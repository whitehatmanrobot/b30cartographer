n pascal */
        }
    atalkcfg_t;

/*
 * ---------------------------------------------------------------------
 *  Engine Configuration
 * ---------------------------------------------------------------------
 */

    /*
     * ---
     *  Engine Configuration Parameters
     * ---
     */
    typedef
        struct engcfg
        {
            unsigned long       timeout;    /* manualfeed timeout */
            unsigned long       leftmargin;
            unsigned long       topmargin;
            unsigned char       pagetype;
        }
    engcfg_t;

/*
 * ---------------------------------------------------------------------
 *  Timeouts Configuration
 * ---------------------------------------------------------------------
 */

    /*
     * ---
     *  Timeouts Configuration Parameters
     * ---
     */
    typedef
        struct toutcfg
        {
            unsigned long       jobtout;
            unsigned long       manualtout;
            unsigned long       waittout;
        }   /* all in millisecond */
    toutcfg_t;

#endif /* !_GEICFG_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\font\ry_font.c ===
// DJC added global include
#include "psglobal.h"

#define    LINT_ARGS            /* @WIN */
#define    NOT_ON_THE_MAC       /* @WIN */
#define    KANJI                /* @WIN */
// DJC use command line #define    UNIX                 /* @WIN */
/*
 * -----------------------------------------------------------------------------
 *  File:   ry_font.c              11/08/89    created by Danny
 *                                 12/01/90    modified by Jerry
 *
 *      Client interface module
 *      Client called by Royal font Module
 *
 *  References:
 *  Revision History:
 *   12/5/90  Danny  Fix the bugs for show char in show (ref. CIRL:)
 *                   fill_cache_cache() calling added (it is in fill_gs.c)
 *   01/30/91 DS     @TT moidfy swap_bitmap() to avoid to copy non-used memory.
 *   03/27/91 Jerry  Modify ry_fill_shape() and cr_FSMemory()
 *   03/27/91 DS     change flag INTEL to LITTLE_ENDIAN
 *   03/29/91 Danny  Fix the bugs for showing the space char (ref: SPC:)
 *   04/23/91 Phlin  Fix the bugs for extra underline of 2 points char and
 *   04/30/91 Phlin  missing char '_' in small point size (ref: 2Pt).
 *   05/10/91 Phlin  Replace rc_GetMetrics_Width by rc_GetAdvanceWidth (ref: GAW)
 *   05/10/91 Phlin  Add do_transform flag used in make_path (ref: DTF)
 * -----------------------------------------------------------------------------
 */


#include <stdio.h>  /* 05/03/91 for SUN */
#include <string.h>

#include        "define.h"
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"

#include        "font.h"
#include        "font.ext"

#include        "warning.h"
#include        "fontqem.ext"

#include        "fontgrap.h"
#include        "fontdict.h"
#include        "fontkey.h"
#include        "fontinfo.def"

/* external function for Dynamic Font Allocation; @DFA 7/9/92 */
#include   "wintt.h"

/* sfnt interface header */
#include        "in_sfnt.h"

/* added for update EMunits;  @DFA @WIN */
#include   "..\bass\FontMath.h"
#include   "..\bass\fnt.h"
#include   "..\bass\sc.h"
#include   "..\bass\FSglue.h"
extern void SetupKey(fsg_SplineKey FAR *, ULONG_PTR);
extern void sfnt_DoOffsetTableMap(fsg_SplineKey FAR *);
extern void FAR *sfnt_GetTablePtr(fsg_SplineKey FAR *, sfnt_tableIndex, boolean);
extern int  EMunits; /* GAW */
extern char FAR *SfntAddr; /*@WIN*/

extern int bWinTT;        /* if using Windows TT fonts; from ti.c;@WINTT */
// extern from wintt.h; @WINTT
void CheckFontData (void);
unsigned long ShowGlyph (unsigned int fuFormat,
     char FAR *lpBitmap);
void ShowOTM (void);
void ShowKerning(void);
void TTLoadFont (int nFont);
void TTLoadChar (int nChar);
int TTAveCharWidth (void);
float TTTransform (float FAR *ctm);

// DJC not used for pstodib
// void TTBitmapSize (struct CharOut FAR *CharOut);

#define  N_BITS_ACCURACY     13  /* 2e-13 == 0.0001 */
#define  EXCESS127(expon)    ((expon) + 127)
#define  N_MANTISSA_BITS     23
#define  NEAR_ZERO(expon, nbit)  ( (expon) <= EXCESS127(-(nbit)) )
#define  DE_EXPONENT(ff)                                    \
                ( (fix16) (  (F2L(ff) & 0x7FFFFFFF)         \
                             >> N_MANTISSA_BITS             \
                          )                                 \
                )
#define FARALLOC(n,type)     /* to allocate far data ... */\
                             (type far *) fardata((ufix32)n * sizeof(type))
#define     PDLDPI           300
#define     CB_MEMSIZE       ((unsigned)64 * 1024)       /* 64 buffer */

/* add prototype; @WIN */
extern void far fill_cache_cache(struct Char_Tbl FAR *,struct Char_Tbl FAR *);
extern fix  rc_InitFonts(int);
extern fix  rc_LoadFont(char FAR *, uint16, uint16);
extern fix  rc_GetAdvanceWidth(int, struct Metrs FAR *);  /* GAW */
extern fix  rc_TransForm(float FAR *);
extern fix  rc_BuildChar(int, struct CharOut FAR *);
extern fix  rc_FillChar(struct BmIn FAR *, BitMap FAR * FAR *);
extern fix  rc_CharPath(void);
extern fix  rc_CharWidth(int, struct CharOut FAR *);
#ifdef  DBG
static void to_bitmap();
#endif

#ifdef LITTLE_ENDIAN
static void swap_bitmap();
#endif

extern struct f_info near FONTInfo;     /* union of current font information */
extern real32  near cxx,  near cyy;     /* current point */
extern real32   near      FONT_BBOX[4]; /* added by CLEO -- font bounding box */
extern int      near      do_transform; /* flag of redoing NewTransformation, DTF */

static ufix32             cb_size;
static byte              FAR *cb_base, FAR *cb_pos; /*@WIN*/
static float              ctm_tx, ctm_ty;
static fix16              ctm_dx, ctm_dy;
static struct CharOut     CharInfo;


/*
 * -----------------------------------------------------------------------------
 * Routine: fontware_init
 *
 * -----------------------------------------------------------------------------
 */
void
fontware_init()
{
    fix     ret_code;

    ret_code = rc_InitFonts(PDLDPI);
    if (ret_code) return;       /* exit(1)=>return; @WIN */

    cb_size = (ufix32)CB_MEMSIZE;

    //DJC cb_base = FARALLOC(cb_size, byte);

    // DJC change to alloc a little extra memory for data we use later...
    // DJC when we split the cache thats left in half. This is required
    // DJC to guarantee DWORD alignment when we split the cache
    cb_base = FARALLOC(cb_size + 10 , byte);

    cb_pos = cb_base;

    return;
} /* fontware_init() */


/*
 * -----------------------------------------------------------------------------
 * Routine: fontware_restart
 *
 * -----------------------------------------------------------------------------
 */
void
fontware_restart()
{
#ifndef SFNT
    struct pld_obj      FAR *private; /*@WIN*/
    gmaddr              FAR *p_base; /*@WIN*/
#endif
    byte                FAR *sfnt; /*@WIN*/
    fix                  ret_code;
    ufix16               platform_id;
    ufix16               specific_id;
    int                 nFontID;        //@WINTT


#ifdef DBG
    printf("Enter fontware_restart\n");
#endif
    cb_pos = cb_base;

#ifdef SFNT
{
        struct object_def  FAR *obj_p ; /*@WIN*/
        obj_p=(struct object_def FAR *)Sfnts(&FONTInfo) ; /*@WIN*/
        sfnt = (byte FAR *)VALUE(obj_p) ; /*@WIN*/
}
#else  /* SFNT */

    p_base = (gmaddr FAR *) PRIvate(&FONTInfo); /*@WIN*/
    private = (struct pld_obj FAR *) (p_base + 1); /*@WIN*/

#ifndef RE_DICT
    sfnt = (byte FAR *)(*((ufix32 FAR *)(&private[0]))); /*@WIN*/
#else    /* RE_DICT */
    sfnt = (byte FAR *)(*((ufix32 FAR *)(*p_base))); /*@WIN*/
#endif   /* RE_DICT */
#endif  /* SFNT */

#ifdef DBG
    printf("sfnt: %lx\n", (ufix32)sfnt);
#endif

    platform_id = (ufix16)PlatID(&FONTInfo) ;
    specific_id = (ufix16)SpecID(&FONTInfo) ;
    ret_code = rc_LoadFont(sfnt, platform_id, specific_id);

//if (bWinTT) {                      // for Win31 truetype; @WINTT
  nFontID = (int)(PRE_fid(&FONTInfo)) - 1024;   // use as font ID
  bWinTT = FALSE;
#ifdef DJC // comment out for fix of MAC chooser problems
  if (nFontID >= 0) {     // for Win31 truetype; @WINTT
    bWinTT = TRUE;
    TTLoadFont(nFontID);
  }
#endif

#ifdef DBGCFONT
    if (ret_code)
        printf("rc_LoadFont error!! PlatformID=%d, SpecificID=%d, sfnt: %lx\n",
                platform_id, specific_id, (ufix32)sfnt);
#endif

    if (ret_code) { ERROR(INVALIDFONT); return; }

    /* update EMunits; moved in from do_setfont();  --- Begin --- @DFA @WIN */
    {
        fsg_SplineKey  KData;
        fsg_SplineKey FAR *key = &KData;
        sfnt_FontHeader FAR *fontHead;

        SfntAddr = (byte FAR *)sfnt;
        SetupKey(key, (ULONG_PTR)sfnt);
        sfnt_DoOffsetTableMap(key);
        fontHead = (sfnt_FontHeader FAR *)sfnt_GetTablePtr(key, sfnt_fontHeader, true );
        EMunits = SWAPW(fontHead->unitsPerEm) ;
    }
    /* update EMunits; moved in from do_setfont();  ---  End  --- @DFA @WIN */

    return;
} /* fontware_restart() */


/*
 * -----------------------------------------------------------------------------
 * Routine: make_path
 *
 * -----------------------------------------------------------------------------
 */
bool
make_path(char_desc)
union char_desc_s FAR *char_desc; /*@WIN*/
{
    ufix          CharCode;
    struct Metrs  Metrs;
    int           GridFit;
    float         largest_ctm;

    /* If font data is not in memory, load and init it; @DFA --- Begin ---*/
    {
        struct object_def          my_obj = {0, 0, 0}, FAR *ary_obj;

        ary_obj = (struct object_def FAR *)Sfnts(&FONTInfo); /*@WIN*/
        if ((byte FAR *)VALUE(ary_obj) == (char FAR *)NULL) {
            struct object_def FAR *obj_uid;
            ufix32      uniqueid;
            char FAR * lpFontData;
            int nSlot;

            /* get uniqueID to locate index of FontDefs[] */
            ATTRIBUTE_SET (&my_obj, LITERAL);
            LEVEL_SET (&my_obj, current_save_level);
            get_name (&my_obj, UniqueID, 8, TRUE);
            get_dict (&current_font, &my_obj, &obj_uid);
            uniqueid = (ufix32)VALUE(obj_uid);
            lpFontData = ReadFontData ((int)uniqueid -TIFONT_UID,
                                       (int FAR*)&nSlot);
            VALUE(&ary_obj[0]) = (ULONG_PTR)lpFontData;
            // if no_block > 1, needs to set other pointers ??? TBD

            /* put font_dict in ActiveFont[] */
            SetFontDataAttr(nSlot, &ary_obj[0]);

            // re-initialize the fontware
            fontware_restart();
        } /* if */
    }
    /* If font data is not in memory, load and init it; @DFA ---  End  ---*/

    CharCode = (ufix)char_desc->charcode;
#ifdef DBG
    printf("Enter make_path: %d\n", CharCode);
#endif

  if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
    // TTLoadChar (CharCode);      move to show_a_char() for temp solution
    //                             since CharCode here is a Glyph index
    largest_ctm = TTTransform(CTM);  // set matrix before getting real advance width
//  Metrs.awx = (int)((float)TTAveCharWidth() / CTM[0]);
    Metrs.awx = (int)((float)TTAveCharWidth() / largest_ctm);
    Metrs.awy = 0;
#endif
      ; // DJC
  } else {
    /* get advancewidth information */
    rc_GetAdvanceWidth(CharCode, &Metrs); /* GAW */
  }

    ctm_dx = (fix16)(ROUND(CTM[4]));
    ctm_dy = (fix16)(ROUND(CTM[5]));

    /* set cachedevice */
    switch (__set_cache_device ((fix)Metrs.awx, (fix)Metrs.awy,
                        (fix)FONT_BBOX[0], (fix)FONT_BBOX[1],
                        (fix)FONT_BBOX[2], (fix)FONT_BBOX[3]))
    {
    case STOP_PATHCONSTRUCT:
        return (FALSE);
    case DO_QEM_AS_USUAL:
        GridFit = TRUE;
        break;
    default:    /* case NOT_TO_DO_QEM : */
        GridFit = FALSE;
        break;
    }

#ifdef DBG
    printf("CTM: %f %f %f %f %f %f\n", CTM[0], CTM[1], CTM[2], CTM[3], CTM[4], CTM[5]);
#endif
    ctm_tx = CTM[4];
    ctm_ty = CTM[5];
    /* DTF */
    if(do_transform) {
       //if (bWinTT) {                      // for Win31 truetype; @WINTT
       // DJC  largest_ctm = TTTransform(CTM);
       // DJC
       // } else {
           //DJC fix from history.log UPD015
           //rc_TransForm(CTM);

           if( rc_TransForm(CTM)) {
              return(FALSE);  //DJC, note return here
           }
           //DJC end fix UPD015
       // }
       do_transform = FALSE;
    }

    /* Not Apply hinting for rotated char */
    if (GridFit &&
        !(( NEAR_ZERO(DE_EXPONENT(CTM[0]), N_BITS_ACCURACY) &&
            NEAR_ZERO(DE_EXPONENT(CTM[3]), N_BITS_ACCURACY) ) ||
          ( NEAR_ZERO(DE_EXPONENT(CTM[1]), N_BITS_ACCURACY) &&
            NEAR_ZERO(DE_EXPONENT(CTM[2]), N_BITS_ACCURACY) ) ) )
        GridFit = FALSE;

    /* build internal char path */
  if (bWinTT) {                      // for Win31 truetype; @WINTT
// DJC    TTBitmapSize (&CharInfo);
   ; // DJC
  } else {
    rc_BuildChar(GridFit, &CharInfo);
  }
    return(TRUE);

} /* make_path() */





// DJC, 2/1/93, complete replace of ry_fill_shape from tumbo UPD009
//
// NOTE:        One thing to watch out for is cb_size getting modified
//              in which case you may up with a situation where its NOT
//              DWORD aligned, this could cause problems to fault on
//              MIPS.... this was fixed once in the original ry_fill_shape
//              but too much stuff changed and we migrated to the new one
//              defined below.
//
/*
 * -----------------------------------------------------------------------------
 * Routine: ry_fill_shape
 *
 * -----------------------------------------------------------------------------
 */
void
ry_fill_shape(filldest)
ufix  filldest;   /* F_TO_CACHE or F_TO_PAGE */
{
    ufix32           cb_size;
    byte            FAR *cb_pos2, FAR *cb_pos3, FAR *sptr, FAR *dptr; /*@WIN*/
    fix              iscan, one_band, n_bands, band_size, ret_code;
    register fix     i, j;
    struct Char_Tbl FAR *save_cache_info, Cache1; /*@WIN*/
    struct BmIn      BmIn;
    struct BitMap   FAR *BmOut; /*@WIN*/

#ifdef DBG
    printf("Enter ry_fill_shape: %d\n", filldest);
    printf("CharInfo.scan = %ld\n", CharInfo.scan);
#endif
/* SPC: Begin, Danny Lu, 3/29/91, Added */
/* 2Pt: Phlin, 4/29/91, Update */
/*  if ((CharInfo.bitWidth == 0) || (CharInfo.scan == 0)) {  */
    if ( CharInfo.bitWidth == 0 ) {
        if (!buildchar) {
              cache_info->bitmap = (gmaddr) 0;
              cache_info->ref_x = 0;
              cache_info->ref_y = 0;
              cache_info->box_w = 0;
              cache_info->box_h = 0;
              bmap_extnt.ximin = -1;
              bmap_extnt.ximax = -1;
              bmap_extnt.yimin = -1;
              bmap_extnt.yimax = -1;
        }
        return;
    }
/* SPC: End, Danny Lu, 3/29/91 */

    save_cache_info = cache_info;
    cb_size = (ufix32)(((ULONG_PTR)cb_base + CB_MEMSIZE) - (ULONG_PTR)(cb_pos));

    if (filldest == F_TO_CACHE) {

          if (buildchar) { /* CIRL */
              Cache1.ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              Cache1.ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
          else {
              bmap_extnt.ximin = 0;
              bmap_extnt.ximax =  CharInfo.bitWidth;
              bmap_extnt.yimin = 0;
/* 2Pt: Begin, Phlin, 4/23/91
 *            bmap_extnt.yimax = CharInfo.scan + 1; */
              bmap_extnt.yimax = CharInfo.scan;
              if (bmap_extnt.yimax)
                  bmap_extnt.yimax--;    /*?????*/
/* 2Pt: End, Phlin, 4/23/91 */

              cache_info->ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              cache_info->ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
    }
    else { /* filldest == F_TO_PAGE */

        lmemcpy ((ubyte FAR *)(&Cache1), (ubyte FAR *)(cache_info), sizeof(struct Char_Tbl)); /*@WIN*/
        cache_info = &Cache1;

        moveto(F2L(ctm_tx), F2L(ctm_ty));

        cache_info->ref_x = (- (int)CharInfo.lsx - 1);  /* add int; @WIN */

        cache_info->ref_y = CharInfo.yMax - 1;
    }

    if ((filldest == F_TO_CACHE) && (!buildchar) ) {

        if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
              /* GetGlyphOutline constants; from "windows.h" */
              #define GGO_METRICS        0
              #define GGO_BITMAP         1
              #define GGO_NATIVE         2
              static nCharCode = 65;
              unsigned long dwWidthHeight;

              dwWidthHeight = TTShowBitmap ((char FAR *)cache_info->bitmap);
              cache_info->box_w = (fix16) (dwWidthHeight >> 16);
              cache_info->box_h = (fix16) (dwWidthHeight & 0x0ffffL);
#endif
        } else {
/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
          cb_size = cb_size / 2;
          cb_pos2 = cb_pos;
          cb_pos3 = cb_pos2 + cb_size;

          BmIn.bitmap5 = (byte FAR *)cache_info->bitmap; /*@WIN*/
          BmIn.bitmap6 = cb_pos2;   /* suppose it is enough */
          BmIn.bitmap7 = cb_pos3;

          BmIn.bottom  = CharInfo.yMin;
          BmIn.top     = CharInfo.yMax;
          ret_code     = rc_FillChar(&BmIn, &BmOut);
          if (ret_code) {  ERROR(INVALIDFONT); return;  }
          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = BmOut->bounds.bottom - BmOut->bounds.top;
#endif
          /* refer to bass\fscaler.c */
          int scans, top;
          char FAR * bitmap;
          /* cb_size = memorySize6 + memorySize7
             where,
             memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
             memorySize7 is fixed, since we band it in y-direction; x-dir is same
             so,
              scan = (cb_size - memorySize7) /
                     ((nYchanges+2) * sizeof(int16) + sizeof(int16 *));
          */
          /* turn off drop out control when memory is not enough */
          if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;

          scans = (int)((cb_size - CharInfo.memorySize7) /
                      ((CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *)));
          top = CharInfo.yMax;
          bitmap = (byte FAR *)cache_info->bitmap;

          BmIn.bitmap6 = cb_pos;
          BmIn.bitmap7 = CharInfo.memorySize7 ?
                         cb_pos + (cb_size - CharInfo.memorySize7) : 0L;
          do {
              BmIn.bitmap5 = bitmap;
              BmIn.top     = top;
              top -= scans;
              BmIn.bottom  = CharInfo.yMin > top ? CharInfo.yMin : top;
              ret_code     = rc_FillChar(&BmIn, &BmOut);

              if (ret_code != 0) {
                 // NTFIX this still needs to get looked at but
                 //       for nowlets just set an error. This is NOT
                 //       critical as only one char in DINGBATS causes this
                 //       (MTSSORTS.TTF
                 //
                 printf("\nWarning... rc_FillChar returns ERROR"); //DJC
                 ERROR(INVALIDFONT);
                 return;
              }
              bitmap += BmOut->rowBytes * scans;
          } while (BmIn.bottom > CharInfo.yMin);

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = CharInfo.yMax - CharInfo.yMin;
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN 7/24/92 */

        }

#ifdef LITTLE_ENDIAN
          sptr=BmOut->baseAddr;
          /* @TT BEGIN move part of buffer which accurately be used
           *     in BASS to cache buffer rather than whole buffer
           *     D.S Tseng 01/30/91
           */
          swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, cache_info->box_h); /*@WIN*/
#endif
#ifdef  DBG
          for (i=0, sptr=BmOut->baseAddr; i<cache_info->box_h;
               i++, sptr+=BmOut->rowBytes, dptr+=(cache_info->box_w/8))
          {
              to_bitmap(sptr, BmOut->rowBytes);
          }
#endif
    }
    else { /* filldest == F_TO_PAGE || ((filldest == F_TO_CACHE) && (buildchar))*/

/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
        cb_size = cb_size / 3;
        cb_size &= 0xfffffffe;       /* 2 bytes alignment */
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + cb_size;
#endif
    {
        /* defined in bass\fscaler.c */
        #ifdef  DEBUGSTAMP
        #define STAMPEXTRA              4
        #else
        #define STAMPEXTRA              0
        #endif
        int scan, width6;
        ufix32 cmb_size;

        /* cb_size = memorySize5 + memorySize6 + memorySize7
           where,
           memorySize5 = (scan * byteWidth) + STAMPEXTRA;
           memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
           memorySize7 is fixed, since we band it in y-direction; x-dir is same
           so,
            scan = (cb_size - memorySize7 - STAMPEXTRA) /
                    (byteWidth + ( (nYchanges+2) * sizeof(int16) + sizeof(int16 *)));
        */
        /* turn off drop out control when memory is not enough */
        if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;
        width6 = (CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *);
        scan = (int)((cb_size - CharInfo.memorySize7 - STAMPEXTRA) /
               (CharInfo.byteWidth + width6));
        if(scan ==0) {
                printf("Fatal error, scan==0\n");
                scan++;
        }

        cb_size = (scan * CharInfo.byteWidth) + STAMPEXTRA;
        cmb_space(&cmb_size);
        if(cb_size > cmb_size) cb_size = cmb_size;
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + (scan * width6);

        BmIn.bitmap5 = cb_pos;
        BmIn.bitmap6 = cb_pos2;
        BmIn.bitmap7 = CharInfo.memorySize7 ? cb_pos3 : 0L;
    }
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN */

        band_size = (fix) (cb_size / CharInfo.byteWidth);       //@WIN
        n_bands   = CharInfo.scan / band_size;
        one_band  = CharInfo.scan % band_size;

        dptr = (byte FAR *)cache_info->bitmap; /*@WIN*/
        if (n_bands) {   /* Char too large; must band into pagemap/bitmap */
            for (iscan=CharInfo.yMax;n_bands>0; iscan -= band_size, n_bands--) {
                BmIn.bottom  = iscan - band_size;
                BmIn.top     = iscan;
                ret_code     = rc_FillChar(&BmIn, &BmOut);
                if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                    sptr=BmOut->baseAddr;
                    /* @TT BEGIN move part of buffer which accurately be used
                     *     in BASS to cache buffer rather than whole buffer
                     *     D.S Tseng 01/30/91
                     */
                    swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, band_size); /*@WIN*/
#endif
                if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                    Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                    Cache1.box_h = (fix16)band_size;

                    fill_cache_cache(cache_info, &Cache1);
                    Cache1.ref_y -= (fix16)band_size;
                }
                else {  /* F_TO_PAGE  (fill to page frame) */

                    if (BmOut->rowBytes % 2) {
                        /* padding bitmap */
                        for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;i<band_size;
                             i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                        {
                            for (j=0; j<BmOut->rowBytes; j++)
                                dptr[j] = sptr[j];
                            dptr[j] = 0;
#ifdef  DBG
                            to_bitmap(sptr, BmOut->rowBytes);
#endif
                        } /* for (i... */
                        cache_info->box_w = BmOut->rowBytes * 8 + 8;
                        cache_info->bitmap = (gmaddr)cb_pos;
                    }
                    else {
                        cache_info->box_w = BmOut->rowBytes * 8;
                        cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    }
                    cache_info->box_h = (fix16)band_size;
                    /* apply bitmap filling */
                    fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                    cache_info->ref_y -= (fix16)band_size;
                }
            } /* for (iscan... */
        }
        if (one_band) {
            BmIn.bottom  = CharInfo.yMin;
            BmIn.top     = CharInfo.yMin + one_band;
            ret_code     = rc_FillChar(&BmIn, &BmOut);
            if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                sptr=BmOut->baseAddr;
                /* @TT BEGIN move part of buffer which accurately be used
                 *     in BASS to cache buffer rather than whole buffer
                 *     D.S Tseng 01/30/91
                 */
                swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, one_band); /*@WIN*/
#endif
            if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                Cache1.box_h = (fix16)one_band;

                fill_cache_cache(cache_info, &Cache1);
            }
            else {  /* F_TO_PAGE  (fill to page frame) */

                if (BmOut->rowBytes % 2) {
                    /* padding bitmap */
                    for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;
                         i<one_band;
                         i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                    {
                        for (j=0; j<BmOut->rowBytes; j++)
                            dptr[j] = sptr[j];
                        dptr[j] = 0;
#ifdef  DBG
                        to_bitmap(sptr, BmOut->rowBytes);
#endif
                    } /* for (i... */
                    cache_info->box_w = BmOut->rowBytes * 8 + 8;
                    cache_info->bitmap = (gmaddr)cb_pos;
                }
                else {
                    cache_info->box_w = BmOut->rowBytes * 8;
                    cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                }
                cache_info->box_h = (fix16)one_band;
                /* apply bitmap filling */
                fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
            }
        }
    }
    if (buildchar && (filldest == F_TO_CACHE) ) { /* CIRL */
        CURPOINT_X += cache_info->adv_x;
        CURPOINT_Y += cache_info->adv_y;
    }
    cache_info = save_cache_info;
#ifdef  DBG
    printf("Exit ry_fill_shape()....\n");
#endif
    return;
} /* ry_fill_shape() */



/*
 * -----------------------------------------------------------------------------
 * Routine: cr_FSMemory
 *
 * -----------------------------------------------------------------------------
 */
char FAR * /*@WIN_BASS*/
cr_FSMemory(size)
long    size;
{
    return((char FAR *)(((ULONG_PTR)FARALLOC(size, char) + 3) / 4 * 4));
} /* cr_FSMemory() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_GetMemory
 *
 * -----------------------------------------------------------------------------
 */
char FAR * /*@WIN_BASS*/
cr_GetMemory(size)
long    size;
{
    char FAR *p; /*@WIN*/
#ifdef DBG
    printf("Enter cr_GetMemory: %ld size\n", size);
#endif

    p = cb_pos;
    cb_pos += (size + 3) / 4 * 4;

    return(p);
} /* cr_GetMemory() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_translate
 *
 * -----------------------------------------------------------------------------
 */
void
cr_translate(tx, ty)
float    FAR *tx, FAR *ty; /*@WIN*/
{
    *tx = ctm_tx;
    *ty = ctm_ty;

    return;
} /* cr_translate() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_newpath
 *
 * -----------------------------------------------------------------------------
 */
void
cr_newpath()
{
#ifdef DBG
    printf("newpath\n");
#endif
    op_newpath();

    return;
} /* cr_newpath() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_moveto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_moveto(float x, float y)     /*@WIN*/
{
    real32  xx, yy;
#ifdef DBG
    printf("%f %f moveto\n", x, y);
#endif

    xx = x;
    yy = y;
    moveto(F2L(xx), F2L(yy));

    return;
} /* cr_moveto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_lineto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_lineto(float x, float y)     /*@WIN*/
{
    real32  xx, yy;
#ifdef DBG
    printf("%f %f lineto\n", x, y);
#endif

    xx = x;
    yy = y;
    lineto(F2L(xx), F2L(yy));

    return;
} /* cr_lineto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_curveto
 *
 * -----------------------------------------------------------------------------
 */
void
cr_curveto(float x1, float y1, float x2, float y2, float x3, float y3) /*@WIN*/
{
    real32  xx1, yy1, xx2, yy2, xx3, yy3;
#ifdef DBG
    printf("%f %f %f %f %f %f curveto\n", x1, y1, x2, y2, x3, y3);
#endif

    xx1 = x1;
    yy1 = y1;
    xx2 = x2;
    yy2 = y2;
    xx3 = x3;
    yy3 = y3;
    curveto(F2L(xx1), F2L(yy1), F2L(xx2), F2L(yy2), F2L(xx3), F2L(yy3));

    return;
} /* cr_curveto() */


/*
 * -----------------------------------------------------------------------------
 * Routine: cr_closepath
 *
 * -----------------------------------------------------------------------------
 */
void
cr_closepath()
{
#ifdef DBG
    printf("closepath\n");
#endif
    op_closepath();

    return;
} /* cr_closepath() */


#ifdef  DBG
/*
 * -----------------------------------------------------------------------------
 * Routine: to_bitmap
 *
 * -----------------------------------------------------------------------------
 */
static void
to_bitmap(p_row, p_len)
byte    FAR p_row[]; /*@WIN*/
fix     p_len;
{
    fix         l_i, l_k;
    ufix16      FAR *l_value; /*@WIN*/
    byte        FAR *l_ptr; /*@WIN*/

    for(l_k=0; l_k < p_len; l_k += 2) {
        l_value = (ufix16 FAR *)(&p_row[l_k]); /*@WIN*/
        for(l_i=0; l_i < 16; l_i++) {
            /* high bit order first */
            if( (*l_value >> (15-l_i)) & 0x01 )
                printf("#");
            else
                printf(".");
        }
    }
    printf("    ");

    l_ptr = p_row;
    for(l_i=0; l_i < p_len; l_ptr++, l_i++)
        printf(" %2x", (ufix16)*l_ptr);
    printf("\n");

    return;
}   /* to_bitmap */
#endif  /* DBG */

#ifdef LITTLE_ENDIAN
/* @TT BEGIN move part of buffer which accurately be used
 *     in BASS to cache buffer rather than whole buffer
 *     D.S Tseng 01/30/91 */
#ifndef LBODR /* #ifdef HB32 */
void swap_bitmap(mapbase, rowbytes,band_size)
ufix16 FAR *mapbase; /*@WIN*/
fix    rowbytes;
fix    band_size;
{
fix    i, row;
ufix16 tmp1;
ufix16 tmp2;
    for (i=0; i<band_size; i++) {
        row = rowbytes;
        for (;row > 3; row -=4) {
            tmp1 = *mapbase;
            tmp2 = *(mapbase+1);
            *mapbase++ = tmp2;
            *mapbase++ = tmp1;
        }
    }
    return;
}
/* @TT END 01/31/91 D.S.Tseng */
#else /* #ifdef LBODR */
void swap_bitmap(mapbase, rowbytes,band_size)
ubyte FAR *mapbase; /*@WIN*/
fix    rowbytes;
fix    band_size;
{
fix    i, j, row;
ufix32 h_val, l_val;
ufix32 tmp1, is_one, is_one_h, is_one_l;
    for (i=0; i<band_size; i++) {
        row = rowbytes;
        for (;row > 3; row -=4) {
            tmp1 = *(ufix32 FAR *)mapbase; /*@WIN*/
            h_val = (1<<31);
            l_val = 1;
            for (j = 15; j >= 0; j--) {
                is_one_h = tmp1 & h_val ? 1 : 0;
                is_one_l = tmp1 & l_val ? 1 : 0;
                if (is_one_h != is_one_l) {
                /* if ((is_one = (tmp1 & h_val)) != (tmp1 & l_val)) { */
                    if (is_one_h) {  /* j+16th bit == 1 */
                    /* if (is_one) { */  /* j+16th bit == 1 */
                        tmp1 -= h_val;
                        tmp1 += l_val;
                    } else {               /* 15-jth bit == 1 */
                        tmp1 -= l_val;
                        tmp1 += h_val;
                    }
                }
                h_val = h_val >> 1;
                l_val = l_val << 1;
            }
            *(ufix32 FAR *)mapbase = tmp1; /*@WIN*/
            mapbase += 4;
        }
    }
    return;
}
#endif
#endif


#ifdef DJC  //Complete replace of ry_fill_shape from current code
/*
 * -----------------------------------------------------------------------------
 * Routine: ry_fill_shape
 *
 * -----------------------------------------------------------------------------
 */
void
ry_fill_shape(filldest)
ufix  filldest;   /* F_TO_CACHE or F_TO_PAGE */
{
    ufix32           cb_size;
    byte            FAR *cb_pos2, FAR *cb_pos3, FAR *sptr, FAR *dptr; /*@WIN*/
    fix              iscan, one_band, n_bands, band_size, ret_code;
    register fix     i, j;
    struct Char_Tbl FAR *save_cache_info, Cache1; /*@WIN*/
    struct BmIn      BmIn;
    struct BitMap   FAR *BmOut; /*@WIN*/

#ifdef DBG
    printf("Enter ry_fill_shape: %d\n", filldest);
    printf("CharInfo.scan = %ld\n", CharInfo.scan);
#endif
/* SPC: Begin, Danny Lu, 3/29/91, Added */
/* 2Pt: Phlin, 4/29/91, Update */
/*  if ((CharInfo.bitWidth == 0) || (CharInfo.scan == 0)) {  */
    if ( CharInfo.bitWidth == 0 ) {
        if (!buildchar) {
              cache_info->bitmap = (gmaddr)NULL;
              cache_info->ref_x = 0;
              cache_info->ref_y = 0;
              cache_info->box_w = 0;
              cache_info->box_h = 0;
              bmap_extnt.ximin = -1;
              bmap_extnt.ximax = -1;
              bmap_extnt.yimin = -1;
              bmap_extnt.yimax = -1;
        }
        return;
    }
/* SPC: End, Danny Lu, 3/29/91 */

    save_cache_info = cache_info;
    cb_size = (ufix32)(cb_base + CB_MEMSIZE) - (ufix32)(cb_pos);

    if (filldest == F_TO_CACHE) {

          if (buildchar) { /* CIRL */
              Cache1.ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              Cache1.ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
          else {
              bmap_extnt.ximin = 0;
              bmap_extnt.ximax =  CharInfo.bitWidth;
              bmap_extnt.yimin = 0;
/* 2Pt: Begin, Phlin, 4/23/91
 *            bmap_extnt.yimax = CharInfo.scan + 1; */
              bmap_extnt.yimax = CharInfo.scan;
              if (bmap_extnt.yimax)
                  bmap_extnt.yimax--;    /*?????*/
/* 2Pt: End, Phlin, 4/23/91 */

              cache_info->ref_x = - (int)CharInfo.lsx - 1 - ctm_dx; /* add int; @WIN */
              cache_info->ref_y = CharInfo.yMax - 1 - ctm_dy;
          }
    }
    else { /* filldest == F_TO_PAGE */

        lmemcpy ((ubyte FAR *)(&Cache1), (ubyte FAR *)(cache_info), sizeof(struct Char_Tbl)); /*@WIN*/
        cache_info = &Cache1;

        moveto(F2L(ctm_tx), F2L(ctm_ty));

        cache_info->ref_x = (- (int)CharInfo.lsx - 1);  /* add int; @WIN */

        cache_info->ref_y = CharInfo.yMax - 1;
    }

    if ((filldest == F_TO_CACHE) && (!buildchar) ) {
#ifdef DJC //correction from history.log
          cb_size = cb_size / 2;

          //DJC add the alignment here so the middle is DWORD aligned as well
          //DJC
          cb_size = WORD_ALIGN(cb_size);


          cb_pos2 = cb_pos;
          cb_pos3 = cb_pos2 + cb_size;

        if (bWinTT) {                      // for Win31 truetype; @WINTT
#ifdef DJC
              /* GetGlyphOutline constants; from "windows.h" */
              #define GGO_METRICS        0
              #define GGO_BITMAP         1
              #define GGO_NATIVE         2
              static nCharCode = 65;
              unsigned long dwWidthHeight;

              dwWidthHeight = ShowGlyph (GGO_BITMAP,
                                         (char FAR *)cache_info->bitmap);
              cache_info->box_w = (fix16) (dwWidthHeight >> 16);
              cache_info->box_h = (fix16) (dwWidthHeight & 0x0ffffL);
#endif
              ; // DJC
        } else {
          BmIn.bitmap5 = (byte FAR *)cache_info->bitmap; /*@WIN*/
          BmIn.bitmap6 = cb_pos2;   /* suppose it is enough */
          BmIn.bitmap7 = cb_pos3;

          BmIn.bottom  = CharInfo.yMin;
          BmIn.top     = CharInfo.yMax;
          ret_code     = rc_FillChar(&BmIn, &BmOut);
          if (ret_code) {  ERROR(INVALIDFONT); return;  }

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = BmOut->bounds.bottom - BmOut->bounds.top;
        }
#endif

//DJC from history.log, UPD009

          /* refer to bass\fscaler.c */
          int scans, top;
          char FAR * bitmap;
          /* cb_size = memorySize6 + memorySize7
             where,
             memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 FAR *));
             memorySize7 is fixed, since we band it in y-direction; x-dir is same
             so,
              scan = (cb_size - memorySize7) /
                     ((nYchanges+2) * sizeof(int16) + sizeof(int16 *));
          */
          /* turn off drop out control when memory is not enough */
          if (CharInfo.memorySize7 > (fix32)(cb_size -4096)) CharInfo.memorySize7 = 0;

          scans = (int)((cb_size - CharInfo.memorySize7) /
                      ((CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *)));
          top = CharInfo.yMax;
          bitmap = (byte FAR *)cache_info->bitmap;

          BmIn.bitmap6 = cb_pos;
          BmIn.bitmap7 = CharInfo.memorySize7 ?
                         cb_pos + (cb_size - CharInfo.memorySize7) : 0L;
          do {
              BmIn.bitmap5 = bitmap;
              BmIn.top     = top;
              top -= scans;
              BmIn.bottom  = CharInfo.yMin > top ? CharInfo.yMin : top;
              ret_code     = rc_FillChar(&BmIn, &BmOut);
              if (ret_code != 0) {
#ifdef WRN_PSTODIB
                 printf("\nrc_FillChar returns error!!");
#endif
                 ERROR(INVALIDFONT);
                 return;
              }
              bitmap += BmOut->rowBytes * scans;
          } while (BmIn.bottom > CharInfo.yMin);

          cache_info->box_w = BmOut->rowBytes * 8;
          cache_info->box_h = CharInfo.yMax - CharInfo.yMin;
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN 7/24/92 */

        }


//DJC, end UPD009


#ifdef LITTLE_ENDIAN
          sptr=BmOut->baseAddr;
          /* @TT BEGIN move part of buffer which accurately be used
           *     in BASS to cache buffer rather than whole buffer
           *     D.S Tseng 01/30/91
           */
          swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, cache_info->box_h); /*@WIN*/
#endif
#ifdef  DBG
          for (i=0, sptr=BmOut->baseAddr; i<cache_info->box_h;
               i++, sptr+=BmOut->rowBytes, dptr+=(cache_info->box_w/8))
          {
              to_bitmap(sptr, BmOut->rowBytes);
          }
#endif
    }
    else { /* filldest == F_TO_PAGE || ((filldest == F_TO_CACHE) && (buildchar))*/

/* calculate memoryBase 5, 6 and 7 correctly; ----- Begin --- @WIN 7/24/92 */
#if 0
        cb_size = cb_size / 3;
        cb_size &= 0xfffffffe;       /* 2 bytes alignment */
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + cb_size;
#endif
    {
        /* defined in bass\fscaler.c */
        #ifdef  DEBUGSTAMP
        #define STAMPEXTRA              4
        #else
        #define STAMPEXTRA              0
        #endif
        int scan, width6;
        ufix32 cmb_size;

        /* cb_size = memorySize5 + memorySize6 + memorySize7
           where,
           memorySize5 = (scan * byteWidth) + STAMPEXTRA;
           memorySize6 = scan * ((nYchanges + 2) * sizeof(int16) + sizeof(int16 *));
           memorySize7 is fixed;
           so,
            scan = (cb_size - memorySize7 - STAMPEXTRA) /
                    (byteWidth + ( (nYchanges+2) * sizeof(int16) + sizeof(int16 *)));
        */
        width6 = (CharInfo.nYchanges+2) * sizeof(int16) + sizeof(int16 FAR *);
        scan = (int)((cb_size - CharInfo.memorySize7 - STAMPEXTRA) /
               (CharInfo.byteWidth + width6));
        if(scan ==0) {
                printf("Fatal error, scan==0\n");
                scan++;
        }

        cb_size = (scan * CharInfo.byteWidth) + STAMPEXTRA;
        cmb_space(&cmb_size);
        if(cb_size > cmb_size) cb_size = cmb_size;
        cb_pos2 = cb_pos  + cb_size;
        cb_pos3 = cb_pos2 + (scan * width6);

        BmIn.bitmap5 = cb_pos;
        BmIn.bitmap6 = cb_pos2;
        BmIn.bitmap7 = cb_pos3;
    }
/* calculate memoryBase 5, 6 and 7 correctly; ----- End --- @WIN */

        band_size = (fix) (cb_size / CharInfo.byteWidth);       //@WIN
        n_bands   = CharInfo.scan / band_size;
        one_band  = CharInfo.scan % band_size;

        dptr = (byte FAR *)cache_info->bitmap; /*@WIN*/
        if (n_bands) {   /* Char too large; must band into pagemap/bitmap */
            for (iscan=CharInfo.yMax;n_bands>0; iscan -= band_size, n_bands--) {
                BmIn.bottom  = iscan - band_size;
                BmIn.top     = iscan;
                ret_code     = rc_FillChar(&BmIn, &BmOut);
                if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                    sptr=BmOut->baseAddr;
                    /* @TT BEGIN move part of buffer which accurately be used
                     *     in BASS to cache buffer rather than whole buffer
                     *     D.S Tseng 01/30/91
                     */
                    swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, band_size); /*@WIN*/
#endif
                if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                    Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                    Cache1.box_h = band_size;

                    fill_cache_cache(cache_info, &Cache1);
                    Cache1.ref_y -= band_size;
                }
                else {  /* F_TO_PAGE  (fill to page frame) */

                    if (BmOut->rowBytes % 2) {
                        /* padding bitmap */
                        for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;i<band_size;
                             i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                        {
                            for (j=0; j<BmOut->rowBytes; j++)
                                dptr[j] = sptr[j];
                            dptr[j] = 0;
#ifdef  DBG
                            to_bitmap(sptr, BmOut->rowBytes);
#endif
                        } /* for (i... */
                        cache_info->box_w = BmOut->rowBytes * 8 + 8;
                        cache_info->bitmap = (gmaddr)cb_pos;
                    }
                    else {
                        cache_info->box_w = BmOut->rowBytes * 8;
                        cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                    }
                    cache_info->box_h = band_size;
                    /* apply bitmap filling */
                    fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
                    cache_info->ref_y -= band_size;
                }
            } /* for (iscan... */
        }
        if (one_band) {
            BmIn.bottom  = CharInfo.yMin;
            BmIn.top     = CharInfo.yMin + one_band;
            ret_code     = rc_FillChar(&BmIn, &BmOut);
            if (ret_code) {  ERROR(INVALIDFONT); return;  }
#ifdef LITTLE_ENDIAN
                sptr=BmOut->baseAddr;
                /* @TT BEGIN move part of buffer which accurately be used
                 *     in BASS to cache buffer rather than whole buffer
                 *     D.S Tseng 01/30/91
                 */
                swap_bitmap((ufix16 FAR *)sptr, BmOut->rowBytes, one_band); /*@WIN*/
#endif
            if (filldest == F_TO_CACHE) { /* buildchar CIRL */

                Cache1.bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                Cache1.box_w = (fix16)BmOut->rowBytes * 8;
                Cache1.box_h = one_band;

                fill_cache_cache(cache_info, &Cache1);
            }
            else {  /* F_TO_PAGE  (fill to page frame) */

                if (BmOut->rowBytes % 2) {
                    /* padding bitmap */
                    for (i=0, sptr=BmOut->baseAddr, dptr=cb_pos;
                         i<one_band;
                         i++, sptr+=BmOut->rowBytes, dptr+=(BmOut->rowBytes + 1))
                    {
                        for (j=0; j<BmOut->rowBytes; j++)
                            dptr[j] = sptr[j];
                        dptr[j] = 0;
#ifdef  DBG
                        to_bitmap(sptr, BmOut->rowBytes);
#endif
                    } /* for (i... */
                    cache_info->box_w = BmOut->rowBytes * 8 + 8;
                    cache_info->bitmap = (gmaddr)cb_pos;
                }
                else {
                    cache_info->box_w = BmOut->rowBytes * 8;
                    cache_info->bitmap = (gmaddr)((char FAR *)BmOut->baseAddr);/*@WIN*/
                }
                cache_info->box_h = one_band;
                /* apply bitmap filling */
                fill_shape(EVEN_ODD, F_FROM_CACHE, F_TO_CLIP);
            }
        }
    }
    if (buildchar && (filldest == F_TO_CACHE) ) { /* CIRL */
        CURPOINT_X += cache_info->adv_x;
        CURPOINT_Y += cache_info->adv_y;
    }
    cache_info = save_cache_info;
#ifdef  DBG
    printf("Exit ry_fill_shape()....\n");
#endif
    return;
} /* ry_fill_shape() */
#endif //DJC end complete replace



/* --------------------- End of ry_font.c ---------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geierr.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIerr.h
 *
 *  HISTORY:
 *  09/13/90    byou        created.
 *  01/07/91    billlwo     rename GEIseterror to GESseterror
 * ---------------------------------------------------------------------
 */

#ifndef _GEIERR_H_
#define _GEIERR_H_

#ifdef  UNIX
#define volatile
#endif  /* UNIX */
/*
 * ---
 *  Error Code List
 * ---
 */
#define     EZERO            0
#define     EPERM            1
#define     ENOENT           2
#define     ESRCH            3
#define     EINTR            4
#define     EIO              5
#define     ENXIO            6
#define     E2BIG            7
#define     ENOEXEC          8
#define     EBADF            9
#define     ECHILD          10
#define     EAGAIN          11
#define     ENOMEM          12
#define     EACCES          13
#define     EFAULT          14
#define     ENOTBLK         15
#define     EBUSY           16
#define     EEXIST          17
#define     EXDEV           18
#define     ENODEV          19
#define     ENOTDIR         20
#define     EISDIR          21
#define     EINVAL          22
#define     ENFILE          23
#define     EMFILE          24
#define     ENOTTY          25
#define     ETXTBSY         26
#define     EFBIG           27
#define     ENOSPC          28
#define     ESPIPE          29
#define     EROFS           30
#define     EMLINK          31
#define     EPIPE           32
#define     EDOM            33
#define     ERANGE          34
#define     EUCLEAN         35
#define     EDEADLOCK       36
#define     ENAMETOOLONG    63
#define     ETIME           73
#define     ENOSR           74
#define     ENOSYS          90

/*
 * ---
 *  Interface Routines
 * ---
 */
volatile    extern int      GEIerrno;

#define     GEIerror()      ( GEIerrno )
#define     GESseterror(e)  ( GEIerrno = (e) )
#define     GEIclearerr()   (void)( GEIerrno = EZERO )

#endif /* !_GEIERR_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geiio.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIio.c
 *
 *  COMPILATION SWITCHES:
 *      FILESYS     - to invoke file system, if defined.
 *
 *  HISTORY:
 *  09/15/90    Erik Chen   created.
 *  10/18/90    byou        removed all about block devices.
 *  10/22/90    byou        revised a lot.
 *                          added code for GESevent.
 *                          removed 'selectstdios' into 'gesiocfg.c'.
 *  01/07/91    billlwo     rename GEIseterror to GESseterror
 *                          update GESio_closeall() to close from
 *                          FileTableBeg.
 * 01/24/91     billlwo     fixed selectstdios() bug in auto polling
 *                          update GESio_closeall() to close from
 *                          FileTable. because GEIio_stderr not close by TI
 * 02/23/91     billlwo     Fixed bug in EOF processing in GES-GEI interface
 * 09/10/91     Falco       revise the status string in the GEIio_init to
 *                          make sure to get the correct string.
 * 09/10/91     Falco       To verify the ic_startup is already or not, only
 *                          initialization is ready, then can get the actual
 *                          status.
 * ---------------------------------------------------------------------
 */

// DJC added global include file
#include "psglobal.h"

#ifdef MTK
extern void    pdl_process(),pdl_no_process();
#endif  /* MTK */

#include        <string.h>

#include        "global.ext"
#include        "gescfg.h"
#include        "geiio.h"
#include        "geierr.h"
#include        "geiioctl.h"
#include        "geisig.h"
#include        "geitmr.h"
#include        "gesmem.h"
#include        "gesdev.h"
#ifndef UNIX
#include        "gesevent.h"
#endif  /* UNIX */
#include        "gesfs.h"               /* @WIN */

// DJC DJC int             GEIerrno = EZERO;
volatile int             GEIerrno = EZERO;

#define         MAXSTDIOS       ( 3 )
GEIFILE FAR *            GEIio_stdin;
GEIFILE FAR *            GEIio_stdout;
GEIFILE FAR *            GEIio_stderr;

#define         NULLFILE        ( (GEIFILE FAR *)NULL )

static GEIFILE FAR *     FileTable    = NULLFILE;
static GEIFILE FAR *     FileTableBeg = NULLFILE;    /* excluding stdios */
static GEIFILE FAR *     FileTableEnd = NULLFILE;

static GEIFILE      FileInitVals =
                    {
                       _S_IFNON,            /* f_type */
                       _F_ERR,              /* f_flag */
                       EOF,                 /* f_handle */
                       (GEIfbuf_t FAR *)NULL,    /* f_fbuf */
                       (GEIfmodq_t FAR *)NULL,   /* f_modq */
                       0,                   /* f_opentag */
                       0                    /* f_savelevel */
                    };
/* make fin a global data  --  01/24/91 bill*/
GEIFILE FAR *            fin  = NULLFILE;
/***/
extern  char    job_name[], job_state[], job_source[];
/* erik chen, 3-1-1991 */
int             local_flag=TRUE;
extern char     TI_state_flag;
extern short int startup_flag;
extern void     change_status(void);
extern void     GEP_restart(void);
/* erik chen, 3-1-1991 */

/* @WIN; add prototype */
static int io_dup(GEIFILE FAR *, GEIFILE FAR *);
static int fbuf_init(GEIfbuf_t FAR * FAR *, unsigned char FAR *, int);
static int outsync(unsigned short, short, unsigned char FAR *, int);

/*
 * ---------------------------------------------------------------------
 *      GEI Status Update and Query
 * ---------------------------------------------------------------------
 */

char                statusbuf[ MAXSTATUSLEN ];
int                 statuslen = 0;

/* ...................................... */

/*void        GEIio_updatestatus( name, state, source, flag )
    char      *name, *state, *source, flag;
    char      flag;
{
   job_name=name;
   job_state=state;
   job_source=source;
   TI_state_flag=flag;
} */

/* ...................................... */

void        GESio_obtainstatus( statusaddr, len )
    char FAR *        FAR *statusaddr;
    int          FAR *len;
{
    unsigned short int l_len;
    struct object_def    FAR *l_tmpobj;

/* add by Falco to initial value, 09/06/91 */
    statusbuf[0]='%';
    statusbuf[1]='%';
    statusbuf[2]='[';
    statusbuf[3]=' ';
    statusbuf[4]='\0';

    if (startup_flag){
        if (job_name[0] != '\0') {
            lstrcat(statusbuf, "name: ");       /*@WIN*/
            lstrcat(statusbuf, job_name);       /*@WIN*/
        }

        get_dict_value("statusdict", "jobstate", &l_tmpobj);
        l_len = LENGTH(l_tmpobj);
        if (lstrcmp(job_state, (char  FAR *)VALUE(l_tmpobj))) {  /*@WIN*/
            lstrcpy(job_state, (char  FAR *)VALUE(l_tmpobj)) ;   /*@WIN*/
            job_state[l_len] = ';' ;
            job_state[l_len + 1] = ' ' ;
            job_state[l_len + 2] = '\0' ;
            change_status();
        }

        lstrcat(statusbuf, "status: ");         /*@WIN*/
        lstrcat(statusbuf, job_state);          /*@WIN*/

        if (lstrcmp(job_state, "idle\0") && strcmp(job_state, "start page\0")) {
            lstrcat(statusbuf, "source: ");     /*@WIN*/
            lstrcat(statusbuf, job_source);     /*@WIN*/
        }
    }

    statuslen = lstrlen(statusbuf)-4;   /*@WIN*/
    lstrcat(statusbuf," ]%%\n\r");      /*@WIN*/

    *statusaddr = statusbuf+4;
    *len = statuslen;
}

/* ...................................... */


/*
 * ---------------------------------------------------------------------
 *      GEIio find first and next open
 * ---------------------------------------------------------------------
 */

static      GEIFILE FAR *        currf = NULLFILE;

/* ...................................... */

GEIFILE FAR *     GEIio_firstopen()
{

    for( currf=FileTable; currf<FileTableEnd; currf++ )
        if( currf->f_handle != EOF )
            return( currf );

    return( NULLFILE );
}

/* ...................................... */

GEIFILE FAR *    GEIio_nextopen()
{
    while( ++currf < FileTableEnd )
        if( currf->f_handle != EOF )
            return( currf );

    return( NULLFILE );
}

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GESio Internal Functions
 * ---------------------------------------------------------------------
 */

static
int         io_dup( newf, oldf )
    register GEIFILE FAR *   newf;
    register GEIFILE FAR *   oldf;
{
    int                 oldopentag;
    GEIfmodq_t FAR *         mq;
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    /* copy all of old into new (exclude fmodq and opentag) */
    oldopentag = newf->f_opentag;
    *newf      = *oldf;
    newf->f_modq    = (GEIfmodq_t FAR *)NULL;
    newf->f_opentag = oldopentag;

    /* open the device driver again */
    switch( newf->f_type )
    {
    case _S_IFEDIT:     /* to be removed in the future!!! */
        break;
    case _S_IFCHR:
        if( CDEV_OPEN( newf->f_handle ) == EOF )
            return( EOF );
        break;
#ifdef FILESYS
    case _S_IFREG:
        break;
#endif
    default:
        GESseterror( EBADF );
        return( EOF );
    }

    newf->f_fbuf->f_refcnt ++;
    newf->f_opentag ++;

    if( oldf->f_modq != (GEIfmodq_t FAR *)NULL )
    {
        GEIfmod_t FAR *              fmods[ MAXFMODQS ];
        int                     nfmods;

        nfmods = 0;
        for( mq=oldf->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
            fmods[ nfmods++ ] = mq->fmod;

        while( --nfmods >= 0 )      /* push from bottom to top */
        {
//          if( GEIio_ioctl( newf, _I_PUSH, (char FAR *)fmods[ nfmods ] ) == EOF )
            if( GEIio_ioctl( newf, _I_PUSH, (int FAR *)fmods[ nfmods ] ) == EOF ) /*@WIN*/
                goto dup_err;

#         ifdef PANEL
            if( GESevent_isset( EVIDofKILL ) )
            {
                GESseterror( EINTR );
                goto dup_err;
            }
#         endif
        }
    }
    return( 0 );

  dup_err:
    for( mq=newf->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
        FMODQ_CLOSE( newf, mq );
    newf->f_fbuf->f_refcnt --;
    if( newf->f_type == _S_IFCHR )
        CDEV_CLOSE( newf->f_handle );

    *newf = FileInitVals;
    newf->f_opentag = oldopentag;
    return( EOF );

}   /* io_dup */

/* ...................................... */

static
int         outsync( ftype, handle, buf, len )
    unsigned short  ftype;
    short           handle;
    unsigned char FAR *  buf;
    int             len;
{
    switch( ftype )
    {
    case _S_IFCHR:
        return( CDEV_WRITE( handle, buf, len, _O_SYNC ) );
#ifdef FILESYS
    case _S_IFREG:
        {
            int     oldflag, tmpflag;

            if( GESfs_ioctl( handle, _F_GETFL, &oldflag ) == EOF )
                return( EOF );

            tmpflag = oldflag;
            if( !(oldflag & _O_SYNC) )
            {
                tmpflag |= _O_SYNC;
                if( GESfs_ioctl( handle, _F_SETFL, &tmpflag ) == EOF )
                    return( EOF );
            }

            if( GESfs_write( handle, buf, len ) == EOF )
                return( EOF );

            if( !(oldflag & _O_SYNC) )
                return( GESfs_ioctl( handle, _F_SETFL, &oldflag ) );

            return( 0 );
        }
#endif /* FILESYS */
    }

    return( 0 );
}

/* ...................................... */

static
int         fbuf_init( fbufap, buf, len )
    register GEIfbuf_t FAR *  FAR *fbufap;
    unsigned char FAR *      buf;
    int                 len;
{
    register GEIfbuf_t FAR * fbufp;

    if( buf != (unsigned char FAR *)NULL )
    {
        if( (fbufp = (GEIfbuf_t FAR *)GESmalloc( sizeof(GEIfbuf_t) ))
                == (GEIfbuf_t FAR *)NULL )
            return( EOF );

        fbufp->f_base = buf;
    }
    else
    {
        if( (fbufp = (GEIfbuf_t FAR *)GESmalloc( sizeof(GEIfbuf_t) + len ))
                == (GEIfbuf_t FAR *)NULL )
            return( EOF );

        fbufp->f_base = (unsigned char FAR *)fbufp + sizeof(GEIfbuf_t);

    }

    fbufp->f_refcnt = 1;
    fbufp->f_size   = len;

    *fbufap = fbufp;

    return( 0 );
}

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      open, sopen, dup, close, read, write, ungetc, flush, ioctl
 * ---------------------------------------------------------------------
 */

GEIFILE FAR *    GEIio_open( filename, namelen, flags )
    char FAR *       filename;
    int         namelen;
    int         flags;
{
    register GEIFILE FAR *       f;
    register GESiocfg_t FAR *    iocfg;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef DBG
    printf( "\nenter io_open: name = %s, flags = %o\n", filename, flags );
#endif

    flags &= (_F_RWMASK |_F_MDMASK |_F_ONLY4OPEN );


    if(  namelen <= 0
      || !(flags & _F_RWMASK)
      || (flags & _O_RDWR) == _O_RDWR  )
    /* inhibited for read and write */
    {
#ifdef  DBG
        printf( "invalid namelen or flags\n" );
#endif
        GESseterror( EINVAL );
        return( NULLFILE );
    }

    if( (iocfg = GESiocfg_namefind( filename, namelen )) != (GESiocfg_t FAR *)NULL )
    {   /* if special, look for the file stream with the same requirements */

        flags &= (_F_RWMASK |_F_MDMASK );    /* ignore others for device */

        for( f=FileTableBeg; f<FileTableEnd; f++ )
        {
            if(   f->f_type == _S_IFCHR
              &&  f->f_handle == iocfg->devnum
              &&  flags == (int)(f->f_flag & (_F_RWMASK | _F_MDMASK ))  )//@WIN
                return( f );        /* return if the same thing found */
        }
    }

    /* allocate a file stream entry */
    for( f=FileTableBeg; f<FileTableEnd; f++ )
        if( f->f_handle == EOF )
            break;
    if( f>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef DBG
    printf( "file alloc address = %lx\n", (long)f );
#endif

    /* determine file type and handle (open device driver or file system) */
    if( iocfg != (GESiocfg_t FAR *)NULL )
    {
        if( CDEV_OPEN( iocfg->devnum ) == EOF )
            return( NULLFILE );

        f->f_handle = iocfg->devnum;
        f->f_type   = _S_IFCHR;
    }
    else    /* not a special file (not a device) */
    {
#ifdef FILESYS
        if( (f->f_handle = (short)GESfs_open( filename, namelen, flags )) == EOF )
            return( NULLFILE );

        f->f_type = _S_IFREG;
#else
#     ifdef DBG
        printf( "no such dev\n" );
#     endif
        GESseterror( ENODEV );
        return( NULLFILE );
#endif
    }

#ifdef DBG
    printf( "file type = %d, handle = 0x%X\n", f->f_type, f->f_handle );
#endif

    /* initialize file fbuf, flag, modq, and then increment opentag */
    if(fbuf_init(&(f->f_fbuf),(unsigned char FAR *)NULL, MAXUNGETCSIZE+MAXFBUFSIZE )
        == EOF )
    {
        f->f_type = FileInitVals.f_type;
        f->f_handle = EOF;
        return( NULLFILE );
    }
    f->f_fbuf->f_ptr =  f->f_fbuf->f_base  +  (flags & _O_RDONLY?
                                                    MAXUNGETCSIZE : 0);
    f->f_fbuf->f_cnt =  flags & _O_RDONLY? 0 : (MAXUNGETCSIZE+MAXFBUFSIZE);

    f->f_flag = _F_MYBUF | ( flags & (_F_RWMASK |_F_MDMASK) );
    f->f_modq = FileInitVals.f_modq;
    f->f_opentag++;

    return( f );

}   /* GEIio_open */

/* ...................................... */

GEIFILE FAR *    GEIio_sopen( string, length, flags )
    char FAR *      string;             /* @WIN */
    int                 length;
    int                 flags;
{
    register GEIFILE FAR *   f;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef  DBG
    printf( "\nenter io_sopen: len = %d, flags = %o\n", length, flags );
#endif

    flags &= _F_RWMASK;

    if(  length < 0  ||  flags == 0  ||  flags == _O_RDWR  )
    {
#ifdef  DBG
        printf( "invalid stringlen or flags\n" );
#endif
        GESseterror( EINVAL );
        return( NULLFILE );
    }

    /* allocate a file stream entry */
    for( f=FileTableBeg; f<FileTableEnd; f++ )
        if( f->f_handle == EOF )
            break;
    if( f>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef DBG
    printf( "file alloc address = %lx\n", (long)f );
#endif

    /* initialize file fbuf, type, handle, flag, and then increment opentag */
    if( fbuf_init( &(f->f_fbuf), string, length ) == EOF )
        return( NULLFILE );
    f->f_fbuf->f_ptr = string;
    //DJC fix from history.log UPD039
    /*
     * f->f_fbuf->f_cnt = flags & _O_RDONLY?  0  :  length;
     *  For string file, the f_cnt should be always set as length, since
     *  it will not issue any GESfbuf_fill at _O_RDONLY mode to read
     *  another data block.   @WIN
     */
    f->f_fbuf->f_cnt = length;
    //DJC end fix UPD039

    f->f_type = _S_IFSTR;
    f->f_handle = 0;
    f->f_flag = (unsigned short)flags;
    f->f_opentag++;

    return( f );

}   /* GEIio_sopen */

/* ...................................... */

GEIFILE FAR *    GEIio_dup( file )
    register GEIFILE FAR *   file;
{
    register GEIFILE FAR *   newf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( NULLFILE );
    }
#endif

#ifdef DBG
    printf( "\nenter io_dup: file = %lx, type = %d, handle = %o\n",
            (long)file, file->f_type, file->f_handle );
#endif

/*  if( f == NULLFILE  ||  f->f_flag & _F_ERR ) */
    if( file == NULLFILE  ||  file->f_flag & _F_ERR )
    {
#ifdef DBG
        printf( "bad file to dup\n" );
#endif
        GESseterror( EBADF );
        return( NULLFILE );
    }

    /* allocate a file stream entry */
    for( newf=FileTableBeg; newf<FileTableEnd; newf++ )
        if( newf->f_handle == EOF )
            break;
    if( newf>=FileTableEnd )
    {
#     ifdef DBG
        printf( "too many open files\n" );
#     endif
        GESseterror( EMFILE );
        return( NULLFILE );
    }

#ifdef  DBG
    printf( "file alloc addr = %lx\t", (long)newf );
#endif

    return( io_dup( newf, file ) == EOF?  NULLFILE  :  newf );

}   /* GEIio_dup */

/* ...................................... */

int         GEIio_close( f )
    GEIFILE FAR *    f;
{
    GEIFILE         oldf;
    GEIfmodq_t FAR *     mq;

    /* you should NEVER to detect GESevents for close */

#ifdef  DBG
    printf( "\nenter io_close: file = %lx, type = %d, handle = %o\n",
            (long)f, f->f_type, f->f_handle );
#endif

    if( f == NULLFILE  ||  f->f_handle == EOF )
        return( 0 );

    if( f->f_type == _S_IFEDIT )    /* to be removed in the future !!! */
        f->f_type = f->f_oldtype;

    for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
        FMODQ_CLOSE( f, mq );
    f->f_modq = (GEIfmodq_t FAR *)NULL;
    GEIclearerr();

    oldf = *f;
    *f = FileInitVals;
    f->f_opentag = oldf.f_opentag;

    if( --oldf.f_fbuf->f_refcnt <= 0 )
    {
        /* to write all buffered output */
        if(   oldf.f_flag & _O_WRONLY
          &&  oldf.f_fbuf->f_ptr > oldf.f_fbuf->f_base  )
            GESio_flush( &oldf );
        GEIclearerr();

        /* for string type, free fbuf only; fbuf and f_base o/w */
        if( oldf.f_type == _S_IFSTR  ||  oldf.f_flag & _F_MYBUF )
            GESfree( (char FAR *)(oldf.f_fbuf) );
    }

    /* invoke device driver or file system to close */
    switch( oldf.f_type )
    {
    case _S_IFCHR:
        CDEV_CLOSE( oldf.f_handle );
        break;
#ifdef FILESYS
    case _S_IFREG:
        GESfs_close( oldf.f_handle );
        break;
#endif
    default:
        break;
    }

    return( 0 );

}   /* GEIio_close */

/* ...................................... */

int         GEIio_read( f, buf, nbytes )
    register GEIFILE FAR *   f;
    char FAR *               buf;
    int                 nbytes;
{
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR  ||  !(f->f_flag & _O_RDONLY) )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    if( nbytes < 0 )
    {
        GESseterror( EINVAL );
        return( EOF );
    }

    if( nbytes == 0 )
        return( 0 );

    return( FMODQ_READ( f, f->f_modq, buf, nbytes ) );

}   /* GEIio_read */

/* ...................................... */

int         GESio_read( f, buf, nbytes )
    register GEIFILE FAR *   f;
    char FAR *               buf;
    int                 nbytes;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;
    int                 nleft = nbytes;
    int                 retval,remainder;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );
    if( nbytes <= fbufp->f_cnt )    /* only have to read out buffered data */
    {
        remainder=nbytes;
more:
        lmemcpy( buf, fbufp->f_ptr, remainder );        /*@WIN*/
        fbufp->f_ptr += remainder;
        fbufp->f_cnt -= remainder;
        return( nbytes );
    }

    if( fbufp->f_cnt > 0 )          /* buffered bytes are not big enough */
    {                               /* however, deliver buffered bytes first */
        lmemcpy( buf, fbufp->f_ptr, fbufp->f_cnt );     /*@WIN*/
        buf   += fbufp->f_cnt;
        nleft -= fbufp->f_cnt;

        fbufp->f_ptr -= fbufp->f_cnt;
        fbufp->f_cnt = 0;

        if( f->f_type == _S_IFSTR  ||  f->f_flag & _O_NDELAY )
            return( nbytes - nleft );
    }

    /* read into user's buffer through GESfbuf_fill */
    while( nleft > 0 )
    {
        if( (retval = GESfbuf_fill( f )) == EOF )
            break;

        *buf++ = (char)retval;
        nleft--;
        if( nleft > 0  &&  fbufp->f_cnt > 0 )
        {
            if (nleft < fbufp->f_cnt)   /* too much, Jimmy */
                {
                remainder=nleft;
                goto more;
                }
            lmemcpy( buf, fbufp->f_ptr, fbufp->f_cnt );         /*@WIN*/
            buf   += fbufp->f_cnt;
            nleft -= fbufp->f_cnt;

            fbufp->f_ptr -= fbufp->f_cnt;
            fbufp->f_cnt = 0;
        }

        if( f->f_flag & _O_NDELAY )
            break;
    }

    return( nleft == nbytes?  EOF  :  nbytes - nleft );

}   /* GESio_read */

/* ...................................... */
/* #ifdef JIMMY
unsigned long   IOwaittimeout = _NOWAITTIMEOUT;

void        GEIio_setwaittimeout( timeout )
    unsigned long   timeout;
{
    IOwaittimeout = timeout;
}

int         waittimeout_handler( timerp )
    GEItmr_t*       timerp;
{
    GESseterror( ETIME );               (* raise timed out error *)
    timerp->interval = _NOWAITTIMEOUT;  (* indicate the timer stopped on exit *)
    return( FALSE );                    (* stop the timer *)
}

#endif (* JIMMY */
/* ...................................... */

int         GESfbuf_fill( f )       /* called when buffer empty */
    register GEIFILE FAR *   f;
{
    /* (f) has been checked against 'isreadable' in getc() */

    register GEIfbuf_t FAR * fbufp;
    int                 retval;

/* Bill move it from behind 05/07/'91 */
    fbufp = f->f_fbuf;
    fbufp->f_cnt = 0;           /* force fbuf consistent */
    fbufp->f_ptr = fbufp->f_base + MAXUNGETCSIZE;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

#ifdef FILESYS
    if( f->f_type != _S_IFCHR  &&  f->f_type != _S_IFREG )
        f->f_flag |= _F_EOF;
#else
    if( f->f_type != _S_IFCHR )
        f->f_flag |= _F_EOF;
#endif

    if( f->f_flag & (_F_ERR | _F_EOF) ) {
       // DJC added
       retval = EOF;
       return(retval);
    }

/* Bill move it forward 05/07/'91
 *   fbufp = f->f_fbuf;
 *   fbufp->f_cnt = 0;
 *   fbufp->f_ptr = fbufp->f_base + MAXUNGETCSIZE;
 */

#ifdef FILESYS
    if( f->f_type == _S_IFREG )
    {
        while( (retval = GESfs_read( f->f_handle, fbufp->f_ptr,
                                     fbufp->f_size - MAXUNGETCSIZE ))
                == 0 )
        {

#         ifdef PANEL
            if( GESevent_isset( EVIDofKILL ) )
            {
                GESseterror( EINTR );
                break;
            }
#         endif

            if( GEIerror() != EZERO )
                break;
        }
    }
    else    /* for character device below */
#endif /* FILESYS */
    {       /* character devices */
/* #ifdef JIMMY
        GEItmr_t        waittimer;
        waittimer.interval =
            MAJdev(f->f_handle)==_SERIAL || MAJdev(f->f_handle)==_PARALLEL?
                IOwaittimeout : _NOWAITTIMEOUT;

        if( waittimer.interval != _NOWAITTIMEOUT )
        {
            waittimer.handler  = waittimeout_handler;
            waittimer.private  = (char*)NULL;
            if( !GEItmr_start( &waittimer ) )
                waittimer.interval = _NOWAITTIMEOUT;
        }
        GEIclearerr();
#endif  (* JIMMY */


        do  /* no-delay read until something got, eof or error */
        {
            retval = CDEV_READ( f->f_handle, fbufp->f_ptr,
                                             fbufp->f_size - MAXUNGETCSIZE,
                                             _O_NDELAY );

            if (retval == 0) {     // @WIN; break as EOF; @LANG
                f->f_flag |= _F_EOF;    // Temp. solution by scchen
                break;
            }

/* erik chen, 3-1-1991 */
            if ((retval == 0) && local_flag) {
                if (startup_flag) {
                    lstrncpy(job_state, "waiting; \0", 11) ;    /*@WIN*/
                    TI_state_flag = 0 ;
                    change_status() ;
                }
                local_flag = FALSE;
            }
/* erik chen, 3-1-1991 */

#         ifdef PANEL
#ifdef MTK
            pdl_no_process();
#endif
            if( GESevent_isset( EVIDofKILL ) )
                GESseterror( EINTR );
#         endif

            if( GEIerror() != EZERO )
                break;

        }while( retval == 0 );
/* #ifdef JIMMY
        if( waittimer.interval != _NOWAITTIMEOUT )
            GEItmr_stop( waittimer.timer_id );
   #endif
*/
    }

/* erik chen, 3-1-1991 */
        if ( !local_flag) {
            lstrncpy(job_state, "busy; \0", 8) ;        /* @WIN */
            TI_state_flag = 1 ;
            local_flag = TRUE;
            change_status() ;
        }
/* erik chen, 3-1-1991 */

    if( GEIerror() != EZERO )
    {
        f->f_flag |= _F_ERR;
        return( EOF );
    }

    if( retval == EOF )
    {
        f->f_flag |= _F_EOF;
        return( EOF );
    }

    fbufp->f_cnt = retval - 1;

    retval=*fbufp->f_ptr; /* Jimmy */
    fbufp->f_ptr++;
#ifdef MTK
    pdl_process();
#endif

    return(retval);

}   /* GESfbuf_fill */

/* ...................................... */

int         GEIio_write( f, buf, nbytes )
    register GEIFILE FAR *   f;
    unsigned char FAR *      buf;
    int                 nbytes;
{
   int retvalue;
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR  ||  !(f->f_flag & _O_WRONLY) )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    if( nbytes < 0 )
    {
        GESseterror( EINVAL );
        return( EOF );
    }

    if( nbytes == 0 )
        return( 0 );

AGAIN:

/*    return( FMODQ_WRITE( f, f->f_modq, buf, nbytes ) ); */
    retvalue = FMODQ_WRITE( f, f->f_modq, buf, nbytes );
#ifdef DBG_W
    printf(" retvalue = %lx nbytes= %lx\n", retvalue, nbytes);
#endif
    switch (retvalue) {
    case EOF:
       return(EOF);
    case 0:
       goto AGAIN;
    default:
       if (retvalue==nbytes) {
          return(retvalue);
       } else {
#ifdef DBG_W
          printf(" buf = %lx, retvalue= %lx\n", buf, retvalue);
#endif
          buf=buf+retvalue;
          nbytes=nbytes-retvalue;
          goto AGAIN;
       } /* endif */
    } /* endswitch */

}   /* GEIio_write */

/* ...................................... */

int         GESio_write( f, buf, nbytes )
    register GEIFILE FAR *   f;
    unsigned char FAR *      buf;
    int                 nbytes;     /* always be positive and non-zero */
{
    register GEIfbuf_t FAR *     fbufp = f->f_fbuf;
    int                     written, nb2write;
    int                     retval;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );

    /* copy as many user's data onto buffer as possible */
    if( (written = (fbufp->f_cnt >= nbytes? nbytes : fbufp->f_cnt)) > 0 )
    {
        lmemcpy( fbufp->f_ptr, buf, written );          /*@WIN*/
        buf += written;
        fbufp->f_ptr += written;
        fbufp->f_cnt -= written;
    }

    /* deal with string file */
    if( f->f_type == _S_IFSTR )
    {
        if( written == 0 )
        {
            f->f_flag |= _F_EOF;
            return( EOF );
        }
        return( written );
    }

    /* here should be only of _S_IFCHR and _S_IFREG */
    switch( f->f_type )
    {
    case _S_IFCHR:
    case _S_IFREG:
        break;
    default:
        GESseterror( EBADF );
        return( EOF );
    }

    /* flush all buffered output and user's output if sync requested */
    if( f->f_flag & _O_SYNC )
    {
        nb2write = fbufp->f_size - fbufp->f_cnt;/* size of buffered output */

        fbufp->f_ptr = fbufp->f_base;           /* reset fbuf */
        fbufp->f_cnt = fbufp->f_size;

        /* flush all buffered output first and user's then */
        if(  outsync( f->f_type, f->f_handle, fbufp->f_base, nb2write ) == EOF
          || outsync( f->f_type, f->f_handle, buf, nbytes-written ) == EOF   )
        {
            f->f_flag |= _F_ERR;
            return( EOF );
        }

        return( nbytes );       /* all been physically written */
    }

    if( written >= nbytes )
        return( nbytes );       /* all been buffered */

#ifdef DBG_W
    if (written>0) printf(" before flush written = %d\n",written);
#endif
    if( (written>0)  &&  (f->f_flag & _O_NDELAY) )
        return( written );      /* return if some been buffered for no-delay */

    /* write buffered output to device driver or file system */
    if( (nb2write = fbufp->f_size - fbufp->f_cnt) > 0 )
    {
#ifdef DBG_W
       printf(" nb2write = %d\n", nb2write);
#endif
        /* make a write to device or file system */
        retval =
#         ifdef FILESYS
            f->f_type == _S_IFREG?
                GESfs_write( f->f_handle, fbufp->f_base, nb2write )  :
#         endif
                CDEV_WRITE(  f->f_handle, fbufp->f_base, nb2write,
                                                f->f_flag & _F_MDMASK );
/*                                              _O_SYNC ); */

        if( retval == EOF )
        {
            f->f_flag |= _F_ERR;
            return( EOF );
        }

      /* 04/11/91 Bill make sure all are flushed */
      if (retval != nb2write) {
        CDEV_WRITE(f->f_handle, fbufp->f_base+retval, nb2write-retval, _O_SYNC);
      } else {
      } /* endif */

#     ifdef PANEL
        if( GESevent_isset( EVIDofKILL ) )
            retval = EOF;
#     endif
#ifdef DBG_W
       printf(" retval = %d\n", retval);
#endif

        /* reset fbufp */
        fbufp->f_cnt = fbufp->f_size;
        fbufp->f_ptr = fbufp->f_base;

#ifdef DBG_W
        printf(" f_cnt = %lx, f_ptr = %lx\n", fbufp->f_cnt, fbufp->f_ptr);
#endif
/* not all written?
 *
 *      if( retval < nb2write )
 *      {
 *          unsigned char*  ptr  = fbufp->f_base;
 *          int             left = nb2write - retval;
 *
 *          for( ; left--> 0; ptr++ )   *ptr = *( ptr + retval );
 *
 *          return( written );
 *      }
 *  }
 */
        /* all buffered output has been written out */

    }
    return( 0 );

}   /* GESio_write */

/* ...................................... */

int         GESfbuf_flush( f, c )   /* called by putc when buffer full */
    GEIFILE FAR *    f;
    int         c;
{
    /* (f) has been checked against iswriteable in putc() */

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_type == _S_IFSTR )
        f->f_flag |= _F_EOF;

    if( f->f_flag & (_F_ERR | _F_EOF) )
        return( EOF );

    if( GESio_flush( f ) == EOF  ||  f->f_flag & (_F_ERR | _F_EOF) )
        return( EOF );

    --( f->f_fbuf->f_cnt );
    return( *( f->f_fbuf->f_ptr++ ) = (char)c );

}   /* GESfbuf_flush */

/* ...................................... */

int         GESio_ungetc( c, f )
    int                 c;
    register GEIFILE FAR *   f;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR  ||  fbufp->f_ptr <= fbufp->f_base )
        return( EOF );

    *( -- fbufp->f_ptr )= (char)c;
    ++ fbufp->f_cnt;

    return( c );

}   /* GESio_ungetc */

/* ...................................... */

int         GEIio_flush( f )
    register GEIFILE FAR *   f;
{
#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f == NULLFILE  ||  f->f_flag & _F_ERR )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    return( FMODQ_FLUSH( f, f->f_modq ) );

}   /* GEIio_flush */

/* ...................................... */

int         GESio_flush( f )
    register GEIFILE FAR *   f;
{
    register GEIfbuf_t FAR * fbufp = f->f_fbuf;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if( f->f_flag & _F_ERR )
        return( EOF );

    if( f->f_flag & _O_RDONLY )
    {
        switch( f->f_type )
        {
        case _S_IFCHR:
            while(  CDEV_READ( f->f_handle, fbufp->f_base, fbufp->f_size, 0 )
                    != EOF );
            break;
#     ifdef FILESYS
        case _S_IFREG:
            while( GESfs_read( f->f_handle, fbufp->f_base, fbufp->f_size )
                    != EOF );
            break;
#     endif
        default:
            break;
        }

        fbufp->f_ptr = fbufp->f_base + fbufp->f_size;
        fbufp->f_cnt = 0;

        f->f_flag |= _F_EOF;
    }   /* end of flush on input stream */
    else
    {   /* flush on output stream */

        outsync( f->f_type, f->f_handle, fbufp->f_base,
                                         fbufp->f_size - fbufp->f_cnt );
        fbufp->f_ptr = fbufp->f_base;
        fbufp->f_cnt = fbufp->f_size;

    }   /* end of flush on output stream */

    if( GEIerror() != EZERO )
    {
        f->f_flag |= _F_ERR;
        return( EOF );
    }

    return( 0 );

}   /* GESio_flush */

/* ...................................... */

int         GEIio_ioctl( f, req, arg )
    register GEIFILE FAR *   f;
    int                 req;
    int                  FAR *arg;
{
    int                 tmpval;
    GEIfmodq_t           FAR *mq,  FAR *mqtop;

    /* you should NEVER to detect GESevents for ioctl */

    if( f == NULLFILE  ||  f->f_flag & _F_ERR )
    {
        GESseterror( EBADF );
        return( EOF );
    }

    switch( req )
    {
    case _I_PUSH:
        tmpval = 0;
        for( mq=f->f_modq; mq!=(GEIfmodq_t FAR *)NULL; mq=FMODQ_NEXT(mq) )
            tmpval ++;

        if(  tmpval == MAXFMODQS  ||
             (mq = (GEIfmodq_t FAR *)GESmalloc( sizeof(GEIfmodq_t) ))
                    == (GEIfmodq_t FAR *)NULL  )
        {
            GESseterror( ENOSR );
            return( EOF );
        }

        mqtop = f->f_modq;

        mq->next = mqtop;
        mq->fmod = (GEIfmod_t FAR *)arg;
        mq->private = (char FAR *)NULL;
        f->f_modq = mq;

        if( FMODQ_OPEN( f, mq ) != EOF )
            return( 0 );    /* successful open */

        f->f_modq = mqtop;
        GESfree( (char FAR *)mq );
        return( EOF );

    case _I_POP:
        if( (mqtop = f->f_modq) == (GEIfmodq_t FAR *)NULL )
        {
            *(GEIfmod_t FAR * FAR *)arg = (GEIfmod_t FAR *)NULL;
            return( 0 );    /* no operation */
        }

        *(GEIfmod_t FAR * FAR *)arg = mqtop->fmod;
        f->f_modq = FMODQ_NEXT( mqtop );
        FMODQ_CLOSE( f, mqtop );
        GESfree( (char FAR *)mqtop );
        return( 0 );

    case _I_LOOK:
        *(char FAR * FAR *)arg = FMODQ_NAME( f->f_modq );
        return( 0 );

    case _F_GETFL:
        *arg = f->f_flag & _F_MDMASK;
        return( 0 );

    case _F_SETFL:
        f->f_flag &= ~_F_MDMASK;
        f->f_flag |= (*arg & _F_MDMASK);
#     ifdef FILESYS
        if( f->f_type == _S_IFREG )
            GESfs_ioctl( f->f_handle, req, arg );
#     endif
        return( 0 );

    case _ECHOEOF:
    case _GETIOCOOK:
    case _SETIOCOOK:
    case _GETIOPARAMS:
    case _SETIOPARAMS:
        if( f->f_type == _S_IFCHR )
            return( CDEV_IOCTL( f->f_handle, req, arg ) );
        break;
    case _FIONREAD:
        if( !(f->f_flag & _O_RDONLY) )
            return( EOF );

        *arg = 0;
        for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
        {
            if( FMODQ_IOCTL( f, mq, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            *arg += tmpval;
        }
        *arg += f->f_fbuf->f_cnt;

        switch( f->f_type )
        {
        case _S_IFCHR:
            if( CDEV_IOCTL( f->f_handle, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            break;
#     ifdef FILESYS
        case _S_IFREG:
            if( GESfs_ioctl( f->f_handle, _FIONREAD, &tmpval ) == EOF )
                return( EOF );
            break;
#     endif
        default:    /* no operation */
            tmpval = 0;
            break;
        }

        *arg += tmpval;
        return( 0 );

    case _FIONRESET:
        for( mq=f->f_modq;  mq!=(GEIfmodq_t FAR *)NULL;  mq=FMODQ_NEXT(mq)  )
            if( FMODQ_IOCTL( f, mq, _FIONRESET, &tmpval ) == EOF )
                return( EOF );

        if( f->f_flag & _O_RDONLY )
        {
            f->f_fbuf->f_ptr = f->f_fbuf->f_base +
                               ( f->f_flag & _F_MYBUF? MAXUNGETCSIZE : 0 );
            f->f_fbuf->f_cnt = 0;
        }
        else
        {
            f->f_fbuf->f_ptr = f->f_fbuf->f_base;
            f->f_fbuf->f_cnt = f->f_fbuf->f_size;
        }

        f->f_flag &= ~(_F_EOF | _F_ERR);

        if( f->f_type == _S_IFCHR )
            CDEV_IOCTL( f->f_handle, _FIONRESET, arg );

        return( 0 );

    default:
        break;
    }

    GESseterror( ENOTTY );
    return( EOF );

}   /* GEIio_ioctl */

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GEIio stdios management
 * ---------------------------------------------------------------------
 */

/* ...................................... */

/* close all file table entries except at position 0,1,2 for ctty */
/* this routine is being called at the time of device switch - Bill lwo */

void        GESio_closeall()
{
    register GEIFILE FAR *   f;

    for( f=FileTable; f<FileTableEnd; f++ )
    {
        if( f->f_handle != EOF )
        {
            GEIclearerr();
            GEIio_close( f );
        }
    }
    GEIclearerr();
    return;
}

/* ...................................... */

GESiocfg_t FAR *     ctty = (GESiocfg_t FAR *)NULL;

/* ...................................... */

void        GESio_interrupt( devnum )   /* called by device driver    */
    int         devnum;                 /* when received an interrupt */
{
    if( ctty != (GESiocfg_t FAR *)NULL  &&  devnum == ctty->devnum )
        GEIsig_raise( GEISIGINT, 0x03 );    /* signal if a ctty */

    return;
}

/* ...................................... */

int         GEIio_forceopenstdios( which )
    unsigned    which;
{
    GEIFILE FAR *                fout = NULLFILE;
    GEIFILE FAR *                ferr = NULLFILE;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( FALSE );
    }
#endif

    if( (ctty = GESiocfg_defaultdev()) == (GESiocfg_t FAR *)NULL )
        return( FALSE );

    if( which & _FORCESTDIN )
        fin = GEIio_open( ctty->devname, lstrlen(ctty->devname), _O_RDONLY );/*@WIN*/

    if( which & _FORCESTDOUT )

    /* Bill 04/11/91 BUG in GESio_write */
        fout = GEIio_open( ctty->devname, lstrlen(ctty->devname),  /*@WIN*/
                           _O_WRONLY +_O_NDELAY );
/*        fout = GEIio_open( ctty->devname, strlen(ctty->devname), _O_WRONLY ); */


    if( which & _FORCESTDERR )
        ferr = GEIio_open( ctty->devname, lstrlen(ctty->devname), _O_WRONLY );/*@WIN*/

    return(  GEIio_setstdios( fin, fout, ferr )  );

}   /* GEIio_forceopenstdios */

/* ...................................... */

int         GEIio_setstdios( fin, fout, ferr )
    GEIFILE FAR *        fin;
    GEIFILE FAR *        fout;
    GEIFILE FAR *        ferr;
{
    register GEIFILE FAR *   f;

#ifdef PANEL
    if( GESevent_isset( EVIDofKILL ) )
    {
        GESseterror( EINTR );
        return( EOF );
    }
#endif

    if(  (fin != NULLFILE && !GEIio_isreadable(fin))   ||
         (fout!= NULLFILE && !GEIio_iswriteable(fout)) ||
         (ferr!= NULLFILE && !GEIio_iswriteable(ferr))  )
    {
        GESseterror( EBADF );
        return( FALSE );
    }

    if(  (f = fin) != GEIio_stdin  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stdin ) )
            GEIio_close( GEIio_stdin );

        if( io_dup( GEIio_stdin, f ) == EOF )
            return( FALSE );
    }

    if(  (f = fout) != GEIio_stdout  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stdout ) )
            GEIio_close( GEIio_stdout );

        if( io_dup( GEIio_stdout, f ) == EOF )
            return( FALSE );
    }

    if(  (f = ferr) != GEIio_stderr  &&  f != NULLFILE  )
    {
        if( GEIio_isopen( GEIio_stderr ) )
            GEIio_close( GEIio_stderr );

        if( io_dup( GEIio_stderr, f ) == EOF )
            return( FALSE );
    }

    return( TRUE );

}   /* GEIio_setstdios */

/* ...................................... */

/*
 * ---------------------------------------------------------------------
 *      GEIio_init
 * ---------------------------------------------------------------------
 */

void        GEIio_init()
{
    register GEIFILE FAR *       f;

    if( (FileTable =
            (GEIFILE FAR *)GESpalloc( (MAXSTDIOS+MAXFILES) * sizeof(GEIFILE) ))
        == NULLFILE )
    {
        GESseterror( ENOMEM );
        return;
    }
    /* Initialize statusbuf  03/22/91 Bill*/
    statusbuf[0]='%';
    statusbuf[1]='%';
    statusbuf[2]='[';
    statusbuf[3]=' ';
    statusbuf[4]='\0';

    GEIio_stdin  = FileTable + 0;
    GEIio_stdout = FileTable + 1;
    GEIio_stderr = FileTable + 2;

    FileTableBeg = FileTable + MAXSTDIOS;
    FileTableEnd = FileTable + MAXSTDIOS + MAXFILES;

    for( f=FileTable; f<FileTableEnd; f++ )
        *f = FileInitVals;

#ifdef FILESYS
    GESfs_init();
#endif

    return;
}

/* Restarting printer */
extern GESiosyscfg_t FAR *  activedev;
void        GEIio_restart()
{
    if ( activedev->iocfg.devnum == MAKEdev(MAJatalk, MINatalk) ) {
       GEIio_getc(GEIio_stdin);
       GEIio_ioctl(GEIio_stdout, _FIONRESET, (int FAR *)0) ;
    }
    GEP_restart();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geiio.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIio.h
 *
 *  HISTORY:
 *  04-07-92   SCC   Add prototypes and re-order the sequence of typedef
 * ---------------------------------------------------------------------
 */

#ifndef _GEIIO_H_
#define _GEIIO_H_

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

#ifndef NULL
#define NULL    ( 0 )
#endif

#ifndef EOF
#define EOF     ( -1 )
#endif


/*
 * ---
 *  File Buffer Structure
 * ---
 */
typedef
    struct GEIfbuf
    {
        int                 f_refcnt;
        int                 f_size;
        int                 f_cnt;
        unsigned char FAR * f_ptr;
        unsigned char FAR * f_base;

        /* the following are used by old version EDIT: PJ */
        short               rw_buffer;
        short               rw_offset;
        short               incount;
        unsigned int        size;
        char                inchar[2];
    }
GEIfbuf_t;

/* @WIN; move typedef of GEIfmodq_t to here before using it */
typedef
    struct GEIfmodq
    {
        struct GEIfmodq FAR *    next;
//      GEIfmod_t FAR *          fmod;     @WIN: avoid define recursively
        struct GEIfmod FAR *     fmod;
        char FAR *               private;
    }
GEIfmodq_t;

/*
 * ---
 *  File Stream Structure
 * ---
 */
/* @WIN; move typedef of GEIFILE to here before using it */
typedef
    struct  GEIiofile
    {
        unsigned short      f_type;
        unsigned short      f_flag;
        short               f_handle;
        GEIfbuf_t FAR *     f_fbuf;
        GEIfmodq_t FAR *    f_modq;
        int                 f_opentag;
        int                 f_savelevel;

        /* the following are used by old version EDIT: PJ */
        unsigned short      f_oldtype;
    }
GEIFILE;

/*
 * ---
 *  File Module Structure
 * ---
 */
/* @WIN; add prototype */
typedef
    struct GEIfmod
    {
        char FAR * fmod_name;
        int (FAR *fmod_open) (GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_close)(GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_ioctl)(GEIFILE FAR *, GEIfmodq_t FAR *, int, int FAR*);
                              /* file, *this_fmodq, req, arg */
        int (FAR *fmod_read) (GEIFILE FAR *, GEIfmodq_t FAR *, char FAR *, int);
                              /* file, *this_fmodq, buf, size */
        int (FAR *fmod_write)(GEIFILE FAR *, GEIfmodq_t FAR *, char FAR *, int);
                              /* file, *this_fmodq, buf, size */
        int (FAR *fmod_flush)(GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_ungetc)(int, GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* char2pushback, file, *this_fmodq */
        int (FAR *fmod_getc) (GEIFILE FAR *, GEIfmodq_t FAR *);
                              /* file, *this_fmodq */
        int (FAR *fmod_putc) (GEIFILE FAR *, GEIfmodq_t FAR *, int);
                              /* file, *this_fmodq, char2put */
    }
GEIfmod_t;



/*  the following macros should never be used by anyone except GEIio */
#   define  FMODQ_OPEN(f,mq)            \
                ( *((mq)->fmod->fmod_open)  )( f, mq )
#   define  FMODQ_CLOSE(f,mq)           \
                ( *((mq)->fmod->fmod_close) )( f, mq )
#   define  FMODQ_IOCTL(f,mq,req,arg)   \
                ( *((mq)->fmod->fmod_ioctl) )( f, mq, req, arg )

void        GESio_closeall(void);

/* interface routines for file modules to call, but through macros only */
/* @WIN; add prototype */
int         GESio_read(GEIFILE FAR *, char FAR *, int);
int         GESio_write(GEIFILE FAR *, unsigned char FAR *, int );
int         GESio_flush(GEIFILE FAR *);
int         GESio_ungetc(int, GEIFILE FAR *);
int         GESfbuf_fill(GEIFILE FAR *);
int         GESfbuf_flush(GEIFILE FAR *, int);

/* macros for file modules to use directly */

#   define  FMODQ_NEXT(mq)          ( (mq)->next )

#   define  FMODQ_NAME(mq)          \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( (mq)->fmod->fmod_name )  :  (char FAR *)NULL      \
                )

/* Bill 04/30/'91 add it according to performance issue */

#ifdef FMODQ
#   define  FMODQ_READ(f,mq,buf,s)  \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_read) )( f, mq, buf, s )  :    \
                        GESio_read( f, buf, s )                             \
                )
#   define  FMODQ_WRITE(f,mq,buf,s) \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_write) )( f, mq, buf, s )  :   \
                        GESio_write( f, buf, s )                            \
                )
#   define  FMODQ_FLUSH(f,mq)       \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_flush) )( f, mq )  :           \
                        GESio_flush( f )                                    \
                )
#   define  FMODQ_UNGETC(c,f,mq)    \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_ungetc) )( c, f, mq )  :       \
                        GESio_ungetc( c, f )                                \
                )
#   define  FMODQ_PUTC(f,mq,c)      \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_putc) )( f, mq, c )  :         \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ ) = (unsigned char)( c )  : \
                        GESfbuf_flush( f, c )                               \
                )
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    (mq) != (GEIfmodq_t FAR *)NULL?                         \
                        ( *((mq)->fmod->fmod_getc) )( f, mq )   :           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        GESfbuf_fill( f )                                   \
                )
#else
#   define  FMODQ_READ(f,mq,buf,s)  \
                (                                                           \
                        GESio_read( f, buf, s )                             \
                )
#   define  FMODQ_WRITE(f,mq,buf,s) \
                (                                                           \
                        GESio_write( f, buf, s )                            \
                )
#   define  FMODQ_FLUSH(f,mq)       \
                (                                                           \
                        GESio_flush( f )                                    \
                )
#   define  FMODQ_UNGETC(c,f,mq)    \
                (                                                           \
                        GESio_ungetc( c, f )                                \
                )
#   define  FMODQ_PUTC(f,mq,c)      \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ ) = (unsigned char)( c )  : \
                        (unsigned char)GESfbuf_flush( f, c ) /*@WIN*/       \
                )

#ifdef DJC
// change cast of (unsigned char) to nothing
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        (unsigned char)GESfbuf_fill( f )     /*@WIN*/       \
                )
#else
#   define  FMODQ_GETC(f,mq)        \
                (                                                           \
                    --((f)->f_fbuf->f_cnt) >= 0 ?                           \
                        *( (f)->f_fbuf->f_ptr++ )  :                        \
                        GESfbuf_fill( f )     /*@WIN*/       \
                )
#endif // DJC


#endif

/* file check macros */
#   define  GEIio_isopen( f )       \
                ( (f) != (GEIFILE FAR *)NULL  &&  (f)->f_handle != EOF )
#   define  GEIio_isok( f )         \
                ( GEIio_isopen(f)  &&  !((f)->f_flag & _F_ERR) )
#   define  GEIio_isreadable( f )   \
                ( GEIio_isok(f)  &&  (f)->f_flag & _O_RDONLY )
#   define  GEIio_iswriteable( f )  \
                ( GEIio_isok(f)  &&  (f)->f_flag & _O_WRONLY )
#   define  GEIio_eof( f )          \
                ( !GEIio_isopen(f)  ||  (f)->f_flag & _F_EOF )
#   define  GEIio_err( f )          \
                ( !GEIio_isopen(f)  ||  (f)->f_flag & _F_ERR )
#   define  GEIio_clearerr( f )     \
                {                                               \
                    if( GEIio_isopen(f) )                       \
                        ( (f)->f_flag &= ~(_F_EOF |_F_ERR) );   \
                }

/* file type definition     */
#   define     _S_IFNON     ( 0 )
#   define     _S_IFCHR     ( 1 )
#   define     _S_IFREG     ( 3 )
#   define     _S_IFSTR     ( 6 )
#   define  GEIio_ischr( f )        ( (f)->f_type == _S_IFCHR )
#   define  GEIio_isreg( f )        ( (f)->f_type == _S_IFREG )
#   define  GEIio_isstr( f )        ( (f)->f_type == _S_IFSTR )

/***
# * define     _S_IFBLK     ( 2 )
# * define     _S_IFDIR     ( 4 )
# * define     _S_IFLNK     ( 5 )
# * define  GEIio_isblk( f )        ( (f)->f_type == _S_IFBLK )
# * define  GEIio_isdir( f )        ( (f)->f_type == _S_IFDIR )
# * define  GEIio_islnk( f )        ( (f)->f_type == _S_IFLNK )
 ***/

#   define     _S_IFEDIT    ( 7 )   /* to be removed someday */
#   define  GEIio_isedit( f )       ( (f)->f_type == _S_IFEDIT )
#   define  GEIio_setedit( f )      { (f)->f_oldtype = (f)->f_type;     \
                                      (f)->f_type = _S_IFEDIT; }

/* file flag definition */
#   define     _F_RWMASK    ( 00007 )   /* read/write mask */
#   define         _O_RDONLY    ( 00001 )
#   define         _O_WRONLY    ( 00002 )
#   define         _O_RDWR      ( _O_RDONLY | _O_WRONLY )   /* not support */
#   define     _F_MDMASK    ( 00070 )   /* operation mode mask */
#   define         _O_APPEND    ( 00010 )
#   define         _O_NDELAY    ( 00020 )
#   define         _O_SYNC      ( 00040 )
#   define     _F_ONLY4OPEN ( 00700 )   /* never put onto f_flag */
#   define         _O_TRUNC     ( 00100 )       /* for file sys only */
#   define         _O_CREAT     ( 00200 )       /* for file sys only */
#   define         _O_EXCL      ( 00400 )       /* for file sys only */
#   define     _F_EOF       ( 00100 )
#   define     _F_ERR       ( 00200 )
#   define     _F_MYBUF     ( 00400 )

/* only for TrueImage usage */
#   define  GEIio_opentag( f )      ( (f)->f_opentag )
#   define  GEIio_savelevel( f )    ( (f)->f_savelevel )
#   define  GEIio_setsavelevel(f,s) (void)( (f)->f_savelevel = (s) )

/*
 * ---
 *  Standard File Streams
 * ---
 */
extern GEIFILE   FAR *GEIio_stdin,  FAR *GEIio_stdout,  FAR *GEIio_stderr;

/*
 * ---
 *  Interface Routines
 * ---
 */
#   define  GEIio_source( )         \
            ctty->devname
/*  Bill 05/02/'91 refine it according to performance issue

#   define  GEIio_getc( f )         \
                ( GEIio_isreadable(f)? FMODQ_GETC( f, (f)->f_modq ) : EOF )
#   define  GEIio_ungetc( c, f )    \
                (                                                   \
                        c!=EOF?              \
                        FMODQ_UNGETC( c, f, (f)->f_modq ) : EOF \
                )
#   define  GEIio_putc( f, c )      \
                ( GEIio_iswriteable(f)? FMODQ_PUTC( f, (f)->f_modq, c ) : EOF )
*/

#   define  GEIio_getc( f )         \
                ( FMODQ_GETC( f, (f)->f_modq ) )
#   define  GEIio_ungetc( c, f )    \
                (                                                   \
                    GEIio_isreadable( f )  &&  c!=EOF?              \
                        FMODQ_UNGETC( c, f, (f)->f_modq ) : EOF     \
                )
#   define  GEIio_putc( f, c )      \
                ( FMODQ_PUTC( f, (f)->f_modq, c ) )

/* @WIN; add prototype */
int         GEIio_forceopenstdios(unsigned /* usingCTTY, seebelow */ );
#               define      _FORCESTDIN     ( 00001 )
#               define      _FORCESTDOUT    ( 00002 )
#               define      _FORCESTDERR    ( 00004 )
#               define      _FORCESTDALL    ( 00007 )
int         GEIio_setstdios(GEIFILE FAR *, GEIFILE FAR *, GEIFILE FAR *);

GEIFILE FAR *    GEIio_firstopen(void);
GEIFILE FAR *    GEIio_nextopen(void);

/* @WIN; add prototype */
GEIFILE FAR *    GEIio_open(char FAR *, int, int );
GEIFILE FAR *    GEIio_sopen(char FAR *, int, int );
GEIFILE FAR *    GEIio_dup(GEIFILE FAR *);
int         GEIio_close(GEIFILE FAR *);
int         GEIio_flush(GEIFILE FAR *);
int         GEIio_read(GEIFILE FAR *, char FAR *, int);         /* @WIN */
int         GEIio_write(GEIFILE FAR *, unsigned char FAR *, int);/* @WIN */
int         GEIio_ioctl(GEIFILE FAR *, int, int FAR *);        /* @WIN */
#ifdef DBGDEV
#ifdef __I960__
int         printf(const char  FAR *, ...);
#else
int         printf( /* format, ... */ );
#endif
#endif
int         GEIio_printf();   // GEIFILE FAR *, char FAR *, ...);
                         /* file, format, ... */

/* status update */
void        GESio_obtainstatus(char FAR * FAR *statusaddr, int FAR *len);

/* set wait timeout */
void        GEIio_setwaittimeout(unsigned long /* wait-timeout-in-msec */ );

/* channel name (in gesiocfg.c) */
char FAR *       GEIio_channelname(int /* 25 or 9 */ );  /* for scc stuff */
char FAR *       GEIio_channelnameforall(int /* index */ );

/* select stdios (in gesiocfg.c) */
int         GEIio_selectstdios(void);   /* @WIN */

#endif /* !_GEIIO_H_ */

/* @WIN; add prototype */
void        GEIio_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geipm.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIpm.h
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GEIPM_H_
#define _GEIPM_H_

/*
 * ---
 *  Global Logical PMid Assignments (ALWAYS FROM 1)
 * ---
 */
#define     PMIDofPASSWORD      ( 1 )
#define     PMIDofPAGECOUNT     ( 2 )
#define     PMIDofPAGEPARAMS    ( 3 )
#define     PMIDofSERIAL25      ( 4 )
#define     PMIDofSERIAL9       ( 5 )
#define     PMIDofPARALLEL      ( 6 )
#define     PMIDofPRNAME        ( 7 )
#define     PMIDofTIMEOUTS      ( 8 )
#define     PMIDofEESCRATCHARRY ( 9 )
#define     PMIDofIDLETIMEFONT  ( 10 )
#define     PMIDofSTSSTART      ( 11 )
#define     PMIDofSCCBATCH      ( 12 )
#define     PMIDofSCCINTER      ( 13 )
#define     PMIDofDPLYLISTSIZE  ( 14 )
#define     PMIDofFONTCACHESZE  ( 15 )
#define     PMIDofATALKSIZE     ( 16 )
#define     PMIDofDOSTARTPAGE   ( 17 )
#define     PMIDofHWIOMODE      ( 18 )
#define     PMIDofSWIOMODE      ( 19 )
#define     PMIDofPAGESTCKORDER ( 20 )
#define     PMIDofATALK         ( 21 )
#define     PMIDofMULTICOPY     ( 22 )
#define     PMIDofPAGETYPE      ( 23 )

#define     PMIDofRESERVE       ( 24 )

/*
 * ---
 *  Interface Routines
 * ---
 */
int /* bool */  GEIpm_read(unsigned, char FAR *, unsigned);
int /* bool */  GEIpm_write(unsigned, char FAR *, unsigned);
int /* bool */  GEIpm_flush(unsigned, char FAR *, unsigned);
void            GEIpm_flushall(void);
void            GEIpm_reload(void);

/* to be implemented ??? */
int /* bool */  GEIpm_ioparams_read(char FAR *, GEIioparams_t FAR *, int);
int /* bool */  GEIpm_ioparams_write(char FAR *, GEIioparams_t FAR *, int);
int /* bool */  GEIpm_ioparams_flush(char FAR *, GEIioparams_t FAR *, int);

#endif /* !_GEIPM_H_ */
#define     _MAXPAGECOUNT      128

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geiiolib.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIiolib.c
 *
 *  COMPILATION SWITCHES:
 *
 *  HISTORY:
 *  09/15/90    Erik Chen   created.
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"


// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include        "geiio.h"
#include        "gescfg.h"

typedef double              real64;
typedef float               real32;
typedef unsigned long       ufix32;
typedef long                fix32;
typedef unsigned int        ufix;
typedef int                 fix;
typedef unsigned short      ufix16;
typedef short               fix16;
typedef unsigned char       ubyte;
typedef char                byte;

#ifndef DOS
#define near
#define far
#endif

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WIN; add prototype */
static byte * near printfield(byte *cursor, ufix32 number, ufix32 divide,
                              ufix32 radix);

/*
 * ---------------------------------------------------------------------
 *  printf( file, ... ) and GEIio_printf(...)
 * ---------------------------------------------------------------------
 */

static char     digit[] =
{
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
    'W','X','Y','Z'
};

/* ...................................... */

static byte * near
printfield(cursor, number, divide, radix)
byte    *cursor;
ufix32  number;
ufix32  divide;
ufix32  radix;
{
    byte        c;
    fix         notzero = 0;

    for (; divide >= 1L;) {
        c = digit[(fix)(number / divide)];
        if (c != '0' || notzero) {
           notzero = 1;
           *cursor++ = c;
        }
        number = number % divide;
        divide = divide / radix;
    }
    if (!notzero)
       *cursor++ = '0';
    return(cursor);
}   /* printfield() */

/* ...................................... */

#ifdef DBGDEV
/*
 *     printf()
 */
fix
printf(va_alist)
char    *va_alist;
{
    char*       argv;
    byte        *cursor;
    byte        *format;
    byte        buffer[256];

    argv = (byte *)&va_alist;
    format = ((char **)(argv += sizeof(char *)))[-1];

    for (cursor = buffer; *format != '\0';) {
        if (*format == '%') {
           fix  flag;

           for (flag = 0, format++; *format != '\0';) {
               switch (*format++) {
               case 'l':
                    flag = 1;
                    break;
               case 'd':
               case 'i':
                    if (flag == 0) {
                       fix  number;

                       number = ((fix *)(argv += sizeof(fix)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                    } else {
                       fix32  number;

                       number = ((fix32 *)(argv += sizeof(fix32)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'u':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                      } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'o':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x8000L, 8L);
                     } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x40000000L, 8L);
                    }
                    flag = 2;
                    break;
               case 'x':
               case 'X':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x1000L, 16L);
                     } else {
                       ufix32  number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x10000000L, 16L);
                    }
                    flag = 2;
                    break;
               case 'f':
               case 'e':
               case 'E':
               case 'g':
               case 'G':
                    {
                       fix      length;
                       fix      expont;
                       real64   number;
                       number = ((real64 *)(argv += sizeof(real64)))[-1];
                       if (number < (real64)0) {
                          if (number <= (real64)-1.0e39) {
                             *cursor++= '-';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number > (real64)-1.0e-39) {
                             *cursor++= '-';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }
                          number = -number;
                          *cursor++= '-';
                       } else {
                          if (number >= (real64)1.0e39) {
                             *cursor++= '+';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number < (real64)1.0e-39) {
                             *cursor++= '+';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }

                          *cursor++= ' ';
                       }
                       if (number >= (real64)1.0) {
                          for (expont = 0; (real32)number >= (real32)10.0; expont++)
                               number = number / 10.0;
                       } else {
                          for (expont = 0; (real32)number < (real32)1.0; expont--)
                              number = number * 10.0;
                       }
                       *cursor++= digit[((fix)number)];
                       number = (number - ((fix)number)) * 10.0;
                       *cursor++= '.';
                       for (length = 0; length < 5; length++) {
                           *cursor++= digit[((fix)number)];
                           number = (number - ((fix)number)) * 10.0;
                       }
                       *cursor++= 'E';
                       if (expont < 0) {
                          expont = -expont;
                          *cursor++= '-';
                       } else
                          *cursor++= '+';
                       cursor = printfield(cursor, (ufix32)expont, 10L, 10L);
                    }
                    flag = 2;
                    break;
               case 'c':
                    {
                       ufix  charac;

                       charac = ((ufix *)(argv += sizeof(ufix)))[-1];
                       *cursor++ = (byte)charac;
                    }
                    flag = 2;
                    break;
               case 's':
                    {
                       byte  *string;

                       string = ((byte **)(argv += sizeof(byte *)))[-1];
                       for (; *string != '\0';)
                           *cursor++= *string++;
                    }
                    flag = 2;
                    break;
               } /* switch */

               if (flag == 2)
                  break;
            } /* for */
        } else {
            *cursor++= *format++;
        }
    } /* for */

    CDEV_WRITE( MINdev(DBGDEV), buffer, cursor-buffer, _O_SYNC );

    return( 0 );
}   /* GEIio_printf() */

#endif /* DBGDEV */

/* ...................................... */

fix
GEIio_printf(file, va_alist)
GEIFILE *file;
char    *va_alist;
{
    char*       argv;
    byte        *cursor;
    byte        *format;
    byte        buffer[256];

    argv = (byte *)&va_alist;
    format = ((char **)(argv += sizeof(char *)))[-1];

    for (cursor = buffer; *format != '\0';) {
        if (*format == '%') {
           fix  flag;

           for (flag = 0, format++; *format != '\0';) {
               switch (*format++) {
               case 'l':
                    flag = 1;
                    break;
               case 'd':
               case 'i':
                    if (flag == 0) {
                       fix  number;

                       number = ((fix *)(argv += sizeof(fix)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                    } else {
                       fix32  number;

                       number = ((fix32 *)(argv += sizeof(fix32)))[-1];
                       if (number < 0) {
                          number = -number;
                          *cursor++= '-';
                       } else
                          *cursor++= ' ';
                       cursor = printfield(cursor, (ufix32)number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'u':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 10000L, 10L);
                      } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 1000000000L, 10L);
                    }
                    flag = 2;
                    break;
               case 'o':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x8000L, 8L);
                     } else {
                       ufix32   number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x40000000L, 8L);
                    }
                    flag = 2;
                    break;
               case 'x':
               case 'X':
                    if (flag == 0) {
                       ufix  number;

                       number = ((ufix *)(argv += sizeof(ufix)))[-1];
                       cursor = printfield(cursor, (ufix32)number, 0x1000L, 16L);
                     } else {
                       ufix32  number;

                       number = ((ufix32 *)(argv += sizeof(ufix32)))[-1];
                       cursor = printfield(cursor, number, 0x10000000L, 16L);
                    }
                    flag = 2;
                    break;
               case 'f':
               case 'e':
               case 'E':
               case 'g':
               case 'G':
                    {
                       fix      length;
                       fix      expont;
                       real64   number;
                       number = ((real64 *)(argv += sizeof(real64)))[-1];
                       if (number < (real64)0.0) {
                          if (number <= (real64)-1.0e39) {
                             *cursor++= '-';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number > (real64)-1.0e-39) {
                             *cursor++= '-';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }
                          number = -number;
                          *cursor++= '-';
                       } else {
                          if (number >= (real64)1.0e39) {
                             *cursor++= '+';
                             *cursor++= 'I';
                             *cursor++= 'N';
                             *cursor++= 'F';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          } else if (number < (real64)1.0e-39) {
                             *cursor++= '+';
                             *cursor++= '0';
                             *cursor++= '.';
                             *cursor++= '0';
                             *cursor++= ' ';
                             flag = 2;
                             break;
                          }

                          *cursor++= ' ';
                       }
                       if (number >= (real64)1.0) {
                          for (expont = 0; (real32)number >= (real32)10.0; expont++)
                               number = number / 10.0;
                       } else {
                          for (expont = 0; (real32)number < (real32)1.0; expont--)
                              number = number * 10.0;
                       }
                       *cursor++= digit[((fix)number)];
                       number = (number - ((fix)number)) * 10.0;
                       *cursor++= '.';
                       for (length = 0; length < 5; length++) {
                           *cursor++= digit[((fix)number)];
                           number = (number - ((fix)number)) * 10.0;
                       }
                       *cursor++= 'E';
                       if (expont < 0) {
                          expont = -expont;
                          *cursor++= '-';
                       } else
                          *cursor++= '+';
                       cursor = printfield(cursor, (ufix32)expont, 10L, 10L);
                    }
                    flag = 2;
                    break;
               case 'c':
                    {
                       ufix  charac;

                       charac = ((ufix *)(argv += sizeof(ufix)))[-1];
                       *cursor++ = (byte)charac;
                    }
                    flag = 2;
                    break;
               case 's':
                    {
                       byte  *string;

                       string = ((byte **)(argv += sizeof(byte *)))[-1];
                       for (; *string != '\0';)
                           *cursor++= *string++;
                    }
                    flag = 2;
                    break;
               } /* switch */

               if (flag == 2)
                  break;
            } /* for */
        } else {
            *cursor++= *format++;
        }
    } /* for */

    GEIio_write( file, buffer, (int)(cursor-buffer) );
    GEIio_flush( file );
    return( 0 );
}   /* GEIio_printf */

/* ...................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geipm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIpm.c
 *
 *  COMPILATION SWITCHES:
 *      REALEEPROM  - enables to physical read/write from real eeprom.
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 *                      - not to interact with real eeprom.
 *                      - always read from ROM copy at boot.
 *                      - always write to RAM copy only instead of eeprom.
 *  09/17/90    byou    added REALEEPROM options.
 *  09/22/90    echen   added APPLE corresponding eeprom
 *  10/30/90    byou    included "gescfg.h" and added ioparams stuff
 *                      for temporary testing.
 *  11/16/90    phchen  reorganized GESpm_init() for real eeprom.
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <string.h>

#include    "gescfg.h"

#include    "geipm.h"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geisig.h"
#include    "geierr.h"

#include    "geicfg.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

#define     _MAXPAGECOUNT       128
#define     _MAXEESCRATCHARRY    64
#define     _MAXIDLETIMEFONT    151
#define     _MAXSCCBATCH         10
#define     _MAXSCCINTER         10
#define     EEPROM_CHECKSUM   84480

#ifdef REALEEPROM
#include    "eeprom.h"
static      int         EEPromOnLine = FALSE;
#endif /* REALEEPROM */

/* @WIN; add prototype */
static void FlushOrUpdateRAMandMarkDiff(unsigned, char FAR *, unsigned, int);
typedef void (*pmop_t)(int, char FAR *);
static pmop_t findpmop( unsigned, unsigned);

/*
 * ---
 *  Physical Persistent Memory Allocation And Initialized Values
 * ---
 */
#ifdef  UNIX
#define ByteAlign( addr )       ( addr )
#define WordAlign( addr )       ( ((addr) + 1) / 2 ) * 2
#define LongAlign( addr )       ( ((addr) + 3) / 4 ) * 4
#endif

/*
    +-------+--------------+----+
    |start  |type          |size|
    |postion|              |    |
    +-------+--------------+----+
    |    0  |magicnum      |  4 |
    |    4  |password      |  4 |
    |    8  |pagecount     |128 |
    |  136  |leftmargin    |  4 |
    |  140  |topmargin     |  4 |
    |  144  |pagetype      |  1 |
    +-------+--------------+----+
    |  145  |baud          |  1 |
    |  146  |flowpari      |  1 | --- serial25
    |  147  |stopdata      |  1 |
    +-------+--------------+----+
    |  148  |baud          |  1 |
    |  149  |flowpari      |  1 | --- serial9
    |  150  |stopdata      |  1 |
    +-------+--------------+----+
    |  151  |prname        | 33 |
    +-------+--------------+----+
    |  184  |jobtout       |  4 |
    |  188  |manualtout    |  4 | --- timeouts
    |  192  |waittout      |  4 |
    +-------+--------------+----+
    |  196  |eescratcharry | 64 |
    |  260  |idletimefont  |151 |
    |  411  |stsstart      |  1 |
    |  412  |sccbatch      | 10 |
    |  422  |sccinter      | 10 |
    |  432  |dplylistsize  |  4 |
    |  436  |fontcachesze  |  4 |
    |  440  |atalksize     |  4 |
    |  444  |dostartpage   |  1 |
    |  445  |hwiomode      |  1 |
    |  446  |swiomode      |  1 |
    |  447  |pagestckorder |  1 |
    |  448  |reserve       | 64 |
    +-------+--------------+----+
*/
#ifdef  UNIX
#define OFFSmagicnum            LongAlign( 0 )
#define SIZEmagicnum            sizeof( unsigned long )

#define OFFSpassword            LongAlign( OFFSmagicnum + SIZEmagicnum )
#define SIZEpassword            sizeof( unsigned long )

#define OFFSpagecount           ByteAlign( OFFSpassword + SIZEpassword )
#define SIZEpagecount           ( _MAXPAGECOUNT )

#define OFFSengparams           LongAlign( OFFSpagecount + SIZEpagecount )
#define     OFFSleftmargin      LongAlign( 0 )
#define     SIZEleftmargin      sizeof( unsigned long )
#define     OFFStopmargin       LongAlign( OFFSleftmargin + SIZEleftmargin )
#define     SIZEtopmargin       sizeof( unsigned long )
#define     OFFSpagetype        ByteAlign( OFFStopmargin + SIZEtopmargin )
#define     SIZEpagetype        sizeof( unsigned char )
#define SIZEengparams           ( OFFSpagetype + SIZEpagetype )

#define OFFSserial25            ByteAlign( OFFSengparams + SIZEengparams )
#define     OFFSbaud            ByteAlign( 0 )
#define     SIZEbaud            sizeof( unsigned char )
#define     OFFSflowpari        ByteAlign( OFFSbaud + SIZEbaud )
#define     SIZEflowpari        sizeof( unsigned char )
#define     OFFSstopdata        ByteAlign( OFFSflowpari + SIZEflowpari )
#define     SIZEstopdata        sizeof( unsigned char )
#define SIZEserial              ( OFFSstopdata + SIZEstopdata )
#define OFFSserial9             ByteAlign( OFFSserial25 + SIZEserial )

#define OFFSprname              ByteAlign( OFFSserial9 + SIZEserial )
#define SIZEprname              ( _MAXPRNAMESIZE )

#define OFFStimeouts            LongAlign( OFFSprname + SIZEprname )
#define     OFFSjobtout         LongAlign( 0 )
#define     SIZEjobtout         sizeof( unsigned long )
#define     OFFSmanualtout      LongAlign( OFFSjobtout + SIZEjobtout )
#define     SIZEmanualtout      sizeof( unsigned long )
#define     OFFSwaittout        LongAlign( OFFSmanualtout + SIZEmanualtout )
#define     SIZEwaittout        sizeof( unsigned long )
#define SIZEtimeouts            ( OFFSwaittout + SIZEwaittout )

#define OFFSeescratcharry       ByteAlign( OFFStimeouts + SIZEtimeouts )
#define SIZEeescratcharry       ( _MAXEESCRATCHARRY )

#define OFFSidletimefont        ByteAlign(OFFSeescratcharry + SIZEeescratcharry)
#define SIZEidletimefont        ( _MAXIDLETIMEFONT )

#define OFFSstsstart            ByteAlign( OFFSidletimefont + SIZEidletimefont)
#define SIZEstsstart            sizeof( unsigned char )

#define OFFSsccbatch            ByteAlign( OFFSstsstart + SIZEstsstart)
#define SIZEsccbatch            ( _MAXSCCBATCH )

#define OFFSsccinter            ByteAlign( OFFSsccbatch + SIZEsccbatch )
#define SIZEsccinter            ( _MAXSCCINTER )

#define OFFSdplylistsize        LongAlign( OFFSsccinter + SIZEsccinter )
#define SIZEdplylistsize        sizeof( unsigned long )

#define OFFSfontcachesze        LongAlign(OFFSdplylistsize + SIZEdplylistsize)
#define SIZEfontcachesze        sizeof( unsigned long )

#define OFFSatalksize           LongAlign(OFFSfontcachesze + SIZEfontcachesze)
#define SIZEatalksize           sizeof( unsigned long )

#define OFFSdostartpage         ByteAlign( OFFSatalksize + SIZEatalksize )
#define SIZEdostartpage         sizeof( unsigned char )

#define OFFShwiomode            ByteAlign( OFFSdostartpage + SIZEdostartpage )
#define SIZEhwiomode            sizeof( unsigned char )

#define OFFSswiomode            ByteAlign( OFFShwiomode + SIZEhwiomode )
#define SIZEswiomode            sizeof( unsigned char )

#define OFFSpagestckorder       ByteAlign( OFFSswiomode + SIZEswiomode )
#define SIZEpagestckorder       sizeof( unsigned char )

#define OFFSreserve             ByteAlign( OFFSpagestckorder+SIZEpagestckorder)
#define SIZEreserve             ( MAXEEPROMSIZE - OFFSreserve )

#else

#define OFFSmagicnum            ( 0 )
#define SIZEmagicnum            sizeof( unsigned long )

#define OFFSpassword            ( OFFSmagicnum + SIZEmagicnum )
#define SIZEpassword            sizeof( unsigned long )

#define OFFSpagecount           ( OFFSpassword + SIZEpassword )
#define SIZEpagecount           ( _MAXPAGECOUNT )

#define OFFSengparams           ( OFFSpagecount + SIZEpagecount )
#define     OFFSleftmargin      ( 0 )
#define     SIZEleftmargin      sizeof( unsigned long )
#define     OFFStopmargin       ( OFFSleftmargin + SIZEleftmargin )
#define     SIZEtopmargin       sizeof( unsigned long )
#define     OFFSpagetype        ( OFFStopmargin + SIZEtopmargin )
#define     SIZEpagetype        sizeof( unsigned char )
#define SIZEengparams           ( OFFSpagetype + SIZEpagetype )

#define OFFSserial25            ( OFFSengparams + SIZEengparams )
#define     OFFSbaud            ( 0 )
#define     SIZEbaud            sizeof( unsigned char )
#define     OFFSflowpari        ( OFFSbaud + SIZEbaud )
#define     SIZEflowpari        sizeof( unsigned char )
#define     OFFSstopdata        ( OFFSflowpari + SIZEflowpari )
#define     SIZEstopdata        sizeof( unsigned char )
#define SIZEserial              ( OFFSstopdata + SIZEstopdata )
#define OFFSserial9             ( OFFSserial25 + SIZEserial )

#define OFFSprname              ( OFFSserial9 + SIZEserial )
#define SIZEprname              ( _MAXPRNAMESIZE )

#define OFFStimeouts            ( OFFSprname + SIZEprname )
#define     OFFSjobtout         ( 0 )
#define     SIZEjobtout         sizeof( unsigned long )
#define     OFFSmanualtout      ( OFFSjobtout + SIZEjobtout )
#define     SIZEmanualtout      sizeof( unsigned long )
#define     OFFSwaittout        ( OFFSmanualtout + SIZEmanualtout )
#define     SIZEwaittout        sizeof( unsigned long )
#define SIZEtimeouts            ( OFFSwaittout + SIZEwaittout )

#define OFFSeescratcharry       ( OFFStimeouts + SIZEtimeouts )
#define SIZEeescratcharry       ( _MAXEESCRATCHARRY )

#define OFFSidletimefont        (OFFSeescratcharry + SIZEeescratcharry)
#define SIZEidletimefont        ( _MAXIDLETIMEFONT )

#define OFFSstsstart            ( OFFSidletimefont + SIZEidletimefont)
#define SIZEstsstart            sizeof( unsigned char )

#define OFFSsccbatch            ( OFFSstsstart + SIZEstsstart)
#define SIZEsccbatch            ( _MAXSCCBATCH )

#define OFFSsccinter            ( OFFSsccbatch + SIZEsccbatch )
#define SIZEsccinter            ( _MAXSCCINTER )

#define OFFSdplylistsize        ( OFFSsccinter + SIZEsccinter )
#define SIZEdplylistsize        sizeof( unsigned long )

#define OFFSfontcachesze        (OFFSdplylistsize + SIZEdplylistsize)
#define SIZEfontcachesze        sizeof( unsigned long )

#define OFFSatalksize           (OFFSfontcachesze + SIZEfontcachesze)
#define SIZEatalksize           sizeof( unsigned long )

#define OFFSdostartpage         ( OFFSatalksize + SIZEatalksize )
#define SIZEdostartpage         sizeof( unsigned char )

#define OFFShwiomode            ( OFFSdostartpage + SIZEdostartpage )
#define SIZEhwiomode            sizeof( unsigned char )

#define OFFSswiomode            ( OFFShwiomode + SIZEhwiomode )
#define SIZEswiomode            sizeof( unsigned char )

#define OFFSpagestckorder       ( OFFSswiomode + SIZEswiomode )
#define SIZEpagestckorder       sizeof( unsigned char )

#define OFFSreserve             ( OFFSpagestckorder+SIZEpagestckorder)
#define SIZEreserve             ( MAXEEPROMSIZE - OFFSreserve )
#endif

/*
 * ---
 *  Physical Persistent Memory Initialization Values
 * ---
 */
#define ROMVAL  static
ROMVAL  unsigned long   INITmagicnum    = 0L;
ROMVAL  unsigned long   INITpassword    = 0L;
/* pagecount */
ROMVAL  unsigned long   INITleftmargin  = 0L;
ROMVAL  unsigned long   INITtopmargin   = 0L;
ROMVAL  unsigned char   INITpagetype    = 0;
ROMVAL  unsigned char   INITbaud25      = _B9600;
ROMVAL  unsigned char   INITflowpari25  = (_FXONXOFF << 4) | _PNONE;
ROMVAL  unsigned char   INITstopdata25  = (1 << 4) | 8;
ROMVAL  unsigned char   INITbaud9       = _B9600;
ROMVAL  unsigned char   INITflowpari9   = (_FXONXOFF << 4) | _PNONE;
ROMVAL  unsigned char   INITstopdata9   = (1 << 4) | 8;
ROMVAL  unsigned char   INITprname[]    = "\023MicroSoft TrueImage0.234567890.23";
ROMVAL  unsigned long   INITjobtout     = 0L;
ROMVAL  unsigned long   INITmanualtout  = 60L;
ROMVAL  unsigned long   INITwaittout    = 30L;
/* eescratcharray */
/* idletimefont */
ROMVAL  unsigned char   INITstsstart    = 0;
ROMVAL  unsigned char   INITsccbatch[]  = "\031\045\200\000\000\011\045\200\000\000";
ROMVAL  unsigned char   INITsccinter[]  = "\031\045\200\000\000\011\045\200\000\000";
ROMVAL  unsigned long   INITdplylssize  = 0L;
ROMVAL  unsigned long   INITfontcasze   = 0L;
ROMVAL  unsigned long   INITatalksize   = 0L;   /* ???? 0xff, 0, 0, 0 */
ROMVAL  unsigned char   INITdostartpage = 0x00;
ROMVAL  unsigned char   INIThwiomode    = 0;
ROMVAL  unsigned char   INITswiomode    = 0;
ROMVAL  unsigned char   INITpstckorder  = 0;

/*
 * ---
 *  RAM Copy of Physical Persistent Memory
 * ---
 */
static  unsigned char   pm_ramcopy[ MAXEEPROMSIZE ];

/* ..................................................................... */

static
void    ReloadFromROM()
{
    int     i;

    *(unsigned long FAR *)( &pm_ramcopy[ OFFSmagicnum ] )
        = INITmagicnum;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSpassword ] )
        = INITpassword;
    for (i = 0; i < _MAXPAGECOUNT; i++)
        pm_ramcopy[ OFFSpagecount + i ] = 0;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams + OFFSleftmargin ] )
        = INITleftmargin;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams + OFFStopmargin ] )
        = INITtopmargin;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSengparams + OFFSpagetype ] )
        = INITpagetype;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSbaud ] )
        = INITbaud25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSflowpari ] )
        = INITflowpari25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial25 + OFFSstopdata ] )
        = INITstopdata25;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSbaud ] )
        = INITbaud9;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSflowpari ] )
        = INITflowpari9;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSserial9 + OFFSstopdata ] )
        = INITstopdata9;
    lmemcpy( &pm_ramcopy[ OFFSprname ], INITprname, sizeof(INITprname) );/*@WIN*/
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSjobtout ] )
        = INITjobtout;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSmanualtout ] )
        = INITmanualtout;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] )
        = INITwaittout;
    for (i = 0; i < _MAXEESCRATCHARRY; i++)
        pm_ramcopy[ OFFSeescratcharry + i ] = 0;
    /* APPLE setting value */
    pm_ramcopy[ OFFSeescratcharry ] = 1;
    pm_ramcopy[ OFFSeescratcharry + 3 ] = 0x64;
    pm_ramcopy[ OFFSeescratcharry + 5 ] = 0x07;
    pm_ramcopy[ OFFSeescratcharry + 6 ] = 0xd0;
    for (i = 0; i < _MAXIDLETIMEFONT; i++)
        pm_ramcopy[ OFFSidletimefont + i ] = 0;
    *(unsigned char  FAR *)( &pm_ramcopy[ OFFSstsstart ] )
        = INITstsstart;
    lmemcpy( &pm_ramcopy[ OFFSsccbatch ], INITsccbatch, sizeof(INITsccbatch) );/*@WIN*/
    lmemcpy( &pm_ramcopy[ OFFSsccinter ], INITsccinter, sizeof(INITsccinter) );/*@WIN*/
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSdplylistsize ] )
        = INITdplylssize;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSfontcachesze ] )
        = INITfontcasze;
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] )
        = INITatalksize;
    /* APPLE setting value */
    *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] ) = 0xff;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSdostartpage ] )
        = INITdostartpage;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFShwiomode ] )
        = INIThwiomode;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSswiomode ] )
        = INITswiomode;
    *(unsigned char FAR *)( &pm_ramcopy[ OFFSpagestckorder ] )
        = INITpstckorder;
    for (i = 0; i < MAXEEPROMSIZE - OFFSreserve; i++)
        pm_ramcopy[ OFFSreserve + i ] = 0;
}

/* ..................................................................... */

/*
 * ---
 *  Byte Diff Bitmap (RAM Copy against Physical)
 * ---
 */

static unsigned char        PMDiffBitmap[ (MAXEEPROMSIZE + 7) / 8 ];
                            /* one bit per byte */

#define     ChkDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  &  ( 1 << ( offset % 8 ) )  )

#define     SetDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  |=  1 << ( offset % 8 )  )

#define     ClrDiff( offset )           \
            (  PMDiffBitmap[ offset / 8 ]  &=  ~( 1 << ( offset % 8 ) )  )

#define     SetAllDiff( setval )                    \
            (  memset( PMDiffBitmap,                \
                       setval? 0xFF : 0x00,         \
                       (MAXEEPROMSIZE + 7) / 8 )  )

/* ..................................................................... */

static
void    FlushOrUpdateRAMandMarkDiff( ramcopy_offs, checkvals, size, toflush )
    register unsigned   ramcopy_offs;
    char FAR *               checkvals;
    unsigned            size;
    int                 toflush;
{
    register unsigned char FAR *     ramcopy_ptr;
    unsigned        offset2;

    ramcopy_ptr = &pm_ramcopy[ ramcopy_offs ];
    for( offset2=0; offset2<size; offset2++, ramcopy_offs++ )
    {
        if( *ramcopy_ptr != (unsigned char)*checkvals )         //@WIN
        {
            *ramcopy_ptr = *checkvals;
            SetDiff( ramcopy_offs );
            if( toflush )
            {
                ClrDiff( ramcopy_offs );
#             ifdef REALEEPROM
                if(  EEPromOnLine
                  && EEPromWrite( ramcopy_offs, pm_ramcopy[ ramcopy_offs ] )
                        != NO_ERR )
                {
                    GEIsig_raise( GEISIGEEPROM, ramcopy_offs );
                }
#             endif /* !REALEEPROM */
            }
        }
        ramcopy_ptr++;
        checkvals++;
    }

    return;
}

/* ..................................................................... */

/*
 * ---
 *  Persistent Logical Segment Handler
 * ---
 */
#define     PMOP_READ       ( 0 )
#define     PMOP_WRITE      ( 1 )
#define     PMOP_FLUSH      ( 2 )

/* ..................................................................... */

static
void        pmop_password( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *(unsigned long FAR *)pmvals =
                    *(unsigned long FAR *)( &pm_ramcopy[ OFFSpassword ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpassword, pmvals, SIZEpassword, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_pagecount( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[OFFSpagecount], SIZEpagecount); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpagecount, pmvals, SIZEpagecount, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_engparams( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (engcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts+OFFSmanualtout ] );

        ( (engcfg_t FAR *)pmvals )->leftmargin =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams+OFFSleftmargin ] );
        ( (engcfg_t FAR *)pmvals )->topmargin  =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFSengparams+OFFStopmargin ] );
        ( (engcfg_t FAR *)pmvals )->pagetype   =
            *(unsigned char FAR *)( &pm_ramcopy[ OFFSengparams+OFFSpagetype ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts + OFFSwaittout,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->timeout ),
        SIZEwaittout,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFSleftmargin,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->leftmargin ),
        SIZEleftmargin,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFStopmargin,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->topmargin ),
        SIZEtopmargin,
        pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSengparams + OFFSpagetype,
        (char FAR *)&(( (engcfg_t FAR *)pmvals )->pagetype ),
        SIZEpagetype,
        pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_dostartpage( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSdostartpage ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSdostartpage, pmvals, SIZEdostartpage, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_serial( pmop, pmvals, pmid )
    int             pmop;
    char FAR *           pmvals;
    unsigned        pmid;
{
    unsigned        offset;
    unsigned char   serialpack[ SIZEserial ];

    offset = pmid == PMIDofSERIAL25? OFFSserial25 : OFFSserial9;

    if( pmop == PMOP_READ )
    {
        ( (serialcfg_t FAR *)pmvals )->timeout =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );

        ( (serialcfg_t FAR *)pmvals )->baudrate    =
                                    pm_ramcopy[ offset + OFFSbaud ];
        ( (serialcfg_t FAR *)pmvals )->flowcontrol =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSflowpari ] >> 4);
        ( (serialcfg_t FAR *)pmvals )->parity      =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSflowpari ] & 0x0F);
        ( (serialcfg_t FAR *)pmvals )->stopbits    =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSstopdata ] >> 4);
        ( (serialcfg_t FAR *)pmvals )->databits    =            //@WIN
                    (unsigned char)(pm_ramcopy[ offset + OFFSstopdata ] & 0x0F);
        return;
    }

    /* deal with waittimeout */
    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts + OFFSwaittout,
        (char FAR *)&(( (serialcfg_t FAR *)pmvals )->timeout),
        SIZEwaittout, pmop == PMOP_FLUSH );

    /* deal with baud, flow/parity, stop/data */
    serialpack[ OFFSbaud ]     = ( (serialcfg_t FAR *)pmvals )->baudrate;
    serialpack[ OFFSflowpari ] = (unsigned char)( ( (serialcfg_t FAR *)pmvals )->flowcontrol << 4 )
                                 | ( (serialcfg_t FAR *)pmvals )->parity; //@WIN
    serialpack[ OFFSstopdata ] = (unsigned char)( ( (serialcfg_t FAR *)pmvals )->stopbits << 4 )
                                 | ( (serialcfg_t FAR *)pmvals )->databits;//@WIN
    FlushOrUpdateRAMandMarkDiff(
        offset, serialpack, SIZEserial, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_prname( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSprname ],            /* @WIN */
                (unsigned)pm_ramcopy[ OFFSprname ] + 1 );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSprname, pmvals, (unsigned)pmvals[0] + 1, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_timeouts( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (toutcfg_t FAR *)pmvals )->jobtout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSjobtout ] );
        ( (toutcfg_t FAR *)pmvals )->manualtout =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSmanualtout ] );
        ( (toutcfg_t FAR *)pmvals )->waittout   =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSjobtout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->jobtout ),
        SIZEjobtout, pmop==PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSmanualtout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->manualtout ),
        SIZEjobtout, pmop==PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSwaittout,
        (char FAR *)&( ( (toutcfg_t FAR *)pmvals )->waittout ),
        SIZEwaittout, pmop==PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_parallel( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (parallelcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts + OFFSwaittout ] );
        return;
    }

    /* deal with waittimeout */
    FlushOrUpdateRAMandMarkDiff(
        OFFStimeouts+OFFSwaittout,
        (char FAR *)&(( (parallelcfg_t FAR *)pmvals )->timeout ),
        SIZEwaittout, pmop==PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_eescratcharry( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSeescratcharry ], SIZEeescratcharry); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSeescratcharry, pmvals, SIZEeescratcharry, pmop == PMOP_FLUSH
);

    return;
}

/* ..................................................................... */

static
void        pmop_idletimefont( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[ OFFSidletimefont ], SIZEidletimefont );/*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSidletimefont, pmvals, SIZEidletimefont, pmop == PMOP_FLUSH
);

    return;
}

/* ..................................................................... */

static
void        pmop_sccbatch( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals, &pm_ramcopy[ OFFSsccbatch ], SIZEsccbatch ); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSsccbatch, pmvals, SIZEsccbatch, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_sccinter( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        lmemcpy( pmvals,  &pm_ramcopy[ OFFSsccinter ], SIZEsccinter ); /*@WIN*/
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSsccinter, pmvals, SIZEsccinter, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_hwiomode( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFShwiomode ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFShwiomode, pmvals, SIZEhwiomode, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_swiomode( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSswiomode ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSswiomode, pmvals, SIZEswiomode, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_dplylistsize( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSdplylistsize ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSdplylistsize, pmvals, SIZEdplylistsize, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_fontcachesze( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSfontcachesze ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSfontcachesze, pmvals, SIZEfontcachesze, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_atalksize( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned long FAR *)pmvals ) =
                        *(unsigned long FAR *)( &pm_ramcopy[ OFFSatalksize ] );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSatalksize, pmvals, SIZEatalksize, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_stsstart( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSstsstart ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSstsstart, pmvals, SIZEstsstart, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_pagestckorder( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        *( (unsigned char FAR *)pmvals ) = pm_ramcopy[ OFFSpagestckorder ];
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSpagestckorder, pmvals, SIZEpagestckorder, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

static
void        pmop_atalk( pmop, pmvals )
    int             pmop;
    char FAR *           pmvals;
{
    if( pmop == PMOP_READ )
    {
        ( (atalkcfg_t FAR *)pmvals )->timeout    =
            *(unsigned long FAR *)( &pm_ramcopy[ OFFStimeouts+OFFSwaittout ] );

        lmemcpy( ( (atalkcfg_t FAR *)pmvals )->prname,          /*@WIN*/
                &pm_ramcopy[ OFFSprname ],
                (unsigned)pm_ramcopy[ OFFSprname ] + 1 );
        return;
    }

    FlushOrUpdateRAMandMarkDiff(
        OFFSwaittout,
        (char FAR *)&(( (atalkcfg_t FAR *)pmvals )->timeout),
        SIZEwaittout, pmop == PMOP_FLUSH );

    FlushOrUpdateRAMandMarkDiff(
        OFFSprname,
        ( (atalkcfg_t FAR *)pmvals )->prname,
        (unsigned)( (atalkcfg_t FAR *)pmvals )->prname[0] + 1, pmop == PMOP_FLUSH );

    return;
}

/* ..................................................................... */

/*
 * ---
 *  PMID and Its Operator Mapping
 * ---
 */
/* @WIN; move to top of the file */
//typedef
//    void    (*pmop_t)(int, char FAR *, unsigned /* pmop, vals, [pmid] */ );

typedef
    struct
    {
        unsigned        pmid;
        unsigned        pmsize;
        pmop_t          pmop;
    }
PMid2op_t;

static  PMid2op_t  PMid2opTbl[] =
    {
       { PMIDofPASSWORD,     SIZEpassword,         (pmop_t)pmop_password     },
       { PMIDofPAGECOUNT,    SIZEpagecount,        (pmop_t)pmop_pagecount    },
       { PMIDofPAGEPARAMS,   sizeof(engcfg_t),     (pmop_t)pmop_engparams    },
       { PMIDofSERIAL25,     sizeof(serialcfg_t),  (pmop_t)pmop_serial       },
       { PMIDofSERIAL9,      sizeof(serialcfg_t),  (pmop_t)pmop_serial       },
       { PMIDofPARALLEL,     sizeof(parallelcfg_t),(pmop_t)pmop_parallel     },
       { PMIDofPRNAME,       SIZEprname,           (pmop_t)pmop_prname       },
       { PMIDofTIMEOUTS,     SIZEtimeouts,         (pmop_t)pmop_timeouts     },
       { PMIDofEESCRATCHARRY,SIZEeescratcharry,    (pmop_t)pmop_eescratcharry},
       { PMIDofIDLETIMEFONT, SIZEidletimefont,     (pmop_t)pmop_idletimefont },
       { PMIDofSTSSTART,     SIZEstsstart,         (pmop_t)pmop_stsstart     },
       { PMIDofSCCBATCH,     SIZEsccbatch,         (pmop_t)pmop_sccbatch     },
       { PMIDofSCCINTER,     SIZEsccinter,         (pmop_t)pmop_sccinter     },
       { PMIDofDPLYLISTSIZE, SIZEdplylistsize,     (pmop_t)pmop_dplylistsize },
       { PMIDofFONTCACHESZE, SIZEfontcachesze,     (pmop_t)pmop_fontcachesze },
       { PMIDofATALKSIZE,    SIZEatalksize,        (pmop_t)pmop_atalksize    },
       { PMIDofDOSTARTPAGE,  SIZEdostartpage,      (pmop_t)pmop_dostartpage  },
       { PMIDofHWIOMODE,     SIZEhwiomode,         (pmop_t)pmop_hwiomode     },
       { PMIDofSWIOMODE,     SIZEswiomode,         (pmop_t)pmop_swiomode     },
       { PMIDofPAGESTCKORDER,SIZEpagestckorder,    (pmop_t)pmop_pagestckorder},
       { PMIDofATALK,        sizeof(atalkcfg_t),   (pmop_t)pmop_atalk        },
       { PMIDofRESERVE,      0,                    (pmop_t)NULL              }
    };

/* ..................................................................... */

static
pmop_t      findpmop( pmid, pmsize )
    unsigned        pmid;
    unsigned        pmsize;
{
    PMid2op_t FAR *      id2op;

    for( id2op=PMid2opTbl; id2op->pmid!=0; id2op++ )
        if( id2op->pmid == pmid )
            return( id2op->pmsize == pmsize? id2op->pmop : (pmop_t)NULL );

    return( (pmop_t)NULL );
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */
#ifndef WIN
int         GEIpm_read( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_READ, pmvals);
    return( TRUE );
}

/* ..................................................................... */

int         GEIpm_write( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_WRITE, pmvals);
    return( TRUE );
}

/* ..................................................................... */

int         GEIpm_flush( pmid, pmvals, pmsize )
    unsigned        pmid;
    char FAR *           pmvals;
    unsigned        pmsize;
{
    pmop_t          pmop;

    if( (pmop = findpmop( pmid, pmsize )) == (pmop_t)NULL )
    {
        GESseterror( EINVAL );
        return( FALSE );
    }

    (*pmop)( PMOP_FLUSH, pmvals);
    return( TRUE );
}

/* ..................................................................... */

void        GEIpm_flushall()
{

#ifdef REALEEPROM
    {
        register unsigned char FAR * diffbmp_p;
        register unsigned       ramcopy_offs, ii;

        if( !EEPromOnLine )
        {
            SetDiff( 0 );
            return;
        }

        diffbmp_p    = PMDiffBitmap;
        ramcopy_offs = 0;
        while( ramcopy_offs < MAXEERPOMSIZE )
        {
            if( *diffbmp_p == 0 )
            {
                ramcopy_offs += 8;
                diffbmp_p++;
                continue;
            }

            for( ii=0; ii<7; ii++ )
            {
                if( *diffbmp_p & ( 1 << ii ) )
                {
                    if( EEPromWrite( ramcopy_offs, pm_ramcopy[ ramcopy_offs ] )
                            != NO_ERR )
                        GEIsig_raise( GEISIGEEPROM, ramcopy_offs );
                    else
                        ClrDiff( ramcopy_offs );
                }

                if( ramcopy_offs++ >= MAXEEPROMSIZE )
                    break;
            }
            diffbmp_p++;
        }
    }
#endif

    return;
}
#endif

/* ..................................................................... */

void        GEIpm_reload()
{
    ReloadFromROM();

#ifdef REALEEPROM
    SetAllDiff( 1 );
    GEIpm_flushall();
#else
    SetAllDiff( 0 );
#endif
}

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */

static
void        GESpm_sighandler( sigid, sigcode )
    int         sigid;
    int         sigcode;
{
    GESseterror( EIO );
}

/* ..................................................................... */

#ifndef WIN
void            GESpm_init()
{
#ifdef REALEEPROM
    {
        register int                ramcopy_offs;
        register unsigned char FAR *     ramcopy_ptr;
        int                         checksum = 0;

        if( ( EEPromOnLine = ( EEPromTInit() == NO_ERR ) ) )
        {
            for( ramcopy_offs = 0, ramcopy_ptr = pm_ramcopy;
                 ramcopy_offs < MAXEEPROMSIZE;
                 ramcopy_offs++, ramcopy_ptr++ )
            {
                if( EEPromRead( ramcopy_offs, ramcopy_ptr ) != NO_ERR )
                {
                    GEIpm_reload();
                    return;
                }
                checksum = checksum + ( *ramcopy_ptr );
            }

            if ( checksum == EEPROM_CHECKSUM )
            {
                ReloadFromROM();
                SetAllDiff( 0 );
                return;
            }
        }
        GEIsig_signal( GEISIGEEPROM, GESpm_sighandler );
        SetAllDiff( 0 );
    }
#else /* REALEEPROM */
    {
        ReloadFromROM();
        SetAllDiff( 0 );
    }
#endif /* REALEEPROM */

    return;
}
#endif

/* ..................................................................... */

/* BYou (for temporary testing ???) */

#include        <string.h>
#include        "geiioctl.h"

typedef
    struct IOParams
    {
        char FAR *           devname;
        GEIioparams_t   ioparams;
    }
IOParams_t;

#ifdef  UNIX
IOParams_t      IOParamsTable[ 2 ] =
                {
                  {
                    "%SERIAL25%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%SERIAL9%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
#else
IOParams_t      IOParamsTable[ 3 ] =/* BE CONSISTENT WITH gesiocfg.def */
                {
                  {
                    "%SERIAL25%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%SERIAL9%",
                    {
                        _SERIAL,
                        { _B9600, _PNONE, 1, 8, _FXONXOFF }
                    }
                  }
                 ,{
                    "%PARALLEL%",
                    {
                        _PARALLEL,
                        { 0 }
                    }
                  }
              /* ,{
               *    "%APPLETALK%",
               *    {
               *        _APPLETALK,
               *        { ' ..... ' }
               *    }
               *  } */
#endif  /* UNIX */
                };

#ifndef WIN
int     GEIpm_ioparams_read( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    register IOParams_t FAR *    iop;

    for( iop=IOParamsTable; iop<&IOParamsTable[3]; iop++ )
        if( lstrcmp( iop->devname, channelname ) == 0 )         /*@WIN*/
        {
            *ioparams = iop->ioparams;
            return( TRUE );
        }

    return( FALSE );
}

int     GEIpm_ioparams_write( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    return( TRUE );
}

int     GEIpm_ioparams_flush( channelname, ioparams, isBatch )
    char FAR *           channelname;
    GEIioparams_t FAR *  ioparams;
    int             isBatch;
{
    return( TRUE );
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geiioctl.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIioctl.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/18/90    byou    completed all the possible definitions.
 *  10/22/90    byou    made GEIioparams a union structure.
 *  01/03/90    billlwo GEIiopararms subfield for AppleTalk was added
 * ---------------------------------------------------------------------
 */

#ifndef _GEIIOCTL_H_
#define _GEIIOCTL_H_

/*
 * ---
 * IO Device Parameters
 * ---
 */
#   define  _MAXPRNAMESIZE      ( 32 )  /* including a prefixed length byte */
#   define  ATTYPE_MAX_SIZE     ( 32 )  /* including a prefixed length byte */
#   define  ATZONE_MAX_SIZE      ( 2 )  /* including a prefixed length byte */
struct sioparams
{
    unsigned char       baudrate;   /* see below */
    unsigned char       parity;     /* see below */
    unsigned char       stopbits;   /* 1 or 2 */
    unsigned char       databits; /* 6(0), 7(1) or 8(2), 11/30/90 Jimmy */
    unsigned char       flowcontrol;/* see below */
};

typedef
    struct GEIioparams
    {
        unsigned char       protocol;   /* see below */
#ifdef  UNIX
        struct sioparams s;
#else
        union
        {
            struct sioparams s;
            struct pioparams
            {
                unsigned            reserved;
            }       p;
            struct aioparams
            {
                unsigned char       prname[ _MAXPRNAMESIZE ];  /* in pascal */
                unsigned char       atalktype[ ATTYPE_MAX_SIZE ];
                unsigned char       atalkzone[ ATZONE_MAX_SIZE ];

            }       a;
        }   u;
#endif  /* UNIX */
    }
GEIioparams_t;

struct dn_para_str {
        int dn;
        GEIioparams_t   para;
};

/* protocol definition */
#   define _SERIAL              ( 0 )
#   define _PARALLEL            ( 1 )
#   define _APPLETALK           ( 2 )
#   define _ETHERTALK           ( 3 )

/* baudrate_definition */
#   define _B110                ( 0 )
#   define _B300                ( 1 )
#   define _B600                ( 2 )
#   define _B1200               ( 3 )
#   define _B2400               ( 4 )
#   define _B4800               ( 5 )
#   define _B9600               ( 6 )
#   define _B19200              ( 7 )
#   define _B38400              ( 8 )
#   define _B57600              ( 9 )

/* parity definition */
#   define _PNONE               ( 0 )
#   define _PODD                ( 1 )
#   define _PEVEN               ( 2 )
#   define _PMARK               ( 3 )
#   define _PSPACE              ( 4 )

/* flowcontrol definition */
#   define _FXONXOFF            ( 0 )
#   define _FDTR                ( 1 )
#   define _FETXACK             ( 2 )

/* value for no wait-timeout event */
#   define _NOWAITTIMEOUT       ( 0L )

/*
 * ---
 * IOCTL Codes
 * ---
 */

#   define _FIONREAD            ( 1 )
#   define _FIONRESET           ( 2 )

#   define _GETIOPARAMS         ( 3 )
#   define _SETIOPARAMS         ( 4 )

#   define _GETIOCOOK           ( 5 )
#   define _SETIOCOOK           ( 6 )

#   define _ECHOEOF             ( 7 )

#   define _F_GETFL             ( 8 )
#   define _F_SETFL             ( 9 )

#   define _I_PUSH              ( 10 )
#   define _I_POP               ( 11 )
#   define _I_LOOK              ( 12 )

#endif /* !_GEIIOCTL_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geisig.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIsig.h
 *
 *  HISTORY:
 *  09/18/90    byou      created.
 *  01/07/91    billlwo   rename GEIseterror to GESseterror
 *                        hook ^C isr at the time of GESsig_init()
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"


#include    "winenv.h"                  /* @WIN */

#include    "geisig.h"
#include    "geierr.h"

#include    "gesmem.h"
#include    "gescfg.h"

#ifndef NULL
#define NULL    ( 0 )
#endif

typedef
    struct sigent
    {
        int             sig_state;      /* nonzero means busy */
        sighandler_t    sig_handler;
    }
sigent_t;

/* @WIN; add prototype */
void hook_interrupt(void);

static  sigent_t FAR *       SigTable;       /* allocated at init */
/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

sighandler_t    GEIsig_signal( sigid, newsighandler )
    int             sigid;
    sighandler_t    newsighandler;
{
    register sigent_t FAR *  sigentp;
    sighandler_t        oldsighandler;

    if( sigid < 0 || sigid >= MAXSIGS )
        return( GEISIG_IGN );

    oldsighandler = (sigentp = (SigTable + sigid))->sig_handler;
    sigentp->sig_handler = newsighandler;

    return( oldsighandler );
}

/* ..................................................................... */

void            GEIsig_raise( sigid, sigcode )
    int         sigid;
    int         sigcode;
{
    register sigent_t FAR *  sigentp;

    if( sigid < 0 || sigid >= MAXSIGS )
        return;

    if( (sigentp = (SigTable + sigid))->sig_state == 0 )
    {
        sigentp->sig_state = 1;
        if( sigentp->sig_handler != GEISIG_IGN )
            (*( sigentp->sig_handler ))( sigid, sigcode );
        sigentp->sig_state = 0;
    }
    return;
}

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */

void        GESsig_init()
{
    register sigent_t FAR *  sigentp;

    SigTable = (sigent_t FAR *)GESpalloc( MAXSIGS * sizeof(sigent_t) );
    if( SigTable == (sigent_t FAR *)NULL )
    {
        GESseterror( ENOMEM );
        return;
    }

    for( sigentp=SigTable; sigentp<( SigTable + MAXSIGS ); sigentp++ )
    {
        sigentp->sig_state   = 0;
        sigentp->sig_handler = GEISIG_IGN;
    }
    /* hook ^C isr - Bill */
    hook_interrupt();                   /* @WIN */
    GEIsig_signal(GEISIGINT, (sighandler_t)hook_interrupt);
}

/* ^C hook routine */
void hook_interrupt()
{
   extern short int_flag;
   int_flag=1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geitmr.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEItmr.h
 *
 *  HISTORY:
 *  09/18/89    you     created (modified from AppleTalk/TIO).
 * ---------------------------------------------------------------------
 */

#ifndef _GEITMR_H_
#define _GEITMR_H_

typedef
    struct GEItmr
    {
        unsigned int    timer_id;
        int             ( *handler )( struct GEItmr FAR * );
        long            interval;   /* in millisecond */
        long            remains;    /* in millisecond */
        char FAR *           private;
    }
GEItmr_t;

int /* bool */  GEItmr_start( GEItmr_t FAR * );
int /* bool */  GEItmr_reset( int /* timer_id */  );
int /* bool */  GEItmr_stop(  int /* timer_id */  );

void            GEItmr_reset_msclock(void);     /* @WIN */
unsigned long   GEItmr_read_msclock(void);      /* @WIN */

#endif /* _GEITMR_H_ */

/* @WIN; add prototype */
void GEStmr_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geisig.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEIsig.h
 *
 *  HISTORY:
 *  09/18/90    byou    created.
 *  01/14/91    bill    update SIGID starting sequence
 * ---------------------------------------------------------------------
 */

#ifndef _GEISIG_H_
#define _GEISIG_H_

#define     GEISIGINT       0  /* ID */
#define     GEISIGEEPROM    1
#define     GEISIGENG       2
#define     GEISIGFPE       3
#define     GEISIGSCC       4  /* when scc cmd received */
#define     GEISIGSTART     5  /* when dostartpage cmd received */
#define     GEISIGKILL      6  /* emulation switch */

typedef     void (*sighandler_t)(int, int /* sigid, sigcode */ );

#define     GEISIG_IGN      (sighandler_t)NULL
#define     GEISIG_DFL      ( GEISIG_IGN )


sighandler_t    GEIsig_signal(int, sighandler_t /* sigid, sighandler */ );
void            GEIsig_raise( int, int /* sigid, sigcode */ ); /* @WIN */

#endif /* !_GEISIG_H_ */

/* @WIN; add prototype */
void        GESsig_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\geitmr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEItmr.c
 *
 *  HISTORY:
 *  09/18/89    you     created (modified from AppleTalk/TIO).
 * ---------------------------------------------------------------------
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <stdio.h>
#include    "geitmr.h"
#include    "geierr.h"

#include    "gescfg.h"
#include    "gesmem.h"


extern      unsigned    GEPtickisr_init();  /* returns millisec per tick */

#ifndef NULL
#define NULL        ( 0 )
#endif

#define TRUE        1
#define FALSE       0

/*
 * ---
 *  Timer Table
 * ---
 */
typedef
    struct tment
    {
        GEItmr_t FAR *       tmr_p;
        unsigned        state;
#define                 TMENT_LOCK      ( 00001 )
#define                 TMENT_TOUT      ( 00002 )
#define                 TMENT_BUSY      ( 00004 )
#define                 TMENT_FREE      ( 00010 )
    }
tment_t;


static  tment_t FAR *        TimerTable = (tment_t FAR *)NULL;

static  tment_t FAR *        HighestMark = (tment_t FAR *)NULL;
                        /* highest entry of those running timers */

static  unsigned long   CountMSec = 0L;

static  unsigned        MSecPerTick = 0;

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */
#ifdef  PCL
unsigned char PCL_TT[ MAXTIMERS * sizeof(tment_t) ];
#endif
/* ..................................................................... */

void            GEStmr_init()
{
    register tment_t FAR *   tmentp;
#ifndef PCL
    TimerTable = (tment_t FAR *)GESpalloc( MAXTIMERS * sizeof(tment_t) );
#else
    TimerTable = (tment_t FAR *) &PCL_TT[0];
#endif
    if( TimerTable == (tment_t FAR *)NULL )
    {
        GEIerrno = ENOMEM;
        return;
    }

    for( tmentp=TimerTable; tmentp<( TimerTable + MAXTIMERS ); tmentp++ )
    {
        tmentp->tmr_p = (GEItmr_t FAR *)NULL;
        tmentp->state = TMENT_FREE;
    }

    HighestMark = TimerTable - 1;

    CountMSec = 0L;

#ifdef  UNIX
    MSecPerTick = 0;
#else
    MSecPerTick = GEPtickisr_init();
#endif  /* UNIX */
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

int         GEItmr_start( tmr )
    GEItmr_t FAR *       tmr;
{
    register tment_t FAR *   tmentp;
             int        tmrid;

    for( tmentp=TimerTable, tmrid=0; tmrid<MAXTIMERS; tmentp++, tmrid++ )
    {
        if( tmentp->state == TMENT_FREE )
        {
            tmr->timer_id = tmrid;
            tmr->remains  = tmr->interval;

            tmentp->state = TMENT_LOCK;
            tmentp->tmr_p = tmr;

            if( tmentp > HighestMark )
                HighestMark = tmentp;

            return( TRUE );
        }
    }

    return( FALSE );
}

/* ..................................................................... */

int         GEItmr_reset( tmrid )
    int     tmrid;
{
    register tment_t FAR *   tmentp;
    unsigned            oldstate;

    if( tmrid < 0  ||  tmrid >= MAXTIMERS )
        return( FALSE );

    tmentp = TimerTable + tmrid;

    if( (oldstate = tmentp->state) & TMENT_FREE )
        return( FALSE );

/*  tmentp->state = TMENT_LOCK;  */
    tmentp->tmr_p->remains = tmentp->tmr_p->interval;
    tmentp->state = oldstate & ~TMENT_TOUT;

    return( TRUE );
}

/* ..................................................................... */

int         GEItmr_stop( tmrid )
    int     tmrid;
{
    register tment_t FAR *   tmentp;

    if( tmrid < 0  ||  tmrid >= MAXTIMERS )
        return( FALSE );

    tmentp = TimerTable + tmrid;

/*  tmentp->state = TMENT_FREE | TMENT_LOCK; */
    tmentp->tmr_p = (GEItmr_t FAR *)NULL;
    tmentp->state = TMENT_FREE;

    if( tmentp == HighestMark )
    {
        while( (--tmentp) >= TimerTable )
            if( !(tmentp->state & TMENT_FREE) )
                break;
        HighestMark = tmentp;
    }

    return( TRUE );
}

/* ..................................................................... */

void        GEItmr_reset_msclock()
{
    CountMSec = 0L;
}

/* ..................................................................... */
//extern  unsigned    CyclesPerMs;          /* Jun-19,91 YM */  @WIN
//extern  unsigned    GetTimerInterval();   /* Jun-19,91 YM */  @WIN

unsigned long   GEItmr_read_msclock()
{
/*  return( CountMSec )         YM Jun-19,91 */
//    return( CountMSec + 10 - GetTimerInterval()/CyclesPerMs ); @WIN
    return( CountMSec );                /* @WIN */
}

/* ..................................................................... */

/*
 * ---
 *  Tick Interrupt Driven Routines
 * ---
 */
/* ..................................................................... */

int         GEStmr_counttick()
{
    register tment_t FAR *   tmentp;
    int         anytimeout;

    CountMSec += MSecPerTick;
    anytimeout = FALSE;
    for( tmentp=TimerTable; tmentp<=HighestMark; tmentp++ )
    {
        if( !(tmentp->state & TMENT_FREE) )
        {
            if( (tmentp->tmr_p->remains -= MSecPerTick) < 0 )
            {
                anytimeout = TRUE;
                tmentp->state |= TMENT_TOUT;
            }
        }
    }

    return( anytimeout );
}

/* ..................................................................... */

void        GEStmr_timeout()
{
    static  unsigned    SemaCount = 0;  /* for critical region */
    register tment_t FAR *   tmentp;

    if( SemaCount )
        return;

    for( tmentp=TimerTable; tmentp<=HighestMark; tmentp++ )
    {
        ++SemaCount;

        if( !(tmentp->state & TMENT_TOUT ))
        {
            --SemaCount;
        }
        else    /* timed out */
        {
            tmentp->state |= TMENT_BUSY;

            --SemaCount;

            if( (*( tmentp->tmr_p->handler ))( tmentp->tmr_p ) && ++SemaCount )
            {   /* to continue this timer */

                tmentp->tmr_p->remains = tmentp->tmr_p->interval;
                tmentp->state &= (unsigned)~(TMENT_TOUT | TMENT_BUSY);
                --SemaCount;
            }
            else
            {   /* to stop this timer */

                tmentp->state = TMENT_FREE;
/*              tmentp->tmr_p = (GEItmr_t FAR *)NULL;     */

                --SemaCount;

                if( tmentp == HighestMark )
                {
                    while( (--tmentp) >= TimerTable )
                        if( (!tmentp->state & TMENT_FREE) )
                            break;
                    HighestMark = tmentp;
                }
            }
        }
    }

    return;
}

/* ..................................................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gescfg.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GEScfg.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/17/90    byou    removed 'devtype' from GESiocfg_t.
 *                      removed 'devtype' parameter from GESiocfg_devnumfind.
 *  10/22/90    byou    removed 'GESiocfg_nextalt()'.
 *                      removed 'devpmid' from GESiocfg_t.
 *  01/14/91    bill    update MAXSIGS
 * ---------------------------------------------------------------------
 */

#ifndef _GESCFG_H_
#define _GESCFG_H_

#include    "geiioctl.h"
#include    "gesdev.h"

/*
 * ---------------------------------------------------------------------
 *  System Capability Parameters
 * ---------------------------------------------------------------------
 */

#ifdef  UNIX
#undef          PANEL
#undef          DIPSWITCH
/* #undef          REALEEPROM */
#define         FILESYS
#else
#define         PANEL
#undef          DIPSWITCH
#undef          REALEEPROM
#undef          FILESYS
#endif  /* UNIX */

/*
 * ---------------------------------------------------------------------
 *  System Limitation Parameters
 * ---------------------------------------------------------------------
 */
#define     MAXSIGS         ( 10)       /* 5, jimmy , be consistent with GEIsig.h */

#define     MAXTIMERS       ( 15 )      /* subject to change */

#define     MAXEEPROMSIZE   ( 512 )     /* size of physical eeprom */

#define     MAXFILES        ( 20 )      /* subject to change */
#define     MAXFMODQS       ( 10 )      /* max number of fmodq per file */

#define     MAXFBUFSIZE     ( 128 )     /* typical size of f_buffer */
#define     MAXUNGETCSIZE   ( 2 )       /* typical extra size of ungetc */

#define     MAXIBUFSIZE     ( 4 * 1024 )/* typical size of io buffer */
#define     MAXOBUFSIZE     ( 512 )

#define     MAXSTATUSLEN    ( 128 )     /* typical max length of status */

/*
 * ---------------------------------------------------------------------
 * Major/Minor Device Number Assignment
 * ---------------------------------------------------------------------
 */
#define     MAJserial           ( _SERIAL )
#define       NMINserial        ( 2 )       /* two serial ports */
#define         MINserial25         ( 0 )
#define         MINserial9          ( 1 )

#ifdef  UNIX
#define     MAJparallel         ( _PARALLEL )
#define       NMINparallel      ( 0 )       /* one parallel port */
#define         MINparallel         ( -1 )
#else
#define     MAJparallel         ( _PARALLEL )
#define       NMINparallel      ( 1 )       /* one parallel port */
#define         MINparallel         ( 0 )
#endif  /* UNIX */

#ifdef  UNIX
#define     MAJatalk            ( _APPLETALK )
#define       NMINatalk         ( 0 )
#define         MINatalk            ( -1 )
#else
/* add by Falco for enable/disable AppleTalk, 04/16/91 */
#define     MAJatalk            ( _APPLETALK )
#ifdef  NO_ATK
#define       NMINatalk         ( 0 )
#define         MINatalk            ( -1 )
#else
#define       NMINatalk         ( 1 )
#define         MINatalk            ( 0 )
#endif
/* add end */
#endif
#define     MAJetalk            ( _ETHERTALK )
#define       NMINetalk         ( 0 )       /* not supported now */
#define         MINetalk            ( -1 )

#define     MAXIODEVICES        ( NMINserial+NMINparallel+NMINatalk+NMINetalk )

/* debug channel for printf (to 'undef' on SUN or others having 'printf' */
#ifdef  UNIX
#undef  DBGDEV
#else
#define     DBGDEV              MAKEdev( MAJserial, MINserial25 )
#endif  /* UNIX */

/* to write thru DBGDEV for parallel output if defined */
/* #define     DBG_DEV */

/*
 * ---------------------------------------------------------------------
 * IO Configuration Parameters
 * ---------------------------------------------------------------------
 */

typedef
    struct GESiocfg
    {
        char FAR *           devname;
        short           devnum;         /* major | minor */
    }
GESiocfg_t;

typedef
    struct GESiosyscfg
    {
        GESiocfg_t      iocfg;
        int             nextalt;
        int             sccchannel;     /* for scc stuff */
        int             state;
#                           define  BADDEV      -1
#                           define  GOODDEV     0
#                           define  OPENED      1
        int             (*diag)( void/* minordev */ );
    }
GESiosyscfg_t;

/*
 * ---------------------------------------------------------------------
 *  Interface Routines
 * ---------------------------------------------------------------------
 */
/* @WIN; add prototype */
GESiocfg_t FAR *     GESiocfg_defaultdev(void);
GESiocfg_t FAR *     GESiocfg_namefind(char FAR *, unsigned);
GESiocfg_t FAR *     GESiocfg_devnumfind(int /* devnum */ );
GESiocfg_t FAR *     GESiocfg_getiocfg(int /* iocfg_index */ );


#endif /* !_GESCFG_H_ */

/* requested by MTK */
/* @WIN; add prototype */
extern void  GEPserial_sleep(void);
extern void  GEPparallel_sleep(void);
extern void  GEPatalk_sleep(void);
extern void  GEPserial_wakeup(void);
extern void  GEPparallel_wakeup(void);
extern void  GEPatalk_wakeup(void);
extern void  GESiocfg_init(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesevent.h ===
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESevent.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GESEVENT_H_
#define _GESEVENT_H_

/*
 * ---
 *  Event ID Assignment
 * ---
 */
#define     EVIDofKILL              ( 00001 )

/*
 * ---
 *  Event Manipulation Macros
 * ---
 */

volatile    extern  unsigned long       GESeventword;
volatile    extern  unsigned long       GESeventmask;

#define     GESevent_set(eid)           ( GESeventword |=  (eid) )
#define     GESevent_clear(eid)         ( GESeventword &= ~(eid) )
#define     GESevent_isset(eid)         ( GESeventword & (eid) )

#define     GESevent_anypending()    ( GESeventword & GESeventmask )
#define     GESevent_clearall()         ( GESeventword = GESeventmask = 0L )

#define     GESevent_setdoing(eid)      ( GESeventmask |=  (eid) )
#define     GESevent_setdone(eid)       ( GESeventmask &= ~(eid) )
#define     GESevent_isdoing(eid)       ( GESeventmask & (eid) )

typedef     void    (*evhandler_t)();

evhandler_t         GESevent_sethandler( /* eventid, eventhandler */ );
void                GESevent_processing();

#endif /* _GESEVENT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesdev.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESdev.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 *  10/17/90    byou    removed all about block devices.
 *  10/18/90    byou    revised CDEV_ macros.
 *  11/19/90    jimmy   move GEStty_t from gesdev.c
 *  01/07/91    billlwo rename c_XXXX to x_XXXX in GESDEV[] definition
 *                      for generic reason.
 * ---------------------------------------------------------------------
 */

#ifndef _GESDEV_H_
#define _GESDEV_H_

#ifdef  UNIX
#define volatile
#endif  /* UNIX */

/*
 * ----------------------------------------------------------------
 * Status Obtaining And Interrupt Signaling
 * ----------------------------------------------------------------
 */
// void        GESio_obtainstatus();
// @WIN; already defined in geiio.h

void        GESio_interrupt(int /* devnum */ );       /*@WIN; add prototype*/

/*
 * ----------------------------------------------------------------
 *  Device Number
 * ----------------------------------------------------------------
 */
#   define  MAJdev( dev )           ( ( 0xFF00 & (dev) ) >> 8 )
#   define  MINdev( dev )           ( 0x00FF & (dev) )
#   define  MAKEdev( major, minor ) ( (0xFF & (major))<<8 | (0xFF & (minor)) )

/*
 * ----------------------------------------------------------------
 *  NullDev and NoDev
 * ----------------------------------------------------------------
 */
int         nulldev();
int         nodev();

/*
 * ----------------------------------------------------------------
 *  Character Device Switch Table
 * ----------------------------------------------------------------
 */
/* @WIN; add prototype */
typedef
    struct GEScdev
    {
        unsigned x_flag;     /* reserved for future use */
        int     (*x_open)  (int /* dev.minor */ );
        int     (*x_close) (int /* dev.minor */ );
        int     (*x_read)  (int, char FAR *, int, int/* dev.minor, buf, size, mode */ );
        int     (*x_write) (int, char FAR *, int, int/* dev.minor, buf, size, mode */ );
        int     (*x_ioctl) (int, int, int FAR * /* dev.minor, request, *arg */ );
} GEScdev_t;
extern          GEScdev_t       GEScdevsw[];

#define         CDEV_OPEN(d)        \
                    ( *GEScdevsw[ MAJdev(d) ].x_open  )( MINdev(d) )
#define         CDEV_CLOSE(d)       \
                    ( *GEScdevsw[ MAJdev(d) ].x_close )( MINdev(d) )
#define         CDEV_READ(d,b,s,m)  \
                    ( *GEScdevsw[ MAJdev(d) ].x_read  )( MINdev(d), b, s, m )
#define         CDEV_WRITE(d,b,s,m) \
                    ( *GEScdevsw[ MAJdev(d) ].x_write )( MINdev(d), b, s, m )
#define         CDEV_IOCTL(d,r,a) \
                    ( *GEScdevsw[ MAJdev(d) ].x_ioctl )( MINdev(d), r, a )

typedef
    struct GEStty
    {
        /* device open count */
        int             tt_count;
        /* input buffer */
        char FAR *      tt_ibuf;
        int             tt_isiz;
        int             tt_iget;
        int             tt_iput;
/* Bill 04/03/91 remove it*/
/* volatile int            tt_icnt; */
        int             tt_himark;
        int             tt_lomark;
        /* output buffer */
        char FAR *      tt_obuf;
        int             tt_osiz;
        int             tt_oget;
        int             tt_oput;
/* Bill 04/08/91 remove it*/
/* volatile int            tt_ocnt; */
        /* control flags */
volatile unsigned char  tt_iflag;
volatile unsigned char  tt_oflag;
volatile unsigned char  tt_cflag;
        /* characters for cooking */
        char            tt_interrupt;   /* ^C */
        char            tt_status;      /* ^T */
        char            tt_eof;         /* ^D */
        /* device parameters */
        GEIioparams_t   tt_params;      /* the structure depends on tty type */
    }
GEStty_t;

#   define _TT_I_BLOCK      ( 00001 )   /* input exceeding high water mark */
#   define _TT_I_EOF        ( 00002 )   /* input EOF received */
#   define _TT_I_ERR        ( 00004 )   /* input buffer overflows */
#   define _TT_O_BLOCK      ( 00001 )   /* output blocked by a peer XOFF */
#   define _TT_O_XMTING     ( 00002 )   /* being transmitting */
#   define _TT_O_CTRL_T     ( 00004 )   /* ^T pressed flag */
#   define _TT_C_PROTOMASK  ( 00007 )   /* protocol mask */
#   define _TT_C_XONXOFF    ( 00001 )   /* Xon/Xoff? */
#   define _TT_C_ETXACK     ( 00002 )   /* ETX/ACK? (not implemented) */
#   define _TT_C_DTR        ( 00004 )   /* DTR? */
#   define _TT_C_COOK       ( 00010 )   /* cook mode? */
#endif /* !_GESDEV_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesfs.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
#ifdef  FILESYS
extern  int     copen();
extern  int     cclose();
extern  int     cread();
extern  int     cwrite();
extern  int     cioctl();
extern  int     nodev();
#endif

/* @WIN; add prototype */
int     GESfs_open(char FAR *,int,int);
int     GESfs_close(int);
int     GESfs_read(int, char FAR *, int);
int     GESfs_write(int, char FAR *, int);
int     GESfs_ioctl(int, int, int FAR *);
int     GESfs_init(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesfs.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* @WIN */
#define INTEL



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

char FAR * WinBuffer=0L;                   /* @WIN */
// DJC removed PSTR (FAR *lpWinRead)(void);

#ifdef  DBG
#define DEBUG(format, data)        (printf(format, data)) ;
#else
#define DEBUG(format, data)
#endif

#ifdef  INTEL
#include        <stdio.h>
#endif
#include        "geiio.h"
#include        "geierr.h"
#include        "geiioctl.h"
#include        "gesmem.h"
#include        "gescfg.h"
#include        "gesdev.h"
#include        "gesfs.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WIN; add prototype */
int c_write( int min, char FAR * buf, int size, int mod);

extern          int     errno;

int     GESfs_open( filename, namelen, flags )
    char FAR *   filename;
    int     namelen;
    int     flags;
{
    int     fd;

    if (namelen <= 0) {
        GESseterror(ENOENT);
        printf("error length\n");
        return EOF;
    }

    if (!(flags &= (_O_RDONLY | _O_WRONLY))) {
        GESseterror(ENOENT);
        printf("error flags\n");
        return EOF;
    }

    flags &= (_O_RDONLY | _O_WRONLY);   /* ignore others for SUN test */

    /* erik chen, 10-10-1990 */
    filename[namelen] = '\0';

    switch(flags) {
        case _O_RDONLY:
                errno = 0;
                //fd = open(filename, 0); /* O_RDONLY + O_BINARY 0x80000 */
                DEBUG("open %s\n", filename)
                fd = 1;
                break;
        case _O_WRONLY:
                errno = 0;
                //fd = creat(filename, 0644);
                DEBUG("creat %s\n", filename)
                fd = 1;
                /* O_WRONLY | O_CREATE | O_TRUNC */
                break;
        case _O_RDWR:                           /* ignore currently */
        case _O_APPEND:
        case _O_NDELAY:
        case _O_SYNC:
        case _O_TRUNC:
        case _O_CREAT:
        case _O_EXCL:
        default:
                fd = -1;
    }
    return (fd == -1 ? EOF : fd);
}

int     GESfs_close( handle )
    int         handle;
{
    if (handle == -1) {
        GESseterror(ENOENT);
#ifdef  DEBUG
        printf("file stream is not opened\n");
#endif
        return EOF;
    }

    errno = 0;
    //close(handle);
    DEBUG("close handle %d\n", handle)
    return 0;
}


int     GESfs_read( handle, buf, nleft )
    int                 handle;
    char FAR *               buf;
    int                 nleft;
{
    int         ret_val;

    if (nleft < 0) {
        GESseterror(ENOSR);
#ifdef  DEBUG
        printf("size of file > 16 K.. ignore\n");
#endif
        return EOF;
    }

    errno = 0;
    //ret_val = fread(buf, nleft, 1, 0);
    DEBUG("read %d bytes\n", nleft)
    for (ret_val = 0; (ret_val<nleft) && (*WinBuffer); ret_val ++) {
        buf[ret_val] = *WinBuffer++;
    }

    if (ret_val)
        return( ret_val );
    else
        return EOF;
}

int     GESfs_write( handle, buf, nleft )
    int                 handle;
    char FAR *               buf;
    int                 nleft;
{
    int i;      // @WIN

#ifdef  DEBUG
        printf("enter GESfs_write\n");
#endif

    if (nleft < 0) {
        GESseterror(ENOSR);
#ifdef  DEBUG
        printf("size of file > 16 K.. ignore\n");
#endif
        return EOF;
    }

    errno = 0;
    //return write(handle, buf, nleft);
    DEBUG("write %d bytes\n", nleft)
    for (i=0; i<nleft; i++) {
        printf("%c", buf[i]);
    }

    return(nleft);
}

int     GESfs_ioctl( handle, req, arg /*, mode*/ )
    int                 handle;
    int                 req;
    int                  FAR *arg;
//  unsigned            mode;                           @WIN
{
//  int                 retval;         @WIN

    GESseterror( ENOTTY );
    return( EOF );
}

int     GESfs_init()
{
        return 0;
}

/* --------------------------------------------------------------------- */

#ifdef UNIX
#ifndef INTEL
#include        <fcntl.h>
#endif
#endif

static          int     fd = EOF;

int         nulldev()
{
    return 0;
}
#ifdef DJC
int   nodev()
{
    GESseterror( ENODEV );
    return EOF;
}
#endif


//DJC begin add new prototypes to get rid of warnings
int nd_open( int min)
{
   GESseterror(ENODEV );
   return(EOF);
}


int     nd_read(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{
    fd = EOF;
    *buf = '\0';
    return(0);
}



int     nd_write(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{

   return(size);
}


int     nd_ioctl(min, req, arg)
int     min;
int     req;
int FAR *   arg;
{

   GESseterror( ENOTTY );
   return( EOF );
}
//DJC end









int         GEPserial_diagnostic()
{
    return TRUE;
}
int         GEPparallel_diagnostic()
{
    return TRUE;
}


//DJC int     c_open(min, mod)
int     c_open(min)
int     min;
//DJC int     mod;
{
        return 0;
}
int     c_close(min)
int     min;
{
        return 0;
}

int     c_read(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{
	extern int PsStdinGetC(unsigned char *);
   unsigned char uc;
   int iRet;

   //
   // PsStdinGet()
   // returns -1 if EOF encountered... if -1 is returned
   // the character will be '\0';
   // otherwise returns 0
	
	// DJC complete rewrite to support pstodib() stuff
   iRet = PsStdinGetC(&uc);


   if (iRet == -1) {
      fd = EOF;
      *buf = '\0';
      return(0);
   }


   *buf = uc;


   // DJC test TEST add for frank so we actually read cntrl d's
   if ( (*buf == 0x04) &&
       !(dwGlobalPsToDibFlags & PSTODIBFLAGS_INTERPRET_BINARY)) {
      fd = EOF;
      return(0);
   }


   return(1);
}    	

int     c_write(min, buf, size, mod)
int     min;
char FAR *   buf;
int     size;
int     mod;
{

   extern void PsStdoutPutC(unsigned char);

   // DJC complete re-write for PStoDib stuff
   int   x;

   for (x = 0; x < size ; x++ ) {
      PsStdoutPutC(*buf++);
   }
   return(size);
}



//DJC int     c_ioctl(min, req, arg, mod)
int     c_ioctl(min, req, arg)
int     min;
int     req;
int FAR *   arg;
//DJC int     mod;
{
static  char    control_d[] = { '^', 'D' };

    switch( req )
    {
    case _I_PUSH:
    case _I_POP:
    case _I_LOOK:
    case _F_GETFL:
    case _F_SETFL:
        GESseterror( ENOTTY );
        return( EOF );

    case _ECHOEOF:
        return( c_write( 0, control_d, sizeof(control_d), _O_SYNC ) );
    case _GETIOCOOK:
    case _SETIOCOOK:
    case _GETIOPARAMS:
    case _SETIOPARAMS:
        return( 0 );

    case _FIONREAD:
        *arg = 1;
        return( 0 );
    case _FIONRESET:
        return( 0 );
    }

    if( GEIerror() != EZERO )
        GESseterror( ENOTTY );
    return( EOF );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesmem.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESmem.h
 *
 *  HISTORY:
 *  09/13/90    byou    created.
 * ---------------------------------------------------------------------
 */

#ifndef _GESMEM_H_
#define _GESMEM_H_

unsigned GESmemavail(void);  /* return # of bytes in the biggest free blk */

char FAR * GESpalloc(unsigned); /* permanent allocation */
char FAR * GESmalloc(unsigned);
void       GESfree(char FAR * /* address_of_space_to_be_freed */ );

#endif /* !_GESMEM_H_ */

/* @WIN; add prototype */
void GESmem_init(char FAR *, unsigned);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesmem.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESmem.c
 *
 *  COMPILATION SWITCHES:
 *
 *  HISTORY:
 *  09/19/90    byou    extracted from ANSI C.
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    "gesmem.h"

#ifndef NULL
#define NULL        ( 0 )
#endif

/*
 * ---
 *  Memory Block Header And Associated Static Vars
 * ---
 */
typedef
    union mblk
    {
        struct
        {
            union mblk FAR *     next;
            unsigned        size;   /* # of mblk_t */
        }       m;
        long    align;          /* force alignment on long boundary */
    }
mblk_t;

static  char FAR *       PoolBase = (char FAR *)NULL;
static  unsigned    PoolSize = 0;
static  mblk_t FAR *     HeadOfFree = (mblk_t FAR *)NULL;

#define     MBLK_RDUP(n)    (  ((n) + sizeof(mblk_t) - 1) / sizeof(mblk_t)  )
#define     MBLK_RDDN(n)    (  (n) / sizeof(mblk_t)  )
#define     NUMOFMBLK(n)    (  (n) / sizeof(mblk_t)  )

/* ..................................................................... */

/*
 * ---
 *  Initialization Code
 * ---
 */

/* ..................................................................... */
#define         MAXGESMEMSIZE   ( (unsigned)52 * 1024 )
unsigned        ext_mem=0;

void    GESmem_init( base, size )
    char FAR *       base;
    unsigned    size;
{
/*  char*       end = base + size;  Jimmy */

    if( size <= sizeof(mblk_t) )
        return;
    if (size > MAXGESMEMSIZE)
        ext_mem = size - MAXGESMEMSIZE;
    PoolBase = (char FAR *)( (mblk_t FAR *)base );
    PoolSize = NUMOFMBLK( size ) * sizeof(mblk_t);

    HeadOfFree = (mblk_t FAR *)PoolBase;

    HeadOfFree->m.next = (mblk_t FAR *)NULL;
    HeadOfFree->m.size = NUMOFMBLK( PoolSize );
}

/* ..................................................................... */

/*
 * ---
 *  Interface Routines
 * ---
 */

/* ..................................................................... */

unsigned        GESmemavail()
{
    register mblk_t      FAR *curr;
    unsigned            nbiggestmblk = 0;

    for( curr=HeadOfFree; curr!=(mblk_t FAR *)NULL; curr=curr->m.next )
        if( curr->m.size > nbiggestmblk )
            nbiggestmblk = curr->m.size;

    return(  nbiggestmblk==0?  0  :  (nbiggestmblk-1) * sizeof(mblk_t)  );
}

/* ..................................................................... */

char FAR *           GESpalloc( nbytes )
    unsigned    nbytes;
{
    unsigned    nmblks;

    if( PoolBase == (char FAR *)NULL  ||  HeadOfFree != (mblk_t FAR *)PoolBase )
        return( (char FAR *)NULL );

    nmblks = MBLK_RDUP( nbytes ) + 1;     /* yang */
    nbytes = nmblks * sizeof(mblk_t);

    if( nbytes > PoolSize )
        return( (char FAR *)NULL );

    PoolBase += nbytes;
    PoolSize -= nbytes;

    nmblks = HeadOfFree->m.size - nmblks;       /* # of free blks */
    HeadOfFree = (mblk_t FAR *)PoolBase;

    HeadOfFree->m.next = (mblk_t FAR *)NULL;
    HeadOfFree->m.size = nmblks;

    return( PoolBase - nbytes );
}

/* ..................................................................... */

char FAR *           GESmalloc( nbytes )
    unsigned    nbytes;
{
    register mblk_t      FAR *prev,  FAR *curr;
    unsigned            nmblks;

    nmblks = MBLK_RDUP( nbytes ) + 1;   /* extra one for mblk_t */

    for(  prev = (mblk_t FAR *)NULL, curr = HeadOfFree;
          curr != (mblk_t FAR *)NULL;
          prev = curr, curr = curr->m.next  )
    {
        if( curr->m.size == nmblks )
        {
            if( prev == (mblk_t FAR *)NULL )
                HeadOfFree = curr->m.next;
            else
                prev->m.next = curr->m.next;

            curr->m.next = (mblk_t FAR *)NULL;

            return( (char FAR *)( curr + 1 ) );
        }
        else if( curr->m.size > nmblks )
        {
            curr->m.size -= nmblks;

            curr += curr->m.size;
            curr->m.next = (mblk_t FAR *)NULL;
            curr->m.size = nmblks;
            return( (char FAR *)( curr + 1 ) );
        }
    }
    return( (char FAR *)NULL );
}

/* ..................................................................... */

void            GESfree( addr )
    char FAR *       addr;
{
    register mblk_t      FAR *tofree,  FAR *prev,  FAR *curr;
    unsigned            nmblks;

    tofree = (mblk_t FAR *)addr -  1;
    nmblks = tofree->m.size;

    /* have 'curr' stopped right after 'tofree', and 'prev' in front */
    for(  prev = (mblk_t FAR *)NULL, curr = HeadOfFree;
          curr != (mblk_t FAR *)NULL  &&  curr < tofree;
          prev = curr, curr = curr->m.next  )
    {};

    /* join to 'prev' if adjacent */
    if( prev != (mblk_t FAR *)NULL )
    {
        if( prev + prev->m.size == tofree )
        {
            prev->m.size += nmblks;
            tofree = prev;
        }
        else
        {
            tofree->m.next = prev->m.next;
            prev->m.next   = tofree;
        }
    }
    else
    {
        HeadOfFree = tofree;
    }

    /* join to 'curr' if adjacent */
    if( curr != (mblk_t FAR *)NULL )
    {
        if( tofree + nmblks == curr )
        {
            tofree->m.size += curr->m.size;
            tofree->m.next =  curr->m.next;
        }
        else
        {
            tofree->m.next = curr;
        }
    }

    return;
}

/* ..................................................................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\gesiocfg.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ---------------------------------------------------------------------
 *  FILE:   GESiocfg.c
 *
 *      1. IO device name, type, number, its persistent data and alternate.
 *      2. Interface Routines to the "iocfg" subcomponent.
 *      3. Refer to GEIpm.c for initialization parameters for each device.
 *
 *  HISTORY:
 *  09/16/90    byou    created.
 *  10/18/90    byou    removed all about 'devtype' and block devices.
 *  01/07/91    billlwo correct selectstdio() bug, add GESio_closeall()
 *  01/24/91    billlwo fixed selectstdios() bug in auto polling
 *  02/06/91    billlwo delete GESpanel_activeparams()
 * ---------------------------------------------------------------------
 */


// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */

#include    <string.h>

#include    "gescfg.h"

#include    "geiio.h"
#include    "geiioctl.h"
#include    "geipm.h"
#include    "geicfg.h"
#include    "geisig.h"
#include    "geierr.h"
//#include    "gep_pan.h"       @WIN
#ifndef UNIX
#include    "gesevent.h"
#endif  /* UNIX */

#include    "gesiocfg.def"

/* add for auto polling - 01/24/91 bill */
extern GEIFILE FAR * fin;
/* Bill */
void GEIio_sleep_others(short);
void GEIio_wakeup_others(short);
int sleep_flag=0;
/* Bill */

#ifdef MTK
void        pdl_no_process();
#endif
/* ..................................................................... */

/*
 * ---
 * Interface Routines
 * ---
 */

/* ..................................................................... */

char FAR *           GEIio_channelname( sccchannel )
    int             sccchannel;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if( iosyscfgp->sccchannel == sccchannel )
            return( iosyscfgp->state != BADDEV?
                    iosyscfgp->iocfg.devname : (char FAR *)NULL );

    return( (char FAR *)NULL );
}

/* ..................................................................... */

char FAR *           GEIio_channelnameforall( iodevidx )
    int             iodevidx;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    if( iodevidx >= 0 )
        for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
            if( iosyscfgp->state != BADDEV )
                if( --iodevidx < 0 )
                    return( iosyscfgp->iocfg.devname );

    return( (char FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_namefind( devname, namelen )
    char FAR *           devname;
    unsigned        namelen;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if(  namelen == (unsigned)lstrlen( iosyscfgp->iocfg.devname )  && /*@WIN*/
             lmemcmp( devname, iosyscfgp->iocfg.devname, namelen ) == 0  )/*@WIN*/
            return( iosyscfgp->state != BADDEV?
                    &( iosyscfgp->iocfg ) : (GESiocfg_t FAR *)NULL );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_devnumfind( devnum )
    int             devnum;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
        if(  iosyscfgp->iocfg.devnum == devnum  )
            return( iosyscfgp->state != BADDEV?
                    &( iosyscfgp->iocfg ) : (GESiocfg_t FAR *)NULL );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

GESiocfg_t FAR *     GESiocfg_getiocfg( iocfgidx )
    int             iocfgidx;
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    if( iocfgidx >= 0 )
        for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
            if( iosyscfgp->state != BADDEV )
                if( --iocfgidx < 0 )
                    return( &( iosyscfgp->iocfg ) );

    return( (GESiocfg_t FAR *)NULL );
}

/* ..................................................................... */

/*
 * ---
 *  active device selection
 * ---
 */

/* ..................................................................... */

GESiosyscfg_t FAR *      defaultdev = (GESiosyscfg_t FAR *)NULL;
GESiosyscfg_t FAR *      activedev  = (GESiosyscfg_t FAR *)NULL;

struct dn_para_str dn_para[MAXIODEVICES];
int GESpanel_defaultdev()
{
   return(MAKEdev(MAJserial, MINserial25));
}

void GESpanel_activeparams(dn,pp)
int  dn;
GEIioparams_t    FAR *pp;
{
int  i;
        i=0;
        while (TRUE) {
                if (dn==dn_para[i].dn) {
                        *pp=dn_para[i].para;
                        break;
                }
                else ++i;
        }
}
/* ..................................................................... */

GESiocfg_t FAR *   GESiocfg_defaultdev()
{
    if( defaultdev == (GESiosyscfg_t FAR *)NULL )
        GEIio_selectstdios();

    return( &( activedev->iocfg ) );
}

/* ..................................................................... */

/* SHOULD BE REMOVED SOME DAY !!! */

int         GEIio_selectstdios()
{
    register GESiosyscfg_t FAR * adev;
    GESiosyscfg_t FAR *          newdev;
    int                     defaultdevnum;
    GEIioparams_t           ioparams;

    int                     bytesavail;


/* Bill */
    if (sleep_flag==1) {
       GEIio_wakeup_others(activedev->iocfg.devnum);
       sleep_flag=0;
       }
/* Bill */
#ifndef UNIX
    /* process all pending events if any */
    if( GESevent_anypending() )
        GESevent_processing();
#endif  /* UNIX */

    /* locate the new default dev */
#ifdef  UNIX
    defaultdevnum = MAKEdev(MAJserial, MINserial25);
#else
#    ifdef PANEL
        defaultdevnum = GESpanel_defaultdev();
#ifdef MTK
        pdl_no_process();
#endif
        GEPpanel_change();    /* any parameters changed ? */
#    else /* i.e. DIPSWITCH */
        defaultdevnum = GESdipsw_defaultdev();
#    endif  /* PANEL */
#endif  /* UNIX */
    for( adev=GESiosyscfgs; adev<GESiosyscfgs_end; adev++ )
        if( adev->iocfg.devnum == defaultdevnum )
            break;
    newdev = adev;

    if( newdev != defaultdev )  /* default device changed? */
    {
        int     isDeviceChainChanged = TRUE;

        /* check if device chain changed */
        if( defaultdev != (GESiosyscfg_t FAR *)NULL )
        {
            adev = defaultdev;
            do
            {
                if( adev == newdev )
                {
                    isDeviceChainChanged = FALSE;
                    break;
                }
                adev = &GESiosyscfgs[ adev->nextalt ];

            }while( adev != defaultdev );
        }

        if( isDeviceChainChanged )
        {
            /* close the prior default driver and its chained alternates */
            if( (adev = defaultdev) != (GESiosyscfg_t FAR *)NULL )
            {
                do
                {
                    GEIclearerr();
                    if( adev->state == OPENED )
                    {
                        CDEV_CLOSE( adev->iocfg.devnum );
                        adev->state = GOODDEV;
                    }
                    adev = &GESiosyscfgs[ adev->nextalt ];

                }while( adev != defaultdev );
                GEIclearerr();
                fin= (GEIFILE FAR *)NULL;  /* 01/24/91 bill */
                GESio_closeall(); /* clear FileTable entries - Bill */
            }

            /* open the newly selected driver and its chained alternates */
            adev = newdev;
            do
            {
                if( adev->state == GOODDEV )
                {
                    GEIclearerr();
                    adev->state = OPENED;
                    CDEV_OPEN( adev->iocfg.devnum );
                }
                adev = &GESiosyscfgs[ adev->nextalt ];

            }while( adev != newdev );
            GEIclearerr();

            /* make the newly selected device become the default */
            defaultdev = newdev;
            activedev = newdev; /* initial active device  -- 01/24/91 bill */
        }
    }

    /* reload io params for all chained and opened devices */
    adev = defaultdev;
    do
    {
        if( adev->state == OPENED )
        {
            GEIclearerr();

/* 02/06/91 bill fixed bug about printername
 * #ifdef PANEL
 *             GESpanel_activeparams( adev->iocfg.devnum, &ioparams );
 * #else
 *             GEIpm_ioparams_read( adev->iocfg.devname, &ioparams, TRUE );
 * #endif
 */
            GEIpm_ioparams_read( adev->iocfg.devname, &ioparams, TRUE );

            CDEV_IOCTL(adev->iocfg.devnum, _SETIOPARAMS, (int FAR *)&ioparams); /*@WIN*/
        }
        adev = &GESiosyscfgs[ adev->nextalt ];

    }while( adev != defaultdev );
    GEIclearerr();

    /* see if any byte available on some candidate device */
    /* 01/24/91 billlwo for bug in auto polling*/
    /* last active channel take higher precedence */
    adev = activedev;  /* 02/28/91 temporary sol'n */
    if ((fin !=(GEIFILE FAR *)NULL) && (fin->f_fbuf->f_cnt > 0 )) {
       return( GEIio_forceopenstdios( _FORCESTDALL ) );
    } else {
    } /* endif */

    do
    {
        if( adev->state == OPENED )
        {

            if( CDEV_IOCTL( adev->iocfg.devnum, _FIONREAD, &bytesavail ) == EOF )
                bytesavail = 0;

            if( bytesavail > 0 )
            {
                activedev = adev;       /* set active device */
                /* Bill */
                GEIio_sleep_others(adev->iocfg.devnum);
                sleep_flag=1;
                /* Bill */
                return( GEIio_forceopenstdios( _FORCESTDALL ) );
            }
        }
        adev = &GESiosyscfgs[ adev->nextalt ];

    }while( adev != activedev ); /* 01/28/91 bill temporary sol'n*/

/*  activedev = defaultdev;     (* set default device as active device */
    return( FALSE );

}   /* GEIio_selectstdios */

/* ..................................................................... */

/*
 * ---
 * Initialization
 * ---
 */

/* ..................................................................... */

void        GESiocfg_init()
{
    register GESiosyscfg_t FAR *     iosyscfgp;

    /* diagnose on all devices */
    for( iosyscfgp=GESiosyscfgs; iosyscfgp<GESiosyscfgs_end; iosyscfgp++ )
    {
        if(  ( *(iosyscfgp->diag) )( /*MINdev( iosyscfgp->iocfg.devnum )*/ )  )
            iosyscfgp->state = GOODDEV;
        else
            iosyscfgp->state = BADDEV;
    }

    return;
}

void GEIio_sleep_others(devno)
short devno;
{
#ifdef  _AM29K
   if (devno != MAKEdev( MAJserial, MINserial25 ))
      GEPserial_sleep(MINserial25);
   if (devno != MAKEdev( MAJparallel, MINparallel ))
      GEPparallel_sleep(MINparallel);
   if (devno != MAKEdev( MAJatalk, MINatalk ))
      GEPatalk_sleep(MINatalk);
/* to be added someday */
/* GEPserial_sleep(MINserial9); */
#endif

}
void GEIio_wakeup_others(devno)
short devno;
{
#ifdef  _AM29K
   if (devno != MAKEdev( MAJserial, MINserial25 ))
      GEPserial_wakeup(MINserial25);
   if (devno != MAKEdev( MAJparallel, MINparallel ))
      GEPparallel_wakeup(MINparallel);
   if (devno != MAKEdev( MAJatalk, MINatalk ))
      GEPatalk_wakeup(MINatalk);
/* to be added someday */
/* GEPserial_wakeup(MINserial9); */
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\start.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* %W%, AMD */
/*************************************************************************
** start.h      STARTUP AND FUNDAMENTAL CONTROLS                v1.0d1  **
**                                                                      **
** Copyright 1989, Advanced Micro Devices, Inc.                         **
** Written by Gibbons and Associates, Inc.                              **
**                                                                      **
**                                                                      **
** This module contains the delarations of the startup routines and     **
** fundamental control routines.                                        **
**                                                                      **
** History: (after version 1.0)                                         **
**                                                                      **
** v1.0d1 JG    add SetTimerNext, add returns to EnbInt, DsbInt and     **
** v1.0d1 JG            IntLevel                                        **
**                                                                      **
*************************************************************************/

#ifndef START_H
#define START_H 1

/*
** LEDs - these don't really merit a separate file, so they are just
** included here.
*/

#define LED_ROM         (1 << 0)        /* ROM Instruction and Checksum */
#define LED_RAM         (1 << 1)        /* RAM Address and Data         */
#define LED_PANEL       (1 << 2)        /* Front panel interface        */
#define LED_EEPROM      (1 << 3)        /* EEPROM interface             */
#define LED_SERIAL      (1 << 4)        /* Serial port                  */
#define LED_COPROC      (1 << 5)        /* Coprocessor interface        */
#define LED_LPEC        (1 << 6)        /* Laser printer engine intf    */
#define LED_PARALLEL    (1 << 7)        /* Parallel port                */

#define LEDS_ON         0x00            /* all LEDs on                  */
#define LEDS_OFF        0xff            /* all LEDs off                 */

/*
** Port external declarations (see also ???port.h)
*/

extern volatile unsigned        LEDs;           /* may use RAM loc      */

/*
** Static data exported to C functions
*/

extern unsigned         CyclesPerSec;   /* CPU cycles per second        */
extern unsigned         CyclesPerMs;    /* CPU cycles per millisecond   */
extern unsigned         LEDCrnt;        /* LEDs image                   */
extern unsigned         LEDCmltv;       /* LEDs cumulative image        */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern void     SerDelay
/*
** This routine provides the delay required by the SCC between register
** accesses.
*/
(
void
);

/*
** The macro below is defined for use of the SerDelay routine above.
** In hardware environments where it the delay is not required, the
** macro can be defined to be a blank.
*/

#define SER_DELAY       SerDelay ();

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern unsigned EnbInt
/*
** This routine enables interrupts by clearing DI.
**
** The prior cps value is returned.
*/
(
void
);

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

extern unsigned DsbInt
/*
** This routine disables interrupts by setting DI.
**
** The prior cps value is returned.
*/
(
void
);


#endif                                  /* ifdef START_H                */

/* end of start.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgb.c ===
/**********************************************************************
 *
 *      Name:       fillgb.c
 *
 *      Purpose:    This file contains routines for performing bitmap related
 *                  operations.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         10/18/88    source file reorganization for saving trapezoids
 *                              in command buffer instead of scanlines, i.e.
 *                              defer scan conversion at lower level graphics
 *                              split scanconv.c => savetpzd.c & fillgb.c
 *                              savetpzd -- save trapezoid in command buffer
 *                              fillgb   -- perform scan conversion, scanline
 *                                          bitblt function.
 *                              primitives:
 *                              gp_scanconv() -- perform scan conversion.
 *                              gp_scanline16() -- 16 bit scanline filling
 *                              gp_scanline32() -- 32 bit scanline filling
 *                              gp_bitblt16() -- 16 bits bitblt moving
 *                              gp_bitblt32() -- 32 bits bitblt moving
 *                              gp_charblt16() -- 16 bits CC --> FB
 *                              gp_charblt32() -- 32 bits CC --> FB
 *                              gp_charblt16_cc() -- 16 bits CC --> CC
 *                              gp_charblt16_clip() -- 16 bits CC --> CMB
 *                              gp_charblt32_clip() -- 32 bits CC --> CMB
 *
 *                  11/03/88    LFX2I => LFX2I_T, SFX2I => SFX2I_T
 *                  11/24/88    add new parameter (seed index) to
 *                              fill_seed_patt()
 *                  1/12/89     modify gp_scanconv():
 *                              end points of trapezoid in 1/8 pixel(instead
 *                              of in pixel), should process start & end line
 *                              segemnt that less than 1 scanline
 *                  01/16/89    @IMAGE: fill_a_band(): add new dest type
 *                              F_TO_MASK to generate clipping mask (CMB)
 *                              for clipped image/imagemask
 *                  01/24/89    gp_scanconv(): truncate y-coord for fill a
 *                              degernated trapezoid
 *                  01/31/89    gp_scanconv(): fix a bug of count of scanline
 *                              loop
 *
 *      4.0         02-03-1989  add primitive routines:
 *                              gp_scanconv_i:
 *                                 filling image seed pattern; it applies
 *                                 interior filling.
 *                              gp_patblt:
 *                                 move image seed pattern to frame buffer
 *
 *                              gp_patblt_m:
 *                                 move image seed pattern to frame buffer with
 *                                 clipping mask
 *                              gp_patblt_c:
 *                                 move image seed pattern to character cache
 *
 *                  03/23/89    gp_scanconv(): round start_y and end_y of the
 *                              trapezoid instead of truncation for quality
 *                              enhancement @RND
 *                  04/19/89    fill_a_band(): use fixed bounding box for
 *                              cahce
 *                  05/18/89    gp_scanconv():should not modify bounding box
 *                              for calling lower level primitives with
 *                              F_TO_CACHE
 *                  05/18/89    fill_a_band(): fix the bug aroused on 4/19/89;
 *                              keep bounding box info in local variable instead
 *                              of in global variable
 *                  05/23/89    gp_scanline32() check negative ys_line
 *                  03/07/91    gp_scanconv_i(): add end of scanline mark
#ifdef WIN
 *  Ada             03/15/91    gp_scanline32_pfOR() to fill pattern OR to page
 *  Ada             03/20/91    gp_scanline32_pfREP() to fill pattern to page
 *  Ada             03/21/91    elimulate WHITE in REP case to call normal fill
#endif
 *                  11/20/91    upgrade for higher resolution @RESO_UPGR
 *                  1/20/92     add checking of negative scan points due to
 *                              arith error in gp_scanconv()
 * SCCHEN           10/07/92    Bitblt functions were moved to fillgbx.c:
 *                              gp_bitblt16 gp_bitblt32
 *                              gp_pixels16 gp_pixels32
 *                              gp_cacheblt16
 *                              gp_bitblt16_32
 *                              gp_charblt16 gp_charblt32 gp_charblt16_cc
 *                              gp_charblt16_clip gp_charblt32_clip
 *                              gp_patblt gp_patblt_m gp_patblt_c
 **********************************************************************/




// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fillproc.h"
#include        "fillproc.ext"

/* @WIN; add prototype */
void      expand_halftone(void);
lfix_t FixMul(lfix_t, lfix_t);
lfix_t FixDiv(lfix_t, lfix_t);


// DJC not necessary
// typedef unsigned long       DWORD;      /* for huge memory */

struct edgese {         /* data structure of a edge */
        fix     s, e;           /*   left and right edge of a scanline */
};
/* scanline structure */
//static SCANLINE near gpscan_table[MAXSCANLINES];      @WIN
SCANLINE FAR  gpscan_table[MAXSCANLINES];
#define scanline_table gpscan_table

/* -------------------------------------------------
 * Local Variables used by gp_scanconv, fill_a_band
 * -------------------------------------------------
 */
//static SCANLINE near *scanline;       @WIN
static SCANLINE FAR *scanline;
static ufix tpzd_destination;                   /* fill destination */
static struct tpzd_info FAR *tpzd_info;             /* bounding box information */

/*
 *      left and right edges for scan conversion
 *
 *              +-----------+             <---  scan_y0
 *             /             \
 *            /                \
 *           /                   \
 *          +---------------------+       <---  scan_y1
 *      scan_lxc: x_change of left edge;
 *      scan_lxint: x_coord. of intersection point of left edge;
 *      scan_rxc: x_change of right edge;
 *      scan_rxint: x_coord. of intersection point of right edge;
 */
static sfix_t   scan_y0,        /* start y_coord */
                scan_y1;        /* end y_coord */
static lfix_t   scan_lxc,       /* x_change of left edge */
                scan_rxc,       /*      ...    right edge */
                scan_lxint,     /* intersect point of left edge */
                scan_rxint;     /*      ...           right edge */


/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void fill_a_band (fix, fix);

#else
/* for no type checks of the parameters in function declarations */
static void fill_a_band ();
#endif

// Short & long word swapping @WINFLOW
#ifdef  bSwap
#define WORDSWAP(lw) \
        (lw =  (lw << 16) | (lw >> 16))
#define SWORDSWAP(sw) \
        (sw =  (sw << 8) | (sw >> 8))
#define LWORDSWAP(lw) \
        (lw =  (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000))
#define S2WORDSWAP(lw) \
        (lw = ((lw >> 8) & 0x00ff00ff) | ((lw << 8) & 0xff00ff00))
#define SWAPWORD(lw) (lw = (lw << 16) | (lw >> 16))
#else
#define WORDSWAP(lw)    (lw)
#define SWORDSWAP(sw)   (sw)
#define LWORDSWAP(lw)   (lw)
#define S2WORDSWAP(lw)  (lw)
#define SWAPWORD(lw) (lw)
#endif

/***********************************************************************
 * Performs scan conversion on a trapezoid. The trapezoid has been converted
 * to a left and right edge. This routine gets a pair of endpoints, and updates for each
 * left and right edge for each scan line. Scan lines are put in the scanline
 * table. It will call fill_a_band to render the scan lines when the scanline
 * table is full.
 *
 * TITLE:       gp_scanconv
 *
 * CALL:        gp_scanconv(dest, info, tpzd)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: bounding box information
 *              3. tpzd: a trapezoid
 *
 * INTERFACE:   Save_tpzd
 *
 * CALLS:       Fill_a_band
 *
 * RETURN:      None
 **********************************************************************/
void far gp_scanconv(dest, info, tpzd)
ufix dest;
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{
        sfix_t dy;

//      fix scan_y;     @WIN
        fix     bb_y, start_y, lines;
        fix32   bmap_size;
        ufix    lines_per_band;
        fix     xs, xe;
        fix     scans;
        bool    first_band, last_band;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif

        tpzd_destination = dest;
        tpzd_info = info;

        /* build left and right edges for scan conversion */
        scan_y0 = tpzd->topy;
        scan_y1 = tpzd->btmy;

        dy = tpzd->btmy - tpzd->topy;
        if (dy == 0) {  /* degernated trapezoid, just a horiz. line */
                scan_lxc = scan_rxc = 0;
        } else {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                scan_lxc = (((fix32)(tpzd->btmxl - tpzd->topxl)) << L_SHIFT) / dy;
                scan_rxc = (((fix32)(tpzd->btmxr - tpzd->topxr)) << L_SHIFT) / dy;
#elif  FORMAT_16_16
                /* "scan_lxc" needs to be in "LFX" format.
                */
                LongFixsMul((tpzd->btmxl - tpzd->topxl), (1L << L_SHIFT), dest1);
                scan_lxc = LongFixsDiv(dy, dest1);
                LongFixsMul((tpzd->btmxr - tpzd->topxr), (1L << L_SHIFT), dest1);
                scan_rxc = LongFixsDiv(dy, dest1);
#elif  FORMAT_28_4
                /* "scan_lxc" needs to be in "LFX" format.
                */
                LongFixsMul((tpzd->btmxl - tpzd->topxl), (1L << L_SHIFT), dest1);
                scan_lxc = LongFixsDiv(dy, dest1);
                LongFixsMul((tpzd->btmxr - tpzd->topxr), (1L << L_SHIFT), dest1);
                scan_rxc = LongFixsDiv(dy, dest1);
#endif
        }

        scan_lxint = SFX2LFX(tpzd->topxl);
        scan_rxint = SFX2LFX(tpzd->topxr);

#ifdef DBG1
        printf("gp_scanconv: destination=%d,", tpzd_destination);
        printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                 tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
        printf("tpzd: scan_y0=%f, scan_y1=%f\n", SFX2F(scan_y0),
               SFX2F(scan_y1));
        printf("      left edge  -- xc=%f, xint=%f\n", LFX2F(scan_lxc),
               LFX2F(scan_lxint));
        printf("      right edge -- xc=%f, xint=%f\n", LFX2F(scan_rxc),
               LFX2F(scan_rxint));
#endif

        /* initilize lines_per_band */
        if (tpzd_destination == F_TO_PAGE) {
                /* a graph to page may exceed a band buffer */
                gwb_space (&bmap_size);
                lines_per_band = (fix)(bmap_size * 8 / tpzd_info->box_w);

                /* lines limit due to scanline table */
                if (lines_per_band > ((MAXSCANLINES - 1) / 3))
                        lines_per_band = (MAXSCANLINES - 1) / 3;
        } else {
                lines_per_band = (MAXSCANLINES - 1) / 3;
        }

        /* initialization */
        scanline = scanline_table;

        /* round y-coord instead of truncation @RND 3/23/89 */
        /*  start_y = SFX2I_T(scan_y0 + 7);
         *  scans = SFX2I_T(scan_y1) - start_y + 1;
         */

         start_y = SFX2I(scan_y0);
         scans = SFX2I(scan_y1) - start_y + 1;

        /* special case: just a horizontal line, to fill it directly */

        if (scans <= 1) {          /* if (scans <= 0)  {  @RND 3/23/89   */
#ifdef DBG1
                printf("scans=%d less than zero\n", scans);
#endif
                /* horiz. line adjustment; expand to max endpoints */
                if (tpzd->topxl > tpzd->btmxl)  /* get min_x */
                     xs = SFX2I_T(tpzd->btmxl);
                else
                     xs = SFX2I_T(tpzd->topxl);

                if (tpzd->topxr < tpzd->btmxr) /* get max_x */
                     xe = SFX2I_T(tpzd->btmxr);
                else
                     xe = SFX2I_T(tpzd->topxr);

                /* put scan line in scanline structure */
                *scanline++ = (SCANLINE)xs;
                *scanline++ = (SCANLINE)xe;
                /* put end_mark in scanline structure */
                *scanline++ = END_OF_SCANLINE;

                /* y-coord truncate to pixel 1/24/89 */
                /* start_y = SFX2I_T(scan_y0);  @RND */
                /* should not modify bounding box for F_TO_CACHE 5/18/89 */
                if (tpzd_destination == F_TO_PAGE) {
                        tpzd_info->BOX_Y = start_y;  /* @RND */
                        tpzd_info->box_h = 1;        /* @RND */
                }

                fill_a_band (start_y, 1);
                return;
        }

        /* modify x_coord as y_coord advances to pixel position */
        dy = I2SFX(start_y) - scan_y0;  /* @RESO_UPGR */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        scan_lxint += (scan_lxc >> S_SHIFT) * dy;
        scan_rxint += (scan_rxc >> S_SHIFT) * dy;
#elif FORMAT_16_16
        LongFixsMul(scan_lxc, dy, dest1);
        scan_lxint += LongFixsDiv((1L << S_SHIFT), dest1);

        LongFixsMul(scan_rxc, dy, dest1);
        scan_rxint += LongFixsDiv((1L << S_SHIFT), dest1);
#elif FORMAT_28_4
        /*
        */
        scan_lxint += ((scan_lxc >> S_SHIFT) * dy);
        scan_rxint += ((scan_rxc >> S_SHIFT) * dy);
#endif

        /*
         * adjustment of left and right edges to prevent broken lines
         */

        /* shift left edge to left side for 1/2 * x_change units */
        if (scan_lxc > 0) {
                scan_lxint -= (scan_lxc >> 1);
                xs = SFX2I_T(tpzd->topxl);
                     /* get real endpoint as 1st scanline; should not shift */
        } else {
                scan_lxint += (scan_lxc >> 1);
                xs = LFX2I_T(scan_lxint);
                if (xs < 0) xs = 0;       /* fix arith error 1/20/91 */
        }

        /* shift right edge to right side for 1/2 * x_change units */
        if (scan_rxc < 0) {
                scan_rxint -= (scan_rxc >> 1);
                xe = SFX2I_T(tpzd->topxr);
                     /* get real endpoint as 1st scanline; should not shift */
        } else {
                scan_rxint += (scan_rxc >> 1);
                xe = LFX2I_T(scan_rxint);
        }

#ifdef DBG1
        printf("1st:  (xs,xe)= (%d, %d)\n", xs, xe);
#endif

/* shortcut for rectangle - begin, 1-16-91, Jack */
        if ((tpzd->btmxl == tpzd->topxl) && (tpzd->btmxr == tpzd->topxr)) {
            for ( ;scans > 0; scans -= lines_per_band,
                start_y += lines_per_band) {
/*              fix dy; */

                if ((ufix)scans <= lines_per_band) {    //@WIN
                    lines = scans;
                } else
                    lines = lines_per_band;
                bb_y = lines;

                /* Loop for each scan line in edge_table */
                while(bb_y--) {
                    *scanline++ = (SCANLINE)xs;
                    *scanline++ = (SCANLINE)xe;
                    *scanline++ = END_OF_SCANLINE;
                } /* scan line loop */
                /* fill the band */
                if (tpzd_destination == F_TO_PAGE) {
                    /* the bounding box infomation should be modified */
                    tpzd_info->BOX_Y = start_y;
                    tpzd_info->box_h = lines;
                }
                fill_a_band (start_y, lines);

                /* initialize scanline structure */
                scanline = scanline_table;
            }
            return;
        }
/* shortcut for rectangle -   end, 1-16-91, Jack */

        /* put 1st scan line in scanline structure */
        *scanline++ = (SCANLINE)xs;
        *scanline++ = (SCANLINE)xe;
        /* put end_mark in scanline structure */
        *scanline++ = END_OF_SCANLINE;

        /* init */
        first_band = TRUE;
        last_band = FALSE;

        /* Loop for filling a band */
        for ( ;scans > 0; scans -= lines_per_band, start_y += lines_per_band) {
            fix dy;                             /* scans >= 0    1/31/89 */

            if ((ufix)scans <= lines_per_band) {        //@WIN
                last_band = TRUE;
                lines = scans;
            } else
                lines = lines_per_band;

            dy = lines;
            if (first_band) {   /* 1st scan line has been generated */
                dy--;
                first_band = FALSE;
            }

#ifdef DBG1
            printf("start_y=%d, scans=%d, lines=%d, lines_per_band=%d, dy=%d\n",
                 start_y, scans, lines, lines_per_band, dy);
#endif

            /* Loop for each scan line in edge_table */
            while(dy--) {

                    /* update edge table */
                    scan_lxint += scan_lxc;
                    scan_rxint += scan_rxc;

                    /* get scan pairs */
                    xs = LFX2I_T(scan_lxint);
                    xe = LFX2I_T(scan_rxint);

#ifdef DBG1
                    printf("      (xs,xe)= (%d, %d)\n", xs, xe);
#endif
                    *scanline++ = (SCANLINE)xs;
                    *scanline++ = (SCANLINE)xe;
                    /* put end_mark in scanline structure */
                    *scanline++ = END_OF_SCANLINE;
            } /* scan line loop */

            /* get real endpoint as the last scanline; should not shift */
            if (last_band) {
                if (scan_lxc < 0) {
                        *(scanline -3) = SFX2I_T(tpzd->btmxl);
#ifdef DBG1
                        printf("revise last xs = %d\n", *(scanline -3));
#endif
                }

                if (scan_rxc > 0) {
                        *(scanline -2) = SFX2I_T(tpzd->btmxr);
#ifdef DBG1
                        printf("revise last xe = %d\n", *(scanline -2));
#endif
                }
            }

            /* fill the band */
            if (tpzd_destination == F_TO_PAGE) {
                    /* the bounding box infomation should be
                     * modified
                     */
                    tpzd_info->BOX_Y = start_y; /* (bb_y >= 1) ? bb_y - 1 : 0; */
                    tpzd_info->box_h = lines;   /* lines + 1; */
                                    /* expand box one more line to
                                     * include top horizontal line
                                     */
            }
#ifdef DBG2
            printf(" Fill a band: box_x=%d,", tpzd_info->BOX_X);
            printf(" bb_y=%d, box_w=%d, lines=%d start_y=%d\n",
                     bb_y, tpzd_info->box_w, lines, start_y);
#endif

#ifdef DBG3
            /* Start of DEBUG: to check if scanlines inside box of trapezoid */
            {
                fix min_x, max_x;
                fix     i, error;
                SCANLINE FAR *scan;

                if (tpzd->topxl > tpzd->btmxl)  /* get min_x */
                     min_x = SFX2I_T(tpzd->btmxl);
                else
                     min_x = SFX2I_T(tpzd->topxl);

                if (tpzd->topxr < tpzd->btmxr) /* get max_x */
                     max_x = SFX2I_T(tpzd->btmxr);
                else
                     max_x = SFX2I_T(tpzd->topxr);

                error = FALSE;
                for (i=0, scan=scanline_table; i<lines; i++) {
                    fix tmp1, tmp2;
                    while( *scan != END_OF_SCANLINE) {
                        if (((tmp1 = *scan++) < min_x) ||
                            ((tmp2 = *scan++) > max_x) ||
                            (tmp1 > tmp2)) {
                            error = TRUE;
                        }
                    }
                    scan++;
                }
                if (error) {
                    printf("Warning, outside tpzd_box!! gp_scanconv():\n");
                    printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                            SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
                    printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                            SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
                    printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n",
                            tpzd_info->BOX_X, tpzd_info->BOX_Y,
                            tpzd_info->box_w, tpzd_info->box_h);
                    printf("tpzd: scan_y0=%f, scan_y1=%f\n", SFX2F(scan_y0),
                           SFX2F(scan_y1));
                    printf("      left edge  -- xc=%f, xint=%f\n",
                           LFX2F(scan_lxc), LFX2F(scan_lxint));
                    printf("      right edge -- xc=%f, xint=%f\n",
                           LFX2F(scan_rxc), LFX2F(scan_rxint));

                    for (i=0, scan=scanline_table; i<lines; i++) {
                        while( *scan != END_OF_SCANLINE) {
                                printf("     <%d ",*scan);
                                scan++;
                                printf("-> %d> ",*scan);
                                scan++;
                        }
                        printf("\n");
                        scan++;
                    }
                } /* if error */
            }
            /* End of DEBUG */
#endif

            fill_a_band (start_y, lines);

            /* initialize scanline structure */
            scanline = scanline_table;

        } /* band loop */
}


/***********************************************************************
 * Performs scan conversion on a quadrangle in a interior fill manner.
 * All verteice of the quadrangle are in integer format.
 *
 * TITLE:       gp_scanconv_i
 *
 * CALL:        gp_scanconv(x_maxs, y_maxs, sample)
 *
 * PARAMETERS:
 *              1. x_maxs: maximum value of x ccordinate
 *              2. y_maxs: maximum value of y ccordinate
 *              3. sample: a quadrangle
 *
 * INTERFACE:   fill_seed
 *
 * CALLS:       fill_seed_patt
 *
 * RETURN:      None
 **********************************************************************/
void far
gp_scanconv_i(image_type, x_maxs, y_maxs, quadrangle)
ufix           image_type;                                      /* 05-25-89 */
fix            x_maxs, y_maxs;
struct sample FAR *quadrangle;
{
    fix                 index;
    struct vertex      FAR *point;
    struct vertex       vertex[5];
    struct edgese       edgese[256];
    SCANLINE      FAR *scanline_table;
    SCANLINE      FAR *scanline;

    scanline_table = alloc_scanline(y_maxs * 3);

    /* reset content of edge table */
    for (index = 0; index < y_maxs; index++)
        edgese[index].s = edgese[index].e = -1;

    /* create circular vertex list */
    vertex[0].x = quadrangle->p[0].x /* - x_mins */;
    vertex[0].y = quadrangle->p[0].y /* - y_mins */;
    vertex[1].x = quadrangle->p[1].x /* - x_mins */;
    vertex[1].y = quadrangle->p[1].y /* - y_mins */;
    vertex[2].x = quadrangle->p[2].x /* - x_mins */;
    vertex[2].y = quadrangle->p[2].y /* - y_mins */;
    vertex[3].x = quadrangle->p[3].x /* - x_mins */;
    vertex[3].y = quadrangle->p[3].y /* - y_mins */;
    vertex[4].x = quadrangle->p[0].x /* - x_mins */;
    vertex[4].y = quadrangle->p[0].y /* - y_mins */;

    for (index = 0, point = vertex; index <  4; point++, index++)
    {
        fix                 x0, y0;
        fix                 x1, y1;
        fix                 dx, dy;
        fix                 x, y, px;

        /* no need to process horizontal edge */
        if (point[0].y == point[1].y)
            continue;

        /* setup points of a edge; be sure that y0 <= y1 */
        if (point[0].y <= point[1].y) {
            x0 = point[0].x; y0 = point[0].y;
            x1 = point[1].x; y1 = point[1].y;
        } else {
            x0 = point[1].x; y0 = point[1].y;
            x1 = point[0].x; y1 = point[0].y;
        }

        /* calculate length of x and y component */
        dx = (x1 - x0) * 2;
        dy = (y1 - y0) * 2;

#ifdef  DBG2
        printf("[%2d, %2d]    [%2d, %2d]    dx: %3d    dy: %3d\n",
               x0, y0, x1, y1, dx, dy);
#endif

        /* could be modified into DDA */
        px = x0 * dy + x1 - x0;
        for (y = y0; y < y1; y++) {
            x = px / dy;
            /* put x into proper field (s or e) */
            if (edgese[y].s == -1)
                edgese[y].s = x;
            else
            if (edgese[y].s <=  x)
                edgese[y].e = x;
            else {
                edgese[y].e = edgese[y].s;
                edgese[y].s = x;
            }
            px+= dx;
        }
    }

    scanline = scanline_table;
    for (index = 0; index < y_maxs; index++) {
        if (edgese[index].s < edgese[index].e) {
            *scanline = (SCANLINE)(edgese[index].s);
            scanline++;
            *scanline = (SCANLINE)(edgese[index].e - 1);
            scanline++;
        }
        *scanline = (SCANLINE) 0x8000;
        scanline++;
    }
    *scanline = (SCANLINE) 0x8000;      /* 3-7-91, Jack */

    fill_seed_patt(image_type, image_info.seed_index,   /* @IMAGE 01-04-89 */
                   x_maxs, y_maxs, y_maxs, scanline_table);     /* 05-25-89 */
}


/***********************************************************************
 * According to the type(tpzd_destination), this routine calls the
 * corresponding lower level graphics primitives to render it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_a_band
 *
 * CALL:        fill_a_band(ys_lines, no_lines)
 *
 * PARAMETERS:
 *              ys_lines: y-coord of the starting sacn line
 *              no_lines: number of scan lines
 *
 *              global variable: tpzd_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *
 * INTERFACE:   gp_scanconv
 *
 * CALLS:       fill_scan_cache
 *              fill_scan_page
 *              clip_cache_page
 *              fill_seed_patt
 *
 * RETURN:      None
 **********************************************************************/
static void fill_a_band (ys_lines, no_lines)
fix     ys_lines, no_lines;
{

#ifdef DBG2
        fix     i;
        SCANLINE FAR *scan;

        printf("Fill_band(): destination=%d,", tpzd_destination);
        printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                 tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
        printf("       ys_lines=%d, no_lines=%d\n", ys_lines, no_lines);

        for (i=0, scan=scanline_table; i<no_lines; i++) {
            while( *scan != END_OF_SCANLINE) {
                    printf("     <%d ",*scan);
                    scan++;
                    printf("-> %d> ",*scan);
                    scan++;
            }
            printf("\n");
            scan++;
        }
#endif

        *scanline = END_OF_SCANLINE;            /* will be deleted ??? */

        switch (tpzd_destination) {

        case F_TO_CACHE :
/*          fill_scan_cache (cache_info->bitmap,
 *              cache_info->box_w, cache_info->box_h,
 *              ys_lines, no_lines, scanline_table);
 */

            /* keep bounding box info in local variable(cache_info) instead of
             * in global variable(cahce_info) for correctly saving commands
             * in command buffer 5/18/89
             */
            fill_scan_cache (tpzd_info->BMAP,           /* 4/19/89 */
                tpzd_info->box_w, tpzd_info->box_h,
                ys_lines, no_lines, scanline_table);
            break;

        case F_TO_PAGE :
/*          fill_scan_page (fill_info.box_x, fill_info.box_y,
 *                          fill_info.box_w, fill_info.box_h,
 *                          scanline_table);
 */
            fill_scan_page (tpzd_info->BOX_X, tpzd_info->BOX_Y,
                            tpzd_info->box_w, tpzd_info->box_h,
                            scanline_table);
            break;

        case F_TO_CLIP :
            clip_cache_page (ys_lines, no_lines, scanline_table);
            break;

/*      CAN BE REMOVED                                  01-16-89
        case F_TO_IMAGE :                       |* @IMAGE *|
#ifdef DBG2
            printf("fill_band(): F_TO_IMAGE");
            printf(" box_x=%d, box_y=%d, box_w=%d, box_h=%d\n", tpzd_info->BOX_X,
                     tpzd_info->BOX_Y, tpzd_info->box_w, tpzd_info->box_h);
            printf("       ys_lines=%d, no_lines=%d\n", ys_lines, no_lines);
#endif

|*          fill_seed_patt(fill_info->box_w, fill_info->box_h,
 *                         no_lines, scanline_table);
 *|
            fill_seed_patt(image_info.seed_index,               |* 11-24-88 *|
                           tpzd_info->box_w, tpzd_info->box_h,
                           no_lines, scanline_table);
            break;
*/

    /* ++++++++++++ @Y.C. BEGIN +++++++++++++++++++++++++++++++++++++++++++ */
        case F_TO_MASK :                        /* @IMAGE  01-16-89  Y.C. */
            clip_image_page (ys_lines, no_lines, scanline_table);
            break;
    /* ++++++++++++ @Y.C. END +++++++++++++++++++++++++++++++++++++++++++++ */

        default :
            printf(" fatal error, tpzd_destination\n");

        } /* swith */
}


/* -----------------------------------------------------------------------
 * THIN LINE SIMULATION: gp_vector() and gp_vector_c()
 *                       gp_vector() -- fill line to frame buffer
 *                       gp_vector_c -- fill line to character cache buffer
 *
 * Function Description:
 *           Draw a thin line (single pixel) into Frame Buffer.
 *           vector with following logical operations:
 *           FC_SOLID: 1 --> destination (cache only)
 *           FC_MERGE: source .OR.  destination --> destination
 *           FC_CLEAR: (.NOT. source)  .AND. (destination) --> destination
 *           FC_MERGE | HT_APPLY:
 *               Step 1. Clear destination for value 1 on source object.
 *               Step 2. (source AND halftone) --> source.
 *               Step 3. (source OR destination) --> destination.
 *           , where source are always "1"
 *
 * Calling sequence:
 *       void gp_vector(DST, FC, X0, Y0, X1, Y1)
 *       void gp_vector_c(DST, FC, X0, Y0, X1, Y1)
 *       struct bitmap *DST;    (* address of destination bitmap *)
 *       ufix16         FC;     (* Paint type *)
 *       fix            X0, Y0; (* position of starting point *)
 *       fix            X1, Y1; (* position of ending point *)
 *
 *
 * Diagram Description:
 *
 *                   destination bitmap
 *          DST +---------------------------+
 *              |                           |
 *              | (X0, Y0)                  |
 *              |       \                   |
 *              |        \                  |
 *              |         \                 |
 *              |          \                |
 *              |           \               |
 *              |            \              |
 *              |             \             |
 *              |              \            |
 *              |               \           |
 *              |                \ (X1,Y1)  |
 *              |                           |
 *              |                           |
 *              +---------------------------+
 *
 * ----------------------------------------------------------------------- */
/* -----------------------------------------------------------------------
 * gp_vector(): fill line to frame buffer
 *
 * ----------------------------------------------------------------------- */

void
gp_vector(dst, fc, x0, y0, x1, y1)
struct bitmap FAR     *dst;
ufix16                  fc;
/* fix                  x0, y0, x1, y1; */
sfix_t                  x0, y0, x1, y1; /* @RESO_UPGR */
{
    fix                 dw;
    BM_DATYP           huge *db, huge *dp;      /* far => huge @WIN */
    fix                 hw;
    BM_DATYP           huge *ht, huge *hp;      /* far => huge @WIN */
    BM_DATYP            pm;

    /* fix              x, y, sx, sy, dx, dy; */
    sfix_t              x, y, sx, sy, dx, dy; /* @RESO_UPGR */
    fix                scans;
    lfix_t             slope, nextp;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif
    ufix32              tmp;                    /* for swap; @WIN */

    dx = (x1 >= x0) ? (x1 - x0) : (x0 - x1);
    dy = (y1 >= y0) ? (y1 - y0) : (y0 - y1);
    dw = dst->bm_cols / BM_PIXEL_WORD;

    /* due to slope evaluate line pixels in x-coord or y-coord major */
    if (dx >= dy) {        /*  |degree| <= 45; x-coord major */
        fix     last_y, delta_y, start_x;

/*      printf("X-coord major\n");      */

        /*  swap for x0 <= x1  */
        if (x1 < x0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }

//      db = &((BM_DATYP huge *) dst->bm_addr)[SFX2I(y0) * dw]; /* far => huge @WIN */
        db = (BM_DATYP huge *) dst->bm_addr +
             ((DWORD)SFX2I(y0) * (DWORD)dw);

        switch (fc)
        {
        case FC_CLEAR:                  /*  0010  D <- D .AND. .NOT. S  */

           start_x = SFX2I_T(x0);
           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
//         dp[0] = AND(dp[0], ~BM_P_MASK(start_x));   /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = AND(dp[0], ~tmp);

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif  FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif  FORMAT_28_4
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);

                   delta_y = y - last_y;
                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = AND(dp[0], ~BM_P_MASK(x));      /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = AND(dp[0], ~tmp);

/*                 printf(" <%d, %d> (%d)", x, y, delta_y);     */
                   last_y = y;
           }
           break;

        case FC_MERGE:                  /*  0111  D <- D .OR. S         */

        case FC_SOLID:                  /*  1111  D <- 1                */

           start_x = SFX2I_T(x0);
           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
//         dp[0] = OR(dp[0], BM_P_MASK(start_x));  /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = OR(dp[0], tmp);

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);

                   delta_y = y - last_y;
                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = OR(dp[0], BM_P_MASK(x));  /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(dp[0], tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_y); */
                   last_y = y;
           }
           break;

        case FC_MERGE | HT_APPLY:       /*  D <- (D .AND. .NOT. S) .OR.
                                                 (S .AND. HT)           */
           start_x = SFX2I_T(x0);

           hw = HTB_Bmap.bm_cols / BM_PIXEL_WORD;
           ht = (BM_DATYP huge *) HTB_Bmap.bm_addr;   /* far => huge @WIN */

           /* fill first pixel */
//         dp = &db[start_x / BM_PIXEL_WORD];   @WIN
           dp = db + start_x / BM_PIXEL_WORD;
           hp = &ht[(SFX2I(y0) % HTB_Bmap.bm_rows) * hw +
                     start_x / BM_PIXEL_WORD];
//         dp[0] = OR(AND(dp[0], ~BM_P_MASK(start_x)),     /*@WIN*/
//                         AND(hp[0],  BM_P_MASK(start_x)));  /*@WIN*/
           tmp = BM_P_MASK(start_x);   /*@WIN*/
           LWORDSWAP(tmp);
           dp[0] = OR(AND(dp[0], ~tmp),     /*@WIN*/
                           AND(hp[0],  tmp));  /*@WIN*/

           /* degernated case, just one pixel */
           if (dx == 0) {
/*                 printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0)); */
                   return;
           }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
           /* "slope" needs to be in "LFX" format.
           */
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
           LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
           slope = LongFixsDiv((x1 - x0), dest1);
#endif
           nextp = SFX2LFX(y0);

           scans = SFX2I_T(x1) - start_x + 1;

           /* modify y_coord as x_coord truncates to pixel position */
           dx = I2SFX(start_x) - x0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
           nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
           LongFixsMul(slope, dx, dest1);
           nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
           nextp += (slope >> S_SHIFT) * dx;
#endif

           /* special processing for the first pixel, use endpoint y0 */
/*         printf(" <%d, %d>", start_x, SFX2I(y0));     */
           last_y = SFX2I(y0);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           x = (sfix_t)start_x;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   x++;

                   y = LFX2I(nextp);
                   delta_y = y - last_y;

                   if(delta_y > 0) {
                        db += dw;
                   }
                   else if (delta_y < 0) {
                        db -= dw;
                   }
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
                   hp = &ht[(y % HTB_Bmap.bm_rows) * hw +
                             x / BM_PIXEL_WORD];
//                 dp[0] = OR(AND(dp[0], ~BM_P_MASK(x)),   /*@WIN*/
//                            AND(hp[0],  BM_P_MASK(x)));  /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(AND(dp[0], ~tmp),     /*@WIN*/
                                   AND(hp[0],  tmp));  /*@WIN*/

/*                 printf(" <%d, %d> (%d)", x, y, delta_y);     */
                   last_y = y;
           }
           break;
        }

    } else {        /*  |degree| > 45; y-coord major */
        fix     start_y;

/*      printf("Y-coord major\n");      */

        /*  swap for y0 <= y1  */
        if (y1 < y0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(x1 - x0)) << L_SHIFT) / (y1 - y0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#elif FORMAT_28_4
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#endif
        nextp = SFX2LFX(x0);

        start_y = SFX2I(y0);
        scans = SFX2I(y1) - start_y + 1;

        /* modify x_coord as y_coord rounds to pixel position */
        dy = I2SFX(start_y) - y0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dy;
#elif  FORMAT_16_16
        LongFixsMul(slope, dy, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dy;
#endif

//      db = &((BM_DATYP huge *) dst->bm_addr)[start_y * dw]; /* far => huge @WIN */
        db = (BM_DATYP huge *)dst->bm_addr + ((DWORD)start_y * (DWORD)dw);
        pm = BM_P_MASK(SFX2I_T(x0));
        LWORDSWAP(pm);                  /*@WIN*/

        switch (fc)
        {
        case FC_CLEAR:                  /*  0010  D <- D .AND. .NOT. S  */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD];       @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           dp[0] = AND(dp[0], ~pm);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = AND(dp[0], ~BM_P_MASK(x));      /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = AND(dp[0], ~tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;

        case FC_MERGE:                  /*  0111  D <- D .OR. S         */

        case FC_SOLID:                  /*  1111  D <- 1                */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD]; @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           dp[0] = OR(dp[0], pm);
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
//                 dp[0] = OR(dp[0], BM_P_MASK(x));    /*@WIN*/
                   tmp = BM_P_MASK(x);   /*@WIN*/
                   LWORDSWAP(tmp);
                   dp[0] = OR(dp[0], tmp);
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;

        case FC_MERGE | HT_APPLY:       /*  D <- (D .AND. .NOT. S) .OR.
                                                 (S .AND. HT)           */

            hw = HTB_Bmap.bm_cols / BM_PIXEL_WORD;
            ht = (BM_DATYP huge *) HTB_Bmap.bm_addr;    /* far => huge @WIN */

           /* special processing for the first pixel, use endpoint x0 */
/*         printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
//         dp = &db[SFX2I_T(x0) / BM_PIXEL_WORD]; @WIN
           dp = db + SFX2I_T(x0) / BM_PIXEL_WORD;
           hp = &ht[(start_y % HTB_Bmap.bm_rows) * hw +
                    SFX2I_T(x0) / BM_PIXEL_WORD];
           dp[0] = OR(AND(dp[0], ~pm),
                      AND(hp[0],  pm));
           if (--scans == 0) return;

           /* Loop for each scan line in edge_table */
           y = (sfix_t)start_y;
           while(scans--) {
                   /* get next position */
                   nextp += slope;
                   db += dw;
                   y++;

                   x = LFX2I_T(nextp);
//                 dp = &db[x / BM_PIXEL_WORD]; @WIN
                   dp = db + x / BM_PIXEL_WORD;
                   hp = &ht[(y % HTB_Bmap.bm_rows) * hw +
                             x / BM_PIXEL_WORD];
                   dp[0] = OR(AND(dp[0], ~pm),
                              AND(hp[0],  pm));
/*                 printf(" <%d, %d> (%d)", x, y, delta_x);     */
           }
           break;
        }

    } /* if 45 degrees */

} /* gp_vector */


/* ----------------------------------------------------------------------
 * gp_vector_c(): used for fill line to character cache
 *
 * ---------------------------------------------------------------------- */
void
gp_vector_c(dst, fc, x0, y0, x1, y1)
struct bitmap FAR     *dst;
ufix16                  fc;
/* fix                  x0, y0, x1, y1; */
sfix_t                  x0, y0, x1, y1; /* @RESO_UPGR */
{
    fix                 dw;
    CC_DATYP           FAR *db, FAR *dp;
    CC_DATYP            pm;

    /* fix              x, y, sx, sy, dx, dy; */
    sfix_t              x, y, sx, sy, dx, dy; /* @RESO_UPGR */
    fix                scans;
    lfix_t             slope, nextp;
#ifdef FORMAT_13_3      /* @RESO_UPGR */
#elif FORMAT_16_16
        long    dest1[2];
        long    temp;
#elif FORMAT_28_4
        long    dest1[2];
        long    temp;
#endif

#ifdef  DBG
    printf("vector_c: %6.6lx %4.4x [%4x,%4x] [%4x,%4x]\n",
           dst->bm_addr, fc, x0, y0, x1, y1);
#endif

    dx = (x1 >= x0) ? (x1 - x0) : (x0 - x1);
    dy = (y1 >= y0) ? (y1 - y0) : (y0 - y1);
    dw = dst->bm_cols / CC_PIXEL_WORD;

    /* due to slope evaluate line pixels in x-coord or y-coord major */
    if (dx >= dy) {        /*  |degree| <= 45; x-coord major */
        fix     last_y, delta_y, start_x;

/*      printf("X-coord major\n");      */

        /*  swap for x0 <= x1  */
        if (x1 < x0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
        //NTFIX
        db = (CC_DATYP FAR *) dst->bm_addr + ((DWORD) SFX2I(y0) * (DWORD) dw);

        start_x = SFX2I_T(x0);

        //NTFIX
        dp = db + start_x / CC_PIXEL_WORD;

        //NTFIX, added the cast to get rid of a warning

        {
            ufix32 tmp;
            tmp = CC_P_MASK( start_x );
            LWORDSWAP(tmp);
            dp[0] = OR(dp[0], (CC_DATYP) tmp );
        }

        /* degernated case, just one pixel */
        if (dx == 0) {
/*              printf(" <%d, %d>", SFX2I_T(x0), SFX2I(y0));    */
                return;
        }

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(y1 - y0)) << L_SHIFT) / (x1 - x0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((x1 - x0), dest1);
#elif FORMAT_28_4
        LongFixsMul((y1 - y0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((x1 - x0), dest1);
#endif
        nextp = SFX2LFX(y0);

        scans = SFX2I_T(x1) - start_x + 1;

        /* modify y_coord as x_coord truncates to pixel position */
        dx = I2SFX(start_x) - x0;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dx;
#elif  FORMAT_16_16
        LongFixsMul(slope, dx, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dx;
#endif

        /* special processing for the first pixel, use endpoint y0 */
/*      printf(" <%d, %d>", start_x, SFX2I(y0));        */
        last_y = SFX2I(y0);
        if (--scans == 0) return;

        /* Loop for each scan line in edge_table */
        x = (sfix_t)start_x;
        while(scans--) {
                /* get next position */
                nextp += slope;
                x++;

                y = LFX2I(nextp);
                delta_y = y - last_y;
                if(delta_y > 0) {
                     db += dw;
                }
                else if (delta_y < 0) {
                     db -= dw;
                }
                //NTFIX
                dp = db + x / CC_PIXEL_WORD;

                //NTFIX
                {
                   ufix16 tmp;
                   tmp = CC_P_MASK(x);
                   SWORDSWAP(tmp);
                   dp[0] = OR( dp[0], tmp );

                }

/*              printf(" <%d, %d> (%d)", x, y, delta_y); */
                last_y = y;
        }

    } else {        /*  |degree| > 45; y-coord major */
        fix     start_y;

/*      printf("Y-coord major\n");      */

        /*  swap for y0 <= y1  */
        if (y1 < y0) {
            sx = x1;
            x1 = x0;
            x0 = sx;
            sy = y1;
            y1 = y0;
            y0 = sy;
        }
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        slope = (((fix32)(x1 - x0)) << L_SHIFT) / (y1 -y0);
#elif FORMAT_16_16
        /* "slope" needs to be in "LFX" format.
        */
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#elif FORMAT_28_4
        LongFixsMul((x1 - x0), (1L << L_SHIFT), dest1);
        slope = LongFixsDiv((y1 - y0), dest1);
#endif
        nextp = SFX2LFX(x0);

        start_y = SFX2I(y0);
        scans = SFX2I(y1) - start_y + 1;

        /* modify x_coord as y_coord rounds to pixel position */
        dy = I2SFX(start_y) - y0;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        nextp += (slope >> S_SHIFT) * dy;
#elif  FORMAT_16_16
        LongFixsMul(slope, dy, dest1);
        nextp += LongFixsDiv((1L << S_SHIFT), dest1);
#elif  FORMAT_28_4
        nextp += (slope >> S_SHIFT) * dy;
#endif

        db = &((CC_DATYP FAR *) dst->bm_addr)[start_y * dw];
        pm = CC_P_MASK(SFX2I_T(x0));


        /* special processing for the first pixel, use endpoint x0 */
/*      printf(" <%d, %d>", SFX2I_T(x0), start_y);   */
        dp = &db[SFX2I_T(x0) / CC_PIXEL_WORD];

        //NTFIX
        {
           ufix16 tmp;
           tmp = CC_P_MASK(SFX2I_T(x0));
           SWORDSWAP(tmp);
           dp[0] = OR(dp[0],tmp);
        }

        if (--scans == 0) return;

        /* Loop for each scan line in edge_table */
        y = (sfix_t)start_y;
        while(scans--) {
                /* get next position */
                nextp += slope;
                db += dw;

                x = LFX2I_T(nextp);
                dp = &db[x / CC_PIXEL_WORD];

                //NTFIX
                {
                   ufix16 tmp;
                   tmp = CC_P_MASK(x);
                   SWORDSWAP( tmp );
                   dp[0] = OR(dp[0], tmp);

                }
/*              printf(" <%d, %d> (%d)", x, y, delta_x);     */
        }

    } /* if 45 degrees */

} /* gp_vector_c */


/* -----------------------------------------------------------------------
 * SCANLINE SIMULATION
 *
 * Programmed by : M.S Lin
 * Date : 5/24/1988
 *
 * Purpose
 *    Given scanline arrary, fill scanline into page buffer.
 *
 *       bb_addr
 *         +------- bb_width -----------+
 *         |                            |
 *         |                            |
 *         |    xs1   xe1  xs2  xe2     |
 *      1  |    =======    ======       | <--- ys_line
 *      2  |       =========            |
 *      .  |            .               |
 *      .  |            .           bb_heigh
 *      .  |            .               |
 * no_lines|      =====   ===   ===     |
 *         |                            |
 *         +----------------------------+
 *
 *
 *
 *    scanlist[]: horizontal lines may be followed scanlines.
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *              .
 *              .
 *              .
 *       <xs1 xe1><xs2 xe2> ... 0x8000
 *      [<yc xs xe>
 *       <yc xs xe>
 *              .
 *              .
 *              .
 *       <yc xs xe>]
 *       0x8000
 *
 *    History :
 *              1. 6-17-88  fix bug when loffset = 0, width > 16
 *                 change if(loffset && nwords) --> if(lmask && nwords).
 *              2. 8-12-88 change interface to consistant with Y.C Chen.
 *              3. 8-24-88 added code for horizontal lines process.
 *                 8-24-88 check bitmap boundary
 *
 * void            gp_scanline16(struct bitmap near *,
 *                               ufix16,
 *                               fix, fix, SCANLINE near *);
 * void            gp_scanline32(struct bitmap near *,
 *                               ufix16,
 *                               fix, fix, SCANLINE near *);
 *
 * -----------------------------------------------------------------------
 */

/* ************************************************************************
 *      gp_scanline16(): Filling into cache, solid filling only.
 *
 * ************************************************************************ */
void    gp_scanline16(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap        FAR *dst_bmap;
ufix16                  halftone;
fix                     ys_line, no_lines;
SCANLINE                FAR *scanlist;
{
register  fix       nwords;                     /* ufix -> fix  11-08-88 */
register  ufix16    huge *ptr;                  // FAR -> huge
register  SCANLINE  xs, xe;
register  fix       bb_width;
          ufix16    huge *scan_addr;            // FRA -> huge
register  ufix16    lmask, rmask;
          ufix16    sw;

#ifdef  DBG
    printf("scanline16: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> SHORTPOWER;
// scan_addr = (ufix16 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix16 huge *)dst_bmap->bm_addr +
               ((DWORD)ys_line * (DWORD)bb_width);

   /*
    * Filling solid
    */

     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                xe = *scanlist++ + 1;
                sw = xs >> SHORTPOWER;
                ptr = scan_addr + sw;

                lmask = (ufix16) (ONE16 LSHIFT (xs & SHORTMASK)); //@WIN
                rmask = BRSHIFT((ufix16)ONE16,(BITSPERSHORT -(xe & SHORTMASK)),16); //@WIN
                nwords = (xe >> SHORTPOWER) - sw;

                // swapping for @WINFLOW
                SWORDSWAP(lmask);
                SWORDSWAP(rmask);

                if(nwords == 0) {
                   *ptr = *ptr | (lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr | lmask;
                while(--nwords > 0)
                   *ptr++ = ONE16;
                *ptr = *ptr | rmask;

        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

     } /* while */
} /* gp_scanline16 */

#ifdef WIN
/* ************************************************************************
 *      gp_scanline32_pfOR(): .OR. Pattern into FRame Buffer
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32_pfOR(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;
          fix          pf_lineoff;
          ufix32       FAR *pf_addr;
           extern       ufix32  PF_BASE[];

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER;
// scan_addr = (ufix32 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

   /* The pfill pattern is designed as a 32 * 16 bitamp.
    * If the size is changed, check the code again.
    */
   pf_lineoff = ys_line % PF_HEIGHT;
   pf_addr = (ufix32 FAR *)(PF_BASE + pf_lineoff *
                (PF_WIDTH >> WORDPOWER) );
#ifdef DBG
   printf("scanline32_pfOR(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone      F = (H & P) | (F & ~P)
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);

     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;



        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (lmask & rmask &
                              ((*htb_ptr & pf) | (*ptr & ~pf)))
                          | (*ptr & ~(lmask & rmask));
                    continue;
                }
                *ptr++ = (lmask &
                             ((*htb_ptr++ & pf) | (*ptr & ~pf)))
                         | (*ptr & ~lmask);
                while(--nwords > 0)
                    *ptr++ = ((*htb_ptr++ & pf) | (*ptr & ~pf));
                *ptr = (rmask & ((*htb_ptr & pf) | (*ptr & ~pf)))
                       | (*ptr & ~rmask);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black      F = P | (F & ~P) = (P | F)
      */
     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   /* reduce this formula
                    * *ptr = ((lmask & rmask) & (*pf_addr | *ptr))
                    *        | (*ptr & ~(lmask & rmask));
                    */
                   *ptr = ((lmask & rmask) & pf) | *ptr;
                   continue;
                }
                /* reduce this formula
                 * *ptr = (lmask & (pf | *ptr)) | (*ptr & ~lmask);
                 */
                *ptr++  = (lmask & pf) | *ptr;
                while(--nwords > 0)
                  *ptr++ = (pf | *ptr);
                /* reduce this formula
                 * *ptr = (rmask & (*pf_addr | *ptr)) | (*ptr & ~rmask);
                 */
                *ptr = (rmask & pf) | *ptr;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* if else */
  else
  {
     /*
      * case 3: halftone pattern white      F = (F & ~P)
      */
     while(no_lines-- >0) {
        ufix32  pf = ~*pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;
                if(xe > dst_bmap->bm_cols)
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = (*ptr & pf) | (*ptr & ~(lmask & rmask));
                   continue;
                }
                *ptr++ = (*ptr & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                  *ptr++ = *ptr & pf;
                *ptr = (*ptr & pf) | (*ptr & ~rmask);
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* else */
} /* gp_scanline32_pfOR */
/* ************************************************************************
 *      gp_scanline32_pfREP(): Filling Pattern into FRame Buffer
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32_pfREP(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;
          fix          pf_lineoff;
          ufix32       FAR *pf_addr;
           extern       ufix32  PF_BASE[];

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER;
// scan_addr = (ufix32 FAR *)dst_bmap->bm_addr + (ys_line * bb_width); @WIN
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

   /* The pfill pattern is designed as a 32 * 16 bitamp.
    * If the size is changed, check the code again.
    */
   pf_lineoff = ys_line % PF_HEIGHT;
   pf_addr = (ufix32 FAR *)(PF_BASE + pf_lineoff *
                (PF_WIDTH >> WORDPOWER) );
#ifdef DBG
   printf("scanline32_pfREP(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone      F = H & P
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);

     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (lmask & rmask & *htb_ptr & pf)
                          | (*ptr & ~(lmask & rmask));
                    continue;
                }
                *ptr++ = (lmask & *htb_ptr++ & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                    *ptr++ = *htb_ptr++ & pf;
                *ptr = (rmask & *htb_ptr & pf) | (*ptr & ~rmask);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black      F = P
      */
     while(no_lines-- >0) {
        ufix32  pf = *pf_addr;
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = (lmask & rmask & pf) | (*ptr & ~(lmask & rmask));
                   continue;
                }
                *ptr++ = (lmask & pf) | (*ptr & ~lmask);
                while(--nwords > 0)
                  *ptr++ = pf;
                *ptr = (rmask & pf) | (*ptr & ~rmask);
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

        /*
         * move pfill pattern to next line.
         */
        if(++pf_lineoff == PF_HEIGHT){
           pf_addr = (ufix32 FAR *)PF_BASE;
           pf_lineoff = 0;
        }
        else
           pf_addr += PF_WIDTH >> WORDPOWER;
     } /* while */

  } /* if else */
/* in order to reduce code size, call normal eofill/fill to achieve it
 *else {
 *   (*
 *    * case 3: halftone pattern white      F = 0
 *    *)
 *              :
 *              :
 *}
 */
} /* gp_scanline32_pfREP */

#endif

/* ************************************************************************
 *      gp_scanline32(): Filling into FRame Buffer, CMB or Seed
 *
 *              Divide into 3 cases: SOLID(BLACK), WHITE, SOLID+HALFTONE.
 * ************************************************************************ */
void    gp_scanline32(dst_bmap, halftone, ys_line, no_lines, scanlist)
struct    bitmap   FAR *dst_bmap;
ufix16    halftone;
fix       ys_line, no_lines;
SCANLINE  FAR *scanlist;
{

register  fix          nwords;                 /* ufix -> fix  11-08-88 */
register  ufix32       huge *ptr;               // FAR -> huge
register  ufix32       FAR *htb_ptr;
register  SCANLINE     xs, xe;
register  ufix32       bb_width;
          ufix32       huge *scan_addr;         // FAR -> huge
          ufix32       lmask, rmask;
          ufix32       FAR *htb_addr;
          ufix32       ht_lineoff;
          ufix32       hw, sw;

#ifdef  DBG
    printf("scanline32: %6.6lx %4x %4x %4x\n",
           dst_bmap->bm_addr, halftone, ys_line, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   bb_width = dst_bmap->bm_cols >> WORDPOWER; //Note: bm_cols should be in long
                                              //      word boundary @WINFLOW
// scan_addr = (ufix32 *)dst_bmap->bm_addr + (ys_line * bb_width);
   scan_addr = (ufix32 huge *)dst_bmap->bm_addr + ((DWORD)ys_line * bb_width);

#ifdef DBG
   printf("scanline32(), bb_addr = %lx, no_lines = %x\n", bb_addr, no_lines);
#endif
   /*
    * divide into 3 cases (Apply halftone, Black, White),
    * process line by line.
    */
  if(halftone & HT_APPLY) {

     /*
      * case 1: apply halftone
      */
     ht_lineoff = ys_line % HT_HEIGH;
     hw = HT_WIDTH >> WORDPOWER;
     htb_addr = (ufix32 FAR *)HTB_BASE + (ht_lineoff * hw);


     while(no_lines-- >0) {

        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {/* check bitmap boundary @WINFLOW*/
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)   /* check bitmap boundary @WINFLOW*/
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix)((xe >> WORDPOWER) - sw);         //@WIN
              /*
               * apply halftone
               */
                htb_ptr = htb_addr + (xs >> WORDPOWER);

                if(nwords == 0) {
                   *ptr = (*ptr & ~(lmask&rmask)) | (lmask & rmask & *htb_ptr);
                    continue;
                }
                *ptr++ = (*ptr & ~lmask) | (lmask & *htb_ptr++);
                while(--nwords > 0)
                    *ptr++ = *htb_ptr++;
                *ptr = (*ptr & ~rmask) | (rmask & *htb_ptr);
        }  /* while */
        /*
         * move halftone & scanline address to next line.
         */
        scan_addr += bb_width;
        if(++ht_lineoff == (ufix32)HT_HEIGH){   //@WIN
           htb_addr = (ufix32 FAR *)HTB_BASE;
           ht_lineoff = 0;
        }
        else
           htb_addr += hw;

     } /* while */
  }
  else if(halftone == FC_BLACK || halftone == FC_SOLID)
  {
     /*
      * case 2: halftone pattern black
      */
     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {    /* check bitmap boundary */
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;

                if(xe > dst_bmap->bm_cols)       /* check bitmap boundary */
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = *ptr | (lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr | lmask;
                while(--nwords > 0)
                  *ptr++ = ONE32;
                *ptr = *ptr | rmask;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;
     } /* while */

  } /* if else */
  else
  {
     /*
      * case 3: halftone pattern white
      */
     while(no_lines-- >0) {

        /*
         * process segment by segment
         */
        while( (xs = *scanlist++) != (SCANLINE)END_OF_SCANLINE ) {
                /*
                 * process one segment in a scanline
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */
                if(xs >= dst_bmap->bm_cols) {
                   scanlist++;
                   continue;
                }
                xe = *scanlist++ + 1;
                if(xe > dst_bmap->bm_cols)
                   xe = (SCANLINE)dst_bmap->bm_cols;

                sw = xs >> WORDPOWER;
                ptr = scan_addr + sw;

                lmask = ONE32 LSHIFT (xs & WORDMASK);
                rmask = BRSHIFT(ONE32,(BITSPERWORD -(xe & WORDMASK)),32);

                // swapping for @WINFLOW
                LWORDSWAP(lmask);
                LWORDSWAP(rmask);

                nwords = (fix) ((xe >> WORDPOWER) - sw);        //@WIN
                if(nwords == 0) {
                   *ptr = *ptr & ~(lmask & rmask);
                   continue;
                }
                *ptr++ = *ptr & ~lmask;
                while(--nwords > 0)
                  *ptr++ = ZERO;
                *ptr = *ptr & ~rmask;
        }  /* while */

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width;

     } /* while */

  } /* else */
} /* gp_scanline32 */

void
ImageClear(type)
ufix32     type;                        /* fix => ufix32 @WIN */
{
#ifdef  DUMBO
        ufix32  huge *ptr;
#else
        ufix32  FAR *ptr;       // @DLL
#endif
        fix32   size, size8;

#ifdef DBG1
   printf("ImageClear() : %lx, %lx\n", FB_ADDR, FB_WIDTH);
#endif
#ifndef  DUMBO
//DJC need this for multi page support so frame buffer will clear        return;               /* @WINFLOW; force to do nothing */

        ptr = (ufix32 FAR *)FB_ADDR;
        size = FB_HEIGH * (FB_WIDTH >> 5);
#else
        ptr = (ufix32 huge *)FB_ADDR;                           // @DLL
        size = (DWORD)FB_HEIGH * (DWORD)(FB_WIDTH >> 5);        // @DLL
#endif

        size8 = size >> 3;
        if (type == BM_WHITE) {
           while(size8--) {
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
              *ptr++ = 0L;
           }
           size8 = size & 0x7;
           while(size8--)
              *ptr++ = 0L;
        } else {
           while(size8--) {
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
              *ptr++ = 0xffffffffL;
           }
           size8 = size & 0x7;
           while(size8--)
              *ptr++ = 0xffffffffL;
        }
}

/* Following code added for stroke enhancement  -jwm, 3/18/91, -begin- */

static ufix32 l_mask32[32] = {
        0xFFFFFFFF, 0x7FFFFFFF, 0x3FFFFFFF, 0x1FFFFFFF,
        0x0FFFFFFF, 0x07FFFFFF, 0x03FFFFFF, 0x01FFFFFF,
        0x00FFFFFF, 0x007FFFFF, 0x003FFFFF, 0x001FFFFF,
        0x000FFFFF, 0x0007FFFF, 0x0003FFFF, 0x0001FFFF,
        0x0000FFFF, 0x00007FFF, 0x00003FFF, 0x00001FFF,
        0x00000FFF, 0x000007FF, 0x000003FF, 0x000001FF,
        0x000000FF, 0x0000007F, 0x0000003F, 0x0000001F,
        0x0000000F, 0x00000007, 0x00000003, 0x00000001
        };

static ufix32 r_mask32[32] = {
        0x00000000, 0x80000000, 0xC0000000, 0xE0000000,
        0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,
        0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,
        0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,
        0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,
        0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,
        0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,
        0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE
        };



void do_fill_box (ul_coord, lr_coord)
struct coord_i FAR *ul_coord, FAR *lr_coord;
{
    ufix32      FAR *fb_ptr, FAR *fb_addr, FAR *htb_ptr, FAR *htb_addr;
    ufix32      left_mask, right_mask;
    fix16       current_y, bottom_y, nwords, word_ctr;
    fix16       left_x, right_x, left_word, fb_words, ht_words, ht_lineoff;

    if (HTP_Flag == HT_CHANGED) {                    /* jwm, 1/30/91 */
        HTP_Flag =  HT_UPDATED;
        expand_halftone();
        }

    current_y = SFX2I(ul_coord->y);
/*    current_y = SFX2I_T(ul_coord->y); */

/*    bottom_y = SFX2I(lr_coord->y);    */
    bottom_y = SFX2I_T(lr_coord->y);

    left_x = SFX2I(ul_coord->x);
/*    left_x = SFX2I_T(ul_coord->x);    */
    left_word = left_x >> WORDPOWER;
    right_x = SFX2I(lr_coord->x);

    fb_addr = (ufix32 FAR *) (FB_ADDR + current_y * (FB_WIDTH >> 3)) + left_word;
    fb_words = FB_WIDTH >> WORDPOWER;

    left_mask = l_mask32[left_x & WORDMASK];

    right_mask = r_mask32[right_x & WORDMASK];

    nwords = (right_x >> WORDPOWER) - left_word;
/*  fb_marked = TRUE;    * 5-7-91, Jack */

    if (HTP_Type == HT_MIXED) {
        ht_lineoff = current_y % HT_HEIGH;
        htb_addr = (ufix32 FAR *)(HTB_BASE + ht_lineoff * (HT_WIDTH >> 3)) + left_word;
        ht_words = HT_WIDTH >> WORDPOWER;

        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;
            htb_ptr = htb_addr;
            word_ctr = nwords;
            if (!word_ctr) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }

            fb_addr += fb_words;
            if (++ht_lineoff == HT_HEIGH) {
                htb_addr = (ufix32 FAR *)HTB_BASE + left_word;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            }
        }

    else if ((FC_Paint == FC_BLACK) || (FC_Paint == FC_SOLID)) {
        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;

            word_ctr = nwords;
            if (!word_ctr) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = left_mask | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = right_mask | (*fb_ptr & ~right_mask);
                }

            fb_addr += fb_words;
            }
        }

    else {
        for ( ; current_y <= bottom_y; current_y++) {
            fb_ptr = fb_addr;
            word_ctr = nwords;
            if (!word_ctr) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = *fb_ptr & ~left_mask;
                ++fb_ptr;
                while (--word_ctr > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = *fb_ptr & ~right_mask;
                }

            fb_addr += fb_words;
            }
        }
}

void do_fill_rect (rect1)
struct line_seg_i FAR *rect1;
{
#ifdef  _AM29K
    volatile
#endif
    lfix_t  lx_incr, rx_incr;
    register    ufix32  FAR *fb_ptr;
    register    fix     current_y;
    register    fix16   current_lx, current_rx;
    fix         critical_y0, critical_y1, critical_y2, bottom_y;
    fix16       adj_lx0, adj_lx1, adj_rx0, adj_rx1;
    lfix_t      lx_intercept, rx_intercept, left_x, left_y, right_x, right_y, frac_y;
    lfix_t      lx_step0, lx_step1, lx_step2, rx_step0, rx_step1, rx_step2;
    lfix_t      critical_lx0, critical_lx1, critical_lx2;
    lfix_t      critical_rx0, critical_rx1, critical_rx2;
    lfix_t      abs_dx, abs_dy, slope1, slope2, tmp_l1, tmp_l2, tmp_l3, tmp_l4, tmp_l5;
    ufix32      FAR *fb_addr, FAR *htb_addr, FAR *htb_ptr;
    ufix32      left_mask, right_mask;
    fix16       left_word, fb_words, ht_words, ht_lineoff, nwords;
    byte        adjust_right, adjust_left;

    if (rect1->p0.x <= rect1->p1.x) {
        left_x = SFX2LFX(rect1->p0.x);
        left_y = SFX2LFX(rect1->p0.y);
        right_x = SFX2LFX(rect1->p1.x);
        right_y = SFX2LFX(rect1->p1.y);
        }
    else {
        left_x = SFX2LFX(rect1->p1.x);
        left_y = SFX2LFX(rect1->p1.y);
        right_x = SFX2LFX(rect1->p0.x);
        right_y = SFX2LFX(rect1->p0.y);
        }

    if ((abs_dx = SFX2LFX(rect1->vct_d.x)) < 0)
        abs_dx = -abs_dx;
    if ((abs_dy = SFX2LFX(rect1->vct_d.y)) < 0)
        abs_dy = -abs_dy;

    tmp_l1 = abs_dy << 1;
    tmp_l4 = right_x - left_x;

    if ((tmp_l3 = left_y - right_y) < 0) {
        tmp_l3 = -tmp_l3;
        slope1 = FixDiv(tmp_l3, tmp_l4);
        slope2 = FixDiv(tmp_l4, tmp_l3);

/*      lx_step[0] = -slope1;
 *      rx_step[0] = slope2;
 */

        lx_intercept = rx_intercept = left_x + abs_dx;
        tmp_l2 = left_y - abs_dy;
        current_y = LFX2I(tmp_l2);

        tmp_l4 = right_y + abs_dy;
        critical_y2 = LFX2I(tmp_l4) + 1;
        critical_lx2 = critical_rx2 = right_x - abs_dx;
        if (tmp_l1 <= tmp_l3) {

            critical_y0 = LFX2I(left_y + abs_dy);
            critical_y1 = LFX2I(right_y - abs_dy);
            critical_lx0 = left_x - abs_dx;
            critical_rx0 = left_x + abs_dx + FixMul(slope2,tmp_l1);
            adj_lx0 = *((fix16 FAR *)(&critical_lx0));

            tmp_l3 -= tmp_l1;
            critical_lx1 = left_x - abs_dx + FixMul(slope2,tmp_l3);
            critical_rx1 = right_x + abs_dx;
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = slope2;
 *          rx_step[1] = slope2;
 *          lx_step[2] = slope2;
 *          rx_step[2] = -slope1;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y - tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - left_y - abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 -= (lx_step1 >> 1);
                critical_rx0 += (rx_step1 >> 1);
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - right_y + abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 1;
            adjust_right = 0;

            }
        else {

            critical_y0 = LFX2I(right_y - abs_dy);
            critical_y1 = LFX2I(left_y + abs_dy);
            critical_lx0 = left_x + abs_dx - FixMul(slope1,tmp_l3);
            critical_rx0 = right_x + abs_dx;
            adj_rx0 = *((fix16 FAR *)(&critical_rx0));

            tmp_l3 = tmp_l1 - tmp_l3;
            critical_lx1 = left_x - abs_dx;
            critical_rx1 = right_x + abs_dx - FixMul(slope1,tmp_l3);
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = -slope1;
 *          rx_step[1] = -slope1;
 *          lx_step[2] = slope2;
 *          rx_step[2] = -slope1;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = (right_y - left_y) >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y + tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y) >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - right_y + abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 += (lx_step1 >> 1);
                critical_rx0 -= (rx_step1 >> 1);
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - left_y - abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 0;
            adjust_right = 1;

            }
        }
    else {

        slope1 = FixDiv(tmp_l3, tmp_l4);
        slope2 = FixDiv(tmp_l4, tmp_l3);

/*      lx_step[0] = -slope2;
 *      rx_step[0] = slope1;
 */

        lx_intercept = rx_intercept = right_x - abs_dx;
        tmp_l2 = right_y - abs_dy;
        current_y = LFX2I(tmp_l2);

        tmp_l4 = left_y + abs_dy;
        critical_y2 = LFX2I(tmp_l4) + 1;
        critical_lx2 = critical_rx2 = left_x + abs_dx;
        if (tmp_l1 <= tmp_l3) {

            critical_y0 = LFX2I(right_y + abs_dy);
            critical_y1 = LFX2I(left_y - abs_dy);
            critical_lx0 = right_x - abs_dx - FixMul(slope2,tmp_l1);
            critical_rx0 = right_x + abs_dx;
            adj_rx0 = *((fix16 FAR *)(&critical_rx0));

            tmp_l3 -= tmp_l1;
            critical_lx1 = left_x - abs_dx;
            critical_rx1 = right_x + abs_dx - FixMul(slope2,tmp_l3);
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = -slope2;
 *          rx_step[1] = -slope2;
 *          lx_step[2] = slope1;
 *          rx_step[2] = -slope2;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y - tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {

                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = tmp_l1 >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {

                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }

            if (critical_y0 == critical_y1) {
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - right_y - abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 += (lx_step1 >> 1);
                critical_rx0 -= (rx_step1 >> 1);
                adj_lx0 = *((fix16 FAR *)(&critical_lx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - left_y + abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 0;
            adjust_right = 1;

            }
        else {

            critical_y0 = LFX2I(left_y - abs_dy);
            critical_y1 = LFX2I(right_y + abs_dy);
            critical_lx0 = left_x - abs_dx;
            critical_rx0 = right_x - abs_dx + FixMul(slope1,tmp_l3);
            adj_lx0 = *((fix16 FAR *)(&critical_lx0));

            tmp_l3 = tmp_l1 - tmp_l3;
            critical_lx1 = left_x - abs_dx + FixMul(slope1,tmp_l3);
            critical_rx1 = right_x + abs_dx;
            adj_lx1 = *((fix16 FAR *)(&critical_lx1));
            adj_rx1 = *((fix16 FAR *)(&critical_rx1));

/*          lx_step[1] = slope1;
 *          rx_step[1] = slope1;
 *          lx_step[2] = slope1;
 *          rx_step[2] = -slope2;
 */
/*  Recalculation of lx_steps & rx_steps for pixel-by-pixel compatibility w/gp_scanconv */
            tmp_l5 = (left_y - right_y) >> 13;
            if (!tmp_l5) {
                lx_step0 = rx_step0 = 0;
                }
            else {
                lx_step0 = ((critical_lx0 - lx_intercept) << 3) / tmp_l5;
                rx_step0 = ((critical_rx0 - rx_intercept) << 3) / tmp_l5;
                }

            tmp_l5 = (right_y - left_y + tmp_l1) >> 13;
            if (!tmp_l5) {
                lx_step1 = rx_step1 = 0;
                }
            else {
                lx_step1 = ((critical_lx1 - critical_lx0) << 3) / tmp_l5;
                rx_step1 = ((critical_rx1 - critical_rx0) << 3) / tmp_l5;
                }

            tmp_l5 = (left_y - right_y) >> 13;
            if (!tmp_l5) {
                lx_step2 = rx_step2 = 0;
                }
            else {
                lx_step2 = ((critical_lx2 - critical_lx1) << 3) / tmp_l5;
                rx_step2 = ((critical_rx2 - critical_rx1) << 3) / tmp_l5;
                }


            if (critical_y0 == critical_y1) {
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }
            else {
                frac_y = I2LFX(critical_y0) - left_y + abs_dy;
                critical_lx0 += FixMul(lx_step1,frac_y);
                critical_rx0 += FixMul(rx_step1,frac_y);
                critical_lx0 -= (lx_step1 >> 1);
                critical_rx0 += (rx_step1 >> 1);
                adj_rx0 = *((fix16 FAR *)(&critical_rx0));
                }

            if (critical_y2 - critical_y1 > 2) {
                frac_y = I2LFX(critical_y1) - right_y - abs_dy;
                critical_lx1 += FixMul(lx_step2,frac_y);
                critical_rx1 += FixMul(rx_step2,frac_y);
                critical_lx1 -= (lx_step2 >> 1);
                critical_rx1 -= (rx_step2 >> 1);
                }

            adjust_left = 1;
            adjust_right = 0;

            }
        }

    if ((critical_y0 - current_y) > 0) {  /* 1st band not degenerate -modified 4/1/91 */
        /* modify x_coord as y_coord advances to pixel position, a la gp_scanconv() */
        frac_y = I2LFX(current_y) - tmp_l2;
        lx_intercept += FixMul(frac_y,lx_step0);
        rx_intercept += FixMul(frac_y,rx_step0);
        lx_intercept += lx_step0 >> 1;
        rx_intercept += rx_step0 >> 1;
        }

    if (HTP_Flag == HT_CHANGED) {
        HTP_Flag =  HT_UPDATED;
        expand_halftone();
        }

    fb_addr = (ufix32 FAR *) (FB_ADDR + current_y * (FB_WIDTH >> 3));
    fb_words = FB_WIDTH >> WORDPOWER;
/*  fb_marked = TRUE;    * 5-7-91, Jack */

    if ((FC_Paint == FC_BLACK) || (FC_Paint == FC_SOLID)) {

        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect10;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect10:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect11;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect11:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect12;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = ONE32;
                *fb_ptr = (right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect12:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }

    else if (HTP_Type == HT_MIXED) {
        ht_lineoff = current_y % HT_HEIGH;
        htb_addr = (ufix32 FAR *)(HTB_BASE + ht_lineoff * (HT_WIDTH >> 3));
        ht_words = HT_WIDTH >> WORDPOWER;
        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect20;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect20:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect21;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect21:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect22;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            htb_ptr = htb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                left_mask = left_mask & right_mask;
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                }
            else {
                *fb_ptr = (*htb_ptr & left_mask) | (*fb_ptr & ~left_mask);
                ++fb_ptr;
                ++htb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = *htb_ptr++;
                *fb_ptr = (*htb_ptr & right_mask) | (*fb_ptr & ~right_mask);
                }
neg_rect22:
            fb_addr += fb_words;
            if(++ht_lineoff == HT_HEIGH){
                htb_addr = (ufix32 FAR *)HTB_BASE;
                ht_lineoff = 0;
                }
            else
                htb_addr += ht_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }

    else {

        current_lx = *((fix16 FAR *)(&lx_intercept));
        current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
        bottom_y = critical_y0;
        lx_incr = lx_step0;
        rx_incr = rx_step0;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect30;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect30:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx0;
        current_lx = adj_lx0;
        rx_intercept = critical_rx0;
        current_rx = adj_rx0 + 1;
        lx_incr = lx_step1;
        rx_incr = rx_step1;
        bottom_y = critical_y1;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect31;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect31:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }

        lx_intercept = critical_lx1;
        if (adjust_left) {
            current_lx = MIN(current_lx,adj_lx1);
            }
        else
            current_lx = adj_lx1;
        rx_intercept = critical_rx1;
        if (adjust_right) {
            current_rx = MAX(current_rx,(adj_rx1 + 1));
            }
        else
            current_rx = adj_rx1 + 1;
        lx_incr = lx_step2;
        rx_incr = rx_step2;
        bottom_y = critical_y2;

        while (current_y < bottom_y) {
            if (current_lx > current_rx)
                goto neg_rect32;
            left_mask = l_mask32[current_lx & WORDMASK];
            right_mask = r_mask32[current_rx & WORDMASK];
            left_word = current_lx >> WORDPOWER;
            fb_ptr = fb_addr + left_word;
            nwords = (current_rx >> WORDPOWER) - left_word;
            if (!nwords) {
                *fb_ptr = *fb_ptr & ~(left_mask & right_mask);
                }
            else {
                *fb_ptr = (*fb_ptr & ~left_mask);
                ++fb_ptr;
                while (--nwords > 0)
                    *fb_ptr++ = 0;
                *fb_ptr = (*fb_ptr & ~right_mask);
                }
neg_rect32:
            fb_addr += fb_words;
            lx_intercept += lx_incr;
            current_lx = *((fix16 FAR *)(&lx_intercept));
            rx_intercept += rx_incr;
            current_rx = *((fix16 FAR *)(&rx_intercept)) + 1;
            ++current_y;
            }
        }
    return;
}
/* -jwm, 3/18/91, -end- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgbx.c ===
/**********************************************************************
 *
 *  Name:       fillgbx.c
 *
 *  Purpose:    This file contains routines for performing bitblt related
 *              operations.
 *
 *  History:
 *  SCChen      10/07/92    Move in bitblt related functions from fillgb.c:
 *                          gp_bitblt16 gp_bitblt32
 *                          gp_pixels16 gp_pixels32
 *                          gp_cacheblt16
 *                          gp_bitblt16_32
 *                          gp_charblt16 gp_charblt32 gp_charblt16_cc
 *                          gp_charblt16_clip gp_charblt32_clip
 *                          gp_patblt gp_patblt_m gp_patblt_c
 **********************************************************************/



// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fillproc.h"
#include        "fillproc.ext"
// Short & long word swapping @WINFLOW
#ifdef  bSwap
#define WORDSWAP(lw) \
        (lw =  (lw << 16) | (lw >> 16))
#define SWORDSWAP(sw) \
        (sw =  (sw << 8) | (sw >> 8))
#define LWORDSWAP(lw) \
        (lw =  (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000))
#define S2WORDSWAP(lw) \
        (lw = ((lw >> 8) & 0x00ff00ff) | ((lw << 8) & 0xff00ff00))
#define SWAPWORD(lw) (lw = (lw << 16) | (lw >> 16))
#else
#define WORDSWAP(lw)    (lw)
#define SWORDSWAP(sw)   (sw)
#define LWORDSWAP(lw)   (lw)
#define S2WORDSWAP(lw)  (lw)
#define SWAPWORD(lw) (lw)
#endif

/* -----------------------------------------------------------------------
 * BITBLT SIMULATION
 *
 * Function Description:
 *           Move bitmap from source to destination with logical
 *           operation in a graphics buffer or between graphics
 *           buffer and character cache buffer.
 *           source bitmap width must equal destination bitmap
 *           width.
 *           simulate graphics bitblt with following logical operations:
 *           FC_MOVES: source                   --> destination
 *           FC_CLIPS: source .AND. destination --> destination
 *           FC_MERGE: source .OR.  destination --> destination
 *           FC_CLEAR: (.NOT. source)  .AND. (destination) --> destination
 *           FC_MERGE | HT_APPLY:
 *               Step 1. Clear destination for value 1 on source.
 *               Step 2. (source AND halftone) --> source.
 *               Step 3. (source OR destination) --> destination.
 *
 *
 * By : M.S Lin
 * Date : May 18, 1988
 *
 * History :
 *        5/24/88  check if nwords == 0 in rowcopy().
 *        8-12-88  Update interface to consistant with Y.C Chen.
 *        11-12-88 Code reduction for portable to single CPU environment.
 *
 * Calling sequence:
 *   gp_bitblt16(DST, DX, DY, W, H, HT_FC, SRC, SX, SY): For bitmap width 16X
 *   gp_bitblt32(DST, DX, DY, W, H, HT_FC, SRC, SX, SY): For bitmap width 32X
 *
 *   struct bitmap *DST;      address of destination bitmap
 *   fix            DX;       X origin of destination rectangle
 *   fix            DY;       Y origin of destination rectangle
 *   fix            W;        width  of rectangle to be bitblted
 *   fix            H;        height of rectangle to be bitblted
 *   ufix16         HT_FC;    operation flag: halftoning flag and
 *                                            logical function
 *   struct bitmap *SRC;      address of source bitmap
 *   fix            SX;       X origin of source rectangle
 *   fix            SY;       Y origin of source rectangle
 *
 * Diagram Description:
 *
 *   DST +---------------------------+   SRC +-----------------------+
 *       |                           |       |       |<-- W -->|     |
 *       |       |<-- W -->|         |       |(SX,SY)*---------+ --- |
 *       |(DX,DY)*---------+ ---     |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  H  |
 *       |       |         |  H      |       |       |         |  |  |
 *       |       |         |  |      |       |       |         |  |  |
 *       |       |         |  |      |       |       +---------+ --- |
 *       |       +---------+ ---     |       |                       |
 *       |                           |       |                       |
 *       |                           |       +-----------------------+
 *       |                           |
 *       |                           |
 *       |                           |
 *       +---------------------------+
 * ----------------------------------------------------------------------- */


/* *************************************************************************
 *      gp_bitblt16(): Bitblt with 16 bit operations.
 *
 * ************************************************************************* */
void
gp_bitblt16(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
   ufix16              huge *db;        /* FAR => huge @WIN */
    fix                 sw;
   ufix16              FAR *sb;
    fix                 hw;
    fix                 hy;
   ufix16              FAR *hb;
    fix                 ls, rs;
    fix                 xs, xe;
    fix                 now, cow;
   ufix16              FAR *hs;

#ifdef  DBGbb
    printf("bitblt16: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> SHORTPOWER;                         /* @DST */
//      db = &((ufix16 FAR *) dst->bm_addr)[dy * dw + (dx >> SHORTPOWER)];
        db = (ufix16 huge *) dst->bm_addr +             /*@WIN*/
             ((ufix32)dy * dw + ((ufix32)dx >> SHORTPOWER));
        sw = src->bm_cols >> SHORTPOWER;                         /* @SRC */
        sb =  ((ufix16 FAR *) src->bm_addr);

        /*  calculate starting and ending coordinate of x
         */
        xs = dx;
        xe = dx + w - 1;
        now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

        /*  calculate shifts and masks based on from SRC to DST
         */
        rs = dx & SHORTMASK;                            /* right shift */
        ls = BITSPERSHORT - rs;                         /* left  shift */

        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> SHORTPOWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = (ufix16 FAR *)HTB_Bmap.bm_addr + (dx >> SHORTPOWER);
        hb = hs + (hy * hw);

        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1, hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & sb[0]);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] &  (CC_RIGH_SHIFT(sb[0], rs)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= CC_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & CC_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(CC_LEFT_SHIFT(sb[0], ls))) |
                            (hb[1] & CC_LEFT_SHIFT(sb[0], ls));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & CC_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(CC_LEFT_SHIFT(sb[0], ls)
                                   |   CC_RIGH_SHIFT(sb[1], rs))) |
                            (hb[1] & (CC_LEFT_SHIFT(sb[0], ls)
                                   |  CC_RIGH_SHIFT(sb[1], rs)));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(CC_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] & (CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    db[0] = (db[0] & ~(CC_LEFT_SHIFT(sb[0], ls)
                                   |   CC_RIGH_SHIFT(sb[1], rs))) |
                            (hb[0] & (CC_LEFT_SHIFT(sb[0], ls)
                                   |  CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = (db[0] & ~(CC_LEFT_SHIFT(sb[0], ls))) |
                        (hb[0] & (CC_LEFT_SHIFT(sb[0], ls)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

} /* gp_bitblt16 */

/* ***********************************************************************
 *      gp_bitblt32(): Bitblt with 32 bits operation.
 *
 * *********************************************************************** */
void
gp_bitblt32(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    BM_DATYP            fm, sm, mm;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32              tmprs0;             /*@WIN 05-12-92*/
    ufix32              tmp0, tmp1;             /*@WIN 05-12-92*/


#ifdef  DBG
    printf("bitblt32: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)];
    db = (BM_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

    switch (fc)
    {
    case FC_MOVES:            /*  0001  D <-  S          */

        fm =  BM_L_MASK(xs);                                /* first  mask */
        sm =  BM_R_MASK(xe);                                /* second mask */
        LWORDSWAP(fm);                  /*@WIN 05-12-92*/
        LWORDSWAP(sm);                  /*@WIN 05-12-92*/
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = sb[0];
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            mm = fm & sm;
            for (; h > 0; db+= dw, sb+= sw, h--) {      /*@WIN 05-12-92*/
                tmp0 = sb[0];
                LWORDSWAP(tmp0);
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~mm) + (LWORDSWAP(tmp0) & mm);
            }
            /*  @WIN 05-12-92
            for (; h > 0; db+= dw, sb+= sw, h--)
                db[0] = (db[0] & ~mm) + (BM_RIGH_SHIFT(sb[0], rs) & mm);
            */
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmp0 = sb[0];            /*@WIN 05-12-92 begin*/
                LWORDSWAP(tmp0);
                tmp1 = tmp0;
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~fm) + (LWORDSWAP(tmp0) & fm);
                tmp0 = BM_LEFT_SHIFT(tmp1, ls);
                tmp1 = sb[1];
                LWORDSWAP(tmp1);
                tmp1 = tmp0 | BM_RIGH_SHIFT(tmp1, rs);
                db[1] = (db[1] & ~sm) + (LWORDSWAP(tmp1) & sm); /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~fm) + (BM_RIGH_SHIFT(sb[0], rs) & fm);
                db[1] = (db[1] & ~sm) + ((BM_LEFT_SHIFT(sb[0], ls) |
                                          BM_RIGH_SHIFT(sb[1], rs)) & sm);
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmp0 = sb[0];                   /*@WIN 05-12-92 begin*/
                LWORDSWAP(tmp0);
                tmp0 = BM_RIGH_SHIFT(tmp0, rs);
                db[0] = (db[0] & ~fm) + (LWORDSWAP(tmp0) & fm);
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmp0 = sb[0];
                    LWORDSWAP(tmp0);
                    tmp1 = sb[1];
                    LWORDSWAP(tmp1);
                    tmp1 = (BM_LEFT_SHIFT(tmp0, ls) |
                            BM_RIGH_SHIFT(tmp1, rs));
                    db[0] = LWORDSWAP(tmp1);
                }
                tmp0 = sb[0];
                LWORDSWAP(tmp0);
                tmp0 = BM_LEFT_SHIFT(tmp0, ls);
                tmp1 = sb[1];
                LWORDSWAP(tmp1);
                tmp1 = BM_RIGH_SHIFT(tmp1, rs);
                tmp1 = LWORDSWAP(tmp0) | LWORDSWAP(tmp1); /* compiler ???*/
                db[0] = (db[0] & ~sm) + (tmp1 & sm); /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~fm) + (BM_RIGH_SHIFT(sb[0], rs) & fm);
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = (BM_LEFT_SHIFT(sb[0], ls) |
                             BM_RIGH_SHIFT(sb[1], rs));
                db[0] = (db[0] & ~sm) + ((BM_LEFT_SHIFT(sb[0], ls) |
                                          BM_RIGH_SHIFT(sb[1], rs)) & sm);
                */
            }
        }
        break;

    case HT_APPLY:              /*  D <- (D .AND. .NOT. S) .OR.
                                         (S .AND. HT)                   */
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = (BM_DATYP FAR *)HTB_Bmap.bm_addr + (dx >> BM_WORD_POWER);
        hb = hs + (hy * hw);

        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1, hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & sb[0]);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0)) |
                        (hb[0] &  (tmprs0));
                /*  @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & BM_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls))) |
                            (hb[1] & BM_LEFT_SHIFT(sb[0], ls));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                            (hb[0] & BM_RIGH_SHIFT(sb[0], rs));
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls)
                                   |   BM_RIGH_SHIFT(sb[1], rs))) |
                            (hb[1] & (BM_LEFT_SHIFT(sb[0], ls)
                                   |  BM_RIGH_SHIFT(sb[1], rs)));
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |
                        (hb[0] & (BM_RIGH_SHIFT(sb[0], rs)));
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls)
                                   |   BM_RIGH_SHIFT(sb[1], rs))) |
                            (hb[0] & (BM_LEFT_SHIFT(sb[0], ls)
                                   |  BM_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls))) |
                        (hb[0] & (BM_LEFT_SHIFT(sb[0], ls)));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        break;

#ifdef DBGwarn
    default:
        printf("gp_bitblt32: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_bitblt32 */


/* ---------------------------------------------------------------------
 *      gp_pixels16(): fill pixels onto character cache
 * --------------------------------------------------------------------- */
void    gp_pixels16(bufferptr, logical, no_pixel, pixelist)
struct  bitmap    FAR *bufferptr;
fix               logical;
fix               no_pixel;
PIXELIST     FAR *pixelist;
{
    fix16    FAR *ptr;
    PIXELIST xc, yc;

    while(no_pixel--) {
       xc = *pixelist++;
       yc = *pixelist++;
       ptr = (fix16 FAR *)( bufferptr->bm_addr +
             (xc >> 4 << 1) + (yc * (bufferptr->bm_cols >> 3)) );

       *ptr = (ONE1_16 LSHIFT (xc & SHORTMASK)) | *ptr;
    }

    return;
} /* gp_pixels16 */

/* ---------------------------------------------------------------------
 *      gp_pixels32(): fill pixels onto page buffer
 * --------------------------------------------------------------------- */
void    gp_pixels32(bufferptr, logical, no_pixel, pixelist)
struct  bitmap    FAR *bufferptr;
ufix               logical;             /* @WIN */
fix               no_pixel;
PIXELIST     FAR *pixelist;
{
   ufix      FAR *ptr, FAR *ht_ptr;
   PIXELIST  xc, yc;

   switch(logical){

     case FC_BLACK:
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr +
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );

           *ptr = (ufix)(ONE1_32 LSHIFT (xc & WORDMASK)) | *ptr;        //@WIN
        }
        break;

     case FC_WHITE:
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr+
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );

           *ptr = (ufix)(~(ONE1_32 LSHIFT (xc & WORDMASK))) & *ptr; //@WIN
        }
        break;

     case HT_APPLY:
        /* apply halftone */
        while(no_pixel--) {
           xc = *pixelist++;
           yc = *pixelist++;
           ptr = (ufix FAR *)( (ufix FAR *)bufferptr->bm_addr +
                 (xc >> WORDPOWER) + yc * (bufferptr->bm_cols >> WORDPOWER) );
           ht_ptr = (ufix FAR *)
                ((ufix FAR *)HTB_BASE  + (yc % HT_HEIGH) * (HT_WIDTH >>
                 WORDPOWER) + (xc >> WORDPOWER) );
          /*
           * filling also apply halftone
           */
           *ptr = (ufix)((ONE1_32 LSHIFT (xc & WORDMASK)) & *ht_ptr) | *ptr;//@WIN
        }
        break;

      default:
        break;
   }

   return;
} /* gp_pixels32 */

void   gp_cacheblt16(dbuf_ptr, dx, dy, swidth, sheight, sbuf_ptr, sx, sy)
struct bitmap FAR *sbuf_ptr, FAR *dbuf_ptr;
fix           dx, dy, swidth, sheight, sx, sy;
{
register  ufix16        FAR *sbase, FAR *dbase;
register  fix           sword, dword, nwords, offD;
ufix16        FAR *src_addr, FAR *dst_addr;
fix           soffset, doffset;
fix           lmask, rmask, i, j;

#ifdef DBG
  printf("Enter gp_cacheblt16()\n");
  printf("   src addr = %lx, dest addr = %lx, sx = %lx, sy = %lx\n",
          sbuf_ptr->bm_addr, dbuf_ptr->bm_addr, sx, sy);
  printf("w = %ld, h = %ld\n", swidth, sheight);
#endif

        /*
         * caculate source & destination bitmap starting address and offset in
         * a word.
         */
        src_addr = (ufix16 FAR *)((ufix16 FAR *)sbuf_ptr->bm_addr +
                   (sy * (sbuf_ptr->bm_cols >> SHORTPOWER) )+
                   ( sx >> SHORTPOWER) );
        soffset = (BITSPERSHORT - (sx & SHORTMASK));
        dst_addr = (ufix16 FAR *)((ufix16 FAR *)dbuf_ptr->bm_addr +
                   (dy * (dbuf_ptr->bm_cols >> SHORTPOWER)) +
                   ( dx >> SHORTPOWER) );
        doffset = (BITSPERSHORT - (dx & SHORTMASK));


        /*
         * setup constant for row copy
         */
        lmask = (ufix16)(ONE16 LSHIFT (BITSPERSHORT-doffset));  //@WIN
        nwords = (swidth - doffset) >> SHORTPOWER;
        rmask = BRSHIFT((ufix16)ONE16,(BITSPERSHORT - ((swidth - doffset) %
                               BITSPERSHORT)),16);      //@WIN
        offD = (doffset > soffset)
               ? (doffset - soffset)
               : (BITSPERSHORT - (soffset - doffset));

#ifdef DBG
   printf("soff=%d, doff=%d, offD=%d, nwords=%d, lmask=%x, rmask=%x\n",
           soffset, doffset, offD, nwords, lmask, rmask);
#endif

    if(swidth < doffset) {
      lmask &= ONE16  RSHIFT (doffset - swidth);

      for(i=0; i<sheight; i++) {

        sbase = src_addr;
        dbase = dst_addr;
        sword = (doffset > soffset)
                ? *sbase++
                : 0;

        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
        *dbase = (dword & lmask) + (*dbase & ~lmask);

        src_addr += (sbuf_ptr->bm_cols >> SHORTPOWER);
        dst_addr += (dbuf_ptr->bm_cols >> SHORTPOWER);
      } /* for */

      return;
    } /* if (swidth < doffset) */
    else {

      for(i=0; i<sheight; i++) {
        sbase = src_addr;
        dbase = dst_addr;
        j = nwords;
        sword = (doffset > soffset)
                ? *sbase++
                : 0;

           /* move left uncomplete word */
/*
        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
 */
        dword = BRSHIFT(sword,offD,16) +
                BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
        *dbase = ((*dbase | dword) & lmask) + (*dbase & ~lmask);
        dbase++;

              /* move # of complete word */
        while(j-- > 0) {
             sword = *sbase++;
/*
             dword = (sword RSHIFT offD) +
                     (*sbase LSHIFT (BITSPERSHORT - offD));
 */
             dword = BRSHIFT(sword,offD,16) +
                     BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
             *dbase = *dbase | dword;
             dbase++;
        }

              /* move right uncomplete word */
        sword = *sbase++;
/*
        dword = (sword RSHIFT offD) + (*sbase LSHIFT (BITSPERSHORT - offD));
 */
        dword = BRSHIFT(sword,offD,16) +
                BLSHIFT(*sbase,(BITSPERSHORT - offD),16);
        *dbase = ((*dbase | dword) & rmask) + (*dbase & ~rmask);

        src_addr += (sbuf_ptr->bm_cols >> SHORTPOWER);
        dst_addr += (dbuf_ptr->bm_cols >> SHORTPOWER);

      } /*for*/
    } /* else */

    return;

} /* gp_cacheblt16 */

#ifndef LBODR
/* ***********************************************************************
 *      gp_bitblt16_32(): Bitblt with 16 bits to 32 bits operation.
 *
 * fill from cache to page, used in high bit ording 32 bits enviroment
 * *********************************************************************** */
void
gp_bitblt16_32(dst, dx, dy, w, h, fc, src, sx, sy)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP       huge *db;        /*@WIN 04-15-92*/
    fix                 sw;
    ufix16             FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32              dword, tword, tmp0;       /*@WIN*/

#ifdef  DBG
    printf("bitblt16_32: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx %4x %4x\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr, sx, sy);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
    db = (BM_DATYP huge *) dst->bm_addr +                       /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));     /*@WIN*/
    sw = src->bm_cols >> SHORTPOWER;                            /* @SRC */
    sb =  ((ufix16 FAR *) src->bm_addr);


    //NTFIX this is only an issue with platforms that dont allow access
    //      to memory posotiong 0
    //
    if (sb == NULL || w == 0 || h == 0 ) {
       return;
    }
    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

                            /*  D <- (D .AND. .NOT. S) .OR.
                                     (S .AND. HT)                   */
    /*  calculate starting address/y and width in words
     */
    hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
    hy = dy % HTB_Bmap.bm_rows;
    hs = (BM_DATYP FAR *)HTB_Bmap.bm_addr + (dx >> BM_WORD_POWER);
    hb = hs + (hy * hw);

    if (w & BM_PIXEL_MASK) {            /* 2 byte boundry */
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= (now + now), hw-= now; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow > 0x00; db++, hb++, cow--) {
                     dword = *sb++;
                     dword = (dword << 16) | *sb++;
                     SWAPWORD(dword);                  /*@WIN*/
                     db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                }
                dword = *sb;
                dword = (dword << 16);
                SWAPWORD(dword);                  /*@WIN*/
                db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb;
                dword = (dword << 16);
                S2WORDSWAP(dword);                      /*@WIN begin*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);       /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);    /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[1] &   BM_LEFT_SHIFT(dword, ls));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (sw-= 2; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                  /*@WIN*/
                    tword = *sb;
                    tword = (tword << 16);
                    S2WORDSWAP(tword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls) | BM_RIGH_SHIFT(tword, rs);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs))) |
                            (hb[1] &  (BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            cow = w >> BM_WORD_POWER;
            if (now == cow)
            {
                for (dw-= now, sw-= (now + now),
                     hw-= now; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                          /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                    */
                    for (db++, hb++, cow = now; cow >= 0x02;
                         db++, hb++, cow--)
                    {
                        tword = dword;
                        dword = *sb++;
                        dword = (dword << 16) | *sb++;
                        S2WORDSWAP(dword);                      /*@WIN begin*/
                        tmp0 = BM_LEFT_SHIFT(tword, ls) |
                               BM_RIGH_SHIFT(dword, rs);
                        LWORDSWAP(tmp0);
                        db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                        /*      @WIN
                        db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs))) |
                                (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs)));
                        */
                    }
                    tword = dword;
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) |
                           BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else
            {
                for (dw-= now, sw-= (now + now - 2),
                     hw-= now; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                    */
                    for (db++, hb++, cow = now; cow > 0x02;
                         db++, hb++, cow--)
                    {
                        tword = dword;
                        dword = *sb++;
                        dword = (dword << 16) | *sb++;
                        S2WORDSWAP(dword);                      /*@WIN begin*/
                        tmp0 = BM_LEFT_SHIFT(tword, ls) |
                               BM_RIGH_SHIFT(dword, rs);
                        LWORDSWAP(tmp0);
                        db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0); /*@WIN end*/
                        /*      @WIN
                        db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs))) |
                                (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                       |   BM_RIGH_SHIFT(dword, rs)));
                        */
                    }
                    tword = dword;
                    dword = *sb;
                    dword = (dword << 16);
                    S2WORDSWAP(dword);                      /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) |
                           BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    ++db; ++hb;
                    /*  @WIN
                    *db++ = (*db   & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (*hb++ &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);    /*@WIN end*/
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[0] &  (BM_LEFT_SHIFT(dword, ls)));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }

    } else {                            /* 4 byte boundry */
        if (rs  == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= ((now + 1) << 1), hw-= now + 1; h > 0;
                 db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, hb++, cow--) {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    SWAPWORD(dword);                   /*@WIN*/
                    db[0] = (db[0] & ~(dword)) | (hb[0] & dword);
                }
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else if (now == 0x00)           /* totally within one word? */
        {
            for (sw-= 1; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb++;
                dword = (dword << 16) | *sb;
                S2WORDSWAP(dword);              /*@WIN begin*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);       /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &  (BM_RIGH_SHIFT(dword, rs)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (sw-= 1; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb;
                    S2WORDSWAP(dword);              /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(dword, ls))) |
                            (hb[1] &   BM_LEFT_SHIFT(dword, ls));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                for (sw-= 3; h > 0; db+= dw, sb+= sw, h--)
                {
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);              /*@WIN*/
                    tword = *sb++;
                    tword = (tword << 16) | *sb;
                    S2WORDSWAP(tword);              /*@WIN begin*/
                    tmp0 = BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) | (hb[0] & tmp0);
                    /*  @WIN
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                    */
                    tmp0 = BM_LEFT_SHIFT(dword, ls) | BM_RIGH_SHIFT(tword, rs);
                    LWORDSWAP(tmp0);
                    db[1] = (db[1] & ~tmp0) | (hb[1] & tmp0);   /*@WIN end*/
                    /*  @WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs)))) |
                            (hb[1] &  ((BM_LEFT_SHIFT(dword, ls)
                                   |   BM_RIGH_SHIFT(tword, rs))));
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            for (dw-= now, sw-= (now + now),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                dword = *sb++;
                dword = (dword << 16) | *sb++;
                S2WORDSWAP(dword);              /*@WIN*/
                tmp0 = BM_RIGH_SHIFT(dword, rs);     /*@WIN*/
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) | /*@WIN*/
                        (hb[0] & tmp0);  /*@WIN*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(dword, rs))) |
                        (hb[0] &   BM_RIGH_SHIFT(dword, rs));
                */
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, hb++, cow--)
                {
                    tword = dword;
                    dword = *sb++;
                    dword = (dword << 16) | *sb++;
                    S2WORDSWAP(dword);          /*@WIN begin*/
                    tmp0 = BM_LEFT_SHIFT(tword, ls) | BM_RIGH_SHIFT(dword, rs);
                    LWORDSWAP(tmp0);
                    db[0] = (db[0] & ~tmp0) |
                            (hb[0] & tmp0);     /*@WIN end*/
                /*      @WIN
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs))) |
                            (hb[0] &  (BM_LEFT_SHIFT(tword, ls)
                                   |   BM_RIGH_SHIFT(dword, rs)));
                */
                }
                tmp0 = BM_LEFT_SHIFT(dword, ls);        /*@WIN begin*/
                LWORDSWAP(tmp0);
                db[0] = (db[0] & ~tmp0) |
                        (hb[0] & tmp0);     /*@WIN end*/
                /*      @WIN
                db[0] = (db[0] & ~(BM_LEFT_SHIFT(dword, ls))) |
                        (hb[0] &  (BM_LEFT_SHIFT(dword, ls)));
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
   }
} /* gp_bitblt16_32 */

#endif

/* ---------------------------------------------------------------------
 *      gp_charblt: a group of bitblt functions for char cache bitblt
 *                  with following logical operations:
 *                  FC_BLACK: source  --> destination.
 *                  FC_WHITE: (^source) AND (destination) --> destination
 *
 *      gp_charblt16(): for cache bitmap width = 16 * X
 *      gp_charblt32(): for cache bitmap width = 32 * X
 * --------------------------------------------------------------------- */

#ifdef  LBODR

/* **********************************************************************
 *      gp_charblt16: move character bitmap from cache to frame buffer
 *                    with cache bitmap width multiple of 16
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt16(charimage, charbitmap, width_height, shift_code)
ufix16 FAR *charimage, FAR *charbitmap;
fix width_height, shift_code;
{
        register fix    savewidth;
        register ufix   wordsline, leftsh;
        register ufix16 bitmapline;
        register ufix16 FAR *chimagep;

#ifdef DBGchar
   printf("gp_charblt16() : %lx, %lx, %lx, %lx\n", charimage, charbitmap,
           width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = FB_WIDTH >> SHORTPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ |= (bitmapline LSHIFT leftsh);
/*
                      *chimagep |= (bitmapline RSHIFT (16 - leftsh));
 */
                      *chimagep |= BRSHIFT(bitmapline,(16 - leftsh),16);
              } while ((shift_code -= 16) > 0);
              charimage += wordsline;
           }
        break;

      case FC_CLEAR:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ &= ~(bitmapline LSHIFT leftsh);
/*
                      *chimagep &= ~(bitmapline RSHIFT (16 - leftsh));
 */
                      *chimagep &= ~(BRSHIFT(bitmapline,(16 - leftsh),16));
              } while ((shift_code -= 16) > 0);
              charimage += wordsline;
           }

    } /* switch */

} /* gp_charblt16 */


/* **********************************************************************
 *      gp_charblt32: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 32
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt32(charimage, charbitmap, width_height, shift_code)
ufix   FAR *charimage, FAR *charbitmap;
fix    width_height, shift_code;
{
        register fix    savewidth;
        register ufix   wordsline, leftsh;
        register ufix   bitmapline;
        register ufix   FAR *chimagep;
#ifdef DBGchar
   printf("gp_charblt32() : %lx, %lx, %lx, %lx\n", charimage, charbitmap,
           width, height);
#endif

        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = FB_WIDTH >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ |= (bitmapline LSHIFT leftsh);
/*
                      *chimagep |= (bitmapline RSHIFT (32 - leftsh));
 */
                      *chimagep |= BRSHIFT(bitmapline,(32 - leftsh),32);
              } while ((shift_code -= 32) > 0);
              charimage += wordsline;
           }
        break;

      case FC_CLEAR:
           while (width_height--) {
              chimagep = charimage;
              shift_code = savewidth;
              do  {
                      bitmapline = *charbitmap++;
                      *chimagep++ &= ~(bitmapline LSHIFT leftsh);
/*
                      *chimagep &= ~(bitmapline RSHIFT (32 - leftsh));
 */
                      *chimagep &= ~(BRSHIFT(bitmapline,(32 - leftsh),32));
              } while ((shift_code -= 32) > 0);
              charimage += wordsline;
           }
        break;

    } /* switch */

} /* gp_charblt32 */

#else

/* **********************************************************************
 *      gp_charblt16: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 16
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt16(charimage, charbitmap, width_height, shift_code)
ufix32  huge *charimage;        /*@WIN*/
ufix16  FAR *charbitmap;
ufix32  width_height, shift_code;       /*@WIN*/
{
        register fix32    savewidth;            /*@WIN*/
        register ufix32   wordsline, leftsh;    /*@WIN*/
        register ufix32   bitmapline, width;    /*@WIN*/
        register ufix32   dw, righsh, tmp;      /*@WIN*/

#ifdef DBGchar
   printf("gp_charblt16() : %lx, %lx, %lx, %lx\n", charimage,
                 charbitmap, width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = savewidth >> WORDPOWER;
        dw = FBX_Bmap.bm_cols >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= (wordsline + 1);
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;

                   S2WORDSWAP(bitmapline);              /*@WIN*/

                   tmp = (bitmapline >> leftsh);        /*@WIN*/
                   *charimage++ |= LWORDSWAP(tmp);      /*@WIN*/
                   tmp = (bitmapline << righsh);        /*@WIN*/
                   *charimage   |= LWORDSWAP(tmp);      /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;

              S2WORDSWAP(bitmapline);                   /*@WIN*/

              tmp = (bitmapline >> leftsh);             /*@WIN*/
              *charimage++ |= LWORDSWAP(tmp);           /*@WIN*/
              tmp = (bitmapline << righsh);             /*@WIN*/
              *charimage   |= LWORDSWAP(tmp);           /*@WIN*/
              charimage += dw;
           }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   *charimage++ |= WORDSWAP(bitmapline);        /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              *charimage |= WORDSWAP(bitmapline);               /*@WIN*/
              charimage += dw;
           }
        }
        break;

      case FC_CLEAR:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= (wordsline + 1);
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   S2WORDSWAP(bitmapline);              /*@WIN*/
                   tmp = ~(bitmapline >> leftsh);       /*@WIN*/
                   *charimage++ &= LWORDSWAP(tmp);      /*@WIN*/
                   tmp = ~(bitmapline << righsh);       /*@WIN*/
                   *charimage   &= LWORDSWAP(tmp);      /*@WIN*/
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              S2WORDSWAP(bitmapline);                   /*@WIN*/
              tmp = ~(bitmapline >> leftsh);            /*@WIN*/
              *charimage++ &= LWORDSWAP(tmp);           /*@WIN*/
              tmp = ~(bitmapline << righsh);            /*@WIN*/
              *charimage   &= LWORDSWAP(tmp);           /*@WIN*/
              charimage += dw;
           }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
              width = wordsline;
              while (width--) {
                   bitmapline = *charbitmap++;
                   bitmapline = (bitmapline << 16) | *charbitmap++;
                   WORDSWAP(bitmapline);                /*@WIN*/
                   *charimage++ &= ~bitmapline;
              }
              bitmapline = *charbitmap++;
              bitmapline = bitmapline << 16;
              WORDSWAP(bitmapline);                     /*@WIN*/
              *charimage &= ~bitmapline;
              charimage += dw;
           }
        }
        break;

    } /* switch */

} /* gp_charblt16 */


/* **********************************************************************
 *      gp_charblt32: move character bitmap from cache to frmae buffer
 *                    with cache bitmap width multiple of 32
 *      width_height: width<<16 | height
 *      shift_code:   shift<<16 | code
 * ********************************************************************** */
void gp_charblt32(charimage, charbitmap, width_height, shift_code)
ufix32  huge *charimage, FAR *charbitmap;       /*@WIN*/
ufix32  width_height, shift_code;               /*@WIN*/
{
        register fix32    savewidth;            /*@WIN*/
        register ufix32   wordsline, leftsh;    /*@WIN*/
        register ufix32   bitmapline, width;    /*@WIN*/
        register ufix32   dw, righsh, tmp;      /*@WIN*/
#ifdef DBGchar
   printf("gp_charblt32() : %lx, %lx, %lx, %lx\n", charimage,
                 charbitmap, width_height, shift_code);
#endif
        leftsh = shift_code >> 16;
        savewidth = width_height >> 16;
        width_height &= 0xffff;
        wordsline = savewidth >> WORDPOWER;
        dw = FBX_Bmap.bm_cols >> WORDPOWER;

#ifdef DBG
   printf("width_height = %lx, shift_code = %lx\n", width_height, shift_code);
#endif

    switch(shift_code & 0xffff) {

      case FC_MERGE:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   LWORDSWAP(bitmapline);                       /*@WIN*/
                   tmp = (bitmapline >> leftsh);                /*@WIN*/
                   *charimage++ |= LWORDSWAP(tmp);              /*@WIN*/
                   tmp = (bitmapline << righsh);                /*@WIN*/
                   *charimage   |= LWORDSWAP(tmp);              /*@WIN*/
                }
                charimage += dw;
            }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   *charimage++ |= bitmapline;       /*@WIN*/
                }
                charimage += dw;
            }
        }
        break;

      case FC_CLEAR:

        if (leftsh)
        {
           righsh = BITSPERWORD - leftsh;
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   LWORDSWAP(bitmapline);                       /*@WIN*/
                   tmp = ~(bitmapline >> leftsh);               /*@WIN*/
                   *charimage++ &= LWORDSWAP(tmp);              /*@WIN*/
                   tmp = ~(bitmapline << righsh);               /*@WIN*/
                   *charimage   &= LWORDSWAP(tmp);              /*@WIN*/
                }
                charimage += dw;
            }
        }
        else
        {
           dw -= wordsline;
           while (width_height--) {
                width = wordsline;
                while (width--) {
                   bitmapline = *charbitmap++;
#ifdef LITTLE_ENDIAN /* 03/27/91 */
                   bitmapline = (bitmapline << 16) | (bitmapline >> 16);
#endif
                   *charimage++ &= ~bitmapline ;
                }
                charimage += dw;
            }
        }
        break;

    } /* switch */

} /* gp_charblt32 */

#endif

/* ------------------------------------------------------------------- */
void
gp_charblt16_cc(dst, w, h, src, sx, sy)
ufix16          FAR     *dst;
fix                     w;
fix                     h;
struct Char_Tbl FAR     *src;
fix                     sx;
fix                     sy;
{
    fix                 sw;
   ufix16              FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix16               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt16_cc: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst, sx, sy, w, h, src->bitmap);
#endif

        /*  calculate starting address and width in words
         */
        sw = src->box_w >> SHORTPOWER;                         /* @DST */
        sb = &((ufix16 FAR *) src->bitmap)[sy * sw + (sx >> SHORTPOWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + SHORTMASK) >> SHORTPOWER;
        rs = sx & SHORTMASK;                    /* right shift */
        ls = BITSPERSHORT - rs;                 /* left  shift */

        for (sw-= now; h > 0; sb+= sw, h--)
        {
           cow = now;
           do  {
                   tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                   tmp1 = sb[1];
                   tmp0 = (ufix16)(BM_LEFT_SHIFT(SWORDSWAP(tmp0), rs) |
                            BM_RIGH_SHIFT(SWORDSWAP(tmp1), ls));//@WIN
                   *dst++ = *dst | SWORDSWAP(tmp0);     /*@WIN 04-20-92 end*/
                /*      @WIN 04-20-92
                   *dst++ = *dst | ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                   sb++;
                } while ((--cow) > 0);
        }
} /* gp_charblt16_cc */


/* ------------------------------------------------------------------- */
void
gp_charblt16_clip(dst, w, h, src, sx, sy)
struct bitmap FAR     *dst;
fix                     w, h;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
   ufix16              FAR *db;
    fix                 sw;
   ufix16              FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix16               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt16_clip: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, sx, sy, w, h, src->bm_addr);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> SHORTPOWER;                         /* @DST */
        db = (ufix16 FAR *) dst->bm_addr;
        sw = src->bm_cols >> SHORTPOWER;                         /* @SRC */
        sb = &((ufix16 FAR *) src->bm_addr)[sy * sw + (sx >> SHORTPOWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + SHORTMASK) >> SHORTPOWER;
        rs = sx & SHORTMASK;                    /* right shift */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     *db++ = *db & *sb++;
                 } while ((--cow) > 0);
            }
        }
        else                            /* crossing more than two words! */
        {
            ls = BITSPERSHORT - rs;                    /* left  shift */
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                     tmp1 = sb[1];
                     tmp0 = (ufix16)(BM_LEFT_SHIFT(SWORDSWAP(tmp0), rs) |
                              BM_RIGH_SHIFT(SWORDSWAP(tmp1), ls)); //@WIN
                     *db++ = *db & (SWORDSWAP(tmp0)); /*@WIN 04-20-92 end*/
                /* @WIN         04-20-92
                     *db++ = *db & ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                      sb++;
                 } while ((--cow) > 0);
            }
        }
} /* gp_charblt16_clip */

/* ------------------------------------------------------------------- */
void
gp_charblt32_clip(dst, w, h, src, sx, sy)
struct bitmap FAR     *dst;
fix                     w, h;
struct bitmap FAR     *src;
fix                     sx, sy;
{
    fix                 dw;
    BM_DATYP           FAR *db;
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 ls, rs;
    fix                 now, cow;
   ufix32               tmp0, tmp1;     /*@WIN 04-20-92*/

#ifdef  DBG
    printf("charblt32_clip: %6.6lx %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, sx, sy, w, h, src->bm_addr);
#endif

        /*  calculate starting address and width in words
         */
        dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
        db = (BM_DATYP FAR *) dst->bm_addr;
        sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
        sb = &((BM_DATYP FAR *) src->bm_addr)[sy * sw + (sx >> BM_WORD_POWER)];

        /*  calculate starting and ending coordinate of x
         */
        now = (w + BM_PIXEL_MASK) >> BM_WORD_POWER;
        rs = sx & BM_PIXEL_MASK;                        /* right shift */


        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     *db++ = *db & *sb++;
                 } while ((--cow) > 0);
            }
        }
        else                            /* crossing more than two words! */
        {
            ls = BM_PIXEL_WORD - rs;                    /* left  shift */
            for (dw-= now, sw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                 cow = now;
                 do {
                     tmp0 = sb[0];        /*@WIN 04-20-92 begin*/
                     tmp1 = sb[1];
                     tmp0 = (BM_LEFT_SHIFT(LWORDSWAP(tmp0), rs) |
                              BM_RIGH_SHIFT(LWORDSWAP(tmp1), ls));
                     *db++ = *db & LWORDSWAP(tmp0);     /*@WIN 04-20-92 end*/
                /* @WIN 04-20-92
                     *db++ = *db & ((BM_LEFT_SHIFT(sb[0], rs) |
                                     BM_RIGH_SHIFT(sb[1], ls)));
                */
                      sb++;
                 } while ((--cow) > 0);
            }
        }
} /* gp_charblt32_clip */

/* ********************************************************************** *
 *      gp_patblt:      move image seed pattern to frame buffer           *
 *                                                                        *
 *      gp_patblt_m:    move image seed pattern to frame buffer with      *
 *                      clipping mask                                     *
 *                                                                        *
 *      gp_patblt_c:    move image seed pattern to character cache        *
 *                                                                        *
 *                                                                        *
 *      1)  All image seed patterns are in multiple of 32; i.e. ufix      *
 *          aligned.  Unused area of bitmap of any image seed pattern     *
 *          is cleared with zero; i.e. white.                             *
 *                                                                        *
 *      2)  The calling sequence of all patblt functions are same as:     *
 *                                                                        *
 *              struct bitmap near *dst;        (* destination bitmap *)  *
 *              fix                 dx, dy;     (* destination x & y *)   *
 *              fix                 w, h;       (* width and height *)    *
 *              ufix16              fc;         (* function code *)       *
 *              struct bitmap near *src;        (* source bitmap *)       *
 *                                                                        *
 *          Parameter w is not in mutiple of 32, it is the actual width   *
 *          of the image seed pattern instead of width of bitmap of image *
 *          seed pattern.                                                 *
 *                                                                        *
 *      3)  The functions code aceepted by gp_bitblt() and gp_bitblt_m()  *
 *          are FC_CLEAR, FC_MERGE and HT_APPLY.  gp_bitblt_c() can       *
 *          accept FC_MERGE only.                                         *
 *                                                                        *
 *      4)  Both gp_patblt() and gp_patblt_m() refer global variables:    *
 *          HTB_Bmap and HTB_Modula.  gp_patblt_m() also refers global    *
 *          variables: CMB_Xorig and CMB_Yorig.                           *
 *                                                                        *
 *      5)  The following code are expanded to its maximum to gain        *
 *          speed instead of space.  Such rule may be not applicable to   *
 *          RISC graphics environment.  It should be optimized based on   *
 *          the architecture of graphics environment ported.              *
 *                                                                        *
 * ********************************************************************** */
void
gp_patblt(dst, dx, dy, w, h, fc, src)
struct bitmap FAR *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR *src;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb;
    fix                 ls, rs;
    BM_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;
    BM_DATYP           FAR *hs;
    ufix32 tmprs0, tmpls0, tmprs1;   /*@WIN 10-05-92*/

#ifdef  DBGp
    printf("patblt: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)];
    db = (BM_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;                         /* @SRC */
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

    if (fc == HT_APPLY) {
/*
    switch (fc)
    {
    case HT_APPLY:  */             /*  D <- (D .AND. .NOT. S) .OR.
                                         (S .AND. HT)                   */
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = ((BM_DATYP FAR *) HTB_Bmap.bm_addr +
                           ((dx % HTB_Modula) >> BM_WORD_POWER));
        hb = hs + (hy * hw);

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, hw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0])) | (hb[0] & (sb[0]));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }

        else if (now == 0x00)           /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                                     /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                                     /*@WIN 04-20-92 end*/
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) |  //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));   //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                                     /*@WIN 10-05-92 begin*/
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                    db[1] = (db[1] & ~tmpls0) | (hb[1] & tmpls0);
                                     /*@WIN 04-20-92 end*/
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));  //@WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls))) | //@WIN
                            (hb[1] &  (BM_LEFT_SHIFT(sb[0], ls)));  //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* two words crossing two words! */
            {
                sm =  BM_R_MASK(xe);        /* second mask */
                LWORDSWAP(sm);                  /*@WIN 10-06-92*/
                for (; h > 0; db+= dw, sb+= sw, h--)
                {
                                     /*@WIN 10-05-92 begin*/
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~tmprs0) | (hb[0] & tmprs0);
                    db[1] = (db[1] & ~((tmpls0 | tmprs1) & sm)) |
                            (hb[1] &  ((tmpls0 | tmprs1) & sm));
                                     /*@WIN 04-20-92 end*/
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs)));  //@WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & sm)) | //@WIN
                            (hb[1] & ((BM_LEFT_SHIFT(sb[0], ls) |  //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs)) & sm)); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1),
                 hw-= now; h > 0; db+= dw, sb+= sw, h--)
            {
                                     /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0)) | (hb[0] &  (tmprs0));
                                     /*@WIN 04-20-92 end*/
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs))) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                */
                for (db++, hb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~(tmpls0 | tmprs1)) |
                            (hb[0] &  (tmpls0 | tmprs1)); //@WIN
                    /*
                    db[0] = (db[0] & ~(BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs))) | //@WIN
                            (hb[0] & (BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                      BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = (db[0] & ~((tmpls0 | tmprs1) & sm)) |
                        (hb[0] &  ((tmpls0 | tmprs1) & sm)); //@WIN
                /*
                db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & sm)) | //@WIN
                        (hb[0] & ((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm)); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
/*        break; */
    }
    else if (fc == FC_CLEAR) {

/*    case FC_CLEAR:  */          /*  0001  D <- D .AND. .NOT. S          */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] & ~(sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--) {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0));
                             /*@WIN 10-05-92 end*/
                //db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~((tmprs0)); //@WIN
                db[1] = db[1] & ~((tmpls0 | tmprs1) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                db[1] = db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0)); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] & ~((tmpls0 | tmprs1));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~((tmpls0 | tmprs1) & sm); //@WIN
                /*
                db[0] = db[0] & ~((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) |    //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                db[0] = db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) |        //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
/*        break; */
    }
    else if (fc == FC_MERGE) {
/*    case FC_MERGE: */             /*  0001  D <- D .OR. S                 */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1; h > 0; db+= dw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--) {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | ((tmprs0));
                //db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | ((tmprs0));
                db[1] = db[1] | ((tmpls0 | tmprs1) & sm);
                /*
                db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                db[1] = db[1] | ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                  BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | ((tmprs0)); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--) {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] | ((tmpls0 | tmprs1));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | ((tmpls0 | tmprs1) & sm);
                /*
                db[0] = db[0] | ((BM_RIGH_SHIFT(sb[0], rs))); //@WIN
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                    db[0] = db[0] | ((BM_LEFT_SHIFT(sb[0], ls) |     //@WIN
                                      BM_RIGH_SHIFT(sb[1], rs))); //@WIN
                db[0] = db[0] | ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                  BM_RIGH_SHIFT(sb[1], rs)) & sm); //@WIN
                */
            }
        }
/*        break; */
#ifdef  DBGwarn
    default:
        printf("gp_patblt: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_patblt */

void
gp_patblt_m(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    BM_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    BM_DATYP           FAR *sb;
    fix                 mw;
    BM_DATYP           FAR *mb;
    fix                 hw;
    fix                 hy;
    BM_DATYP           FAR *hb, FAR *hs;
    fix                 ls, rs;
    BM_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;
    ufix32 tmprs0, tmpls0, tmprs1;   /*@WIN 10-05-92*/

#ifdef  DBGp
    printf("patblt_m: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif



    // NTFIX   A negative destination should get remapped to 0. This is
    //         from the printer group.
    //
    if (dx < 0 ) {
       dx = 0;
    }

    if (dy <0 ) {
       dy = 0;
    }

    /*  calculate starting address and width in words
     */
    dw = dst->bm_cols >> BM_WORD_POWER;                         /* @DST */
//  db = &((BM_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> BM_WORD_POWER)]; @WINFLOW
    db = (ufix32 huge *)dst->bm_addr +
               ((fix32)dy * (fix32)dw + ((fix32)dx >> BM_WORD_POWER));
    sw = src->bm_cols >> BM_WORD_POWER;
    sb =  ((BM_DATYP FAR *) src->bm_addr);

    mw = CMB_Bmap.bm_cols >> BM_WORD_POWER;                     /* @CMB */
//  mb = &((BM_DATYP FAR *) CMB_Bmap.bm_addr)[(dy - CMB_Yorig) * mw +  @WINFLOW
//                                       ((dx - CMB_Xorig) >> BM_WORD_POWER)];

    /* adjust starting address of CMB; --- begin --- 11/9/92 @WIN */
//  mb = (BM_DATYP FAR *) CMB_Bmap.bm_addr +
//                       ((DWORD)(dy - CMB_Yorig) * mw +
//                       ((DWORD)(dx - CMB_Xorig) >> BM_WORD_POWER));
    {
    int nX = (dx > CMB_Xorig) ? (dx - CMB_Xorig) : 0;
    int nY = (dy > CMB_Yorig) ? (dy - CMB_Yorig) : 0;
    mb = (BM_DATYP FAR *) CMB_Bmap.bm_addr +
                         ((DWORD)(nY) * mw +
                         ((DWORD)(nX) >> BM_WORD_POWER));
    }
    /* adjust starting address of CMB; --- end --- 11/9/92 @WIN */

    /* adjust starting addresses when they are out of page;  10-6-92 @WIN */
    /* it also needs to consider dx; To Be Fixed??? */
    if (dy < 0) {       // too small
        h += dy;
        db = (ufix32 huge *)dst->bm_addr + ((fix32)dx >> BM_WORD_POWER);
        sb += (-dy) * sw;
        mb += (-dy) * mw;
        dy = 0;
    }
    if ((dy+h) > SFX2I(GSptr->device.default_clip.uy)) { // tooo large
        h = SFX2I(GSptr->device.default_clip.uy) - dy;
    }
    /* adjust starting addresses when they are out of page;  --end-- */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
    xe = dx + w - 1;
    now = ((fix)(xe & BM_ALIGN_MASK) - (fix)(xs & BM_ALIGN_MASK)) >> BM_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & BM_PIXEL_MASK;                            /* right shift */
    ls = BM_PIXEL_WORD - rs;                            /* left  shift */

/*
    switch (fc)
    {
    case HT_APPLY:  */          /*  D <- (D .AND. .NOT.(S .AND. M)) .OR.
                                         ((S .AND. M) .AND. HT)         */
    if (fc == HT_APPLY) {
        /*  calculate starting address/y and width in words
         */
        hw = HTB_Bmap.bm_cols >> BM_WORD_POWER;
        hy = dy % HTB_Bmap.bm_rows;
        hs = ((BM_DATYP FAR *) HTB_Bmap.bm_addr +
                           ((dx % HTB_Modula) >> BM_WORD_POWER));
        hb = hs + (hy * hw);

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1,
                 hw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, hb++, cow--)
                    db[0] = (db[0] & ~(sb[0] & mb[0])) |
                            (hb[0] &  (sb[0] & mb[0]));
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                        (hb[0] &  (tmprs0 & mb[0]));
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            if (w <= BM_PIXEL_WORD)     /* one word crossing two words? */
            {
                for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
                {
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                            (hb[0] &  (tmprs0 & mb[0]));
                    db[1] = (db[1] & ~(tmpls0 & mb[1])) |
                            (hb[1] &  (tmpls0 & mb[1]));
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                    db[1] = (db[1] & ~(BM_LEFT_SHIFT(sb[0], ls) & mb[1])) | //@WIN
                            (hb[1] &  (BM_LEFT_SHIFT(sb[0], ls) & mb[1])); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
            else                        /* one word crossing two words? */
            {
                sm =  BM_R_MASK(xe);    /* second mask */
                LWORDSWAP(sm);                  /*@WIN 10-06-92*/
                for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
                {
                    tmprs0 = sb[0];
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmprs0);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~(tmprs0 & mb[0])) | //@WIN
                            (hb[0] &  (tmprs0 & mb[0])); //@WIN
                    db[1] = (db[1] & ~((tmpls0 | tmprs1) & mb[1] & sm)) |
                            (hb[1] &  ((tmpls0 | tmprs1) & mb[1] & sm));
                    /*
                    db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                            (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                    db[1] = (db[1] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                     BM_RIGH_SHIFT(sb[1], rs)) & mb[1] & sm)) | //@WIN
                            (hb[1] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                     BM_RIGH_SHIFT(sb[1], rs)) & mb[1] & sm)); //@WIN
                    */
                    hy++;
                    if (hy == HTB_Bmap.bm_rows)
                    {
                        hy =  0;
                        hb = hs;
                    } else
                        hb += hw;
                }
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1), mw-= now,
                 hw-= now; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = (db[0] & ~(tmprs0 & mb[0])) |
                        (hb[0] &  (tmprs0 & mb[0]));
                /*
                db[0] = (db[0] & ~(BM_RIGH_SHIFT(sb[0], rs) & mb[0])) | //@WIN
                        (hb[0] &  (BM_RIGH_SHIFT(sb[0], rs) & mb[0])); //@WIN
                */
                for (db++, hb++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, hb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = (db[0] & ~((tmpls0 | tmprs1) & mb[0])) |
                            (hb[0] &  ((tmpls0 | tmprs1) & mb[0]));
                    /*
                    db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])) | //@WIN
                            (hb[0] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = (db[0] & ~((tmpls0 | tmprs1) & mb[0] & sm)) |
                        (hb[0] &  ((tmpls0 | tmprs1) & mb[0] & sm));
                /*
                db[0] = (db[0] & ~((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0] & sm)) | //@WIN
                        (hb[0] &  ((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0] & sm)); //@WIN
                */
                hy++;
                if (hy == HTB_Bmap.bm_rows)
                {
                    hy =  0;
                    hb = hs;
                } else
                    hb += hw;
            }
        }
/*      break; */
    }
    else if (fc == FC_CLEAR) {
/*  case FC_CLEAR:  */          /*  0001  D <- D .AND. .NOT.(S .AND. M) */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, cow--)
                    db[0] = (db[0] & ~(sb[0] & mb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~(((tmprs0) & mb[0])); //@WIN
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~(((tmprs0) & mb[0]));
                db[1] = db[1] & ~(((tmpls0 | tmprs1) & mb[1]) & sm);
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                db[1] = db[1] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[1]) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1),
                 mw-= now; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] & ~((tmprs0 & mb[0])); //@WIN
                /*
                db[0] = db[0] & ~(((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] & ~(((tmpls0 | tmprs1) & mb[0]));
                    /*
                    db[0] = db[0] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                        BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                    */
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] & ~(((tmpls0 | tmprs1) & mb[0]) & sm);
                /*
                db[0] = db[0] & ~(((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                    BM_RIGH_SHIFT(sb[1], rs)) & mb[0]) & sm); //@WIN
                */
            }
        }
/*      break; */
    }
    else if (fc == FC_MERGE) {
/*  case FC_MERGE:  */          /*  0001  D <- D .OR. (S .AND. M)       */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, mw-= now + 1; h > 0; db+= dw, mb+= mw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, mb++, cow--)
                    db[0] = (db[0] | (sb[0] & mb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                */
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmprs0);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                db[1] = db[1] | (((tmpls0 | tmprs1) & mb[1]) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                db[1] = db[1] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & mb[1]) & sm); //@WIN
                */
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  BM_R_MASK(xe);        /* second mask */
            LWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1), mw-= now;
                 h > 0; db+= dw, sb+= sw, mb+= mw, h--)
            {
                             /*@WIN 10-05-92 begin*/
                tmprs0 = sb[0];
                tmprs0 = BM_RIGH_SHIFT(LWORDSWAP(tmprs0), rs);
                LWORDSWAP(tmprs0);
                db[0] = db[0] | (((tmprs0) & mb[0]));
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    tmpls0 = sb[0];
                    tmprs1 = sb[1];
                    tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                    tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                    LWORDSWAP(tmpls0);
                    LWORDSWAP(tmprs1);
                    db[0] = db[0] | (((tmpls0 | tmprs1) & mb[0]));
                }
                tmpls0 = sb[0];
                tmprs1 = sb[1];
                tmpls0 = BM_LEFT_SHIFT(LWORDSWAP(tmpls0), ls);
                tmprs1 = BM_RIGH_SHIFT(LWORDSWAP(tmprs1), rs);
                LWORDSWAP(tmpls0);
                LWORDSWAP(tmprs1);
                db[0] = db[0] | (((tmpls0 | tmprs1) & mb[0]) & sm);
                             /*@WIN 10-05-92 end*/
                /*
                db[0] = db[0] | (((BM_RIGH_SHIFT(sb[0], rs)) & mb[0])); //@WIN
                for (db++, mb++, cow = now; cow >= 0x02;
                     db++, sb++, mb++, cow--)
                {
                    db[0] = db[0] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                       BM_RIGH_SHIFT(sb[1], rs)) & mb[0])); //@WIN
                }
                db[0] = db[0] | (((BM_LEFT_SHIFT(sb[0], ls) | //@WIN
                                   BM_RIGH_SHIFT(sb[1], rs)) & mb[0]) & sm); //@WIN
                */
            }
        }
/*      break; */

#ifdef  DBGwarn
    default:
        printf("gp_patblt_m: Illegal FC_code = %x\n", fc);
        break;
#endif
    }
} /* gp_patblt_m */

//NTFIX , total replacement of gp_patblt_c the code below does swapping to
//        correct memory orientation issues. Since were replicating a patter
//        that has already been corrected this should not be done here.
//        when the cache is moved to the final surface the swapping will
//        be correct.

#if 0
void
gp_patblt_c(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    CC_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    CC_DATYP           FAR *sb;
    fix                 ls, rs;
    CC_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;

#ifdef  DBGp
    printf("patblt_c: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif
    /* for clipped cached font, 5-30-91, -begin- */
    fix                 dh;



    //UPD056
    dh = h;
    if ( dx > dst->bm_cols || dy > dst->bm_rows)
        return;         /* out of clipped region */
    if (dx < 0 ) {
       dx = 0;
    }




    if ((dx + w - 1) > dst->bm_cols)
        xe = dst->bm_cols;
    else
        xe = dx + w - 1;
    if ((dy + dh - 1) > dst->bm_rows)
        h = dy + dh - 1 - dst->bm_rows;
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr);
    dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER));
    if (dy < 0) {
        if ((dy + dh - 1) < 0)
            return;    /* out of clipped region */
        else {
            h = dy + dh;
            sb = &((CC_DATYP FAR *) src->bm_addr)[-dy * sw];
//          db = &((CC_DATYP FAR *) dst->bm_addr)[dx >> CC_WORD_POWER];
            db = (CC_DATYP huge *) dst->bm_addr + ((ufix32)dx >> CC_WORD_POWER); //@WIN
        }
    }
    /* for clipped cached font, 5-30-91, -end- */

    /*  calculate starting address and width in words
     */
/*  dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP FAR *) dst->bm_addr + ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER)); //@WIN
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr); * 5-30-91, Jack */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
/*  xe = dx + w - 1; * 5-30-91, Jack */
    now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & CC_PIXEL_MASK;                            /* right shift */
    ls = CC_PIXEL_WORD - rs;                            /* left  shift */

/*  case FC_MERGE:   */         /*  0001  D <- D .OR. S      */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1 ; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));  /*@WIN*/
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {

            sm =  CC_R_MASK(xe);        /* second mask */
            SWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                db[1] = db[1] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
        else                            /* crossing more than two words! */
        {

            sm =  CC_R_MASK(xe);        /* second mask */
            SWORDSWAP(sm);                  /*@WIN 10-06-92*/
            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                {
                    db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                      CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
} /* gp_patplt_c */

#endif

//
//NTFIX, this is the corrected patblt function that works in nt.
//
void
gp_patblt_c(dst, dx, dy, w, h, fc, src)
struct bitmap FAR     *dst;
fix                     dx, dy;
fix                     w, h;
ufix16                  fc;
struct bitmap FAR     *src;
{
    fix                 dw;
    CC_DATYP           huge *db;        /* FAR => huge @WIN */
    fix                 sw;
    CC_DATYP           FAR *sb;
    fix                 ls, rs;
    CC_DATYP            sm;
    fix                 xs, xe;
    fix                 now, cow;

#ifdef  DBGp
    printf("patblt_c: %6.6lx %4x %4x %4x %4x %4.4x %6.6lx\n",
           dst->bm_addr, dx, dy, w, h, fc, src->bm_addr);
#endif
    /* for clipped cached font, 5-30-91, -begin- */
    fix                 dh;

    //UPD056
    dh = h;
    if ( dx > dst->bm_cols || dy > dst->bm_rows)
        return;         /* out of clipped region */
    if (dx < 0 ) {
       dx = 0;
    }

    //
    //NTFIX  There are situations where this code gets called with a 0 width
    //       or height. This should be a NOP
    //
    if (w == 0 || h == 0) {
       return;
    }



    if ((dx + w - 1) > dst->bm_cols)
        xe = dst->bm_cols;
    else
        xe = dx + w - 1;
    if ((dy + dh - 1) > dst->bm_rows)
        h = dy + dh - 1 - dst->bm_rows;
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr);
    dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP huge *) dst->bm_addr +               /*@WIN*/
         ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER));
    if (dy < 0) {
        if ((dy + dh - 1) < 0)
            return;    /* out of clipped region */
        else {
            h = dy + dh;
            sb = &((CC_DATYP FAR *) src->bm_addr)[-dy * sw];
//          db = &((CC_DATYP FAR *) dst->bm_addr)[dx >> CC_WORD_POWER];
            db = (CC_DATYP huge *) dst->bm_addr + ((ufix32)dx >> CC_WORD_POWER); //@WIN
        }
    }
    /* for clipped cached font, 5-30-91, -end- */

    /*  calculate starting address and width in words
     */
/*  dw = dst->bm_cols >> CC_WORD_POWER;
//  db = &((CC_DATYP FAR *) dst->bm_addr)[dy * dw + (dx >> CC_WORD_POWER)];
    db = (CC_DATYP FAR *) dst->bm_addr + ((ufix32)dy * dw + ((ufix32)dx >> CC_WORD_POWER)); //@WIN
    sw = src->bm_cols >> CC_WORD_POWER;
    sb =  ((CC_DATYP FAR *) src->bm_addr); * 5-30-91, Jack */

    /*  calculate starting and ending coordinate of x
     */
    xs = dx;
/*  xe = dx + w - 1; * 5-30-91, Jack */
    now = ((fix)(xe & CC_ALIGN_MASK) - (fix)(xs & CC_ALIGN_MASK)) >> CC_WORD_POWER;
                                                 /* cast fix 10/16/92 @WIN */

    /*  calculate shifts and masks based on from SRC to DST
     */
    rs = dx & CC_PIXEL_MASK;                            /* right shift */
    ls = CC_PIXEL_WORD - rs;                            /* left  shift */

/*  case FC_MERGE:   */         /*  0001  D <- D .OR. S      */

        if (rs == 0x00)                /* no left/right shift? */
        {
            for (dw-= now + 1, sw-= now + 1 ; h > 0; db+= dw, sb+= sw, h--)
            {
                for (cow = now; cow >= 0x00; db++, sb++, cow--)
                    db[0] = (db[0] | (sb[0]));
            }
        }
        else  if (now == 0x00)          /* totally within one word? */
        {
            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));  /*@WIN*/
            }
        }
        else  if (now == 0x01)          /* just crossing two words? */
        {
            sm =  CC_R_MASK(xe);        /* second mask */

            //NTFIX, no swaping memory is already swaped..
            //
            //SWORDSWAP(sm);                  /*@WIN 10-06-92*/

            for (; h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                db[1] = db[1] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
        else                            /* crossing more than two words! */
        {
            sm =  CC_R_MASK(xe);        /* second mask */

            //NTFIX memory is already swapped.
            //
            //SWORDSWAP(sm);                  /*@WIN 10-06-92*/

            for (dw-= now, sw-= (now - 1); h > 0; db+= dw, sb+= sw, h--)
            {
                db[0] = db[0] | ((CC_RIGH_SHIFT(sb[0], rs)));
                for (db++, cow = now; cow >= 0x02; db++, sb++, cow--)
                {
                    db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                      CC_RIGH_SHIFT(sb[1], rs)));
                }
                db[0] = db[0] | ((CC_LEFT_SHIFT(sb[0], ls) |
                                  CC_RIGH_SHIFT(sb[1], rs)) & sm);
            }
        }
} /* gp_patplt_c */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\gei\main.c ===
/*
 *****************************************************************************
 *
 *      Copyright (c) 1989, 1990 Microsoft Corporation
 *
 ******************************************************************************
 *
 *       main Source Code File
 *
 ******************************************************************************
 *
 *      Filename........:       main.c
 *      Description.....:       This module sets up the default communication
 *                              configuration initializes the Interpreter and
 *                              launches it.
 *      Author..........:
 *      Created.........:
 *      Routines........:
 *              configErr()     - Displays configuration errors.
 *
 ******************************************************************************
 *      History.........: <   date  version  author >
 *                              < description >
 *
 *      03-12-90        V1.00
 *              Cleaned up for source code control & added UNIX flag for SUN
 *              compatability.
 *      04-18-90        V2.00
 *              Created from pdl.c of nike2 startup for SUN build.
 *      06-19-90        V2.10
 *              Cleaned up and changed stdio.h to wrap_io.h.
 *      06-23-90        V2.10
 *              Changed wrap_config.h to ic_config.h and removed wrap_io.h.
 *              Increased memory from 2 Megs to 3 megs.
 *
 ******************************************************************************
 */



// DJC added global include file
#include "psglobal.h"

// DJC DJC #include    "windowsx.h"                /* @WIN */
#include "windows.h"

#include    "winenv.h"                  /* @WIN */
#define INTEL

#ifdef  INTEL
#include <stdio.h>
#endif
#include "ic_cfg.h"
#include "geiio.h"
#include "geierr.h"
#include "geitmr.h"
#include "geisig.h"
#include "gesmem.h"
#include "gescfg.h"

#ifndef TRUE
#define TRUE    ( 1 )
#define FALSE   ( 0 )
#endif

/* @WINl add prototype */
static void configErr(int, char FAR *);
int ps_main(struct ps_config FAR *);

#define ONE_MEG         1024 * 1024
#define PDL_MEM_SIZE    5 * ONE_MEG

#ifdef  INTEL
#define RAM_START       0x10100000L     /* INTEL */
#define RAMSize         0x00a00000L     /* INTEL */
#define FDPTR           0x10600000L     /* Font data area */
#endif
//#define MAXGESBUFSIZE   (60 * 1024)           @WIN
#define MAXGESBUFSIZE   (4 * 1024)
char GESbuffer[ (unsigned)MAXGESBUFSIZE ];

struct ps_config    pscf ;

int TrueImageMain();

/*
 *  return 0: OK
 *      else: fail
 */
int TrueImageMain()
{
        int err=0;      /* @WIN; init to zero */
//      struct ps_config    pscf ;              // move out as global; @WIN
#ifdef  INTEL
//      char    FAR *fdptr;     @WIN
//      char    c_in;           @WIN
//      int     i, j, size;     @WIN
#endif

        GESmem_init( (char FAR *)GESbuffer, (unsigned)MAXGESBUFSIZE );
        GEStmr_init();
#ifndef INTEL
        GESpm_init();
#endif
        GESsig_init();
        GESiocfg_init();
        GEIio_init();

        GEIio_forceopenstdios( _FORCESTDALL );

        if( GEIerror() != EZERO )
        {
            printf( "GEI init failed, code = %d\n", GEIerror() );
            //exit( -1 );
            return(-1);      // return fail; @WIN */
        }

#ifdef  INTEL
/* YM
        fdptr = (char FAR *)FDPTR;
        printf("Please send your font data through RS232.......\n");
        printf("This font data will download to %lx\n", fdptr);
        printf("Please enter your font data size in decimal\n");
        c_in = getchar();
        size = 0;
        for(i=0; (c_in != 0x0D) || (c_in != 0x0A); i++) {
            if(c_in < 0x30 || c_in > 0x39) {
                printf("\007Error...\n");
                printf("Please enter decimal value\n");
                c_in = getchar();
            } else {
                size = size * 10 + (c_in - 0x30);
            }
        }
        printf("Your font data size is %d\n", size);
        printf("Is this size correct ? Y/N (Y)");
        if c_in = getchar() != "n"


        getchar();
*/
        pscf.PsMemoryPtr = (unsigned int FAR *)RAM_START;
        pscf.PsMemorySize = RAMSize;    /* INTEL */
#else
        if (!(pscf.PsMemoryPtr = (unsigned int FAR *) malloc(PDL_MEM_SIZE))) {
                printf("*** Error: allocating %d bytes ***\n",PDL_MEM_SIZE) ;
                //exit(1) ;
                return(-1);      // return fail; @WIN */
        }
        pscf.PsMemorySize = PDL_MEM_SIZE ;
#endif  /* INTEL */
#ifdef DDEBUG
        dprintf("Postscript memory @ %lx, with %lx bytes...\n",
                pscf.PsMemoryPtr, pscf.PsMemorySize) ;
#endif /* DDEBUG */
        if(err = ps_main(&pscf)) {
                switch (err) {
                case PS_CONFIG_MALLOC:
                        configErr(err,"memory size allocation") ;
                        break ;
                case PS_CONFIG_MPLANES:
                        configErr(err,"memory planes") ;
                        break ;
                case PS_CONFIG_MWPP:
                        configErr(err,"memory size per plane") ;
                        break ;
                case PS_CONFIG_DPI:
                        configErr(err,"drawing resolution") ;
                        break ;
                case PS_FATAL_UNKNOWN:
                        configErr(err,"fatal error") ;
                        break ;
                default:
                        configErr(err,"unknown error") ;
                        break ;
                }
        }
        return(err);      // return error code; @WIN */
}

static void configErr(num,msg)
int num ;
char FAR *msg ;
{
        printf("*** Error(%d): ps_main() - %s ***\n",num,msg) ;
        //exit(1) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\coord.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *  Name:      coord.c
 *
 *  Purpose:   Manipulate coordinate systems.
 *
 *  Developer: J. Jih
 *
 *  History:
 *  Version    Date      Comments
 *             1/17/89   op_rotate(): fix bug of transformation from
 *                       any degree to range of 0 to 360
 *             1/25/89   op_invertmatrix(): for compatabitily --
 *                       ignore invalid access check on 1st matrix
 *             1/7/91    change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *             3/20/91   refine the tolance check: UNDRTOLANCE --> IS_ZERO
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"

#define         ERR             3

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static bool near preprocess_op(ufix, struct object_def FAR * FAR *);
static void near get_g_array(struct object_def FAR *, ufix, struct object_def FAR *);
static void near create_object(long32, struct  object_def FAR *);

#else
/* for no type checks of the parameters in function declarations */
static bool near preprocess_op();
static void near get_g_array();
static void near create_object();
#endif

/* @WIN; add prototype */
bool type_chk(struct  object_def FAR *);


/***********************************************************************
 * Given a floating value and an object, to put the value to the object
 * and set it as a real type object.
 *
 * CALL:        create_object()
 *
 * PARAMETER:   l_value     : object value (input)
 *              obj         : will be created object (input/output)
 *
 * INTERFACE:   op_matrix
 **********************************************************************/
static void near
create_object(l_value, obj)
long32    l_value;
struct  object_def FAR *obj;
{
        real32   value;
        union   four_byte  value4;

        value = L2F(l_value);

        /* create object of array element */
        TYPE_SET(obj, REALTYPE);
        ATTRIBUTE_SET(obj, UNLIMITED);
        ACCESS_SET(obj, LITERAL);
        obj->length = 0;
        value4.ff = value;
        obj->value = value4.ll;
        ROM_RAM_SET(obj, RAM);
        LEVEL_SET(obj, current_save_level);

}

/***********************************************************************
 *
 * This module is to check type of array element object
 *
 * TITLE:       type_chk
 *
 * CALL:        type_chk()
 *
 * PARAMETER:   obj_array_element
 *
 * INTERFACE:   * many *
 *
 * CALLS:       none
 *
 * RETURN:      TRUE  : sucess
 *              FALSE : failure
 *
 **********************************************************************/
bool
type_chk(obj_array_element)
struct  object_def      FAR *obj_array_element;
{
        if(!IS_REAL(obj_array_element) &&
           !IS_INTEGER(obj_array_element)){
                ERROR(TYPECHECK);
                return(FALSE);
        }
        else{
                return(TRUE);
        }
}


/***********************************************************************
 *
 * This module is to get value of array element
 *
 * TITLE:       get_array_elmt
 *
 * CALL:        get_array_elmt(obj_array, array_length, elmt, flag)
 *
 * PARAMETER:   obj_array    : array  object
 *              array_length : array length
 *              elmt         : array element
 *              flag         : (PACKEDARRAY || ARRAY) || (ARRAY)
 *
 * INTERFACE:   * many *
 *
 * CALLS:       get_array, get_g_array
 *
 * RETURN:      TRUE  : normal (return elmt)
 *              FALSE : TYPECHECK error
 *
 * Modified by J. Lin, 8-19-1988
 **********************************************************************/
bool16
get_array_elmt(obj_array, array_length, elmt, flag)
 struct  object_def FAR *obj_array;
 fix     array_length;
 real32  FAR elmt[];
 ufix    flag;
{
 fix  i;
 struct  object_def obj_cont, FAR *obj_elmt;
 union   four_byte num4;

    obj_elmt = &obj_cont;
    for (i = 0; i < array_length; i++){
        /* get matrix element object */
        if (flag == G_ARRAY) /* PACKEDARRAY || ARRAY */
           get_g_array(obj_array, i, obj_elmt);
        else /* flag == ARRAY_ONLY */
           get_array(obj_array, i, obj_elmt);

        /* check array element type */
        if (!type_chk(obj_elmt)) {
           ERROR(TYPECHECK);
           return(FALSE);
        } else {
           num4.ll = (fix32)VALUE(obj_elmt);
           if (IS_REAL(obj_elmt))
              elmt[i] = num4.ff;
           else
              elmt[i] = (real32)num4.ll;
        }
    }
    return(TRUE);
}



/***********************************************************************
 *
 * This module is to get array, but no access limit
 *
 * TITLE:       get_g_array
 *
 * CALL:        get_g_array(obj_array, array_length, elmt)
 *
 * PARAMETER:   obj_array    : array  object
 *              array_index  : array index
 *              elmt         : array element
 *
 * INTERFACE:   * many *
 *
 * CALLS:       get_pk_object, get_pk_array
 *
 **********************************************************************/
static void near
get_g_array(obj_array, array_index, elmt)
struct  object_def  FAR *obj_array, FAR *elmt ;
ufix    array_index ;
{
    struct  object_def   FAR *l_temp ;

    l_temp = (struct object_def FAR *)VALUE(obj_array) ;

    if(TYPE(obj_array) == ARRAYTYPE) {
        l_temp += array_index ;
        COPY_OBJ( l_temp, elmt ) ;
    } else
        get_pk_object(get_pk_array((ubyte FAR *)l_temp, array_index), elmt,
                      LEVEL(obj_array)) ;

}   /* end get_g_array */


/***********************************************************************
 *
 * This module is to return a 6_element array object with the value of
 * identity matrix
 *
 * SYNTAX:      -       matrix  matrix
 *
 * TITLE:       op_matrix
 *
 * CALL:        op_matrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_matrix)
 *
 * CALLS:       create_object, put_array
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_matrix()
{
        struct object_def obj_array;

        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* create a new array object */
        create_array(&obj_array, MATRIX_LEN);

        /* create array element object */
        create_object(F2L(one_f) ,GET_OBJ(&obj_array,0));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,1));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,2));
        create_object(F2L(one_f) ,GET_OBJ(&obj_array,3));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,4));
        create_object(F2L(zero_f),GET_OBJ(&obj_array,5));

        /* push array object on the operand stack */
        PUSH_OBJ(&obj_array);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current CTM in the current graphics state
 * to device default matrix
 *
 * SYNTAX:      -       initmatrix      -
 *
 * TITLE:       op_initmatrix
 *
 * CALL:        op_initmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_initmatrix)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_initmatrix()
{
        ufix16  i;

        /* set the current CTM to default matrix */
        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }
        /* the default CTM is initially established by the framedevice
         * or banddevice operator, i.e. default CTM =
         * [4.166666, 0.0, 0.0, -4.166666, -75.0, 3268.0]
         */

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of
 * identity matrix
 *
 * SYNTAX:      matrix  identmatrix     matrix
 *
 * TITLE:       op_identmatrix
 *
 * CALL:        op_identmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_identmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_identmatrix()
{
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }


        /* create matrix element object */
        PUT_VALUE(F2L(one_f), 0, obj_matrix);
        PUT_VALUE(F2L(zero_f), 1, obj_matrix);
        PUT_VALUE(F2L(zero_f), 2, obj_matrix);
        PUT_VALUE(F2L(one_f), 3, obj_matrix);
        PUT_VALUE(F2L(zero_f), 4, obj_matrix);
        PUT_VALUE(F2L(zero_f), 5, obj_matrix);
        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of the
 * device default matrix
 *
 * SYNTAX:      matrix  defaultmatrix   matrix
 *
 * TITLE:       op_defaultmatrix
 *
 * CALL:        op_defaultmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_defaultmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_defaultmatrix()
{
        ufix16  i;
        struct  object_def FAR *obj_matrix;

        /* get operand  */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        for(i = 0; i < MATRIX_LEN; i++){
            /* create matrix element object */
            PUT_VALUE(F2L(GSptr->device.default_ctm[i]), i, obj_matrix);
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix with the value of the
 * current CTM
 *
 * SYNTAX:      matrix  currentmatrix   matrix
 *
 * TITLE:       op_currentmatrix
 *
 * CALL:        op_currentmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentmatrix)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentmatrix()
{
        ufix16  i;
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check access right */
        if( !access_chk(obj_matrix, ARRAY_ONLY) ) return(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        for(i = 0; i < MATRIX_LEN; i++){
            /* create matrix element object */
            PUT_VALUE(F2L(GSptr->ctm[i]), i, obj_matrix);
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current CTM in the current graphics state
 * to the specific matrix
 *
 * SYNTAX:      matrix  setmatrix       -
 *
 * TITLE:       op_setmatrix
 *
 * CALL:        op_setmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setmatrix)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setmatrix()
{
        struct  object_def FAR *obj_matrix;

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check rangecheck error */
        if (LENGTH(obj_matrix) != MATRIX_LEN) {
           ERROR(RANGECHECK);
           return(0);
        }

        if (!get_array_elmt(obj_matrix, MATRIX_LEN, GSptr->ctm ,G_ARRAY))
           return(0);

        /* pop operand stack */
        POP(1);
        return(0);
} /* op_setmatrix() */


/***********************************************************************
 *
 * This module is used as preprocessor of procedure that process two
 * operator types, its function includes check STACKUNDERFLOW,
 * TYPECHECK, and decide if matrix operand is exist, if matrix operand
 * is exist then check RANGECHECK also
 *
 * TITLE:       preprocess_op
 *
 * CALL:        preprocess_op()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_translate, op_scale, op_itransform, op_idtransform
 *
 * CALLS:       none
 *
 * RETURN:      matrix_exist : matrix exist flag
 *
 **********************************************************************/
static bool near
preprocess_op(opns, obj_opd)
ufix    opns;
struct  object_def FAR * FAR obj_opd[];
{
        bool    matrix_exist;

        /* get operand */
        obj_opd[0] = GET_OPERAND(0);

        if(opns == 3){
                matrix_exist = TRUE;           /* matrix exist flag */

                /* check rangecheck error */
                if(LENGTH(obj_opd[0]) != MATRIX_LEN){
                        ERROR(RANGECHECK);
                        return(ERR);
                }

                obj_opd[1] = GET_OPERAND(1);
                obj_opd[2] = GET_OPERAND(2);

        }
        else{
                matrix_exist = FALSE;          /* matrix exist flag */

                obj_opd[1] = GET_OPERAND(1);

        }
        return(matrix_exist);
}


/***********************************************************************
 *
 * This module is to move the origin of the user coordinate system by
 * (tx, ty) units, or to define translating the value of matrix by
 * (tx, ty) units
 *
 * SYNTAX:               tx  ty  translate       -
 *        or     tx  ty  matrix  translate       matrix
 *
 * TITLE:       op_translate
 *
 * CALL:        op_translate()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_translate)
 *
 * CALLS:       preprocess_op, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_translate(opns)
fix     opns;
{
        real32   tx, ty;
        bool    matrix_exist;
        struct  object_def FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
             return(0);
        }
        else if(matrix_exist == TRUE){

             /* check access right */
             if( !access_chk(obj_operand[0], ARRAY_ONLY)) return(0);

             GET_OBJ_VALUE(tx, obj_operand[2]);
             GET_OBJ_VALUE(ty, obj_operand[1]);

             PUT_VALUE(F2L(one_f), 0, obj_operand[0]);
             PUT_VALUE(F2L(zero_f), 1, obj_operand[0]);
             PUT_VALUE(F2L(zero_f), 2, obj_operand[0]);
             PUT_VALUE(F2L(one_f), 3, obj_operand[0]);
             PUT_VALUE(F2L(tx), 4, obj_operand[0]);
             PUT_VALUE(F2L(ty), 5, obj_operand[0]);

             /* pop operand stack */
             POP(3);

             /* push modified matrix on the operand stack */
             PUSH_OBJ(obj_operand[0]);
        }
        else{   /* matrix_exist == FALSE */

                /* replace the CTM by [1.0, 0.0, 0.0, 1.0, tx, ty] * CTM,
                 * i.e., GSptr->ctm[ep, fp] = GSptr->ctm[a*tx + c*ty + e,
                 * b*tx + d*ty + f] */

                GET_OBJ_VALUE(tx, obj_operand[1]);
                GET_OBJ_VALUE(ty, obj_operand[0]);

                _clear87() ;
                GSptr->ctm[4] = GSptr->ctm[0] * tx + GSptr->ctm[2] * ty +
                                GSptr->ctm[4];
                CHECK_INFINITY(GSptr->ctm[4]);

                GSptr->ctm[5] = GSptr->ctm[1] * tx + GSptr->ctm[3] * ty +
                                GSptr->ctm[5];
                CHECK_INFINITY(GSptr->ctm[5]);
                /* pop operand stack */
                POP(2);
        }

        return(0);
}

/***********************************************************************
 *
 * This module is to scale the user coordinate system by (sx, sy) units,
 * or to define scaling the value of matrix by (sx, sy) units
 *
 * SYNTAX:              sx  sy  scale   -
 *        or    sx  sy  matrix  scale   matrix
 *
 * TITLE:       op_scale
 *
 * CALL:        op_scale()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_scale)
 *
 * CALLS:       preprocess_op, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_scale(opns)
fix     opns;
{
        real32   sx, sy;
        bool    matrix_exist;
        struct  object_def FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
             return(0);
        }
        else if(matrix_exist == TRUE){

            /* check access right */
            if( !access_chk(obj_operand[0], ARRAY_ONLY) ) return(0);

            GET_OBJ_VALUE(sx, obj_operand[2]);
            GET_OBJ_VALUE(sy, obj_operand[1]);

            PUT_VALUE(F2L(sx), 0, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 1, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 2, obj_operand[0]);
            PUT_VALUE(F2L(sy), 3, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 4, obj_operand[0]);
            PUT_VALUE(F2L(zero_f), 5, obj_operand[0]);

            /* pop operand stack */
            POP(3);

            /* push modified matrix on the operand stack */
            PUSH_OBJ(obj_operand[0]);

        }
        else{   /* matrix_exist == FALSE */

                /* replace the CTM by [sx, 0.0, 0.0, sy, 0.0, 0.0]*CTM,
                 * i.e., GSptr->ctm[ap, bp, cp, dp] =
                 *       GSptr->ctm[a*sx, b*sx, c*sy, d*sy] */

#ifdef DBG
                printf("op_scale: before\n");
                printf("ctm[0]=%f, ctm[1]=%f\n", GSptr->ctm[0], GSptr->ctm[1]);
                printf("ctm[2]=%f, ctm[3]=%f\n", GSptr->ctm[2], GSptr->ctm[3]);
                printf("ctm[4]=%f, ctm[5]=%f\n", GSptr->ctm[4], GSptr->ctm[5]);
#endif
                GET_OBJ_VALUE(sx, obj_operand[1]);
                GET_OBJ_VALUE(sy, obj_operand[0]);

                _clear87() ;
                GSptr->ctm[0] = GSptr->ctm[0] * sx;
                CHECK_INFINITY(GSptr->ctm[0]);

                GSptr->ctm[1] = GSptr->ctm[1] * sx;
                CHECK_INFINITY(GSptr->ctm[1]);

                GSptr->ctm[2] = GSptr->ctm[2] * sy;
                CHECK_INFINITY(GSptr->ctm[2]);

                GSptr->ctm[3] = GSptr->ctm[3] * sy;
                CHECK_INFINITY(GSptr->ctm[3]);

                /* pop operand stack */
                POP(2);
#ifdef DBG
                printf("op_scale: after\n");
                printf("ctm[0]=%f, ctm[1]=%f\n", GSptr->ctm[0], GSptr->ctm[1]);
                printf("ctm[2]=%f, ctm[3]=%f\n", GSptr->ctm[2], GSptr->ctm[3]);
                printf("ctm[4]=%f, ctm[5]=%f\n", GSptr->ctm[4], GSptr->ctm[5]);
#endif
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to rotate the user coordinate system by angle degrees,
 * or to rotating the value of matrix by angle degrees
 *
 * SYNTAX:              angle  rotate   -
 *         or   angle  matrix  rotate   matrix
 *
 * TITLE:       op_rotate
 *
 * CALL:        op_rotate()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_rotate)
 *
 * CALLS:       PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_rotate(opns)
fix     opns;
{
        real64  theta;
        bool    matrix_exist;
        real32   a, b, c, d;
        real32   angle, cos_theta, sin_theta, neg_sin_theta;
        struct  object_def FAR *obj_opd0, FAR *obj_opd1;

        /* get operand */
        obj_opd0 = GET_OPERAND(0);

        if(opns == 2){
                matrix_exist = TRUE;           /* matrix exist flag */

                /* check rangecheck error */
                if(LENGTH(obj_opd0) != MATRIX_LEN){
                        ERROR(RANGECHECK);
                        return(0);
                }

                /* get operand */
                obj_opd1 = GET_OPERAND(1);

        }
        else{
             matrix_exist = FALSE;          /* matrix exist flag */
        }

        if(matrix_exist == TRUE){

            GET_OBJ_VALUE(angle, obj_opd1);
            if( F2L(angle) == F2L(infinity_f)){
                  cos_theta = infinity_f;
                  sin_theta = infinity_f;
            }
            else{
                  /* angle -= (real32)floor(angle/360.)*360.; 1/17/89 */
                  theta = angle * PI / 180;
                  cos_theta = (real32)cos(theta);
                  sin_theta = (real32)sin(theta);
            }

            /* check access right */
            if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);

            PUT_VALUE(F2L(cos_theta), 0, obj_opd0);
            PUT_VALUE(F2L(sin_theta), 1, obj_opd0);

            if(F2L(sin_theta) == F2L(infinity_f)){
                 PUT_VALUE(F2L(infinity_f), 2, obj_opd0);
            }
            else{
                 neg_sin_theta = -sin_theta;
                 PUT_VALUE(F2L(neg_sin_theta), 2, obj_opd0);
            }

            PUT_VALUE(F2L(cos_theta), 3, obj_opd0);
            PUT_VALUE(F2L(zero_f), 4, obj_opd0);
            PUT_VALUE(F2L(zero_f), 5, obj_opd0);
            /* pop operand stack */
            POP(2);

            /* push modified matrix on the operand stack */
            PUSH_OBJ(obj_opd0);
        }
        else{   /* matrix_exist == FALSE */

                GET_OBJ_VALUE(angle, obj_opd0);
                if( F2L(angle) == F2L(infinity_f)){
                  GSptr->ctm[0] = infinity_f;
                  GSptr->ctm[1] = infinity_f;
                  GSptr->ctm[2] = infinity_f;
                  GSptr->ctm[3] = infinity_f;
                  POP(1);
                  return(0);
                }
                else{
                      /* angle -= (real32)floor(angle/360.)*360.; 1/17/89 */
                      theta = angle * PI / 180;
                      cos_theta = (real32)cos(theta);
                      sin_theta = (real32)sin(theta);
                }

                /* replace the CTM by  R * CTM,
                 * i.e., GSptr->ctm = [cos, sin, -sin, cos, 0.0, 0.0]*CTM */
                a = GSptr->ctm[0];
                b = GSptr->ctm[1];
                c = GSptr->ctm[2];
                d = GSptr->ctm[3];
                _clear87() ;
                GSptr->ctm[0] =  a * cos_theta + c * sin_theta;
                CHECK_INFINITY(GSptr->ctm[0]);

                GSptr->ctm[1] =  b * cos_theta + d * sin_theta;
                CHECK_INFINITY(GSptr->ctm[1]);

                GSptr->ctm[2] = -a * sin_theta + c * cos_theta;
                CHECK_INFINITY(GSptr->ctm[2]);

                GSptr->ctm[3] = -b * sin_theta + d * cos_theta;
                CHECK_INFINITY(GSptr->ctm[3]);
                /* pop operand stack */
                POP(1);
        }

        return(0);
}


/***********************************************************************
 *
 * state by concatenating the matrix with the current CTM
 *
 * SYNTAX:      matrix  concat  -
 *
 * TITLE:       op_concat
 *
 * CALL:        op_concat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_concate)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_concat()
{
        struct  object_def FAR *obj_matrix;
        real32   l, m, n, o, p, q, elmt[MATRIX_LEN];

        /* get operand */
        obj_matrix = GET_OPERAND(0);

        /* check rangecheck error */
        if(LENGTH(obj_matrix) != MATRIX_LEN){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_matrix, G_ARRAY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_matrix,MATRIX_LEN,(real32 FAR*) elmt,G_ARRAY))
                return(0);

        /* value of CTM elements */
        l = GSptr->ctm[0];
        m = GSptr->ctm[1];
        n = GSptr->ctm[2];
        o = GSptr->ctm[3];
        p = GSptr->ctm[4];
        q = GSptr->ctm[5];

        _clear87() ;
        GSptr->ctm[0] = elmt[0] * l + elmt[1] * n;
        CHECK_INFINITY(GSptr->ctm[0]);

        GSptr->ctm[1] = elmt[0] * m + elmt[1] * o;
        CHECK_INFINITY(GSptr->ctm[1]);

        GSptr->ctm[2] = elmt[2] * l + elmt[3] * n;
        CHECK_INFINITY(GSptr->ctm[2]);

        GSptr->ctm[3] = elmt[2] * m + elmt[3] * o;
        CHECK_INFINITY(GSptr->ctm[3]);

        GSptr->ctm[4] = elmt[4] * l + elmt[5] * n + p;
        CHECK_INFINITY(GSptr->ctm[4]);

        GSptr->ctm[5] = elmt[4] * m + elmt[5] * o + q;
        CHECK_INFINITY(GSptr->ctm[5]);

        /* pop operand stack */
        POP(1);
        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix3 by the result of
 * concatenating matrix1 with the matrix2
 *
 * SYNTAX:      matrix1  matrix2  matrix3 concatmatrix  matrix3
 *
 * TITLE:       op_concatmatrix
 *
 * CALL:        op_concatmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_concatmatrix)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_concatmatrix()
{
        real32   ap, bp, cp, dp, ep, fp;
        real32   elmt1[MATRIX_LEN], elmt2[MATRIX_LEN];
        struct  object_def FAR *obj_opd0, FAR *obj_opd1, FAR *obj_opd2;

        obj_opd0 = GET_OPERAND(0);
        obj_opd1 = GET_OPERAND(1);
        obj_opd2 = GET_OPERAND(2);

        /* check rangecheck error */
        if((LENGTH(obj_opd0) != MATRIX_LEN) ||
           (LENGTH(obj_opd1) != MATRIX_LEN) ||
           (LENGTH(obj_opd2) != MATRIX_LEN)){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);
        if( !access_chk(obj_opd1, G_ARRAY) ) return(0);
        if( !access_chk(obj_opd2, G_ARRAY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd2,MATRIX_LEN,(real32 FAR*)elmt2,G_ARRAY))
                return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd1,MATRIX_LEN,(real32 FAR*)elmt1,G_ARRAY))
                return(0);

        /* create modified matrix3 element objects */
        _clear87() ;
        ap = elmt2[0] * elmt1[0] + elmt2[1] * elmt1[2];
        CHECK_INFINITY(ap);

        bp = elmt2[0] * elmt1[1] + elmt2[1] * elmt1[3];
        CHECK_INFINITY(bp);

        cp = elmt2[2] * elmt1[0] + elmt2[3] * elmt1[2];
        CHECK_INFINITY(cp);

        dp = elmt2[2] * elmt1[1] + elmt2[3] * elmt1[3];
        CHECK_INFINITY(dp);

        ep = elmt2[4] * elmt1[0] + elmt2[5] * elmt1[2] + elmt1[4];
        CHECK_INFINITY(ep);

        fp = elmt2[4] * elmt1[1] + elmt2[5] * elmt1[3] + elmt1[5];
        CHECK_INFINITY(fp);

        PUT_VALUE(F2L(ap), 0, obj_opd0);
        PUT_VALUE(F2L(bp), 1, obj_opd0);
        PUT_VALUE(F2L(cp), 2, obj_opd0);
        PUT_VALUE(F2L(dp), 3, obj_opd0);
        PUT_VALUE(F2L(ep), 4, obj_opd0);
        PUT_VALUE(F2L(fp), 5, obj_opd0);

        /* pop operand stack */
        POP(3);

        /* push modified matrix3 on the operand stack */
        /* PUSH_OBJ(obj_opd0);  this cause one more save level Nov-11-91 YM */
        PUSH_ORIGLEVEL_OBJ(obj_opd0); /* Nov-11-91 YM */

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the user coordinate (x, y) by the current
 * CTM to produce the corresponding device coordinate (x', y'), or to
 * transform (x, y) by the matrix to produce the corresponding (x', y')
 *
 * SYNTAX:              x  y  transform  x'  y'
 *         or   x  y  matrix  transform  x'  y'
 *
 * TITLE:       op_transform
 *
 * CALL:        op_transform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_transform)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_transform(opns)
fix     opns;
{
        bool    matrix_exist;
        union   four_byte   xp4, yp4;
        real32   x, y, xp, yp, elmt[MATRIX_LEN];
        struct  object_def  FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(x, obj_operand[2]);
                GET_OBJ_VALUE(y, obj_operand[1]);

                /* get matrix element */
                if(!get_array_elmt(obj_operand[0],MATRIX_LEN,
                    (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                _clear87() ;
                xp = elmt[0] * x + elmt[2] * y + elmt[4];
                CHECK_INFINITY(xp);

                yp = elmt[1] * x + elmt[3] * y + elmt[5];
                CHECK_INFINITY(yp);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(x, obj_operand[1]);
                GET_OBJ_VALUE(y, obj_operand[0]);

                _clear87() ;
                xp = GSptr->ctm[0]*x + GSptr->ctm[2]*y + GSptr->ctm[4];
                CHECK_INFINITY(xp);

                yp = GSptr->ctm[1]*x + GSptr->ctm[3]*y + GSptr->ctm[5];
                CHECK_INFINITY(yp);

                /* pop operand stack */
                POP(2);
        }

        /* push (xp, yp) on the operand stack */
        xp4.ff = xp;
        yp4.ff = yp;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xp4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yp4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the distance vector (dx, dy) by the
 * current CTM to produce the corresponding distance vector (dx', dy')
 * in device coordinate, or to transform (dx, dy) by the matrix to
 * produce the corresponding (dx', dy')
 *
 * SYNTAX:              dx  dy  dtransform  dx'  dy'
 *         or   dx  dy  matrix  dtransform  dx'  dy'
 *
 * TITLE:       op_dtransform
 *
 * CALL:        op_dtransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_dtransform)
 *
 * CALLS:       get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_dtransform(opns)
fix     opns;
{
        bool    matrix_exist;
        union   four_byte   dxp4, dyp4;
        real32   dx, dy, dxp, dyp, elmt[MATRIX_LEN];
        struct  object_def  FAR *obj_operand[3];

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(dx, obj_operand[2]);
                GET_OBJ_VALUE(dy, obj_operand[1]);

                /* get matrix element */
                if(!get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY) )
                        return(0);

                _clear87() ;
                dxp = elmt[0] * dx + elmt[2] * dy;
                CHECK_INFINITY(dxp);

                dyp = elmt[1] * dx + elmt[3] * dy;
                CHECK_INFINITY(dyp);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(dx, obj_operand[1]);
                GET_OBJ_VALUE(dy, obj_operand[0]);

                _clear87() ;
                dxp = GSptr->ctm[0]*dx + GSptr->ctm[2]*dy;
                CHECK_INFINITY(dxp);

                dyp = GSptr->ctm[1]*dx + GSptr->ctm[3]*dy;
                CHECK_INFINITY(dyp);

                /* pop operand stack */
                POP(2);
        }

        /* push (dxp, xyp) on the operand stack */
        dxp4.ff = dxp;
        dyp4.ff = dyp;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dxp4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dyp4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the user coordinate (x', 'y) by the
 * inverse of current CTM to produce the corresponding device coordinate
 * (x, y), or to transform (x', y') by the inverse matrix to produce the
 * corresponding (x, y)
 *
 * SYNTAX:              x'  y'  itransform  x  y
 *         or   x'  y'  matrix  itransform  x  y
 *
 * TITLE:       op_itransform
 *
 * CALL:        op_itransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_itransform)
 *
 * CALLS:       preprocess_op, get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_itransform(opns)
fix     opns;
{
        bool    matrix_exist;
        real32   det_matrix;
        real32   x, y, xp, yp, elmt[MATRIX_LEN];
        union   four_byte   x4, y4;
        struct  object_def  FAR *obj_operand[3];
        /*real32  tmp;*/

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(xp, obj_operand[2]);
                GET_OBJ_VALUE(yp, obj_operand[1]);

                /* get matrix element */
                if( !get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                _clear87() ;
                det_matrix = elmt[0] * elmt[3] - elmt[1] * elmt[2];
                CHECK_INFINITY(det_matrix);


                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                x = (elmt[3]*xp - elmt[2]*yp - elmt[4]*elmt[3] +
                     elmt[2]*elmt[5]) / det_matrix;
                CHECK_INFINITY(x);

                y = (elmt[0]*yp - elmt[1]*xp - elmt[0]*elmt[5] +
                     elmt[4]*elmt[1]) / det_matrix;
                CHECK_INFINITY(y);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(xp, obj_operand[1]);
                GET_OBJ_VALUE(yp, obj_operand[0]);

                _clear87() ;
                det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                             GSptr->ctm[1] * GSptr->ctm[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                x = (GSptr->ctm[3]*xp - GSptr->ctm[2]*yp -
                     GSptr->ctm[4]*GSptr->ctm[3] +
                     GSptr->ctm[2]*GSptr->ctm[5]) / det_matrix;
                CHECK_INFINITY(x);

                y = (GSptr->ctm[0]*yp - GSptr->ctm[1]*xp -
                     GSptr->ctm[0]*GSptr->ctm[5] +
                     GSptr->ctm[4]*GSptr->ctm[1]) / det_matrix;
                CHECK_INFINITY(y);

                /* pop operand stack */
                POP(2);
        }

        /* push (x, y) on the operand stack */
        x4.ff = x;
        y4.ff = y;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to transform the distance vector (dx', dy') by the
 * inverse of current CTM to produce the corresponding distance vector
 * (dx, dy) in user coordinate, or to transform (dx', dy') by the
 * inverse of matrix to produce the corresponding (dx, dy)
 *
 * SYNTAX:              dx'  dy'  idtransform  dx  dy
 *         or   dx'  dy'  matrix  idtransform  dx  dy
 *
 * TITLE:       op_idtransform
 *
 * CALL:        op_idtransform()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_idtransform)
 *
 * CALLS:       preprocess_op, get_array_elmt
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_idtransform(opns)
fix     opns;
{
        bool    matrix_exist;
        real32   det_matrix;
        real32   dx, dy, dxp, dyp, elmt[MATRIX_LEN];
        union   four_byte   dx4, dy4;
        struct  object_def  FAR *obj_operand[3];
        /*real32  tmp;*/

        /* preprocess operands : check error and dcide operator type */
        matrix_exist = preprocess_op(opns, obj_operand);

        if(matrix_exist == ERR){
                return(0);
        }
        else if(matrix_exist == TRUE){

                GET_OBJ_VALUE(dxp, obj_operand[2]);
                GET_OBJ_VALUE(dyp, obj_operand[1]);

                /* get matrix element */
                if( !get_array_elmt(obj_operand[0],MATRIX_LEN,
                        (real32 FAR*)elmt,G_ARRAY))
                        return(0);

                /* calculate the det(matrix) */
                _clear87() ;
                det_matrix = elmt[0] * elmt[3] - elmt[1] * elmt[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                /* calculate (dx, dy), (dx, dy) -concat- INV(matrix) */
                dx = ( elmt[3] / det_matrix) * dxp +
                     (-elmt[2] / det_matrix) * dyp;
                CHECK_INFINITY(dx);

                dy = (-elmt[1] / det_matrix) * dxp +
                     ( elmt[0] / det_matrix) * dyp;
                CHECK_INFINITY(dy);

                /* pop operand stack */
                POP(3);
        }
        else{   /*matrix_exist == FALSE */

                GET_OBJ_VALUE(dxp, obj_operand[1]);
                GET_OBJ_VALUE(dyp, obj_operand[0]);

                /* calculate the det(CTM) */
                _clear87() ;
                det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                             GSptr->ctm[1] * GSptr->ctm[2];
                CHECK_INFINITY(det_matrix);

                /* check undefinedresult error */
                /*FABS(tmp, det_matrix);
                if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
                if(IS_ZERO(det_matrix)) {
                        ERROR(UNDEFINEDRESULT);
                        return(0);
                }

                /* calculate (dx, dy), (dx, dy) -concat- INV(CTM) */
                dx = ( GSptr->ctm[3] / det_matrix) * dxp +
                     (-GSptr->ctm[2] / det_matrix) * dyp;
                CHECK_INFINITY(dx);

                dy = (-GSptr->ctm[1] / det_matrix) * dxp +
                     ( GSptr->ctm[0] / det_matrix) * dyp;
                CHECK_INFINITY(dy);

                /* pop operand stack */
                POP(2);
        }

        /* push (dx, dy) on the operand stack */
        dx4.ff = dx;
        dy4.ff = dy;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dx4.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, dy4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to replace the value of matrix2 by the result of
 * inverting matrix1
 *
 * SYNTAX:      matrix1  matrix2  invertmatrix  matrix2
 *
 * TITLE:       op_invertmatrix
 *
 * CALL:        op_invertmatrix()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_invertmatrix)
 *
 * CALLS:       get_array_elmt, PUT_VALUE
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_invertmatrix()
{
        real32   det_matrix1;
        real32   ap, bp, cp, dp, ep, fp, elmt[MATRIX_LEN];
        struct  object_def FAR *obj_opd0, FAR *obj_opd1;
        /*real32  tmp;*/

        obj_opd0 = GET_OPERAND(0);
        obj_opd1 = GET_OPERAND(1);

        /* check rangecheck error */
        if((LENGTH(obj_opd0) != MATRIX_LEN) ||
           (LENGTH(obj_opd1) != MATRIX_LEN)){
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        if( !access_chk(obj_opd0, ARRAY_ONLY) ) return(0);

        /* get matrix element */
        if( !get_array_elmt(obj_opd1,MATRIX_LEN,
                (real32 FAR*)elmt,G_ARRAY) ) return(0);

        /* calculate the det(matrix1) */
        _clear87() ;
        det_matrix1 = elmt[0] * elmt[3] - elmt[1] * elmt[2];
        CHECK_INFINITY(det_matrix1);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix1);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix1)) {
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        ap =  elmt[3] / det_matrix1;
        CHECK_INFINITY(ap);

        bp = -elmt[1] / det_matrix1;
        CHECK_INFINITY(bp);

        cp = -elmt[2] / det_matrix1;
        CHECK_INFINITY(cp);

        dp =  elmt[0] / det_matrix1;
        CHECK_INFINITY(dp);

        ep = (elmt[2] * elmt[5] - elmt[3] * elmt[4]) / det_matrix1;
        CHECK_INFINITY(ep);

        fp = (elmt[1] * elmt[4] - elmt[0] * elmt[5]) / det_matrix1;
        CHECK_INFINITY(fp);

        PUT_VALUE(F2L(ap), 0, obj_opd0);
        PUT_VALUE(F2L(bp), 1, obj_opd0);
        PUT_VALUE(F2L(cp), 2, obj_opd0);
        PUT_VALUE(F2L(dp), 3, obj_opd0);
        PUT_VALUE(F2L(ep), 4, obj_opd0);
        PUT_VALUE(F2L(fp), 5, obj_opd0);
        /* pop operand stack */
        POP(2);

        /* push modified matrix2 on the operand stack */
        PUSH_OBJ(obj_opd0);

        return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\filling.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   filling.c
 *
 *      Purpose: This file contains 2 modules of filling interfaces:
 *               1) fill_shape -- to fill the current path
 *               2) stroke_shape -- to stroke the current path
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *                  2/5/88      @IMAGE: enhance image processing
 *                  2/12/88     @RAISE_ONLY:
 *                              raise one pixel of problem point
 *                  2/25/88     add first_flag
 *                  2/27/88     @EHS_CACHE: enhance cache
 *                  3/1/88      @F_CHOP: truncation of filling
 *                                       RND_S -> INT_S
 *                  3/3/88      INT_S -> SFX_I
 *                  3/3/88      @RSL: fill resolution in SFX unit
 *                  3/18/88     @HORZ_LINE: add horizontal lines
 *                  3/21/88     @FILL_INFO: put bounding box information
 *                                 of filling to a global structure
 *                  3/24/88     @DFR_SCAN: defer scan_conversion, put
 *                              all edges and just do scan-conversion
 *                              once.
 *                  4/2/88      @CHOP_BOX:
 *                              bounding box: round -> truncation
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  4/22/88     @EHS_ROUND: enhance round_join and
 *                              round_cap
 *                  6/7/88      delete @DFR_SCAN; not defer performing
 *                              scan_conversion
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int   ==> sfix_t, for short fixed real
 *                                       ==> fix, for integer
 *                              3) int_coord ==> coord_i
 *                              4) delete INTG, FRAC, RND_S macro definitions
 *                              5) SFX_I ==> SFX2I_T
 *                              6) move ONE_SFX, HALF_SFX to "graphics.h"
 *                              7) bb_y << 3 ==> I2SFX(bb_y)
 *                  7/20/88     @ALIGN_W: word alignment of bounding box
 *                  7/28/88     @PARA: remove unused parameters of graphics
 *                              primitives interface
 *      3.0         8/13/88     @SCAN_EHS: scan_conversion enhancement
 *                              delete filler(), put_fill_edge().
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and set its value only at
 *                              necessary time instead of each op_stroke command
 *      3.0         9/10/88     @STK_INT: stroke enhancement for stroking under
 *                              interger operations
 *                  10/21/88    @THIN_STK: add condition for checking thin
 *                              linewidth stroke
 *                              call new routines: is_thinstroke &
 *                                                 path_to_outline_t
 *                  10/28/88    @CRC: update circle cache for putting bitmap in
 *                              correct position:
 *                              1. revise
 *                                 1) round_point for setting ref_x & ref_y,
 *                                    and calling fill_shape(.., F_FROM_CRC)
 *                                 2) fill_shape: add another type F_FROM_CRC
 *                  11/22/88    revise the sequence of conditions of checking
 *                              thin linewidth stroke in stroke_shape():
 *                  11/30/88    fill_shape(): call init_edgetable before
 *                              shape_approximation
 *                  01/16/89    @IMAGE: fill_shape(): add new fill type
 *                              F_FROM_IMAGE to generate clipping mask (CMB)
 *                              from clippath for clipped image/imagemask
 *                  01/26/89    stroke_shape(): return if any error occurs
 *                  08/11/89    fill_shape(): Update the max. y-coord(bb_uy),
 *                              decreased by 1, for step 2 of filling from cache
 *                              to page.
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  12/12/90    @CPPH: stroke_shape(): set current point as
 *                              init values of bbox, since path->head may be
 *                              NULLP.
 *                  03/26/91    stroke_shape(): added CLEAR_ERROR and
 *                              traverse_path to avoid error which come from
 *                              0 scale at the x and y direction.
 *                  4/17/91     fill_shape(): limit check for edge table
 *                  11/20/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"

/* ********* local constants *********** */
/* stroke type */
#define FLOAT_STROKE            1  /* floating point stroking */
#define THIN_STROKE             2  /* thin line width stroke */
#define INTEGER_STROKE_IN_CLIP  3  /* integer stroke & inside single clip */
#define INTEGER_STROKE_OV_CLIP  4  /* integer stroke & not inside single clip */

/* ********** static variables ********** */
static real32 near cache_y = (real32)0.0;        /* @EHS_CACHE */
static fix near cache_y_ii = 0;

/***********************************************************************
 * This routine provides an interface to fill the current path.
 *
 * TITLE:       fill_shape
 *
 * CALL:        fill_shape (winding_type, fill_type, dest)
 *
 * PARAMETERS:  winding_type -- (NON_ZERO/EVEN_ODD)
 *              fill_type -- F_NORMAL: from path to page or cache
 *                           F_FROM_CACHE: from cache to page
 *              dest -- F_TO_PAGE: fill to page
 *                      F_TO_CACHE: fill to cache
 *
 *              combination:
 *               fill_type   |  dest      |
 *              -------------+------------+-----------------------------------
 *               F_NORMAL    | F_TO_PAGE  | fill current path to page
 *               F_NORMAL    | F_TO_CACHE | fill current path to cache memory
 *               F_FROM_CACHE| F_TO_PAGE  | get bitmap from cache, and move to
 *                           |            | page
 *
 * INTERFACE:   op_fill, op_eofill, font machineary
 *
 * CALLS:       traverse_path, shape_approximation, shape_reduction
 *              op_newpath, draw_cache_page, init_cache_page,
 *              save_tpzd, fill_cache_page
 *
 * RETURN:      None
 **********************************************************************/
void fill_shape (winding_type, fill_type, dest)
ufix    winding_type, fill_type, dest;
{
    fix     bb_xorig, bb_yorig, bb_width, bb_heigh, bb_uy;
    CP_IDX icp;
    struct nd_hdr FAR *cp;
    struct polygon_i polygon, FAR *pgn; /*@WIN*/
    ufix        save;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
    real32   tmp;
#elif  FORMAT_16_16
    long dest1[2];
#elif  FORMAT_28_4
    long dest1[2];
#endif

    pgn = (struct polygon_i FAR *)&polygon;     /*@WIN*/

    switch (fill_type) {

    case F_NORMAL :         /* from shape to page/cache */
        fill_destination = dest;

        /* initialize edge table 11/30/88 */
        init_edgetable();       /* in "shape.c" */

        /* perform shape approximation, reduction, then fill it */
        traverse_path (shape_approximation, (fix FAR *)NULLP);
        if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                return;
        }
        shape_reduction (winding_type);

        if ( ANY_ERROR() == LIMITCHECK ) /* 05/07/91, Peter, out of scany_table */
                return;

        op_newpath();
        break;

    case F_FROM_CRC :     /* from circle cache to page @CRC 10/28/88 */
        fill_destination = dest;        /* 12/09/87 */

        /* STEP 1 : clear clipping bitmap */
        bb_xorig = SFX2I_T((F2SFX(GSptr->position.x) - cache_info->ref_x));
        bb_yorig = SFX2I_T((F2SFX(GSptr->position.y) - cache_info->ref_y));
        goto set_bb;            /*
                                 * Because circle cache needs 1/8 pixel unit of
                                 * ref_x and ref_y to compute the correct
                                 * bb_xorig and bb_yorig, so use different
                                 * calculation with F_FROM_CACHE case.
                                 * F2SFX should be consistent with those
                                 * defined in path_to_outline_i and
                                 * path_to_outline_t
                                 */

    case F_FROM_CACHE :     /* from cache to page */
        fill_destination = dest;        /* 12/09/87 */

        /* STEP 1 : clear clipping bitmap */
        /* get bounding box information on page */      /* 12/17/87 */

        //UPD058
        bb_xorig = (fix)(GSptr->position.x+.5) - cache_info->ref_x;/* 2/24/88 */

/*      bb_yorig = (fix)(GSptr->position.y) - cache_info->ref_y;
 */
        if (F2L(cache_y) != F2L(GSptr->position.y)) {   /* @EHS_CACHE 2/27/88 */
                cache_y = GSptr->position.y;

                //UPD058
                cache_y_ii = (fix)(GSptr->position.y+.5);
        }
        bb_yorig = cache_y_ii - cache_info->ref_y;

set_bb:
        bb_width = cache_info->box_w;
        bb_heigh = cache_info->box_h;
        bb_uy = bb_yorig + bb_heigh - 1;        /* 8/11/89 */

#ifdef DBG1
        printf(" fill_shape(F_FROM_CACHE): current point=(%f, %f)\n",
                 GSptr->position.x, GSptr->position.y);
        printf(" cache_info: ref_x=%d ref_y=%d\n", cache_info->ref_x,
                cache_info->ref_y);
        printf(" bb_xorig=%d,", bb_xorig);
        printf(" bb_yorig=%d, bb_width=%d, bb_heigh=%d\n", bb_yorig,
                 bb_width, bb_heigh);
        dump_all_clip();
#endif

        /* check if cache bitmap totally inside clipping region 12/4/87 */
        if ((GSptr->clip_path.single_rect) &&           /* 12/7/87 */
            (bb_xorig >= SFX2I_T(GSptr->clip_path.bb_lx)) &&
            (bb_yorig >= SFX2I_T(GSptr->clip_path.bb_ly)) &&
            ((bb_xorig + bb_width) <= SFX2I_T(GSptr->clip_path.bb_ux)) &&
            ((bb_yorig + bb_heigh) <= SFX2I_T(GSptr->clip_path.bb_uy))) {
                /* fill page buffer with cache image directly */
                draw_cache_page ((fix32)bb_xorig, (fix32)bb_yorig, /*@WIN*/
                    (ufix32)bb_width, (ufix32)bb_heigh, cache_info->bitmap);
                break;
        }


        init_cache_page (bb_xorig, bb_yorig, bb_width, bb_heigh,
                         cache_info->bitmap);

        /* STEP 2 : generate mask of clipping path */

        /* set fill_destination for generating clip mask */
        save = fill_destination;
        fill_destination = F_TO_CLIP;

        for (icp = GSptr->clip_path.head; icp != NULLP;
            icp = cp->next) {
            sfix_t   bb_uy8, bb_yorig8;          /* bb_ * 8  @PRE_CLIP */
            struct tpzd tpzd;

            cp = &node_table[icp];

            bb_uy8 = I2SFX(bb_uy);               /* bb_uy << 3; @PRE_CLIP */
            bb_yorig8 = I2SFX(bb_yorig);         /* bb_yorig << 3 */

            /* clip trapezoid outside bounding box */
            if ((cp->CP_TOPY > bb_uy8) ||
                (cp->CP_BTMY < bb_yorig8)) continue;
#ifdef DBG1
            printf("fill_shape(): clip mask gen. clip_trapez=\n");
            printf("(%f, %f, %f), (%f, %f, %f)\n",
                    cp->CP_TOPY/8.0, cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0,
                    cp->CP_BTMY/8.0, cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

            tpzd.topy  = cp->CP_TOPY;
            tpzd.topxl = cp->CP_TOPXL;
            tpzd.topxr = cp->CP_TOPXR;
            tpzd.btmy  = cp->CP_BTMY;
            tpzd.btmxl = cp->CP_BTMXL;
            tpzd.btmxr = cp->CP_BTMXR;

            /*
             * modify clip trapezoid
             */
            /* for bottom line */
            if (cp->CP_BTMY > bb_uy8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_uy8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.btmxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.btmxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.btmy = bb_uy8;
            }

            /* for top line */
            if (cp->CP_TOPY < bb_yorig8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_yorig8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.topxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.topxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif FORMAT_16_16
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif FORMAT_28_4
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.topy = bb_yorig8;
            }

            save_tpzd(&tpzd);

        } /* for cp */

        /* restore fill_destination */
        fill_destination = save;

        /* STEP 3 : fill page buffer with cache image */
        fill_cache_page ();
        break;

    /* ++++++++++++ @Y.C. BEGIN +++++++++++++++++++++++++++++++++++++++++++ */
    case F_FROM_IMAGE :     /* from cache to page  @IMAGE 01-16-89 */
        fill_destination = dest;        /* 12/27/88 */

        /* STEP 1 : clear clipping bitmap */
        /* get bounding box information on page */      /* 12/27/88 */
        bb_xorig = image_info.bb_lx;
        bb_yorig = image_info.bb_ly;
        bb_width = image_info.bb_xw;
        bb_heigh = image_info.bb_yh;

        bb_uy = bb_yorig + bb_heigh;

#ifdef DBG1
        printf(" fill_shape(F_FROM_IMAGE)\n");
        printf(" bb_xorig=%d, bb_yorig=%d, bb_width=%d, bb_heigh=%d\n",
                 bb_xorig, bb_yorig, bb_width, bb_heigh);
        dump_all_clip();
#endif
#ifdef DBG9
        printf(" fill_shape(F_FROM_IMAGE)\n");
        printf(" bb_xorig=%d, bb_yorig=%d, bb_width=%d, bb_heigh=%d\n",
                 bb_xorig, bb_yorig, bb_width, bb_heigh);
#endif

        init_image_page (bb_xorig, bb_yorig, bb_width, bb_heigh);

        /* STEP 2 : generate mask of clipping path */

        for (icp = GSptr->clip_path.head; icp != NULLP;
            icp = cp->next) {
            sfix_t   bb_uy8, bb_yorig8;          /* bb_ * 8  @PRE_CLIP */
            struct tpzd tpzd;

            cp = &node_table[icp];

            bb_uy8 = I2SFX(bb_uy);               /* bb_uy << 3; @PRE_CLIP */
            bb_yorig8 = I2SFX(bb_yorig);         /* bb_yorig << 3 */

            /* clip trapezoid outside bounding box */
            if ((cp->CP_TOPY > bb_uy8) ||
                (cp->CP_BTMY < bb_yorig8)) continue;
#ifdef DBG1
            printf("fill_shape(): clip mask gen. clip_trapez=\n");
            printf("(%f, %f, %f), (%f, %f, %f)\n",
                    cp->CP_TOPY/8.0, cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0,
                    cp->CP_BTMY/8.0, cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

            tpzd.topy  = cp->CP_TOPY;
            tpzd.topxl = cp->CP_TOPXL;
            tpzd.topxr = cp->CP_TOPXR;
            tpzd.btmy  = cp->CP_BTMY;
            tpzd.btmxl = cp->CP_BTMXL;
            tpzd.btmxr = cp->CP_BTMXR;

            /*
             * modify clip trapezoid
             */
            /* for bottom line */
            if (cp->CP_BTMY > bb_uy8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_uy8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.btmxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.btmxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.btmy = bb_uy8;
            }

            /* for top line */
            if (cp->CP_TOPY < bb_yorig8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_yorig8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.topxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.topxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.topy = bb_yorig8;
            }

            save_tpzd(&tpzd);

        } /* for cp */
        break;
    /* ++++++++++++ @Y.C. END +++++++++++++++++++++++++++++++++++++++++++++ */

    default :
            printf("\07Fatal error, fill_type");
    } /* switch */
}

extern void path_to_outline_q ();       /* stroke enhancement  -jwm, 3/18/91 */

/***********************************************************************
 * This routine provides an interface to stroke the current path.
 *
 * TITLE:       stroke_shape
 *
 * CALL:        stroke_shape (dest)
 *
 * PARAMETERS:
 *              dest -- F_TO_PAGE: stroke to page
 *                      F_TO_CACHE: stroke to cache
 *
 * INTERFACE:   op_stroke, font machineary
 *
 * CALLS:       traverse_path, path_to_outline, init_stroke,
 *              set_inverse_ctm, op_newpath, free_node
 *
 * RETURN:
 *
 **********************************************************************/
void stroke_shape (dest)
ufix    dest;
{
        real32    bbox[4];              /* @STK_INT */
        /* struct   nd_hdr *sp; @NODE */
        ufix     stroke_type;

        /* initialization of stroke parameters */
        init_stroke();          /* @EHS_STK 1/29/88 */

        if (ANY_ERROR()) {      /* return if any error 1/26/89 */
                /* When 0 scale at x and y direction will cause error at the
                 * inverse matrix calculation, we can not let this error showing
                 * at the screen(it is not an error at NTX). We just clear error
                 * ,traverse_path, and return. phchen 03/26/91. ref. Matrix1.ps */
                CLEAR_ERROR();
                traverse_path (path_to_outline_t, (fix FAR *)TRUE);
                end_stroke();
                return;
        }

        fill_destination = dest;

        /*
         * Check conditions for applying appropriate stroking routines:
         * Conditions:
         *      1: linejoin points inside
         *         [PAGE_LEFT, PAGE_TOP] and [PAGE_RIGHT, PAGE_BTM]@RESO_UPGR
         *      2: inside single clip path
         *      3: CTM criteria         @RESO_UPGR
         *               1. |a| == |d|
         *               2. |b| == |c|
         *               3. |a| < 8   and   |b| < 8  <------ wrong
         *               3. |a| <[=] CTM_LIMIT and |b| <[=] CTM_LIMIT
         *                  See graphics.h for the details
         *      4: linewidth < 1 pixel
         *
         * Stroke_type:
         * 1) FLOAT_STROKE -- worse case, using floating point arith.
         * 2) THIN_STROKE  -- thin line width stroke
         *                    condition: 1, 2, 4
         * 3) INTEGER_STROKE_IN_CLIP -- integer stroke & inside single clip
         *                    condition: 1, 2, 3
         * 4) INTEGER_STROKE_OV_CLIP -- integer stroke & not inside single clip
         *                    condition: 1, 3
         */

        /* initialization */
/*      (* get the first MOVETO coordinate as initial value 5/19/88 *)
 *      path = &path_table[GSptr->path];
 *      while (path->head == NULLP) {
 *              path = &path_table[path->previous];
 *      }
 *      (* @NODE
 *       * sp = &node_table[path->head];
 *       * vtx = &node_table[sp->SP_HEAD];
 *       *)
 *      vtx = &node_table[path->head];
 *
 *      bbox[0] = vtx->VERTEX_X;  (* min_x *)
 *      bbox[2] = vtx->VERTEX_X;  (* max_x *)
 *      bbox[1] = vtx->VERTEX_Y;  (* min_y *)
 *      bbox[3] = vtx->VERTEX_Y;  (* max_y *)
 */
        /* set current point as initial value @CPPH; 12/12/90 */
        bbox[0] = bbox[2] = GSptr->position.x;  /* min_x, max_x */
        bbox[1] = bbox[3] = GSptr->position.y;  /* min_y, max_y */

        /* find bounding box of current path */
// DJC        traverse_path (bounding_box, (fix FAR *)bbox);
        traverse_path ((TRAVERSE_PATH_ARG1)(bounding_box), (fix FAR *)bbox);

        /* add with max expanding length of miter join */
        expand_stroke_box (bbox);

        /*
         * Condition 1: linejoin points inside SFX boundary
         */
        /* check if outside the page boundary */
        if (too_small(F2L(bbox[0])) ||
            too_small(F2L(bbox[1])) ||
            too_large(F2L(bbox[2])) ||
            too_large(F2L(bbox[3]))) {
            /* Normal floating stroking */
            stroke_type = FLOAT_STROKE;

        } else {
            /*
             * Condition 2: inside single clip path
             */
            if ((GSptr->clip_path.single_rect) &&
                (F2SFX(bbox[0]) >= GSptr->clip_path.bb_lx) &&
                (F2SFX(bbox[1]) >= GSptr->clip_path.bb_ly) &&
                (F2SFX(bbox[2]) <= GSptr->clip_path.bb_ux) &&
                (F2SFX(bbox[3]) <= GSptr->clip_path.bb_uy)) {

                /*
                 * Condition 4: linewidth < 1 pixel
                 */
                if (is_thinstroke()) {
                    stroke_type = THIN_STROKE;
                } else {
                    /*
                     * Condition 3: CTM criteria
                     */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) <= CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) <= CTM_LIMIT))
#elif  FORMAT_16_16
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#elif  FORMAT_28_4
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#endif
                        stroke_type = INTEGER_STROKE_IN_CLIP;
                    else
                        stroke_type = FLOAT_STROKE;

                } /* condition 4: thin stroke */

            } else { /* not single rectangle clip */
                    /*
                     * Condition 3: CTM criteria
                     */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) <= CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) <= CTM_LIMIT))
#elif  FORMAT_16_16
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#elif  FORMAT_28_4
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#endif
                        stroke_type = INTEGER_STROKE_OV_CLIP;
                    else
                        stroke_type = FLOAT_STROKE;
            } /* condition 2: single_rect */

        } /* condition 1: outside page */

        /* perform corresponding stroking routine */
        switch (stroke_type) {

        case FLOAT_STROKE:
                traverse_path (path_to_outline, (fix FAR *)TRUE);
                break;
        case THIN_STROKE:
                traverse_path (path_to_outline_t, (fix FAR *)TRUE);
                break;
        case INTEGER_STROKE_IN_CLIP:
/*              if ((GSptr->dash_pattern.pat_size == 0) && (fill_destination == F_TO_PAGE))
 *                  traverse_path (path_to_outline_q, (fix *)TRUE);  (* jwm, 3/18/91 *)
 *              else  (* quality has trouble,MPOST003; deleted by scchen 3/29/91 *)
 */
                    traverse_path (path_to_outline_i, (fix FAR *)TRUE);
                break;                          /* TRUE: inside clip region */
        case INTEGER_STROKE_OV_CLIP:
                traverse_path (path_to_outline_i, (fix FAR *)FALSE);
                break;                      /* FALSE: not inside clip region */
        }

        /* clear current path if stroke successful */
        if( ANY_ERROR() != LIMITCHECK ) op_newpath();

        /* restore cache_info which was set at init_stroke @CIR_CACHE */
        end_stroke();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* --------------------------------------------------------------------
 * File : fillgr.c
 *
 * Programmed by: M.S Lin
 * Date: 10-19-1988
 *
 * Purpose: Provided routines for Graphics Command Buffer(GCB)
 *
 * Modification History:
 *          check_print() defined in fillgp.c
 * 07/29/89 cg - Unix port changes
 * Peter 09/12/90 change check_print() to GEIeng_checkcomplete() for ICI.
#ifdef WIN
 *  Ada             03/15/91    op_setpattern() and op_patfill()
 *                  execute_gcb() to process PFILL_PTZD and CHANGE_PF_PATTERN
 *  Ada             03/20/91    change op_patfill() to include backgroup drawing
 *  Ada             03/21/91    make WHITE REP to call normal fill
 *                            if Foregroup = Backgroup, do the normal fill only
 *  Ada             04/18/91    update pattern in LANSACOPE and adopted
 *                              for new driver files billmcc sent
 *  Ada             05/02/91  update the repeat pattern in LANDSCAPE
 *  Ada             05/15/91  solve pattern fill in contious printing
 *                            execute_gcb()  case CHANGE_PF_PATTERN:
 #endif
 *                  11/23/91  upgrade for higher resolution @RESO_UPGR
 * ---------------------------------------------------------------------
 */


// DJC added global include
#include "psglobal.h"


#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "font.h"
#include               "fillproc.h"
#include               "fillproc.ext"
#include               "stdio.h"      /* to define printf() @WIN */

/* @WIN; add prototype */
fix GEIeng_checkcomplete(void);
fix fb_busy(void);

#ifdef WIN
#include               <string.h>
#include               "pfill.h"

/*************************************************************************
 * SYNTAX:      pattern setpattern -
 *
 * TITLE:       op_setpattern
 *
 * CALL:        op_setpattern()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setpattern)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 *************************************************************************/
fix
op_setpattern()
{
    ubyte FAR *pattern;
    fix    ii;
    ufix32 FAR *pf_addr = (ufix32 FAR *) PF_BASE;
    ufix32  pat;
    ULONG_PTR *old_ptr;
    fix     jj, mask, rot_byte;

    if (LENGTH_OPERAND(0) != 8) {
        ERROR(RANGECHECK);
        return(0);
    }
#ifdef DBG_PFILL
    printf("CTM = %f %f %f %f]\n", GSptr->ctm[0], GSptr->ctm[1],
            GSptr->ctm[2], GSptr->ctm[3]);
#endif
    pattern = (ubyte FAR *) (VALUE_OPERAND(0));

    /* to check if LANDSCOPE or PORTRAIT */
    if (GSptr->ctm[0] >= TOLERANCE) {
        /*  Generate the fill pattern:
         *  if pattern[0] = 01011100 then bitmap 32*16 will be
         * HSB            LSB
         *  +----------------+----------------+
         *  |1100110000001111|    the same    |
         *  |1100110000001111|    the same    |
         *  +----------------+----------------+
         *  |  pattern[1]    |                |
         *  |     :          |                |
         *  |     :          |                |
         *  |  pattern[7]    |                |
         *  +----------------+----------------+
         */
        for (ii = 0; ii < 8; ii++) {
#ifdef DBG_PFILL
            printf(" %x ==> %x\n", (fix) pattern[ii], (fix)
                   pf_cell[pattern[ii]]);
#endif
#ifdef DJC  // take this code out UDP027
            pat = (((ufix32) pf_cell[pattern[ii]]) << 16) |
                            pf_cell[pattern[ii]];
            *pf_addr++ = pat;
            *pf_addr++ = pat;
#endif
            //DJC fix from history.log UPD027
            pat =  ((ufix32) pattern[ii]) << 24 |
                   ((ufix32) pattern[ii]) << 16 |
                   ((ufix32) pattern[ii]) <<  8 |
                   ((ufix32) pattern[ii]);
            pat = ~pat;
            *pf_addr = pat;
            *(pf_addr+8) = pat;
            pf_addr++;

            //DJC end fix for UPD027




        } /* end for */
    } else {
        /* if in case of LANDSCAPE */
        /*  Generate the fill pattern:
         *  if pattern[0] = 01011100 then bitmap 32*16 will be
         *                                       Ywin  <---+
         *      +--+--+--+--+--+--+--+--+----------------+ |
         * HSB  |p |  |  |  |  |  |  |11|  the same      | v
         *      |a |  |  |  |  |  |  |11|                | Xwin
         *      |t |  |  |  |  |  |  |00|                |
         *      |t |  |  |  |  |  |  |00|                |
         *      |e |  |  |  |  |  |  |11|                |
         *      |r |  |  |  |  |  |  |11|                |
         *      |n |  |  |  |  |  |  |00|                |
         *      |^ |  |  |  |  |  |  |00|                |
         *      |7 |  |  |  |  |  |  |00|                |
         *      |v |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |00|                |
         *      |  |  |  |  |  |  |  |11|                |
         *      |  |  |  |  |  |  |  |11|                |
         *      |  |  |  |  |  |  |  |11|                |
         * LSB  |  |  |  |  |  |  |  |11|                |
         *      +--+--+--+--+--+--+--+--+----------------+
         */
        for (ii = 0, mask = 0x80; ii < 8; ii++, mask >>= 1) {
            for (jj = 7, rot_byte = 0; jj >= 0; jj--) {
                rot_byte <<= 1;
                rot_byte |= pattern[jj] & mask;
            }
            rot_byte >>= (7 - ii);
#ifdef DBG_PFILL
            printf("rot_byte = %x\n", rot_byte);
#endif
//DJC fix from history.log UPD027
/*          Take out the mapping from 1 bit to 2*2 bits; @WIN
 *          pat = (((ufix32) pf_cell[rot_byte]) << 16) |
 *                          pf_cell[rot_byte];
 *          *pf_addr++ = pat;
 *          *pf_addr++ = pat;
 */
            pat =  ((ufix32) rot_byte) << 24 |
                   ((ufix32) rot_byte) << 16 |
                   ((ufix32) rot_byte) <<  8 |
                   ((ufix32) rot_byte);
            pat = ~pat;
            *pf_addr = pat;
            *(pf_addr+8) = pat;
            pf_addr++;

//DJC end fix UPD027


        }
    } /* end else */

#ifdef DBG_PFILL
    printf("pfill pattern = ");
    for (ii = 0; ii < 16; ii++)
        printf("%8lx ", PF_BASE[ii]);
    printf("\n");
#endif

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = CHANGE_PF_PATTERN;
            /* put pattern into gcb */
            lmemcpy((ufix8 FAR *)gcb_ptr, (ufix8 FAR *)PF_BASE, PF_BSIZE << 2);/*@WIN*/
            gcb_ptr += PF_BSIZE;
            *old_ptr = (ULONG_PTR)gcb_ptr;
        }
    }

    POP(1);
    return(0);
}

/*************************************************************************
 * SYNTAX:      Bred Bgreen Bblue  Fred Fgreen Fblue ftype patfill -
 *
 * TITLE:       op_patfill
 *
 * CALL:        op_patfill()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_patfill)
 *
 * CALLS:       setrgbcolor, fill_shape
 *
 * RETURN:      none
 *
 *************************************************************************/
fix     pfill_flag = PF_NON;
fix
op_patfill()
{
    fix     pfill_flag_save;
    fix     ftype;
    real32      fred, fgreen, fblue, bred, bgreen, bblue;

    /* Ignore it if no currentpoints */
    if (F2L(GSptr->position.x) == NOCURPNT) return(0);

    ftype = (fix) VALUE_OPERAND(0);
    GET_OBJ_VALUE(fblue, GET_OPERAND(1));
    GET_OBJ_VALUE(fgreen, GET_OPERAND(2));
    GET_OBJ_VALUE(fred, GET_OPERAND(3));
    GET_OBJ_VALUE(bblue, GET_OPERAND(4));
    GET_OBJ_VALUE(bgreen, GET_OPERAND(5));
    GET_OBJ_VALUE(bred, GET_OPERAND(6));

    if (ftype != 0 && ftype != 1) {
        ERROR(RANGECHECK);
        return(0);
    }

#ifdef DBGpfill
    {
        fix ii;
        printf("pfill pattern = ");
        for (ii = 0; ii < 16; ii++)
            printf("%8lx ", PF_BASE[ii]);
        printf("\n");
    }
#endif

    pfill_flag_save = pfill_flag;
    setrgbcolor(F2L(bred), F2L(bgreen), F2L(bblue)); /* set backgroup color */
    if (HTP_Type == HT_WHITE) {
#ifdef DBGpfill
        printf("PFILL with WHITE backgroup -- PFILL(REP)\n");
#endif
        setrgbcolor(F2L(fred), F2L(fgreen), F2L(fblue)); /* set foregroup color */
        if (HTP_Type == HT_WHITE)
            /* Ada 3/21/91 to call normal fill */
            pfill_flag = PF_NON;
        else
            /* pfill the area REPLACE the framebuffer */
            pfill_flag = PF_REP;
        fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
    }
    else /* HT_MIXED or HT_BLOCK */ {
        real32  gray;
#ifdef DBGpfill
        printf("PFILL with nonBLACK backgroup");
#endif
        gray = GSptr->color.gray;
        /* fill/eofill the area  */
        op_gsave();     /* save the currentpath */
        pfill_flag = PF_NON;
        fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
        op_grestore();
#ifdef DBGpfill
        printf(" -- PFILL(OR)\n");
        /* op_copypage(); */
#endif
        setrgbcolor(F2L(fred), F2L(fgreen), F2L(fblue)); /* set foregroup color */
        if (gray == GSptr->color.gray)
            op_newpath();
        else {
            /* pfill the area OR the framebuffer */
            pfill_flag = PF_OR;
            fill_shape(ftype == 0 ? NON_ZERO : EVEN_ODD, F_NORMAL, F_TO_PAGE);
        }
    }
    pfill_flag = pfill_flag_save;

    POP(7);
    return(0);
}
#endif

/* ******** GCB (Graphics Command Buffer) **************************** */

/* --------------------------------------------------------------------
 * execute_gcb(): execute all of the graphics low level commands on
 *                GCB
 *
 * Called by: flush_gcb
 * --------------------------------------------------------------------*/
void    execute_gcb()
{
  ufix32   FAR *ptr, FAR *next_ptr;                     /* @WIN */
  ULONG_PTR   par1, par2, par3, par4, par5;          /* @WIN */
  struct Char_Tbl       FAR *cptr1, FAR *cptr2;
  struct tpzd_info      FAR *tpzdinfo_ptr;
  struct tpzd           FAR *tpzd_ptr;
  struct coord_i        FAR *coord_ptr;             /* jwm, 3/18 */
#ifdef WIN
  extern ufix32         PF_BASE[];
  extern fix            pfill_flag;
#endif

#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif FORMAT_16_16
           sfix_t par3_sf, par4_sf, par5_sf, par6_sf;
           sfix_t temp;
#elif  FORMAT_28_4
           sfix_t par3_sf, par4_sf, par5_sf, par6_sf;
           sfix_t temp;
#endif

#ifdef DBGgcb
  printf("execute_gcb(): %ld, %lx\n", GCB_count, gcb_ptr);
#endif

  ptr = (ufix32 FAR *)GCB_BASE;                 /* @WIN */
  while(GCB_count--) {
#ifdef DBGgcb
  printf("       %lx", ptr);
#endif
#ifndef _WIN64
    next_ptr = (ufix32 FAR *)*ptr++;            /* @WIN */
#else
    next_ptr = NULL;
#endif
#ifdef DBGgcb
  printf(" ,%lx\n", *ptr);
#endif
    switch(*ptr++) {

        case RESET_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           reset_page((fix)par1, (fix)par2, (fix)*ptr);
           break;

        case ERASE_PAGE:
           /* Integrate the changes made by YM at 6-21-91 @HSIC */
           par1 = HTP_Type;
           HTP_Type = (fix)*ptr++;      //@WIN
           /* End of Integration */

           erase_page();

           /* Integrate the changes made by YM at 6-21-91 @HSIC */
           HTP_Type = (fix)par1;        //@WIN
           /* End of Integration */
           break;

#ifdef WIN
        case CHANGE_PF_PATTERN:
            lmemcpy((ufix8 FAR *)PF_BASE, (ufix8 FAR *)ptr, PF_BSIZE << 2);/*@WIN*/
            break;

        case PFILL_TPZD:
        {
            fix     pfill_flag_save;
            pfill_flag_save = pfill_flag;

            pfill_flag = (fix) *ptr++;
            image_info.seed_index = (fix16 )*ptr++;         /*MS 10-20-88 */
            par1 = *ptr++;
            tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
            tpzd_ptr = (struct tpzd FAR *)(tpzdinfo_ptr + 1);
            fill_tpzd((ufix)par1, tpzdinfo_ptr, tpzd_ptr);

            pfill_flag = pfill_flag_save;
            break;
        }
#endif

        case FILL_TPZD:
           image_info.seed_index = (fix16 )*ptr++;         /*MS 10-20-88 */
           par1 = *ptr++;
           tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
           tpzd_ptr = (struct tpzd FAR *)(tpzdinfo_ptr + 1);
           fill_tpzd((ufix)par1, tpzdinfo_ptr, tpzd_ptr);
           break;

        case FILL_LINE:   /* 1-18-89 */
           par1 = *ptr++;
           tpzdinfo_ptr = (struct tpzd_info FAR *)ptr;
           ptr = (ufix32 FAR *)(tpzdinfo_ptr + 1);
#ifdef FORMAT_13_3 /* @RESO_UPGR */
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
//         fill_line((ufix )par1, tpzdinfo_ptr, par3, par4, par5, *ptr); @WIN
           fill_line((ufix )par1, tpzdinfo_ptr, (sfix_t)par3, (sfix_t)par4, (sfix_t)par5, (sfix_t)*ptr);
#elif FORMAT_16_16
           temp = *ptr++;
           par3_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par4_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par5_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par6_sf = (temp << 16) | *ptr;
           fill_line((ufix )par1, tpzdinfo_ptr, par3_sf, par4_sf, par5_sf, par6_sf);
#elif  FORMAT_28_4
           temp = *ptr++;
           par3_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par4_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par5_sf = (temp << 16) | *ptr++;
           temp = *ptr++;
           par6_sf = (temp << 16) | *ptr;
           fill_line((ufix )par1, tpzdinfo_ptr, par3_sf, par4_sf, par5_sf, par6_sf);
#endif
           break;

        case FILL_SCAN_PAGE:    /* 10-07-88 */
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           fill_scan_page((fix)par1, (fix)par2, (fix)par3, (fix)par4,
                            (SCANLINE FAR *)ptr);
           break;

        case FILL_PIXEL_PAGE:
           par1 = *ptr++;
           fill_pixel_page((fix)par1, (PIXELIST FAR *)ptr);
           break;

        case INIT_CHAR_CACHE:
           init_char_cache((struct Char_Tbl FAR *)ptr);
           break;

        case COPY_CHAR_CACHE:
           cptr1 = (struct Char_Tbl FAR *)ptr;
           cptr2 = cptr1 + 1;
           ptr = (ufix32 FAR *)(cptr2 + 1);
           par3 = *ptr++;
           copy_char_cache((struct Char_Tbl FAR *)cptr1,
                           (struct Char_Tbl FAR *)cptr2, (fix)par3, (fix)*ptr);
           break;

        case FILL_SCAN_CACHE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
           fill_scan_cache((gmaddr)par1, (fix)par2, (fix)par3, (fix)par4, (fix)par5,
                           (SCANLINE FAR *)ptr);
           break;

        case FILL_PIXEL_CACHE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           fill_pixel_cache((gmaddr)par1, (fix)par2, (fix)par3, (fix)par4,
                            (PIXELIST FAR *)ptr);
           break;

        case INIT_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           init_cache_page((fix)par1, (fix)par2, (fix)par3, (fix)par4, (gmaddr)*ptr);
           break;

        case CLIP_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           clip_cache_page((fix)par1, (fix)par2, (SCANLINE FAR *)ptr);
           break;

        case FILL_CACHE_PAGE:
           fill_cache_page();
           break;

        case DRAW_CACHE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           draw_cache_page((fix32)par1, (fix32)par2, (ufix32)par3,
                        (ufix32)par4, (gmaddr)*ptr);    /*@WIN 04-15-92*/
           break;

        case FILL_SEED_PATT:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           par5 = *ptr++;
           fill_seed_patt((fix)par1, (fix)par2, (fix)par3, (fix)par4, (fix)par5, (SCANLINE FAR *)ptr);
           break;

        case CHANGE_HALFTONE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           par4 = *ptr++;
           change_halftone((ufix32 FAR *)par1, (gmaddr)par2, (fix)par3, (fix)par4, (fix)*ptr);
                                                      /* ufix => ufix32 @WIN */
           break;

        case MOVE_CHAR_CACHE:
           cptr1 = (struct Char_Tbl FAR *)ptr;
           cptr2 = cptr1 + 1;
           move_char_cache(cptr1,cptr2);
           break;

        case INIT_IMAGE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           par3 = *ptr++;
           init_image_page((fix)par1, (fix)par2, (fix)par3, (fix)*ptr);
           break;

        case CLIP_IMAGE_PAGE:
           par1 = *ptr++;
           par2 = *ptr++;
           clip_image_page((fix)par1, (fix)par2, (SCANLINE FAR *)(ptr));
           break;

        /* jwm, 3/18/91, -begin- */
        case FILL_BOX:
            par1 = (ULONG_PTR) ptr;        /* @WIN */
            coord_ptr = (struct coord_i FAR *) ptr;
            par2 = (ULONG_PTR) (++coord_ptr);      /* @WIN */
            do_fill_box((struct coord_i FAR *)par1, (struct coord_i FAR *)par2);
            break;

        case FILL_RECT:
            par1 = (ULONG_PTR) ptr;        /* @WIN */
            do_fill_rect((struct line_seg_i FAR *)par1);
            break;
        /* jwm, 3/18/91, -end- */

        default:
           printf("\07GCB error !\n");
           break;

    } /* switch */
    ptr = next_ptr;

  } /* while */
  return;
} /* execute_gcb */

/* --------------------------------------------------------------------
 * flush_gcb: flush GCB commands
 *
 * Called by: alloc_gcb on GCB full or *GCB_flush == TRUE
 * --------------------------------------------------------------------*/
void flush_gcb(check_flag)
fix     check_flag;
{
#ifdef DBGgcb
   printf("flush_gcb(): %ld, %lx\n", GCB_count, gcb_ptr);
#endif

  if(check_flag){
     /* wait until Frame Buffer availabel */
/*   while(check_print())       @GEI */
     while(GEIeng_checkcomplete())
        ;
  }
  if(GCB_count > 0) {

    GCB_flush = TRUE;
    execute_gcb();
  }
  GCB_flush = FALSE;
  GCB_count = 0;
  gcb_ptr = (ULONG_PTR *)GCB_BASE;                     /* @WIN */

  return;
} /* flush_gcb */

/* --------------------------------------------------------------------
 * alloc_gcb(): check GCB available size
 *
 * Parameter: alloc_size -- expected size.
 *
 * Return(NIL)     -- when GCB full
 *       (gcb_ptr) -- when size availabe
 * --------------------------------------------------------------------*/
fix     FAR *alloc_gcb(alloc_size)
fix     alloc_size;
{
#ifdef DBGgcb
   printf("alloc_gcb(): %lx\n", gcb_ptr);
#endif

   if(!fb_busy())
        return(NIL);

   if( (GCB_BASE + GCB_SIZE - (ULONG_PTR)gcb_ptr) < (ULONG_PTR)alloc_size){   /* @WIN */
#ifdef DBGgcb
           printf("GCB full: %lx\n", gcb_ptr);
#endif

           flush_gcb(TRUE);
           return(NIL);
   }
   GCB_count++;
   return((fix FAR *)gcb_ptr);          /* @WIN */

} /* alloc_gcb */


/* --------------------------------------------------------------------
 * put_scanline(): put scanline list into GCB
 *
 * Parameter
 *    no_lines -- no. of scanline
 *    scanline -- scanline list
 *
 * --------------------------------------------------------------------*/
void  put_scanline(no_lines, scanline)
fix             no_lines;
SCANLINE        FAR *scanline;
{
   SCANLINE     FAR *ptr, FAR *scan;

#ifdef DBGgcb
   printf("put_scanline(): %lx\n", gcb_ptr);
/*   get_scanlist(0L, no_lines, scanline);*/
#endif

   scan = scanline;
   ptr = (SCANLINE FAR *)gcb_ptr;
   while(no_lines--) {
      while((*ptr++ = *scan++) != (SCANLINE )END_OF_SCANLINE)
        *ptr++ = *scan++;
   }
#ifdef DBGgcb
   printf("\thoriz. line\n");
#endif

   /* horizontal lines */
   while((*ptr++ = *scan++) != (SCANLINE )END_OF_SCANLINE){
        *ptr++ = *scan++;
        *ptr++ = *scan++;
   }

  gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)ptr + 3) & 0xFFFFFFFCL ); /* 4 byte allignment @WIN*/
   return;
} /* put_scanline */


/* --------------------------------------------------------------------
 * put_pixelist(): put pixelist into GCB
 *
 * Parameter
 *    no_pixel -- no. of pixel
 *    pixelist -- pixelist
 *
 * --------------------------------------------------------------------*/
void    put_pixelist(no_pixel, pixelist)
fix             no_pixel;
PIXELIST        FAR *pixelist;
{
   PIXELIST     FAR *ptr, FAR *pixel;

#ifdef DBGgcb
   printf("put_pixelist(): %lx\n", gcb_ptr);
#endif

   pixel = pixelist;
   ptr = (PIXELIST FAR *)gcb_ptr;
   while(no_pixel--) {
      *ptr++ = *pixel++;
      *ptr++ = *pixel++;
   }
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)ptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
   return;
}

/* --------------------------------------------------------------------
 * put_Char_Tbl(): put Char_tbl structure into GCB
 *
 * Parameter
 *   dcc_info: pointer to Char_Tbl structure
 * --------------------------------------------------------------------*/

void        put_Char_Tbl(dcc_info)
struct      Char_Tbl    FAR *dcc_info;
{
   struct Char_Tbl      FAR *cptr;

#ifdef DBGgcb
   printf("put_Char_Tbl: %lx\n", gcb_ptr);
#endif
   cptr = (struct Char_Tbl FAR *)gcb_ptr;
   *cptr++ = *dcc_info;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}


/* -------------------------------------------------------------------------
 *      put_tpzd_info(p1, p2): put tpzd_info structure to GCB
 *
 * ------------------------------------------------------------------------- */
void    put_tpzd_info(ptr)
struct  tpzd_info       FAR *ptr;
{
        struct  tpzd_info       FAR *cptr;


#ifdef DBGgcb
   printf("put_tpzd_info: %lx\n", gcb_ptr);
#endif
   cptr = (struct tpzd_info FAR *)gcb_ptr;
   *cptr++ = *ptr;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}


/* -------------------------------------------------------------------------
 *      put_tpzd(p1, p2): put tpzd structure to GCB
 *
 * ------------------------------------------------------------------------- */
void    put_tpzd(ptr)
struct  tpzd       FAR *ptr;
{
        struct  tpzd       FAR *cptr;


#ifdef DBGgcb
   printf("put_tpzd: %lx\n", gcb_ptr);
#endif
   cptr = (struct tpzd FAR *)gcb_ptr;
   *cptr++ = *ptr;
   gcb_ptr = (ULONG_PTR *)( ((ULONG_PTR)cptr + 3) & 0xFFFFFFFCL); /* 4 byte allignment @WIN*/
#ifdef DBGgcb
   printf("%lx..>\n", gcb_ptr);
#endif

   return;
}
//DJC we will always return false
fix fb_busy()
{
   return(FALSE);
}
#ifdef XXX
/* @WIN ??? */
/* -------------------------------------------------------------------------
 *      FB_busy(): return TRUE if Frame buffer busy.
 *                 return FALSE if Frame buffer ready.
 * -------------------------------------------------------------------------*/
fix     fb_busy()
{
/*      if(check_print())               @GEI */
        if(GEIeng_checkcomplete())
           return(TRUE);
        if(GCB_count && !GCB_flush)
           flush_gcb(FALSE);
        FB_busy = FALSE;
        return(FALSE);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\fillproc.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************************
 *
 *      Name:       fillproc.h
 *
 *      Purpose:    Header files of graphics machinery, for definitions of
 *                  data types, data structures, constants, and macros.
 *
 *      Developer:  Y.C. Chen
 *      Modified By: D.S Tseng for INTEL 80960 board
 *
 *      History:
 *              5/23/91 mslin   Add Macro   ONE8000
 *                                          LSHIFTEQ
 *                                          RSHIFTEQ
 *
 **************************************************************************/

#define HT_WHITE        0x00            /* HTP all white                */
#define HT_MIXED        0x07            /* HTP mixed or colored         */
#define HT_BLACK        0xFF            /* HTP all black                */
#define HT_CHANGED      0x00            /* halftone pattern being changed  */
#define HT_UPDATED      0xFF            /* halftone pattern being updated  */

/*      Macro definitions of important parameters of bitmaps               */
#define FB_ADDR            (FBX_Bmap.bm_addr)
#define FB_WIDTH           (FBX_Bmap.bm_cols)
#define FB_HEIGH           (FBX_Bmap.bm_rows)
#define FB_PLANE           (FBX_Bmap.bm_bpp)
#define HT_WIDTH           (HTB_Bmap.bm_cols)
#define HT_HEIGH           (HTB_Bmap.bm_rows)
#define HT_PLANE           (HTB_Bmap.bm_bpp)


struct  PT_Entry        /* PageType structure                           */
{
    fix                 FB_Width;       /* width. of frame buffer       */
    fix                 FB_Heigh;       /* height of frame buffer       */
    fix                 PT_Width;       /* width. of paper tray         */
    fix                 PT_Heigh;       /* height of paper tray         */
    fix                 PM_Width;       /* width. of page margin (left) */
    fix                 PM_Heigh;       /* height of page margin (top.) */
};

struct  bitmap          /* Bitmap Structure
                                           all graphics primitives which
                                           operates on bitmap should
                                           recognize bitmap structure   */
{
    gmaddr              bm_addr;        /* base address of bitmap       */
    fix                 bm_cols;        /* #(cols) of bitmap in pixels  */
    fix                 bm_rows;        /* #(rows) of bitmap in pixels  */
    fix                 bm_bpp;         /* #(planes) of bitmap
                                           bpp means bits per pixel     */
                                        /* the following fields may be
                                           defined if necessary         */
};

#define BM_XORIG        0x0000
#define BM_XMAXI        0x7FFF
#define BM_YORIG        0x0000
#define BM_YMAXI        0x7FFF

#define BM_ENTRY(BM, BM_ADDR, BM_COLS, BM_ROWS, BM_BPP) \
                        BM.bm_addr = BM_ADDR; \
                        BM.bm_cols = BM_COLS; \
                        BM.bm_rows = BM_ROWS; \
                        BM.bm_bpp  = 1;

#define MB_ENTRY(MB)   ((gmaddr) ((ufix32) MB << 20))
#define FB_ENTRY(FB)   ((gmaddr) (MB_ENTRY(FB) + FBX_BASE))


/**************************************************************************
 *      The following macros shift a bitmap word left or right in the
 *      concept of printout.  You should modify these macros to match
 *      the bit ordering.
 **************************************************************************/

#define BMW_LEFT        0x8000          /* bitmap word left most bit      */
#define BMW_MASK        0x000F          /* bitmap word round or mask      */
#define BMW_PIXS        0x0010          /* bitmap word number of pixels   */
#define BMW_BYTE        0x0002          /* bitmap word number of bytes    */

#define CS_2WORD(CS)   (CS >> 4)        /* convert columns into words     */
#define BMS_LEFT(BM,S) (BM << S)        /* shift a bitmap word left       */
#define BMS_RIGH(BM,S) (BM >> S)        /* shift a bitmap word right      */


/**************************************************************************
 *      Symbolic Definition of HT/FC: Halftoning Flag & Function Code
 **************************************************************************/

#define HT_MASK         0xFF00  /* mask of halftone flag                  */
#define FC_MASK         0x00FF  /* mask of function code                  */

#define HT_NONE         0x0000  /* halftone flag: need not be applied     */
#define HT_APPLY        0xFF00  /* halftone flag: should be applied       */

#define FC_WHITE        0x0002  /* 0010B   logical function [all white]   */
#define FC_BLACK        0x0007  /* 0111B   logical function [all black]   */

#define FC_ERASE        0x0000  /* 0000B   for Step 1.  D <- 0            */
#define FC_SOLID        0x000F  /* 1111B   for Step 2.  D <- 1            */
#define FC_CLIPS        0x0001  /* 0001B   for Step 2.  D <- D.AND.S      */
#define FC_CLEAR        0x0002  /* 0010B   for Step 3.  D <- D.AND..NOT.S */
#define FC_HTONE        0x0001  /* 0001B   for Step 4.  D <- D.AND.S      */
#define FC_MERGE        0x0007  /* 0111B   for Step 5.  D <- D.OR.S       */
#define FC_MOVES        0x0005  /* 0101B             .  D <- S            */


/* BEGIN 02/26/90 D.S. Tseng */
/* Change the following defines to variables and initialize them in SETVM.C */
/************************************************************************
 *      System Parameters of Graphics Memory                            *
 ************************************************************************/

/* #define CCB_OFST    ((ufix32) 0x00080000L) */ /* Character Cache Buffer   */
/* #define CCB_SIZE    ((fix32)  1024 *  250) */ /*  250 kilobytes for CCB   */
                                                         /* @IMAGE  01-16-89 */

/* #define ECB_OFST    ((ufix32) 0x000BE800L) */ /* Erasepage Command Buffer */
                                                         /* @IMAGE  01-16-89 */
/* #define ECB_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for ECB   */
/* #define CRC_OFST    ((ufix32) 0x000BF000L) */ /* Joint/Cap Circular Cache */
                                                         /* @IMAGE  01-16-89 */
/* #define CRC_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for CRC   */
/* #define ISP_OFST    ((ufix32) 0x000BF800L) */ /* ImageMask Seed Pattern   */
                                                       /* @IMAGE  01-16-89 */
/* #define ISP_SIZE    ((fix32)   256 *    2) */ /*    8 kilobytes for ISP   */
/* #define HTP_OFST    ((ufix32) 0x000C1800L) */ /* HalfTone RepeatPattern   */
/* #define HTP_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for PCL   */
/* #define HTC_OFST    ((ufix32) 0x000C2000L) */ /* HalfTone Pattern Cache   */
/* #define HTC_SIZE    ((fix32)  1024 *   16) */ /*   16 kilobytes for HTC   */
/* #define HTB_OFST    ((ufix32) 0x000C6000L) */ /* HalfTone Bitmap Buffer   */
/* #define HTB_SIZE    ((fix32)  1024 *   12) */ /*   12 kilobytes for HTB   */
/* #define HTE_OFST    ((ufix32) 0x000C9000L) */ /* HalfTone Bitmap Buffer   */
/* #define HTE_SIZE    ((fix32)  1024 *   12) */ /*   12 kilobytes for HTB   */
/* #define CMB_OFST    ((ufix32) 0x000CC000L) */ /* Clipping  Mask  Buffer   */
/* #define CMB_SIZE    ((fix32)  1024 *   16) */ /*   16 kilobytes for CMB   */
/* #define GCB_OFST    ((ufix32) 0x000D0000L) */ /* GraphicsCommand Buffer   */
/* #define GCB_SIZE    ((fix32)  1024 *  128) */ /*  128 kilobytes for HTB   */
/* #define GWB_OFST    ((ufix32) 0x000F0000L) */ /* Graphic Working BitMap   */
/* #define GWB_SIZE    ((fix32)   300 *  216) */ /*  216 scanlines for GWB   */
/* END   02/26/90 D.S. Tseng */


/* ************************************************************************ *
 *      Environment Dependent Parameters                                    *
 * ************************************************************************ */
#define HTB_XMIN         256    /* mim width of expanded halftone pattern   */
#define HTB_XMAX        FB_WIDTH  /* max width of expanded halftone pattern */

#define SP_BLOCK         256    /* max number of image samples per block
                                       for gcb allocation                   */

#define SP_WIDTH        MAXSEEDSIZE
#define SP_HEIGH        MAXSEEDSIZE

#define GMS_i186       ((ufix32) 0xE0000000L)
                                /* Segment Address of Graphics Memory       */
#define GMA_i186(A)    ((ufix32) (GMS_i186 + (A & 0x0000FFFFL)))
                                /* macro for convert address of graphics
                                       memory into address of 80186         */
#define GM_PMASK       ((ufix32) 0xFFFF0000L)
#define GM_PBANK(G)    ((ufix16) ((ufix32) G >> 16))

/* ************************************************************************ *
 *      Following defined & declarations are added by M.S Lin               *
 *
 * ************************************************************************ */
#define         ZERO            0x0
#define         ONE             0x1
#define         ONE16           0xffffL
#define         ONE32           ((ufix32)0xffffffffL)
#define         BITSPERWORD     0x20
#define         WORDPOWER       0x5
#define         WORDMASK        0x1f
#define         BITSPERSHORT    0x10
#define         SHORTPOWER      0x4
#define         SHORTMASK       0xf

/*MS used by gp_vector 1-18-89 */
#define BM_DATYP        ufix32
#define CC_DATYP        ufix16
#define AND(X,Y)        (X & Y)
#define OR(X,Y)         (X | Y)

/*MS constant define used by GCB */
#define         RESET_PAGE           1
#define         ERASE_PAGE           2
#define         FILL_SCAN_PAGE       3
#define         FILL_PIXEL_PAGE      5
#define         INIT_CHAR_CACHE      6
#define         COPY_CHAR_CACHE      7
#define         FILL_SCAN_CACHE      8
#define         FILL_PIXEL_CACHE     9
#define         INIT_CACHE_PAGE      10
#define         CLIP_CACHE_PAGE      11
#define         FILL_CACHE_PAGE      12
#define         DRAW_CACHE_PAGE      13
#define         FILL_SEED_PATT       14
#define         FILL_TPZD            15
#define         CHANGE_HALFTONE      16
#define         MOVE_CHAR_CACHE      17
#define         FILL_LINE            18
#define         INIT_IMAGE_PAGE      19
#define         CLIP_IMAGE_PAGE      20
#define         FILL_BOX             21         /* jwm, 3/18/91 -begin- */
#define         FILL_RECT            22         /* jwm, 3/18/91 -end- */
#ifdef WIN
#define         PFILL_TPZD           23
#define         CHANGE_PF_PATTERN    24
#endif

#define         GCB_SIZE1            100        /* for no scanline commands */
#define         GCB_SIZE2            8192       /* for scanline commands    */



/*MS macro define */
#define WORD_ALLIGN(x)  (((x + BITSPERWORD -1) >> WORDPOWER) << WORDPOWER )


#ifdef  LBODR
#define         LSHIFT          <<
#define         RSHIFT          >>
#define         ONE1_32         (ufix32)0x1L
#define         ONE1_16         (ufix16)0x1
#define 	ONE8000 	(ufix32)0x80000000	     /*mslin 5/23/91 */
#define         LSHIFTEQ        <<=                     /*mslin 5/23/91 */
#define         RSHIFTEQ        >>=                     /*mslin 5/23/91 */
#else
#define         LSHIFT          >>
#define         RSHIFT          <<
#define         ONE1_32         (ufix32)0x80000000
#define         ONE1_16         (ufix16)0x8000
#define 	ONE8000 	(ufix32)0x1L	       /*mslin 5/23/91 */
#define         LSHIFTEQ        >>=                     /*mslin 5/23/91 */
#define         RSHIFTEQ        <<=                     /*mslin 5/23/91 */
#define         GP_BITBLT16_32  gp_bitblt16_32
#endif

#define BRSHIFT(value,shift,base) ((shift == base) ? 0 : value RSHIFT shift)
#define BLSHIFT(value,shift,base) ((shift == base) ? 0 : value LSHIFT shift)

/*MS
 * Bitmap related functions name macro definition
 */
#define GP_SCANLINE16           gp_scanline16
#define GP_SCANLINE32           gp_scanline32
#ifdef WIN
#define GP_SCANLINE32_pfREP     gp_scanline32_pfREP
#define GP_SCANLINE32_pfOR      gp_scanline32_pfOR
#endif
#define GP_BITBLT16             gp_bitblt16
#define GP_BITBLT32             gp_bitblt32
#define GP_PIXELS16             gp_pixels16
#define GP_PIXELS32             gp_pixels32
#define GP_CACHEBLT16           gp_cacheblt16
#define GP_CHARBLT16            gp_charblt16
#define GP_CHARBLT32            gp_charblt32
#define GP_CHARBLT16_CC         gp_charblt16_cc
#define GP_CHARBLT16_CLIP       gp_charblt16_clip
#define GP_CHARBLT32_CLIP       gp_charblt32_clip
#define GP_PATBLT               gp_patblt
#define GP_PATBLT_M             gp_patblt_m
#define GP_PATBLT_C             gp_patblt_c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgs.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*  ----------------------------------------------------------------
 *  Fill : Fillgs.c
 *
 *  Programmed by: Y.C Chen for 80186+82786 iLaser Board.
 *  Modified by: M.S Lin for single CPU environment.
 *  Date: 5-26-1988
 *        6-05-1989  by J.S.
 *
 *  Purpose
 *     Provide graphics & font module fill and cache supporting functions
 *
 *  Modication History:
 *      8-8-1988 interface change for version X2.1
 *      10-18-88        add fill_tpzd for intermediate file feature.
 *      11-15-88        modified code for portable.
 *      11-25-88        copy_char_cache() modified: gp_charblt16_cc() added.
 *                      init_cache(), clip_cache_page(), fill_cache_page()
 *                      modified: gp_charblt16_clip(), gp_charblt32_clip added.
 *      11-28-88        add alloc_scanline() for font
 *                      add move_char_cache() for font
 *                      fill_scan_page, fill_scan_cache, clip_cache_page
 *                      didn't need save scanline table into GCB
 *      12-01-88        conv_SL() bug fixed.
 *                      *putptr++ = (xe > bb_width) ? (bb_width -1) : xe;
 *                             --->
 *                      *putptr++ = (xe >= bb_width) ? (bb_width -1) : xe;
 *
 *      12-16-88        print_page modified to support manualfeed.
 *
 *      12-20-88        ufix32 printer_status(void) added
 *      01-06-89        fill_line() added
 *      01-19-89        fill_seed_patt() parameter changed, seed_index added
 *      02-03-1989      update for image enchancement.
 *                      @IMAGE-1, @IMAGE-2
 *      06-07-1989      ImageClear() moved to fillgp.c
 *      07-29-1989      cg - Unix port changes to include files
 *      09-24-1990      @CONT_PRI, MSLin 9/24/90
 *                      init_char_cache(), fill_cache_page() and
 *                      draw_cache_page
 *      12/5/90  Danny  Fix the bugs for show char in show (ref. CIRL:)
 *                      new fill_cache_cache() routine added
 *      01/09/91        update GEIeng_printpage() return value check
 #ifdef WIN
 *  Ada 02-15-1991      change fill_tpzd(), fill_scan_page() to handle op_pfill
 #endif
 *      11/20/91        upgrade for higher resolution @RESO_UPGR
 *
 *  Debug Switch:
 *      DBG  -- for function enter message.
 *      DBG1 -- for more information on function call.
 *      DBGscanline -- for scanline list info.
 *      DBGgcb -- for GCB debug message.
 *      DBGfontdata -- for get fontdata info.
 *      DBGcmb -- clipping mask buffer info.
 *
 *
 *  Program Notes:
 *    1. This file support interface routines for graphics and font modules
 *       for running on single CPU environment.
 *
 *    2. We used scanline filling directly into frame buffer without using
 *       graphics working buffer like iLaser board. Scanline and Bitblt
 *       with halftoning applied directly.
 *
 *    3. gp_scanline16() used for filling into font character cache because
 *       bitmap width is multiple of 16.
 *
 *    4. gp_scanline32() used for filling into frame buffer, seed, CMB
 *       because bitmap width of these data area are multiple of 32.
 *
 *    5. gp_bitblt16() and gp_bitblt32() are BITBLT routines also support
 *       halftoning applied.
 *
 *    6. GCB (Graphics Command Buffer) feature also supported for througput
 *       in single buffer environment.
 *
 *
 * ------------------------------------------------------------------------ */


// DJC added global include
#include "psglobal.h"


#include                <stdio.h>
#include                <string.h>
#include                "global.ext"
#include                "graphics.h"

// DJC moved font.h above graphics.ext to avoid prototype prob with init_char_cache
#include                "font.h"

#include                "graphics.ext"
#include                "halftone.h"
#include                "fillproc.h"
#include                "fillproc.ext"   /* 02/28/90 D.S. Tseng */
#include                "language.h"     /* 12-16-88 */
#include                "geieng.h"      /* @GEI */
#include                "geitmr.h"      /* @GEI */
#include                "geierr.h"      /* @GEI */
#include                "user.h"     /* 12-16-88 */

#include                "win2ti.h"     /* @WIN */

/* routines defined in status.c */
extern void     printer_error();
extern fix16    timeout_flag;
int             timeout_flagset;
int             g_handler;
long            g_interval;

/* *************************************************************************
        Local variables
 * ************************************************************************/
static struct bitmap    ISP_Bmap[16]; /* 03/08/89 */
static fix              SP_Width;
static fix              SP_Heigh;

static struct bitmap    HTP_Bmap;
static struct bitmap    SCC_Bmap;
static struct bitmap    DCC_Bmap;


static fix              ISP_Repeat;     /* width of repeat pattern @IMAGE-1 */
static fix              HTB_Expand;     /* width of halftone       @IMAGE-1 */
static fix              HTB_Xmax;       /* HTB expansion width     @IMAGE-1 */
GEItmr_t                manualfeed_tmr;
short  int              manualfeedtimeout_set;
int                     manualfeedtimeout_task();
ufix32                  save_printer_status = EngNormal;

/* *************************************************************************
        Local variables for init_cache_page(), clip_cache_page(),
        fill_cache_page(), and draw_cache_page()

        BB_XXXXX are parameters are bounding box been aligned on word
                 and clipped
        CC_XXXXX are parameters describes how to bitblt CMB onto
                 frame buffer
        CB_XXXXX are parameters described how to bitblt character
                 cache onto CMB
 * ************************************************************************/
static fix              BB_Xorig;
static fix              BB_Yorig;
static fix              BB_Width;
static fix              BB_Heigh;
static fix              CC_Xorig;
static fix              CC_Yorig;
static fix              CC_Width;
static fix              CC_Heigh;

/* @WT: margins defined in "wrapper.c", used by ps_transmit() */
extern int      top_margin;
extern int      left_margin;

/* ufix            seed_flag = 0; */

#ifdef  LINT_ARGS
void      near  expand_halftone(void);
void      near  apply_halftone(fix, fix, fix, fix);

void      near  get_bitmap(gmaddr, ufix far *, fix, fix);
void      near  put_bitmap(gmaddr, ufix32 far *, fix, fix); /* ufix => ufix32 @WIN */

fix       far   conv_SL(fix, SCANLINE FAR *, fix, fix, fix, fix);
void      gp_vector(struct bitmap FAR *, ufix16, fix, fix, fix, fix);

void      gp_vector_c(struct bitmap FAR *, ufix16, fix, fix, fix, fix);
void      gp_patblt(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
void      gp_patblt_m(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
void      gp_patblt_c(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
fix       GEIeng_printpage(fix, fix);           /* @WIN */
void      GEIeng_setpage(GEIpage_t FAR *);


void      ImageClear(ufix32 /* void */);            /* fix => ufix32 @WIN */

#else
void      near  expand_halftone();
void      near  apply_halftone();

void      near  get_bitmap();
void      near  put_bitmap();

fix       far   conv_SL();
void      gp_vector();

void      gp_vector_c();
void      gp_patblt();
void      gp_patblt_m();
void      gp_patblt_c();
fix       GEIeng_printpage();
void      GEIeng_setpage();

void      ImageClear();

#endif

/*MS add*/
#ifdef DBGscanline
   void get_scanlist(fix, fix, SCANLINE FAR *);
#endif
#ifdef DBG
   fix           get_printbufferptr();
#endif

#ifdef  DUMBO
extern byte     bBackflag;      // @DLL
extern byte     bFlushframe;    // @DLL
extern void     longjump(void); // @DLL
extern byte far *lpStack;       // @DLL
#endif


/* ******************************************************************** */

/* -------------------------------------------------------------------- */
/*      init_physical     --  Initialize Fill Procedure Context         */
void
init_physical()
{
#ifdef  DBG
   printf("init_physical...\n");
#endif

/* BEGIN 02/27/90 D.S. Tseng */
/*
 *      FBX_BASE = 0x00800000;
 *
 *      CCB_BASE = CCB_OFST;
 *      ISP_BASE = ISP_OFST;
 *      HTP_BASE = HTP_OFST;
 *      HTC_BASE = HTC_OFST;
 *      HTB_BASE = HTB_OFST;
 *      CMB_BASE = CMB_OFST;
 *      CRC_BASE = CRC_OFST;
 *      GCB_BASE = GCB_OFST;
 *      GWB_BASE = GWB_OFST;
 */
/* END   02/27/90 D.S. Tseng */

        /* public graphics paramters for all modules; @YC 03-21-89 */
        ccb_base = CCB_BASE;    /* base of character cache pool         */
        ccb_size = CCB_SIZE;    /* size of character cache pool         */
        htc_base = HTC_BASE;    /* size of halftone pattern cache       */
        htc_size = HTC_SIZE;    /* size of halftone pattern cache       */
        crc_size = CRC_SIZE;    /* size of circular round cache         */
        isp_size = ISP_SIZE;    /* size of image seed patterns          */
        gwb_size = GWB_SIZE;    /* size of graphics working bitmap      */
        cmb_size = CMB_SIZE;    /* size of clipping mask bitmap         */

        /*  reset default paper tray type and page type  */
        reset_tray(2544, 3328);     /* letter paper tray as default   */
/* Peter reset_page(2400, 3236, 1);      letter page type as default    */
        //DJC took out reset_page(2496, 3300, 1);    /* letter page type as default    */

        /* setup GCB parameters */
        FB_busy = FALSE;      /* 03/08/89 */
        GCB_flush = FALSE;    /* 03/08/89 */
        gcb_ptr = (ULONG_PTR *)GCB_BASE;
        GCB_count = 0L;

#ifdef DBG
        printf("CCB_BASE=%lx, ISP_BASE\n", CCB_BASE, ISP_BASE);
        printf("HTP_BASE=%lx, HTC_BASE=%lx, HTB_BASE=%lx\n",
                HTP_BASE, HTC_BASE, HTB_BASE);
        printf("CMB_BASE=%lx, CRC_BASE=%lx, GCB_BASE=%lx\n",
                CMB_BASE, CRC_BASE, GCB_BASE);
        printf("GWB_BASE=%lx, FBX_BASE=%lx\n", GWB_BASE,FBX_BASE);
#endif

}

/* -------------------------------------------------------------------- */
/*      init_halftone     --  Initialize Half Tone Pattern              */

void init_halftone()
{
#ifdef DBG
   printf("init_halftone..\n");
#endif

        InitHalfToneDat();                                /* 01-29-88 */
#ifdef DBG
   printf("init_halftone().1\n");
#endif

        SetHalfToneCell();
#ifdef DBG
   printf("init_halftone().2\n");
#endif

         FillHalfTonePat();
#ifdef DBG
   printf("init_halftone().3\n");
#endif
}


/* ******************************************************************** *
 *                                                                      *
 *      5.4.2.1 Page Manipulation                                       *
 *                                                                      *
 * ******************************************************************** */


/* -------------------------------------------------------------------- */
/*      reset_tray                                                      */
void far
reset_tray(pt_width, pt_heigh)
fix             pt_width;
fix             pt_heigh;
{
#ifdef  DBG
    printf("reset_tray:  %x %x\n", pt_width, pt_heigh);
#endif

        /* width and height of paper tray in page type structure */
        PageType.PT_Width = pt_width;
        PageType.PT_Heigh = pt_heigh;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   reset_page()                                            *
 *                                                                      *
 *  Parameters: 1. width  of page type                                  *
 *              2. height of page type                                  *
 *                                                                      *
 *  Called by:  init_physical(), op_framedevice(), restore()            *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
reset_page(fb_width, fb_heigh, fb_plane)
fix            fb_width;
fix            fb_heigh;
fix            fb_plane;
{
        // fix    *old_ptr; @WIN
        ULONG_PTR *old_ptr;

#ifdef  DBG
   printf("reset_page:  %x %x %x\n", fb_width, fb_heigh, fb_plane);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = RESET_PAGE;
                *gcb_ptr++ = fb_width;
                *gcb_ptr++ = fb_heigh;
                *gcb_ptr++ = fb_plane;
                *old_ptr = (ULONG_PTR)gcb_ptr;       // (fix )gcb_ptr;@WIN
                return;
            }
        }

    /*  record width, height and number of planes of page type in page
        type structure  */
        PageType.FB_Width = WORD_ALLIGN(fb_width);       /* 10-08-88 */
        PageType.FB_Heigh = fb_heigh;
        FB_Plane = fb_plane;

/* 10-16-90, JS
        HTB_Xmax = HTB_XMAX;                             (* @IMAGE-1 *)
 */

#ifdef DBG1
    printf("Page width=%ld, Page height=%lx\n", FB_WIDTH, FB_HEIGH);
#endif
    /*  define bitmap of active frame buffer  */





        // DJC begin added for realloc of frame buff if needed...
        {
            ufix32 twidth, frame_size;

            twidth = ((WORD_ALLIGN((ufix32)(fb_width))) >> 3);
            frame_size = twidth * (ufix32) fb_heigh;


            //twidth = ((WORD_ALLIGN((ufix32)(PageType.FB_Width ))) >> 3);
            //frame_size = twidth * PageType.FB_Heigh;

            if (! PsAdjustFrame((LPVOID *) &FBX_BASE, frame_size)) {
                    ERROR(LIMITCHECK);
                    return ;  //DJC check this bug we need to report something???
            }

        }
        //DJC end



        BM_ENTRY(FBX_Bmap, FBX_BASE, PageType.FB_Width,
                 PageType.FB_Heigh, FB_PLANE);

    /* 10-16-90, JS */
        HTB_Xmax = HTB_XMAX;                             /* @IMAGE-1 */

    /*  Clear Active frame buffer */
        ImageClear(BM_WHITE);

}
/* --------------------------------------------------
              manualfeedtimeout handler
-----------------------------------------------------*/
int manualfeedtimeout_task()
{
/*
   printf("%c%c[PrinterError : manualfeed timeout ]%c%c\n",37,37,37,37);
   ERROR(TIMEOUT);
   GESseterror(ETIME);
   GEItmr_stop(manualfeed_tmr.timer_id);
   manualfeedtimeout_set=0;
   timeout_flag=1;
   return(TRUE);
*/
    struct object_def  FAR *l_stopobj;
//  struct object_def  FAR *l_valueobj,FAR *l_tmpobj;   @WIN
//  byte   l_buf[60];                                   @WIN
   get_dict_value(SYSTEMDICT,"stop",&l_stopobj);
   printf("%c%c[PrinterError : manualfeed timeout ]%c%c\n",37,37,37,37);
   ERROR(TIMEOUT);
   GESseterror(ETIME);
   GEItmr_stop(manualfeed_tmr.timer_id);
   manualfeedtimeout_set=0;
   PUSH_EXEC_OBJ(l_stopobj);
   timeout_flag = 1;
   timeout_flagset=1;
/* interpreter(l_stopobj); */
   return(TRUE);
}

/* -------------------------------------------------------------------- */
/*      print_page        --  Print Full Page Buffer                    */

void far
print_page(tm_heigh, lm_width, no_pages, pageflag, manualfeed)
fix                     tm_heigh;
fix                     lm_width;
fix                     no_pages;
bool                    pageflag;
fix                     manualfeed;
{
#ifdef _AM29K
   GEIpage_t      PagePt;               /* Peter 09/21/1990 */
   unsigned long  eng_status;           /* Peter 09/28/1990 */
   short int   ii;
   struct object_def  FAR *l_mfeedtimeout;
#endif                                          //@WIN

#ifdef DBG
   printf("print_page()\n");
   printf("page size = %ld %ld %ld, %ld, %ld\n",
           PageType.FB_Width, PageType.FB_Heigh, lm_width, tm_heigh, no_pages);
#endif

#ifdef _AM29K
        flush_gcb(TRUE);
        PagePt.pageNX    = PageType.FB_Width;
        PagePt.pageNY    = PageType.FB_Heigh;
        PagePt.pageLM    = lm_width;
        PagePt.pageTM    = tm_heigh;
        PagePt.feed_mode = manualfeed;
        PagePt.pagePtr   = (unsigned char *) FBX_BASE;
        GEIeng_setpage(&PagePt);
        ii=0;

printf("1\n");
           if (manualfeed)
           {
              get_dict_value(STATUSDICT,"manualfeedtimeout",&l_mfeedtimeout);
              if (VALUE(l_mfeedtimeout)>0)
              {
                g_interval=VALUE(l_mfeedtimeout)*1000;
/*
                manualfeed_tmr.handler=manualfeedtimeout_task;
                manualfeed_tmr.interval=VALUE(l_mfeedtimeout)*1000;
                manualfeedtimeout_set=1;
                GEItmr_start(&manualfeed_tmr);
                */

              }
           }
        while((eng_status = GEIeng_status()) != EngNormal)
        {

/*
           if ((manualfeed) && (!ii))
           {
              ii=1;
              get_dict_value(STATUSDICT,"manualfeedtimeout",&l_mfeedtimeout);
              if (VALUE(l_mfeedtimeout)>0)
              {
printf("manualfeed_set \n");
                manualfeed_tmr.handler=manualfeedtimeout_task;
                manualfeed_tmr.interval=VALUE(l_mfeedtimeout)*1000;
                manualfeedtimeout_set=1;
                GEItmr_start(&manualfeed_tmr);

              }
           }
           */
           printer_error(eng_status);                   /* Peter 09/28/1990 */
        }
        save_printer_status = EngNormal;

        /* waiting until last printout finished */
        while( !GEIeng_printpage(no_pages, 0))         /* Jimmy 1/9/91     */
        ;
      /*
        timeout_flagset = 0;
        if (manualfeedtimeout_set)
        {
          manualfeedtimeout_set=0;
          GEItmr_stop(manualfeed_tmr.timer_id);
        }
        */
        FB_busy = TRUE;
#else
#ifdef  DUMBO
        bFlushframe = 1;        // @DLL
        bBackflag = 1;          // @DLL
        longjump(lpStack);      // @DLL
        bFlushframe = 0;        // @DLL
#else
        //DJC GEIeng_printpage(1, 0);            /* Peter 09/28/1990 @WIN */


        //DJC add code to get the current page type and pass along
        //
        {
          struct object_def FAR *l_page;
          real32 page_type;


          get_dict_value(PSPRIVATEDICT, "psprivatepagetype", &l_page) ;
          GET_OBJ_VALUE( page_type, l_page);


          PsPrintPage( no_pages,
                       0,
                       (LPVOID) FB_ADDR,
                       FB_WIDTH,
                       FB_HEIGH,
                       FB_PLANE,
                       (DWORD) page_type );



        }
#endif
#endif
}


/* ************* Erase ************************************************ */

/* -------------------------------------------------------------------- */
/*      erase_page        --  Erase full Page Buffer                    */

void erase_page()
{
//DJC #ifdef DUMBO
        fix             FB_Ycord;
        //fix           *old_ptr;       @WIN
        ULONG_PTR *old_ptr;
//DJC #endif

#ifdef DBG
   printf("erase_page()\n");
#endif

   /* @WINFLOW; don't erase page temp solution */
// printf("Warning to call erase_page()\n");
//DJC #ifdef DUMBO

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = ERASE_PAGE;
                *gcb_ptr++ = HTP_Type;          /* Jun-21-91 YM */
                *old_ptr = (ULONG_PTR)gcb_ptr;          /*@WIN*/
                return;
            }
        }

        if (HTP_Flag == HT_CHANGED) {                     /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        if(HTP_Type != HT_MIXED) {
                ImageClear((HTP_Type == HT_WHITE) ? BM_WHITE : BM_BLACK);
        }
        else {
     /*
      * copy HTB repeat pattern which have been expanded on expand_halftone
      * to frame buffer
      */
           GP_BITBLT32(&FBX_Bmap, BM_XORIG, BM_YORIG, FB_WIDTH,
                        RP_Heigh,
                        FC_MOVES,
                       &HTB_Bmap, BM_XORIG, BM_YORIG);

           for(FB_Ycord = RP_Heigh; FB_Ycord < FB_HEIGH;
                   FB_Ycord = FB_Ycord << 1) {
                GP_BITBLT32(&FBX_Bmap, BM_XORIG, FB_Ycord, FB_WIDTH,
                            ((FB_Ycord << 1) <= FB_HEIGH)
                            ? FB_Ycord : (FB_HEIGH - FB_Ycord),
                            FC_MOVES,
                            &FBX_Bmap, BM_XORIG, BM_YORIG);
           }
        }
//DJC #endif
        return;
} /* erase_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   next_pageframe()                                        *
 *                                                                      *
 *  Parameters: ----                                                    *
 *                                                                      *
 *  Called by:  op_showpage()                                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
next_pageframe()
{
#ifdef  DBG
    printf("next_pageframe...\n");
#endif

}



/* ************* Halftone ********************************************* */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   change_halftone()                                       *
 *                                                                      *
 *  Parameters: 1. pointer of repeat pattern                            *
 *              2. address of halftone pattern cache                    *
 *              3. type of halftoning; white, gray, or black            *
 *              4. width  of repeat pattern                             *
 *              5. height of repeat pattern                             *
 *                                                                      *
 *  Called by:  FillHalfTonePat()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
change_halftone(rp_array, rp_entry, htp_type, rp_width, rp_heigh)
ufix32             far *rp_array;       /* ufix => ufix32 @WIN */
gmaddr                  rp_entry;
fix                     htp_type;
fix                     rp_width;
fix                     rp_heigh;
{
        //fix           *old_ptr, *temp_ptr;    @WIN
        ULONG_PTR       *old_ptr, *temp_ptr;
        fix             length;

#ifdef  DBG
   printf("change_halftone:  %lx %x %x %x\n",
           rp_entry, htp_type, rp_width, rp_heigh);
#endif

  /*
   * if Frame Buffer busy then put into GCB
   */
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                HTP_Type = htp_type;    /* 6/26/1989 */
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = CHANGE_HALFTONE;
                temp_ptr = gcb_ptr;
                *gcb_ptr++ = (ULONG_PTR)rp_array;      /*@WIN*/
                *gcb_ptr++ = rp_entry;      /*@WIN*/
                *gcb_ptr++ = htp_type;
                *gcb_ptr++ = rp_width;
                *gcb_ptr++ = rp_heigh;
        /*  put repeat pattern onto halftone pattern cache by miss  */
                if (rp_array != NULL) {
                    *temp_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
                    length = rp_width * BM_BYTES(rp_heigh);
                    lmemcpy((ufix8 FAR *)gcb_ptr, (ufix8 FAR *)rp_array, length);/*@WIN*/
                    gcb_ptr += (length + 3) >> 2;
                }
                *old_ptr = (ULONG_PTR)gcb_ptr;         /*@WIN*/
                return;
            }
        }

    /*  record cache address, type, width and height of repeat pattern  */
        HTP_Flag = HT_CHANGED;
        ISP_Flag = HT_CHANGED;                           /* @IMAGE-1 */
        HTP_Type = htp_type;
        RP_CacheBase = rp_entry;
        RP_Width = rp_width;
        RP_Heigh = rp_heigh;

    /*  put repeat pattern onto halftone pattern cache by miss  */
        if (rp_array != NULL)
                put_bitmap(rp_entry, rp_array, rp_width, rp_heigh);
} /* change_halftone */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   expand_halftone()                                       *
 *                                                                      *
 *  Parameters: ----                                                    *
 *                                                                      *
 *  Called by:  erase_page()                                            *
 *              fill_scan_page(),  fill_pixel_page()                    *
 *              init_cache_page(), draw_cache_page()                    *
 *              fill_image_page()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void near
expand_halftone()
{
        fix              HT_Xcord;
        ufix32           i, FAR *hb_addr, FAR *hb_addrb;
        ufix32           FAR *hp_addr;
        fix              width;


#ifdef  DBG
   printf("expand_halftone...\n");
#endif

        /*  determine function code for erasing and painting  */
           if (HTP_Type != HT_MIXED) {
               FC_Paint = (HTP_Type == HT_WHITE) ? FC_WHITE : FC_BLACK;
               HTP_Flag = HT_UPDATED;

#ifdef DBG1
   printf("expand_halftone() OK.1 : %x\n", FC_Paint);
#endif
               return;
           }

#ifdef DBG
   printf("Start expand halftone !,HTB_Xmax = %x\n",HTB_Xmax);
#endif
           FC_Paint = HT_APPLY;

#ifdef DBG1
   printf("Halftone repeat pattern on cache addr = %lx\n",RP_CacheBase);
   printf("RP_Width = %x, RP_Heigh = %x\n",RP_Width, RP_Heigh);
   printf("Halftone pattern buffer addr = %lx\n", HTB_BASE);
   printf("FB_WIDTH = %lx\n", FB_WIDTH);
#endif
           BM_ENTRY(HTP_Bmap, (gmaddr)RP_CacheBase, BM_BOUND(RP_Width),
                    RP_Heigh, FB_PLANE);
           BM_ENTRY(HTB_Bmap, (gmaddr)HTB_BASE, HTB_Xmax,
                    RP_Heigh, FB_PLANE);

        /*  copy repeat pattern to halftone pattern buffer HTB_BASE  */
           hp_addr = (ufix32 FAR *)HTP_Bmap.bm_addr;
           hb_addrb = (ufix32 FAR *)HTB_Bmap.bm_addr;
           for (i = 0; i < (ufix32)RP_Heigh; i++) {     //@WIN
                width = RP_Width;
                hb_addr = hb_addrb;
                while (width > 0) {
                      *hb_addr++ = *hp_addr++;
                      width -= 32;
                 }
                 hb_addrb += HT_WIDTH >> 5;
           }
/*
 *         GP_BITBLT16(&HTB_Bmap, BM_XORIG, BM_YORIG,
 *                     RP_Width, RP_Heigh,
 *                     FC_MOVES,
 *                     &HTP_Bmap, BM_XORIG, BM_YORIG);
 */

#ifdef  DBG3
        {
            fix         row, col;
            ufix32       FAR *hpattern;

            printf("repeat pattern expanding ......\n");
            printf("HTB_BASE = %lx\n",HTB_BASE);
            hpattern = (ufix32 FAR *)HTB_BASE;
            for (row = 0; row < RP_Heigh; row++)
            {
                for (col = 0; col < RP_Width; col+=32)
                {
                    printf(" %lx", *hpattern);
                }
                hpattern += HT_WIDTH >> 5;
                printf("\n");
            }
        }
#endif

        /*  expand halftone on frame buffer horizontally

            +-------------------------------------------------------+
            |//////\\\\\\++++++++++++######################## . . . |
            |//////\\\\\\++++++++++++######################## . . . |
            +-------------------------------------------------------+
             |RP*1||RP*1||<- RP*2 ->||<------ RP * 4 ------>|

            horizontal expansion are applied as follows:

                1.  copy region(/) to region(\)
                2.  copy region(\) to region(+)
                3.  copy region(+) to region(#)
               etc.
        */

            for (HT_Xcord = RP_Width; HT_Xcord <= (HT_WIDTH >> 1);
                HT_Xcord = HT_Xcord << 1) {

#ifdef DBG1
   printf("expand_halftone().2, HT_Xcord = %ld\n", HT_Xcord);
#endif
                GP_BITBLT32(&HTB_Bmap, HT_Xcord, BM_YORIG,
                           HT_Xcord, RP_Heigh,
                           FC_MOVES,
                          &HTB_Bmap, BM_XORIG, BM_YORIG);

            }   /* for  */
            if (HT_Xcord != HT_WIDTH)
               GP_BITBLT32(&HTB_Bmap, HT_Xcord, BM_YORIG,
                          (HT_WIDTH - HT_Xcord), RP_Heigh,
                          FC_MOVES,
                         &HTB_Bmap, BM_XORIG, BM_YORIG);

#  ifdef DBG1
      printf("expand_halftone() OK.2\n");
#  endif

        return;

} /* expand_halftone() */


/* ************* Filling ********************************************** */

/* ********************************************************************
 *
 *  printout scanline list for debug
 *
 * ******************************************************************** */
#ifdef DBGscanline
void get_scanlist(startline, lines, scan)
fix        startline, lines;
SCANLINE  FAR *scan;
{
        fix   i = 1;
        SCANLINE   xs;

        printf("ys_lines = %d, no_lines = %d\n", startline, lines);
        while(lines-- >0) {
          printf("line %d : \n", i++);
          printf("\t");
          while( (xs = *scan++) != (SCANLINE)END_OF_SCANLINE )
             printf("<%d, %d>, ", xs, *scan++);
          printf("\n");
        }
        return;
}
#endif



/***********************************************************************
 * According to the type(dest), this routine appends the input
 * trapezoid to command buffer, or calls "gp_scanconv" to render it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_tpzd
 *
 * CALL:        fill_tpzd(dest, info, tpzd)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: bounding box information
 *              3. tpzd: a trapezoid
 *
 * INTERFACE:
 *
 * CALLS:       gp_scanconv
 *
 * RETURN:      None
 **********************************************************************/
void far fill_tpzd(dest, info, tpzd)
ufix dest;
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{

        ULONG_PTR *old_ptr;         /*@WIN*/
#ifdef WIN
        extern  fix     pfill_flag;
#endif

#ifdef DBG
   printf("fill_tpzd(): dest=%d\n\ttpzd=\n", dest);
   printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
           SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
   printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
           SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif

        /* Save trapezoid in command buffer if frame buffer/cache is busy */
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
#ifdef WIN
                if (pfill_flag) {
                    *gcb_ptr++ = PFILL_TPZD;
                    *gcb_ptr++ = pfill_flag;
                }
                else
#endif
                *gcb_ptr++ = FILL_TPZD;
                *gcb_ptr++ = (fix )image_info.seed_index;/*MS 10-20-88*/
                *gcb_ptr++ = (fix) dest;
                put_tpzd_info(info);
                put_tpzd(tpzd);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
            }
        }

/* @WINFLOW; ------------- begin ------------------*/
        {
          void far GDIPolygon(struct tpzd_info FAR *, struct tpzd FAR *);

          // /* perform scan conversion */
          // gp_scanconv(dest, info, tpzd);

          /* If using normal holftone, calls GDI directly, otherwise perform
           * the scan conversion  @WINFLOW
           */
          if (dest == F_TO_PAGE && bGDIRender) {        /* @WINFLOW */
              /* Windows GDI fill the trapezoid */
              // DJC GDIPolygon(info, tpzd);

          } else {
              /* Trueimage does the rendering */

              /* modify coord of tpzd as relative to the left-top corner @WINFLOW */
              /* for dynamic global memory allocate only
              tpzd->topxl -= I2SFX(info->BOX_X);
              tpzd->topxr -= I2SFX(info->BOX_X);
              tpzd->btmxl -= I2SFX(info->BOX_X);
              tpzd->btmxr -= I2SFX(info->BOX_X);
              */

              gp_scanconv(dest, info, tpzd);
          }
        }
/* @WINFLOW; -------------  end  ------------------*/

}

/* **************************************************************************
 * This is a interier filling routine for image seed filling.
 *
 * TITLE: fill_seed
 *
 * CALL: fill_seed(image_type, x_maxs, y_maxs, quadrangle)
 *
 * PARAMETERS:
 *
 * CALLS: gp_scanconv_i
 *
 * RETURN: none
 *
 * **************************************************************************
 */

void far
fill_seed(image_type, x_maxs, y_maxs, quadrangle)
ufix           image_type;
fix            x_maxs, y_maxs;
struct sample FAR *quadrangle;
{
    gp_scanconv_i(image_type, x_maxs, y_maxs, quadrangle);
} /* fill_seed */


/***********************************************************************
 * According to the type(dest), this routine appends the input
 * trapezoid to command buffer, or renders it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_line
 *
 * CALL:        fill_line(dest, info, x0, y0, x1, y1)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: tpzd info.
 *              3. tpzd: line start & end points
 *
 * INTERFACE:
 *
 * CALLS: gp_vector, gp_vector_c
 *
 * RETURN:      None
 **********************************************************************/
void far fill_line(dest, info, x0, y0, x1, y1)
ufix              dest;
struct tpzd_info FAR *info;
sfix_t            x0, y0;
sfix_t            x1, y1;
{
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG1
    printf("fill_line(): dest=%d\n", dest);
    printf("[%d, %d] -- [%d, %d]\n", x0, y0, x1, y1);
#endif

    /* Save line in command buffer if frame buffer/cache is busy */
  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE1) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = FILL_LINE;
        *gcb_ptr++ = (fix) dest;
        put_tpzd_info(info);
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        *gcb_ptr++ = (fix) x0;
        *gcb_ptr++ = (fix) y0;
        *gcb_ptr++ = (fix) x1;
        *gcb_ptr++ = (fix) y1;
#elif  FORMAT_16_16 /* FORMAT_16_16 and FORMAT_28_4 can be combined */
        /* x0, y0, x1, y1 are 4-byte long while fix may be only 2-byte
           Therefore, storing high-byte then low-byte into gcb.
        */
        *gcb_ptr++ = (fix) (x0 >> 16);
        *gcb_ptr++ = (fix) (x0 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y0 >> 16);
        *gcb_ptr++ = (fix) (y0  & 0x0000ffff);
        *gcb_ptr++ = (fix) (x1 >> 16);
        *gcb_ptr++ = (fix) (x1 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y1 >> 16);
        *gcb_ptr++ = (fix) (y1 & 0x0000ffff);
#elif  FORMAT_28_4
        /* x0, y0, x1, y1 are 4-byte long while fix may be only 2-byte
           Therefore, storing high-byte then low-byte into gcb.
        */
        *gcb_ptr++ = (fix) (x0 >> 16);
        *gcb_ptr++ = (fix) (x0 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y0 >> 16);
        *gcb_ptr++ = (fix) (y0  & 0x0000ffff);
        *gcb_ptr++ = (fix) (x1 >> 16);
        *gcb_ptr++ = (fix) (x1 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y1 >> 16);
        *gcb_ptr++ = (fix) (y1 & 0x0000ffff);
#endif
        *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
        return;
    }
  }


    /* perform line drawing */
    switch (dest)
    {
    case F_TO_PAGE:
        if (HTP_Flag == HT_CHANGED)                             /* @IMAGE-1 */
        {
            HTP_Flag =  HT_UPDATED;
            expand_halftone();
        }
        /*  fill line directly onto frame buffer black or white   */
        /* @WINFLOW; ------------ start ------------ */
        //gp_vector(&FBX_Bmap, /* @RESO_UPGR */
        //       FC_Paint,
        //       (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        if (bGDIRender)
            // DJC GDIPolyline((fix) x0, (fix) y0, (fix) x1, (fix) y1);
            ; // DJC
        else
            gp_vector(&FBX_Bmap, /* @RESO_UPGR */
                     FC_Paint,
                     (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        /* @WINFLOW; ------------  end  ------------ */
        break;
    case F_TO_CACHE:
        BM_ENTRY(DCC_Bmap, info->BMAP, info->box_w, info->box_h, 1);
        gp_vector_c(&DCC_Bmap, /* @RESO_UPGR */
                     FC_SOLID,
                     (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        break;
    default:
        printf("Can't fill to other than PAGE or CACHE\n");
        break;
    }
} /* fill_line */



/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_scan_page()                                        *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT FOR RISC)  *
 *              2. x origin of bounding box             (NOT FOR RISC)  *
 *              3. width  of bounding box               (NOT FOR RISC)  *
 *              4. height of bounding box               (NOT FOR RISC)  *
 *              5. y coordinate of starting scanlines                   *
 *              6. number  of scanlines                                 *
 *              7. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  fill_a_band()                                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_scan_page(bb_xorig, bb_yorig, bb_width, bb_heigh, scanline)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
SCANLINE          FAR *scanline;
{
        ULONG_PTR *old_ptr;         /*@WIN*/
#ifdef WIN
        extern  fix     pfill_flag;
#endif

#ifdef  DBG
   printf("fill_scan_page:   %x %x %x %x \n",
           bb_xorig, bb_yorig, bb_width, bb_heigh);
   printf("scanline_table = %lx\n",scanline);
#endif
#ifdef  DBGscanline
   get_scanlist(bb_yorig, bb_heigh, scanline);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_SCAN_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                put_scanline(bb_heigh, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

#ifdef WIN
        if (pfill_flag == PF_REP) {
            GP_SCANLINE32_pfREP(&FBX_Bmap, (ufix16)FC_Paint,
                      bb_yorig, bb_heigh, scanline);
        }
        else if (pfill_flag == PF_OR) {
            GP_SCANLINE32_pfOR(&FBX_Bmap, (ufix16)FC_Paint,
                      bb_yorig, bb_heigh, scanline);
        }
        else
#endif
        /* @WINFLOW; ------------ start ------------ */
        {

            /* @WINFLOW; through GDI to bitblt to Windows */
            // GP_SCANLINE32(&FBX_Bmap, (ufix16)FC_Paint,
            //               bb_yorig, bb_heigh, scanline);
            if (bGDIRender)
                // DJC GDIBitmap(bb_xorig, bb_yorig, bb_width, bb_heigh,
                // DJC   (ufix16)FC_Paint, PROC_SCANLINE32, (LPSTR)scanline);
                ; // DJC
            else {
               GP_SCANLINE32(&FBX_Bmap, (ufix16)FC_Paint,
                             bb_yorig, bb_heigh, scanline);
            }
        }
        /* @WINFLOW; ------------  end  ------------ */

} /* fill_scan_page */


/* -------------------------------------------------------------------  */
/*      fill_pixel_page   --  Filling Pixel List into Page Buffer       */
/*MS    Note : page width should be multiple of 32                      */

void fill_pixel_page(no_pixel, pixelist)
fix                     no_pixel;
PIXELIST                FAR *pixelist;
{
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
   printf("fill_pixel_page()\n");
#endif
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_PIXEL_PAGE;
                *gcb_ptr++ = no_pixel;
                put_pixelist(no_pixel, pixelist);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        GP_PIXELS32(&FBX_Bmap, FC_Paint, no_pixel, pixelist);
        return;

}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   init_char_cache()                                       *
 *                                                                      *
 *  Parameters: 1. cache_info to be cleared                             *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
init_char_cache(dcc_info)
struct Char_Tbl   far  *dcc_info;
{
        ufix16          FAR *ptr;
        ufix32          FAR *ptr32;
        fix             i;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef  DBG
    printf("init_char_cache:  %lx %x %x\n",
           dcc_info->bitmap, dcc_info->box_w, dcc_info->box_h);
#endif
/*@CONT_PRI, MSLin 9/24/90*/
        if(GCB_count)
            flush_gcb(TRUE);

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = INIT_CHAR_CACHE;
                put_Char_Tbl(dcc_info);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
             }
        }

  /*
   * clear cache bitmap
   */
        if (dcc_info->box_w & 0x1f) {
           ptr = (ufix16 FAR *)dcc_info->bitmap;
           i = dcc_info->box_h * (dcc_info->box_w >> SHORTPOWER);
           while(i--)
              *ptr++ = 0;
        }else {
           ptr32 = (ufix32 FAR *)dcc_info->bitmap;
           i = dcc_info->box_h * (dcc_info->box_w >> WORDPOWER);
           while (i--)
              *ptr32++ = 0L;
        }

}

/* --------------------------------------------------------------------
 *      move_char_cache   --  Move Character Cache
 *
 *       cc_from                cc_into
 *       +-------------+        +-----------+
 *       |  + cc_xorig |        |           |
 *       |    cc_yorig =========>           |
 *       |             |        |           |
 *       |             |        |           |
 *       +-------------+        +-----------+
 * --------------------------------------------------------------------- */

void move_char_cache(cci_into, cci_from)
struct Char_Tbl   far  *cci_into;
struct Char_Tbl   far  *cci_from;
{
  ULONG_PTR *old_ptr;
  fix           width;
  ufix16        FAR *src_addr16, FAR *dst_addr16;
  ufix32        FAR *src_addr32, FAR *dst_addr32;       //@WIN: ufix=>ufix32


#ifdef DBG
   printf("move_char_cache() : dest = %lx, src = %lx\n",
           cci_into->bitmap, cci_from->bitmap);
   printf( "width = %d, height = %d\n",
            cci_into->box_w, cci_into->box_h);

#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE1) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = MOVE_CHAR_CACHE;
        put_Char_Tbl(cci_into);
        put_Char_Tbl(cci_from);
        *old_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
        return;
    }
  }

  width = cci_into->box_w;
  if(width & 0x1f) {
     width = cci_into->box_h * (width >> SHORTPOWER);
     src_addr16 = (ufix16 FAR *)cci_from->bitmap;
     dst_addr16 = (ufix16 FAR *)cci_into->bitmap;
     while(width--)
       *dst_addr16++ = *src_addr16++;
  }
  else {
     width = cci_into->box_h * (width >> WORDPOWER);
     src_addr32 = (ufix32 FAR *)cci_from->bitmap;  // @WIN: ufix=>ufix32
     dst_addr32 = (ufix32 FAR *)cci_into->bitmap;  // @WIN: ufix=>ufix32
     while(width--)
       *dst_addr32++ = *src_addr32++;
  }

  return;
} /* move_char_cache */

/* ----------------------------------------------------------------------
 * alloc_scanline(): allocate scanline table for font module
 *
 * ---------------------------------------------------------------------- */
/* @INTEL960 BEGIN D.S.Tseng */
static     SCANLINE     scan_buf[MAXSCANLINES] = {0}; /* 0; */
/* @INTEL960 END   D.S.Tseng */

SCANLINE   FAR *alloc_scanline(size)
fix     size;
{
/*  SCANLINE    *old_ptr;
 *
 *  if(fb_busy()){
 *      size = WORD_ALLIGN(size);
 *      if(alloc_gcb(size + GCB_SIZE1) != NIL){
 *        old_ptr = (SCANLINE *)gcb_ptr;
 *        gcb_ptr += size >> 2;
 *        GCB_count--;
 *      }
 *      else
 *        old_ptr = (SCANLINE *)GCB_BASE;
 *  }
 *  else
 *      old_ptr = (SCANLINE *)GCB_BASE;
 *  return((SCANLINE *)old_ptr);
 */
    return((SCANLINE *)scan_buf);

} /* alloc_scanline */

/* --------------------------------------------------------------------
 *      copy_char_cache   --  Copy Character Cache
 *
 *       cc_from                cc_into
 *       +-------------+        +-----------+
 *       |  + cc_xorig |        |           |
 *       |    cc_yorig =========>           |
 *       |             |        |           |
 *       |             |        +-----------+
 *       +-------------+
 * --------------------------------------------------------------------- */

void copy_char_cache(cci_into, cci_from, cc_xorig, cc_yorig)
struct Char_Tbl   far  *cci_into;
struct Char_Tbl   far  *cci_from;
fix                     cc_xorig;
fix                     cc_yorig;
{
        ufix16         FAR *src_addr16, FAR *srcptr, FAR *dstptr;
        fix             cc_width, cc_heigh;
        ULONG_PTR *old_ptr;         /*@WIN*/

#ifdef DBG
   printf("copy_char_cache() : dest = %lx, src = %lx\n",
           cci_into->bitmap, cci_from->bitmap);
   printf( "cc_xorig = %d, cc_yorig = %d, width = %d, height = %d\n",
            cc_xorig, cc_yorig, cci_into->box_w, cci_into->box_h);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = COPY_CHAR_CACHE;
                put_Char_Tbl(cci_into);
                put_Char_Tbl(cci_from);
                *gcb_ptr++ = cc_xorig;
                *gcb_ptr++ = cc_yorig;
                *old_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
                return;
           }
        }

/*MS  11-25-88 */
        if ( cc_xorig == 0 ) {

        /* cc_xorig = # of ufix16 of source bitmap width */
           cc_xorig = cci_from->box_w >> 4;
           cc_heigh = cci_into->box_h;
           dstptr = (ufix16 FAR *)cci_into->bitmap;
           src_addr16 = (ufix16 FAR *)((ufix16 FAR *)cci_from->bitmap +
                                cc_yorig * cc_xorig);

        /* cc_yorig = # of ufix16 of destination bitmap width */
           cc_yorig = cci_into->box_w >> SHORTPOWER;
           while ( cc_heigh--) {
                srcptr = src_addr16;
                cc_width = cc_yorig;
                while (cc_width--)
                    *dstptr++ = *srcptr++;
                src_addr16 += cc_xorig;
           }
           return;
        }

        cc_width = MIN(cci_into->box_w, cci_from->box_w-cc_xorig);
/* 10-20-90, JS
        cc_heigh = cci_into->box_h;

        src_addr16 = (ufix16 *)((ufix16 *)cci_from->bitmap +
                        cc_yorig * (cci_from->box_w >> SHORTPOWER) +
                       (cc_xorig >> SHORTPOWER) );
        cc_width = (cc_width << 16) | (cc_heigh);       (* 11-22-1988 *)
        cc_heigh = ((cc_xorig & 0xf) << 16) | (cci_from->box_w >> SHORTPOWER) ;
        GP_CHARBLT16_CC((ufix16 *)cci_into->bitmap, src_addr16,
                          cc_width, cc_heigh);
 */
        GP_CHARBLT16_CC((ufix16 FAR *)cci_into->bitmap,
                                  cc_width, cci_into->box_h,
                        cci_from, cc_xorig, cc_yorig);

        return;

} /* copy_char_cache */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_scan_cache()                                       *
 *                                                                      *
 *  Parameters: 1. address of character cache                           *
 *              2. width  of character cache                            *
 *              3. height of character cache                            *
 *              4. y coordinate of starting scanlines                   *
 *              5. number  of scanlines                                 *
 *              6. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_scan_cache(cc_entry, cc_width, cc_heigh, ys_lines, no_lines, scanline)
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
fix                     ys_lines;
fix                     no_lines;
SCANLINE                FAR *scanline;
{
        ULONG_PTR *old_ptr;           /*@WIN*/

#ifdef  DBG
   printf("fill_scan_cache:  %lx %x %x  %x %x\n",
           cc_entry, cc_width, cc_heigh, ys_lines, no_lines);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_SCAN_CACHE;
                *gcb_ptr++ = (fix )cc_entry;
                *gcb_ptr++ = cc_width;
                *gcb_ptr++ = cc_heigh;
                *gcb_ptr++ = ys_lines;
                *gcb_ptr++ = no_lines;
                put_scanline(no_lines, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

        BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, cc_width, cc_heigh, 1);

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif
        GP_SCANLINE16(&SCC_Bmap,
                       FC_SOLID, ys_lines,
                       no_lines, scanline);
}



/* -------------------------------------------------------------------
 *      fill_pixel_cache  --  Filling Pixel List into Character Cache
 *MS    Note : cc_width should be multiple of 16
 * ------------------------------------------------------------------- */

void fill_pixel_cache(cc_entry, cc_width, cc_heigh, no_pixel, pixelist)
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
fix                     no_pixel;
PIXELIST                FAR *pixelist;
{
//      fix16           FAR *ptr;       //@WIN
//      PIXELIST        xc, yc;         //@WIN
        ULONG_PTR *old_ptr;   /*@WIN*/

#ifdef DBG
   printf("fill_pixel_cache() : ");
   printf("cc_entry = %lx, cc_width = %d,", cc_entry, cc_width);
   printf("no_pixel = %d\n", no_pixel);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_PIXEL_CACHE;
                *gcb_ptr++ = (fix )cc_entry;
                *gcb_ptr++ = cc_width;
                *gcb_ptr++ = cc_heigh;
                *gcb_ptr++ = no_pixel;
                put_pixelist(no_pixel, pixelist);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

        BM_ENTRY(SCC_Bmap, cc_entry, cc_width, cc_heigh, 1)
        GP_PIXELS16(&SCC_Bmap,
                     FC_SOLID,
                    no_pixel, pixelist);

        return;

} /* fill_pixel_cache */



/* ******************************************************************** *
 *                                                                      *
 *  Function:   init_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box                             *
 *              2. x origin of bounding box                             *
 *              3. width  of bounding box                               *
 *              4. height of bounding box                               *
 *              5. address of character cache                           *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
init_cache_page(bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
gmaddr                  cc_entry;
{
        fix32           i;                      /*@WIN*/
        ULONG_PTR *old_ptr;           /*@WIN*/
        ULONG_PTR *ptr;               /*@WIN*/

        /* Expand bb_xorig to 4 times; @GRAY */
        if (GSptr->device.nuldev_flg == GRAYDEV) {      /* Jack Liaw 7-26-90 */
                bb_xorig= bb_xorig << 2;
        }

#ifdef  DBG
    printf("init_cache_page:  %ld %ld %ld %ld  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif
#ifdef  DBGcmb
    printf("init_cache_page:  %ld %ld %ld %ld  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = INIT_CACHE_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                *gcb_ptr++ = (fix )cc_entry;
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
           }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        CC_Xorig = BM_XORIG;
        CC_Yorig = BM_YORIG;
        BB_Xorig = bb_xorig;
        BB_Yorig = bb_yorig;
        BB_Width = bb_width;
        BB_Heigh = bb_heigh;

        if (bb_xorig < BM_XORIG) {
           CC_Xorig = -bb_xorig;
           BB_Xorig = BM_XORIG;
           BB_Width += bb_xorig;
        }   /* if   */
        else if ((bb_xorig + bb_width) > FB_WIDTH)   /* Y.C. 10-19-88 */
                BB_Width = FB_WIDTH - BB_Xorig;

        if (bb_yorig < BM_YORIG) {
           CC_Yorig = -bb_yorig;
           BB_Yorig = BM_YORIG;
           BB_Heigh += bb_yorig;
        }   /* if   */
        else if ((bb_yorig + bb_heigh) > FB_HEIGH)   /* Y.C. 10-19-88 */
                 BB_Heigh = FB_HEIGH - BB_Yorig;

        if (BB_Width <= 0 || BB_Heigh <= 0)
                return;

        CC_Width = BB_Width;
        BB_Width = WORD_ALLIGN(BB_Width);

#ifdef  DBGcmb
    printf("BB:  %ld %ld %ld %ld\n", BB_Xorig, BB_Yorig, BB_Width, BB_Heigh);
    printf("CC:  %ld %ld\n", CC_Xorig, CC_Yorig);
#endif

        BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, bb_width, bb_heigh, 1);
        BM_ENTRY(CMB_Bmap, (gmaddr)CMB_BASE, BB_Width, BB_Heigh, 1);

    /*  clear clipping mask buffer  */

/*MS
 *      GP_BITBLT16(&CMB_Bmap, BM_XORIG, BM_YORIG,
 *                   CC_Width, CC_Heigh,
 *                   FC_CLEAR,
 *                  &CMB_Bmap, BM_XORIG, BM_YORIG);
 */
        ptr = (ULONG_PTR *)CMB_BASE;           /* @WIN 04-20-92 */
        i = BB_Heigh * (BB_Width >> 5);
        while(i--)
              *ptr++ = 0L;

}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   clip_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT USED)      *
 *              2. x origin of bounding box             (NOT USED)      *
 *              3. width  of bounding box               (NOT USED)      *
 *              4. height of bounding box               (NOT USED)      *
 *              5. y coordinate of starting scanlines                   *
 *              6. number  of scanlines                                 *
 *              7. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
clip_cache_page(ys_lines, no_lines, scanline)
fix                     ys_lines;
fix                     no_lines;
SCANLINE            FAR *scanline;
{
//  fix                 bb_xorig;               //@WIN
//  fix                 bb_yorig;               //@WIN
    ULONG_PTR *old_ptr;           /*@WIN*/

#ifdef  DBG
    printf("clip_cache_page:  %x %x\n", ys_lines, no_lines);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = CLIP_CACHE_PAGE;
                *gcb_ptr++ = ys_lines;
                *gcb_ptr++ = no_lines;
                put_scanline(no_lines, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
           }
        }

        if(BB_Width <= 0 || BB_Heigh <= 0)
                return;

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif

        if (conv_SL(no_lines, scanline,
                    BB_Xorig, BB_Yorig, CC_Width, BB_Heigh) == 0)
                return;

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif

    /*  setup clipping mask buffer from scanlines of clippath  */

#ifdef LBODR
        GP_SCANLINE32(&CMB_Bmap,
                       FC_SOLID,
                       ys_lines - BB_Yorig, no_lines, scanline);
#else
        GP_SCANLINE16(&CMB_Bmap,
                       FC_SOLID,
                       ys_lines - BB_Yorig, no_lines, scanline);
#endif
        return;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT USED)      *
 *              2. x origin of bounding box             (NOT USED)      *
 *              3. width  of bounding box               (NOT USED)      *
 *              4. height of bounding box               (NOT USED)      *
 *              5. address of character cache           (NOT USED)      *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
fill_cache_page()
{
    ULONG_PTR *old_ptr;           /*@WIN*/
//  ufix16              FAR *src_addr16;        //@WIN
//  ufix32              FAR *src_addr32;        //@WIN
    ufix32              huge *dst_addr32; /*@WIN 04-15-92*/
    ufix32              bb_width, bb_heigh;                /*@WIN 04-15-92*/
    fix32               scc_width;

#ifdef  DBG
    printf("fill_cache_page...\n");
#endif

/*@CONT_PRI, MSLin 9/24/90*/
        if(GCB_count)
            flush_gcb(TRUE);

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_CACHE_PAGE;
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
           }
        }

        if(BB_Width <= 0 || BB_Heigh <= 0)
                return;

    /*
     *  clip character cache with clipping mask buffer into
     *  a clipped character cache
     */
/*
 *  GP_BITBLT16(&CMB_Bmap, BM_XORIG, BM_YORIG,
 *             CC_Width, BB_Heigh,
 *             FC_CLIPS,
 *            &SCC_Bmap, CC_Xorig, CC_Yorig);
 */
        scc_width = SCC_Bmap.bm_cols;
        if (scc_width & 0x1f) {
/* 10-20-90, JS
           src_addr16 = (ufix16 *)((ufix16 *)SCC_Bmap.bm_addr +
                                 CC_Yorig * (scc_width >> SHORTPOWER) +
                                 (CC_Xorig >> SHORTPOWER) );
           bb_width = (CC_Width << 16) | (BB_Heigh);  (* 11-22-1988 *)
           bb_heigh = ((CC_Xorig & 0xf) << 16) | (scc_width >> SHORTPOWER) ;
           GP_CHARBLT16_CLIP((ufix16 *)CMB_Bmap.bm_addr, src_addr16,
                                       bb_width, bb_heigh);
 */
           GP_CHARBLT16_CLIP(&CMB_Bmap, CC_Width, BB_Heigh,
                             &SCC_Bmap, CC_Xorig, CC_Yorig);
        } else {
/* 10-20-90, JS
           src_addr32 = (ufix *)((ufix *)SCC_Bmap.bm_addr +
                                 CC_Yorig * (scc_width >> WORDPOWER) +
                                 (CC_Xorig >> WORDPOWER) );
           bb_width = (CC_Width << 16) | (BB_Heigh);   (* 11-22-1988 *)
           bb_heigh = ((CC_Xorig & 0x1f) << 16) | (scc_width >> WORDPOWER) ;
           GP_CHARBLT32_CLIP((ufix *)CMB_Bmap.bm_addr, src_addr32,
                                     bb_width, bb_heigh);
 */
           GP_CHARBLT32_CLIP(&CMB_Bmap, CC_Width, BB_Heigh,
                             &SCC_Bmap, CC_Xorig, CC_Yorig);
        }

    /*
     * fill Clipping Mask buffer into frame buffer
     */
/*
 *      GP_BITBLT32(&FBX_Bmap, BB_Xorig, BB_Yorig,
 *                 BB_Width, BB_Heigh,
 *                 FC_Paint,
 *                &CMB_Bmap, BM_XORIG, BM_YORIG);
 */
        if (HTP_Type != HT_MIXED ){
           dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                        (ufix32)BB_Yorig * ((ufix32)FB_WIDTH >> WORDPOWER) +
                        (ufix32)(BB_Xorig >> WORDPOWER) );  /*@WIN*/
           bb_width = ((ufix32)BB_Width << 16) | (BB_Heigh);    /*@WIN*/
           bb_heigh = ((ufix32)(BB_Xorig & 0x1f) << 16) | FC_Paint; /*@WIN*/
           GP_CHARBLT32((ufix32 huge *)dst_addr32, (ufix32 FAR *)CMB_Bmap.bm_addr,
                        bb_width, bb_heigh);    /*@WIN 04-15-92*/

        } else {

#ifdef LBODR
           GP_BITBLT32(&FBX_Bmap, BB_Xorig, BB_Yorig,
                        BB_Width, BB_Heigh,
                        FC_Paint,
                       &CMB_Bmap, BM_XORIG, BM_YORIG);
#else
           GP_BITBLT16_32(&FBX_Bmap, BB_Xorig, BB_Yorig,
                           BB_Width, BB_Heigh,
                           FC_Paint,
                          &CMB_Bmap, BM_XORIG, BM_YORIG);
#endif

        }

} /* fill_cache_page */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   draw_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box                             *
 *              2. x origin of bounding box                             *
 *              3. width  of bounding box                               *
 *              4. height of bounding box                               *
 *              5. address of character cache                           *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
draw_cache_page(bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry)
fix32                   bb_xorig;
fix32                   bb_yorig;
ufix32                  bb_width;
ufix32                  bb_heigh;
gmaddr                  cc_entry;
{
        ULONG_PTR *old_ptr;       /*@WIN*/
        ufix32      huge *dst_addr32;   /*@WIN 04-15-92*/
#ifdef LBODR
        ufix16      huge *dst_addr16;   /*@WIN 04-15-92*/
#endif

        /* Expand bb_xorig to 4 times; @GRAY */
        if (GSptr->device.nuldev_flg == GRAYDEV) {      /* Jack Liaw 7-26-90 */
                bb_xorig= bb_xorig << 2;
        }

#ifdef  DBG
    printf("draw_cache_page:  %x %x %x %x  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif

/*@CONT_PRI, MSLin 9/24/90*/

        if ( ((ufix32)CCB_BASE > (ufix32)cc_entry) ||
             (((ufix32)CCB_BASE + (ufix32)CCB_SIZE) <= (ufix32)cc_entry) )
            flush_gcb(TRUE);

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = DRAW_CACHE_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                *gcb_ptr++ = cc_entry;         /*@WIN*/
                *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }
/*
 *  BB_Xorig = BM_ALIGN(bb_xorig);
 *  BB_Yorig = bb_yorig;
 *  BB_Width = BM_BOUND((bb_xorig - BB_Xorig) + bb_width);
 *  BB_Heigh = bb_heigh;
 *
 *  CC_Xorig = bb_xorig - BB_Xorig;
 *  CC_Yorig = BM_YORIG;
 *  CC_Width = bb_width;
 *  CC_Heigh = bb_heigh;
 */

        if (HTP_Type != HT_MIXED) {

        /*  fill the character cache onto frame buffer
         *  for black halftone by FC_MERGE
         */
        /* 11-04-1988 GP_BITBLT16 --> gp_charblt */
/*MS        GP_BITBLT16(&FBX_Bmap, bb_xorig, bb_yorig,
 *                       bb_width, bb_heigh,
 *                       FC_MERGE,
 *                      &SCC_Bmap, BM_XORIG, BM_YORIG);
 */
            if(bb_width & 0x1f) {
#ifndef LBODR
                dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                               bb_yorig * (FB_WIDTH >> WORDPOWER) +
                              (bb_xorig >> WORDPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0x1f) << 16 | FC_Paint;
                GP_CHARBLT16((ufix32 huge *)dst_addr32, (ufix16 FAR *)cc_entry,
                                bb_width, bb_heigh);    /*@WIN 04-15-92*/
#else
                dst_addr16 = (ufix16 FAR *)((ufix16 FAR *)FB_ADDR +
                               bb_yorig * (FB_WIDTH >> SHORTPOWER) +
                              (bb_xorig >> SHORTPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0xf) << 16 | FC_Paint;
                GP_CHARBLT16((ufix16 FAR *)dst_addr16, (ufix16 FAR *)cc_entry,
                        bb_width, bb_heigh);
#endif
            } else {
                dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                               bb_yorig * (FB_WIDTH >> WORDPOWER) +
                              (bb_xorig >> WORDPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0x1f) << 16 | FC_Paint;
                GP_CHARBLT32((ufix32 huge *)dst_addr32, (ufix32 FAR *)cc_entry,
                                bb_width, bb_heigh);    /*@WIN 04-15-92*/
            }
        } else {
        /*
         *  fill the character cache onto frame buffer with
         *  halftoning directly
         */

            BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, (fix)bb_width, (fix)bb_heigh, 1); //@WIN
#ifndef LBODR
            GP_BITBLT16_32(&FBX_Bmap, (fix)bb_xorig, (fix)bb_yorig,
                            (fix)bb_width, (fix)bb_heigh,       /*@WIN*/
                            FC_MERGE | HT_APPLY,
                           &SCC_Bmap, BM_XORIG, BM_YORIG);
#else
            GP_BITBLT16(&FBX_Bmap, bb_xorig, bb_yorig,
                         bb_width, bb_heigh,
                         FC_MERGE | HT_APPLY,
                        &SCC_Bmap, BM_XORIG, BM_YORIG);
#endif
                                                      /* @HT HTB_Bmap */
        }   /* if   */
} /* draw_cache_page */


/* CIRL: Begin, 12/5/90, Danny */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_cache_cache()                                      *
 *                                                                      *
 *  Created By: Danny Lu, 12/5/90                                       *
 *                                                                      *
 *  Description: To fill the bitmap from cache to cache                 *
 *                                                                      *
 *  Parameters: 1. destination cache information                        *
 *              2. source cache information                             *
 *                                                                      *
 *  Called by:  ry_fill_shape() in ry_font.c                            *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_cache_cache(dest, src)
struct Char_Tbl  FAR *dest, FAR *src;
{
    fix16  org_x, org_y;
//  byte   FAR *sptr, FAR *dptr;                @WIN
    fix    DX, DY, W, H, SX, SY;
    struct bitmap DST, SRC;

    org_x = (fix16)GSptr->position.x - src->ref_x;
    org_y = (fix16)GSptr->position.y - src->ref_y;

#ifdef DBGfcc
    printf("org_x = %d, org_y = %d\n", org_x, org_y);
    printf("SRC: box_w = %d, box_h = %d\n", src->box_w, src->box_h);
    printf("DEST: box_w = %d, box_h = %d\n", dest->box_w, dest->box_h);
#endif

    if (org_x < 0) {
        W  = src->box_w + org_x;
        if (W <= 0)
            return;
        if (W > dest->box_w)
            W = dest->box_w;

        DX = 0;
        SX = -org_x;
    }
    else {
        if (org_x >= dest->box_w)
            return;
        if ((org_x + src->box_w) > dest->box_w)
            W = dest->box_w - org_x;
        else
            W = src->box_w;

        DX = org_x;
        SX = 0;
    }

    if (org_y < 0) {
        H  = src->box_h + org_y;
        if (H <= 0)
            return;
        if (H > dest->box_h)
            H = dest->box_h;

        DY = 0;
        SY = -org_y;
    }
    else {
        if (org_y >= dest->box_h)
            return;
        if ((org_y + src->box_h) > dest->box_h)
            H = dest->box_h - org_y;
        else
            H = src->box_h;

        DY = org_y;
        SY = 0;
    }

    SRC.bm_addr = (gmaddr)src->bitmap;
    SRC.bm_cols = (fix)src->box_w;
    SRC.bm_rows = (fix)src->box_h;
    SRC.bm_bpp  = 1;

    DST.bm_addr = (gmaddr)dest->bitmap;
    DST.bm_cols = (fix)dest->box_w;
    DST.bm_rows = (fix)dest->box_h;
    DST.bm_bpp  = 1;

#ifdef DBGfcc
    printf("BitBlt: ADDR = %lx, DX = %x, DY = %x, W = %x, H = %x, ADDR = %lx, SX = %x, SY = %x\n", DST.bm_addr, DX, DY, W, H, SRC.bm_addr, SX, SY);
#endif
    GP_CACHEBLT16(&DST, DX, DY, W, H, &SRC, SX, SY);

} /* fill_cache_cache() */
/* CIRL: End, 12/5/90, Danny */



/* ************* Image ************************************************ */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_seed_patt()                                        *
 *                                                                      *
 *  Parameters: 1. width  of image seed pattern                         *
 *              2. height of image seed pattern                         *
 *              3. number  of scanlines                                 *
 *              4. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  scan_conversion()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_seed_patt(image_type, seed_index, sp_width, sp_heigh, no_lines, scanline)
ufix                    image_type;                             /* 05-25-89 */
fix                     seed_index;
fix                     sp_width;
fix                     sp_heigh;
fix                     no_lines;
SCANLINE            FAR *scanline;
{
        struct bitmap           FAR *isp_desc;
        ULONG_PTR *old_ptr;   /*@WIN*/
        fix                     i, FAR *ptr;
        fix16                   FAR *ptr16;

#ifdef  DBG
    printf("fill_seed_patt:   %x %x %x  (%x)\n",
           sp_width, sp_heigh, no_lines, seed_index);
#endif
        if (FB_busy) {
           if(alloc_gcb(GCB_SIZE2) != NIL) {
              old_ptr = gcb_ptr++;
              *gcb_ptr++ = FILL_SEED_PATT;
              *gcb_ptr++ = (fix )image_type;
              *gcb_ptr++ = seed_index;
              *gcb_ptr++ = sp_width;
              *gcb_ptr++ = sp_heigh;
              *gcb_ptr++ = no_lines;
              put_scanline(no_lines, scanline);
              *old_ptr = (ULONG_PTR)gcb_ptr;               /*@WIN*/
              return;
           }
        }


        ISP_Repeat = -1;

        isp_desc = &ISP_Bmap[seed_index];
        SP_Width = sp_width;                                    /* @IMAGE-2 */
        SP_Heigh = sp_heigh;                                    /* @IMAGE-2 */

        if (image_type == F_TO_PAGE) {                          /* 05-25-89 */
           BM_ENTRY(ISP_Bmap[seed_index],                       /* @IMAGE-1 */
                    ISP_BASE + ISP_SIZE * seed_index,
                    BM_BOUND(sp_width), sp_heigh, 1)

    /*  clear the image seed pattern  */
           ptr = (fix FAR *) isp_desc->bm_addr;                     /* 10-06-88 */
           i= SP_Heigh * (BM_BOUND(SP_Width) >> 5);
           while(i--)
                *ptr++ = 0L;

#ifdef  DBGscanline
   get_scanlist(0, no_lines, scanline);
#endif
    /*  fill scanlines onto the image seed pattern  */
           GP_SCANLINE32(isp_desc,
                         FC_SOLID,
                         BM_YORIG, no_lines, scanline);
        } else {
           BM_ENTRY(ISP_Bmap[seed_index],                       /* @IMAGE-1 */
                    ISP_BASE + ISP_SIZE * seed_index,
                    CC_BOUND(sp_width), sp_heigh, 1)

        /*  clear the image seed pattern  */
           ptr16 = (fix16 FAR *) isp_desc->bm_addr;                 /* 10-06-88 */
           i= SP_HEIGH * (SP_WIDTH >> 4);
           while(i--)
                 *ptr16++ = 0L;
        /*  fill scanlines onto the image seed pattern  */
           GP_SCANLINE16(isp_desc,
                         FC_SOLID,
                         BM_YORIG, no_lines, scanline);
        }

/*      seed_flag = 0; */

}


/* ********************************************************************
 *
 *  Function:   init_image_page(), clear image clipping mask buffer
 *
 *  Parameters: 1. bounding box Xorig
 *              2. bounding box Yorig
 *              3. bounding box Width
 *              4. bounding box Heigh
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
init_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
{
        fix     i, FAR *ptr;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
      printf("init_image_page()..\n");
      printf("bb_x=%lx, bb_y=%lx, bb_w=%lx, bb_h=%lx\n",
              bb_xorig, bb_yorig, bb_width, bb_heigh);
#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE2) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = INIT_IMAGE_PAGE;
        *gcb_ptr++ = bb_xorig;
        *gcb_ptr++ = bb_yorig;
        *gcb_ptr++ = bb_width;
        *gcb_ptr++ = bb_heigh;
        *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
        return;
    }
  }
    /*  update maximum expansion width for image operation  */
    if (ISP_Repeat != RP_Width)                         /* GVC-V3 11-01-88 */
    {
        ISP_Repeat = RP_Width;

        for (HTB_Expand = RP_Width; (HTB_Expand << 1) < HTB_XMAX;
             HTB_Expand = HTB_Expand << 1)
        {
            if (HTB_Expand & BM_PIXEL_MASK)
                continue;

            if (HTB_Expand >= SP_Width)
                break;
        }

        if ((HTB_Expand << 1) < HTB_XMAX)
        {
            HTB_Modula = HTB_Expand;
            HTB_Expand = HTB_Expand << 1;
        }
        else
        {
            HTB_Modula = FB_WIDTH;
            HTB_Expand = FB_WIDTH;
        }
    }

    /*  record x, y origin of CMB  */
    CMB_Xorig = bb_xorig;
    CMB_Yorig = bb_yorig;

    BB_Xorig = bb_xorig;
    BB_Yorig = bb_yorig;
    BB_Width = bb_width;
    BB_Heigh = bb_heigh;

    BM_ENTRY(CMB_Bmap, CMB_BASE, WORD_ALIGN(BB_Width), BB_Heigh, 1)

    /*  clear clipping mask buffer  */
        ptr = (fix FAR *)CMB_BASE;                       /* 10-06-88 */
        i = BB_Heigh * (BB_Width >> 5);
        while(i--)
           *ptr++ = 0;
} /* init_image_page */


/* ********************************************************************
 *
 *  Function:   clip_image_page(), fill image clipping mask buffer
 *
 *  Parameters: 1. scanline starting y_coordinate
 *              2. # of scanlines
 *              3. pointer to scanline table
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
clip_image_page(ys_lines, no_lines, scanline)
fix                     ys_lines;
fix                     no_lines;
SCANLINE           FAR *scanline;
{
        fix     no_segts;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
   printf("clip_image_page()  ");
   printf("%x, %x, %lx\n", ys_lines, no_lines, scanline);
#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE2) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = CLIP_IMAGE_PAGE;
        *gcb_ptr++ = ys_lines;
        *gcb_ptr++ = no_lines;
        put_scanline(no_lines, scanline);
        *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
        return;
    }
  }
    if ((no_segts = conv_SL(no_lines, scanline,
                            BB_Xorig, BB_Yorig, BB_Width, BB_Heigh)) == 0)
        return;

    /*  setup clipping mask buffer from scanlines of clippath  */
    GP_SCANLINE32(&CMB_Bmap,                       /* GVC-V3 11-01-88 */
                   FC_SOLID,
                   ys_lines - BB_Yorig, no_lines, scanline);
} /* clip_image_page */


/* ********************************************************************
 *
 *  Function:   fill_image_page(), fill image seed pattern into page
 *              with image clipping mask buffer "AND" operation.
 *
 *  Parameters: 1. image seed index
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
/*fill_image_page(sp_index)
fix                     sp_index;*/
fill_image_page(isp_index)              /* 3-13-91, Jack */
fix16                   isp_index;      /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap  FAR *isp_desc;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("fill_image_page:  %x \n", sp_index);
#endif
    if(GCB_count)
       flush_gcb(TRUE);
    /*  expand halftone before rendering onto frame buffer  */
    if (ISP_Flag == HT_CHANGED)                                 /* @IMAGE-1 */
    {
        ISP_Flag =  HT_UPDATED;

        HTB_Xmax = HTB_Expand;                                  /* @IMAGE-1 */
        expand_halftone();
        HTB_Xmax = HTB_XMAX;                                    /* @IMAGE-1 */
    }

/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        GP_PATBLT_M(&FBX_Bmap, nd_point->SAMPLE_BB_LX,
                               nd_point->SAMPLE_BB_LY,
                     SP_Width, SP_Heigh,                (* GVC-V3 11-01-88 *)
                     FC_Paint, isp_desc);
(*                     isp_desc, BM_XORIG, BM_YORIG);*)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {
        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        //GP_PATBLT_M(&FBX_Bmap, isp->bb_x, isp->bb_y,  @WINFLOW
        //           SP_Width, SP_Heigh,
        //           FC_Paint, isp_desc);
        if (bGDIRender)
            // DJC GDIBitmap(isp->bb_x, isp->bb_y,
            // DJC           SP_Width, SP_Heigh, (ufix16)FC_Paint,
            // DJC            PROC_PATBLT_M, (LPSTR)isp_desc);
            ; // DJC
        else
            GP_PATBLT_M(&FBX_Bmap, isp->bb_x, isp->bb_y,
                       SP_Width, SP_Heigh,
                       FC_Paint, isp_desc);
    }   /* for, 3-13-91, Jack */
} /* fill_image_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   draw_image_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT FOR RISC)  *
 *              2. x origin of bounding box             (NOT FOR RISC)  *
 *              3. width  of bounding box               (NOT FOR RISC)  *
 *              4. height of bounding box               (NOT FOR RISC)  *
 *              5. index  of sample list                                *
 *                                                                      *
 *  Called by:  op_image(), imagemask_shape()                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
/*draw_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh, sp_index)*/
draw_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh, isp_index) /* 3-13-91, Jack */
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
/*fix                     sp_index;*/
fix16                   isp_index;      /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap  FAR *isp_desc;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("draw_image_page:  %x %x %x %x  %x\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, sp_index);
#endif

    if(GCB_count)
       flush_gcb(TRUE);


    /*  update maximum expansion width for image operation  */
    if (ISP_Repeat != RP_Width)                         /* GVC-V3 11-01-88 */
    {
        ISP_Repeat =  RP_Width;

        for (HTB_Expand = RP_Width; (HTB_Expand << 1) < HTB_XMAX;
             HTB_Expand = HTB_Expand << 1)
        {
            if (HTB_Expand & BM_PIXEL_MASK)
                continue;

            if (HTB_Expand >= SP_Width)
                break;
        }

        if ((HTB_Expand << 1) < HTB_XMAX)
        {
            HTB_Modula = HTB_Expand;
            HTB_Expand = HTB_Expand << 1;
        }
        else
        {
            HTB_Modula = FB_WIDTH;
            HTB_Expand = FB_WIDTH;
        }
    }

    /*  expand halftone before rendering onto frame buffer  */
    if (ISP_Flag == HT_CHANGED)                                 /* @IMAGE-1 */
    {
        ISP_Flag =  HT_UPDATED;

        HTB_Xmax = HTB_Expand;                                  /* @IMAGE-1 */
        expand_halftone();
        HTB_Xmax = HTB_XMAX;                                    /* @IMAGE-1 */
    }

/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        GP_PATBLT(&FBX_Bmap, nd_point->SAMPLE_BB_LX,
                             nd_point->SAMPLE_BB_LY,
                   SP_Width, SP_Heigh,                  (* GVC-V3 11-01-88 *)
                   FC_Paint, isp_desc);
(*                   isp_desc, BM_XORIG, BM_YORIG); *)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {

        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        //GP_PATBLT(&FBX_Bmap, isp->bb_x, isp->bb_y,    @WINFLOW
        //           SP_Width, SP_Heigh,
        //           FC_Paint, isp_desc);
        if (bGDIRender)
            // DJC GDIBitmap(isp->bb_x, isp->bb_y,
            // DJC          SP_Width, SP_Heigh, (ufix16)FC_Paint,
            // DJC         PROC_PATBLT, (LPSTR)isp_desc);
            ; // DJC
        else
            GP_PATBLT(&FBX_Bmap, isp->bb_x, isp->bb_y,
                     SP_Width, SP_Heigh,
                     FC_Paint, isp_desc);

    }   /* for, 3-13-91, Jack */

} /* draw_image_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_image_cache()                                      *
 *                                                                      *
 *  Parameters: 1. address of character cache                           *
 *              2. width  of character cache                            *
 *              3. height of character cache                            *
 *              4. index  of sample list                                *
 *                                                                      *
 *  Called by:  imagemask_shape()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
/*fill_image_cache(cc_entry, cc_width, cc_heigh, sp_index)*/
fill_image_cache(cc_entry, cc_width, cc_heigh, isp_index) /* 3-13-91, Jack */
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
/*fix                     sp_index;*/
fix16                   isp_index;     /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap      FAR *isp_desc;
/*  ufix32   i, j, data, *ptr; */
    fix                width, heigh;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("fill_image_cache: %lx %x %x  %x\n",
           cc_entry, cc_width, cc_heigh, isp_index);
#endif

        if(GCB_count)
          flush_gcb(TRUE);

/*
 *      if (seed_flag == 0) {
 *          for (i = 0; i < 16; i++) {
 *              ptr = (ufix32 *)ISP_Bmap[i].bm_addr;
 *              for (j = 0; j < ISP_Bmap[i].bm_rows; j++) {
 *                  data = (*ptr << 16) + (*ptr >> 16);
 *                  *ptr++ = data;
 *                  data = (*ptr << 16) + (*ptr >> 16);
 *                  *ptr++ = data;
 *              }
 *          }
 *          seed_flag = 1;
 *      }
 */

    BM_ENTRY(SCC_Bmap, cc_entry, cc_width, cc_heigh, 1)
/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        width = MIN(SP_Width, cc_width-nd_point->SAMPLE_BB_LX); (*06/02/89 MS*)
        heigh = MIN(SP_Heigh, cc_heigh-nd_point->SAMPLE_BB_LY); (*06/02/89 MS*)
        GP_PATBLT_C(&SCC_Bmap, nd_point->SAMPLE_BB_LX,
                               nd_point->SAMPLE_BB_LY,
                     width, heigh,
                (*   SP_Width, SP_Heigh,                          06/02/89 MS*)
                     FC_MERGE, isp_desc);
(*                     isp_desc, BM_XORIG, BM_YORIG); *)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {
        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        width = MIN(SP_Width, cc_width-isp->bb_x);
        heigh = MIN(SP_Heigh, cc_heigh-isp->bb_y);
        GP_PATBLT_C(&SCC_Bmap, isp->bb_x,
                               isp->bb_y,
                     width, heigh,
                     FC_MERGE, isp_desc);
    }   /* for, 3-13-91, Jack */

} /* fill_image_cache */


/* Following 2 routines for stroke improvements  -jwm, 3/18/21, -begin- */

extern void do_fill_box ();

void fill_box (ul_coord, lr_coord)
struct coord_i FAR *ul_coord, FAR *lr_coord;
{
    struct coord_i      FAR *tmp_coord;
    ULONG_PTR *old_ptr;                /*@WIN*/

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = FILL_BOX;
            tmp_coord = (struct coord_i FAR *) gcb_ptr;
            *tmp_coord++ = *ul_coord;
            *tmp_coord++ = *lr_coord;
            gcb_ptr =  (ULONG_PTR *)tmp_coord;         /*@WIN*/
            *old_ptr = (ULONG_PTR)gcb_ptr;                /*@WIN*/
            return;
            }
        }
    else
        do_fill_box (ul_coord, lr_coord);

}



extern void do_fill_rect ();

void fill_rect (rect1)
struct line_seg_i FAR *rect1;
{
    struct line_seg_i   FAR *tmp_line_seg;
    ULONG_PTR *old_ptr;        /*@WIN*/

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = FILL_RECT;
            tmp_line_seg = (struct line_seg_i FAR *) gcb_ptr;
            *tmp_line_seg++ = *rect1;
            gcb_ptr =  (ULONG_PTR *)tmp_line_seg;      /*@WIN*/
            *old_ptr = (ULONG_PTR)gcb_ptr;        /*@WIN*/
            return;
            }
        }
    else
        do_fill_rect (rect1);

}
/*  -jwm, 3/18/21, -end- */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   gwb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of space of GWB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
gwb_space(gwb_size)
fix32              far *gwb_size;
{
        *gwb_size = GWB_SIZE;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   ccb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of address of CCB                            *
 *              2. pointer of space of CCB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
ccb_space(ccb_base, ccb_size)
gmaddr            far  *ccb_base;
fix32             far  *ccb_size;
{
        *ccb_base = CCB_BASE;
        *ccb_size = CCB_SIZE;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   cmb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of space of CMB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
cmb_space(cmb_size)
fix32              far *cmb_size;
{
        *cmb_size = CMB_SIZE;
}



/* ******************************************************************** *
 *                                                                      *
 *  Function:   get_fontdata()                                          *
 *                                                                      *
 *  Parameters: 1. address of fontdata                                  *
 *              2. pointer of fontdata buffer                           *
 *              3. length  of fontdata                                  *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
get_fontdata(fontdata, buffer, length)
gmaddr          fontdata;
ufix8          huge *buffer;    /*@WIN 04-20-92 */
ufix            length;
{
        ufix8  FAR *src, huge *dst;
        ufix    temp;

#ifdef  DBGfontdata
   printf("get_fontdata()\n");
   printf("dest addr = %lx, src addr = %lx, length = %d\n",
           buffer, fontdata, length);
#endif
        temp = length;
        src = (ufix8 FAR *) fontdata;
        dst = buffer;    /* @WIN 04-20-92 */
        while (length--)
           *dst++ = *src++;

#ifdef  DBGfontdata
        {
           ubyte FAR *ptr;
           ufix  i, j;

           ptr = buffer;
           i = temp;
           j = 0;
           printf("\nfontdata1:\n ");
           while(i-- > 0){
             j++;
             if(j>=14) {
                j = 0;
                printf("\n ");
             }
             printf("%x ", *ptr++);
           }
        }
#endif
        return;

}

/* ******************************************************************** *
 *                                                                      *
 *  Function:   get_fontcache()                                         *
 *                                                                      *
 *  Parameters: 1. address of fontcache                                 *
 *              2. pointer of fontcache buffer                          *
 *              3. length  of fontcache                                 *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
get_fontcache(fontcache, buffer, length)
gmaddr          fontcache;
ufix8          FAR *buffer;
ufix            length;
{
        ufix8  FAR *src, FAR *dst;

#ifdef DBG
   printf("get_fontcache()\n");
   printf("dest addr = %lx, src addr = %lx, length = %d\n",
           buffer, fontcache, length);
#endif
        src = (ufix8 FAR *) fontcache;
        dst = (ufix8 FAR *) buffer;
        while(length--)
                *dst++ = *src++;
        return;

}

/* ******************************************************************** *
 *                                                                      *
 *  Function:   put_fontcache()                                         *
 *                                                                      *
 *  Parameters: 1. address of fontcache                                 *
 *              2. pointer of fontcache buffer                          *
 *              3. length  of fontcache                                 *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
put_fontcache(fontcache, buffer, length)
gmaddr          fontcache;
ufix8          FAR *buffer;
ufix            length;
{
        ufix8  FAR *src, FAR *dst;

#ifdef DBG
   printf("put_fontcache()\n");
#endif
        src = (ufix8 FAR *) buffer;
        dst = (ufix8 FAR *) fontcache;
        while(length--)
                *dst++ = *src++;
        return;

}


/* *********************************************************************
 *
 *  convert scanline from device coordinate into GWB coordinate
 *
 *    - Conv_SL     (NO, SL, BB_X, BB_Y, BB_W, BB_H);
 *    fix       far   conv_SL(fix, SCANLINE near *, fix, fix, fix, fix);
 * ********************************************************************* */

fix conv_SL(no_lines, scanlist, bb_xorig, bb_yorig, bb_width, bb_heigh)
fix                     no_lines;
SCANLINE                FAR *scanlist;
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
{
        fix             no_segts, xs, xe;
        SCANLINE        FAR *scan, FAR *putptr;

#ifdef DBG
   printf("conv_SL()..\n");
#endif

        no_segts = 0;
        scan = scanlist;
        putptr = scanlist;
   /*
    * convert scanline
    */
        while(no_lines--) {
            while( (xs = *scan++) != (SCANLINE)END_OF_SCANLINE ) {
                xs -= bb_xorig;
                xe = *scan++ - bb_xorig;
                if ((xs < bb_width) && (xe >= 0)) {
                   *putptr++ = (xs >= 0) ? xs : 0;
                   *putptr++ = (xe >= bb_width) ? (bb_width -1) : xe;
                   no_segts++;
                }
           }
           *putptr++ = (SCANLINE)xs;
        }
        *putptr = (SCANLINE)END_OF_SCANLINE;
        return(no_segts);
} /* conv_SL */


/* **********************************************************************
 *
 *  put_bitmap() : copy bitmap from source to destination
 *
 *  void      near  put_bitmap(gmaddr, ufix far *, fix, fix);
 * ********************************************************************** */
void      near  put_bitmap(dest_addr, src_addr, width, heigh)
gmaddr          dest_addr;
ufix32  far       *src_addr;    /* ufix => ufix32 @WIN */
fix             width, heigh;
{
        ufix    length;

#ifdef DBG
   printf("put_bitmap()..\n");
#endif

        length = width * BM_BYTES(heigh);

#ifdef DBG1
   {
      fix     i, j, k;
      ufix16  FAR *sptr, temp;

      printf("  length = %ld\n",length);
      sptr = (ufix16 FAR *)src_addr;
      for(i=0; i<width; i++){
        printf("\n");
        for(j=0; j< BM_WORDS(heigh); j++)
          printf("%x ", *sptr++);
      }
   }
#endif
        lmemcpy((ufix8 FAR *)dest_addr, (ufix8 FAR *)src_addr, length); /*@WIN*/
        return;
} /* put_bitmap */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\gopr.c ===
/*
 * Copyrigqht (c) 1989,90 Microsoft Corporation

 */
/**********************************************************************
 *
 *      Name:       gopr.c
 *
 *      Purpose:    This file contains routines to process the graphics
 *                  operators.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      1.0         12/24/87    Performance enhancement:
 *                              1.@PRE_CLIP
 *                                pre-clipping for fixed-point
 *                                arithmatics
 *                  1/7/88      @RECT_I:
 *                              integer polygon structure
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/15/88     @PAGE_TYPE: page type selection
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  5/19/88     update initial value for calculating
 *                              path bounding box
 *                  5/20/88     limit check for op_framedevice
 *                  5/23/88     @DEVICE: update framedevice & nulldevice
 *                              for correct operation under gsave/grestore.
 *                              append 4 fields in dev_hdr: width, hight,
 *                              chg_flg, and nuldev_flg.
 *                  5/23/88     @PFALL: copy current path to a working path
 *                              for dumpping all nodes
 *                  6/02/88     @DFL_CLP: default clip in SFX format
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int   ==> sfix_t, for short fixed real
 *                                           fix, for integer
 *                                 short ==> fix
 *                              3) long  ==> long32, for parameter
 *                              4) iwidth8 * 8 ==> I2SFX(iwidth8)
 *                                 iheight * 8 ==> I2SFX(iheight)
 *                                 ux - 8 ==> ux - ONE_SFX
 *                                 uy - 8 ==> uy - ONE_SFX
 *                              5) add compiling option: LINT_ARGS
 *                              6) introduce ATTRIBUTE_SET
 *                  7/20/88     @ARC_POP: pop operand stack for degernated
 *                              arc in arc_process
 *                  7/20/88     @PAGE_CNT: update page count for each print
 *                  7/22/88     @PRT_FLAG: set SHOWPAGE/COPYPAGE flag for
 *                              lower level graphics primitives
 *                  8/11/88     remove continuation mark "\" in routines:
 *                              op_arcto
 *      3.0         8/13/88     @SCAN_EHS: scan_conversion enhancement
 *                  8/18/88     @OUT_PAGE: enhancement of out_page checking
 *                  8/30/88     move in erasepage() from "shape.c"
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and set its value only at
 *                              necessary time instead of each op_stroke command
 *                  10/27/88    change routine check_infinity() to
 *                              macro CHECK_INFINITY()
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/25/88    @STK_CHK: check if operand stack no free space
 *                  11/30/88    clip_process(): call init_edgetable before
 *                              shape_approximation
 *                  12/02/88    arc_process(), op_arcto(): modify OUTPAGE check
 *                  12/14/88    clip_process(): init. values of clip box
 *                  12/15/88    revise inverse_transform(): directly solve
 *                              equations instead of inverse_ctm[]
 *                  1/25/89     op_framedevice(): for compatability --
 *                              1. add rangecheck on matrix
 *                              2. modify values of limit check
 *                              3. ignore invalid access check on matrix
 *                  1/28/89     @REM_STK: not change contains of operand stack
 *                              when error occurs
 *                  1/30/89     op_strokepath(): update currentpoint
 *                  1/31/89     op_arcto(): delete dirty code
 *                                          change arc to arc_to_bezier
 *                                          check small cross angle condition
 *                  1/31/89     @STK_OVR: push values to operand stack as many
 *                              as possible until overflow
 *                  5/26/89     st_frameto_printer(): add one more parameter
 *                              "manfeed" for manualfeed feature
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  1/15/90     st_frametoprinter(): modify input interface for
 *                              LW-V47 compatability; left margins changed from
 *                              bytes to bits. Note: 1pp also needs to be
 *                              modified.
 *                  2/20/90     fix @NODE bug in op_reversepath()
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  8/31/90     ccteng; include stdio.h, remove dprintf
 *                  11/29/90    check undefine error, Jack
 *                  12/4/90     @CPPH: fix limitcheck error of clippath
 *                              op_clippath(): save clipping trapezoids in
 *                                 cp_path, defined in path_table[], instead
 *                                 of transforming it to path directly.
 *                              fill_clippath(): new created for op_fill/eofill
 *                              op_initclip(): free old clipping path only it
 *                                 does not used by current path(cp_path).
 *                              op_fill & op_eofill(): try to fill clipping
 *                                 trapezoids (call fill_clippath) directly
 *                                 instead of normal filling procedure.
 *                              op_pathbbox(): set current point as init value
 *                                 of bbox, since path->head may be NULLP.
 *                  1/7/91      change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *                  1/11/91     op_pathbbox(): for charpath, current point is
 *                              not a real node, pathbbox can not use it as
 *                              init value.
 *                  2/22/91     op_flattenpath(): fix the bug of an
 *                              un-initialized variable vlist.
 *                  2/28/91     op_stroke(): fix the bug of ignoring stroke
 *                              when 0 scaling in both x and y which occurs on
 *                              12-12-90 update.
 *                  3/20/91     refine the tolerance check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 *                  3/26/91     op_reversepath(): fix the bug of an
 *                              uninitialized variable vlist.
 *                  4/17/91     clip_process(): limit check for edge table
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "fillproc.h"                   /* 8-1-90 Jack Liaw */
#include "fillproc.ext"                 /* 8-1-90 Jack Liaw */
#include "font.h"
#include "font.ext"
#include "stdio.h"

/* grayscale 8-1-90 Jack Liaw */
extern ufix32 highmem;
extern gmaddr FBX_BASE; //DJC @WIN  put back , now used...

/* #define GV_flag 1    @GEI */
/* papertype changed 10-11-90, JS */
//DJC ufix32  last_frame = 0;

/* ********** static variables ********** */
/* type of print_page, for lower level graphics primitives @PRT_FLAG */
static bool near print_page_flag;
static byte cur_gray_mode = MONODEV;    /* @GRAY */

/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near moveto_process(fix);
static void near lineto_process(fix);
static void near arc_process(fix);
static struct coord * near endpoint (long32, long32, long32, long32, long32,
                               long32, long32, ufix);
static void near curveto_process(fix);
static void near free_newpath(void);
static void near clip_process(fix);
static void near erasepage(void);
static fix near fill_clippath(void);                   /* @CPPH */

#else
/* for no type checks of the parameters in function declarations */
static void near moveto_process();
static void near lineto_process();
static void near arc_process();
static struct coord * near endpoint ();
static void near curveto_process();
static void near free_newpath();
static void near clip_process();
static void near erasepage();
static fix near fill_clippath();                   /* @CPPH */
#endif

/************************************************************************
 * This module is to implement newpath operator.
 * Syntax :        -   newpath   -
 *
 * TITLE:       op_newpath
 *
 * CALL:        op_newpath()
 *
 * INTERFACE:   interpreter(op_newpath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_newpath()
{
        /* free current path */
        free_path();

        /* set no current point */
        F2L(GSptr->position.x) = F2L(GSptr->position.y) = NOCURPNT;

        return(0);
}


/************************************************************************
 * This module is to implement currentpoint operator.
 * Syntax :        -   currentpoint   x y
 *
 * TITLE:       op_currentpoint
 *
 * CALL:        op_currentpoint()
 *
 * INTERFACE:   interpreter(op_currentpoint)
 *
 * CALLS:       inverse_transform
 ************************************************************************/
fix
op_currentpoint()
{
        struct coord FAR *p;
        union  four_byte x4, y4;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* Get current position, transform to user's space,
         * and push to operand stack
         */
        /* check infinity 10/29/88 */
        if ((F2L(GSptr->position.x) == F2L(infinity_f)) ||
            (F2L(GSptr->position.y) == F2L(infinity_f))) {
                x4.ff = infinity_f;
                y4.ff = infinity_f;
        } else {
                p = inverse_transform(F2L(GSptr->position.x),
                                      F2L(GSptr->position.y));

                if(ANY_ERROR()) return(0);      /* @REM_STK */

                x4.ff = p->x;
                y4.ff = p->y;
        }

        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

        return(0);
}


/************************************************************************
 * This module is to process moveto & rmoveto operators.
 *
 * TITLE:       moveto_process
 *
 * CALL:        moveto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type (MOVETO, RMOVETO)
 *
 * INTERFACE:   op_moveto, op_rmoveto
 *
 * CALLS:       transform, moveto
 ************************************************************************/
static void near moveto_process(opr_type)
fix     opr_type;
{
        real32  x, y, px, py;
        struct coord FAR *p;
        struct object_def FAR *obj_x, FAR *obj_y;

        if(opr_type == RMOVETO ){
                /* check nocurrentpoint error */
                if(F2L(GSptr->position.x) == NOCURPNT){
                        ERROR(NOCURRENTPOINT);
                        return;
                }
        }

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_y = GET_OPERAND(0);
        obj_x = GET_OPERAND(1);

        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */

        /* Transform coordinates and set up MOVETO node */
        p = transform(F2L(x), F2L(y));

        if(opr_type == MOVETO){
                /* process op_moveto */
                moveto(F2L(p->x), F2L(p->y));
        }
        else{
                /* opr_type == RMOVETO, process op_rmoveto */
                px = p->x - GSptr->ctm[4] + GSptr->position.x;
                py = p->y - GSptr->ctm[5] + GSptr->position.y;
                moveto(F2L(px), F2L(py));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(2);

}


/************************************************************************
 * This module is to implement moveto operator.
 * Syntax :        x y   moveto   -
 *
 * TITLE:       op_moveto
 *
 * CALL:        op_moveto()
 *
 * INTERFACE:   interpreter(op_moveto)
 *
 * CALLS:       moveto_process
 ************************************************************************/
fix
op_moveto()
{
        moveto_process(MOVETO);
        return(0);
}


/************************************************************************
 * This module is to implement rmoveto operator.
 * Syntax :        dx dy   rmoveto   -
 *
 * TITLE:       op_rmoveto
 *
 * CALL:        op_rmoveto()
 *
 * INTERFACE:   interpreter(op_rmoveto)
 *
 * CALLS:       moveto_process
 ************************************************************************/
fix
op_rmoveto()
{
        moveto_process(RMOVETO);
        return(0);

}


/************************************************************************
 * This module is to process lineto & rlineto operators.
 *
 * TITLE:       lineto_process
 *
 * CALL:        lineto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type (LINETO, RLINETO)
 *
 * INTERFACE:   op_lineto, op_rlineto
 *
 * CALLS:       transform, lineto
 ************************************************************************/
static void near lineto_process(opr_type)
fix     opr_type;
{
        real32  x, y, px, py;
        struct coord FAR *p;
        struct object_def FAR *obj_x, FAR *obj_y;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return;
        }

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_y = GET_OPERAND(0);
        obj_x = GET_OPERAND(1);

        /* Transform coordinates and set up MOVETO node */
        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */

        p = transform(F2L(x), F2L(y));

        if(opr_type == LINETO){
                /* process op_lineto */
                lineto(F2L(p->x), F2L(p->y));
        }
        else{
                /* opr_type == RLINETO,  process op_rlineto */
                px = p->x - GSptr->ctm[4] + GSptr->position.x;
                py = p->y - GSptr->ctm[5] + GSptr->position.y;
                lineto(F2L(px), F2L(py));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(2);

}


/************************************************************************
 * This module is to implement lineto operator.
 * Syntax :        x y   lineto   -
 *
 * TITLE:       op_lineto
 *
 * CALL:        op_lineto()
 *
 * INTERFACE:   interpreter(op_lineto)
 *
 * CALLS:       lineto_process
 ************************************************************************/
fix
op_lineto()
{
        lineto_process(LINETO);
        return(0);

}

/************************************************************************
 * This module is to implement rlineto operator.
 * Syntax :        dx dy   rlineto   -
 *
 * TITLE:       op_rlineto
 *
 * CALL:        op_rlineto()
 *
 * INTERFACE:   interpreter(op_rlineto)
 *
 * CALLS:       lineto_process
 ************************************************************************/
fix
op_rlineto()
{
        lineto_process(RLINETO);
        return(0);
}


/************************************************************************
 * This module is to process arc & arcn operators.
 *
 * TITLE:       arc_process
 *
 * CALL:        arc_process(direction)
 *
 * PARAMETER:   direction : CLKWISE, CNTCLK
 *
 * INTERFACE:   op_arc, op_arcn
 *
 * CALLS:       transform, arc, moveto, lineto
 ************************************************************************/
static void near arc_process(direction)
fix     direction;
{
        VX_IDX node;
        real32  x, y, r, ang1, ang2, lx, ly;
        struct coord FAR *p;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct object_def FAR *obj_x, FAR *obj_y, FAR *obj_r, FAR *obj_ang1, FAR *obj_ang2;

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_ang2 = GET_OPERAND(0);
        obj_ang1 = GET_OPERAND(1);
        obj_r = GET_OPERAND(2);
        obj_y = GET_OPERAND(3);
        obj_x = GET_OPERAND(4);

        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */
        GET_OBJ_VALUE(r, obj_r);        /* r = get_obj_value(obj_r); */
        GET_OBJ_VALUE(ang1, obj_ang1);  /* ang1 = get_obj_value(obj_ang1); */
        GET_OBJ_VALUE(ang2, obj_ang2);  /* ang2 = get_obj_value(obj_ang2); */

        /* Pre_draw a line if current point exist;
         *  Otherwise, create a MOVETO node
         */

        lx = x+r*(real32)cos(ang1*PI/(real32)180.0);
        ly = y+r*(real32)sin(ang1*PI/(real32)180.0);
        p = transform(F2L(lx), F2L(ly));

        if(F2L(GSptr->position.x) != NOCURPNT)
                lineto(F2L(p->x), F2L(p->y));
        else
                moveto(F2L(p->x), F2L(p->y));

        /* degenerated case handling */
        /* if (F2L(r) == F2L(zero_f)) {    3/20/91; scchen */
        if (IS_ZERO(r)) {
                POP(5);                 /* @ARC_POP */
                return;
        }

        /* Convert arc to some curvetoes */
        vlist = arc(direction,F2L(x),F2L(y),F2L(r),F2L(ang1),F2L(ang2));

        if( ANY_ERROR() == LIMITCHECK ){
                return;                         /* @REM_STK */
        }

        /* append approximated arc into current path */
        /* if (vlist->head != NULLP) { @NODE */
        if (vlist != NULLP) {
            VX_IDX  ivtx;
            struct nd_hdr FAR *vtx;

            sp = &node_table[path_table[GSptr->path].tail];
                    /* pointer to current subpath */
            node = sp->SP_TAIL;
            /* @NODE
             * node_table[node].next = vlist->head;
             * sp->SP_TAIL = vlist->tail;
             */
            node_table[node].next = vlist;
            sp->SP_TAIL = node_table[vlist].SP_TAIL;

            /* set sp_flag @SP_FLG 1/8/88 */
            sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
            if (!(sp->SP_FLAG & SP_OUTPAGE)) {               /* 12/02/88 */
                /* for (ivtx = vlist->head; ivtx!=NULLP; @NODE */
                for (ivtx = vlist; ivtx!=NULLP; /* check OUTPAGE flag */
                     ivtx = vtx->next) {
                    vtx = &node_table[ivtx];
                    /* set sp_flag @SP_FLG */
                    if (out_page(F2L(vtx->VERTEX_X)) ||        /* @OUT_PAGE */
                        out_page(F2L(vtx->VERTEX_Y))) {
                            sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                            break;                        /* 12/02/88 */
                    } /* if */
                } /* for */
            } /* if */
        } /* if */

        /* Update current position */
        ang2 = ang2 * PI /(real32)180.0;
        lx = x+r*(real32)cos(ang2);
        ly = y+r*(real32)sin(ang2);
        p = transform(F2L(lx), F2L(ly));
        GSptr->position.x = p->x;
        GSptr->position.y = p->y;

        POP(5);

}


/************************************************************************
 * This module is to implement arc operator.
 * Syntax :        x y r ang1 ang2   arc   -
 *
 * TITLE:       op_arc
 *
 * CALL:        op_arc()
 *
 * INTERFACE:   interpreter(op_arc)
 *
 * CALLS:       arc_process
 ************************************************************************/
fix
op_arc()
{
        arc_process(CNTCLK);
        return(0);
}


/************************************************************************
 * This module is to implement arcn operator.
 * Syntax :        x y r ang1 ang2   arcn   -
 *
 * TITLE:       op_arcn
 *
 * CALL:        op_arcn()
 *
 * INTERFACE:   interpreter(op_arcn)
 *
 * CALLS:       arc_process
 ************************************************************************/
fix
op_arcn()
{
        arc_process(CLKWISE);
        return(0);
}


/************************************************************************
 * This module is to implement arcto operator.
 * Syntax :        x1 y1 x2 y2 r   arcto   xt1 yt1 xt2 yt2
 *
 * TITLE:       op_arcto
 *
 * CALL:        op_arcto()
 *
 * INTERFACE:   interpreter(op_arcto)
 *
 * CALLS:       transform, arc, lineto
 ************************************************************************/
fix
op_arcto()
{
        VX_IDX node;
        ufix   direction;
        struct coord FAR *p=NULL;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct object_def FAR *obj_x1, FAR *obj_y1, FAR *obj_x2, FAR *obj_y2, FAR *obj_r;
        real32  cross, absr;
        real32  px0, py0, px1, py1;
        real32  dtx1, dty1, dtx2, dty2, delta;
        real32  dx, dy, dx2, dy2, dxy;
        real32  x0, y0, x1, y1, x2, y2, r;
        real32  rx0, ry0, ang1, ang2, xt1, yt1, xt2, yt2;
        union  four_byte  xt14, yt14, xt24, yt24;
        real32  tmpx, tmpy;     /* @FABS */
        real32  d, tmp;
        fix     NEG;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_r  = GET_OPERAND(0);
        obj_y2 = GET_OPERAND(1);
        obj_x2 = GET_OPERAND(2);
        obj_y1 = GET_OPERAND(3);
        obj_x1 = GET_OPERAND(4);

        /* Get values */
        GET_OBJ_VALUE(x1, obj_x1);      /* x1 = get_obj_value(obj_x1); */
        GET_OBJ_VALUE(y1, obj_y1);      /* y1 = get_obj_value(obj_y1); */
        GET_OBJ_VALUE(x2, obj_x2);      /* x2 = get_obj_value(obj_x2); */
        GET_OBJ_VALUE(y2, obj_y2);      /* y2 = get_obj_value(obj_y2); */
        GET_OBJ_VALUE(r, obj_r);        /* r  = get_obj_value(obj_r);  */

        /* check undefinedresult error */
        tmpx = x1 - x2;
        tmpy = y1 - y2;
        FABS(tmpx, tmpx);
        FABS(tmpy, tmpy);
        if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        /* current point */
        p = inverse_transform(F2L(GSptr->position.x), F2L(GSptr->position.y));
		if (p == NULL) {
                ERROR(UNDEFINEDRESULT);
				return (0);
		}
        x0 = p->x;
        y0 = p->y;


        /* Calculate arguments for arc, and join points with 2 tangent lines
         * compute root of arc (rx0, ry0) */
                /* Find end point of edge 1 */
                p = endpoint (F2L(x1), F2L(y1), F2L(x0), F2L(y0),
                              F2L(x2), F2L(y2), F2L(r), IN_POINT);
                px0 = p->x;
                py0 = p->y;

                /* Find end point of edge 2 */
                p = endpoint(F2L(x1), F2L(y1), F2L(x2), F2L(y2),
                             F2L(x0), F2L(y0), F2L(r), IN_POINT);
                px1 = p->x;
                py1 = p->y;

                /* compute root of arc (rx0, ry0) */
                tmpx = px0 - px1;
                tmpy = py0 - py1;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                        rx0 = px0;
                        ry0 = py0;
                }
                else{
                        dtx1 = x1 - px0;
                        dty1 = y1 - py0;
                        dtx2 = x1 - px1;
                        dty2 = y1 - py1;
                        delta = (dtx2*dty1 - dtx1*dty2);
                        FABS(tmpx, delta);
                        if( tmpx < (real32)5e-3 ){                /* ??? */
                            rx0 = x1;
                            ry0 = y1;
                        }else {
                            rx0 = (dty1*dty2*(py1-py0) + px1*dtx2*dty1 -
                                  px0*dtx1*dty2) / delta;
                            ry0 = (dtx1*dtx2*(px1-px0) + py1*dtx1*dty2 -
                                  py0*dtx2*dty1) / (- delta);
                        }
                }


        /* Compute join points (xt1, yt1), (xt2, yt2) */
                dx = x1 - x0;
                dy = y1 - y0;
                FABS (tmpx, dx);
                FABS (tmpy, dy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                     xt1 = x0;
                     yt1 = y0;
                }
                else{
                     if(tmpx < (real32)1e-4)dx = zero_f;
                     if(tmpy < (real32)1e-4)dy = zero_f;
                     dxy = dx * dy;
                     dx2 = dx * dx;
                     dy2 = dy * dy;
                     xt1 = (x0*dy2 + rx0 *dx2 - (y0-ry0) * dxy) / (dx2 + dy2);
                     yt1 = (y0*dx2 + ry0 *dy2 - (x0-rx0) * dxy) / (dx2 + dy2);
                }

                dx = x1 - x2;
                dy = y1 - y2;
                FABS (tmpx, dx);
                FABS (tmpy, dy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                     xt2 = x1;
                     yt2 = y1;
                }
                else{
                     if(tmpx < (real32)1e-4)dx = zero_f;
                     if(tmpy < (real32)1e-4)dy = zero_f;
                     dxy = dx * dy;
                     dx2 = dx * dx;
                     dy2 = dy * dy;
                     xt2 = (x2*dy2 + rx0 *dx2 - (y2-ry0) * dxy) / (dx2 + dy2);
                     yt2 = (y2*dx2 + ry0 *dy2 - (x2-rx0) * dxy) / (dx2 + dy2);
                }

                tmpx = rx0 - xt1;
                tmpy = ry0 - yt1;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if(tmpx < (real32)1e-4) {
                        if(yt1 > ry0) ang1 = (real32)( PI / 2.);
                        else          ang1 = (real32)(-PI / 2.);
                } else if (tmpy < (real32)1e-4) {
                        if(xt1 < rx0) ang1 = (real32) PI;
                        else          ang1 = zero_f;
                } else
                        ang1 = (real32)atan2((yt1-ry0) , (xt1-rx0));

                tmpx = rx0 - xt2;
                tmpy = ry0 - yt2;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if(tmpx < (real32)1e-4) {
                        if(yt2 > ry0) ang2 =  (real32)( PI / 2.0);
                        else          ang2 =  (real32)(-PI / 2.);
                } else if (tmpy < (real32)1e-4) {
                        if(xt2 < rx0) ang2 =  (real32)PI;
                        else          ang2 =  zero_f;
                } else
                        ang2 = (real32)atan2((yt2-ry0) , (xt2 - rx0));

        /* calculate cross product of edge1 and edge2
         * (rx0, ry0), (xt1, yt1)  cross (xt1, yt1), (xt2, yt2)
         * i.e. (xt1-rx0, yt1-ry0) cross (xt2-xt1, yt2-yt1)
         */
//      cross = (xt1-rx0)*DIFF(yt2-yt1) - (yt1-ry0)*DIFF(xt2-xt1);
        tmpx = xt2-xt1;                 // @WIN: fabs => FABS
        tmpy = yt2-yt1;
        FABS(tmpx, tmpx);
        FABS(tmpy, tmpy);
        cross = (xt1-rx0)* (tmpy < (real32)1e-4 ? (real32)0.0 : (yt2-yt1)) -
                (yt1-ry0)* (tmpx < (real32)1e-4 ? (real32)0.0 : (xt2-xt1));

        /* Create a preceeding edge and an arc */
        p = transform(F2L(xt1), F2L(yt1));
        lineto(F2L(p->x), F2L(p->y));

        /* (xt1, yt1) and (xt2, yt2) isn't co_point */
        FABS(tmpx, cross);
        if(tmpx > (real32)TOLERANCE){
            /*direction = (cross < zero_f) ? CLKWISE : CNTCLK ; 3/20/91; scchen*/
            direction = (SIGN_F(cross)) ? CLKWISE : CNTCLK ;

            ang1 = ang1 * (real32)180.0 / PI;
            ang2 = ang2 * (real32)180.0 / PI;
            FABS(absr, r);

            /* create a bezier curve */
            if(direction == CLKWISE)
                    NEG = -1;
            else
                    NEG = 1;

            d = NEG * (ang2-ang1);
            /*while (d < zero_f) d += (real32)360; 3/20/91; scchen */
            while (SIGN_F(d)) d += (real32)360.0;

            /* degernated case */
            FABS(tmp, d);
            if (tmp >= (real32)1e-3){  /* 1e-4 => 1e-3;  12/14/88 */
                  ang2 = ang1 + NEG * d;
            }

            vlist = arc_to_bezier (F2L(rx0), F2L(ry0),
                       F2L(absr), F2L(ang1),F2L(ang2));
                    /* arc routine is under user's space */

            if( ANY_ERROR() == LIMITCHECK ){
                    return(0);                  /* @REM_STK */
            }

            /* append approximated arc into current path */
            /* if (vlist->head != NULLP) { @NODE */
            if (vlist != NULLP) {
                VX_IDX  ivtx;
                struct nd_hdr FAR *vtx;

                sp = &node_table[path_table[GSptr->path].tail];
                        /* pointer to current subpath */
                node = sp->SP_TAIL;
                /* @NODE
                 * node_table[node].next = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                node_table[node].next = vlist;
                sp->SP_TAIL = node_table[vlist].SP_TAIL;

                /* set sp_flag @SP_FLG 1/8/88 */
                sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
                /*sp->SP_FLAG &= ~SP_OUTPAGE;    (*init. in page*) */
                if (!(sp->SP_FLAG & SP_OUTPAGE)) {               /* 12/02/88 */
                    /* for (ivtx = vlist->head; ivtx!=NULLP; @NODE */
                    for (ivtx = vlist; ivtx!=NULLP; /* check OUTPAGE flag */
                         ivtx = vtx->next) {
                            vtx = &node_table[ivtx];
                            /* set sp_flag @SP_FLG */
                            if (out_page(F2L(vtx->VERTEX_X)) ||
                                out_page(F2L(vtx->VERTEX_Y))) {
                                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                                break;                /* 12/02/88 */
                            }
                    } /* for */
                } /* if */
            } /* if */

        }

        /* Update current position */
        p = transform(F2L(xt2), F2L(yt2));
        GSptr->position.x = p->x;
        GSptr->position.y = p->y;

        POP(5);

        /* Return 2 join points: xt1, yt1, xt2, yt2 */
        xt14.ff = xt1;
        yt14.ff = yt1;
        xt24.ff = xt2;
        yt24.ff = yt2;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xt14.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yt14.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xt24.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yt24.ll);

        return(0);
}


/***********************************************************************
 *
 * TITLE:       endpoint
 *
 * CALL:        endpoint (x0, y0, x1, t1, x2, y2)
 *
 * PARAMETERS:  x0, y0, x1, y1, x2, y2 -- 3 coordinates
 *
 * INTERFACE:   linejoin
 *
 * CALLS:
 *
 * RETURN:      coordinate of a endpoint
 **********************************************************************/
static struct coord * near endpoint (lx0, ly0, lx1, ly1, lx2, ly2, ld, select)
long32    lx0, ly0, lx1, ly1, lx2, ly2, ld;
ufix    select;
{
        real32   x0, y0, x1, y1, x2, y2, d;
        real32   tx1, ty1, tx2, ty2, m, c;
        static  struct  coord p;        /* should be static */
        real32   f, dx, dy;
        real32  tmpx, tmpy;     /* @FABS */

        x0 = L2F(lx0);
        y0 = L2F(ly0);
        x1 = L2F(lx1);
        y1 = L2F(ly1);
        x2 = L2F(lx2);
        y2 = L2F(ly2);
        d  = L2F(ld);

        /* Compute 2 endpoints of the edge (x0, y0) --> (x1, y1) */
        tmpy = y1 - y0;
        FABS(tmpy, tmpy);
        if(tmpy < (real32)1e-4) {
                tx1 = tx2 = x0;
                ty1 = y0 + d;
                ty2 = y0 - d;
        } else {
                m = (x0 - x1) / (y1 - y0);
                c = d * (real32)sqrt(1 / (1 + m*m));
                tx1 = x0 + c;
                ty1 = y0 + m*c;
                tx2 = x0 - c;
                ty2 = y0 - m*c;
        }

        /* select the desired endpoint */

        dx = x2 - x0;
        dy = y2 - y0;
        FABS(tmpx, dx);
        FABS(tmpy, dy);
        if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)) {
             dx = one_f;
             dy = one_f;
        } else{
                if(tmpx < (real32)1e-4) dx = zero_f;
                if(tmpy < (real32)1e-4) dy = zero_f;
        }

        f = (tx1-x0)*dx+(ty1-y0)*dy;
        f = ((select == OUT_POINT) ? f : (real32)-1.0 * f);
        /* if (d < zero_f) f = -f; 3/20/91; scchen */
        if (SIGN_F(d)) f = -f;
        if (f <= zero_f) {
                p.x = tx1;
                p.y = ty1;
        } else {
                p.x = tx2;
                p.y = ty2;
        }

        return (&p);
}



/************************************************************************
 * This module is to process curveto & rcurve operators.
 *
 * TITLE:       curveto_process
 *
 * CALL:        curveto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type : CURVETO, RCURVETO
 *
 * INTERFACE:   op_curveto, op_rcurveto
 *
 * CALLS:       transform, curveto
 ************************************************************************/
static void near curveto_process(opr_type)
fix     opr_type;
{
        struct coord FAR *p;
        real32  dx1, dy1, dx2, dy2, dx3, dy3, x, y, temp_x, temp_y;
        struct object_def FAR *obj_x1, FAR *obj_y1, FAR *obj_x2, FAR *obj_y2, FAR *obj_x3, FAR *obj_y3;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return;
        }

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_y3 = GET_OPERAND(0);
        obj_x3 = GET_OPERAND(1);
        obj_y2 = GET_OPERAND(2);
        obj_x2 = GET_OPERAND(3);
        obj_y1 = GET_OPERAND(4);
        obj_x1 = GET_OPERAND(5);

        if(opr_type == CURVETO){
                /* process op_curveto */
                GET_OBJ_VALUE(x, obj_x3);       /* x = get_obj_value(obj_x3); */
                GET_OBJ_VALUE(y, obj_y3);       /* y = get_obj_value(obj_y3); */
                p = transform(F2L(x), F2L(y));
                dx3 = p->x;
                dy3 = p->y;
                GET_OBJ_VALUE(x, obj_x2);       /* x = get_obj_value(obj_x2); */
                GET_OBJ_VALUE(y, obj_y2);       /* y = get_obj_value(obj_y2); */
                p = transform(F2L(x), F2L(y));
                dx2 = p->x;
                dy2 = p->y;
                GET_OBJ_VALUE(x, obj_x1);       /* x = get_obj_value(obj_x1); */
                GET_OBJ_VALUE(y, obj_y1);       /* y = get_obj_value(obj_y1); */
                p = transform(F2L(x), F2L(y));
                dx1 = p->x;
                dy1 = p->y;
                curveto(F2L(dx1),F2L(dy1),F2L(dx2),F2L(dy2),F2L(dx3),F2L(dy3));
        }
        else{
                /* opr_type == RCURVETO, process op_rcurveto */

                temp_x = GSptr->position.x - GSptr->ctm[4];
                temp_y = GSptr->position.y - GSptr->ctm[5];

                GET_OBJ_VALUE(x, obj_x3);       /* x = get_obj_value(obj_x3); */
                GET_OBJ_VALUE(y, obj_y3);       /* y = get_obj_value(obj_y3); */
                p = transform(F2L(x), F2L(y));
                dx3 = p->x + temp_x;
                dy3 = p->y + temp_y;

                GET_OBJ_VALUE(x, obj_x2);       /* x = get_obj_value(obj_x2); */
                GET_OBJ_VALUE(y, obj_y2);       /* y = get_obj_value(obj_y2); */
                p = transform(F2L(x), F2L(y));
                dx2 = p->x + temp_x;
                dy2 = p->y + temp_y;

                GET_OBJ_VALUE(x, obj_x1);       /* x = get_obj_value(obj_x1); */
                GET_OBJ_VALUE(y, obj_y1);       /* y = get_obj_value(obj_y1); */
                p = transform(F2L(x), F2L(y));
                dx1 = p->x + temp_x;
                dy1 = p->y + temp_y;
                curveto(F2L(dx1),F2L(dy1),F2L(dx2),F2L(dy2),F2L(dx3),F2L(dy3));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(6);

}


/************************************************************************
 * This module is to implement curveto operator.
 * Syntax :        x1 y1 x2 y2 x3 y3   curveto   -
 *
 * TITLE:       op_curveto
 *
 * CALL:        op_curveto
 *
 * INTERFACE:   interpreter(op_curveto)
 *
 * CALLS:       curveto_process
 ************************************************************************/
fix
op_curveto()
{
        curveto_process(CURVETO);
        return(0);
}


/************************************************************************
 * This module is to implement rcurveto operator.
 * Syntax :        dx1 dy1 dx2 dy2 dx3 dy3   rcurveto   -
 *
 * TITLE:       op_rcurveto
 *
 * CALL:        op_rcurveto()
 *
 * INTERFACE:   interpreter(op_rcurveto)
 *
 * CALLS:       transform, curveto
 *
 ************************************************************************/
fix
op_rcurveto()
{
        curveto_process(RCURVETO);
        return(0);
}


/************************************************************************
 * This module is to implement closepath operator.
 * Syntax :        -   closepath   -
 *
 * TITLE:       op_closepath
 *
 * CALL:        op_closepath()
 *
 * INTERFACE:   interpreter(op_closepath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_closepath()
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;   /* index to node_table for vertex */

        /* Ignore closepath if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return(0);
                }
        }

        //DJC fix from history.log UPD020
        if (path->tail == NULLP) return(0);

        sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* Ignore ineffective closepath */
        if (vtx->VX_TYPE == CLOSEPATH) return(0);

        /* Create a CLOSEPATH node */
        /* Allocate a node */
        if((ivtx = get_node()) == NULLP){
                ERROR(LIMITCHECK);
                return(0);
        }
        vtx = &node_table[ivtx];

        /* Set up a CLOSEPATH node */
        vtx->VX_TYPE = CLOSEPATH;
        vtx->next = NULLP;

        /* Append this node to current_subpath */
        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        /* Set current position = head of current subpath */
        /* @NODE
         * vtx = &node_table[sp->SP_HEAD];
         * GSptr->position.x = vtx->VERTEX_X;
         * GSptr->position.y = vtx->VERTEX_Y;
         */
        GSptr->position.x = sp->VERTEX_X;
        GSptr->position.y = sp->VERTEX_Y;

        return(0);
}


/************************************************************************
 * This module is to implement flattenpath operator.
 * Syntax :        -   flattenpath   -
 *
 * TITLE:       op_flattenpath
 *
 * CALL:        op_flattenpath()
 *
 * INTERFACE:   interpreter(op_flattenpath)
 *
 * CALLS:       flatten_subpath
 *
 ************************************************************************/
fix
op_flattenpath()
{
        SP_IDX isp;    /* index to node_table for subpath */
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist=NULLP, FAR *pre_sp;            /* init.; scchen 2/22/91 */


        path = &path_table[GSptr->path];

        /* Traverse the current path, and immediately flatten the path
         * in current gsave level
         */
        pre_sp = &(path->head);         /* @NODE */
        /* for (isp = path->head; isp != NULLP; isp = sp->next) { @NODE */
        for (isp = path->head; isp != NULLP; isp = sp->SP_NEXT) {
                sp = &node_table[isp];
                /* @NODE
                 * vlist = flatten_subpath (sp->SP_HEAD, F2L(GSptr->flatness));
                 */
                vlist = flatten_subpath (isp, F2L(GSptr->flatness));

                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return(0);
                }
                /* @NODE
                 * free_node(sp->SP_HEAD);
                 * sp->SP_HEAD = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                free_node(isp);
                *pre_sp = vlist;

                /* clear CURVE flag of the new subpath @SP_FLG */
                /* sp->SP_FLAG &= ~SP_CURVE; @NODE */
                node_table[vlist].SP_FLAG &= ~SP_CURVE;

                pre_sp = &(node_table[vlist].SP_NEXT);  /* @NODE */
        }
        path->tail = vlist;             /* @NODE */

        /* Set flatten flag for path below current gsave level */
        if (!(path->rf & P_FLAT)) {
                path->rf |= P_FLAT;
                path->flat = GSptr->flatness;
        }

        return(0);
}


/************************************************************************
 * This module is to implement reversepath operator.
 * Syntax :        -   reversepath   -
 *
 * TITLE:       op_reversepath
 *
 * CALL:        op_reversepath()
 *
 * INTERFACE:   interpreter(op_reversepath)
 *
 * CALLS:       reverse_subpath
 ************************************************************************/
fix
op_reversepath()
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        struct nd_hdr FAR *vtx;
        SP_IDX isp, nsp;    /* index to node_table for subpath */
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist, FAR *pre_sp;

        path = &path_table[GSptr->path];

        if (path->head == NULLP) return(0);     /* avoid to use uninitialized
                                                   vlist, phchen 3/26/91 */

        /* Traverse the current path, and immediately reverse the path
         * in current gsave level
         */
        pre_sp = &(path->head);         /* @NODE */
        /* for (isp = path->head; isp != NULLP; isp = sp->next) { @NODE */
        for (isp = path->head; isp != NULLP; isp = nsp) {  /* @NODE 2/20/90 */
                nsp = node_table[isp].SP_NEXT;          /* @NODE 2/20/90 */
                /* vlist = reverse_subpath (sp->SP_HEAD); @NODE */
                vlist = reverse_subpath (isp);

                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return(0);
                }

                /* @NODE
                 * free_node(sp->SP_HEAD);
                 * sp->SP_HEAD = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                free_node(isp);
                *pre_sp = vlist;

                /* pre_sp = &(sp->SP_NEXT);     @NODE */
                pre_sp = &(node_table[vlist].SP_NEXT);    /* @NODE 2/20/90 */
        }
        path->tail = vlist;             /* @NODE */

        /* update current position */
        sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        if (vtx->VX_TYPE == CLOSEPATH) {
                /* @NODE
                 * GSptr->position.x = node_table[sp->SP_HEAD].VERTEX_X;
                 * GSptr->position.y = node_table[sp->SP_HEAD].VERTEX_Y;
                 */
                GSptr->position.x = node_table[path->tail].VERTEX_X;
                GSptr->position.y = node_table[path->tail].VERTEX_Y;
        } else {
                GSptr->position.x = vtx->VERTEX_X;
                GSptr->position.y = vtx->VERTEX_Y;
        }

        /* Set reverse flag for path below current gsave level */
        if (!(path->rf & P_RVSE)) {
                path->rf ^= P_RVSE;
        }

        return(0);
}


/************************************************************************
 * This module is to implement strokepath operator.
 * Syntax :        -   strokepath   -
 *
 * TITLE:       op_strokepath
 *
 * CALL:        op_strokepath()
 *
 * INTERFACE:   interpreter(op_strokepath)
 *
 * CALLS:       traverse_path, path_to_outline
 *
 ************************************************************************/
fix
op_strokepath()
{

/* @WIN: Bug of c6.0; just dummy the all function ???*/
#ifdef XXX

        struct ph_hdr FAR *path;

        /* get pointer of current path */
        path = &path_table[GSptr->path];

        /* initialize new_path structure, where the new generated
         * path will be placed by path_to_outline routine
         */
        new_path.head = new_path.tail = NULLP;

        /* initialization of stroke parameters */
        init_stroke();          /* @EHS_STK 1/29/88 */

        /* Convert current path to outline and paint it */
        traverse_path (path_to_outline, (fix FAR *)FALSE);
                        /* new generated path in new_path structure */

        if( ANY_ERROR() == LIMITCHECK ){
                free_newpath();
                return(0);
        }

        /* free old current path on current gsave level */
        free_path();

        /* install the new current path */
        path->head = new_path.head;
        path->tail = new_path.tail;
        path->previous = NULLP;

        /* update current position 1/30/89 */
        if (path->tail == NULLP) {
            /* set no current point */
            F2L(GSptr->position.x) = F2L(GSptr->position.y) = NOCURPNT;
        } else {
            struct nd_hdr FAR *sp;
            struct nd_hdr FAR *vtx;

            sp = &node_table[path->tail];
//          vtx = &node_table[sp->SP_TAIL];   for c6.0 bug @WIN

            if (vtx->VX_TYPE == CLOSEPATH) {
                    /* @NODE
                     * GSptr->position.x = node_table[sp->SP_HEAD].VERTEX_X;
                     * GSptr->position.y = node_table[sp->SP_HEAD].VERTEX_Y;
                     */
                    GSptr->position.x = node_table[path->tail].VERTEX_X;
                    GSptr->position.y = node_table[path->tail].VERTEX_Y;
            } else {
                    GSptr->position.x = vtx->VERTEX_X;
                    GSptr->position.y = vtx->VERTEX_Y;
            }
        }

#endif
        return(0);
}


/************************************************************************
 * This module is to implement clippath operator.
 * Syntax :        -   clippath   -
 *
 * TITLE:       op_clippath
 *
 * CALL:        op_clippath()
 *
 * INTERFACE:   interpreter(op_clippath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_clippath()
{
        struct nd_hdr FAR *tpzd;

        /* free current path */
        free_path();

        /* save clipping trapezoids in cp_path, instead of transforming
         * it to path directly. @CPPH; 12/4/90
         */

        /* set clip_path as part of current path @CPPH */
        path_table[GSptr->path].cp_path = GSptr->clip_path.head;

        /* update current position */
        tpzd = &node_table[GSptr->clip_path.tail];      /* @CPPH */
        GSptr->position.x = SFX2F(tpzd->CP_TOPXL);
        GSptr->position.y = SFX2F(tpzd->CP_TOPY);

        return(0);
}


/************************************************************************
 * This module is to implement pathbbox operator.
 * Syntax :        -   pathbbox   llx lly urx ury
 *
 * TITLE:       op_pathbbox
 *
 * CALL:        op_pathbbox()
 *
 * INTERFACE:   interpreter(op_pathbbox)
 *
 * CALLS:       inverse_transform
 ************************************************************************/
fix
op_pathbbox()
{
        real32    bbox[4];
        struct coord FAR *p;

        union    four_byte lx4, ly4, ux4, uy4;
        struct   ph_hdr FAR *path;
        struct   nd_hdr FAR *sp;
        struct   nd_hdr FAR *vtx;

        path = &path_table[GSptr->path];

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* set bbox[] init value 1/11/91 */
        if (path->rf & P_NACC) {
            /* for charpath, current point is not a real node, pathbbox
             * can not use it as init value(it added a advance vector).
             * to get the first MOVETO coordinate as initial value
             */
            while (path->head == NULLP) {
                    path = &path_table[path->previous];
            }
            sp = &node_table[path->head];
            vtx = sp;
            bbox[0] = bbox[2] = vtx->VERTEX_X;  /* min_x, max_x */
            bbox[1] = bbox[3] = vtx->VERTEX_Y;  /* min_y, max_y */
        } else {
            /* set current point as initial value @CPPH; 12/12/90 */
            bbox[0] = bbox[2] = GSptr->position.x;  /* min_x, max_x */
            bbox[1] = bbox[3] = GSptr->position.y;  /* min_y, max_y */
        }

        /* find bounding box of current path */
// DJC         traverse_path (bounding_box, (fix FAR *)bbox);
        traverse_path ((TRAVERSE_PATH_ARG1)(bounding_box), (fix FAR *)bbox);

        /* Transform to user's coordinate system */
        p = inverse_transform(F2L(bbox[0]), F2L(bbox[1]));  /* (min_x, min_y) */
        if(ANY_ERROR()) return(0);      /* @REM_STK */
        lx4.ff = ux4.ff = p->x;
        ly4.ff = uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[0]), F2L(bbox[3]));  /* (min_x, max_y) */
        if(ANY_ERROR()) return(0);      /* @REM_STK */
        if(p == NULL) return(0);      
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[2]), F2L(bbox[1]));  /* (max_x, min_y) */
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[2]), F2L(bbox[3]));  /* (max_x, max_y) */
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        /* Convert lx4, ly4, ux4, uy4 to objects, and push
         * them into operand stack.
         */
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, lx4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, ly4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, ux4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, uy4.ll);

        return(0);
}


/************************************************************************
 * This module is to implement pathforall operator.
 * Syntax :        move line curve close   pathforall   -
 *
 * TITLE:       op_pathforall
 *
 * CALL:        op_pathforall()
 *
 * INTERFACE:   interpreter(op_pathforall)
 *
 * CALLS:       traverse_path, dump_subpath
 *
 ************************************************************************/
fix
op_pathforall()
{
        struct object_def objects[4];
        struct sp_lst sp_list;          /* @PFALL */
        SP_IDX isp;    /* index to node_table for subpath */

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        COPY_OBJ(GET_OPERAND(3), &objects[0]);
        COPY_OBJ(GET_OPERAND(2), &objects[1]);
        COPY_OBJ(GET_OPERAND(1), &objects[2]);
        COPY_OBJ(GET_OPERAND(0), &objects[3]);

        /* reject dumpping noaccess path 1/25/88 */
        if (path_table[GSptr->path].rf & P_NACC) {
                ERROR(INVALIDACCESS);
                return(0);
        }

        /* pre-calculate inverse CTM  @INV_CTM */
        set_inverse_ctm();
        if( ANY_ERROR() == UNDEFINEDRESULT) return(0);

        POP(4);            /* @REM_STK */

        /* copy current path to a temp. path for dump */
        sp_list.head = sp_list.tail = NULLP;
        get_path(&sp_list);

        /* dump all nodes */
        /* @NODE
         * for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].next) {
         */
        for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].SP_NEXT) {
                dump_subpath (isp, objects);
        }

        /* free temp. path */
        /* @NODE
         * for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].next) {
         *         free_node (node_table[isp].SP_HEAD);
         * }
         * free_node (sp_list.head);
         */
        for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].SP_NEXT) {
                free_node (isp);
        }

        return(0);
}


/************************************************************************
 * This module is to implement initclip operator.
 * Syntax :        -   initclip   -
 *
 * TITLE:       op_initclip
 *
 * CALL:        op_initclip()
 *
 * INTERFACE:   interpreter(op_initclip)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_initclip()
{
        CP_IDX itpzd;
        struct nd_hdr FAR *tpzd;

        /* free old clipping path if it is not used by lower gsave level
         * and not used by current path  @CPPH; 12/1/90
         */
        if(!GSptr->clip_path.inherit &&
           path_table[GSptr->path].cp_path != GSptr->clip_path.head) /* @CPPH */
                free_node (GSptr->clip_path.head);

        /* create a trapezoid with default clipping region */
        if((itpzd = get_node()) == NULLP){
                ERROR(LIMITCHECK);
                return(0);
        }

        tpzd = &node_table[itpzd];
        tpzd->CP_TOPY = GSptr->device.default_clip.ly;
        tpzd->CP_BTMY = GSptr->device.default_clip.uy;
        tpzd->CP_TOPXL = tpzd->CP_BTMXL = GSptr->device.default_clip.lx;
        tpzd->CP_TOPXR = tpzd->CP_BTMXR = GSptr->device.default_clip.ux;

        /* install the clipping path */
        GSptr->clip_path.head = GSptr->clip_path.tail = itpzd;
        GSptr->clip_path.inherit = FALSE;
        GSptr->clip_path.bb_ux = GSptr->device.default_clip.ux;
        GSptr->clip_path.bb_uy = GSptr->device.default_clip.uy;
        GSptr->clip_path.bb_lx = GSptr->device.default_clip.lx;
        GSptr->clip_path.bb_ly = GSptr->device.default_clip.ly;
        GSptr->clip_path.single_rect = TRUE;

        return(0);
}


/************************************************************************
 * This module is to implement clip operator.
 * Syntax :        -   clip   -
 *
 * TITLE:       op_clip
 *
 * CALL:        op_clip()
 *
 * INTERFACE:   interpreter(op_clip)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_clip()
{
        clip_process (NON_ZERO);
        return(0);
}


/************************************************************************
 * This module is to implement eoclip operator.
 * Syntax :        -   eoclip   -
 *
 * TITLE:       op_eoclip
 *
 * CALL:        op_eoclip()
 *
 * INTERFACE:   interpreter(op_eoclip)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_eoclip()
{
        clip_process (EVEN_ODD);
        return(0);
}




static void near clip_process(winding_type)
fix     winding_type;
{
        struct nd_hdr FAR *tpzd;

        /* initialize edge table 11/30/88 */
        init_edgetable();       /* in "shape.c" */

        /* Approximate the current path */
        traverse_path (shape_approximation, (fix FAR *)NULLP);
        if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                return;
        }

        /* initialize new_clip structure, where the new generated
         * clipping path will be placed by shape_reduction routine
         * after shape reduction and performming SAVE_CLIP action.
         */
        new_clip.head = new_clip.tail = NULLP;
        new_clip.bb_ux = new_clip.bb_uy = MIN_SFX;      /* -32767; 12/17/88 */
        new_clip.bb_lx = new_clip.bb_ly = MAX_SFX;      /*  32768; 12/17/88 */

        /* Reduce path to trapezoidized path, and clip it to old clip
         * region
         */
        fill_destination = SAVE_CLIP;
        shape_reduction (winding_type);
                        /* new generated clip in new_clip structure */

        if(ANY_ERROR() == LIMITCHECK){  /* 05/07/91, Peter, out of scany_table */
                free_node(new_clip.head);
                return;
        }

        /* free old clipping path if it is not used by lower gsave level */
        if(!GSptr->clip_path.inherit)
                free_node (GSptr->clip_path.head);

        /* install the new clipping path */
        GSptr->clip_path.head = new_clip.head;
        GSptr->clip_path.tail = new_clip.tail;
        GSptr->clip_path.inherit = FALSE;
        GSptr->clip_path.bb_ux = new_clip.bb_ux;
        GSptr->clip_path.bb_uy = new_clip.bb_uy;
        GSptr->clip_path.bb_lx = new_clip.bb_lx;
        GSptr->clip_path.bb_ly = new_clip.bb_ly;

        /* particular case, null clip; @WIN 5/20/92 */
        if (new_clip.head == NULLP) {
            GSptr->clip_path.single_rect = TRUE;
            return;
        }

        /* check if single rectangle */
        GSptr->clip_path.single_rect = FALSE;
        if (new_clip.head == new_clip.tail) {   /* single trapezoid */
                tpzd = &node_table[new_clip.head];
                if ((tpzd->CP_TOPXL == tpzd->CP_BTMXL) &&
                    (tpzd->CP_TOPXR == tpzd->CP_BTMXR)) {
                        /* rectangle */
                        GSptr->clip_path.single_rect = TRUE;
                }
        }

}




/************************************************************************
 * This module is to implement erasepage operator. It erases the entire current
 * page by painting it with gray level 1.
 * Syntax :        -   erasepage   -
 *
 * TITLE:       op_erasepage
 *
 * CALL:        op_erasepage()
 *
 * INTERFACE:   interpreter(op_erasepage)
 *
 * CALLS:       erasepage
 *
 ************************************************************************/
fix
op_erasepage()
{

        /* Erase the entire page */
        erasepage();

        return(0);
}


/************************************************************************
 * This module is to implement fill operator.
 * Syntax :        -   fill   -
 *
 * TITLE:       op_fill
 *
 * CALL:        op_fill()
 *
 * INTERFACE:   interpreter(op_fill)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_fill()
{
        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
            show_buildchar(OP_FILL);
        else {
            if (fill_clippath())                                /* @CPPH */
                fill_shape(NON_ZERO, F_NORMAL, F_TO_PAGE);
        }

        return(0);
}

/************************************************************************
 *
 * This module is to implement eofill operator.
 * Syntax :        -   eofill   -
 *
 * TITLE:       op_eofill
 *
 * CALL:        op_eofill()
 *
 * INTERFACE:   interpreter(op_eofill)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 *
 ************************************************************************/
fix
op_eofill()
{

        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
            show_buildchar(OP_EOFILL);
        else {
            if (fill_clippath())                                /* @CPPH */
                fill_shape(EVEN_ODD, F_NORMAL, F_TO_PAGE);
        }

        return(0);
}


/************************************************************************
 * Fill the clipping trapezoids directly from clip path which was stored
 * in path_table[].cp_path.
 *
 * TITLE:       fill_clippath
 *
 * CALL:        fill_clippath()
 *
 * RETURN:      0  -- fill clipping trapezoids successfully
 *              -1 -- do nothing
 *
 * INTERFACE:   op_fill, op_eofill
 *
 * CALLS:       save_tpzd, free_node
 ************************************************************************/
static fix near fill_clippath()                        /* @CPPH */
{
        struct ph_hdr FAR *path;
        PH_IDX  ipath;

        ipath = GSptr->path;

        do {
            path = &path_table[ipath];

            if (path->head != NULLP) return(-1);

            if (path->cp_path != NULLP) {
                CP_IDX itpzd;
                struct nd_hdr FAR *tpzd;

                /* fill trapezoid from clip_trapezoid */
                fill_destination = F_TO_PAGE;
                for (itpzd = path->cp_path; itpzd != NULLP;
                    itpzd = tpzd->next) {
                    tpzd = &node_table[itpzd];
                    save_tpzd(&tpzd->CP_TPZD);
                }

                /* free cp_path for current gsave level */
                if (ipath == GSptr->path) {
                    if (path->cp_path != GSptr->clip_path.head)
                            free_node (path->cp_path);
                    path->cp_path = NULLP;
                }
                return(0);      /* return successfully */
            } /* if */
        } while ((ipath = path->previous) != NULLP);

        return(-1);
}


/************************************************************************
 *
 * This module is to implement stroke operator.
 * Syntax :        -   stroke   -
 *
 * TITLE:       op_stroke
 *
 * CALL:        op_stroke()
 *
 * INTERFACE:   interpreter(op_stroke)
 *
 * CALLS:       traverse_path, path_to_outline
 *
 ************************************************************************/
fix
op_stroke()
{
/*      real32  tmp1, tmp2;     (*12-12-90*); deleted by scchen 2/28/91 */

        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
                show_buildchar(OP_STROKE);
        else
                stroke_shape(F_TO_PAGE);

        return(0);
}


/************************************************************************
 * This module is to implement showpage operator. It output one copy of the
 * current page, and erase the current page).
 * Syntax :        -   showpage   -
 *
 * TITLE:       op_showpage
 *
 * CALL:        op_showpage()
 *
 * INTERFACE:   interpreter(op_showpage)
 *
 * CALLS:       erasepage, initgraphics
 ************************************************************************/
fix
op_showpage()
{

        /* check undefine error, Jack, 11-29-90 */
        struct  object_def      name_obj;
        if(is_after_setcachedevice()){
                get_name(&name_obj, "showpage", 8, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* set showpage flag for st_frametoprinter @PRT_FLAG */
        print_page_flag = SHOWPAGE;

        /* Transmit the current page to output device */
        if(interpreter(&GSptr->device.device_proc)) {
                return(0);
        }

        /* change frame buffer for showpage/erasepage enhancement */
        if (GSptr->device.nuldev_flg != NULLDEV) { /* not a null device only; Jack Liaw */
                next_pageframe();
        }

#ifndef DUMBO
/* Don't erase page @WIN */
//      /* Erase the current page */
//      erasepage();
        erasepage();  // DJC put this back...
#else
        erasepage();
#endif

        /* Initialize the graphics state */
        op_initgraphics();

        return(0);
}


/************************************************************************
 * This module is to implement copypage operator. It output one copy of the
 * current page, and without erasing the current page.
 * Syntax :        -   copypage   -
 *
 * TITLE:       op_copypage
 *
 * CALL:        op_copypage()
 *
 * INTERFACE:   interpreter(op_copypage)
 *
 * CALLS:       interpreter
 ************************************************************************/
fix
op_copypage()
{

        /* set copypage flag for st_frametoprinter @PRT_FLAG */
        print_page_flag = COPYPAGE;

        /* Transmit the current page to output device */
        if(interpreter(&GSptr->device.device_proc)) {
                return(0);
        }
        return(0);
}

/************************************************************************
 * This module is to implement banddevice operator.
 * Syntax :        matrix width height proc   banddevice   -
 *
 * TITLE:       op_banddevice
 *
 * CALL:        op_banddevice()
 ************************************************************************/
fix
op_banddevice()
{
       return(0);
}


/************************************************************************
 * This module is to implement framedevice operator.
 * Syntax :        matrix width height proc   framedevice   -
 *
 * TITLE:       op_framedevice
 *
 * CALL:        op_framedevice()
 *
 * INTERFACE:   interpreter(op_framedevice)
 *
 * CALLS:       none
 *
 ************************************************************************/
fix
op_framedevice()
{
        fix     i;
        fix     iwidth8, iheight;
        sfix_t  ux, uy;
        real32  height, width, elmt[MATRIX_LEN];
        struct object_def FAR *obj_matrix, FAR *obj_height, FAR *obj_width, FAR *obj_proc;
        fix GEIeng_checkcomplete(void);         /*@WIN: add prototype */

#ifdef DJC
        /* @EPS */
        typedef struct tagRECT
          {
            int         left;
            int         top;
            int         right;
            int         bottom;
          } RECT;
        extern RECT EPSRect;
#endif
        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_matrix = GET_OPERAND(3);
        obj_width  = GET_OPERAND(2);
        obj_height = GET_OPERAND(1);
        obj_proc   = GET_OPERAND(0);

        /* Derive the default clipping path */
        GET_OBJ_VALUE(width, obj_width); /* width  = get_obj_value(obj_width);*/
        GET_OBJ_VALUE(height, obj_height);
                                       /* height = get_obj_value(obj_height); */
        /* check rangecheck error 1/25/89 */
        if(LENGTH(obj_matrix) != MATRIX_LEN) {
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        /* if( !access_chk(obj_matrix, G_ARRAY) ) return(0); for compatability
         *                                                       1/25/89
         */

        if( !get_array_elmt(obj_matrix,MATRIX_LEN,elmt,G_ARRAY)) return(0);



         {

            double  xScale, yScale;


            xScale = yScale = 1.0;

            // DJC DJC DJC ?????
            // where do we get the xres and yres from ???
            PsGetScaleFactor(&xScale, &yScale, 300, 300);

            // Now we need to scale the X and Y multiplier by the ratio of
            // the PSTODIB model. This number is generated by comparing the
            // resolution of the target device surface and the interpreter
            // resolution, currently we dont support scaling for greater
            // than 300 dpi devices because of our MATH possibly breaking
            // down.
            if (xScale <= 1.0) {
               elmt[0] *= (real32)xScale;
               elmt[4] *= (real32)xScale;
            }
            if (yScale <= 1.0) {
               elmt[3] *= (real32)yScale;
               elmt[5] *= (real32)yScale;
            }



#ifdef DJC
            /* update width, height, and matrix according to EPS boundary; @EPS */
            width = (real32)(EPSRect.right - EPSRect.left + 1)/8;
            height = (real32)(EPSRect.bottom - EPSRect.top + 1);
            elmt[4] -= (real32)EPSRect.left;
            elmt[5] -= (real32)EPSRect.top;

#endif

        }

#ifdef XXX      /*@WIN; not need to update starting address of frame buffer */
        /* limit error check - grayscale 8-1-90 Jack Liaw */
        {
            ufix32      l_diff, frame_size;
            ufix32      twidth;

            twidth = ((WORD_ALLIGN((ufix32)(width * 8))) >> 3);
            if (GSptr->graymode)        /* gray */
                frame_size = twidth * (ufix32) height * 4;
            else                        /* mono */
                frame_size = twidth * (ufix32) height;
#ifdef  DBG
            printf("width<%x>,heigh<%x>,size<%lx>\n", (fix)width,
                   (fix)height, frame_size);
#endif
            /* BEGIN, papertype changed 10-11-90, JS */
            if (frame_size != last_frame) {
               /*  wait until laser printer turns ready  */
                while (GEIeng_checkcomplete()) ;
                last_frame = frame_size;
            }
            /* END 10-11-90, JS */

            DIFF_OF_ADDRESS (l_diff, fix32, (byte FAR *)highmem, (byte FAR *)vmptr);
            if (frame_size > l_diff) {
                ERROR(LIMITCHECK);
                return(0);
            } else {
                vmheap = (byte huge *)(highmem - frame_size);
                FBX_BASE = highmem - frame_size;
            }
        }
#endif





#ifdef DJC

        // DJC begin added for realloc of frame buff if needed...
        {
            ufix32 twidth, frame_size;

            twidth = ((WORD_ALLIGN((ufix32)(width * 8))) >> 3);
            frame_size = twidth * (ufix32) height;


            //twidth = ((WORD_ALLIGN((ufix32)(PageType.FB_Width ))) >> 3);
            //frame_size = twidth * PageType.FB_Heigh;

            if (! PsAdjustFrame((LPVOID *) &FBX_BASE, frame_size)) {
                    ERROR(LIMITCHECK);
                    return 0;  //DJC check this bug we need to report something???
            }

        }
        //DJC end



#endif












        if (GSptr->graymode)                    /* gray */
            iwidth8 = (fix)(width * 8 * 4);     /* bits */
        else                                    /* mono */
            iwidth8 = (fix)(width * 8);         /* bits */
        iheight = (fix)height;
        ux = I2SFX(GSptr->graymode ? (fix)(iwidth8 / 4) : iwidth8);   /* iwidth8 * 8;  SFX format */
        uy = I2SFX(iheight);             /* iheight * 8;             */

        /* default clipping region = {(0, 0), (ux, 0), (ux, uy),
         * and (0, uy)}
         */

        /* Save device characteristics: width, height, CTM, procedure @DEVICE */
        GSptr->device.width = (fix16)iwidth8;
        GSptr->device.height = (fix16)iheight;

        /* device procedure */
        COPY_OBJ(obj_proc, &GSptr->device.device_proc);

        /* CTM */
        for(i=0; i < MATRIX_LEN; i++) {
                   GSptr->ctm[i] = GSptr->device.default_ctm[i] = elmt[i];
        }

        /* set change_flag; @DEVICE */
        GSptr->device.chg_flg = TRUE;   /* device has been changed;
                                         * set for grestore
                                         */
        /* set not a null device; grayscale 8-1-90 Jack Liaw */
        if (GSptr->graymode) {
            GSptr->device.nuldev_flg = GRAYDEV;
            GSptr->halftone_screen.freq = (real32)100.0;        /* 100 lines */
            GSptr->halftone_screen.angle = (real32)45.0;
        } else {
            GSptr->device.nuldev_flg = MONODEV;
            GSptr->halftone_screen.freq = (real32)60.0;         /*  60 lines */             GSptr->halftone_screen.angle = (real32)45.0;
        }

#ifdef DBG
        if (GSptr->device.nuldev_flg == GRAYDEV)                /* test */
            fprintf(stderr, " framedevice is ... GRAY\n");      /* test */
        else                                                    /* test */
            fprintf(stderr, " framedevice is ... MONO\n");      /* test */
#endif

        /* reset halftone *)
        SetHalfToneCell();
        FillHalfTonePat();*/

        /* save default clipping */
        GSptr->device.default_clip.lx = 0;
        GSptr->device.default_clip.ly = 0;

        GSptr->device.default_clip.ux = ux - (fix16)ONE_SFX;    //@WIN
        GSptr->device.default_clip.uy = uy - (fix16)ONE_SFX;    //@WIN

        /*
         * set current clipping
         */
        op_initclip();

        reset_page (iwidth8, iheight, 1);
                                /* 1: monochrome */
/*      reset_page (iwidth8, iheight, 1); |* once again ?, Jack Liaw, 8-8-90 */

        POP(4);

        return(0);
}


/************************************************************************
 * This module is to implement nulldevice operator.
 * Syntax :        -   nulldevice   -
 *
 * TITLE:       op_nulldevice
 *
 * CALL:        op_nulldevice()
 *
 * INTERFACE:   interpreter(op_nulldevice)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_nulldevice()
{
        fix     i;

        create_array(&GSptr->device.device_proc, 0);
        ATTRIBUTE_SET(&GSptr->device.device_proc, EXECUTABLE);

        GSptr->device.default_ctm[0] = one_f;     /* identity CTM */
        GSptr->device.default_ctm[1] = zero_f;
        GSptr->device.default_ctm[2] = zero_f;
        GSptr->device.default_ctm[3] = one_f;
        GSptr->device.default_ctm[4] = zero_f;
        GSptr->device.default_ctm[5] = zero_f;

        GSptr->device.default_clip.lx = 0;    /* clip at the origin */
        GSptr->device.default_clip.ly = 0;
        GSptr->device.default_clip.ux = 0;
        GSptr->device.default_clip.uy = 0;

        /* Set current CTM */
        for(i=0; i<MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }

        /* set current clip */
        op_initclip();

        /* set a null device; Jack Liaw */
        GSptr->device.nuldev_flg = NULLDEV;

        return(0);
}


/************************************************************************
 * This module is to implement renderbands operator.
 * Syntax :        proc   renderbands   -
 *
 * TITLE:       op_renderbands
 *
 * CALL:        op_renderbands()
 ************************************************************************/
fix
op_renderbands()
{
        return(0);
}


/************************************************************************
 *
 * This module is to implement frametoprinter internal operator.
 * Syntax :        #copies   frametoprinter   -
 *
 * TITLE:       st_frametoprinter
 *
 * CALL:        st_frametoprinter()
 *
 * INTERFACE:   interpreter(st_frametoprinter)
 *
 * CALLS:       none
 ************************************************************************/
fix
st_frametoprinter()
{
        real32  copies, tmp;
        fix    copies_i;
        struct object_def FAR *obj_copies;
        fix    top, left, manfeed;
        struct object_def FAR *obj_top, FAR *obj_left, FAR *obj_manfeed;

        /*
         * Get input parameters from operand stack
         */

        /* Check number of operands */
        if(COUNT() < 4) {
                ERROR(STACKUNDERFLOW);
                return(0);
        }

        /* Get operand 3 */
        obj_top = GET_OPERAND(3);
        if (TYPE(obj_top) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_top);
        top   = (fix)tmp;

        /* Get operand 2 */
        obj_left = GET_OPERAND(2);
        if (TYPE(obj_left) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_left);
        left   = (fix)tmp;

        /* Get operand 1 */
        obj_manfeed = GET_OPERAND(1);
        if (TYPE(obj_manfeed) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_manfeed);
        manfeed   = (fix)tmp;

        /* Get operands */
        obj_copies = GET_OPERAND(0);

        /* Type check */
        if (TYPE(obj_copies) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }

        /* get # of copies */
        GET_OBJ_VALUE(copies, obj_copies);
                                     /* copies = get_obj_value(obj_copies); */

        if(copies > zero_f) {
                copies_i = (fix)copies;

                /* print pages */
                print_page (top, left, copies_i, print_page_flag, manfeed);
                /* print_page (top, left*8, copies_i, print_page_flag, manfeed);
                 *             input unit changed from bytes to bits; 1/15/90
                 */

                /* update page count @PAGE_CNT */
                updatepc((ufix32)copies_i);
        }

        POP(4);

        return(0);
}

/***********************************************************************
 *
 * This module erases the entire current page by painting it with gray
 * level 1.
 *
 * TITLE:       erasepage
 *
 * CALL:        erasepage()
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_erasepage, op_showpage
 *
 * CALLS:       setgray, filler
 *
 * RETURN:
 *
 **********************************************************************/
static void near erasepage()
{
        real32   old_gray, gray_1;

        /* do nothing if it is a null device; Jack Liaw */
//      if (GSptr->device.nuldev_flg == NULLDEV) { @WIN; device not set yet
//              return;                                  Temp. ???
//      }

        gray_1 = one_f;

        /* Save current gray level */
        old_gray = GSptr->color.gray;

        /* Paint the entire page with gray level 1 */
        setgray (F2L(gray_1));

        /* clear the full page */
        erase_page();

        /* Restore the gray level */
        setgray (F2L(old_gray));
        return;
}

/************************************************************************
 * This module is to transform (x, y) by CTM
 *
 * TITLE:       transform
 *
 * CALL:        transform(x, y)
 *
 * PARAMETER:   x, y: source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p: address of transform result (x', y')
 ************************************************************************/
struct coord FAR *transform(lx, ly)
long32   lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;
        p.x = GSptr->ctm[0]*x + GSptr->ctm[2]*y + GSptr->ctm[4];
        CHECK_INFINITY(p.x);

        p.y = GSptr->ctm[1]*x + GSptr->ctm[3]*y + GSptr->ctm[5];
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to inverse transform (x, y) by CTM
 *
 * TITLE:       inverse_transform
 *
 * CALL:        inverse_transform(x, y)
 *
 * PARAMETER:   x, y: source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p : address of inverse transform result (x', y')
 *
 ************************************************************************/
struct coord FAR *inverse_transform(lx, ly)
long32   lx, ly;
{
        static struct coord p;  /* should be static */
        real32  x, y, det_matrix;

        /* calculate the det(CTM) */
        _clear87() ;
        det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                     GSptr->ctm[1] * GSptr->ctm[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return((struct coord FAR *)NIL);
        }

        x = L2F(lx);
        y = L2F(ly);
        p.x = (GSptr->ctm[3]*x - GSptr->ctm[2]*y - GSptr->ctm[4]*GSptr->ctm[3] +
               GSptr->ctm[2]*GSptr->ctm[5]) / det_matrix;
        CHECK_INFINITY(p.x);

        p.y = (GSptr->ctm[0]*y - GSptr->ctm[1]*x - GSptr->ctm[0]*GSptr->ctm[5] +
               GSptr->ctm[4]*GSptr->ctm[1]) / det_matrix;
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to transform (x, y) by matrix
 *
 * TITLE:       any_transform
 *
 * CALL:        any_transform(matrix, x, y)
 *
 * PARAMETER:   matrix: transform matrix
 *              x, y  : source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p:address of transform result (x', y')
 ************************************************************************/
struct coord FAR *any_transform(matrix, lx, ly)
real32   FAR matrix[];
long32    lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;
        p.x = matrix[0] * x + matrix[2] * y + matrix[4];
        CHECK_INFINITY(p.x);

        p.y = matrix[1] * x + matrix[3] * y + matrix[5];
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to fill im with inverse of matrix
 *
 * TITLE:       inverse_mat
 *
 * CALL:        inverse_mat(matrix)
 *
 * PARAMETER:   matrix : source matrix
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &im: address of im
 ************************************************************************/
real32 FAR *inverse_mat(matrix)
real32   FAR matrix[];
{
        static real32 im[6];
        real32 det_matrix;

        /* calculate the det(matrix1) */
        _clear87() ;
        det_matrix = matrix[0] * matrix[3] - matrix[1] * matrix[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return((real32 *)NIL);
        }

        /* calculate the value of INV(matrix) */
        im[0] =  matrix[3] / det_matrix;
        CHECK_INFINITY(im[0]);

        im[1] = -matrix[1] / det_matrix;
        CHECK_INFINITY(im[1]);

        im[2] = -matrix[2] / det_matrix;
        CHECK_INFINITY(im[2]);

        im[3] =  matrix[0] / det_matrix;
        CHECK_INFINITY(im[3]);

        im[4] = (matrix[2] * matrix[5] - matrix[3] * matrix[4]) / det_matrix;
        CHECK_INFINITY(im[4]);

        im[5] = (matrix[1] * matrix[4] - matrix[0] * matrix[5]) / det_matrix;
        CHECK_INFINITY(im[5]);

        return(im);
}


/************************************************************************
 * This module is to fill mat3 with mat1 * mat2.
 *
 * TITLE:       concat_mat
 *
 * CALL:        concat_mat(mat1, mat2)
 *
 * PARAMETER:   mat1, mat2 : matrix1 & matrix2
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      mat3
 ************************************************************************/
real32 FAR *concat_mat(mat1, mat2)
real32   FAR mat1[], FAR mat2[];
{
        static real32 mat3[6];

        /* create element of mat3 */
        _clear87() ;
        mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[2];
        CHECK_INFINITY(mat3[0]);

        mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[3];
        CHECK_INFINITY(mat3[1]);

        mat3[2] = mat1[2] * mat2[0] + mat1[3] * mat2[2];
        CHECK_INFINITY(mat3[2]);

        mat3[3] = mat1[2] * mat2[1] + mat1[3] * mat2[3];
        CHECK_INFINITY(mat3[3]);

        mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[2] + mat2[4];
        CHECK_INFINITY(mat3[4]);

        mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[3] + mat2[5];
        CHECK_INFINITY(mat3[5]);

        return(mat3);
}


/***********************************************************************
 * This module frees current new path
 *
 * TITLE:       free_newpath
 *
 * CALL:        free_newpath()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   op_strokepath
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
static void near free_newpath()
{
        struct  nd_hdr FAR *sp;
        SP_IDX  isp;    /* index to node_table for subpath */

        /*
         * Free current newpath
         */
        /* free each subpath of current newpath */
        /* @NODE
         * for (isp = new_path.head; isp != NULLP; isp = sp->next) {
         *         sp = &node_table[isp];
         *         free_node (sp->SP_HEAD);
         * }
         */
        for (isp = new_path.head; isp != NULLP; isp = sp->SP_NEXT) {
                sp = &node_table[isp];
                free_node (isp);
        }

        /* free all subpath headers */
        /* free_node (new_path.head);           @NODE; 1/6/90 */
        new_path.head = new_path.tail = NULLP;
}

/***********************************************************************
 * This module sets gray mode in the current graphics state
 *
 * TITLE:       op_setgraymode
 *
 * CALL:        op_setgraymode()
 *
 * PARAMETERS:  none
 *
 * NOTES:       Jack Liaw 7-26-90
 *
 * SYNTAX:      bool setgraymode bool
 **********************************************************************/
fix
op_setgraymode()
{
//  bool8  mode;                        @WIN
    struct object_def  FAR *obj;

    /* get operand */
    obj = GET_OPERAND(0);
//  GET_OBJ_VALUE (mode, obj);          @WIN ???
    POP(1);

    if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    }

    GSptr->graymode = FALSE;
    PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, FALSE);

    return(0);
} /* op_setgraymode */

/***********************************************************************
 * This module gets current gray mode in the graphics state
 *
 * TITLE:       op_currentgraymode
 *
 * CALL:        op_currentgraymode()
 *
 * PARAMETERS:  none
 *
 * NOTES:       Jack Liaw 7-26-90
 *
 * SYNTAX:      - currentgraymode bool
 **********************************************************************/
fix
op_currentgraymode()
{
    if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    }
    /* return gray mode */
    PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, GSptr->graymode);
    return(0);
} /* op_currentgraymode */

/***********************************************************************
 * This module sets the image interpolation value in the graphics state
 *
 * TITLE:       op_setinterpolation
 *
 * CALL:        op_setinterpolation()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 7-26-90
 *
 * SYNTAX:      bool setinterpolation -
 **********************************************************************/
fix
op_setinterpolation()
{
/*  POP(1); */
    return(0);
} /* op_setinterpolation */

/***********************************************************************
 * This module gets current value of the image interpolation in the
 * graphics state
 *
 * TITLE:       op_currentinterpolation
 *
 * CALL:        op_currentinterpolation()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 7-26-90
 *
 * SYNTAX:      - currentinterpolation bool
 **********************************************************************/
fix
op_currentinterpolation()
{
/*  if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    } */
    /* always false */
/*  PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, FALSE); */
    return(0);
} /* op_currentinterpolation */

/***********************************************************************
 * This module is used to calibrate the printer in graymode
 *
 * TITLE:       op_calibrategray
 *
 * CALL:        op_calibrategray()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 8-15-90
 *
 * SYNTAX:      string int calibrategray -
 **********************************************************************/
fix
op_calibrategray()
{
    POP(2);
    return(0);
} /* op_calibrategray */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\graphics.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   graphics.h
 *
 *      Purpose: Header files of graphics machinery, for definitions of data
 *               types, data structures, constants, and macros.
 *
 *      Developer:      S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *                  01/16/89    @IMAGE: new feature for fill_shape F_FROM_IMAGE
 *                              and F_TO_MASK to generate clipping mask (CMB)
 *                              for clipped image which can be processed by
 *                              using image seed patterns
 *                  03/17/89    @I2SFX: eliminate (sfix_t) cast of I2SFX macro
 *                              to make it feasible for conversion from "semi-
 *                              lfix" (13-bit fract) into exact lfix (16-bit fract).
 *                              (by Brian for BSFILL2.C)
 *                  03/30/89    MAXCELLSIZE is adjusted for V47 compatible
 *                              from 33 to 80
 *
 *                  04/12/89    approaching compatibility to V 47.
 *                               1) actual cell size would not be greater
 *                                  than 50 pixels in 300 DPI
 *                               2) the size of repeat pattern after
 *                                  expansing on 32-bit aligned would not
 *                                  be greater than 2400 pixels in 300 DPI
 *                  04/26/89    @MAC: update macros of transformation from
 *                              float to fixed numbers for performance
 *                              enhancement
 *                  05/10/89    delete F2SFX4, add F2LFX8
 *                  05/10/89    enlarge spot order array for V47 compatibility
 *                              from 4096 -> 5120
 *                  05/26/89    add new macros IS_ZERO() and IS_NOTZERO for
 *                              floating points
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  1/11/90     change max gsave level(MAXGSL) from 32 to 31
 *                              for compatibility.
 *                  07/26/90    update for grayscale, Jack Liaw
 *                  8/8/90      added rootfont in gs_hdr struct for KANJI
 *                  12/4/90     @CPPH: 1) Add cp_path in struct ph_hdr
 *                                     2) Add a mocro definition CP_TPZD
 *                  3/20/91     update macro IS_ZERO & IS_NOTZERO for speed;
 *                              add a macro SIGN_F to get a sign bit from a
 *                              floating point variable
 *                  3/20/91     add constants for pattern fill; Ada
 *                  3/26/91     Add bit 2 and bit 1 for PDL_CONDITION check
 *                  4/17/91     change MAXEDGE to 1600
 *                  11/11/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/

/* limits */

#ifdef DBG9              /* reduced version, so it can run with CoreView */
#define MAXGSL  4
#define MAXNODE 300
#define MAXEDGE 300
#else
#define MAXGSL MAXGSAVESZ    /* 31; max gsave level, defined in "constant.h" */
#define MAXNODE MAXPATHSZ    /* 1500; max number of nodes in path description */
//*!!!#define MAXEDGE MAXPATHSZ    |* 1500; max number of edges */
//DJCOld#define MAXEDGE 1600         /* 1500; max number of edges */
#define MAXEDGE (MAXPATHSZ + 100)   /* 1500; max number of edges */
#endif

#define MAXDASH MAXDASHSZ /* 11, maximum number of elements in a dash pattern */
#define MAXSCANLINES 3072 /* max. number of scan lines per band filling */
#define MAXGRAYVALUE 256  /* max. number of gray_chain table @IMAGE */
#define MAXGRAY 8         /* max. number of adjust gray table */
#define MAXSPOT 5120      /* max. number of adjust spot order table 05/10/89 */

/*      Note: MAXPATSIZE should be multiple of 16                       */
#define MAXPATTSIZE      128    /* 208 max. repeating pattern size      */
#define MAXSEEDSIZE       64    /* 128 max. seed size                   */
#define MAXCELLSIZE       70    /*  48 max. halftone cell size     03-16-89 */
#define MAXCACTSIZE       50    /* maximum cell actual size        04-12-89 */
#define MAXPEXPSIZE     2400    /* maximum pattern expansion size  04-12-89 */

#define GRAYUNIT         255    /* units of gray value         11-24-88 */
#define GRAYSCALE       0x4000  /* scale of gray value         11-24-88 */

/* grayscale for device state, 8-1-90 Jack Liaw */
#define NULLDEV         0       /* null device */
#define MONODEV         1       /* mono device */
#define GRAYDEV         4       /* gray device */

#define KANJI                   /* @WIN 05-05-92*/
/*-----------------*
 | type definition |
 *-----------------*/
/***************************************************************************
 *             ............ README ............
 *
 * While 13.3 was adopted for the short fixed format and 16.16 was used for
 * long fixed format in TrueImage, the range of number can be represented
 * in integer is between -2**12 and 2**12 -1. If the number does not fall
 * into this range, TrueImage will use "floating number math" to do the work.
 * To expand this range such that TrueImage could run faster for the higher
 * resolution, 16.16, 18.14 or 28.4 will be used.
 * @RESO_UPGR
 *
 * 16 bits fixed real number(13.3):
 *      +------------+------+           The range of numbers:
 *      |  integer   | frac |           [-2**12 .. 2**12 - 1]
 *      +------------+------+
 *          13 bits   3 bits
 *
 * 32 bits fixed real number(16.16):
 *      +------------+------------+
 *      |  integer   |    frac    |     [-2**14 .. 2**14 - 1]
 *      +------------+------------+
 *          16 bits      16 bits
 *
 * 32 bits fixed real number(18.14):
 *      +--------------+----------+
 *      |  integer     |   frac   |     [-2**16 .. 2**16 - 1]
 *      +--------------+----------+
 *          18 bits      14 bits
 *
 * 32 bits fixed real number(28.4):
 *      +------------------+------+
 *      |  integer         | frac |     [-2**26 .. 2**26 - 1]
 *      +------------------+------+
 *          28 bits         4 bits
 *
 * In the code, we used the following notation:
 *      "sfix_t" is used to maintain some degrees of precision while
 *      "lfix_t" is used when we need to keep higher precision during
 *      the math manipulation. Therefore,
 *      "sfix_t" can be either in 13.3, 16.16 or 28.4 while "lfix_t" is in
 *      16.16 or 18.14 depending upon the formats been used.
 *
 * Currently, the code is modified to support three different combination
 * of formats. The following compiler switch can be selected depending
 * upon the resolution of the printer.
 * (1) FORMAT_13_3: 13.3 is used for short fixed format and 16.16 is used
 *                  for long fixed format.  Basically, it is the same as
 *                  the released code before this modification. The range of
 *                  number can be represented in integer is
 *                  [-2**12 .. 2**12 - 1]. It should be used on 300 dpi
 *                  printer ONLY.
 * (2) FORMAT_16_16: 16.16 is used for both short and long fixed format.
 *                   The range of number can be represented in integer is
 *                   [-2**14 .. 2**14 - 1].  Therefore, the maximum resolution
 *                   can be supported by this format is up to 1152dpi(72 * 16)
 *                   on the legal size paper(14").
 * (3) FORMAT_28_4: 28.4 is used for short fixed format and 18.14 is for
 *                  long fixed format. The range of number can be represented
 *                  in integer is [-2**16 .. 2**16 - 1]. The maximum resolution
 *                  can be supported by this format is up to 3456dpi(72 * 48)
 *                  with the size of paper (17" maximum).
 ***************************************************************************/
#ifdef FORMAT_13_3
#undef FORMAT_16_16
#undef FORMAT_28_4
#endif

#ifdef FORMAT_16_16
#undef FORMAT_13_3
#undef FORMAT_28_4
#endif

#ifdef FORMAT_28_4
#undef FORMAT_13_3
#undef FORMAT_16_16
#endif

/*************************************************************************
 * To change from 28.4 and 16.16 combination to 28.4 and 18.14 combination
 * there are 3 places needed to be changed.
 * (1). L_SHIFT:  16 --> 14.
 * (2). Change the section which defines for PAGE_*
 * (3). CTM_LIMIT: CTM_16 --> CTM_48
 *************************************************************************/

#ifdef FORMAT_13_3 /* The current one before upgrade */
typedef fix16           sfix_t; /* 13.3 format (SF format) */
typedef fix32           lfix_t; /* 16.16 format (LF format) */
#define S_SHIFT         3       /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#elif FORMAT_16_16
typedef fix32           sfix_t; /* 16.16 format (SF format) */
typedef fix32           lfix_t; /* 16.16 format (LF format) */
#define S_SHIFT         16      /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#elif FORMAT_28_4
typedef fix32           sfix_t; /* 28.4 format (SF format) */
typedef fix32           lfix_t; /* 16.16 or 18.14 format (LF format) */
#define S_SHIFT         4       /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#endif

#define ONE_SFX  (1L << S_SHIFT)        /* 1   in SF format representation */
#define HALF_SFX (ONE_SFX >> 1)         /* 0.5 in SF format representation */
#define ONE_LFX  (1L << L_SHIFT)        /* 1   in LF format representation */
#define HALF_LFX (ONE_LFX >> 1)         /* 0.5 in LF format representation */
#define L_S_DIFF (L_SHIFT - S_SHIFT)    /* the difference between them */
#define HALF_L_S ((1L << L_S_DIFF)>> 1)/* the real half value of above number */

#ifdef FORMAT_13_3
#define MIN_SFX         -32768          /* min. 16-bit integer */
#define MAX_SFX          32767          /* max. 16-bit integer */
#elif  FORMAT_16_16
#define MIN_SFX         -2147483648     /* min. 32-bit integer */
#define MAX_SFX          2147483647     /* max. 32-bit integer */
#elif  FORMAT_28_4
#define MIN_SFX         -2147483648     /* min. 32-bit integer */
#define MAX_SFX          2147483647     /* max. 32-bit integer */
#endif

#ifdef FORMAT_13_3
#define PAGE_LEFT       -4096.0         /* -4K          */
#define PAGE_RIGHT       4095.0         /*  4K-1        */
#define PAGE_TOP        -4096.0         /* -4K          */
#define PAGE_BTM         4095.0         /*  4K-1        */
#define PG_CLP_IEEE      0x45800000L    /*  4K          */
#define PG_CLP_HALF_IEEE 0x45000000L    /*  2K          */
#define CTM_4_IEEE       0x40800000L    /*  4           */
#elif  FORMAT_16_16
/* The range of the numbers can be in [-32K .. 32K-1] under 16.16 format.
   However, there are some math "add" or "sub" operations of these numbers
   during internal calculation. Therefore, the range has been shrunk down
   to [-16384 .. 16383] to prevent from overflow.
*/
#define PAGE_LEFT       -16384.0        /* -16K         */
#define PAGE_RIGHT       16383.0        /*  16K-1       */
#define PAGE_TOP        -16384.0        /* -16K         */
#define PAGE_BTM         16383.0        /*  16K-1       */
#define PG_CLP_IEEE      0x46800000L    /*  16K         */
#define PG_CLP_HALF_IEEE 0x46000000L    /*  8K          */
#define CTM_16_IEEE      0x41800000L    /*  16          */
#elif  FORMAT_28_4
/* Theoretically, the range of the numbers can be represented by 28.4
   format is [-2**27 .. 2**27 - 1]. When this 28.4 is used with 16.16,
   the range of number can be represented in integer are decreased down
   to [-16384 .. 16383] due to there are some math "add" or "sub"
   operations for the long fixed numbers.
   The following are for 28.4 and 16.16 combination formats.
*/
#define PAGE_LEFT       -16384.0        /* -16K         */
#define PAGE_RIGHT       16383.0        /*  16K-1       */
#define PAGE_TOP        -16384.0        /* -16K         */
#define PAGE_BTM         16383.0        /*  16K-1       */
#define PG_CLP_IEEE      0x46800000L    /*  16K         */
#define PG_CLP_HALF_IEEE 0x46000000L    /*  8K          */
#define CTM_16_IEEE      0x41800000L    /*  16          */
#endif
/* Theoretically, the range of the numbers can be represented by 28.4
   format is [-2**27 .. 2**27 - 1]. When this 28.4 is used with 18.14,
   the range of number can be represented in integer are decreased down
   to [-65536 .. 65535] due to there are some math "add" or "sub"
   operations for the long fixed numbers.
   The following are for 28.4 and 18.14 combination formats.
#define PAGE_LEFT       -65536.0        |* -64K         *|
#define PAGE_RIGHT       65535.0        |*  64K-1       *|
#define PAGE_TOP        -65536.0        |* -64K         *|
#define PAGE_BTM         65535.0        |*  64K-1       *|
#define PG_CLP_IEEE      0x47800000L    |*  64K         *|
#define PG_CLP_HALF_IEEE 0x47000000L    |*  32K         *|
#define CTM_48_IEEE      0x42400000L    |*  48          *|
#endif
*/

#ifdef FORMAT_13_3
#define CTM_LIMIT       CTM_4_IEEE
#elif  FORMAT_16_16
#define CTM_LIMIT       CTM_16_IEEE
#elif  FORMAT_28_4
/* For 28.4 and 16.16 combination
*/
#define CTM_LIMIT       CTM_16_IEEE
/* For 28.4 and 18.14 combination
#define CTM_LIMIT       CTM_48_IEEE
*/
#endif

typedef fix16   PH_IDX;         /* index to path header, in path_table */
typedef fix16   SP_IDX;         /* index to subpath header, in node_table */
typedef fix16   VX_IDX;         /* index to vertex, in node_table */
typedef fix16   ET_IDX;         /* index to edge_table */
typedef fix16   CP_IDX;         /* index to clip_trpzd, in node_table */
typedef ULONG_PTR  gmaddr;         /* graphics memory address */
// DJC change to ufix16 typedef fix16   SCANLINE;       /* scanline structure */
typedef ufix16   SCANLINE;       /* scanline structure */

typedef fix16   HORZLINE;       /* scanline structure */
typedef fix16   PIXELIST;

/*------------------*
 | macro definition |
 *------------------*/
/* object related */
#define         IS_REAL(a)      (TYPE(a)  == REALTYPE ? TRUE : FALSE)
#define         IS_INTEGER(a)   (TYPE(a)  == INTEGERTYPE ? TRUE : FALSE)
/* Modify for speed; 3/20/90; scchen
 *#define         IS_ZERO(a)      ((F2L(a) & 0x7FFFFFFFL) == F2L(zero_f))
 *#define         IS_NOTZERO(a)   ((F2L(a) & 0x7FFFFFFFL) != F2L(zero_f))
 */
#define         IS_ZERO(f) ((ufix32)  (!((*((long FAR *)(&f))) & 0x7fffffffL)))
#define         IS_NOTZERO(f) ((ufix32)  (((*((long FAR *)(&f))) & 0x7fffffffL)))

#define         GET_OBJ(obj, indx)\
                ((struct object_def FAR *)VALUE(obj) + indx)
#define         VALUE_OPERAND(n)\
                ( opnstack[opnstktop - (n + 1)].value )
#define         LENGTH_OPERAND(n)\
                ( opnstack[opnstktop - (n + 1)].length )
#define         DIFF(a)         (fabs(a) < (real32)1e-4 ? (real32)0 : (a))

#define         PUT_VALUE(val, indx, ary_obj)\
                {\
                  struct object_def l_obj;\
                         l_obj.bitfield = 0;\
                         TYPE_SET(&l_obj, REALTYPE);\
                         l_obj.length = 0;\
                         l_obj.value = (val);\
                         put_array(ary_obj, indx, &l_obj);\
                }

#define         GET_OBJ_VALUE(f, obj)\
                {\
                        if (IS_REAL(obj))\
                                f = L2F(VALUE(obj));\
                        else\
                                f = (real32)((fix32)VALUE(obj));\
                }

#ifdef _AM29K
#define _clear87()      _clear_fp()
#define _status87()     _status_fp()
extern _clear_fp(), _status_fp();
#endif

#define         CHECK_INFINITY(f)\
                {\
                        if(_status87() & PDL_CONDITION){\
                                f = infinity_f ;\
                                _clear87() ;\
                        }\
                }

/* arithematic operations of the fix point real numbers */
/***************************************************************************
 * The following defines need to be modified according to the adopted format.
 * Some of the defines can still be used are kept without any changes. The
 * unused defines are removed.  The defines will be affected by the format
 * are modifed and only one of them should be activated.  @RESO_UPGR
 ***************************************************************************/
/* The defines have been used before upgrade.
#define F2LFX(f)        ((lfix_t)(floor((f) * 65536 + 0.5)))
#define F2LFX8(f)       ((lfix_t)(floor((f) *   256 + 0.5)))
#define F2SFX(f)        ((sfix_t)((((lfix_t)((f) * 65536)) +  4096L) >> 13))
#define F2SFX12(f)      ((sfix_t)((((lfix_t)((f) * 65536)) +     8L) >>  4))
#define LFX2F(lfx)      ((real32)(lfx) / 65536)         |* @FIXPNT *|
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) +  4096L) >> 13))
#define LFX2I(lfx)      ((fix)   (((lfx) + 32768L) >> 16))      |* @you *|
#define SFX2F(sfx)      ((real32)(sfx) / 8)
#define SFX2LFX(s)      ((lfix_t)(s) << 13)
#define SFX2I(sfx)      ((fix)(((sfx) + 4) >> 3))               |* @you *|
#define I2LFX(i)        ((lfix_t)(i) << 16)
#define I2SFX(i)                ((i) << 3)              |* @I2SFX *|

#define F2LFX_T(f)      ((lfix_t)((f) * 65536))
#define F2LFX8_T(f)     ((lfix_t)((f) *  256))
#define F2SFX_T(f)      ((sfix_t)((f) *     8))
#define F2SFX12_T(f)    ((sfix_t)((f) *  4096))                  |* @STK_INT *|
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> 13) )
#define LFX2I_T(lfix)   ( (fix) ((lfix) >> 16) )    |* truncate to long fix  *|
#define SFX2I_T(sfix)   ( (fix) ((sfix) >>  3) )    |* truncate to short fix *|
*/

/* #define F2LFX(f)     ((lfix_t)(floor((f) * 65536 + 0.5))) */
#define F2LFX(f)        ((lfix_t)(floor((f) * ONE_LFX + 0.5)))

/* #define F2LFX8(f)       ((lfix_t)(floor((f) * 256 + 0.5))) not used */

/* #define F2SFX(f)     ((sfix_t)((((lfix_t)((f) * 65536)) + 4096L) >> 13)) */
#ifdef FORMAT_13_3
#define F2SFX(f)    ((sfix_t)(((lfix_t)((f) * ONE_LFX) + HALF_L_S) >> L_S_DIFF))
#elif  FORMAT_16_16
#define F2SFX(f)    F2LFX(f)
#elif  FORMAT_28_4
#define F2SFX(f)    ((sfix_t)(((lfix_t)((f) * ONE_LFX) + HALF_L_S) >> L_S_DIFF))
#endif

/*#define F2SFX12(f) ((sfix_t)((((lfix_t)((f) * 65536)) + 8L) >> 4)) not used */

/* #define LFX2F(lfx)   ((real32)(lfx) / 65536) */
#define LFX2F(lfx)      ((real32)(lfx) / ONE_LFX)

/* LFX2SFX(lfx) is used in stroke.c and image.c
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + 4096L) >> 13))
*/
#ifdef FORMAT_13_3
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + HALF_L_S) >> L_S_DIFF))
#elif  FORMAT_16_16
#define LFX2SFX(lfx)    (lfx)
#elif  FORMAT_28_4
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + HALF_L_S) >> L_S_DIFF))
#endif

/* #define LFX2I(lfx)   ((fix)(((lfx) + 32768L) >> 16)) */
#define LFX2I(lfx)      ((fix)(((lfx) + HALF_LFX) >> L_SHIFT))

/*#define SFX2F(sfx)    ((real32)(sfx) / 8) */
#define SFX2F(sfx)      ((real32)(sfx) / ONE_SFX)

/*#define SFX2LFX(s)    ((lfix_t)(s) << 13) */
#ifdef FORMAT_13_3
#define SFX2LFX(s)      ((lfix_t)(s) << L_S_DIFF)
#elif  FORMAT_16_16
#define SFX2LFX(s)      (s)
#elif  FORMAT_28_4
#define SFX2LFX(s)      ((lfix_t)(s) << L_S_DIFF)
#endif

/*#define SFX2I(sfx)    ((fix)(((sfx) + 4) >> 3)) */
#define SFX2I(sfx)      ((fix)(((sfx) + HALF_SFX) >> S_SHIFT))

/*#define I2LFX(i)      ((lfix_t)(i) << 16) */
#define I2LFX(i)        ((lfix_t)(i) << L_SHIFT)

/*#define I2SFX(i)      ((i) << 3) */
#define I2SFX(i)        ((i) << S_SHIFT)

/*#define F2LFX_T(f)    ((lfix_t)((f) * 65536)) */
#define F2LFX_T(f)      ((lfix_t)((f) * ONE_LFX))

/* F2LFX8_T(f) is used in get_rect_points_i() ONLY. It is a generic
   define regardless the format used.  */
#define F2LFX8_T(f)     ((lfix_t)((f) * 256))

/* #define F2SFX_T(f)   ((sfix_t)((f) * 8)) */
#define F2SFX_T(f)      ((sfix_t)((f) * ONE_SFX))

/* F2SFX12_T(f) is used in init_stroke() ONLY. It is a generic define
   regardless the format used as F2LFX8_T(). please refer to
   stk_info.half_width_i and get_rect_points_i() for detail.
*/
#define F2SFX12_T(f)    ((fix32)((f) * 4096))

/*#define LFX2SFX_T(lfx) ((sfix_t)((lfx) >> 13)) */
#ifdef FORMAT_13_3
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> L_S_DIFF))
#elif  FORMAT_16_16
#define LFX2SFX_T(lfx)  (lfx)
#elif  FORMAT_28_4
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> L_S_DIFF))
#endif

/*#define LFX2I_T(lfix) ((fix)((lfix) >> 16)) */
#define LFX2I_T(lfix)   ((fix)((lfix) >> L_SHIFT))

/*#define SFX2I_T(sfix) ((fix)((sfix) >> 3)) */
#define SFX2I_T(sfix)   ((fix)((sfix) >> S_SHIFT))

/* These macros need to be modified too
#define I_OF_LFX(lfix)  ( (lfix) >> 16 )            |* take integer part     *|
#define F_OF_LFX(lfix)  ( (lfix) & 0x0000FFFF )     |* take fraction part    *|
#define I_OF_SFX(sfix)  ( (sfix) >> 3)              |* take integer part     *|
#define F_OF_SFX(sfix)  ( (sfix) & 7)               |* take fraction part    *|
*/
#define I_OF_LFX(lfix)  ((lfix) >> L_SHIFT)        /* take integer part */
#define F_OF_LFX(lfix)  ((lfix) & ((1L << L_SHIFT) - 1))
                                                   /* take fraction part */

/* #define I_OF_SFX(sfix)  ( (sfix) >> 3)          is not used */
/* #define F_OF_SFX(sfix)  ( (sfix) & 7)           is not used */
/* End of macro defines change @RESO_UPGR */

/* The following macro was in shape.c */
#define     LABS(i)      ((i) > (fix32)0    ? (i) : -(i))

/* IEEE floating point format */
#define SIGN(f)            (((f) & 0x80000000L))
#define EXP(f)  ((ufix32)  (((f) & 0x7f800000L)))
#define MAT(f)  ((ufix32)  (((f) & 0x007fffffL)))
#define MAGN(f) ((ufix32)  (((*((long32 FAR *)(&f))) & 0x7fffffffL)))
                           /* get magnitude, ignore sign bit */
#define SIGN_F(f) ((ufix32)  (((*((long FAR *)(&f))) & 0x80000000L)))

/* macro to align a bounding box to the word boundary @ALIGN_W
 *      |<== x                 y ====>|
 *      |    +-----------------+      |
 *           |                 |
 *           |                 |
 *      ^    +-----------------+      ^
 *      |                             |
 *    word                          word
 *    ALIGN_L(x)                    ALIGN_R(y)
 */
#define ALIGN_L(x)    ( (x) & 0xfff0 )
#define ALIGN_R(x)    ( ((x) & 0xfff0) + 15 )

/*-----------------------*
 | Common Data Structure |
 *-----------------------*/

struct sp_lst {         /* a list of subpaths */
        SP_IDX   head;
        SP_IDX   tail;
};

struct cp_lst {         /* a list of clipping trapezoids */
        CP_IDX   head;
        CP_IDX   tail;
};

struct list_hdr {       /* general header for a list */
        fix16     head;
        fix16     tail;
};

struct coord {          /* floating point coordinate structure */
        real32  x;
        real32  y;
};

struct coord_i {        /* fixed point coordinates @PRE_CLIP */
        sfix_t   x;
        sfix_t   y;
};

struct rectangle_i {    /* rectangle in integer coordinates */
        sfix_t  ux;
        sfix_t  uy;
        sfix_t  lx;
        sfix_t  ly;
};

struct  polygon {       /* 8 sides polygon in float coordinates */
        fix16   size;
        struct  coord p[8];
};

struct  polygon_i {     /* 8 sides polygon in integer coordinates */
        fix16   size;
        struct  coord_i p[8];
};

/* ***** stroke structure, moved from stroke.c, 3/18/91   -jwm, -begin- */
/* line_segment structure:
 *                      pgn[1]                           pgn[2]
 *                            +------------------------+
 *                      p0    +------------------------+ p1
 *                            +------------------------+
 *                      pgn[0]                           pgn[3]
 */
struct  line_seg {
        struct coord p0;        /* starting point of central line */
        struct coord p1;        /* ending point of central line */
        struct coord vct_u;     /* vector of p0 -> pgn[0] in user space */
        struct coord vct_d;     /* vector of p0 -> pgn[0] in device space */
        struct coord pgn[4];    /* outline of the line segment */
};
struct  line_seg_i {      /* @STK_INT */
        struct coord_i p0;        /* starting point of central line */
        struct coord_i p1;        /* ending point of central line */
        struct coord   vct_u;     /* vector of p0 -> pgn[0] in user space */
        struct coord_i vct_d;     /* vector of p0 -> pgn[0] in device space */
        struct coord_i pgn[4];    /* outline of the line segment */
};
/* ***** stroke structure, moved from stroke.c, 3/18/91   -jwm, -end- */

/* structures for enhancement of image */
struct  gray_chain_hdr {        /* @Enhance OP_IMAGE */
        fix16   start_seed_sample;
};

struct g_sample_hdr {
        fix16   bb_lx;
        fix16   bb_ly;
        fix16   bb_xw;          /* @IMAGE  01-16-89  Y.C. */
        fix16   bb_yh;          /* @IMAGE  01-16-89  Y.C. */
        fix16   seed_index;     /* @#IMAGE 04-27-88  Y.C. */
        fix16   gray_level;
};

struct vertex {         /* data structure of a vertex */
        fix     x, y;           /*   x and y coordinates of a vertex */
};

struct sample {         /* data structure of image seed pattern */
        struct vertex p[4];     /*   x and y coordinates of vertice of a seed */
};

/* data structures for 'xxx_image_proc'; were unodes  -jwm, 12/26 -begin- */
struct isp_data  {
        fix16   bb_x;
        fix16   bb_y;
        fix16   index;
        fix16   next;
};
/* data structures for 'xxx_image_proc'; were unodes  -jwm, 12/26 -end- */

/*-------------------------------*
 | Graphics State Data Structure |
 *-------------------------------*/

struct clr_hdr {                /* color structure */
        fix16   adj_gray;       /* index to gray table */
        real32  gray;           /* gray value */
        real32  hsb[3];         /* hue, sat, brt */
        fix16   inherit;        /* TRUE: inherit form previous */
};

struct gray_hdr {               /* adjust gray structure */
        fix16   val[256];
};

struct cp_hdr {                 /* Clipping trapezoid structure */
        CP_IDX  head;           /* index to edge table, to the head and tail */
        CP_IDX  tail;           /* of clipping trapezoids                    */
        sfix_t  bb_ux;          /* bounind box of clipping path:             */
        sfix_t  bb_uy;          /*      (ux, uy), (lx, ly)                   */
        sfix_t  bb_lx;          /*                                           */
        sfix_t  bb_ly;
        fix16   single_rect;    /* TRUE: single rectangle clipping region */
        fix16   inherit;        /* TRUE: inherit from previous gsave level */
};

struct scrn_hdr {               /* Halftone screen structure */
        fix16   chg_flag;       /* indicate repeat pattern need to update */
        real32  freq;
        real32  angle;
        fix16   no_whites;
        struct  object_def proc;
        fix16   spotindex;
                /* @@@ gstate manipulator should update fields above  */
        fix16   majorfact;
        fix16   minorfact;
        fix16   size_fact;
        fix16   cell_fact;
        fix16   scalefact;
        fix16   patt_size;
        fix16   cell_size;
        fix16   no_pixels;
                                /* the following fields inserted for
                                 * strange spots of binary pattern
                                 */
        fix16   ht_binary;
        fix16   bg_pixels;
        real32  back_gray;
        fix16   fg_pixels;
        real32  fore_gray;
};

struct dsh_hdr {                        /* dash pattern structure */
        fix16   pat_size;               /* no# of pattern element */
        real32  pattern[MAXDASH];       /* MAXDASH = 11 */
        struct  object_def pattern_obj;
        real32  offset;
                                        /* adjusted dash pattern @EHS_STK */
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

struct dev_hdr {                /* device related structure */
        real32  default_ctm[6];
        struct  rectangle_i default_clip;
        struct  object_def  device_proc;
        fix16   width;
        fix16   height;
        byte    chg_flg;        /* indicate device header needs to update */
        byte    nuldev_flg;     /* null device */
};

struct gs_hdr {                                 /* Graphics State structure */
        fix16   save_flag;                      /* set by save operator */
        real32  ctm[6];                         /* current transform matrix */
        struct  clr_hdr color;                  /* color */
        struct  coord   position;               /* current point */
        fix16   path;                           /* current path */
        struct  cp_hdr  clip_path;              /* clipping path */
        struct  object_def  font;               /* current typeface */
#ifdef KANJI
        struct  object_def  rootfont;           /* current rootfont */
#endif
        real32  line_width;                     /* line width */
        fix16   line_cap;                       /* line cap */
        fix16   line_join;                      /* line join */
        struct  scrn_hdr    halftone_screen;    /* halftone screen */
        struct  object_def transfer;            /* gray transfer function */
        real32  flatness;                       /* flatness */
        real32  miter_limit;                    /* miter limit */
        struct  dsh_hdr dash_pattern;           /* dash pattern */
        struct  dev_hdr device;                 /* device dependent */
                                                /* Jack Liaw 7-26-90 */
        bool8   graymode;                       /* FALSE:mono; TRUE:gray */
        bool8   interpolation;                  /* FALSE/TRUE */
};


/*----------------------------*
 | Path Header Data Structure |
 *----------------------------*/

struct ph_hdr {
        bool16  rf;             /* rf = P_RVSE : reverse_path,
                                 * rf = P_FLAT : flatten_path,
                                 * rf = P_NACC : can't be pathforall
                                 * rf = P_DFRGS: defer copying nodes @DFR_GS
                                 */
        real32  flat;           /* flatness of previous subpath(s) */
        SP_IDX  head;           /* index to node table, to the first subpath */
        SP_IDX  tail;           /* index to node table, to the last subpath */
        PH_IDX  previous;       /* index to path table, to previous path */
        CP_IDX  cp_path;        /* path defined in clip_path @CPPH */
};


/*---------------------*
 | Node Data Structure |
 *---------------------*/
/* node_table is an union of 4 structures: subpath, vertex, clip trapezoid,
 * and sample cell
 */

/* Structure 1: subpath header */
struct vx_hdr {
    bool8   type;   /* MOVETO/LINETO/CURVETO/CLOSEPATH; */
    bool8   flag;   /* for first node(MOVETO) only
                     * 1.SP_DUP:
                     *        duplicated subpath; if it is not on the top
                     *        gs_level, it is a useless subpath
                     * 2.SP_OUTPAGE:
                     *        subpath outside page boundary
                     * 3.SP_CURVE:
                     *        subpath contains curves
                     */
    real32  x, y;   /* vertex position */
    VX_IDX  tail;   /* tail of subpath; first node only */
    SP_IDX  next_sp;/* next subpath; first node only */
};
#define sp_hdr vx_hdr

/* Structure 3: short fixed vertex for font & stroke internal usage @SVX_NODE */
struct svx_hdr {
    bool16  type;   /* MOVETO/LINETO/CURVETO/CLOSEPATH */
    sfix_t x, y; /* vertex position */
};

/* Structure 4: clip trapezoid */
struct tpzd {                           /* clip_tpzd --> tpzd, @SCAN_EHS */
    sfix_t topy;  /* y coordinate of upper horiz. line */
    sfix_t topxl; /* left x_coordinate */
    sfix_t topxr; /* right x_coordinate */
    sfix_t btmy;  /* y coordinate of bottom horiz. line */
    sfix_t btmxl; /* left x_coordinate */
    sfix_t btmxr; /* right x_coordinate */
};

/* Structure 5: sample cell */
struct sample_hdr {
    fix16   bb_lx;
    fix16   bb_ly;
    fix16   seed_index;     /* @#IMAGE 04-27-88  Y.C. */
};

struct nd_hdr {
    VX_IDX  next;                            /* next node */
    union {
        struct  sp_hdr     subpath_node;      /* subpath header */
        struct  vx_hdr     vertex_node;       /* vertex */
        struct  svx_hdr    svx_node;          /* short fixed vertex @SVX_NODE*/
        struct  tpzd       clip_tpzd;         /* clip trapezoid */
        struct  sample_hdr seed_sample_node;  /* sample cell for image */
        struct  rectangle_i clip_sample_node; /* @JJ */
    } unode;
};

/* #define SP_HEAD      unode.subpath_node.head         @NODE */
#define SP_NEXT         unode.subpath_node.next_sp   /* @NODE */
#define SP_TAIL         unode.subpath_node.tail
#define SP_FLAG         unode.subpath_node.flag
#define VX_TYPE         unode.vertex_node.type
#define VERTEX_X        unode.vertex_node.x
#define VERTEX_Y        unode.vertex_node.y
#define CP_TPZD         unode.clip_tpzd                 /* @CPPH */
#define CP_TOPY         unode.clip_tpzd.topy
#define CP_TOPXL        unode.clip_tpzd.topxl
#define CP_TOPXR        unode.clip_tpzd.topxr
#define CP_BTMY         unode.clip_tpzd.btmy
#define CP_BTMXL        unode.clip_tpzd.btmxl
#define CP_BTMXR        unode.clip_tpzd.btmxr
#define SAMPLE_BB_LX    unode.seed_sample_node.bb_lx
#define SAMPLE_BB_LY    unode.seed_sample_node.bb_ly
#define SEED_INDEX      unode.seed_sample_node.seed_index
#define SAMPLE_P0_X     unode.clip_sample_node.lx
#define SAMPLE_P0_Y     unode.clip_sample_node.ly
#define SAMPLE_P1_X     unode.clip_sample_node.ux
#define SAMPLE_P1_Y     unode.clip_sample_node.ly
#define SAMPLE_P2_X     unode.clip_sample_node.ux
#define SAMPLE_P2_Y     unode.clip_sample_node.uy
#define SAMPLE_P3_X     unode.clip_sample_node.lx
#define SAMPLE_P3_Y     unode.clip_sample_node.uy
#define VXSFX_TYPE      unode.svx_node.type              /* @SVX_NODE */
#define VXSFX_X         unode.svx_node.x
#define VXSFX_Y         unode.svx_node.y

/*
 *                         Figure of Path
 *                         --------------
 *
 *
 *        path_table[]                   node_table[1500]
 *
 *          'Path'                       'Subpath' + 'Vertex'
 *      (ph_hdr structure)                (nd_hdr structure)
 *       +-----------+
 *       ! rf        !
 *       +-----------+          'Subpath'
 *       ! flat      !      (sp_hdr structure)
 *       +-----------+       +--------------+
 *       ! head      +------>!   SUBPATH    !
 *       +-----------+       +--------------+         'Vertex'
 *       ! tail      +--+    ! flag         !     (vx_hdr structure)
 *       +-----------+  !    +--------------+   +--------+   +--------+
 *       ! previous  !  !    ! head         +-->! MOVETO !   ! LINETO !
 *       +-+---------+  !    +--------------+   +--------+   +--------+
 *         !            !    ! tail         +-+ ! x, y   !   ! x, y   !
 *         v            !    +--------------+ ! +--------+   +--------+
 *       +-----------+  !    ! next         ! ! ! next   +-+>! next   !
 *       ! rf        !  !    +-+------------+ ! +--------+ ! +--------+
 *       +-----------+  !      !              +------------+
 *       ! flat      !  !      v
 *       +-----------+  !      ~
 *       ! head      +  !      ~
 *       +-----------+  !      !
 *       ! tail      +  !      v
 *       +-----------+  !    +--------------+
 *       ! previous  !  +--> !              !
 *       +-+---------+       !              !
 *         !                 +--------------+
 *         !                 +-+------------+
 *         !                   !
 *         ~                   ~
 *
 */
/*      @NODE
 *                         Figure of Path
 *                         --------------
 *
 *
 *        path_table[]                   node_table[1500]
 *
 *          'Path'                       'Subpath' + 'Vertex'
 *      (ph_hdr structure)                (nd_hdr structure)
 *       +-----------+
 *       ! rf        !
 *       +-----------+
 *       ! flat      !        (first node)
 *       +-----------+       +------+-----+    +------+-----+    +------+-----+
 *       ! head      +------>!MOVETO| flag!    !LINETO| *** !    !LINETO| *** !
 *       +-----------+       +------+-----+    +------+-----+    +------+-----+
 *       ! tail      +--+    !   x, y     !    !   x, y     !    !   x, y     !
 *       +-----------+  !    +------------+    +------------+    +------------+
 *       ! previous  !  !    !   next     +--->!   next     +-+->!   NULL     !
 *       +-+---------+  !    +------------+    +------------+ |  +------------+
 *         !            !    !   tail     +-+  !    ***     ! |  !    ***     !
 *         v            !    +------------+ |  +------------+ |  +------------+
 *       +-----------+  !    !  next_sp   ! |  !    ***     ! |  !    ***     !
 *       ! rf        !  !    +-----+------+ |  +------------+ |  +------------+
 *       +-----------+  !          !        |                 |
 *       ! flat      !  !          v        +-----------------+
 *       +-----------+  !          ~
 *       ! head      +  !          ~
 *       +-----------+  !          !
 *       ! tail      +  !          v
 *       +-----------+  !    +--------------+
 *       ! previous  !  +--> !              !
 *       +-+---------+       !              !
 *         !                 +--------------+
 *         !                 +-----+--------+
 *         !                       !
 *         ~                       ~
 *
 */


/*----------------------*
 | Edge Table Structure |
 *----------------------*/
/*
 * edge_table is an union of 3 different structures
 */

/* Structure 1: shape_reduction */
struct et_reduce {              /* For shape_reduction */
        sfix_t  top_y;       /* larger y coordinate of edge */
        sfix_t  top_x;       /* x coordinate that goes with top_y */
        sfix_t  left_x;      /* x coordinate for left split */
        sfix_t  left_y;      /* y coordinate for left split */
        sfix_t  right_x;     /* x coordinate for right split */
        sfix_t  end_y;       /* smaller y coordinate of edge */
        sfix_t  end_x;       /* x coordinate that goes with end_y */
        sfix_t  x_intersect; /* x coordinate that y_scan line
                              * intersects with the edge.
                              */
        sfix_t  x_isect0;    /* x coordinate that y_scan line     12/06/88
                              * intersects with previous edge.
                              */
        ufix8   flag;         /* bit 0 -- horizontal edge: HORIZ_EDGE
                               * bit 1 -- useless edge: FREE_EDGE
                               * bit 2 -- direction of edge: WIND_UP
                               * bit 3 -- intersect with scan line:
                               *          CROSS_PNT
                               */
        fix8    winding_no;   /* winding number of the area on the
                               * right side of the edge.
                               */
};
#define ET_TOPX         et_item.et_reduce.top_x
#define ET_TOPY         et_item.et_reduce.top_y
#define ET_LFTX         et_item.et_reduce.left_x
#define ET_LFTY         et_item.et_reduce.left_y
#define ET_RHTX         et_item.et_reduce.right_x
#define ET_ENDX         et_item.et_reduce.end_x
#define ET_ENDY         et_item.et_reduce.end_y
#define ET_XINT         et_item.et_reduce.x_intersect
#define ET_XINT0        et_item.et_reduce.x_isect0              /* 12/06/88 */
#define ET_FLAG         et_item.et_reduce.flag
#define ET_WNO          et_item.et_reduce.winding_no
/* for horizontal edge */
#define HT_Y            ET_TOPY
#define HT_XL           ET_TOPX
#define HT_XR           ET_ENDX

/* Structure 2: Font QEM filling @12/09/88= by you */
struct  qem_et_fill  {
        fix16   ystart;         /* starting y-scanline of the edge   */
        fix16   ylines;         /* number of y-scanlines of the edge */
        lfix_t  xintc;          /* x-intercept that goes with ystart */
        lfix_t  xchange;        /* delta of x-intercept per y-scanline */
        fix16   dir;            /* edge direction?  */
};      /*
         * all short names (macros) about this are defined
         *      in FONTQEM.EXT to show locality of this structure.
         */

/* Structure 3: cross point table; for shape_reduction */
struct xpnt_hdr {               /* cross point table */
        sfix_t  x;              /* x coordinate of the cross point */
        sfix_t  y;              /* y coordinate of the cross point */
        struct edge_hdr FAR *edge1; /* edge intersects with the following edge */
        struct edge_hdr FAR *edge2;                 /* @ET */
};
#define XT_X     et_item.xpnt.x
#define XT_Y     et_item.xpnt.y
#define XT_EDGE1 et_item.xpnt.edge1
#define XT_EDGE2 et_item.xpnt.edge2

struct edge_hdr {                               /* edge table */
        union {
                struct  et_reduce et_reduce;    /* shape_reduction */
                struct  qem_et_fill qem_et_fill;/* font QEM fill */
                struct  xpnt_hdr  xpnt;         /* cross point table */
        } et_item;
};

/*---------------------*
 | tpzd_info structure |        @FILL_INFO
 *---------------------*/
/* bounding box information of the trapezoid to be filled, used by savetpzd.c &
 * fillgb.c
 */
struct tpzd_info {
        union {
                struct {
                        fix  box_x;     /* x-coordinate of upper-left corner */
                        fix  box_y;     /* y-coordinate of upper-left corner */
                } coord;
                gmaddr  bitmap;         /* address of character bitmap */
        } orig;
        fix  box_w;          /* width of the bounding box */
        fix  box_h;          /* height of the bounding box */
};
#define BMAP   orig.bitmap
#define BOX_X  orig.coord.box_x
#define BOX_Y  orig.coord.box_y

/*-------------------------------*
 | active dash pattern structure |
 *-------------------------------*/
 /* for op_stroke/op_strokepath  */
struct actdp {
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

/*-----------*
 | constants |
 *-----------*/
#define NULLP           -1              /* 2 bytes, null index */
#define NOCURPNT        0xff800000L     /* -infinitive, IEEE standard
                                         * null coordinates
                                         */
/*#define BTMSCAN         3330          bottom scan line of the page, not used */

/* The following defines need to be changed for resolution upgrade. @RESO_UPGR
   They have been moved to the beginning of this file.
#define ONE_LFX         65536L          |* 1   in long  fix representation *|
#define HALF_LFX        32768L          |* 0.5 in long  fix representation *|
#define ONE_SFX         8               |* 1   in short fix representation *|
#define HALF_SFX        4               |* 0.5 in short fix representation *|
#define MIN_SFX         -32768
#define MAX_SFX         32767           |* max. 16-bits integer *|
*|
|* page boundary *|                     |* @PRE_CLIP *|
#define PAGE_LEFT       -4096.0         |* -4K          *|
#define PAGE_RIGHT       4095.0         |*  4K-1        *|
#define PAGE_TOP        -4096.0         |* -4K          *|
#define PAGE_BTM         4095.0         |*  4K-1        *|
*/

/* node type */
#define SUBPATH         1
#define MOVETO          2
#define LINETO          3
#define CURVETO         4
#define CLOSEPATH       5
#define PSMOVE          6

/* rf field of path header */
#define P_RVSE          01
#define P_FLAT          02
#define P_NACC          04
#define P_DFRGS        010  /* defer copying nodes of gsave operator @DFR_GS */

/* flag of subpath header(sp_flag) */
#define SP_OUTPAGE      01
#define SP_CURVE        02
#define SP_DUP          04

/* arc direction */
#define CNTCLK          1
#define CLKWISE         2

/* action */
#define ACT_PAINT       1
#define ACT_CLIP        2
#define ACT_SAVE        3
#define ACT_IMAGE       4

/* fill type */
#define F_NORMAL        1
#define F_FROM_CACHE    2       /* source from cache memory */
#define F_BSTREAM       3       /* filling for Bitstream font */
#define F_ITFONT        4       /* filling for Inteli_font */
#define F_FROM_CRC      5       /* source from circle cache memory */
#define F_FROM_IMAGE    6       /* @IMAGE  01-16-89  Y.C.
                                   fill_shape() call init_image_page()
                                                 and clip_image_page() */

/* fill destination */
#define F_TO_PAGE       1       /* fill to page */
#define F_TO_CACHE      2       /* fill to cache */
#define F_TO_CLIP       3
#define F_TO_IMAGE      4       /* @IMAGE */
#define SAVE_CLIP       5       /* to save clip path; from clip operator */
#define F_TO_MASK       6       /* @IMAGE  01-16-89  Y.C.
                                   fill_shape() call init_image_page()
                                                 and clip_image_page() */

/* clip status  @IMAGE */
#define OUT_CLIPPATH    0
#define CLIP            1
#define INSIDE_CLIPPATH 2


/* winding type */
#define NON_ZERO        1
#define EVEN_ODD        2

/* flag on edge_table: et_reduce.flag @ET */
#define HORIZ_EDGE      0x01
#define FREE_EDGE       0x02
#define WIND_UP         0x04
#define CROSS_PNT       0x08

/* type of linejoin */
#define MITER_JOIN      0
#define ROUND_JOIN      1
#define BEVEL_JOIN      2

/* type of linecap */
#define BUTT_CAP        0
#define ROUND_CAP       1
#define SQUARE_CAP      2

/*      System/Device Parameters        from HalfTone                   */
#define MIN_RESOLUTION   60                                     /* @RES */
#define MAX_RESOLUTION  300                                     /* @RES */
#define TOLERANCE       1e-7

#define END_OF_SCANLINE 0x8000          /* -32768   */

#define MATRIX_LEN      6

#define ARRAY_ONLY      0
#define G_ARRAY         1

#define OUT_POINT       0
#define IN_POINT        1
#define RLINETO         -1
#define RMOVETO         -1
#define RCURVETO        -1

#define OP_FILL         1
#define OP_EOFILL       2
#define OP_STROKE       3
#define OP_IMAGEMASK    4

/* type of print_page, for lower level graphics primitives @PRT_FLAG */
#define COPYPAGE        0
#define SHOWPAGE        1

/* used by "gstate.c" */
#define RESTORE         999

/* used for checking status87 */
#ifdef _AM29K
/* Define or appropriate bits for 29027 -- zero divide (bit 5),
 * overflow (bit 2), reserved (bit 1), and invalid (bit 0).
 */
#define PDL_CONDITION   32+4+2+1        /* phchen 03/26/91 */
#else
#define PDL_CONDITION   SW_ZERODIVIDE+SW_OVERFLOW+SW_INVALID
#endif

/* input flag to convex_clipper @SCAN_EHS */
#define CC_IMAGE        1       /* calling from image */
#define CC_TPZD         2       /* input is a trapezoid */

#ifdef WIN
/* Ada 3/20/91 for pattern fill */
#define PF_HEIGHT       16
#define PF_WIDTH        32
#define PF_BSIZE        (PF_HEIGHT * (PF_WIDTH >> WORDPOWER))

#define PF_REP          2
#define PF_OR           1
#define PF_NON          0
#endif

/* ***********  Constants from FILLPROC.DEF  11-24-88  **************** */


/************************************************************************
 *      Macro Definitions of Bitmap                     11-24-88        *
 ************************************************************************/
#define bSwap TRUE      /*@WIN*/

#define HT_ALIGN_MASK  (0xFFFFFFE0)             /* alignment mask of halftone */

/* @WIN: set following two macro from ufix => ufix32, so they may be
 * consistent with BM_DATP; scchen */
#define BM_WORD_POWER  ((sizeof(ufix32)   / 2) + 3) /* shift power to word  @WIN  */
#define BM_PIXEL_WORD  (sizeof(ufix32) * 8)     /* number of pixels per word @WIN */
#define BM_PIXEL_MASK  ( (BM_PIXEL_WORD - 1))   /* mask for pixel from word   */
#define BM_ALIGN_MASK  (~(BM_PIXEL_WORD - 1))   /* mask for word alignment    */
#define BM_ALIGN(X)    (((X) & BM_ALIGN_MASK))  /* floor   word alignment     */
                                                /* celling word alignment     */
#define BM_BOUND(X)    (((X) + BM_PIXEL_MASK) & BM_ALIGN_MASK)
#define BM_FRONT(X)    (((X) | BM_PIXEL_MASK) + 1)
#define BM_PIXEL(B)    ((B) * (sizeof(ufix8) * 8))        /* words  -> pixels */
#define BM_BYTES(W)    (BM_BOUND(W) / (sizeof(ufix8) * 8))/* pixels -> bytes  */
#define BM_WORDS(W)    (BM_BOUND(W) / (sizeof(ufix32)  * 8))/* pixels -> words @WIN */

#define BM_WHITE       ((ufix32) 0x00000000)    /* all white pixels in a word @WIN*/
#define BM_BLACK       ((ufix32) 0xFFFFFFFF)    /* all black pixels in a word @WIN*/
#ifdef  LBODR
#define BM_LEFT_SHIFT(D, S)                                             \
                       ((ufix32) ((D) >> (S)))          /* @WIN */
#define BM_RIGH_SHIFT(D, S)                                             \
                       ((ufix32) ((D) << (S)))          /* @WIN */
#else
#define BM_LEFT_SHIFT(D, S)                                             \
                       ((ufix32) ((D) << (S)))          /* @WIN */
#define BM_RIGH_SHIFT(D, S)                                             \
                       ((ufix32) ((D) >> (S)))          /* @WIN */
#endif
                                                /* left  most pixel in a word */
#define BM_L_PIX  ((ufix32) (BM_LEFT_SHIFT(BM_BLACK, BM_PIXEL_WORD - 1)))/*@WIN*/
                                                /* right most pixel in a word */
#define BM_R_PIX  ((ufix32) (BM_RIGH_SHIFT(BM_BLACK, BM_PIXEL_WORD - 1)))/*@WIN*/


#define BM_P_MASK(C)                                                          \
                (BM_RIGH_SHIFT(BM_L_PIX, (C) & BM_PIXEL_MASK))  /* ----*---- */
#define BM_L_MASK(C)                                                          \
                (BM_RIGH_SHIFT(BM_BLACK, (C) & BM_PIXEL_MASK))  /* ----***** */
#define BM_R_MASK(C)                                                          \
                (BM_LEFT_SHIFT(BM_BLACK, (((C) ^ BM_PIXEL_MASK)               \
                                             & BM_PIXEL_MASK))) /* *****---- */


/************************************************************************
 *      Macro Definitions of Character Cache            11-24-88        *
 ************************************************************************/


#define CC_WORD_POWER  ((sizeof(ufix16) / 2) + 3)   /* shift power to word    */
#define CC_PIXEL_WORD  ((sizeof(ufix16) * 8))   /* number of pixels per word */
#define CC_PIXEL_MASK  ( (CC_PIXEL_WORD - 1))   /* mask for pixel from word  */
#define CC_ALIGN_MASK  (~(CC_PIXEL_WORD - 1))   /* mask for word alignment   */
#define CC_ALIGN(X)    (((X) & CC_ALIGN_MASK))  /* floor   word alignment    */
                                                /* celling word alignment    */
#define CC_BOUND(X)    (((X) + CC_PIXEL_MASK) & CC_ALIGN_MASK)
#define CC_FRONT(X)    (((X) | CC_PIXEL_MASK) + 1)
#define CC_PIXEL(B)    ((B) * (sizeof(ufix8) * 8)))        /* words -> pixels */
#define CC_BYTES(W)    (CC_BOUND(W) / (sizeof(ufix8)  * 8))/* pixels -> bytes */
#define CC_WORDS(W)    (CC_BOUND(W) / (sizeof(ufix16) * 8))/* pixels -> words */

#define CC_WHITE       ((ufix16) 0x0000)        /* all white pixels in a word */
#define CC_BLACK       ((ufix16) 0xFFFF)        /* all black pixels in a word */
#ifdef  LBODR
#define CC_L_PIX  ((ufix16) 0x0001)     /* left  most pixel in a word */
#define CC_R_PIX  ((ufix16) 0x8000)     /* right most pixel in a word */
#define CC_LEFT_SHIFT(D, S)                                             \
                       ((ufix16) ((D) >> (S)))
#define CC_RIGH_SHIFT(D, S)                                             \
                       ((ufix16) ((D) << (S)))
#else
#define CC_L_PIX  ((ufix16) 0x8000)     /* left  most pixel in a word */
#define CC_R_PIX  ((ufix16) 0x0001)     /* right most pixel in a word */
#ifdef  bSwap
#define SwapWord(S)     ((S) << 8 | (S) >> 8)
#define CC_LEFT_SHIFT(D, S)                                             \
                ((ufix16) SwapWord((ufix16)(SwapWord(D) << (S))))
#define CC_RIGH_SHIFT(D, S)                                             \
                ((ufix16) SwapWord((ufix16)(SwapWord(D) >> (S))))
#else
#define CC_LEFT_SHIFT(D, S)                                             \
                       ((ufix16) ((D) << (S)))
#define CC_RIGH_SHIFT(D, S)                                             \
                       ((ufix16) ((D) >> (S)))
#endif  /* bSwap @WIN */
#endif


#define CC_P_MASK(C)                                                          \
                (CC_RIGH_SHIFT(CC_L_PIX, (C) & CC_PIXEL_MASK))  /* ----*---- */
#define CC_L_MASK(C)                                                          \
                (CC_RIGH_SHIFT(CC_BLACK, (C) & CC_PIXEL_MASK))  /* ----***** */
#define CC_R_MASK(C)                                                          \
                (CC_LEFT_SHIFT(CC_BLACK, (((C) ^ CC_PIXEL_MASK)               \
                                             & CC_PIXEL_MASK))) /* *****---- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\gstate.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   gstate.c
 *
 *      Purpose:
 *
 *      Developer:      J.Jih
 *
 *      History:
 *      Version     Date        Comments
 *                  1/31/89     @STK_OVR: push values to operand stack as many
 *                              as possible until overflow
 *                  1/31/89     @HT_RST: add code to restore legal halftone
 *                              screen when error occurs during setting new
 *                              halftone screen
 *                  5/20/89     update grestoreall_process() to restore
 *                              halftone screen information properly
 *                  6/04/89     fix bug of grestoreall_process() @05/20/89
 *                  11/8/89     fix copy_path_table() bug: reverse flag can not
 *                              be copied
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                              rename copy_node_table() to copy_last_subpath(),
 *                              and set it as a global routine.
 *                  3/13/90     op_sethsbcolor(): special values processing
 *                  8/17/90     grayscale: vm checking for resetting page
 *                  08/24/90    performance enhancement of setscreen, Jack
 *                  12/4/90     @CPPH: copy_path_table(): initialize cp_path
 *                              to be NULLP, when copy path from previous state
 *                              to current one.
 *                  12/14/90    update error checking of op_setscreen for
 *                              compatibility.
 *                  1/9/91      comment 8-24-90 performance enhancement of
 *                              op_setscreen
 *                  3/19/91     op_settransfer(): skip calling interpreter if
 *                              proc is null
 *                  3/20/91     refine the zero check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include       <math.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fntcache.ext"

#define         WR      .30
#define         WG      .59
#define         WB      .11

/* grayscale 8-1-90 Jack Liaw */
extern ufix32 highmem;
extern ufix32 FAR FBX_BASE;     /* @WIN */
/* papertype changed 10-11-90, JS */
extern ufix32 last_frame;

static real32  near Hue, near Sat,   near Brt;
static real32  near Red, near Green, near Blue;

static bool   near screen_change;

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near copy_stack_content(void);
static void near copy_path_table(void);
/* static void near copy_node_table(struct ph_hdr *);   @DFR_GS */
static void near restore(void);
static real32 near adj_color_domain(long32);
static real32 near hsb_to_gray(void);
static void near hsb_to_rgb(void);
static void near rgb_to_hsb(void);

#else
/* for no type checks of the parameters in function declarations */
static void near copy_stack_content();
static void near copy_path_table();
/* static void near copy_node_table();                  @DFR_GS */
static void near restore();
static real32 near adj_color_domain();
static real32 near hsb_to_gray();
static void near hsb_to_rgb();
static void near rgb_to_hsb();
#endif

/***********************************************************************
 *
 * This module is to check access right of array object
 *
 * TITLE:       access_chk
 *
 * CALL:        access_chk()
 *
 * PARAMETER:   obj_array
 *              flag    : 1  PACKEDARRAY || NORMAL ARRAY
 *                        2  NORMAL ARRAY
 *
 * INTERFACE:   * many *
 *
 * CALLS:       none
 *
 * RETURN:      TRUE  : success
 *              FALSE : failure
 *
 *********************************************************************/
bool
access_chk(obj_array, flag)
struct  object_def      FAR *obj_array;
fix     flag;
{
        if(flag == G_ARRAY){      /* PACKEDARRAY || NORMAL ARRAY */
              if((ACCESS(obj_array) == READONLY) ||
                 (ACCESS(obj_array) == UNLIMITED)){
                      return(TRUE);
              }
              else{
                      ERROR(INVALIDACCESS);
                      return(FALSE);
              }
         }
         else{ /* flag == ARRAY_ONLY,   NORMAL ARRAY */
              if(ACCESS(obj_array) == UNLIMITED){
                      return(TRUE);
              }
              else{
                      ERROR(INVALIDACCESS);
                      return(FALSE);
              }
         }
}

/***********************************************************************
 *
 * This module is to push a copy of graphics state on the graphics
 * state stack
 *
 * SYNTAX:      -    gsave    -
 *
 * TITLE:       op_gsave
 *
 * CALL:        op_gsave()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_gsave)
 *
 * CALLS:       gsave_process
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_gsave()
{
        bool    save_op_flag;

        save_op_flag = FALSE;
        /* process elements of graphics state after current graphics
         * state was copied */
        gsave_process(save_op_flag);

        return(0);
}

/***********************************************************************
 *
 * This module is to copy the current graphics state on the top of
 * graphics state stack
 *
 * TITLE:       copy_stack_content
 *
 * CALL:        copy_stack_content()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near copy_stack_content()
{
        // struct   gs_hdr   near *post_ptr, near *pre_ptr; @WIN
        struct   gs_hdr   FAR *post_ptr, FAR *pre_ptr;

        /* copy the current graphics state on the top of graphics
         * state stack
         */
        pre_ptr = &gs_stack[current_gs_level];
        post_ptr = &gs_stack[current_gs_level + 1];

        *post_ptr = *pre_ptr;
        post_ptr->color.inherit  = TRUE;
        post_ptr->path           = pre_ptr->path + 1;
        post_ptr->clip_path.inherit = TRUE;
        post_ptr->halftone_screen.chg_flag = FALSE;

}


/***********************************************************************
 *
 * This module is to copy the current path table on top of path table
 *
 * TITLE:       copy_path_table
 *
 * CALL:        copy_path_table()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near copy_path_table()
{
        /* copy path table to top of path table stack */
        path_table[GSptr->path].rf = path_table[GSptr->path - 1].rf & ~P_RVSE;
                                /* reverse flag can not be copied; 11/8/89 */
        path_table[GSptr->path].flat = path_table[GSptr->path - 1].flat;
        path_table[GSptr->path].head = NULLP;
        path_table[GSptr->path].tail = NULLP;
        path_table[GSptr->path].cp_path = NULLP;                /* @CPPH */
        path_table[GSptr->path].previous = GSptr->path - 1;

}

/***********************************************************************
 *
 * This module is to copy the last incomplete subpath(node table) to top
 * of path table
 *
 * TITLE:       copy_last_subpath
 *
 * CALL:        copy_last_subpath()
 *
 * PARAMETER:   path_ptr : subpath pointer
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       get_node
 *
 * RETURN:      none
 *
 **********************************************************************/
void copy_last_subpath(path_ptr)
struct ph_hdr FAR *path_ptr;
{
        fix     inode, idx, sp_node, pre_node;

        if (path_ptr->tail == NULLP) return;

        node_table[path_ptr->tail].SP_FLAG |= SP_DUP;
                                        /* old subpath is duplicated */
        sp_node = NULLP;                /* sub_path node    @NODE */

        for(idx = path_ptr->tail;
            idx != NULLP; idx = node_table[idx].next){
               /* create new node */
               if((inode = get_node()) == NULLP){
                        ERROR(LIMITCHECK);
                        free_node (sp_node);    /* @NODE */
                        return;
               }

                /* copy vertex node */
                node_table[inode].VX_TYPE     = node_table[idx].VX_TYPE;
                node_table[inode].next     = NULLP;
                node_table[inode].VERTEX_X = node_table[idx].VERTEX_X;
                node_table[inode].VERTEX_Y = node_table[idx].VERTEX_Y;

                if(sp_node == NULLP){
                        sp_node = inode;
                }
                else{
                        node_table[pre_node].next   = (VX_IDX)inode;
                }

                pre_node = inode;
        }

        /* setup subpath header @NODE */
        node_table[sp_node].SP_FLAG = (node_table[path_ptr->tail].SP_FLAG) &
                                    (bool8)(~SP_DUP);   //@WIN
                                /* copy subpath flag and set not duplicated */
        node_table[sp_node].SP_NEXT = NULLP;
        node_table[sp_node].SP_TAIL = (VX_IDX)inode;
        path_table[GSptr->path].head = (SP_IDX)sp_node;
        path_table[GSptr->path].tail = (SP_IDX)sp_node;
}


/***********************************************************************
 *
 * This module is to process elements of graphics state after current
 * graphics state was copied
 *
 * TITLE:       gsave_process
 *
 * CALL:        gsave_process()
 *
 * PARAMETER:   save_op_flag : check invoking source
 *                             TRUE:  invoked by save_op
 *                             FALSE: invoked by gsave_op
 *
 * INTERFACE:   op_gsave, op_save
 *
 * CALLS:       font_save
 *
 * RETURN:      none
 *
 **********************************************************************/
bool
gsave_process(save_op_flag)
bool    save_op_flag;
{
        struct  ph_hdr  FAR *path_ptr;

        /* check limitcheck error */
        if(current_gs_level >= (MAXGSL - 1)){
                ERROR(LIMITCHECK);
                return(FALSE);
        }

        /* copy the current graphics state on the top of graphics state stack */
        copy_stack_content();

        current_gs_level ++;
        GSptr = &gs_stack[current_gs_level];
        /* GSptr point to the current graphics state */

        if(save_op_flag == RESTORE) GSptr->save_flag = TRUE;
        else                        GSptr->save_flag = (fix16)save_op_flag;

        GSptr->halftone_screen.chg_flag = FALSE;

        /* set device not being changed; @DEVICE */
        GSptr->device.chg_flg = FALSE;

        /* copy path table to top of path table stack */
        copy_path_table();

        /* trace the inherit path to find whether last subpath is incomplete */
        path_ptr = &path_table[GSptr->path - 1];
        if(path_ptr->tail != NULLP &&
           node_table[node_table[path_ptr->tail].SP_TAIL].VX_TYPE != CLOSEPATH){
                path_table[GSptr->path].rf |= P_DFRGS;
        }
        else if(path_ptr->tail != NULLP){
                node_table[path_ptr->tail].SP_FLAG &= ~SP_DUP;
        }

        /* ??? */
        if(save_op_flag == TRUE){
                font_save();
        }

        return(TRUE);
}

/***********************************************************************
 *
 * This is to reset the current graphics state
 *
 * TITLE:       restore
 *
 * CALL:        restore()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_grestore, op_grestoreall
 *
 * CALLS:       free_path, free_edge
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near restore()
{
        fix GEIeng_checkcomplete();

        /* deallocate all nodes of the current subpaths to node table */
        free_path();

        if(GSptr->clip_path.inherit == FALSE){

                /* deallocate  all nodes of the current clipping path
                 * to edge table */
                free_node(GSptr->clip_path.head);
                GSptr->clip_path.head = GSptr->clip_path.tail = NULLP;
        }

        /* restore gray table , create in settransfer */
        if(GSptr->color.inherit == TRUE) GSptr->color.adj_gray --;

#ifdef  DBGs
        printf("restore: %d verify screen\n", current_gs_level);
#endif
        if(GSptr->halftone_screen.chg_flag == TRUE){
#ifdef  DBGs
                printf("restore: %d change screen\n", current_gs_level);
#endif
                gs_stack[current_gs_level - 1].halftone_screen.no_whites
                    = -1; /* 03-14-1988 */
                screen_change = TRUE;
#ifdef  DBGs
                printf("screen change: %d  just set\n", screen_change);
#endif
        }
        else {
                if(gs_stack[current_gs_level - 1].halftone_screen.no_whites
                                        != GSptr->halftone_screen.no_whites)
                    gs_stack[current_gs_level - 1].halftone_screen.no_whites
                        = -2; /* 03-14-1988,  -1 -> -2  Y.C. Chen 20-Apr-88 */
        }
        current_gs_level --;
#ifdef  DBGs
        printf("screen change: %d  gs--\n", screen_change);
#endif

        /* restore the current graphics state */
        GSptr = &gs_stack[current_gs_level];
        if(path_table[GSptr->path].tail != NULLP)       /* 02/12/92 SC */
        node_table[path_table[GSptr->path].tail].SP_FLAG &= ~SP_DUP;    /* 04/29/91, Peter */

#ifdef  DBGs
        printf("screen change: %d  gsptr\n", screen_change);
#endif

        spot_usage = GSptr->halftone_screen.spotindex           /* 03-12-87 */
                   + GSptr->halftone_screen.cell_size
                   * GSptr->halftone_screen.cell_size;
#ifdef  DBGs
        printf("screen change: %d  usage\n", screen_change);
#endif

        /* reset the page configuration if device header has been changed;
         * 8-1-90 Jack Liaw                                        @DEVICE
         */
        if (gs_stack[current_gs_level + 1].device.chg_flg &&
            (GSptr->device.nuldev_flg != NULLDEV)) {
/* @WIN; fix the starting address of frame buffer; not need to adjust FBX */
#ifdef XXX
                /* limit error check - grayscale 8-1-90 Jack Liaw */
                {
                    ufix32      l_diff, frame_size;
                    ufix32      twidth;

                    twidth = (((ufix32) (GSptr->device.width / 8) + 3) / 4) * 4;
                    frame_size = twidth * (ufix32) GSptr->device.height;
                    /* BEGIN, papertype changed 10-11-90, JS */
                    if (frame_size != last_frame) {
                       /*  wait until laser printer turns ready  */
                       while (GEIeng_checkcomplete()) ;
                       last_frame = frame_size;
                    }
                    /* END 10-11-90, JS */
                    DIFF_OF_ADDRESS (l_diff, fix32, (byte FAR *)highmem, (byte FAR*)vmptr);
                    if (frame_size > l_diff) {
                        ERROR(LIMITCHECK);
                        return;
                    } else {
                        vmheap = (byte huge *)(highmem - frame_size);
                        FBX_BASE = highmem - frame_size;
                    }
                }
#endif
                reset_page (GSptr->device.width, GSptr->device.height, 1);
#ifdef  DBGs
                printf("screen change: %d  reset\n", screen_change);
#endif
        }

#ifdef  DBGs
        printf("screen change: %d  done\n", screen_change);
#endif

        return;
}


/***********************************************************************
 *
 * This is to reset the current graphics state from the one that was
 * saved by matching gsave_op
 *
 * SYNTAX:      -    grestore    -
 *
 * TITLE:       op_grestore
 *
 * CALL:        op_grestore()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_grestore)
 *
 * CALLS:       restore, gsave_process, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_grestore()
{
        bool    save_flag;
        fix     gray_index, old_gray_val;

        /* check if there is matching gsave */
        if(current_gs_level == 0 ){
                return(0);
        }
        else {
               save_flag = GSptr->save_flag;

               gray_index = (fix)(GSptr->color.gray * 255);
               old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

               /* restore save level, initial screen_change = FALSE */
               screen_change = FALSE;
               restore();

               /* save graphics state */
               if(save_flag == TRUE){
                        gsave_process(RESTORE);
               }

               gray_index =(fix)(GSptr->color.gray * 255);
               /* restore the spot_matrix and halftone_grid, if necessary */
               if(screen_change == TRUE ||
               old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                       FillHalfTonePat();
               }

               gf_restore();
               return(0);
        }

}


/***********************************************************************
 *
 * This module is to reset the current graphic sstate from the on that
 * was saved by save_op or bottommost graphics state
 *
 * SYNTAX:      -    grestoreall    -
 *
 * TITLE:       op_grestoreall
 *
 * CALL:        op_grestoreall()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_grestoreall)
 *
 * CALLS:       grestoreall_process
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_grestoreall()
{
        grestoreall_process(FALSE);
        return(0);
}

/***********************************************************************
 *
 * This module is to main routine of op_grestoreall
 *
 * TITLE:       grestoreall_process
 *
 * CALL:        grestoreall_process(flag)
 *
 * PARAMETER:   flag : TRUE : called by restore operator
 *                     FALSE: called by grestoreall operator
 *
 * INTERFACE:   op_grestoreall
 *
 * CALLS:       restore, font_restore, gsave_process, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
void grestoreall_process(flag)
bool    flag;
{
        fix     gray_index, old_gray_val;

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        screen_change = FALSE;
        /* check if there is matching save */
        while(current_gs_level != 0 && GSptr->save_flag == FALSE){
                /* restore graphics state */
                restore();
        }

        if(GSptr->save_flag == TRUE){
                /* restore save level  */
                restore();

                /* save graphics state (called by grestoreall operator) */
                if(flag == FALSE) gsave_process(RESTORE);
        }

        /* restore the spot_matrix and halftone_grid, if necessary */
        gray_index = (fix)(GSptr->color.gray * 255);
        if(screen_change == TRUE ||
           old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                /* force halftone cache to be flushed */
                if (screen_change == TRUE)                      /* 06-04-89 */
                    GSptr->halftone_screen.no_whites = -1;
                FillHalfTonePat();
        }

        /* restore font  : called by restore */
        if(flag == TRUE) font_restore();

        gf_restore();
}


/***********************************************************************
 *
 * This module is to reset several values in the current graphics state
 * to their default values
 *
 * SYNTAX:      -    initgraphics    -
 *
 * TITLE:       op_initgraphics
 *
 * CALL:        op_initgraphics()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_initgraphics)
 *
 * CALLS:       op_newath, op_initclip, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_initgraphics()
{
        ufix16  i;
        fix     gray_index, old_gray_val;

        /* init current matrix */
        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }

        /* deallocate all nodes of the current subpath to node table */
        op_newpath();

        /* allocate nodes to create a default clipping path and
         * chain it to clip path */
        op_initclip();

        gray_index   = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        GSptr->color.gray   = zero_f;
        GSptr->color.hsb[0] = zero_f;
        GSptr->color.hsb[1] = zero_f;
        GSptr->color.hsb[2] = zero_f;
        GSptr->line_width   = one_f;
        GSptr->line_join    = 0;
        GSptr->line_cap     = 0;
        GSptr->dash_pattern.pat_size = 0;
        GSptr->dash_pattern.offset   = zero_f;
        create_array(&GSptr->dash_pattern.pattern_obj, 0);
        GSptr->miter_limit = (real32)10.0;

        gray_index = (fix)(GSptr->color.gray * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                FillHalfTonePat();
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current line width in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setlinewidth    -
 *
 * TITLE:       op_setlinewidth
 *
 * CALL:        op_setlinewidth()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinewidth)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinewidth()
{
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        GET_OBJ_VALUE(GSptr->line_width, obj_num);
        FABS(GSptr->line_width, GSptr->line_width);

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the value of the line width in the current
 * graphics state
 *
 * SYNTAX:      -       currentlinewidth        num
 *
 * TITLE:       op_currentlinewidth
 *
 * CALL:        op_currentlinewidth()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinewidth)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinewidth()
{
        union   four_byte       line_width4;

        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line width on the operand stack */
        line_width4.ff = GSptr->line_width;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, line_width4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current line cap in the current graphics
 * state to the specific value
 *
 * SYNTAX:      int     setlinecap      -
 *
 * TITLE:       op_setlinecap
 *
 * CALL:        op_setlinecap()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinecap)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinecap()
{
        union   four_byte intg4;
        struct  object_def FAR *obj_intg;

        /* get operand */
        obj_intg = GET_OPERAND(0);

        intg4.ll = (fix32)VALUE(obj_intg);

        /* check rangecheck error */
        if(intg4.ll < 0 || intg4.ll > 2){
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->line_cap = (fix)intg4.ll;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the line cap in the
 * current graphics state
 *
 * SYNTAX:      -    currentlinecap     int
 *
 * TITLE:       op_currentlinecap
 *
 * CALL:        op_currentlinecap()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinecap)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinecap()
{
        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line cap on the operand stack */
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0,
                                            (ufix32)GSptr->line_cap);
        return(0);
 }


/***********************************************************************
 *
 * This module is to set the current line join in the current graphics
 * state to the specific value
 *
 * SYNTAX:      int     setlinejoin     -
 *
 * TITLE:       op_setlinejoin
 *
 * CALL:        op_setlinejoin()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinejoin)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinejoin()
{
        union   four_byte  intg4;
        struct  object_def FAR *obj_intg;

        /* get operand */
        obj_intg = GET_OPERAND(0);

        intg4.ll = (fix32)VALUE(obj_intg);

        /* check rangecheck error */
        if(intg4.ll < 0 || intg4.ll > 2){
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->line_join = (fix)intg4.ll;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the line join in the
 * current graphics state
 *
 * SYNTAX:      -       currentlinejoin int
 *
 * TITLE:       op_currentlinejoin
 *
 * CALL:        op_currentlinejoin()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinejoin)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinejoin()
{
        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line join on the operand stack */
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0,
                                            (ufix32)GSptr->line_join);
        return(0);
}


/***********************************************************************
 *
 * This module is to set the current miter limit in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setmiterlimit   -
 *
 * TITLE:       op_setmiterlimit
 *
 * CALL:        op_setmiterlimit()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setmiterlimit)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setmiterlimit()
{
        real32   miter_limit;
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        /* check rangecheck error */
        GET_OBJ_VALUE(miter_limit, obj_num);
        if(miter_limit < one_f) {
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->miter_limit = miter_limit;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the miter limit in the
 * current graphics state
 *
 * SYNTAX:      -       currentmiterlimit       num
 *
 * TITLE:       op_currentmiterlimit
 *
 * CALL:        op_currentmiterlimit()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentmiterlimit)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentmiterlimit()
{
        union   four_byte       miter_limit4;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current miter limit on the operand stack */
        miter_limit4.ff = GSptr->miter_limit;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, miter_limit4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current dash patternin the current graphics
 * graphics state to the specific value
 *
 * SYNTAX:      array   offset  setdash    -
 *
 * TITLE:       op_setdash
 *
 * CALL:        op_setdash()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setdash)
 *
 * CALLS:       get_array
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setdash()
{
        ufix16  i;
        ufix16  array_length, zero_count;
        bool    negative_flag;
        real32   pattern[11];
        struct  object_def FAR *obj_array, FAR *obj_offset;

        /* get operand */
        obj_offset = GET_OPERAND(0);
        obj_array  = GET_OPERAND(1);

        /* get array length */
        array_length = LENGTH(obj_array);

        /* check limitcheck error */
        if(array_length > MAXDASH){
                ERROR(LIMITCHECK);
                return(0);
        }

        if( !access_chk(obj_array, G_ARRAY)) return(0);

        if( !get_array_elmt(obj_array,array_length,pattern,G_ARRAY) )
             return(0);

        zero_count = 0;
        negative_flag = FALSE;

        for(i = 0; i < array_length; i++){
                /*if(F2L(pattern[i]) == F2L(zero_f)) zero_count++; 3/20/91;sc*/
                if(IS_ZERO(pattern[i])) zero_count++;
                /*if(pattern[i] <  zero_f) negative_flag = TRUE; 3/20/91;sc */
                if(SIGN_F(pattern[i])) negative_flag = TRUE;
        }

        if((array_length > 0 && zero_count == array_length) ||
           (negative_flag == TRUE)){
                ERROR(RANGECHECK);
                return(0);
        }
        else{
                for(i = 0; i < array_length; i++){
                    GSptr->dash_pattern.pattern[i] = pattern[i];
                }
        }

        /* save each elements of array to pattern, and no. of element
         * to pat_size */

        GSptr->dash_pattern.pat_size = array_length;
        COPY_OBJ(obj_array, &GSptr->dash_pattern.pattern_obj);
        GET_OBJ_VALUE(GSptr->dash_pattern.offset, obj_offset );

        /* compute the adjusted dash pattern */
        /* init_dash_pattern();    12-8-90 */

        /* pop operand stack */
        POP(2);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the dash pattern in
 * the current graphics state
 *
 * SYNTAX:      -       currentdash     array   offset
 *
 * TITLE:       op_currentdash
 *
 * CALL:        op_currentdash()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentdash)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentdash()
{
        union   four_byte      offset4;

        /* push array object on the operand stack */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_OBJ(&GSptr->dash_pattern.pattern_obj);

        /* push GSptr->dash_pattern.offset on the operand stack */
        offset4.ff = GSptr->dash_pattern.offset;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, offset4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current flatness tolerance in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setflat     -
 *
 * TITLE:       op_setflat
 *
 * CALL:        op_setflat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setflat)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setflat()
{
        real32   num;
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        GET_OBJ_VALUE(num, obj_num );

        /* set range 0.2 <= num <= 100.0 */
        if(num < (real32)0.2)         num = (real32)0.2;
        else if(num > (real32)100.0)  num = (real32)100.0;

        GSptr->flatness = num;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the flatness torlence
 * in the current graphics state
 *
 * SYNTAX:      -       currentflat     num
 *
 * TITLE:       op_currentflat
 *
 * CALL:        op_currentflat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentflat)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentflat()
{
        union   four_byte       flatness4;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current flatness on the operand stack */
        flatness4.ff = GSptr->flatness;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, flatness4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current gray level in the current graphics
 * state to the specific value
 *
 * SYNTAX:      num     setgray     -
 *
 * TITLE:       op_setgray
 *
 * CALL:        op_setgray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setgray)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setgray()
{
        real32   num;
        struct  object_def      FAR *obj_num, name_obj;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "setgray", 7, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* get operand */
        obj_num = GET_OPERAND(0);

        /* adjust num value */
        GET_OBJ_VALUE(num, obj_num );
        num = (real32)floor(num * 255 + 0.5) / 255;

        /* set range 0.0 <= num <= 1.0 */
        if(num > one_f)      num = one_f;
        /*else if(num < zero_f) num = zero_f; 3/20/91; scchen */
        else if(SIGN_F(num)) num = zero_f;

        setgray(F2L(num));

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current gray level in the current graphics
 * state to the specific value
 *
 * TITLE:       setgray
 *
 * CALL:        setgray(num)
 *
 * PARAMETER:   num
 *
 * INTERFACE:   op_setgray
 *
 * CALLS:       FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
void setgray(l_num)
long32   l_num;
{
        real32   num;
        fix     gray_index, old_gray_val;

        num = L2F(l_num);

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        /* set the current gray level to the specific value */
        GSptr->color.hsb[0] = zero_f;
        GSptr->color.hsb[1] = zero_f;
        GSptr->color.hsb[2] = num;
        GSptr->color.gray   = num;

        gray_index = (fix)(num * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                FillHalfTonePat();
        }
}


/***********************************************************************
 *
 * This module is to return the current value of the gray level in the
 * current graphics state
 *
 * SYNTAX:      -       currentgray     num
 *
 * TITLE:       op_currentgray
 *
 * CALL:        op_currentgray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentgray)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentgray()
{
        union   four_byte       hsb24;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current gray level on the operand stack */
        hsb24.ff = GSptr->color.gray;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb24.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to adjust color elements (HSB, RGB) to be in domain
 * [0, 1]
 *
 * TITLE:       adj_color_domain
 *
 * CALL:        adj_color_domain
 *
 * PARAMETER:   color_elmt
 *
 * INTERFACE:   op_setrgbcolor, op_sethsbcolor
 *
 * CALLS:       none
 *
 * RETURN:      color_elmt: adjusted color_elmt
 *
 * HISTORY: modified by J. Lin, 12-16-88 color_elmt value be digitized by
 *          1/255 quantity.
 *
 **********************************************************************/
static real32 near adj_color_domain(l_color_elmt)
long32   l_color_elmt;
{
        real32   color_elmt;

        color_elmt = L2F(l_color_elmt);

        /*if (color_elmt < zero_f) 3/20/91; scchen */
        if (SIGN_F(color_elmt))
           color_elmt = zero_f;
        else if (color_elmt > one_f)
           color_elmt = one_f;
        else
           color_elmt = (real32)((fix)(color_elmt * 255 + (real32)0.5)) / (real32)255.;
        return(color_elmt);
}


/***********************************************************************
 *
 * This module is to get gray value from Hue, Sat, and Blue. The sequence
 * is as follows.
 *
 *   HSB_TO_RBG
 *   Gray = WR * Red + WG * Green + WB * Blue
 *
 * TITLE:       hsb_to_gray
 *
 * CALL:        hsb_to_gray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_sethsbcolor
 *
 * CALLS:       none
 *
 * RETURN:      gray value
 *
 * HISTORY: added by J. Lin, 8-12-88
 *          modified by J. Lin, 12-14-88
 **********************************************************************/
static real32 near hsb_to_gray()
{

    /* invoke hsb_to_rgb procedure to get the corresponding RGB value */
    hsb_to_rgb();
    return((real32)(WR * Red + WG * Green + WB * Blue));
}

/***********************************************************************
 *
 * This module is to translate RGB to HSB (presented by Alvy Ray Smith,
 * base on NTSC case)
 *
 * TITLE:       rgb_to_hsb
 *
 * CALL:        rgb_to_hsb()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_setrgbcolor
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near rgb_to_hsb()
{
        real32 min, max, rc, gc, bc;

        /* find min. and max. of (Red, Green, Blue) */
        if (Red > Green) {
                max = Red;
                min = Green;
        } else {
                max = Green;
                min = Red;
        }
        if (Blue > max) max = Blue;
        else if (Blue < min) min = Blue;

        /* find brightness (Brt) */
        Brt = max;

        /* find saturation (Sat) */
        /*if (F2L(max) != F2L(zero_f)) Sat = (max - min) / max; 3/20/90;scchen
         *else    Sat = zero_f;
         */
        if (IS_ZERO(max)) Sat = zero_f;
        else    Sat = (max - min) / max;

        /* find hue */
        /*if (F2L(Sat) == F2L(zero_f)) Hue = zero_f; 3/20/91; scchen */
        if (IS_ZERO(Sat)) Hue = zero_f;
        else {  /* saturation not zero, so determine hue */
                rc = (max - Red) / (max - min);
                gc = (max - Green) / (max - min);
                bc = (max - Blue) / (max - min);

                if (Red == max) {
                        if (Green == min)
                                Hue = 5 + bc;
                        else /* Blue == min */
                                Hue = 1 - gc;
                } else if (Green == max) {
                        if (Blue == min)
                                Hue = 1 + rc;
                        else /* Red == min */
                                Hue = 3 - bc;
                } else {        /* Blue == max */
                        if (Red == min)
                                Hue = 3 + gc;
                        else
                                Hue = 5 - rc;
                }
                if (Hue >= (real32)6.0) Hue = Hue - 6;
                Hue = Hue / 6;
        }

}


/***********************************************************************
 *
 * This module is to translate HSB to RGB (presented by Alvy Ray Smith
 * base on NTSC case)
 *
 * TITLE:       hsb_to_rgb
 *
 * CALL:        hsb_to_rgb()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_currentrgbcolor
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near hsb_to_rgb()
{

        fix     i;
        real32   h, f, p, q, t;

        h = Hue * (real32)360.;

        /*if (F2L(Sat) == F2L(zero_f)) { 3/20/91; scchen */
        if (IS_ZERO(Sat)) {   /* achromatic color; there is no hue */
           /*if (F2L(h) == F2L(zero_f)) {  3/20/91; scchen*/
           if (IS_ZERO(h)) {        /* achromatic case */
              Red = Brt;
              Green = Brt;
              Blue = Brt;
           } else {                /* error if Sat=0 and h has a value */
              return;
           }
        } else {        /* Sat != 0, achromatic color; there is a hus */
           if (h == (real32)360.0)
              h = zero_f;
           h = h / 60;
           i = (fix)floor(h);
           f = h - i;
           p = Brt * (1 - Sat);
           q = Brt * (1 - (Sat * f));
           t = Brt * (1 - (Sat * (1 - f)));
           switch (i) {
           case 0 :
                   Red = Brt;
                   Green = t;
                   Blue = p;
                   break;
           case 1 :
                   Red = q;
                   Green = Brt;
                   Blue = p;
                   break;
           case 2 :
                   Red = p;
                   Green = Brt;
                   Blue = t;
                   break;
           case 3 :
                   Red = p;
                   Green = q;
                   Blue = Brt;
                   break;
           case 4 :
                   Red = t;
                   Green = p;
                   Blue = Brt;
                   break;
           case 5 :
                   Red = Brt;
                   Green = p;
                   Blue = q;
                   break;
           } /* switch */
        } /* if */

}


/***********************************************************************
 *
 * This module is to set the current color in the current graphics
 * state to the specific hue, sat, and brt values
 *
 * SYNTAX:      hue   sat   brt   sethsbcolor   -
 *
 * TITLE:       op_sethsbcolor
 *
 * CALL:        op_sethsbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_sethsbcolor)
 *
 * CALLS:       FillHalfTonePat
 *
 * RETURN:      none
 *
 * HISTORY: modified by J. Lin, 8-12-88
 *          modified by J. Lin, 12-16-88, when S=0, H should be to 0.
 **********************************************************************/
fix
op_sethsbcolor()
{
        struct  object_def  name_obj;
        real32   gray;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "sethsbcolor", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        GET_OBJ_VALUE(Hue, GET_OPERAND(2));
        GET_OBJ_VALUE(Sat, GET_OPERAND(1));
        GET_OBJ_VALUE(Brt, GET_OPERAND(0));

        Hue = adj_color_domain(F2L(Hue));
        Sat = adj_color_domain(F2L(Sat));
        Brt = adj_color_domain(F2L(Brt));

        /* Special values processing 3/13/90 */
        /*if (F2L(Brt) == F2L(zero_f)) { 3/20/91; scchen */
        if (IS_ZERO(Brt)) {
           Hue = (real32)0.0;
           Sat = (real32)0.0;
        }
        /*if (F2L(Sat) == F2L(zero_f)) {        3/20/91; scchen */
        if (IS_ZERO(Sat)) {          /* 3/13/90 */
           Hue = (real32)0.0;
        } else {
           /*if (F2L(Hue) == F2L(zero_f))       3/20/91; scchen */
           if (IS_ZERO(Hue))         /* 3/13/90 */
              Hue = (real32)1.0;
        }

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        /* get a gray value from HSB */
        gray = hsb_to_gray();
        if(GSptr->color.gray != gray) {
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }

        /* pop operand stack */
        POP(3);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the color in the
 * current graphics state
 *
 * SYNTAX:      -       currenthsbcolor   hue  sat  brt
 *
 * TITLE:       op_currenthsbcolor
 *
 * CALL:        op_currenthsbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currenthsbcolor)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currenthsbcolor()
{
       union    four_byte       hsb4;

        /* push hue sat brt on operand stack */
        hsb4.ff = GSptr->color.hsb[0];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);
        hsb4.ff = GSptr->color.hsb[1];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);
        hsb4.ff = GSptr->color.hsb[2];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current color in the current graphics
 * state to the specific red, green, and blue values
 *
 * SYNTAX:      red  green  blue  setrgbcolor   -
 *
 * TITLE:       op_setrgbcolor
 *
 * CALL:        op_setrgbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setrgbcolor)
 *
 * CALLS:       FillHalfTonePat, rgb_to_hsb
 *
 * RETURN:      none
 *
 *
 * HISTORY: modified by J. Lin, 8-12-88
 *          modified by J. Lin, 12-14-88 for gray value
 **********************************************************************/
fix
op_setrgbcolor()
{
        struct  object_def  name_obj;
        real32  gray;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "setrgbcolor", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        GET_OBJ_VALUE(Red, GET_OPERAND(2));
        GET_OBJ_VALUE(Green, GET_OPERAND(1));
        GET_OBJ_VALUE(Blue, GET_OPERAND(0));

        Red   = adj_color_domain(F2L(Red));
        Green = adj_color_domain(F2L(Green));
        Blue  = adj_color_domain(F2L(Blue));

        /* invoke rgb_to_hsb procedure to get the corresponding HSB
         * value */
        rgb_to_hsb();

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        gray = (real32)(WR * Red + WG * Green + WB * Blue);
        if(GSptr->color.gray != gray){
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }

        /*pop operand stack */
        POP(3);
        return(0);
}

#ifdef WIN
/***********************************************************************
 *
 **********************************************************************/
void
setrgbcolor(red, green, blue)
long32  red, green, blue;
{
        real32  gray;

        Red   = adj_color_domain(red);
        Green = adj_color_domain(green);
        Blue  = adj_color_domain(blue);

        /* invoke rgb_to_hsb procedure to get the corresponding HSB
         * value */
        rgb_to_hsb();

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        gray = (real32)(WR * Red + WG * Green + WB * Blue);     /* 12-14-88 */
        if(GSptr->color.gray != gray){
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }
}

#endif


/***********************************************************************
 *
 * This module is to return the current value of the color in the
 * current graphics state
 *
 * SYNTAX:      -       currentrgbcolor red  green  blue
 *
 * TITLE:       op_currentrgbcolor
 *
 * CALL:        op_currentrgbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentrgbcolor)
 *
 * CALLS:       hsb_to_rgb
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentrgbcolor()
{
       union four_byte  rgb4;

        Hue = GSptr->color.hsb[0];
        Sat = GSptr->color.hsb[1];
        Brt = GSptr->color.hsb[2];

        /* invoke hsb_to_rgb procedure to get the corresponding RGB
         * value */
        hsb_to_rgb();

        /* push Red Green Blue on operand stack */
        rgb4.ff = Red;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);
        rgb4.ff = Green;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);
        rgb4.ff = Blue;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current resolution or dpi of device
 *
 * SYNTAX:      resolution  setscreen
 *
 * TITLE:       st_setresolution
 *
 * CALL:        st_setresolution()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(st_setresolution)
 *
 * CALLS:       SetHalfToneCell, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
st_setresolution()                                              /* @RES */
{
        fix                     res;
        struct  object_def      FAR *obj_res;

        if (COUNT() < 1) {
           ERROR(STACKUNDERFLOW);
           return(0);
        }

        /* get operand */
        obj_res = GET_OPERAND(0);

        if (TYPE(obj_res) != INTEGERTYPE) {
           ERROR(TYPECHECK);
           return(0);
        }

        /* get resolution */
        res = (fix) VALUE(obj_res);

        if (res < MIN_RESOLUTION || res > MAX_RESOLUTION) {
           ERROR(RANGECHECK);
           return(0);
        }

        /* update resolution and setscreen and setgray */
        resolution = res;

        /* invoke SetHalfToneCell procedure to regenerate the
         * spot_matrix based on the current halftone screen */
        SetHalfToneCell();

        /* invoke FillhalftonePat procedure to regenerate the
         * halftone_cel and repeat_pattern based on the current
         * spot_matrix and gray */
        FillHalfTonePat();

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current resolution of device
 *
 * SYNTAX:      -       currentresolution   resolution
 *
 * TITLE:       st_currentresolution
 *
 * CALL:        st_currentresolution()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(currentresolution)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
st_currentresolution()                                          /* @RES */
{
       /* check if operand stack no free space */
        if (FRCOUNT() < 1){
           ERROR(STACKOVERFLOW);
        } else {
        /* push current resolution on the operand stack */
           PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, (ufix32)resolution);
        }
        return(0);
}


/***********************************************************************
 *
 * This module is to set the current halftone screen in the current
 * graphics state to the specific value
 *
 * SYNTAX:      freq  angle  proc  setscreen    -
 *
 * TITLE:       op_setscreen
 *
 * CALL:        op_setscreen()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setscreen)
 *
 * CALLS:       SetHalfToneCell, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setscreen()
{
/*      real32  angle;                                  (* ph, 8-24-90, Jack */
        real32  freq;
        struct  object_def     FAR *obj_freq, FAR *obj_angle, FAR *obj_proc;

        ufix16  gerc_save;                              /* @HT_RST: 01-31-89 */
        real32  freq_save;                              /* @HT_RST: 01-31-89 */
        real32  angle_save;                             /* @HT_RST: 01-31-89 */
        struct  object_def      proc_save;              /* @HT_RST: 01-31-89 */

        /* get operand */
        obj_proc  = GET_OPERAND(0);
        obj_angle = GET_OPERAND(1);
        obj_freq  = GET_OPERAND(2);

        GET_OBJ_VALUE(freq, obj_freq);
        /* if(freq <= zero_f){ (* 12-14-90, Jack *) 3/20/91; scchen*/
        if(IS_ZERO(freq)) {
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        /* performance enhancement, 8-24-90, Jack, begin *)
        GET_OBJ_VALUE(angle, obj_angle);

#ifdef DBG1x
        printf("Input: freq = %f, angle = %f\n", freq, angle);
        printf("Input: proc = %ld\n", VALUE(obj_proc));
        printf("Input: bitfield = %x\n", obj_proc->bitfield);
        printf("Gstate:freq = %f, angle = %f\n", GSptr->halftone_screen.freq,
                GSptr->halftone_screen.angle);
        printf("Gstate:proc = %ld\n", GSptr->halftone_screen.proc.value);
        printf("Gstate:bitfield = %x\n", GSptr->halftone_screen.proc.bitfield);
#endif

        if ( (freq == GSptr->halftone_screen.freq) &&
             (angle == GSptr->halftone_screen.angle) &&
             (LEVEL(obj_proc) >= LEVEL(&GSptr->halftone_screen.proc)) &&
             (VALUE(obj_proc) == GSptr->halftone_screen.proc.value) ) {
#ifdef DBG1x
            printf(" screen isn't changed ...\n");
#endif
            POP(3);
            return(0);             (* screen isn't changed *)
        }
#ifdef DBG1x
        printf(" change screen ???\n");
#endif
        (* performance enhancement, 8-24-90, Jack, end */

        /* save last screen parameters */
        freq_save  = GSptr->halftone_screen.freq;       /* @HT_RST: 01-31-89 */
        angle_save = GSptr->halftone_screen.angle;      /* @HT_RST: 01-31-89 */
        COPY_OBJ(&GSptr->halftone_screen.proc,          /* @HT_RST: 01-31-89 */
                 &proc_save);

        GSptr->halftone_screen.freq  = freq;
        GET_OBJ_VALUE(GSptr->halftone_screen.angle, obj_angle);
        COPY_OBJ(obj_proc, &GSptr->halftone_screen.proc);

        /* pop operand stack */
        POP(3);

        /* invoke SetHalfToneCell procedure to regenerate the
         * spot_matrix based on the current halftone screen */
        SetHalfToneCell();

        if (ANY_ERROR()) {                              /* @HT_RST: 01-31-89 */

            /* save global_error_code */
            gerc_save = ANY_ERROR();
            CLEAR_ERROR();

            /* restore last screen parameters */
            GSptr->halftone_screen.freq  = freq_save;   /* @HT_RST: 01-31-89 */
            GSptr->halftone_screen.angle = angle_save;  /* @HT_RST: 01-31-89 */
            COPY_OBJ(&proc_save,                        /* @HT_RST: 01-31-89 */
                     &GSptr->halftone_screen.proc);

            /* invoke SetHalfToneCell procedure to regenerate the
             * spot_matrix based on the current halftone screen */
            SetHalfToneCell();

            /* invoke FillhalftonePat procedure to regenerate the
             * halftone_cel and repeat_pattern based on the current
             * spot_matrix and gray */
            FillHalfTonePat();

            /* restore global_error_code */
            ERROR(gerc_save);

        } else {

            /* invoke FillhalftonePat procedure to regenerate the
             * halftone_cel and repeat_pattern based on the current
             * spot_matrix and gray */
            FillHalfTonePat();

        }

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the halftone screen
 * in the current graphics state
 *
 * SYNTAX:      -       currentscreen  freq  angle  proc
 *
 * TITLE:       op_currentscreen
 *
 * CALL:        op_currentscreen()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(currentscreen)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentscreen()
{
        union   four_byte       freq4, angle4;

        /* push GSptr->halfscreen on the operand stack */
        freq4.ff = GSptr->halftone_screen.freq;
        angle4.ff = GSptr->halftone_screen.angle;

        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, freq4.ll);
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, angle4.ll);
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_OBJ(&GSptr->halftone_screen.proc);

        return(0);
}


/**********************************************************************
 *
 * This module is to set the current gray transfer function in the
 * current graphics state to the specific value
 *
 * SYNTAX:      proc    settransfer     -
 *
 * TITLE:       op_settransfer
 *
 * CALL:        op_settransfer()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(settransfer)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_settransfer()
{
        ufix16  i;
        real32   gray_value;
        union   four_byte  iv4;
        fix     gray_index, old_gray_val;
        struct  object_def FAR *proc_obj, name_obj;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "settransfer", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* get operand */
        proc_obj = GET_OPERAND(0);

        if(ATTRIBUTE(proc_obj) != EXECUTABLE){
                ERROR(TYPECHECK);
                return(0);
        }

        /* pop operand stack */
        POP(1);

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        /* set the current gray transfer function to the specific
         * value */
        COPY_OBJ(proc_obj, &GSptr->transfer);

        /* create gray table , restore in grestore & grestoreall */
        if(GSptr->color.inherit == TRUE){
                if(GSptr->color.adj_gray >= MAXGRAY){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                else{
                        /* create new gray table */
                        GSptr->color.adj_gray ++;
                }
        }

        /* skip calling interpreter if proc is null scchen 3/19/91 */
        if( ! LENGTH(proc_obj) )
        for(i = 0; i < 256; i++){
                gray_value = (real32)(i/255.);
                gray_table[GSptr->color.adj_gray].val[i]
                        /* = (fix)(gray_value * GRAYSCALE); mslin 4/11/91*/
                        = (fix)(gray_value * GRAYSCALE+0.5);
        }
        else
        /* generate gray table value */
        for(i = 0; i < 256; i++){
                iv4.ff = (real32)(i/255.);
                PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, iv4.ll);

                if (interpreter(&GSptr->transfer)) {
                        return(0);
                }

                /* adjust gray value */
                GET_OBJ_VALUE(gray_value, GET_OPERAND(0));

                if (gray_value > one_f)      gray_value = one_f;
                /*else if (gray_value < zero_f) gray_value = zero_f; 3/20/91;sc*/
                else if (SIGN_F(gray_value)) gray_value = zero_f;

                /* "* 4096" is used to transfer data type from real
                 * to integer, it used 12 bits */
                gray_table[GSptr->color.adj_gray].val[i]
                        = (fix)(gray_value * GRAYSCALE);

                POP(1);
        }

        gray_index = (fix)(GSptr->color.gray * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                /* exchange halftone pattern */
                FillHalfTonePat();
        }

        GSptr->color.inherit = FALSE;

        return(0);
}


/**********************************************************************
 *
 * This module is to return the current gray transfer function in the
 * current graphics state
 *
 * SYNTAX:      -       currenttransfer  proc
 *
 * TITLE:       op_currenttransfer
 *
 * CALL:        op_currenttransfer()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currenttransfer)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currenttransfer()
{
       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current gray transfer function on the operand
         * stack */
        PUSH_OBJ(&GSptr->transfer);

        return(0);
}



/***********************************************************************
 *
 * This module is to restore the current clip path from the previous
 * graphics level.
 *
 * TITLE:       restore_clip
 *
 * CALL:        restore_clip()
 *
 * PARAMETER:   none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void
restore_clip()
{
        // struct   gs_hdr   near *pre_ptr; @WIN
        struct   gs_hdr   FAR *pre_ptr;

        /* pointer of previous graphics stack */
        pre_ptr = &gs_stack[current_gs_level - 1];

        /* free current clipping path if it is not used by lower gsave level */
        if(!GSptr->clip_path.inherit)
                free_node (GSptr->clip_path.head);

        /* copy clip information from previous level */
        GSptr->clip_path = pre_ptr->clip_path;
        GSptr->clip_path.inherit = TRUE;

}



/***********************************************************************
 *
 * This module is to restore the default CTM and clip from the previous
 * graphics level.
 *
 * TITLE:       restore_device
 *
 * CALL:        restore_device
 *
 * PARAMETER:   none
 *
 * INTERFACE:   font machinery
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void
restore_device()
{
        fix     i;
        //struct   gs_hdr   near *pre_ptr; @WIN
        struct   gs_hdr   FAR *pre_ptr;

        /* pointer of previous graphics stack */
        pre_ptr = &gs_stack[current_gs_level - 1];

        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->device.default_ctm[i] =
                           pre_ptr->device.default_ctm[i];
        }

        GSptr->device.default_clip.ux = pre_ptr->device.default_clip.ux;
        GSptr->device.default_clip.uy = pre_ptr->device.default_clip.uy;
        GSptr->device.default_clip.lx = pre_ptr->device.default_clip.lx;
        GSptr->device.default_clip.ly = pre_ptr->device.default_clip.ly;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\gs_dummy.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:       gs_dummy.c
 *
 *      Purpose:    This file contains 4 pseudo BAUER PDL operators used
 *                  for debugging: st_dumppath, st_dumpclip, st_countnode,
 *                  and st_countedge.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      1.0         12/28/87    Performance enhancement:
 *                              1.@TRVSE
 *                                update routines called by traverse_
 *                                path: dump_all_path().
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) add compiling option: LINT_ARGS
 *                  11/30/88    @ET:
 *                              1) delete count_freeedges()
 *                              2) revise dump_all_edge()
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"



#ifdef DBG
#ifdef LINT_ARGS
        static void dump_a_node(struct nd_hdr FAR *);
#else
        static void dump_a_node();
#endif
#endif


fix st_dumppath()
{
#ifdef DBG
        traverse_path(dump_all_path, (fix FAR *)NULLP);
#endif
        return(0);
}

fix st_dumpclip()
{
#ifdef DBG
        printf("clipping information:\n bounding box:");
        dump_all_clip();
#endif
        return(0);
}


fix st_countnode()
{
#ifdef DBG
        fix     ret;
        fix     i;
        struct nd_hdr FAR *node;

        ret = count_freenodes();
        printf("# of free nodes = %d,",ret);
        printf("  current_gs_level = %d\n", current_gs_level);
#ifdef DBG2
        /* dump all nodes that are not in the free list */
        if (ret != MAXNODE) {
                printf("Unfreed nodes:\n");
                for (i=0; i<MAXNODE; i++) {
                        node = &node_table[i];
                        if (node->VX_TYPE != 0x55) {
                                printf("  #%d= ", i);
                                dump_a_node(node);
                        }
                }
        }
#endif
#endif
        return(0);
}

fix st_countedge()
{
        return(0);
}

#ifdef DBG

static void dump_a_node(node)
struct nd_hdr FAR *node;
{

        switch (node->VX_TYPE) {
        case MOVETO :
        case PSMOVE:

                /* @NODE */
                printf("SUBPATH  ");
                printf("flag=%d tail=%d\n",
                       node->SP_FLAG, node->SP_TAIL);

                printf("MOVETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;
        case LINETO:
                printf("LINETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        case CURVETO:
                printf("CURVETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        case CLOSEPATH:
                printf("CLOSEPATH  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        default:
                /* @NODE
                 * printf("SUBPATH  ");
                 * printf("flag=%d head=%d tail=%d\n",
                 *        node->SP_FLAG, node->SP_HEAD, node->SP_TAIL);
                 * printf("or TPZD  ");
                 */
                printf("TPZD  ");
                printf("(%f, %f, %f), ", node->CP_TOPY/8.0,
                       node->CP_TOPXL/8.0, node->CP_TOPXR/8.0);
                printf("(%f, %f, %f)\n", node->CP_BTMY/8.0,
                       node->CP_BTMXL/8.0, node->CP_BTMXR/8.0);
        } /* switch */

        printf("next=%d\n", node->next);
}


void dump_all_clip ()
{
        fix     i;
        CP_IDX  itpzd;
        struct nd_hdr FAR *tpzd;

        printf(" (%f, %f),",
               GSptr->clip_path.bb_lx/8.0, GSptr->clip_path.bb_ly/8.0);
        printf(" (%f, %f)\n",
               GSptr->clip_path.bb_ux/8.0, GSptr->clip_path.bb_uy/8.0);
        printf("   single_rect=");
        if (GSptr->clip_path.single_rect)
                printf("TRUE");
        else
                printf("FALSE");
        printf("   inherit=");
        if (GSptr->clip_path.inherit)
                printf("TRUE");
        else
                printf("FALSE");

        printf("\n   clip trapezoids:\n");
        for (i = 1, itpzd = GSptr->clip_path.head; itpzd != NULLP;
             i++, itpzd = tpzd->next) {
                tpzd = &node_table[itpzd];
                printf("   %d) ",i);
                printf("(%f, %f, %f), ", tpzd->CP_TOPY/8.0,
                       tpzd->CP_TOPXL/8.0, tpzd->CP_TOPXR/8.0);
                printf("(%f, %f, %f)\n", tpzd->CP_BTMY/8.0,
                       tpzd->CP_BTMXL/8.0, tpzd->CP_BTMXR/8.0);
        }
}




void dump_all_path (isubpath)
SP_IDX isubpath;
{
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx;
        struct coord FAR *p;
        fix     i;

#ifdef DBG1
        printf("subpath# %d\n", isubpath);
#endif

        /* Traverse the current subpath, and dump all nodes */
        /* for (ivtx = node_table[isubpath].SP_HEAD; @NODE */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];
                p = inverse_transform(F2L(vtx->VERTEX_X),F2L(vtx->VERTEX_Y));

#ifdef DBG1
                printf("#%d", ivtx);
#endif

                switch (vtx->VX_TYPE) {

                case PSMOVE :
                        printf(" %f %f moveto", p->x, p->y);
#ifdef DBG1
                        printf(" Psmove (%f, %f)", p->x, p->y);
                        /* if (node_table[isubpath].SP_FLAG & SP_CURVE) @NODE*/
                        if (vtx->SP_FLAG & SP_CURVE)    /* @NODE */
                                printf(" V");
                        if (vtx->SP_FLAG & SP_OUTPAGE)  /* @NODE */
                                printf(" O");
                        if (vtx->SP_FLAG & SP_DUP)      /* @NODE */
                                printf(" D");
                        printf(", next=%d, tail=%d, sp_next=%d", vtx->next,
                                vtx->SP_TAIL, vtx->SP_NEXT);
#endif
                        printf("\n");
                        break;

                case MOVETO :
                        printf(" %f %f moveto", p->x, p->y);
#ifdef DBG1
                        /* if (node_table[isubpath].SP_FLAG & SP_CURVE) @NODE*/
                        if (vtx->SP_FLAG & SP_CURVE)    /* @NODE */
                                printf(" V");
                        if (vtx->SP_FLAG & SP_OUTPAGE)  /* @NODE */
                                printf(" O");
                        if (vtx->SP_FLAG & SP_DUP)      /* @NODE */
                                printf(" D");
                        printf(", next=%d, tail=%d, sp_next=%d", vtx->next,
                                vtx->SP_TAIL, vtx->SP_NEXT);
#endif
                        printf("\n");
                        break;

                case LINETO :
                        printf(" %f %f lineto\n", p->x, p->y);
                        break;

                case CURVETO :
                        for (i=0; i<2; i++) {
                                printf(" %f %f", p->x,p->y);
                                vtx = &node_table[vtx->next];
                                p = inverse_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                        }
                        printf(" %f %f curveto\n", p->x, p->y);
                        break;

                case CLOSEPATH :
                        printf(" closepath\n");
                        break;

                default:
                        printf(" Unknow node_type=%d\n", node->VX_TYPE);

                } /* switch */

        } /* for loop */

}

void dump_all_edge (first_edge, last_edge)              /* @ET */
fix     first_edge, last_edge;
{
        fix     current_edge;
        struct  edge_hdr FAR *cp;
        fix     i;

        printf("   edge#        topx:topy      endx:endy    x_int\n");
        for (i = 1, current_edge=first_edge; current_edge <= last_edge;
             i++, current_edge++) {

                /*cp = &edge_table[current_edge]; */
                cp = edge_ptr[current_edge];

                printf("%d)  %lx  (%f, %f)  (%f, %f) %f  ", current_edge, cp,
                       SFX2F(cp->ET_TOPX), SFX2F(cp->ET_TOPY),
                       SFX2F(cp->ET_ENDX), SFX2F(cp->ET_ENDY),
                       SFX2F(cp->ET_XINT));

                if (cp->ET_FLAG & HORIZ_EDGE) printf("- ");
                else if (cp->ET_FLAG & WIND_UP) printf("^ ");
                else printf("v ");
                if (cp->ET_FLAG & FREE_EDGE) printf("F ");
                if (cp->ET_FLAG & CROSS_PNT) printf("X ");
                if (cp->ET_WNO) printf("W ");
                printf("\n");
        }
}


fix count_freenodes()
{
        fix     i, inode;
        struct  nd_hdr FAR *node;

        i = 0;
        for (inode = freenode_list; inode != NULLP; ) {
            if (inode > MAXNODE || inode < 0) {
               printf("Fatal error - illegal node entry - %d\n", inode);
               break;
            }
            node = &node_table[inode];
            inode = node ->next;
#ifdef DBG2
            node->VX_TYPE = 0x55;
#endif
            i++;
        }
        return(i);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\image.c ===
/***************************************************************************
 *
 *      Name:       image.c
 *
 *      Purpose:
 *
 *      Developer: J.Jih
 *
 *      History:
 *      Version    Date        Comments
 *                 4/2/88      @CACHE_INFO: get cache_info from
 *                             font machinery for scan_conversion
 *                 4/5/88      @SCAN_CVT: call scan_conversion with
 *                             F_TO_IMAGE only for filling a seed
 *                 4/18/88     @CLIP_TBL: move clip_path from
 *                             edge_table to node_table
 *                 4/27/88     @#IMAGE: split single image seed
 *                             pattern into 4 image seed patterns
 *                 5/20/88     @#IMAGE: correct the calculation of
 *                             max_bb_height by casting (fix32)
 *                 5/21/88     @#IMAGE: correct the calculation of
 *                             the size of image seed patterns and
 *                             x & y thresholds
 *                 5/24/88     @#IMAGE: coordinates of sample is
 *                             out of SFX range
 *                 5/25/88     @#IMAGE: show_buildchar does not call
 *                             imagemask_shape for space of user
 *                             defined font
 *                 5/31/88     @#IMAGE: different result of image
 *                 6/14/88     remove unnecessary codes and options
 *                 7/21/88     @DT: data type version
 *                             - long  -> long32 -- fill_seed()
 *                             - char  -> ubyte
 *                             - int   -> fix
 *                             - float -> real32
 *                             - short -> fix16
 *                             - long  -> fix32
 *                             Note: unsolved data type "union" in
 *                                   check_clip_status();
 *                                   ref. S.C. Chen
 *                 7/21/88     @#ALIGN: bitmap word alignment
 *                 8/11/88     remove continuation mark "\" in routines:
 *                             op_image, imagemask_shape
 *                 8/26/88     @#GEN: graphics enhancement              Y.C.
 *                 8/30/88     @#CSR: code size reduction               Y.C.
 *                                    op_imagemask()
 *                                    image_boundary()
 *                                    band_boundary()
 *                 9/14/88     reduce code size and remove commented code
 *                 10/07/88    change COUNT to FRCOUNT
 *                 10/20/88    modify check_clip_status add clip trapzod
 *                             feature
 *                 11/02/88    process rectangle clip case
 *                 12/30/88    remove set_pcode
 *                             modify image_boundary()
 *                                    check_clip_status()
 *                 01/16/89    new image/imagemask processing approach
 *                 01/26/89    fix bugs comes from new image/imagemask
 *                             processing approach
 *                 02/01/89    translate variables declared as fix16 to fix
 *                             unused parameters are also removed
 *                 03/18/89    pack neighboring samples on same number of
 *                             white pixels instead of same gray level
 *                 03/30/89    alloc_vmheap() & free_vmheap() is moved to
 *                             language group
 *                 04/08/89    fix bugs of selecting wrong image process
 *                             routine
 *                 04/21/89    approaching compatibility of gray to V 47
 *                 05/25/89    add a parameter of fill_destination to
 *                             fill_seed().
 *                 05/26/89    apply new macro for zero comparison of floating
 *                             points; macro: IS_ZERO()
 *                 07/18/89    fix bug of fast_clip_image_process(): string
 *                             pointer does not advance before enter unclipped
 *                             area such that image is swapped up
 *                 4/7/90      fix bug of white lines in fast_clip_image_process
 *                 5/15/90     skip pixmap[-1] in slow_clip_image_process
 *                 10/16/90    updated for upsidedown image
 *                 4/17/91     get rid of width checking (3331 was the previous
 *                             maximum width)
 *                 4/17/91     porting from 68K to 29K:
 *                              get rid of BottomLine, fb_mark
 *                              get rid of wait_unitl_flush()
 *                              add GEIeng_checkcomplete()
 *                              delete amplify_image_page()
 *                              get rid of path in include file.
 *                 5/02/91      Add CHECK_STRINGTYPE() after each interpreter
 *                              call
 *
 *                 5/06/91     Add macro SAVE_OPNPTR() and RESTORE_OPNPTR()
 *                              move operand stack pointer before image and
 *                              imagemask processing, restore opnstktop and
 *                              opnstkptr before return from op_image and
 *                              op_imagemask if error occurred.
 *                             Add two global varialbes:
 *                              ufix16  save_opnstktop;
 *                              struct  object_def      *save_opnstkptr;
 *                             Should be move to global.def in the future, also
 *                             save and restore opnstkptr and opnstktop in
 *                             operator dispatch function: interpreter().
 *                 5/6/91      update op_imagemask for empty procedure,
 *                              i.e. pop operands first.
 *                 5/7/91      update fast_clip_image_process to skip
 *                              clipping checking for rotated images
 *                 5/21/91     add flush_gcb in op_image and op_imagemask
 *                 11/21/91     upgrade for higher resolution @RESO_UPGR
 *****************************************************************************/


// DJC added global include
#include "psglobal.h"


#include <stdio.h>
#include <math.h>
//#include "float.h"
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "halftone.h"
#include "fillproc.h"
#include "fillproc.ext"
#include "font.h"
#include "font.ext"
#include "image.h"         /*mslin 1/13/91 IMG_OPT*/

#define static  /* ??? */

#define BOTTOM  1                       /* bit 0: BOTTOM   -- c1  */
#define TOP     2                       /* bit 1: TOP      -- c2  */
#define RIGHT   4                       /* bit 2: RIGHT    -- c3  */
#define LEFT    8                       /* bit 3: LEFT     -- c4  */

#define LFX2S(lfx)    ((fix16) (LFX2I(lfx)))
#define SFX2S(sfx)    ((fix16) (SFX2I(sfx)))

/* The following one is replaced by HALF_LFX.  @RESO_UPGR
#define LFX_HALF      ((lfix_t) (I2LFX(1)) >> 1) */

/*mslin 5/6/91 begin */
ufix16  save_opnstktop;
struct  object_def      FAR *save_opnstkptr;

#define SAVE_OPNPTR() {\
        save_opnstktop = opnstktop; \
        save_opnstkptr = opnstkptr; \
}
#define RESTORE_OPNPTR() {\
        opnstktop = save_opnstktop; \
        opnstkptr = save_opnstkptr; \
}
/*mslin 5/6/91 end */

/* ********** static function declartion ********** */

#ifdef  LINT_ARGS
/*mslin 3/21/91 begin OPT*/
bool image_shortcut(real32 FAR *, real32 FAR *, fix);
void clear_image(real32 FAR *);
static void  near    scale_image_process(fix, fix32,
                                        struct object_def,
                                        lfix_t FAR *);
void amplify_image_page(IMAGE_INFOBLOCK   FAR *);
/*mslin 3/21/91 end OPT*/

static void  near    best_image_process(ufix, fix, fix32, fix, bool,
                                        struct object_def, fix,
                                        lfix_t FAR *);
static void  near    fast_clip_image_process(ufix, fix, fix32, fix, bool,
                                             struct object_def, fix,
                                             lfix_t FAR *);
static void  near    slow_clip_image_process(ufix, fix, fix32, fix, bool,
                                             struct object_def,
                                             fix, lfix_t FAR *);
static void  near    worst_image_process(ufix, fix, fix32, fix, bool,
                                         struct object_def,
                                         real32 FAR *);
static void  near    exhaust_image_data(fix, fix32, fix, struct object_def);

static void  near    image_matrix(real32 FAR *, real32 FAR *,
                                  fix32, fix, real32 FAR *);
static void  near    image_sample(real32 FAR *, fix);
static fix   near    check_clip_status(real32 FAR *);
static fix   near    image_gwcm_space(fix32, lfix_t FAR *, fix);
static void  near    band_boundary(lfix_t FAR *, fix32, fix32, fix,
                                   fix FAR *);

static void  near    flush_seed_sample_list(ufix, fix, fix FAR *);
static void  near    flush_clip_sample_list(ufix, fix, fix FAR *);
static bool  near    fill_a_sample(struct polygon_i FAR *);
#else
/*mslin 3/21/91 begin OPT*/
bool image_shortcut();
void clear_image();
static void  near    scale_image_process();
void amplify_image_page();
/*mslin 3/21/91 end OPT*/

static void  near    best_image_process();
static void  near    fast_clip_image_process();
static void  near    slow_clip_image_process();
static void  near    worst_image_process();
static void  near    exhaust_image_data();

static void  near    image_matrix();
static void  near    image_sample();
static fix   near    check_clip_status();
static fix   near    image_gwcm_space();
static void  near    band_boundary();

static bool  near    fill_a_sample();
static void  near    flush_seed_sample_list();
static void  near    flush_clip_sample_list();
#endif


/* ************* Code Size Reduction ********************************** */

#define IMAGE           0x0000          /* op_image()                   */
#define IMAGEMASK       0x0001          /* op_imagemask()               */

static fix      save_res = -1;
/* static real32   gray_map[256]; move it out as a global allocate space @WIN*/
real32 FAR * gray_map;          /* gray value mapping table     */

/* ************* seed selection optimation *************** 12-16-88 *** */


#define MAXIMAGEWIDTH   1024                            /* @IMAGE 01-05-89 */
#define MAXSAMPLEWIDTH   256                            /* @IMAGE 01-05-89 */


struct vector {         /* data structure of a vector */
        fix     x, y;           /*   x and y component of a vector */
};

struct lookup {         /* data structure of lookup table */
        fix16     index;          /*   seed index */
        fix16     x, y;           /*   x and y relative coordinate */
};

#define ITM_A00D        0x1001          /* ITM - [A 0 0 D Tx Ty] */
#define ITM_0BC0        0x0110          /* ITM - [0 B C 0 Tx Ty] */
#define ITM_ABCD        0x1111          /* ITM - [A B C D Tx Ty] */

static ufix             itm_type;       /* Inverse Transformation Matrix type */

#define ISP_NONE        0x0000          /* ISP - SEED Too Large  */
#define ISP_FILL        0xFFFF          /* ISP - SEED Applicable */

static ufix             isp_flag = ISP_NONE;    /* SEED is applicable or not */

/*
    for image cases rotated by normal degree as [0, 90, 180, 270]
*/

static fix              no_vectors;
static fix              no_samples;     /* <- no_vectors * no_vectors */
static fix              no_lookups;
static struct vector    r_vector[4];
static struct vector    c_vector[4];
static struct sample    patterns[16];
static struct lookup   huge *x_lookup;  /* @WIN 04-20-92 */

static ufix             fill_destination_save = 0xFFFF;         /* 03-17-89 */
/* static sfix_t        r_save_x = -1, r_save_y = -1; Not useful */
/* static sfix_t        c_save_x = -1, c_save_y = -1; @RESO_UPGR */
static lfix_t           r_padv_x = -1, r_padv_y = -1; /* @RESO_UPGR */
static lfix_t           c_padv_x = -1, c_padv_y = -1; /* @RESO_UPGR */
static fix              x_mins, y_mins;
static fix              x_maxs, y_maxs;
static struct vector    r_mins, r_maxs;
static struct vector    c_mins, c_maxs;

/* mslin, begin 1/3/91 IMG_OPT */
ubyte   image_dev_flag;
ubyte   image_logic_op;
ubyte   image_shift;
/* mslin, end 1/3/91 IMG_OPT */


static void near
image_sample(inv_matrix, width)
real32    FAR *inv_matrix;
fix             width;
{
    real32              r_size_x, r_size_y;
    real32              c_size_x, c_size_y;

    /* get idea seed from inverse transformation matrix */
    r_size_x = inv_matrix[2];
    r_size_y = inv_matrix[3];
    c_size_x = inv_matrix[0];
    c_size_y = inv_matrix[1];

#ifdef  DBG1
    printf("R@: [%f, %f]     C@: [%f, %f]\n",
           r_size_x, r_size_y, c_size_x, c_size_y);
#endif

    /* check if image seed patterns changed */
    /* if (fill_destination_save != fill_destination ||   |* 03-17-89 *|
        r_save_x != F2SFX(r_size_x) || r_save_y != F2SFX(r_size_y) ||
        c_save_x != F2SFX(c_size_x) || c_save_y != F2SFX(c_size_y) */
    /* [cr]_save_[xy] is not useful and can be replaced by
       [cr]_padv_[xy] @RESO_UPGR
    */
    if (fill_destination_save != fill_destination ||
        r_padv_x != F2LFX(r_size_x) || r_padv_y != F2LFX(r_size_y) ||
        c_padv_x != F2LFX(c_size_x) || c_padv_y != F2LFX(c_size_y)
        )
    {
        fix                 r_index;
        fix                 c_index;
        fix                 p_index;
        struct sample      FAR *p_point;

        x_mins = y_mins = 0;
        x_maxs = y_maxs = 0;

        fill_destination_save = fill_destination;               /* 03-17-89 */

        /* calculate the vectors in internal short fix format
           Not useful and use [cr]_padv_[xy] instead   @RESO_UPGR
        r_save_x = F2SFX(r_size_x);
        r_save_y = F2SFX(r_size_y);
        c_save_x = F2SFX(c_size_x);
        c_save_y = F2SFX(c_size_y); */

        /* calculate the vectors in internal long fix format */
        r_padv_x = F2LFX(r_size_x);
        r_padv_y = F2LFX(r_size_y);
        c_padv_x = F2LFX(c_size_x);
        c_padv_y = F2LFX(c_size_y);
#ifdef DJC //This printf accesses variables that are commented out above!
#ifdef  DBG1
        printf("R*: [%x, %x]     C*: [%x, %x]\n",
               r_save_x, r_save_y, c_save_x, c_save_y);
        printf("R$: [%lx, %lx]     C$: [%lx, %lx]\n",
               r_padv_x, r_padv_y, c_padv_x, c_padv_y);
#endif
#endif


        /* setup minimum and maximum vectors along X and Y */
        r_mins.x = (fix) (r_size_x);
        r_maxs.x = (fix) (r_mins.x + ((r_padv_x >= 0) ? 1 : -1));
        r_mins.y = (fix) (r_size_y);
        r_maxs.y = (fix) (r_mins.y + ((r_padv_y >= 0) ? 1 : -1));
        c_mins.x = (fix) (c_size_x);
        c_maxs.x = (fix) (c_mins.x + ((c_padv_x >= 0) ? 1 : -1));
        c_mins.y = (fix) (c_size_y);
        c_maxs.y = (fix) (c_mins.y + ((c_padv_y >= 0) ? 1 : -1));

#ifdef  DBG1
        printf("RX- %d    RY-: %d\n", r_mins.x, r_mins.y);
        printf("RX+ %d    RY+: %d\n", r_maxs.x, r_maxs.y);
        printf("CX- %d    CY-: %d\n", c_mins.x, c_mins.y);
        printf("CX+ %d    CY+: %d\n", c_maxs.x, c_maxs.y);
#endif

        /* setup row and column vectors */
        if (IS_ZERO(c_size_y) && IS_ZERO(r_size_x)) {

            itm_type = ITM_A00D;
            c_vector[0].x = c_mins.x;   c_vector[0].y = 0;
            c_vector[1].x = c_maxs.x;   c_vector[1].y = 0;
            r_vector[0].x = 0;          r_vector[0].y = r_mins.y;
            r_vector[1].x = 0;          r_vector[1].y = r_maxs.y;
            no_vectors = 2;
        } else

        if (IS_ZERO(c_size_x) && IS_ZERO(r_size_y)) {
#ifdef  DBG1
            printf("[0 B C 0 Tx Ty]\n");
#endif

            itm_type = ITM_0BC0;
            c_vector[0].x = 0;          c_vector[0].y = c_mins.y;
            c_vector[1].x = 0;          c_vector[1].y = c_maxs.y;
            r_vector[0].x = r_mins.x;   r_vector[0].y = 0;
            r_vector[1].x = r_maxs.x;   r_vector[1].y = 0;
            no_vectors = 2;
        } else {
#ifdef  DBG1
            printf("[A B C D Tx Ty]\n");
#endif
            itm_type = ITM_ABCD;
            c_vector[0].x = c_mins.x;   c_vector[0].y = c_mins.y;
            c_vector[1].x = c_maxs.x;   c_vector[1].y = c_mins.y;
            c_vector[2].x = c_mins.x;   c_vector[2].y = c_maxs.y;
            c_vector[3].x = c_maxs.x;   c_vector[3].y = c_maxs.y;
            r_vector[0].x = r_mins.x;   r_vector[0].y = r_mins.y;
            r_vector[1].x = r_maxs.x;   r_vector[1].y = r_mins.y;
            r_vector[2].x = r_mins.x;   r_vector[2].y = r_maxs.y;
            r_vector[3].x = r_maxs.x;   r_vector[3].y = r_maxs.y;
            no_vectors = 4;
        }

        no_samples = no_vectors * no_vectors;

#ifdef  DBG1
        printf("#V: %d    #S: %d\n", no_vectors, no_samples);
#endif
        p_point = patterns;

        /* setup polygon descriptions of image seed patterns from
           row and column vectors */
        for (r_index = 0; r_index < no_vectors; r_index++) {
            for (c_index = 0; c_index < no_vectors; c_index++) {
                p_point->p[0].x = 0;
                p_point->p[0].y = 0;

                p_point->p[1].x = c_vector[c_index].x;
                if (x_mins > p_point->p[1].x)  x_mins = p_point->p[1].x;
                if (x_maxs < p_point->p[1].x)  x_maxs = p_point->p[1].x;
                p_point->p[1].y = c_vector[c_index].y;
                if (y_mins > p_point->p[1].y)  y_mins = p_point->p[1].y;
                if (y_maxs < p_point->p[1].y)  y_maxs = p_point->p[1].y;

                p_point->p[2].x = c_vector[c_index].x + r_vector[r_index].x;
                if (x_mins > p_point->p[2].x)  x_mins = p_point->p[2].x;
                if (x_maxs < p_point->p[2].x)  x_maxs = p_point->p[2].x;
                p_point->p[2].y = c_vector[c_index].y + r_vector[r_index].y;
                if (y_mins > p_point->p[2].y)  y_mins = p_point->p[2].y;
                if (y_maxs < p_point->p[2].y)  y_maxs = p_point->p[2].y;

                p_point->p[3].x = r_vector[r_index].x;
                if (x_mins > p_point->p[3].x)  x_mins = p_point->p[3].x;
                if (x_maxs < p_point->p[3].x)  x_maxs = p_point->p[3].x;
                p_point->p[3].y = r_vector[r_index].y;
                if (y_mins > p_point->p[3].y)  y_mins = p_point->p[3].y;
                if (y_maxs < p_point->p[3].y)  y_maxs = p_point->p[3].y;

#ifdef  DBG1
                printf("[%d, %d]  [%d, %d]  [%d, %d]\n",
                       p_point->p[1].x, p_point->p[1].y,
                       p_point->p[2].x, p_point->p[2].y,
                       p_point->p[3].x, p_point->p[3].y);
#endif

                p_point++;
            }
        }

#ifdef  DBG1
        printf("X-: %d    X+: %d\n", x_mins, x_maxs);
        printf("Y-: %d    Y+: %d\n", y_mins, y_maxs);
#endif

        x_maxs-= x_mins;        y_maxs-= y_mins;

        /* determine if image seed pattern is applicable or not */
        isp_flag = (ufix)((BM_BOUND(x_maxs)) <= MAXSAMPLEWIDTH &&
                    (BM_BYTES(x_maxs) * y_maxs) <= (ufix)isp_size)       //@WIN
                   ? ISP_FILL : ISP_NONE;

#ifdef  DBG1
        printf((isp_flag == ISP_FILL)
               ? "SEED is applicable\n" : "SEED is too large\n");
#endif

        if (isp_flag == ISP_FILL) {
            /* generate all image seed patterns: 4 or 16 */
            for (p_index= 0, p_point = patterns; p_index < no_samples;
                 p_index++, p_point++)
            {
                fix                     index;
                struct sample           quadrangle;

                /* select seed index */
                image_info.seed_index = (fix16)p_index;

                for (index = 0; index < 4; index++)
                {
                    quadrangle.p[index].x = p_point->p[index].x - x_mins;
                    quadrangle.p[index].y = p_point->p[index].y - y_mins;
                }

                fill_seed(fill_destination_save, x_maxs,        /* 05-25-89 */
                                      y_maxs, &quadrangle);
            }
        }

        no_lookups = 0;
    }

    /* setup lookup description of column */
    if (isp_flag == ISP_FILL)                                   /* 03-30-89 */
    {
        fix                 index;
        struct lookup huge  *point;     /* @WIN 04-20-92 */
        fix                 c_post_x, c_post_y;
        lfix_t              c_pabs_x, c_pabs_y;

#ifdef  DBG1
        printf("#L: %d\n", width);
#endif

        if ((x_lookup = (struct lookup huge *)  /* @WIN 04-20-92 */
                    alloc_heap((ufix32) (width + 1)
                                    * sizeof(struct lookup))) == NIL)
        {
            CLEAR_ERROR();
            goto skip;
        }

        point = x_lookup;
        c_post_x = c_post_y = 0;
        c_pabs_x = c_pabs_y = 0;

        if (itm_type == ITM_A00D) {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_x+= c_padv_x;
                if ((LFX2S(c_pabs_x) - c_post_x) == c_maxs.x)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_x = LFX2S(c_pabs_x);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }
        } else
        if (itm_type == ITM_0BC0) {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_y+= c_padv_y;
                if ((LFX2S(c_pabs_y) - c_post_y) == c_maxs.y)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_y = LFX2S(c_pabs_y);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }
        } else {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_x+= c_padv_x;
                if ((LFX2S(c_pabs_x) - c_post_x) == c_maxs.x)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_x = LFX2S(c_pabs_x);

                c_pabs_y+= c_padv_y;
                if ((LFX2S(c_pabs_y) - c_post_y) == c_maxs.y)
                    point->index|= 0x02;
                c_post_y = LFX2S(c_pabs_y);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }

            point->x = (fix16)c_post_x;
            point->y = (fix16)c_post_y;
        }

        no_lookups = width;

    skip:   ;
    }
}


/************************************************************************
 *
 * This module is to flush sample list to page
 *
 * TITLE:       flush_seed_sample_list
 *
 * CALL:        flush_seed_sample_list()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
flush_seed_sample_list(optype, gray_res, bb)
ufix     optype;
fix      gray_res;
fix FAR bb[];
{
    fix     index;
    fix     bb_xorig;
    fix     bb_yorig;
    fix     bb_width;
    fix     bb_height;

    bb_xorig  = bb[0];                                          /* 01-26-89 */
    bb_yorig  = bb[2];                                          /* 01-26-89 */
    bb_width  = bb[1] - bb[0];                                  /* 01-26-89 */
    bb_height = bb[3] - bb[2] + 1;                              /* 01-26-89 */

#ifdef  DBG3
    printf("SEED:  %x %x %x %x\n", bb_xorig, bb_yorig, bb_width, bb_height);
#endif

    if (optype == IMAGE) {
        for (index = 0; index <= gray_res; index++) {
            if (gray_chain[index].start_seed_sample != NULLP) {
#ifdef  DBG4
                printf("flush %x: %f %x\n",
                index, gray_map[index], gray_chain[index].start_seed_sample);
#endif

                setgray(F2L(gray_map[index]));
                draw_image_page(bb_xorig, bb_yorig,
                                bb_width, bb_height,
                                gray_chain[index].start_seed_sample);

/*                free_node(gray_chain[index].start_seed_sample);       */
                gray_chain[index].start_seed_sample = NULLP;
            }
        }
    } else {
        if (gray_chain[0].start_seed_sample != NULLP) {
            switch (fill_destination) {
            case F_TO_PAGE :
                 draw_image_page(bb_xorig, bb_yorig,
                                 bb_width, bb_height,
                                 gray_chain[0].start_seed_sample);
                 break;
            case F_TO_CACHE :
                 fill_image_cache(cache_info->bitmap,
                                  cache_info->box_w,
                                  cache_info->box_h,
                                  gray_chain[0].start_seed_sample);
                 break;
            }
/*            free_node(gray_chain[0].start_seed_sample);       */
            gray_chain[0].start_seed_sample = NULLP;
        }
    }
} /* end of flush_seed_sample_list() */


/************************************************************************
 *
 * This module is to flush sample list to page
 *
 * TITLE:       flush_clip_sample_list
 *
 * CALL:        flush_clip_sample_list()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
/*flush_clip_sample_list(optype, gray_res, bb, last_isp)*/
flush_clip_sample_list(optype, gray_res, bb)
ufix     optype;
fix      gray_res;
fix  FAR bb[];
/*struct isp_data *last_isp;*/
{
    fix    index;
    fix    bb_xorig;
    fix    bb_yorig;
    fix    bb_width;
    fix    bb_height;
    ufix   dest_save;

    bb_xorig  = bb[0];                                          /* 01-26-89 */
    bb_yorig  = bb[2];                                          /* 01-26-89 */
    bb_width  = bb[1] - bb[0];                                  /* 01-26-89 */
    bb_height = bb[3] - bb[2] + 1;                              /* 01-26-89 */

#ifdef  DBG3
    printf("CLIP:  %x %x %x %x\n", bb_xorig, bb_yorig, bb_width, bb_height);
#endif

    /* save fill_destination */
    dest_save = fill_destination;

    /* generate clipping mask for clipped image */
    image_info.bb_lx = (fix16)bb_xorig;
    image_info.bb_ly = (fix16)bb_yorig;
    image_info.bb_xw = (fix16)bb_width;
    image_info.bb_yh = (fix16)bb_height;
    fill_shape(NON_ZERO, F_FROM_IMAGE, F_TO_MASK);

    /* restore fill_destination */
    fill_destination = dest_save;

    if (optype == IMAGE) {
        for (index = 0; index <= gray_res; index++) {
            if (gray_chain[index].start_seed_sample != NULLP) {
#ifdef  DBG4
                printf("flush %x: %f %x\n",
                index, gray_map[index], gray_chain[index].start_seed_sample);
#endif

                setgray(F2L(gray_map[index]));
                fill_image_page(gray_chain[index].start_seed_sample);
/*                fill_image_page(gray_chain[index].start_seed_sample); -jwm, 12/26 */

/*                free_node(gray_chain[index].start_seed_sample);       -jwm, 12/26 */
                gray_chain[index].start_seed_sample = NULLP;
            }
        }
    } else {
        if (gray_chain[0].start_seed_sample != NULLP) {
            fill_image_page(gray_chain[0].start_seed_sample);
/*            fill_image_page(gray_chain[0].start_seed_sample);         -jwm, 12/26 */
/*            free_node(gray_chain[0].start_seed_sample);               -jwm, 12/26 */
            gray_chain[0].start_seed_sample = NULLP;
        }
    }
} /* end of flush_clip_sample_list() */


/************************************************************************
 *
 * This module is to detect if portrate or landscape
 *
 * TITLE:       image_shortcut
 *
 * CALL:        clear_image
 *
 * INTERFACE:
 *
 * CALLS:
 *
 *********************************************************************/
bool image_shortcut(inv_matrix, image_bb, type)
real32  FAR *inv_matrix, FAR *image_bb;
fix     type;
{
    fix    clip_status;
    real32  tmp0, tmp1, tmp2, tmp3;     // @WIN: fabs => FABS
        FABS(tmp0, inv_matrix[0]);      // @WIN
        FABS(tmp1, inv_matrix[1]);      // @WIN
        FABS(tmp2, inv_matrix[2]);      // @WIN
        FABS(tmp3, inv_matrix[3]);      // @WIN

        image_dev_flag = FALSE;
//      if ( (0.001 > (float)fabs(inv_matrix[1])) &&    @WIN
//                (0.001>(float)fabs(inv_matrix[2]))) {
        if ( 0.001 > tmp1 && 0.001 > tmp2) {

#ifdef  DBG1
            printf("[A 0 0 D Tx Ty]\n");
#endif

             image_dev_flag = PORTRATE;
//      } else if ( (0.001 > (float)fabs(inv_matrix[0])) &&     @WIN
//              (0.001 > (float)fabs(inv_matrix[3])) ) {
        } else if ( 0.001 > tmp0 && 0.001 > tmp3) {
#ifdef  DBG1
            printf("[0 B C 0 Tx Ty]\n");
#endif
             image_dev_flag =LANDSCAPE;

        }
        else
            {
             return(0);
             }

    if ( fill_destination != F_TO_CACHE ) {
        if ((clip_status = check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
             return(0);
        }
        if (clip_status == CLIP) {
                if(GSptr->clip_path.single_rect) {
                        image_logic_op |= IMAGE_CLIP_BIT;
                        if (image_bb[0] < SFX2F(GSptr->clip_path.bb_lx))
                            image_bb[0] = SFX2F(GSptr->clip_path.bb_lx);
                        if (image_bb[1] > SFX2F(GSptr->clip_path.bb_ux))
                            image_bb[1] = SFX2F(GSptr->clip_path.bb_ux);
                        if (image_bb[2] < SFX2F(GSptr->clip_path.bb_ly))
                            image_bb[2] = SFX2F(GSptr->clip_path.bb_ly);
                        if (image_bb[3] > SFX2F(GSptr->clip_path.bb_uy))
                            image_bb[3] = SFX2F(GSptr->clip_path.bb_uy);
                }
                else
                        return(0);

        }
        //
        // NTFIX, this was incorrectly commented out, we put it back.
        //

        if(type == IMAGE)              // @WIN_IM: not need to clear image ???
          clear_image(image_bb);      //  @WIN_IM


        return(1);
    }
    return(0);

} /* image_shortcut */

/************************************************************************
 *      (Not used by window)
 * This module is to implement image operator
 * Syntax :        width height bits matrix proc   image   -
 *
 * TITLE:       op_image
 *
 * CALL:        op_image()
 *
 * INTERFACE:   interpreter(op_image)
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
fix
op_image()
{
    fix32  height;
    lfix_t lfxm[MATRIX_LEN];
    fix    shift, width, index, gray_res;
    real32 matrix[MATRIX_LEN], inv_matrix[MATRIX_LEN], image_bb[4];
    fix    clip_status;
    real32 save_gray;
    struct object_def FAR *obj_matrix, obj_proc, name_obj;
    real32 tmp;

    byte huge          *vmheap_save;                            /* 02-13-89 */

#ifdef  DBG
    printf("op_image......\n");
#endif

    /* Check in setcachedevice error */
    if (is_after_setcachedevice()) {     /* @@ 08/17/88, you */
        /* Buildchar_and_setcachedevice flag is set to TRUE, when
         * setcachedevice operator is worked within the scope of a
         * Buildchar procedure
         */
        get_name(&name_obj, "image", 5, FALSE);
        if (FRCOUNT() < 1) {            /* Jerry 10-07-88 */
            ERROR(STACKOVERFLOW);
            return(0);
        }
        PUSH_OBJ(&name_obj);
        ERROR(UNDEFINED);
        return(0);
    }

    /* set fill_destination, it always fills to pages */
    fill_destination = F_TO_PAGE;

    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4));
 *  height = (fix32) get_obj_value(GET_OPERAND(3));
 *  shift  = ( fix ) get_obj_value(GET_OPERAND(2));
 */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix ) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(3));
    height = (fix32) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(2));
    shift  = ( fix ) tmp;

/* mslin, begin  1/3/91 IMG_OPT */
    image_logic_op = IMAGE_BIT;
    image_shift = (ubyte)shift;         //@WIN
/* mslin, end 1/3/91 IMG_OPT */


#ifdef  DBG
    printf("width  = %d\n", width);
    printf("height = %d\n", height);
    printf("shift  = %d\n", shift);
#endif

    obj_matrix = GET_OPERAND(1);
    COPY_OBJ(GET_OPERAND(0), &obj_proc);

    /* limit error check */
   /* mslin 4/17/91
    *if (width > 3331) {                 |* get from ADOBE postscript *|
    *    ERROR(LIMITCHECK);
    *    return(0);
    *}
    */

    /* rangecheck error check */
    if ((shift != 1) && (shift != 2) &&
        (shift != 4) && (shift != 8)) {
        ERROR(RANGECHECK);
        return(0);
    }

    /* check access right */
    if (!access_chk(obj_matrix, G_ARRAY) ||
        !get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY))
        return(0);

    SAVE_OPNPTR();      /*mslin 5/6/91*/
    POP(5);

    //while(GEIeng_checkcomplete());    /* @CPPH; Debug by scchen @WIN */
    flush_gcb(TRUE);    /* 5-21-91, Jack */


    /* Save current gray level */
    save_gray = GSptr->color.gray;

    /* Save the VM heap pointer */
    vmheap_save = vmheap;                                       /* 02-13-89 */

    /* Initialization; set image parameters & calculate image bounding box */
    image_matrix((real32 FAR *) matrix, (real32 FAR *) inv_matrix,
                 height, width, (real32 FAR *) image_bb);

/*mslin 3/26/91 begin OPT*/
    if(image_shortcut(inv_matrix,image_bb, IMAGE)) {
         /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }
#ifdef DBG_MS
{
    static ufix32       tmp, tmp1;

    tmp = curtime();
#endif
        scale_image_process(width, height,
                            obj_proc, (lfix_t FAR *) lfxm);
#ifdef DBG_MS
    tmp1 = curtime() - tmp;
    printf("time=%ld ", tmp1);
}
#endif
        goto exit;
    }
/*mslin 3/26/91 end OPT*/

    /* setup image seed patterns and relative information */
    image_sample((real32 FAR *) inv_matrix, width);

    if (ANY_ERROR())  goto exit;                                /* 02-13-89 */

    /* setup gray level mapping table */
    gray_res = (1 << shift) - 1;
    if (gray_res != save_res) {
        for (index = 0; index <= gray_res; index++) {
            gray_map[index] = (float) index / (float) gray_res;
        }
        save_res = gray_res;
    }

#ifdef  DBG
    printf("gray_res = %d\n", gray_res);
#endif

    /*  image/imagemask processing guildline:
     *
     *  best_image_process      -- INSIDE_CLIPPATH
     *  fast_clip_image_process -- CLIP AND ABLE TO FIT INTO SEED AND CMB
     *  slow_clip_image_process -- INSIDE_CLIPPATH OR
     *                                    UNABLE TO FIT INTO SEED OR CMB
     *  worst_image_process     -- UNABLE TO FIT INTO INTERNAL FORMAT
     *  exhaust_image_data      -- OUTSIDE_CLIPPATH
     */



    /* check if cross with wide_page size boundary */
    /* fast macro for boundary crossing check
    if (image_bb[0] < (real32)PAGE_LEFT || image_bb[1] > (real32)PAGE_RIGHT ||
        image_bb[2] < (real32)PAGE_TOP  || image_bb[3] > (real32)PAGE_BTM) {
    */
    if (too_small(F2L(image_bb[0])) || too_large(F2L(image_bb[1])) ||
        too_small(F2L(image_bb[2])) || too_large(F2L(image_bb[3]))) {
        /* worst process case */
        worst_image_process(IMAGE, width, height, shift, FALSE, obj_proc,
                            (real32 FAR *) inv_matrix);
        goto exit;
    }

    if ((clip_status = check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
        exhaust_image_data(width, height, shift, obj_proc);
        goto exit;

    }
    else { /* CLIP || INSIDE_CLIPPATH */

        /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }

        /* initial gray_chain */
        for (index = 0; index <= gray_res; index++) {
            gray_chain[index].start_seed_sample = NULLP;
        }

        /* check sample size is applicable or not */
        if (isp_flag == ISP_NONE || x_lookup == NIL) {  /* 03-30-89 04-08-89 */
            /* worst process case */
            slow_clip_image_process(IMAGE, width, height, shift, FALSE,
                                    obj_proc, gray_res, (lfix_t FAR *) lfxm);
            goto exit;
        }

        /* clip */
        if (clip_status == CLIP) {

            fast_clip_image_process(IMAGE, width, height, shift, FALSE,
                                    obj_proc, gray_res, (lfix_t FAR *) lfxm);

        } /* if CLIP */
        else { /* clip_status == INSIDE_CLIPPATH */

            best_image_process(IMAGE, width, height, shift, FALSE,
                               obj_proc, gray_res, (lfix_t FAR *) lfxm);

        }/* else INSIDE_CLIPPATH */
    }/* else CLIP || INSIDE_CLIPPATH */

exit:
    /* Restore the VM heap pointer */
    free_heap(vmheap_save);                     /* 02-13-89 */  /* 03-30-89 */

    /* Restore the gray level */
    setgray(F2L(save_gray));

#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %x %x %x %x\n",
           GSptr->clip_path.bb_lx, GSptr->clip_path.bb_ux,
           GSptr->clip_path.bb_ly, GSptr->clip_path.bb_uy);
#endif

    /*mslin 5/6/91 begin */
    if(ANY_ERROR())
        RESTORE_OPNPTR();
    /*mslin 5/6/91 end */

    return(0);
}/* end op_image */


/************************************************************************
 * This module is to implement imagemask operator.
 * Syntax :        width height invert matrix proc   imagemask   -
 *
 * TITLE:       op_imagemask
 *
 * CALL:        op_imagemask()
 *
 * INTERFACE:   interpreter(op_imagemask)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_imagemask()
{
    fix    width;
    real32 matrix[MATRIX_LEN];
    struct object_def FAR *obj_matrix;
    real32 tmp;

#ifdef  DBG
    printf("op_imagemask......\n");
#endif

    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4)); */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix )tmp;

    obj_matrix = GET_OPERAND(1);

    /* limit error check */
   /* mslin 4/17/91
    *  if (width > 3331) {             |* get from ADOBE postscript *|
    *      ERROR(LIMITCHECK);
    *      return(0);
    * }
    */

    /* check access right */
    if (!access_chk(obj_matrix, G_ARRAY) ||
        !get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY))
        return(0);

    /*
     * The lines listed above are moved from imagemask_shape()
     *                                  @#IMAGE: 05-25-88 Y.C.
     */

    /*  UNDEFINED error check in show_buildchar() */
    if (buildchar) {
        show_buildchar(OP_IMAGEMASK);
        POP(5);         /* 5-8-91, Jack */
    } else
        imagemask_shape(F_TO_PAGE);

/*  POP(5); *mslin, 5/6/91 */

    //while(GEIeng_checkcomplete());    /* @CPPH; Debug by scchen @WIN */
    flush_gcb(TRUE);    /* 5-21-91, Jack */


#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %x %x %x %x\n",
           GSptr->clip_path.bb_lx, GSptr->clip_path.bb_ux,
           GSptr->clip_path.bb_ly, GSptr->clip_path.bb_uy);
#endif

    /*mslin 5/6/91 begin */
    if(ANY_ERROR())
        RESTORE_OPNPTR();
    /*mslin 5/6/91 end */

    return(0);
}/* end of op_imagemask */


/************************************************************************
 * This module is to implement imagemask operator.
 *
 * TITLE:       imagemask_shape
 *
 * CALL:        imagemask_shape(dest)
 *
 * INTERFACE:   op_imagemask
 *
 * CALLS:       transform, convex_clipper, filler
 ************************************************************************/
void
imagemask_shape(dest)
ufix    dest;
{
    fix32  height;
    lfix_t lfxm[MATRIX_LEN];
    bool   invert;
    fix    width, index;
    real32 matrix[MATRIX_LEN], inv_matrix[MATRIX_LEN], image_bb[4];
    fix    clip_status;
//  fix    max_bb_height;       @win
    fix shift=1,gray_res=1;
    struct object_def FAR *obj_matrix, obj_proc;
    real32 tmp;

    byte huge          *vmheap_save;                            /* 02-13-89 */

#ifdef  DBG
    printf("imagemask_shape......\n");
#endif

    /* set fill_destination, it always fills to pages */
    fill_destination = dest;


    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4));
 *  height = (fix32) get_obj_value(GET_OPERAND(3));
 */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix ) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(3));
    height = (fix32) tmp;
    invert = (bool)  VALUE(GET_OPERAND(2));

/* mslin, begin 1/3/91 IMG_OPT */
    image_shift = 1;
    image_logic_op = (ubyte)(invert == FALSE ? IMAGEMASK_FALSE_BIT :    //@WIN
                        0);
/* mslin, end 1/3/91 IMG_OPT */

#ifdef  DBG
    printf("width  = %d\n", width);
    printf("height = %d\n", height);
    printf("invert = %d\n", invert);
#endif

    obj_matrix = GET_OPERAND(1);
    COPY_OBJ(GET_OPERAND(0), &obj_proc);

    /*mslin 5/6/91 begin, retored by op_imagemask() if error occurred */
    SAVE_OPNPTR();
    if (! buildchar)    /* 5-8-91, Jack */
        POP(5);
    /*mslin 5/6/91 end */


    //NTFIX we can get here in valid conditions and should check for for test....
    //      this boundary condition.

    if (height == 0 || width == 0 ) {
#ifdef DBG
       printf("\nGetting width or height = 0 in imagemask_shape()");
#endif
       return;
    }

    get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY);

    /* Save the VM heap pointer */
    vmheap_save = vmheap;                                       /* 02-13-89 */

    /* Initialization; set image parameters & calculate image bounding box */
    image_matrix((real32 FAR *) matrix, (real32 FAR *) inv_matrix,
                 height, width, (real32 FAR *) image_bb);

/*mslin 3/26/91 begin OPT*/
    if(image_shortcut(inv_matrix,image_bb, IMAGEMASK)) {
         /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }
        scale_image_process(width, height,
                            obj_proc, (lfix_t FAR *) lfxm);
        goto exit;
    }
/*mslin 3/26/91 end OPT*/

    /* setup image seed patterns and relative information */
    image_sample((real32 FAR *) inv_matrix, width);

    if (ANY_ERROR())  goto exit;                                /* 02-13-89 */



    /* check if cross with wide_page size boundary */
    /* fast macro for boundary crossing check
    if (image_bb[0] < (real32)PAGE_LEFT || image_bb[1] > (real32)PAGE_RIGHT ||
        image_bb[2] < (real32)PAGE_TOP  || image_bb[3] > (real32)PAGE_BTM) {
    */
    if (too_small(F2L(image_bb[0])) || too_large(F2L(image_bb[1])) ||
        too_small(F2L(image_bb[2])) || too_large(F2L(image_bb[3]))) {
        /* worst process case */
        worst_image_process(IMAGEMASK, width, height, 1, invert, obj_proc,
                            (real32 FAR *) inv_matrix);
        goto exit;
    }

    if ((clip_status = (fill_destination == F_TO_CACHE)
                     ? INSIDE_CLIPPATH
                     : check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
        exhaust_image_data(width, height, 1, obj_proc);
        goto exit;
    }
    else { /* CLIP || INSIDE_CLIPPATH */

        /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }

        /* initial gray_chain */
        gray_chain[0].start_seed_sample = NULLP;

        /* check sample size is applicable or not */
        if (isp_flag == ISP_NONE || x_lookup == NIL) {  /* 03-30-89 04-08-89 */
            /* worst process case */
            slow_clip_image_process(IMAGEMASK, width, height, 1, invert,
                                    obj_proc, 1, (lfix_t FAR *) lfxm);
            goto exit;

        }
        /* clip */
        if (clip_status == CLIP) {

            fast_clip_image_process(IMAGEMASK, width, height, 1, invert,
                                    obj_proc, 1, (lfix_t FAR *) lfxm);

        } /* if CLIP */
        else { /* clip_status == INSIDE_CLIPPATH */

            best_image_process(IMAGEMASK, width, height, 1, invert,
                               obj_proc, 1, (lfix_t FAR *) lfxm);

        }/* else INSIDE_CLIPPATH */
    }/* else CLIP || INSIDE_CLIPPATH */

exit:
    /* Restore the VM heap pointer */
    free_heap(vmheap_save);                     /* 02-13-89 */  /* 03-30-89 */

    return;
}/* end of imagemask_shape */

/*mslin 3/21/91 begin OPT*/
/************************************************************************
 *
 * This module is to implement clear image area before render image
 *
 * TITLE:       clear_image
 *
 * CALL:
 *
 * INTERFACE:
 *
 * CALLS:
 * History:     MSLin created on 3/21/91
 *
 *********************************************************************/

void
clear_image(bb)
real32  FAR *bb;
{
 fix                 ys_line, no_lines;
 register  fix       nwords;                     /* ufix -> fix  11-08-88 */
 register  ufix16    FAR *ptr;
 register  SCANLINE  xs, xe;
 register  fix       bb_width;
           ufix16    FAR *scan_addr;
           ufix16    FAR *bb_addr;
 register  ufix16    lmask, rmask;
           ufix16    loffset;
 real32              FAR *rptr;

   /*
    * get destination bitmap address & width
    */
   bb_addr = (ufix16 FAR *)FB_ADDR;
   bb_width = FB_WIDTH;
   rptr = bb;
   xs = (SCANLINE)F2SHORT(*rptr++) + 1;
   xe = (SCANLINE)F2SHORT(*rptr++) - 1;
   ys_line = (fix)F2SHORT(*rptr++) + 1;                 /* -1 ??? */
   no_lines = (fix)*rptr - ys_line - 1;                 /* -1 ??? */
   if(xe < xs)
        return;

#ifdef DBG_MS
 printf("xs=%d, xe=%d, ys=%d,  ye=%d\n",
         xs, xe, (fix)bb[2], (fix)bb[3]);
#endif
#ifdef DBG
 printf("Enter scanline(), bb_addr = %lx, no_lines = %d\n", bb_addr, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   scan_addr = bb_addr + ys_line * (bb_width >> SHORTPOWER);

   /*
    * Filling zero
    */
     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
#ifdef DBG
  printf("line start\n");
#endif
                /*
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */

                ptr = scan_addr + (xs >> SHORTPOWER);
#ifdef DBG
  printf("seg. ptr = %lx, xs = %d, xe = %d\n", ptr, xs, xe);
#endif
                loffset = xs & SHORTMASK;
                lmask = (ufix16) (ONE16 LSHIFT loffset);        //@WIN
                rmask = (ufix16) BRSHIFT(ONE16,
                        (BITSPERSHORT -((fix16)xe & SHORTMASK)),16); //@WIN
                nwords = (xe >> SHORTPOWER) - (xs >> SHORTPOWER);
#ifdef DBG
  printf("lmask = %x, rmask = %x, nwords = %d\n", lmask, rmask, nwords);
#endif
                if(nwords == 0) {
                   *ptr &= ~lmask;
                   continue;
                }
                if(lmask != 0) {
                   *ptr &=  ~lmask;
                   ptr++;
                }
                while(--nwords > 0)
                   *ptr++ = 0;
                *ptr &= ~rmask;

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width >> SHORTPOWER;

     } /* while */

} /* clear_image */

/************************************************************************
 *
 * This module is to implement scale image process
 *
 * TITLE:       scale_image_process
 *
 * CALL:        scale_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 * History:     MSLin created on 3/21/91
 *
 *********************************************************************/
static void near
scale_image_process(width, height, obj_proc, lfxm)
fix    width;
fix32  height;
struct object_def obj_proc;
lfix_t FAR  lfxm[];
{
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    IMAGE_INFOBLOCK     infoptr;

#ifdef  DBGX
    printf("scale_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    flush_gcb(TRUE);    /*mslin 3/29/91 for 29K*/

       r_post_x = LFX2S(lfxm[4]);
       r_post_y = LFX2S(lfxm[5]);
#ifdef DJC //The printf below acceses variables that are now undefined
#ifdef DBG1
        printf("r_post_x=%d, r_post_y=%d\n", r_post_x, r_post_y);
        printf("dst_ptr[BASE]=%lx [%lx]\n", dst_ptr, FBX_BASE);
        printf("bb_width=%d, max_bb_height=%d\n", bb_width, max_bb_height);
#endif
#endif

        infoptr.raw_width = (ufix16)width;
        infoptr.raw_height = (ufix16)height;    //@WIN
        infoptr.dev_buffer = (ufix16 FAR *)edge_table;
        infoptr.dev_buffer_size = (fix)(MAXEDGE * sizeof(struct edge_hdr)) ;
        infoptr.lfxm = lfxm;
        infoptr.ret_code = NOT_DONE;
        infoptr.obj_proc = obj_proc;
        infoptr.bits_p_smp = image_shift;
        infoptr.xorig = (fix16)r_post_x;
        infoptr.yorig = (fix16)r_post_y;
        image_PortrateLandscape(&infoptr);

      /* pop the last string in operand stack */
      POP(1);
      return;

} /* scale_image_process */
/*mslin 3/21/91 end OPT*/

/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       best_image_process
 *
 * CALL:        best_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
best_image_process(optype, width, height, shift, invert, obj_proc,
                   gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    fix         bit_count, right;
    ufix        chr_count;
    fix32       start_h, end_h;
    fix         bb_height, bb[4];
    fix32       gwb_size;                                       /* 01-26-89 */
    fix         max_bb_height;
    fix16       isp;
    struct isp_data     FAR *isp_ptr;

    fix         ys_index;                                               /*@OPT*/
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    fix         r_psav_x, r_psav_y;                                     /*@OPT*/
    lfix_t      r_pabs_x, r_pabs_y;                                     /*@OPT*/
    struct lookup huge  *xs_point;      /* @WIN 04-20-92 */


    /* decide gwb_size and whether gwb_size is enough or not */
    gwb_space(&gwb_size);                                       /* 01-26-89 */

    if ((max_bb_height = image_gwcm_space(gwb_size, (lfix_t FAR *) lfxm,
                                          width)) <= 0) {       /* 01-26-89 */
        // UPD053
        slow_clip_image_process(optype, width, height, shift, FALSE,
                                 obj_proc, gray_res,
                                 (lfix_t FAR *) lfxm);
        return;
    }

#ifdef  DBGX
    printf("best_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }


    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;

    /* initial bb_height & start_h */
    bb_height = 0;
    start_h = 1;

    r_post_x = LFX2S(lfxm[4]) + x_mins;
    r_post_y = LFX2S(lfxm[5]) + y_mins;
    r_pabs_x = I2LFX(r_post_x);
    r_pabs_y = I2LFX(r_post_y);

    isp = 0;            /* jwm, 12/26 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        r_psav_x = r_post_x;
        r_psav_y = r_post_y;

        if (itm_type == ITM_A00D)                                       /*@OPT*/
        {
            r_pabs_y+= r_padv_y;
/*          if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)*/
            if (((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y) || (y_maxs == 1)) /*
12-18-90 */
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("A- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        if (itm_type == ITM_0BC0)
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x04;
                else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);

            r_pabs_y+= r_padv_y;
            if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)
                ys_index|= 0x08;

            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }

        xs_point = x_lookup;

        for (ix=1; ix<=width; ix++) {

            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

            if (optype == IMAGE || !(sval ^ invert)) {

                if (isp >= last_isp_index) {            /* jwm, 12/26 */
/*                if ((isp = get_node()) == NULLP) [    */

                    end_h = start_h + bb_height;
                    /* calculate image bounding box */
                    band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                                  width, (fix FAR *) bb);
                    /* transfer sample list to page cache */
                    flush_seed_sample_list(optype, gray_res, (fix FAR *) bb);
                    start_h = end_h;
                    bb_height = 0;

                    isp = 0;    /* jwm, 12/26 */

/*                    if ((isp = get_node()) == NULLP) {
 *                        ERROR(LIMITCHECK);
 *                        return;
 *                    }
 */
                }

                /* calculate up_left corner's position */

                isp_ptr = &isp_table[isp];
                isp_ptr->bb_x = r_psav_x + xs_point->x;
                isp_ptr->bb_y = r_psav_y + xs_point->y;
                isp_ptr->index = ys_index + xs_point->index;
                if (optype == IMAGE) {
                    isp_ptr->next = gray_chain[sval].start_seed_sample;
                    gray_chain[sval].start_seed_sample = isp;
                } else {
                    isp_ptr->next = gray_chain[0].start_seed_sample;
                    gray_chain[0].start_seed_sample = isp;
                }

                ++isp;



/*                node_table[isp].SAMPLE_BB_LX = r_psav_x + xs_point->x;
 *                node_table[isp].SAMPLE_BB_LY = r_psav_y + xs_point->y;
 *                if (optype == IMAGE) {
 *                    node_table[isp].next =
 *                                    gray_chain[sval].start_seed_sample;
 *                    gray_chain[sval].start_seed_sample = isp;
 *                } else {
 *                    node_table[isp].next = gray_chain[0].start_seed_sample;
 *                    gray_chain[0].start_seed_sample = isp;
 *                }
 *
 *                node_table[isp].SEED_INDEX = ys_index + xs_point->index;
 */

#ifdef  DBG9
                printf("* %x,%x %x/%x\n",
                       r_psav_x + xs_point->x, r_psav_y + xs_point->y,
                       sval, ys_index + xs_point->index);
#endif
            }/* if */

            xs_point++;
        }/* for ix */

        bb_height++;
        /* check if bb_height is reached */
        if (bb_height == max_bb_height || iy == height) {

            end_h = start_h + bb_height - 1;
            /* calculate image bounding box */
            band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                          width, (fix FAR *) bb);
            /* transfer sample list to page or cache */
            flush_seed_sample_list(optype, gray_res, (fix FAR *) bb);
            start_h = end_h + 1;
            bb_height = 0;

            isp = 0;    /* jwm, 12/26 */

        }/* if max_bb_height */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of best_image_process */


/********************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       fast_clip_image_process
 *
 * CALL:        fast_clip_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
fast_clip_image_process(optype, width, height, shift, invert, obj_proc,
                        gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    fix         bit_count, right;
    ufix        chr_count;
    fix32       start_h, end_h;
    fix         bb_height, bb[4];
    fix32       cmb_size;                                       /* 01-26-89 */
    fix         max_bb_height;
    fix16       isp;    /* jwm, 12/26 */
    struct isp_data     FAR *isp_ptr;

/*    SP_IDX      isp; */

    fix         ys_index;                                               /*@OPT*/
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    fix         r_psav_x, r_psav_y;                                     /*@OPT*/
    lfix_t      r_pabs_x, r_pabs_y;                                     /*@OPT*/
    struct lookup huge *xs_point;       /* @WIN 04-20-92 */

#define ROW_NONE        0x00
#define ROW_FILL        0x01
    fix         row_flag;                                               /*@OPT*/
#define ROW_PRIO        0x00
#define ROW_CLIP        0x01
#define ROW_POST        0x02
    fix         row_type;                                               /*@OPT*/
    fix         bb_lx, bb_ux;                                           /*@OPT*/
    fix         bb_ly, bb_uy;                                           /*@OPT*/

    /* decide gwb_size and whether gwb_size is enough or not */
    cmb_space(&cmb_size);                                       /* 01-26-89 */

    if ((max_bb_height = image_gwcm_space(cmb_size, (lfix_t FAR *) lfxm,
                                          width)) <= 0) {       /* 01-26-89 */
        // UPD053
        slow_clip_image_process(optype, width, height, shift, FALSE,
                                 obj_proc, gray_res,
                                 (lfix_t FAR *) lfxm);
        return;
    }

#ifdef  DBGX
    printf("fast_clip_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif


    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }


    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;

    /* initial bb_height & start_h */
    bb_height = 0;
    start_h = 1;

    r_post_x = LFX2S(lfxm[4]) + x_mins;
    r_post_y = LFX2S(lfxm[5]) + y_mins;
    r_pabs_x = I2LFX(r_post_x);
    r_pabs_y = I2LFX(r_post_y);

    row_flag = ROW_NONE;
    row_type = ROW_PRIO;
    bb_lx = SFX2S(GSptr->clip_path.bb_lx) - 1;
    bb_ly = SFX2S(GSptr->clip_path.bb_ly) - 1;
/*  bb_ux = SFX2S(GSptr->clip_path.bb_ux) - x_maxs + 1;
    bb_uy = SFX2S(GSptr->clip_path.bb_uy) - y_maxs + 1;  */
    bb_ux = SFX2S(GSptr->clip_path.bb_ux) + 1;    /* 4-7-90 SC */
    bb_uy = SFX2S(GSptr->clip_path.bb_uy) + 1;    /* 4-7-90 SC */

#ifdef  DBG
    printf("<bbox> lx: %x  ly: %x  ux: %x  uy: %x\n",
           bb_lx, bb_ly, bb_ux, bb_uy);
    printf("%x <- %lx    %x <- %lx\n",
           r_post_x, lfxm[4], r_post_y, lfxm[5]);
#endif

    isp = 0;            /* jwm, 12/26 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        r_psav_x = r_post_x;
        r_psav_y = r_post_y;

        if (itm_type == ITM_A00D)                                       /*@OPT*/
        {
            r_pabs_y+= r_padv_y;
/*          if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)*/
            if (((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y) || (iy == height)) /* 12-17-90, Jack */
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("A- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        if (itm_type == ITM_0BC0)
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);
#ifdef  DBG8
            printf("6- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x04;
                else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);

            r_pabs_y+= r_padv_y;
            if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)
                ys_index|= 0x08;

            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }

        /* NOTE: rotated images are not processed properly */
        /* note: to process rotated images, skip clipping checking for
                 rotated images, 5-7-91, Jack */
    if ((itm_type == ITM_A00D) || (itm_type == ITM_0BC0)) { /* 5-7-91, Jack */
        if (LFX2F(r_padv_y) < 0) {      /* added by Jack, 10-16-90 */
            if (row_type == ROW_PRIO) { /* as per setting of negative y */
                if (r_psav_y <= bb_uy /* && (r_psav_s + p_slop_y) > bb_ly */ ){
#ifdef  DBG8
                    printf("- enter clipping region\n");
#endif
                    row_type = ROW_CLIP;
                }
            }
            else
            if (row_type == ROW_CLIP) {
                if (r_psav_y < bb_ly /* && (r_psav_s + p_slop_y) > bb_uy */ ) {
#ifdef  DBG8
                    printf("- leave clipping region\n");
#endif
                    row_type = ROW_POST;
                }
            }                           /* added by Jack, 10-16-90 */
        } else {
            if (row_type == ROW_PRIO) {
                if (r_psav_y >= bb_ly /* && (r_psav_s + p_slop_y) > bb_ly */) {
#ifdef  DBG8
                    printf("+ enter clipping region\n");
#endif
                    row_type = ROW_CLIP;
                }
            }
            else
            if (row_type == ROW_CLIP) {
                if (r_psav_y > bb_uy /* && (r_psav_s + p_slop_y) > bb_uy */ ) {
#ifdef  DBG8
                    printf("+ leave clipping region\n");
#endif
                    row_type = ROW_POST;
                }
            }
        }
    } else                   /* 5-7-91, Jack */
        row_type = ROW_CLIP; /* 5-7-91, Jack */

        if (row_type != ROW_CLIP) {

            for (ix=1; ix<=width; ix++) {

                if (bit_count == 8) {
                    chr_count--;
                    if (chr_count == 0) {
                        /* pop last string on operand stack */
                        POP(1);

                        if (interpreter(&obj_proc)) {
                            ERROR(STACKUNDERFLOW);
                            return;
                        }
                        /*mslin 5/02/91*/
                        CHECK_STRINGTYPE();

                        string = (ubyte FAR *) VALUE_OPERAND(0); /* 07-18-89 */
                        if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                            return;
                        }
                    }

                    /* read next string */
                    string++;                                   /* 07-18-89 */
                    bit_count = 0;
                }

                bit_count+= shift;
            }/* for ix */

        } else {

            row_flag = ROW_FILL;
            xs_point = x_lookup;

            for (ix=1; ix<=width; ix++) {

                if (bit_count == 8) {
                    chr_count--;
                    if (chr_count == 0) {
                        /* pop last string on operand stack */
                        POP(1);

                        if (interpreter(&obj_proc)) {
                            ERROR(STACKUNDERFLOW);
                            return;
                        }
                        /*mslin 5/02/91*/
                        CHECK_STRINGTYPE();

                        string = (ubyte FAR *) VALUE_OPERAND(0);
                        if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                            return;
                        }
                    }

                    /* read next string */
                    data = *string++;
                    bit_count = 0;
                }

                sval = (ubyte) ((data & mask) >> right);        //@WIN
                data = (ubyte) (data << shift);                 //@WIN
                bit_count+= shift;

                /* JUST TURN OFF UNTIL FIXED
                if (bb_ux < (r_psav_x + xs_point->x) ||
                            (r_psav_x + xs_point->x) < bb_lx)
                    continue;
                */

                if (optype == IMAGE || !(sval ^ invert)) {

                    /* create sample node */
                    if (isp >= last_isp_index) {                /* jwm, 12/26 */
/*                    if ((isp = get_node()) == NULLP) [        */

                        end_h = start_h + bb_height;
                        /* calculate image bounding box */
                        band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                                      width, (fix FAR *) bb);
                        /* transfer sample list to page cache */
                        flush_clip_sample_list(optype, gray_res,
                                                       (fix FAR *) bb);
                        start_h = end_h;
                        bb_height = 0;

                        isp = 0;        /* jwm, 12/26 */

/*                        if ((isp = get_node()) == NULLP) {
 *                            ERROR(LIMITCHECK);
 *                            return;
 *                        }
 */

                    }

                    /* calculate up_left corner's position */

                    isp_ptr = &isp_table[isp];
                    isp_ptr->bb_x = r_psav_x + xs_point->x;
                    isp_ptr->bb_y = r_psav_y + xs_point->y;
                    isp_ptr->index = ys_index + xs_point->index;
                    if (optype == IMAGE) {
                        isp_ptr->next = gray_chain[sval].start_seed_sample;
                        gray_chain[sval].start_seed_sample = isp;
                    } else {
                        isp_ptr->next = gray_chain[0].start_seed_sample;
                        gray_chain[0].start_seed_sample = isp;
                    }

                    ++isp;


/*      -jwm, 12/26
 *                    node_table[isp].SAMPLE_BB_LX = r_psav_x + xs_point->x;
 *                    node_table[isp].SAMPLE_BB_LY = r_psav_y + xs_point->y;
 *                    if (optype == IMAGE) {
 *                        node_table[isp].next =
 *                                        gray_chain[sval].start_seed_sample;
 *                        gray_chain[sval].start_seed_sample = isp;
 *                    } else {
 *                        node_table[isp].next = gray_chain[0].start_seed_sample;
 *                        gray_chain[0].start_seed_sample = isp;
 *                    }
 *
 *                    node_table[isp].SEED_INDEX = ys_index + xs_point->index;
 */

#ifdef  DBG9
                    printf("* %x,%x %x/%x\n",
                           r_psav_x + xs_point->x, r_psav_y + xs_point->y,
                           sval, ys_index + xs_point->index);
#endif
                }/* if */

                xs_point++;
            }/* for ix */

        }

        bb_height++;
        /* check if bb_height is reached */
        if (bb_height == max_bb_height || iy == height) {

            end_h = start_h + bb_height - 1;
            if (row_flag == ROW_FILL) {
                /* calculate image bounding box */
                band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                              width, (fix FAR *) bb);
                /* transfer sample list to page or cache */
                flush_clip_sample_list(optype, gray_res,
                                               (fix FAR *) bb);
                row_flag = ROW_NONE;

                isp = 0;        /* jwm, 12/26 */

            }
            start_h = end_h + 1;
            bb_height = 0;

        }/* if max_bb_height */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of fast_clip_image_process */


/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       slow_clip_image_process
 *
 * CALL:        slow_clip_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
slow_clip_image_process(optype, width, height, shift, invert, obj_proc,
                        gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    ufix        gval, pval;
    fix         bit_count, right;
    ufix        chr_count;
    lfix_t      dx_r, dy_r;
    lfix_t      dx_c, dy_c;
    lfix_t      lx[4], ly[4];
    sfix_t      sx[4], sy[4];
    struct polygon_i sample;

    fix         spix, ppix;                                     /* 03-18-89 */
    fix         no_pixels;                                      /* 03-18-89 */
    fix         grayindex;                                      /* 03-18-89 */
    fix         pixmap[256];                                    /* 03-18-89 */

#ifdef  DBGX
    printf("slow_clip_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    dx_r = lfxm[2];
    dy_r = lfxm[3];
    dx_c = lfxm[0];
    dy_c = lfxm[1];

    /* initial matrix parameter */
    lx[0] = lfxm[4];
    lx[1] = lfxm[4] + dx_r;
    ly[0] = lfxm[5];
    ly[1] = lfxm[5] + dy_r;

    /* generate pixel map from gray value */
    no_pixels = CGS_No_Pixels;                                  /* 03-18-89 */
    for (grayindex = 0; grayindex < gray_res; grayindex++) {
        pixmap[grayindex] = CGS_GrayValue(no_pixels,            /* 04-21-89 */
                                          grayindex);
    }

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;
    gval = pval = ppix = 0xFFFF;                                /* 03-18-89 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        /* initial sample's position */
        sx[0] = LFX2SFX(lx[0]);
        sx[1] = LFX2SFX(lx[1]);
        lx[2] = lx[1];
        lx[3] = lx[0];
        sy[0] = LFX2SFX(ly[0]);
        sy[1] = LFX2SFX(ly[1]);
        ly[2] = ly[1];
        ly[3] = ly[0];

#ifdef  DBG8
        printf("row: %3d [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n", iy,
               sx[0], sy[0], sx[1], sy[1], sx[2], sy[2], sx[3], sy[3]);
#endif

        for (ix=1; ix<=width; ix++) {

            lx[2]+= dx_c;
            sx[2] = LFX2SFX(lx[2]);
            lx[3]+= dx_c;
            sx[3] = LFX2SFX(lx[3]);
            ly[2]+= dy_c;
            sy[2] = LFX2SFX(ly[2]);
            ly[3]+= dy_c;
            sy[3] = LFX2SFX(ly[3]);

            /* Get endpoints of a sample cell */
            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

#ifdef  DBG8
            printf("value = %x\n", sval);
#endif

            if (optype == IMAGE || !(sval ^ invert)) {

                if (pval == 0xFFFF) goto skip; /* @SC, skip pixmap[-1] at
                                                  the following line, 5-15-90 */
                /* check if repeat pattern no changed */
                if (((ppix = pixmap[pval]) ==                   /* 03-18-89 */
                     (spix = pixmap[sval])) &&                  /* 03-18-89 */
                    (sample.p[3].x == sx[0] && sample.p[3].y == sy[0] &&
                     sample.p[2].x == sx[1] && sample.p[2].y == sy[1])) {
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                } else
                if (ppix == spix &&                             /* 03-18-89 */
                    (sample.p[1].x == sx[0] && sample.p[1].y == sy[0] &&
                     sample.p[2].x == sx[3] && sample.p[2].y == sy[3])) {
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                } else {
                    if (pval != 0xFFFF) {
#ifdef  DBG4
                        printf("pack fill gray: %f\n", gray_map[gval]);
#endif

                        if(gval != 0xFFFF)
                            setgray(F2L(gray_map[gval]));
                        fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                                /* convex_clipper just build up the edge table
                                 * and update the bounding box information, but
                                 * does not perform scan-conversion.
                                 */
                    }
skip:                                           /* @SC, 5-15-90 */
                    /* Calculate gray level of this sample */
                    if (optype == IMAGE && sval != (ubyte)gval) //@WIN
                        gval = sval;
                    pval = sval;
                    spix = ppix;                                /* 03-18-89 */

                    /* Fill this sample cell: create a sample */
                    sample.size = 4;
                    sample.p[0].x = sx[0];
                    sample.p[0].y = sy[0];
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                }

            } else {
                if (pval != 0xFFFF) {
#ifdef  DBG4
                    printf("pack fill gray: %f\n", gray_map[gval]);
#endif

                    if (gval != 0xFFFF)
                        setgray(F2L(gray_map[gval]));
                    fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                        /* convex_clipper just build up the edge table
                         * and update the bounding box information, but
                         * does not perform scan-conversion.
                         */
                    pval = spix = 0xFFFF;                       /* 03-18-89 */
                }
            }/* if */

            sx[0] = sx[3];
            sx[1] = sx[2];
            sy[0] = sy[3];
            sy[1] = sy[2];
        }/* for ix */

        bit_count = 8;

        lx[0] = lx[1];
        lx[1]+= dx_r;
        ly[0] = ly[1];
        ly[1]+= dy_r;
    }/* for iy */

    if (pval != 0xFFFF) {
#ifdef  DBG4
        printf("pack fill gray: %f\n", gray_map[gval]);
#endif

        if (gval != 0xFFFF)
            setgray(F2L(gray_map[gval]));
        fill_a_sample((struct polygon_i FAR *) &sample);       /* @#CVCF */
                /* convex_clipper just build up the edge table
                 * and update the bounding box information, but
                 * does not perform scan-conversion.
                 */
    }

    /* pop the last string in operand stack */
    POP(1);
}/* end of slow_clip_image_process */


/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       worst_image_process
 *
 * CALL:        worst_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
worst_image_process(optype, width, height, shift, invert, obj_proc, inv_matrix)
ufix    optype;
fix     width;
fix32   height;
fix     shift;
bool    invert;
struct  object_def obj_proc;
real32  FAR  inv_matrix[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    ufix        gval, pval;
    fix         bit_count, right;
    ufix        chr_count;
    real32      dx_r, dy_r;
    real32      dx_c, dy_c;
    real32      dx_o, dy_o;
    real32      fx[4], fy[4];
    sfix_t      sx[4], sy[4];
    struct polygon_i sample;

#ifdef  DBGX
    printf("worst_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    dx_r = inv_matrix[2];
    dy_r = inv_matrix[3];
    dx_c = inv_matrix[0];
    dy_c = inv_matrix[1];

    /* initial matrix parameter */
    dx_o = inv_matrix[4];
    dy_o = inv_matrix[5];

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;
    gval = pval = 0xFFFF;

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        /* initial sample's position */
        fx[0] = fx[3] = dx_o;
        fx[1] = fx[2] = dx_o + dx_r;
        fy[0] = fy[3] = dy_o;
        fy[1] = fy[2] = dy_o + dy_r;

#ifdef  DBG1
        printf("row: %3d [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n", iy,
               sx[0], sy[0], sx[1], sy[1], sx[2], sy[2], sx[3], sy[3]);
#endif

        for (ix=1; ix<=width; ix++) {

            fx[2]+= dx_c;
            fx[3]+= dx_c;
            fy[2]+= dy_c;
            fy[3]+= dy_c;

            /* Get endpoints of a sample cell */
            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

            if (optype == IMAGE || !(sval ^ invert)) {
                /* Check if coordinates out of SFX range.
                   Should be solved by page_clipper().
                        Ref. S.C. Chen  @#IMAGE 05-24-88 Y.C.
                 */
                /* fast macro for boundary crossing check
                for (index = 0; index < 4; index++) {
                    if ((x[index] < (real32)PAGE_LEFT)  ||
                        (x[index] > (real32)PAGE_RIGHT) ||
                        (y[index] < (real32)PAGE_TOP)   ||
                        (y[index] > (real32)PAGE_BTM))
                }
                */
                    if (out_page(F2L(fx[0])) || out_page(F2L(fy[0])) ||
                        out_page(F2L(fx[1])) || out_page(F2L(fy[1])) ||
                        out_page(F2L(fx[2])) || out_page(F2L(fy[2])) ||
                        out_page(F2L(fx[3])) || out_page(F2L(fy[3])))
                        goto out_of_range;

                sx[0] = F2SFX(fx[0]);
                sy[0] = F2SFX(fy[0]);
                sx[1] = F2SFX(fx[1]);
                sy[1] = F2SFX(fy[1]);
                sx[2] = F2SFX(fx[2]);
                sy[2] = F2SFX(fy[2]);
                sx[3] = F2SFX(fx[3]);
                sy[3] = F2SFX(fy[3]);

                if (pval == sval &&
                    (sample.p[3].x == sx[0] && sample.p[3].y == sy[0] &&
                     sample.p[2].x == sx[1] && sample.p[2].y == sy[1])) {
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                } else
                if (pval == sval &&
                    (sample.p[1].x == sx[0] && sample.p[1].y == sy[0] &&
                     sample.p[2].x == sx[3] && sample.p[2].y == sy[3])) {
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                } else {
                    if (pval != 0xFFFF) {
                        if(gval != 0xFFFF)
                            setgray(F2L(gray_map[gval]));
                        fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                                /* convex_clipper just build up the edge table
                                 * and update the bounding box information, but
                                 * does not perform scan-conversion.
                                 */
                    }

                    /* Calculate gray level of this sample */
                    if (optype == IMAGE && sval != (ubyte)gval) //@WIN
                        gval = sval;
                    pval = sval;

                    /* Fill this sample cell: create a sample */
                    sample.size = 4;
                    sample.p[0].x = sx[0];
                    sample.p[0].y = sy[0];
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                }

            } else {

out_of_range:
                if (pval != 0xFFFF) {
                    if (gval != 0xFFFF)
                        setgray(F2L(gray_map[gval]));
                    fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                        /* convex_clipper just build up the edge table
                         * and update the bounding box information, but
                         * does not perform scan-conversion.
                         */
                    pval = 0xFFFF;
                }
            }/* if */

            fx[0] = fx[3];
            fx[1] = fx[2];
            fy[0] = fy[3];
            fy[1] = fy[2];
        }/* for ix */

        bit_count = 8;

        dx_o+= dx_r;
        dy_o+= dy_r;
    }/* for iy */

    if (pval != 0xFFFF) {
        if (gval != 0xFFFF)
            setgray(F2L(gray_map[gval]));
        fill_a_sample((struct polygon_i FAR *) &sample);       /* @#CVCF */
                /* convex_clipper just build up the edge table
                 * and update the bounding box information, but
                 * does not perform scan-conversion.
                 */
    }

    /* pop the last string in operand stack */
    POP(1);
}/* end of worst_image_process */


/***********************************************************************
 * Do nothing, exhaust image data only
 *
 * TITLE:       exhaust_image_data
 *
 * CALL:        exhaust_image_data()
 *
 * PARAMETERS:  height   : height of image
 *              width    : width of image
 *              shift    : bits/sample
 *              tot_char : total character of image
 *              obj_proc : input procedure
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
exhaust_image_data(width, height, shift, obj_proc)
fix    width;
fix32  height;
fix    shift;
struct object_def obj_proc;
{
    fix32  iy;
    fix    ix;
    fix    bit_count;
    ufix   chr_count;

#ifdef  DBGX
    printf("exhaust_image_data......\n");
#endif

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    bit_count = 0;

    for (iy=1; iy<=height; iy++) {

#ifdef  DBG1
        printf("process row: %d\n", iy);
#endif

        for (ix=1; ix<=width; ix++) {

            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                bit_count = 0;
            }

            bit_count+= shift;
        }/* for ix */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of exhaust_image_process */


/***********************************************************************
 *
 * TITLE:       image_matrix
 *
 * CALL:        image_matrix
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
image_matrix(matrix, inv_matrix, height, width, image_bb)
real32 FAR  matrix[];
real32 FAR  inv_matrix[];
fix32       height;
fix         width;
real32 FAR  image_bb[];
{
    /*  combine image_matrix & image_boundary                      01-26-89 */

    real32 FAR *im, x[4], y[4];
    fix     index;

#ifdef  DBG1
    printf("CTM:  |%f %f %f|\n     |%f %f %f|\n",
           GSptr->ctm[0], GSptr->ctm[1], GSptr->ctm[2],
           GSptr->ctm[3], GSptr->ctm[4], GSptr->ctm[5]);
    printf("ITM': |%f %f %f|\n     |%f %f %f|\n",
           matrix[0], matrix[1], matrix[2],
           matrix[3], matrix[4], matrix[5]);
#endif

    im = inverse_mat(matrix);
    for (index = 0; index < MATRIX_LEN; index++) {
        inv_matrix[index] = im[index];
    }

    im = concat_mat(inv_matrix, GSptr->ctm);
    for (index = 0; index < MATRIX_LEN; index++) {
        inv_matrix[index] = im[index];
    }

#ifdef  DBG1
    printf("ITM:  |%f %f %f|\n     |%f %f %f|\n",
           inv_matrix[0], inv_matrix[1], inv_matrix[2],
           inv_matrix[3], inv_matrix[4], inv_matrix[5]);
#endif

    /* special adjustment of Tx & Ty of ITM  01-12-89 */
    inv_matrix[4]+= (real32) 0.0001;    /* Tx */
    inv_matrix[5]+= (real32) 0.0001;    /* Ty */

    /* calculate bounding box of image/imagemask */
    x[0] =                                                  inv_matrix[4];
    y[0] =                                                  inv_matrix[5];
    x[1] =                          width * inv_matrix[0] + inv_matrix[4];
    y[1] =                          width * inv_matrix[1] + inv_matrix[5];
    x[2] = height * inv_matrix[2] + width * inv_matrix[0] + inv_matrix[4];
    y[2] = height * inv_matrix[3] + width * inv_matrix[1] + inv_matrix[5];
    x[3] = height * inv_matrix[2]                         + inv_matrix[4];
    y[3] = height * inv_matrix[3]                         + inv_matrix[5];

    image_bb[0] = image_bb[1] = x[0];
    image_bb[2] = image_bb[3] = y[0];
    for (index = 1; index <= 3; index++) {
        if (x[index] < image_bb[0]) image_bb[0] = x[index];
        if (x[index] > image_bb[1]) image_bb[1] = x[index];
        if (y[index] < image_bb[2]) image_bb[2] = y[index];
        if (y[index] > image_bb[3]) image_bb[3] = y[index];
    }

#ifdef  DBG
    printf("image_bb: X: %d - %d    Y %d - %d\n",
           image_bb[0], image_bb[1], image_bb[2], image_bb[3]);
#endif
} /* end of image_matrix() */


/***********************************************************************
 * Given a path, this module check its clip status
 *
 * TITLE:       check_clip_status
 *
 * CALL:        check_clip_status(im_path)
 *
 * PARAMETERS:  im_path : input path to be clipped
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      clip_status:
 *                      OUT_CLIPPATH    : out of clippath
 *                      CLIP            : take place clip
 *                      INSIDE_CLIPPATH : inside clippath
 **********************************************************************/
static fix near
check_clip_status(image_bb)
real32 FAR  image_bb[];
{
    ET_IDX  itpzd;
    struct nd_hdr FAR *tpzd;
    /* @RESO_UPGR */
    sfix_t     cp_lx, cp_ly, cp_ux, cp_uy; /* bbox of clippath */
    sfix_t     im_lx, im_ly, im_ux, im_uy; /* bbox of image */

    /* decide clip status and check if out of clip path */
    im_lx = F2SFX(image_bb[0]);
    im_ux = F2SFX(image_bb[1]);
    im_ly = F2SFX(image_bb[2]);
    im_uy = F2SFX(image_bb[3]);


#ifdef  DBG2
    printf("image box: %ld %ld %ld %ld\n", im_lx, im_ux, im_ly, im_uy);
#endif

    /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of current clip */
    cp_lx = GSptr->clip_path.bb_lx;
    cp_ly = GSptr->clip_path.bb_ly;
    cp_ux = GSptr->clip_path.bb_ux;
    cp_uy = GSptr->clip_path.bb_uy;

#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %ld %ld %ld %ld\n", cp_lx, cp_ux, cp_ly, cp_uy);
#endif

    /* check if totally outside clip polygon */
    if (im_uy < cp_ly || im_ly > cp_uy ||
        im_ux < cp_lx || im_lx > cp_ux) {
#ifdef  DBG2
        printf("check_clip_status -- OUTSIDE_CLIPPATH\n");
#endif
        return(OUT_CLIPPATH);
    }

    /* Check if im_path totally inside the rectangle current clip */
    if (GSptr->clip_path.single_rect) {

        if (cp_ly < im_ly && im_uy < cp_uy &&
            cp_lx < im_lx && im_ux < cp_ux) {

#ifdef  DBG2
            printf("check_clip_status -- INSIDE_CLIPPATH\n");
#endif
            return(INSIDE_CLIPPATH);
        } else {
#ifdef  DBG2
            printf("check_clip_status -- CLIP\n");
#endif
            return(CLIP);
        }
    }

    for (itpzd = GSptr->clip_path.head; itpzd != NULLP;
         itpzd = tpzd->next) {

        tpzd = &node_table[itpzd];

        cp_ly = tpzd->CP_TOPY;
        cp_uy = tpzd->CP_BTMY;

        if (im_uy < cp_ly || im_ly > cp_uy)
            continue;

        /* check if outside a trapezoid of clip_path */
        cp_lx = (tpzd->CP_TOPXL < tpzd->CP_BTMXL)
               ? tpzd->CP_TOPXL : tpzd->CP_BTMXL;
        cp_ux = (tpzd->CP_TOPXR > tpzd->CP_BTMXR)
               ? tpzd->CP_TOPXR : tpzd->CP_BTMXR;

        if (im_ux < cp_lx || im_lx > cp_ux)
            continue;

        /* check if inside a trapezoid of clip_path */
        cp_lx = (tpzd->CP_TOPXL > tpzd->CP_BTMXL)
               ? tpzd->CP_TOPXL : tpzd->CP_BTMXL;
        cp_ux = (tpzd->CP_TOPXR < tpzd->CP_BTMXR)
               ? tpzd->CP_TOPXR : tpzd->CP_BTMXR;

        /* Check if im_path totally inside the rectangle current clip */
        if (cp_ly < im_ly && im_uy < cp_uy &&
            cp_lx < im_lx && im_ux < cp_ux) {

#ifdef  DBG2
            printf("check_clip_status -- INSIDE_CLIPPATH\n");
#endif
            return(INSIDE_CLIPPATH);
        } else {
#ifdef  DBG2
            printf("check_clip_status -- CLIP\n");
#endif
            return(CLIP);
        }
    } /* for */

#ifdef  DBG2
    printf("check_clip_status -- OUTSIDE_CLIPPATH\n");
#endif
    return(OUT_CLIPPATH);
} /* check_clip_status */


/***********************************************************************
 * Fill a sample to page or cache
 *
 * TITLE:       fill_a_sample
 *
 * CALL:        fill_a_sample()
 *
 * PARAMETERS:  sample
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       convex_clipper
 *
 * RETURN:      TRUE  : successful
 *              FALSE : node table is NULL
 *
 *********************************************************************/
static bool near
fill_a_sample(sample)                           /* @#IMAGE 04-27-88  Y.C. */
struct polygon_i FAR  *sample;
{
    sfix_t   x, y;

    /* clockwise convertion before polygon reduction */
    /* clockwise: ((x1 - x0) * (y2 - y1) - (y1 - y0) * (x2 - x1)) >= 0 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
    if ((((fix32) (sample->p[1].x - sample->p[0].x)) *
         ((fix32) (sample->p[2].y - sample->p[1].y)) -
         ((fix32) (sample->p[1].y - sample->p[0].y)) *
         ((fix32) (sample->p[2].x - sample->p[1].x))) < 0) {
#elif  FORMAT_16_16
    long dest1[2], dest2[2], tmp[2];

    LongFixsMul((sample->p[1].x - sample->p[0].x),
                (sample->p[2].y - sample->p[1].y), dest1);
    LongFixsMul((sample->p[1].y - sample->p[0].y),
                (sample->p[2].x - sample->p[1].x), dest2);
    LongFixsSub(dest1, dest2, tmp);
    if (tmp[0] < 0) {
#elif  FORMAT_28_4
    long dest1[2], dest2[2], tmp[2];

    LongFixsMul((sample->p[1].x - sample->p[0].x),
                (sample->p[2].y - sample->p[1].y), dest1);
    LongFixsMul((sample->p[1].y - sample->p[0].y),
                (sample->p[2].x - sample->p[1].x), dest2);
    LongFixsSub(dest1, dest2, tmp);
    if (tmp[0] < 0) {
#endif
        x = sample->p[1].x;
        sample->p[1].x = sample->p[3].x;
        sample->p[3].x = x;
        y = sample->p[1].y;
        sample->p[1].y = sample->p[3].y;
        sample->p[3].y = y;
    }

#ifdef  DBG4
    printf("*sample*  [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n",
           sample->p[0].x, sample->p[0].y,
           sample->p[1].x, sample->p[1].y,
           sample->p[2].x, sample->p[2].y,
           sample->p[3].x, sample->p[3].y);
#endif

    return(convex_clipper(sample, FALSE));                          /* @#CVCF */
        /* convex_clipper just build up the edge table and update the
         * bounding box information, but does not perform scan-conversion.
         */
} /* end of fill_a_sample() */

#ifdef DJC // this is the original
/***********************************************************************
 *
 * TITLE:       image_gwcm_space
 *
 * CALL:        image_gwcm_space
 *
 * RETURN:      none
 *
 *********************************************************************/
static fix near
image_gwcm_space(gwcm_size, lfxm, width)
fix32       gwcm_size;
lfix_t FAR  lfxm[];
fix         width;
{
    fix    image_width;

    if (itm_type == ITM_A00D) {

        /* adjust image width to word boundary */
        image_width = (lfxm[0] >= 0)
                    ? (BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] - HALF_LFX)) -
                       BM_ALIGN(LFX2I(lfxm[4] + HALF_LFX)))
/*                  : (BM_ALIGN(LFX2I(lfxm[4] - HALF_LFX)) -
                       BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] + HALF_LFX)));*/                    : (BM_ALIGN(LFX2I(lfxm[4])) -
                       BM_BOUND(LFX2I_T(lfxm[0] * width + lfxm[4] - HALF_LFX)));/* 12-13-90, Jack */

#ifdef  DBG1
        printf("gwbcmb: %d <- %lx & %lx\n", image_width, lfxm[0], lfxm[4]);
        printf("gwbcmb: %lx <- %d\n", gwcm_size,
               (fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));
#endif

        if (!image_width)               /* jwm, 12/11 */
            return (0);                 /* ??? -jwm */

        return((fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));

    } else {

        lfix_t  x[4], y[4];
        lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
        fix     max_bb, inc_bb;
        fix     no_row, no_col;
        fix     index;

        /* some binary search approach is applied */
        for (max_bb = inc_bb = 16; ; max_bb+= inc_bb) {

            x[1] =                    width * lfxm[0];
            y[1] =                    width * lfxm[1];
            x[2] = max_bb * lfxm[2] + width * lfxm[0];
            y[2] = max_bb * lfxm[3] + width * lfxm[1];
            x[3] = max_bb * lfxm[2];
            y[3] = max_bb * lfxm[3];

#ifdef  DBG1
            printf("%x+%x: [%lx, %lx] [%lx, %lx] [%lx, %lx]\n",
                   max_bb, inc_bb, x[1], y[1], x[2], y[2], x[3], y[3]);
#endif

            bb_lx = bb_ux = 0;
            bb_ly = bb_uy = 0;
            for (index = 1; index <= 3; index++) {
                if (x[index] < bb_lx) bb_lx = x[index];
                if (x[index] > bb_ux) bb_ux = x[index];
                if (y[index] < bb_ly) bb_ly = y[index];
                if (y[index] > bb_uy) bb_uy = y[index];
            }

            /* calculate the row and column in pixels */
            no_row = LFX2S(bb_uy + HALF_LFX) - LFX2S(bb_ly - HALF_LFX);
            no_col = BM_ALIGN(LFX2S(bb_ux + HALF_LFX) -
                              LFX2S(bb_lx - HALF_LFX)) + BM_PIXEL_WORD * 2;

#ifdef  DBG1
            printf("%x = %lx / (%x * %x)\n",
                   (fix) (gwcm_size * 8 / ((fix32) no_row * no_col)),
                   gwcm_size, no_row, no_col);
#endif

            /* check if size over space of GBW or CMB or not */
            if ((gwcm_size * 8 / ((fix32) no_row * no_col)) < max_bb) {
                max_bb-= inc_bb;
                if (inc_bb == 1) {
#ifdef  DBG1
                    printf("max_bb: %d\n", max_bb);
#endif

                    return(max_bb);
                }

                inc_bb = inc_bb / 2;
            }
        }

    }
} /* end of image_cmb_space() */

#endif


/***********************************************************************
 *
 * TITLE:       image_gwcm_space
 *
 * CALL:        image_gwcm_space
 *
 * RETURN:      none
 *
 *********************************************************************/
static fix near
image_gwcm_space(gwcm_size, lfxm, width)
fix32       gwcm_size;
lfix_t FAR  lfxm[];
fix         width;
{
    fix    image_width;

    if (itm_type == ITM_A00D) {
//DJC begin , this was broken out to solve calculation errors in original!!
        if (lfxm[0] >= 0 ) {
           fix32 temp_val;
           fix32 temp_val2;

           temp_val = lfxm[0] * width + lfxm[4] - HALF_LFX;
           temp_val = LFX2I(temp_val);
           temp_val = BM_BOUND(temp_val);

           temp_val2 = lfxm[4] + HALF_LFX;
           temp_val2 = LFX2I(temp_val2);
           temp_val2 = BM_ALIGN(temp_val2);
           temp_val -= temp_val2;
           image_width = temp_val;


        } else {
           fix32 temp_val;
           fix32 temp_val2;

           temp_val =  lfxm[4];
           temp_val =  LFX2I(temp_val);
           temp_val =  BM_ALIGN(temp_val);

           temp_val2 = lfxm[0] * width + lfxm[4] - HALF_LFX;
           temp_val2 = LFX2I_T( temp_val2);
           temp_val2 = BM_BOUND( temp_val2);

           image_width = temp_val - temp_val2;

        }
//DJC end

#ifdef DJC
        /* adjust image width to word boundary */
        image_width = (lfxm[0] >= 0)
                    ? (BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] - HALF_LFX)) -
                       BM_ALIGN(LFX2I(lfxm[4] + HALF_LFX)))
/*                  : (BM_ALIGN(LFX2I(lfxm[4] - HALF_LFX)) -
                       BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] + HALF_LFX)));*/                    : (BM_ALIGN(LFX2I(lfxm[4])) -
                       BM_BOUND(LFX2I_T(lfxm[0] * width + lfxm[4] - HALF_LFX)));/* 12-13-90, Jack */
#endif



#ifdef  DBG1
        printf("gwbcmb: %d <- %lx & %lx\n", image_width, lfxm[0], lfxm[4]);
        printf("gwbcmb: %lx <- %d\n", gwcm_size,
               (fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));
#endif

        if (!image_width)               /* jwm, 12/11 */
            return (0);                 /* ??? -jwm */

        return((fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));

    } else {

        lfix_t  x[4], y[4];
        lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
        fix     max_bb, inc_bb;
        fix     no_row, no_col;
        fix     index;

        /* some binary search approach is applied */
        for (max_bb = inc_bb = 16; ; max_bb+= inc_bb) {

            x[1] =                    width * lfxm[0];
            y[1] =                    width * lfxm[1];
            x[2] = max_bb * lfxm[2] + width * lfxm[0];
            y[2] = max_bb * lfxm[3] + width * lfxm[1];
            x[3] = max_bb * lfxm[2];
            y[3] = max_bb * lfxm[3];

#ifdef  DBG1
            printf("%x+%x: [%lx, %lx] [%lx, %lx] [%lx, %lx]\n",
                   max_bb, inc_bb, x[1], y[1], x[2], y[2], x[3], y[3]);
#endif

            bb_lx = bb_ux = 0;
            bb_ly = bb_uy = 0;
            for (index = 1; index <= 3; index++) {
                if (x[index] < bb_lx) bb_lx = x[index];
                if (x[index] > bb_ux) bb_ux = x[index];
                if (y[index] < bb_ly) bb_ly = y[index];
                if (y[index] > bb_uy) bb_uy = y[index];
            }

            /* calculate the row and column in pixels */
            no_row = LFX2S(bb_uy + HALF_LFX) - LFX2S(bb_ly - HALF_LFX);
            no_col = BM_ALIGN(LFX2S(bb_ux + HALF_LFX) -
                              LFX2S(bb_lx - HALF_LFX)) + BM_PIXEL_WORD * 2;

#ifdef  DBG1
            printf("%x = %lx / (%x * %x)\n",
                   (fix) (gwcm_size * 8 / ((fix32) no_row * no_col)),
                   gwcm_size, no_row, no_col);
#endif

            /* check if size over space of GBW or CMB or not */
            if ((gwcm_size * 8 / ((fix32) no_row * no_col)) < max_bb) {
                max_bb-= inc_bb;
                if (inc_bb == 1) {
#ifdef  DBG1
                    printf("max_bb: %d\n", max_bb);
#endif

                    return(max_bb);
                }

                inc_bb = inc_bb / 2;
            }
        }

    }
} /* end of image_cmb_space() */


















/***********************************************************************
 * Give start_h and end_h this module calculate the band's boundary(fix)
 *
 * TITLE:       band_boundary
 *
 * CALL:        band_boundary()
 *
 * PARAMETERS:  lfxm       : coordinate parameter(fix32 fix)
 *              start_h    : start height
 *              end_h      : end height
 *              width      : width of image
 *              bb         : image boundary(fix)
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       sample_boundary
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
band_boundary(lfxm, start_h, end_h, width, bb)
lfix_t FAR  lfxm[];
fix32  start_h;
fix32  end_h;
fix    width;
fix    FAR  bb[];
{
    lfix_t  x[4], y[4];
    lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
    fix     index;

#ifdef  DBG3
    printf("BAND: %ld %ld %d\n", start_h, end_h, width);
#endif

    x[0] = start_h * lfxm[2]                   + lfxm[4];
    y[0] = start_h * lfxm[3]                   + lfxm[5];
    x[1] = start_h * lfxm[2] + width * lfxm[0] + lfxm[4];
    y[1] = start_h * lfxm[3] + width * lfxm[1] + lfxm[5];
    x[2] = end_h   * lfxm[2] + width * lfxm[0] + lfxm[4];
    y[2] = end_h   * lfxm[3] + width * lfxm[1] + lfxm[5];
    x[3] = end_h   * lfxm[2]                   + lfxm[4];
    y[3] = end_h   * lfxm[3]                   + lfxm[5];

    bb_lx = bb_ux = x[0];
    bb_ly = bb_uy = y[0];
    for (index = 1; index <= 3; index++) {
        if (x[index] < bb_lx) bb_lx = x[index];
        if (x[index] > bb_ux) bb_ux = x[index];
        if (y[index] < bb_ly) bb_ly = y[index];
        if (y[index] > bb_uy) bb_uy = y[index];
    }

    bb[0] = BM_ALIGN(LFX2S(bb_lx - HALF_LFX));                  /* 01-26-89 */
    bb[1] = BM_BOUND(LFX2S(bb_ux + HALF_LFX));                  /* 01-26-89 */
    bb[2] = LFX2S(bb_ly - HALF_LFX);                            /* 01-26-89 */
    bb[3] = LFX2S(bb_uy + HALF_LFX);                            /* 01-26-89 */

} /* end of band_boundary() */


/* .................... End of image.c .................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\halftone.c ===
/*
 * Copyright (c) 1989,90,1991 Microsoft Corporation
 */
/************************************************************************
    Halftone: gray integrated version


    History:

         02/04/91       new algorithm for sethalftone and fillhtpattern
                        The interface keeps the same.
         04/08/91       change sqrt(int) to sqrt((real32)int) for library
                        compatibility

    Programmed by:      shenzhi Zhang


    C Library Functions Called:

        1. memset()
************************************************************************/


// DJC added global include
#include "psglobal.h"



#include               <stdio.h>
#include               <math.h>
#include               <string.h>
/* #include               <stdlib.h> */ /* kevina 4.13.90: removed for Sun build */

#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "halftone.h"
#include               "halftone.def"
#include               "fillproc.h"
#include               "fillproc.ext"

/* @WIN; add prototype */
static struct angle_entry far *select_best_pair(
       fix32 real_size_, fix32 alpha_angle_);
float SpotFunc(float x, float y);

static ufix32              far *repeat_pattern;     /* ufix => ufix32 @WIN*/

static fix                      cache_count;
static fix                      cache_scale;
static struct cache_entry far  *cache_point;
static gmaddr                   cache_index;
static fix                      cache_colof;
static fix                      cache_sizof;
static fix16                    cos_theta;
static fix16                    sin_theta;



static struct group_entry far  *cache_group;
static struct cache_entry far  *cache_array;
//static struct cache_entry       cache_dummy = {-1, -1, NULL,};  /* 08-05-88 */
static struct cache_entry       cache_dummy = {-1, (gmaddr)-1, NULL,}; //@WIN


/*************************************************************************

 ** InitHalfToneDat()

*************************************************************************/

void InitHalfToneDat()                                          /* 01/12/88 */
{
    /*
     * Step 1. Allocate dynamic memory buffers for HalfTone
     */

    {
        /* set default resolution as max. resolution */
        resolution       = MAX_RESOLUTION;                      /* @RES */

        cache_group      = (struct group_entry far *)
                           fardata((ufix32) MAX_GROUP
                                          * sizeof(struct group_entry));
        cache_array      = (struct cache_entry far *)
                           fardata((ufix32) MAX_ENTRY
                                          * sizeof(struct cache_entry));

        /* initialize cache address of default cache */
        cache_dummy.cache = HTP_BASE;                           /* 08-05-88 */


#ifdef  DBG1X
        printf("cache_group:      %lx\n", cache_group);
        printf("cache_array:      %lx\n", cache_array);
#endif
    }
}


/*************************************************************************

 ** spot_function()

*************************************************************************/
//float SpotFunc(x,y)           @WIN
//float x, y;
float SpotFunc(float x, float y)
{
    return((float)1.0-x*x-y*y);         //@WIN
}






/*************************************************************************

 ** select_best_pair()

*************************************************************************/

static struct angle_entry far *select_best_pair(real_size_, alpha_angle_)
fix32                   real_size_;
fix32                   alpha_angle_;
{
    real32              real_size;
    real32              alpha_angle;
    fix                 scalefact;
    fix                 patt_size;
    fix                 cell_size;
    fix32               htwa_size;                              /* @HTWA */
    real32              alpha_error;
    struct angle_entry FAR *alpha_entry;
    struct angle_entry FAR *angle_entry;
    fix                 lower_index;
    struct angle_entry FAR *lower_entry;
    fix                 upper_index;
    struct angle_entry FAR *upper_entry;

    /*  select best frequency & angle pair
     */
    real_size   = L2F(real_size_);
    alpha_angle = L2F(alpha_angle_);

    alpha_entry = (struct angle_entry FAR *) NO_BEST_FIT_CASE;

    lower_index = MIN_AT_ENTRY;
    lower_entry = &angle_table[MIN_AT_ENTRY];
    upper_index = MAX_AT_ENTRY;
    upper_entry = &angle_table[MAX_AT_ENTRY];

    for (; lower_index <= upper_index;)
    {
        real32              spec_size;
        real32              entry_error;
        real32              angle_error;
        real32              fsize_error;
        real32              angle_diff;                         /* 11-24-88 */

        if ((alpha_angle - lower_entry->alpha) >
            (upper_entry->alpha - alpha_angle)) {
            angle_entry = lower_entry;
            lower_entry++;
            lower_index++;
        } else {
            angle_entry = upper_entry;
            upper_entry--;
            upper_index--;
        }
/* Removed by phchen, 04/10/91, to fixed the bug at "apple013.b" case
 *      if ((angle_entry->alpha - alpha_angle > 10.0) ||
 *          (angle_entry->alpha - alpha_angle < -10.0)) continue; (* 10-18-90 *)
 */

        /*  adjust frequency & size properly
         */
        scalefact = (fix) ((real_size * angle_entry->scale      /* 08-15-88 */
                                      / angle_entry->sum) + 0.5);

        /*  original approach                                      04-14-89
         *  if (scalefact > (MAXCELLSIZE / angle_entry->sum))
         *      scalefact = (MAXCELLSIZE / angle_entry->sum);
         *  if (scalefact > (MAXPATTSIZE / angle_entry->sos))
         *      scalefact = (MAXPATTSIZE / angle_entry->sos);
         */

        cell_size = scalefact * angle_entry->sum;
        patt_size = scalefact * angle_entry->sos;

        if (cell_size >  MAXCELLSIZE ||                         /* 04-14-89 */
            patt_size >  MAXPATTSIZE)  continue;

        spec_size = cell_size / angle_entry->scale;

        if (spec_size >= (real32) MAXCACTSIZE)  continue;       /* 04-14-89 */

        /*  check if expanded halftone on 32-bits over some threshold
         */
        for (htwa_size = patt_size; htwa_size & HT_ALIGN_MASK;  /*@HTWA @BAC*/
             htwa_size = htwa_size << 1)  ;
        /*  original approach                                      04-14-89
         *  if ((htwa_size * patt_size) > BM_PIXEL(HTB_SIZE))   (*@HTWA @BAC*)
         *      continue;
         */
        if (htwa_size >  MAXPEXPSIZE)  continue;                /* 04-14-89 */

        /*  calculate the error from idea halftone cell           @04-14-89
         */
        angle_diff  = angle_entry->alpha - alpha_angle;         /* 11-24-88 */
        FABS(angle_diff, angle_diff);                           /* 11-24-88 */
        angle_error = (real32) (1.0 - angle_diff / 90.0);       /* 11-24-88 */
        fsize_error = (spec_size < real_size)
                      ? (real32) (spec_size / real_size)
                      : (real32) (real_size / spec_size);
        entry_error = angle_error * angle_error * fsize_error;

        /*  select it if it is in minimum error (difference)
         */
        if (alpha_entry == (struct angle_entry FAR *) NO_BEST_FIT_CASE ||
            alpha_error <= entry_error) {
            alpha_entry = angle_entry;
            alpha_error = entry_error;
        }
    }

    return(alpha_entry);
}




/*************************************************************************

 ** SetHalfToneCell()

*************************************************************************/

void SetHalfToneCell()
{
    static real64           alpha_phase;        /*@WINDLL*/
    fix16                   cell_size;
    fix16                   majorfact;
    fix16                   minorfact;
    real32                  real_size;
    real32                  real_degs;
    real32                  alpha_angle;
    fix16                   scalefact;
    fix16                   no_pixels;
    struct angle_entry     FAR *alpha_entry;
    fix16                   i,j,k,l;
    real32                  x,y;
    fix16                  huge *cValue;        /*@WIN*/
    fix16                   val;
    union four_byte         x4, y4;
    fix                     status;
    struct object_def      FAR *object;
    byte huge              *vmheap_save;                        /* 01-30-89 */
    static fix              FirsTime = TRUE;    /* ???  For Demo 9/5/87 */
    real32                     theta_angle;
    fix32                   cx,cy,tx,ty;        /*@WIN 05-07-92*/
    fix32                   bound;              /*@WIN 05-06-92*/
    fix16                   minorp, majorp;

#ifdef DBG
        printf("Entering set halftone\n");
#endif
    /*
     * Step 1. Determine the final cell_size, alpha_angle, and cell_fact,
     *          after adjustment.
     */

                        /*      compute the real size of half tone cell*/
        if ((real_size = (real32) ((real32) resolution / Frequency))
                       < (real32) 1.0)
            real_size = (real32) 1.0;

        if (real_size >= (real32) MAXCACTSIZE)
        {                    /* 04-14-89 */
            /*  adjust fraquency and angle permanently
             *  **************************************
             *  ***  CAN'T FIND OUT RULES OF V.47  ***
             *  **************************************
             */
            for (Frequency+= (float) 2.0; ; Frequency+= (float) 2.0)
            {
                if ((real_size = (real32) ((real32) resolution / Frequency))
                               <= (real32) MAXCACTSIZE)  break;
            };
        };

        /*  get nearest angle_entry form angle_table          */

        real_degs = (real32) (modf((Angle < (real32) 0.0)                                   /* 01-08-88 */
                                  ? (real32) (1.0 - (-Angle / 360.0))
                                  : (real32) (Angle / 360.0),
                                  &alpha_phase) * 360.0);
        alpha_angle = ((theta_angle = (real32) (modf((real32) (real_degs / 90.),  /* 01-08-88 */
                                                    &alpha_phase) * 90.))
                                               <= (real32) 45.)
                      ? theta_angle : (real32) (90. - theta_angle);

        /*  select best frequency & angle pair
         */

        /*  calculate all halftone screen parameters
         */
/*shenzhi */
#ifdef  DBG
        printf("realsize angle %f %f \n", real_size, alpha_angle);
#endif

		if (real_size == (real32)0)
		{
             ERROR(RANGECHECK);
             return;
		}
		
        if ((alpha_entry = select_best_pair(F2L(real_size),
                                            F2L(alpha_angle)))
            == (struct angle_entry FAR *) NO_BEST_FIT_CASE)
            {
             ERROR(LIMITCHECK);
             return;
            }

        scalefact=(fix16)((real_size*alpha_entry->scale/alpha_entry->sum)+0.5);
        if (scalefact > (MAXCELLSIZE / alpha_entry->sum))       /* 01-08-88 */
            scalefact = (MAXCELLSIZE / alpha_entry->sum);
        if (scalefact > (MAXPATTSIZE / alpha_entry->sos))       /* 01-08-88 */
            scalefact = (MAXPATTSIZE / alpha_entry->sos);
        CGS_ScaleFact =scalefact;
        CGS_Cell_Size = cell_size = scalefact*alpha_entry->sum;
        if (cell_size ==1)
            {
#ifdef   DBG
                printf("binary\n");
#endif
                goto Setscreen_Exit;
            };



        /*  -2: calculate cosine/sine and major/minor
                major/minor are pair of intergers without common divisor
         */
        if (theta_angle > (float)45.0)          //@WIN
        {
/*shenzhi */
#ifdef   DBG
        printf(">45\n");
#endif
        CGS_MinorFact = alpha_entry->minor;
        CGS_MajorFact = alpha_entry->major;
        }
        else
        {
/* shenzhi */
#ifdef  DBG
        printf("<45\n");
#endif
        CGS_MinorFact = alpha_entry->major;
        CGS_MajorFact = alpha_entry->minor;
        };
/*shenzhi major here corresponding to m */
/*      i =(fix16)((CGS_MajorFact<<11)/sqrt(alpha_entry->sos)+0.5);
        j =(fix16)((CGS_MinorFact<<11)/sqrt(alpha_entry->sos)+0.5);*/
        i =(fix16)((CGS_MajorFact<<11)/sqrt((real32)alpha_entry->sos)+0.5); /* 4-8-91, Jack */
        j =(fix16)((CGS_MinorFact<<11)/sqrt((real32)alpha_entry->sos)+0.5); /* 4-8-91, Jack */
        switch ((fix) alpha_phase)
         {
            case 0:               /* 0-90 */
                 sin_theta = i;
                 cos_theta = j;
                 break;
            case 1:               /* 0-90 */
                 sin_theta = j;
                 cos_theta = -i;
                 break;
            case 2:               /* 0-90 */
                 sin_theta = -i;
                 cos_theta = -j;
                 break;
            case 3:               /* 0-90 */
                 sin_theta = -j;
                 cos_theta = i;
                 break;
         };
        minorfact = CGS_MinorFact*scalefact;
        majorfact = CGS_MajorFact*scalefact;
#ifdef DBG
        printf("M N %d %d\n", CGS_MajorFact, CGS_MinorFact);
#endif
        CGS_Patt_Size = scalefact*alpha_entry->sos;
        minorp =minorfact*minorfact;
        majorp =majorfact*majorfact;
        CGS_No_Pixels = no_pixels = majorp+minorp;
/* shenzhi    */
#ifdef DBG
        printf("COS SIN %d %d \n", cos_theta,sin_theta);
#endif
    /*
     *  Step 2. Allocate structures: spot_index_array & spot_value_array
     *          from VMHEAP.
     */

        vmheap_save = vmheap;


//DJC,fix bug from HIST if ((cValue = (fix16 huge *)alloc_heap(sizeof(fix16)*cell_size*cell_size))
        if ((cValue = (fix16 far *)alloc_heap(
            sizeof(fix16)*(cell_size*cell_size+1)))  // add 1 for init of qsort; @WIN
            == NIL) {                   /* 04-20-92 @WIN */
#ifdef DBG
            printf("no mem\n");
#endif
            goto Setscreen_Exit;
        };


    /*
     *  Step 3. Evaluate spot value for each pixel in halftone cell
     */
        CGS_HT_Binary = FALSE;
        CGS_BG_Pixels = 0;
        CGS_FG_Pixels = 0;
        if (CGS_AllocFlag == TRUE)
           {
                if ((CGS_SpotIndex +no_pixels) > MAXSPOT)
                  {
                        ERROR(LIMITCHECK);
                        goto Setscreen_Exit;
                  }
           }
        else
           {
                if ((CGS_SpotIndex +no_pixels) > MAXSPOT)
                  {
                        ERROR(LIMITCHECK);
                        goto Setscreen_Exit;
                  };
                CGS_SpotIndex = CGS_SpotUsage;
                CGS_AllocFlag = TRUE;
           };
        CGS_SpotUsage = CGS_SpotIndex + no_pixels;
        k = 0;   /* index of spot*/
        bound = (fix32)(sqrt((real32)alpha_entry->sos) *
                       ((fix32)scalefact<<11))/2;       /*@WIN 05-06-92*/
        cx =cy=(1-cell_size);
        cx = cx*(cos_theta + sin_theta)/2;
        cy = cy*(cos_theta - sin_theta)/2;
        for (l=0; l< no_pixels;l++)
           {
                    if (l<minorp)
                      { i = l/minorfact;
                        j = l%minorfact;
                      }
                    else
                      {
                        i = (l-minorp)/majorfact;
                        j = (l-minorp)%majorfact+minorfact;
                      };
                    tx = (fix32)i*sin_theta+(fix32)j*cos_theta+cx; /*@WIN*/
                    ty = (fix32)i*cos_theta-(fix32)j*sin_theta+cy; /*@WIN*/
                    if (tx< -bound )
                         x = (real32)(tx +2*bound)/bound;
                         else if (tx > bound)   /* shenzhi 4-17-91 */
                             x = (real32)(tx - 2 * bound) / bound; /* shenzhi 4-17-91 */
                    else
                         x = (real32)tx/bound;
                    if (ty< -bound )
                         y = (real32)(ty +2*bound)/bound;
                         else if (ty > bound)   /* shenzhi 4-17-91 */
                             y = (real32)(ty - 2 * bound) / bound; /* shenzhi 4-17-91 */
                    else
                         y = (real32)ty/bound;
#ifdef  DBG
                    if ((x>1.0) || (x<-1.0) || (y>1.0) || (y < -1.0))
                        printf("l,i,j,x,y %d %d %d %f %f\n",l,i,j,x,y);
#endif
                    if (FirsTime)
                        val = cValue[k++] = (fix16)(SpotFunc(x,y)*500);
                    else
                       {
                               /*       check if operand stack no available space
                                */
                        if(FRCOUNT() < 2)
                             {
                                ERROR(STACKOVERFLOW);
                                goto Setscreen_Exit;
                             };

                /*  push x & y coordinates as parameters of spot function
                 */
                        x4.ff = x;
                        y4.ff = y;
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);


                /*  call interpreter to execute spot function
                 */
                        if ((status = interpreter(&GSptr->halftone_screen.proc)))
                            {
                              if (ANY_ERROR() == INVALIDEXIT)
                              CLEAR_ERROR();
                              goto Setscreen_Exit;
                            };

                /*  extract spot value from operand stack
                 *    first,  check if any result in operand stack
                 *    second, check if type of result is numeric
                 *    third,  check if spot value in corrent range
                 */
                        if (COUNT() < 1)
                            {
                             ERROR(STACKUNDERFLOW);
                             goto Setscreen_Exit;
                            };

                        object = GET_OPERAND(0);

                        if ((TYPE(object) != INTEGERTYPE) &&
                                (TYPE(object) != REALTYPE))
                            {
                             ERROR(TYPECHECK);
                             goto Setscreen_Exit;
                            };

                        y4.ll = (fix32)VALUE(object);
                        if (TYPE(object) != INTEGERTYPE)
                           val = cValue[k++] = (fix16)(y4.ff*500);
                        else
                           val = cValue[k++] = (fix16)(y4.ll*500);       /* 12-30-87 +0.5 */
                        POP(1);

                        if ((val < -505) || ( 505 <val))
                            {
                                ERROR(RANGECHECK);
                                goto Setscreen_Exit;
                            };
                       };

           };
        val = 0;
        for (i = 0; i< no_pixels;i++)
                 CGS_SpotOrder[i] = i;

        cValue[no_pixels] = 0x7FFF;  // init as a max value for quick sort; @WIN

/* quick sort */
        {
        fix                         p, q, c;
        fix                         i, j, v;
        struct spot_stack FAR      *point;                      /*@WINDLL*/
        struct spot_stack           stack[MAX_SPOT_STACK];
        fix16                       spot_value;

         if (CGS_HT_Binary != TRUE)                             /* 02-03-88 */
          {
            /*  QUICKSORT algorithm: please refer to any textbook in hand
             */

            for (point = (struct spot_stack FAR *) stack,       /*@WINDLL*/
                 p = 0, q = no_pixels - 1, c = 0; ; c++)
              {
                while (p < q)
                {
                    i = p;
                    j = q + 1;
                    v = cValue[i];
                    for (; ; )
                    {
                        for (i++; v > cValue[i]; i++);
                        for (j--; v < cValue[j]; j--);
                        if (i < j)
                        {
                            spot_value = cValue[i];
                            cValue[i] = cValue[j];
                            cValue[j] = spot_value;
                            spot_value = CGS_SpotOrder[i];
                            CGS_SpotOrder[i] = CGS_SpotOrder[j];
                            CGS_SpotOrder[j] = spot_value;

                        }
                        else  break;
                    }
                    spot_value = cValue[p];
                    cValue[p] = cValue[j];
                    cValue[j] = spot_value;
                    spot_value = CGS_SpotOrder[p];
                    CGS_SpotOrder[p] = CGS_SpotOrder[j];
                    CGS_SpotOrder[j] = spot_value;
                    point->p = j + 1;
                    point->q = (fix16)q;
                    point++;
                    q = j - 1;
                }
                if (point == (struct spot_stack FAR *) stack)   /*@WINDLL*/
                    break;  point--;
                p = point->p;
                q = point->q;
              }
          };
        };   /* quick sort */
        for (i=0; i< no_pixels; i++)
          cValue[i] = CGS_SpotOrder[i];
        for (i=0; i< no_pixels; i++)
          CGS_SpotOrder[cValue[i]] = i;

        CGS_No_Whites = -1;

        /*  keep all halftone screen parameters in graphics stack
         */

Setscreen_Exit:

    {
		if (vmheap_save)
		{
        	free_heap(vmheap_save);         /* @VMHEAP: 01-31-89 */ /* 03-30-89 */
		}
        FirsTime = FALSE;                      /*   ??? For Demo 9/5/87 */
    }
}


/*************************************************************************

 ** FillHalfTonePat()

*************************************************************************/

fix  FromGrayToPixel(no_pixels, grayindex)                      /* 01-25-90 */
fix                     no_pixels;
fix                     grayindex;
{
    fix                 no_levels;
    fix                 graylevel;
    fix                 scale_unit;
    fix                 compensate;
    fix                 split_zone;

    if (grayindex >= (GrayScale - CGS_GrayRound))
        return(no_pixels);

    no_levels = (no_pixels <= MAXGRAYVALUE) ? no_pixels : MAXGRAYVALUE;
    graylevel = (fix)CGS_GrayLevel;     //@WIN

    scale_unit = GrayScale / no_levels;
    compensate = GrayScale - (scale_unit * no_levels);
    split_zone = scale_unit * (no_levels / 2) + compensate;

#ifdef  DBG1
    printf("I: %x%s    U: %d     C: %d     Z: %d    P: %d    L: %d\n",
           grayindex, (graylevel > split_zone) ? "*" : " ", scale_unit,
           compensate, split_zone, no_pixels, no_levels);
#endif

    if (graylevel > split_zone)
        graylevel-= compensate;

    return((fix) ((((fix32) (graylevel + CGS_GrayRound)) / scale_unit)
                  * no_pixels / no_levels));
}





/************************************************************************

 ** FillHalfTonePat()  - updated for greyscale by Jack Liaw 5/31/90

 ************************************************************************/

#ifdef  bSwap                                   /*@WIN 05-11-92*/
static ufix32 ShifterMask [32]
=
{
  0x00000080, 0x00000040, 0x00000020, 0x00000010,
  0x00000008, 0x00000004, 0x00000002, 0x00000001,
  0x00008000, 0x00004000, 0x00002000, 0x00001000,
  0x00000800, 0x00000400, 0x00000200, 0x00000100,
  0x00800000, 0x00400000, 0x00200000, 0x00100000,
  0x00080000, 0x00040000, 0x00020000, 0x00010000,
  0x80000000, 0x40000000, 0x20000000, 0x10000000,
  0x08000000, 0x04000000, 0x02000000, 0x01000000
};
#define SHIFTER(x)      ShifterMask[x&0x1f]
#else
#define SHIFTER(x)      (1L<<(31 - (x & 0x1f)))
#endif

void FillHalfTonePat()
{
    fix16    majorfact, minorfact, scalefact;
    fix16    patt_size, cell_size, no_pixels, no_whites;
    struct cache_entry  FAR *cache_entry;
    fix            grayindex;
    struct group_entry  FAR *group;
    struct cache_entry  FAR *cache;
    ufix32     patterns[MAXPATTSIZE*MAXPATTWORD];    /* ufix => ufix32 @WIN */
    fix   fill_type,ox,oy;
    fix16 i,j,k;
    fix16 x,y,ytemp,m;
    fix16 cPattern=0;


    /*  extract all halftone screen parameters in graphics stack */
        scalefact = CGS_ScaleFact;
        majorfact = CGS_MajorFact*scalefact;
        minorfact = CGS_MinorFact*scalefact;
        patt_size = CGS_Patt_Size;
        cell_size = CGS_Cell_Size;
        no_pixels = CGS_No_Pixels;
        /* shenzhi*/
/*      printf("PATT CELL %d %d \n", patt_size, cell_size);  */
    /*
     *  Step 2. Determine the number of white pixels
     */
        grayindex = CGS_GrayIndex;
        no_whites = (fix16)CGS_GrayValue(no_pixels, grayindex);
/* shenzhi
        printf("W P %d %d \n",no_whites,no_pixels);
*/
        /*  do nothing when halftone pattern unchanged */
        if (no_whites == CGS_No_Whites)
             return;
        /*  check if halftone pattern cache flushed or not
         *  halftone pattern cache flushed while screen changed *)
         *  or graydevice changed 06-11-90 */

        if (CGS_No_Whites == -1)
        {
            fix                 index;
            struct group_entry  FAR *group;

            /* flush cache and calculate corresponding parameters */
            for (group = cache_group, index = 0; index < MAX_GROUP;
                 group++, index++)
                 group->first = NULL;


            cache_index = htc_base;
            cache_colof = BM_WORDS(patt_size);
            cache_sizof = BM_BYTES(patt_size) * patt_size;
            cache_count = (fix) (htc_size / cache_sizof);
            if (cache_count > MAX_ENTRY)
                cache_count = MAX_ENTRY;
            cache_scale = no_pixels / MAX_GROUP + 1;
            cache_point = cache_array;

        }
        /*  update number of white pixel and determine type of pattern */

        CGS_No_Whites = no_whites;                              /* 03-09-88 */
        fill_type = (no_whites == no_pixels)
                ? HT_WHITE : (no_whites > 0)
                        ? HT_MIXED : HT_BLACK;
        /*  search against cache by number of white pixel */
        group = &cache_group[no_whites / cache_scale];
        cache = group->first;
        for (; cache != NULL; cache = cache->next)
                {
                    if (no_whites == cache->white)
                        {
                           repeat_pattern = NULL;
                           cache_entry = cache;
                           goto Reset_HalfTone;
                        }
                }
        if (cache_count >= 1)
            {
                if (group->first != NULL)
                   group->last->next = cache_point;
                else
                   group->first = cache_point;
                group->last = cache_point;
                cache_entry = cache_point;
                cache_entry->cache = cache_index;
                cache_entry->next       = NULL;
                cache_index+= cache_sizof;
                cache_point++;
                cache_count--;
            }
        else
            cache_entry = &cache_dummy;
        cache_entry->white = no_whites;



    /*
     *  Step 4. Generate the actual halftone repeat pattern
     */


        /*  clear repeat pattern to white
         */
        repeat_pattern = (ufix32 far *) patterns;   /*@BAC ufix => ufix32 @WIN*/
        lmemset((fix8 FAR *) repeat_pattern, (int)BM_WHITE, cache_sizof); /*@WIN*/
/*      ox=oy = 0; * need to align ox, 4-12-91, Jack */
        oy = 0;                                 /* alignment, 4-12-91 */
        ox = (majorfact == 0 || minorfact == 0) /* alignment, 4-12-91 */
             ? 0 : (patt_size - minorfact);     /* alignment, 4-12-91 */
        for (k = 0; k <patt_size/scalefact; k++)
        {
          y = (fix16)oy;
          m=0;
          for (i=0; i< minorfact; i++)
            {
              x = (fix16)ox;
              ytemp =y*cache_colof;
              for (j=0; j< minorfact; j++)
                {
                 if (CGS_SpotOrder[m++] >= (ufix16)no_whites)   //@WIN
                    repeat_pattern[ytemp+(x>>5)] |= SHIFTER(x); /*@WIN*/
                 x+=1;
                 if (x==patt_size)
                    x=0;
                };
              y +=1;
              if (y==patt_size)
                y=0;
            };
         m = minorfact*minorfact;
         y = (fix16)oy;
         for (i=0; i< majorfact; i++)
            {
              ytemp = y*cache_colof;
              x = (ox+minorfact)%patt_size;
              for (j=0; j< majorfact; j++)
                {
                 if (CGS_SpotOrder[m++] >= (ufix16)no_whites)   //@WIN
                    repeat_pattern[ytemp+(x>>5)] |= SHIFTER(x); /*@WIN*/
                 x+=1;
                 if (x==patt_size)
                    x=0;
                };
              y +=1;
              if (y==patt_size)
                 y=0;
            };
          ox +=minorfact;
          if (ox >=patt_size)
             ox -=patt_size;
          oy +=majorfact;
          if (oy >= patt_size)
             oy -=patt_size;
        };

/*
        for(i=0;i<cPattern;i++)
                printf(" val %d \n",repeat_pattern[i]);
*/
    /*
     *  Step 5. Reset halftone repeat pattern
     */
Reset_HalfTone:
    {
        change_halftone((ufix32 far *) repeat_pattern, cache_entry->cache, /* ufix => ufix32 @WIN */
                        fill_type, patt_size, patt_size);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\halftone.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
        Modification history: Please refer to HALFTONE.C

        01-16-89        modify conversion of grayvalue to pixels; compensate
                        all calculation errors and adjust rounding method
        02-01-89        add new type of pixel DONE_INDEX
        04-21-89        approaching compatibility of gray to V 47.
        07-26-90        Jack Liaw, update for grayscale
*/


/*      Function Declaration Section                                    */


#define MAXREALSIZE      256                                    /* 04-07-88 */


#define MAXPATTWORD   (BM_WORDS(MAXPATTSIZE))                                   /* 11-24-88 */
#define MAXCELLWORD   (BM_WORDS(MAXCELLSIZE))                                   /* 11-24-88 */

#define NO_BEST_FIT_CASE  -1L


/*      CGS Group : Current Graphics State Macros                       */


#define Frequency      (GSptr->halftone_screen.freq)
#define Angle          (GSptr->halftone_screen.angle)

#define GrayScale      (GRAYSCALE)                                              /* 11-24-88 */
#define GrayEntry      (GRAYSCALE / MAXGRAYVALUE)               /* 04-21-89 */

#define CGS_GrayColor  (GSptr->color.gray)                      /* 02-03-88 */
#define CGS_GrayIndex  ((fix16) (GSptr->color.gray * GRAYUNIT + 0.001)) /* 11-24-88 */

/*  old gray to white pixels transformation                     (* 04-21-89 *)
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex] + 1))
#define CGS_GrayRound  (GrayScale / 18)                         (* 01-16-89 *)
#define CGS_GrayValue(no_pixels, grayindex)                                    \
                       ((fix) ((no_pixels * CGS_GrayLevel + CGS_GrayRound)     \
                               / (fix32) GrayScale))
*/

/*  new gray to white pixels transformation                     (* 04-21-89 *)
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex] + 1))
#define CGS_GrayRound  (GrayScale / MAXGRAYVALUE / 2)           (* 04-21-89 *)
#define CGS_GrayValue(no_pixels, grayindex)                     (* 04-21-89 *) \
                       ((fix) (no_pixels >= MAXGRAYVALUE)                      \
                              ? (((CGS_GrayLevel + CGS_GrayRound) / GrayEntry) \
                                 * no_pixels / MAXGRAYVALUE)                   \
                              : (((CGS_GrayLevel + CGS_GrayRound))             \
                                 * no_pixels / GrayScale))
*/

/*  new gray to white pixels transformation  */                 /* 01-25-90 */
#ifdef  LINT_ARGS
fix     FromGrayToPixel(fix, fix);
#else
fix     FromGrayToPixel();
#endif
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex]))
#define CGS_GrayRound  (GrayScale / MAXGRAYVALUE / 2)           /* 01-25-90 */
#define CGS_GrayValue(no_pixels, grayindex)                     /* 01-25-90 */ \
        (fix) FromGrayToPixel((fix) no_pixels, (fix) grayindex)

#define CGS_AllocFlag  (GSptr->halftone_screen.chg_flag)        /* change/allocation flag       */
#define CGS_MajorFact  (GSptr->halftone_screen.majorfact)       /* major factor of halftone     */
#define CGS_MinorFact  (GSptr->halftone_screen.minorfact)       /* major factor of halftone     */
#define CGS_Size_Fact  (GSptr->halftone_screen.size_fact)       /* size factor of halftone      */
#define CGS_Cell_Fact  (GSptr->halftone_screen.cell_fact)       /* cell factor of halftone      */
#define CGS_ScaleFact  (GSptr->halftone_screen.scalefact)       /* scale factor of halftone     */
#define CGS_Patt_Size  (GSptr->halftone_screen.patt_size)       /* size of repeat pattern       */
#define CGS_Cell_Size  (GSptr->halftone_screen.cell_size)       /* size of halftone cell        */
#define CGS_No_Pixels  (GSptr->halftone_screen.no_pixels)       /* number of halftone pixels    */
#define CGS_SpotIndex  (GSptr->halftone_screen.spotindex)       /* spot order index             */
#define CGS_SpotOrder  (&spot_table[CGS_SpotIndex])             /* spot order entry             */
#define CGS_SpotUsage  (spot_usage)                             /* spot order usage             */

#define BinaryInitial  ((fix16) 0x8000)                         /* 09-12-88 */
#define CGS_HT_Binary  (GSptr->halftone_screen.ht_binary)       /* 02-03-88  for binary pattern */
#define CGS_BG_Pixels  (GSptr->halftone_screen.bg_pixels)       /* 02-03-88  for binary pattern */
#define CGS_Back_Gray  (GSptr->halftone_screen.back_gray)       /* 02-03-88  for binary pattern */
#define CGS_FG_Pixels  (GSptr->halftone_screen.fg_pixels)       /* 02-03-88  for binary pattern */
#define CGS_Fore_Gray  (GSptr->halftone_screen.fore_gray)       /* 02-03-88  for binary pattern */
#define CGS_No_Whites  (GSptr->halftone_screen.no_whites)       /* 02-03-88  for binary pattern */


#define CORD_SCALE     (1 << 10)                /* scale factor of coordinate   */
#define SPOT_SCALE     (1 << 14)                /* scale factor of spot value   */
#define SPOT_RANGE    ((1 << 14) * 2)           /* range factor of spot value   */
#define SPOT_ERROR     (1 <<  4)                /* error factor of spot value   */

#define LOWERBOUND     (-SPOT_SCALE+4)          /* lowerbound of cellspace 10-21-87 */
#define UPPERBOUND     ( SPOT_SCALE-4)          /* upperbound of cellspace 10-21-87 */

#define EPSILON        (   4)                   /* epsilon for cell range  10-30-87 */

#define LOWERRANGE     (-SPOT_SCALE-EPSILON)    /* lowerlimit of spotvalue 10-30-87 */
#define UPPERRANGE     ( SPOT_SCALE+EPSILON)    /* upperlimit of spotvalue 10-30-87 */


struct  angle_entry
{
    real32              alpha;          /* alpha angle                  */
    real32              cos;            /* cos(alpha)                   */
    real32              sin;            /* sin(alpha)                   */
    fix16               major;          /* major side                   */
    fix16               minor;          /* minor side                   */
    fix16               sum;            /* sum of major and minor       */
    fix16               sos;            /* sum of square                */
    real32              scale;          /* scaling factor               */
};


#define SELF_INDEX     (MAXCELLSIZE+1)
#define DONE_INDEX     (MAXCELLSIZE+2)
#define LINK_INDEX     (MAXCELLSIZE+3)


struct  spot_index
{
    ufix8               si_row;
    ufix8               si_col;
    fix16               sv_row;
    fix16               sv_col;
};


#define MAX_SPOT_STACK    64                                    /* 02-10-88 */

struct  spot_stack                                              /* 02-10-88 */
{
    fix16               p, q;
};


#define MAX_SPOT_VALUE  0x7FFF                                  /* 02-10-88 */

struct  spot_value
{
    fix16               value;
    ufix8               sv_row;
    ufix8               sv_col;
};


#define MAX_GROUP                 64
#define MAX_ENTRY                256

struct  group_entry
{
    struct cache_entry FAR *first;
    struct cache_entry FAR *last;
};

struct  cache_entry
{
    fix16               white;
    gmaddr              cache;
    struct cache_entry FAR *next;
};

/* greyscale - by Jack Liaw 7-26-90 */

#define WORD_LENGTH (sizeof(ufix) * 8)   /* # of bits per word */
#define MAX_BPP  4                       /* max. # of bits per pixel */
#define RIGH_SHIFT(D, S) ((D) >> (S))
#define LEFT_SHIFT(D, S) ((D) << (S))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\image.h ===
/* ---------------------------------------------------------------
 * File: image.h
 * Created by: MIn-Shyong Lin
 * Date: 1/13/91
 * Used by: image.c and scaling.c
 *
 * ---------------------------------------------------------------
 */

/*
 * image_dev_flag =
 *                  FALSE
 *                  PORTRATE
 *                  LANDSCAPE
 * image_logic_op =
 *                  00000001 -- IMAGE_BIT
 *                  00000010 -- IMAGEMASK_FALSE_BIT
 *                  00000100 -- IMAGE_CLIP_BIT
 */
#define F2SHORT(f)      ((sfix_t)((f) + 0.5))
#define PORTRATE        1
#define LANDSCAPE       5
#define ROTATE_LEFT     0x0800
#define ROTATE_RIGHT    0x0400
#define NOT_IMAGEMASK   2
#define IMAGE_BIT               0x1
#define IMAGEMASK_FALSE_BIT     0x2
#define IMAGE_CLIP_BIT          0x8

/* constant defined for image processing */
#define  DONE           0x8000
#define  NOT_DONE       0x0000
#define  NO_DATA        0x4000


/*
 *IGS Registers
 */
#define         IGS_DWIDTH      0x4C0030
#define         IGS_BMADR       0x4C0002
#define         IGS_BMDATA      0x4C0006
#define         IGS_AUTOINC     0x4C0008
#define         IGS_XLDSB       0x4C000E
#define         IGS_ALU         0x4C002A
#define         IGS_BITOFFSET   0x3800000


/*
 * IGS logic constant
 */
#define         LOG_OR          0x0E             /* Logical OR */
#define         LOG_NAND        0x02             /* (A*)B */
#define         LOG_AND         0x0B             /* 0 */
/* #define              FC_CLEAR        0x02     fillproc.h defined as white */

/*
 * IGS rotation constant
 */
#define         ROT_LEFT        0x800            /* rotate left */
#define         ROT_RIGHT       0x400            /* rotate right */
#define         ROT_DOWN        0xC00            /* upside down */

/*mslin 5/02/91 for image*/
#define CHECK_STRINGTYPE() {                    \
        if(TYPE(GET_OPERAND(0)) != STRINGTYPE){ \
            ERROR(TYPECHECK);                   \
            return;                             \
        }                                       \
}

/*
 * image information block
 */
 typedef struct {
    ufix16       ret_code;       /* return code of this module
                                  * 0x8000 -- complete image process
                                  * 0x0000 -- not yet completed but
                                  *           buffer full
                                  * others -- Error defined by language
                                  */
    ufix16       FAR *dev_buffer;/* device resolution image buffer */
    fix          dev_buffer_size;/* number of byte in dev_buffer[] */
    ufix16       dev_width;      /* pixel width of device resolution image */
    ufix16       dev_height;      /* pixel height of device resolution image */
    ufix16       band_height;     /* height return in dev_buffer*/
    ufix16       raw_width;      /* pixel width of raw image data */
    ufix16       raw_height;      /* pixel height of raw image data */
    fix16        flag;           /* indicate type of data in dev_buffer[]
                                  * 0: image source data
                                  * 1: device resolution data
                                  */
    fix16        bits_p_smp;     /* bits per samp */
    ufix16       FAR *divr;      /* pointer to array of row scaling info,
                                  * return when Amplify
                                  */
    ufix16       FAR *divc;      /* pointer to array of column scaling info,
                                  * return when Amplify
                                  */
    lfix_t       FAR *lfxm;      /* matrix in long fix format */
    struct object_def obj_proc; /* object to get string from interpreter */
    ufix16      logic;           /* logic and rotation for IGS */
    fix16       xorig;           /* x coord. in left upper cornor */
    fix16       yorig;           /* y coord. in left upper cornor */

 } IMAGE_INFOBLOCK;

/*
 * functions declaration
 */
void image_PortrateLandscape(IMAGE_INFOBLOCK FAR *);    /* @WIN */
void    amplify_image_page();      /*amplify image by IGS*/
void    set_IGS();                 /*defined in charblt.s */
void    restore_IGS();             /*defined in charblt.s */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\path.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *      Name:       path.c
 *      Developer:  S.C.Chen
 *      History:
 *      Version     Date        Comments
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/11/88     @EHS_JOIN: enhance linejoin by
 *                              pre-calculating miter limit
 *                  4/14/88     @END_DASH: revise endpoint drawing
 *                              of dash line
 *                  4/22/88     @EHS_ROUND: enhance round_join and
 *                              round_cap
 *                  4/28/88     @DOT_PRO: put calculation of dot product
 *                              in linejoin routine
 *                  5/19/88     perform scan-conversion for each dash
 *                              line segment
 *                  5/27/88     @CNTCLK: strokepath in countclockwise
 *                              direction
 *                  6/7/88      delete @DFR_SCAN; not defer performing
 *                              scan_conversion
 *                  6/16/88     @STKDIR: update the direction of the
 *                              outline of stroke/strokepath in clock-
 *                              wise direction
 *                  6/17/88     @DASH: revise drawing of dash pattern:
 *                              1. Correct initial dpat_on flag
 *                              2. Don't skip pattern of zero length
 *                  6/17/88     @CIR_FLAT: use current flatness to
 *                              approximate the circle of linejoin/cap
 *                              instead of refined flatness(stroke_flat)
 *                  6/22/88     @BIG_CIR: not flatten the circle of the
 *                              linejoin/cap if the linewidth is too
 *                              large
 *                  7/19/88     update data types:
 *                              1) F2LONG ==> F2LFX
 *                                 LONG2F ==> LFX2F
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           lfix_t, for long fixed real
 *                                           long32, for parameter
 *                              6) add compiling option: LINT_ARGS
 *                  7/20/88     @ALIGN_W: word alignment of bounding box
 *      3.0         8/13/88     @SCAN_EHS: scan conversion enhancement
 *                  8/18/88     @OUT_PAGE: enhancement of out_page checking
 *                  8/20/88     @TOUR: linetour enhancement, calculating in
 *                              device space
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and re-calculate those
 *                              values only they have been changed instead of
 *                              each op_stroke command
 *      3.0         9/10/88     @STK_INT: stroke enhancement for stroking under
 *                              interger operations
 *                              1)Add structures of integer version:
 *                                struct line_seg_i, stroke_ctm, inverse_ctm_i
 *                              2)Update stk_info
 *                              3)Add routines of integer version:
 *                                path_to_outline_i, linetour_i, linecap_i,
 *                                linejoin_i, get_rect_points_i, paint_or_save_i
 *                                round_point_i
 *      3.0         10/5/88     seperate stroke related routines from this file
 *                              to stroke.c
 *                  10/20/88    update calling sequence: fix far copy_subpath()
 *                              => void far copy_subpath()
 *                  10/24/88    get_path(): move code of assigning ret_list to
 *                              the end for skipping LIMITCHECK
 *                  10/27/88    change routine check_infinity() to
 *                              macro CHECK_INFINITY()
 *                  10/27/88    update dump_subpath: check infinity coordinates
 *                              before calling fast_inv_transform
 *                  11/18/88    set_inverse_ctm(): move setting of inverse_ctm_i
 *                              to init_stroke() for preventing floating point
 *                              exception.
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/25/88    @STK_CHK: check if operand stack no free space
 *                  11/30/88    @ET: delete get_edge(), free_edge()
 *                  12/14/88    arc(): update error torlance 1e-4 => 1e-3
 *                  12/20/88    @SFX_BZR: provides a SFX version of
 *                              bezier interpolation: bezier_to_line_sfx()
 *                  01/31/89    move arc_to_bezier() declaration to GRAPHICS.EXT
 *                  11/8/89     fix reverse_subpath() bug: for subpath contains
 *                              only one moveto node; tail pointer undefined
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  2/20/90     fix @NODE bug in reverse_subpath()
 *                  12/4/90     @CPPH: free_path(): needs to free cp_path when
 *                              clipping trapezoids has freed from clip_path.
 *                  1/7/91      change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *                  3/20/91     refine the tolerance check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* **************** static variables *************** */

/* local variables for bezier curve approximation
 * used by "bezier_to_line" and "bezier_split"
 */
static  fix near bezier_depth;                  /* recursive depth */
static  real32 near bezier_x, near bezier_y;     /* reference point */
static  lfix_t near bezier_flatness;              /* flatness */

/* *************** Macro definition *************** */
#define DIV2(a)         ((a) >> 1)

/* property of CTM */
#define NORMAL_CTM      1
#define LEFT_HAND_CTM   2


/* ********** static function declartion ********** */

#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static void near bezier_split(VX_IDX, lfix_t, lfix_t, lfix_t, lfix_t, lfix_t,
              lfix_t, lfix_t, lfix_t);
static void near bezier_split_sfx(VX_IDX, lfix_t, lfix_t, lfix_t, lfix_t, lfix_t,
              lfix_t, lfix_t, lfix_t);          /* @SFX_BZR */
static void far copy_subpath (VX_IDX, struct sp_lst *);
static struct coord * near fast_inv_transform(long32, long32);  /* @INV_CTM */

#else

/* for no type checks of the parameters in function declarations */
static void near bezier_split();
static void near bezier_split_sfx();          /* @SFX_BZR */
static void far copy_subpath ();
static struct coord * near fast_inv_transform();

#endif

/***********************************************************************
 * This module creates a path contains some Bezier curves, each curve
 * represents a sector of 90 degrees, to approximate an arc. The
 * direction of the arc may be clockwise or countclockwise, and its
 * degree may over 360 degrees.
 *
 * TITLE:       arc
 *
 * CALL:        arc(direction, lx0, ly0, lr, lang1, lang2)
 *
 * PARAMETERS:
 *              direction    -- (CLKWISE/CNTCLK)
 *              lx0, ly0     -- coordinate of root
 *              lr           -- radius of arc
 *              lang1, lang2 -- starting and ending angles
 *
 * INTERFACE:   op_arc, op_arcn, op_arcto, linejoin, linecap
 *
 * CALLS:       arc_to_bezier
 *
 * RETURN:      none
 **********************************************************************/
SP_IDX arc(direction, lx0, ly0, lr, lang1, lang2)
ufix direction;
long32 lx0, ly0, lr, lang1, lang2;
{
        fix    NEG;
        bool   done;
        real32  d, t;
        real32  ang1, ang2;
        SP_IDX bezier_list;
        SP_IDX arc_list;
        real32  tmp;

        ang1 = L2F(lang1);
        ang2 = L2F(lang2);

        /* initilize arc_list */
        arc_list = NULLP;                      /* @NODE */

        /* Set NEG constant due to direction */
        if(direction == CLKWISE)
                NEG = -1;
        else
                NEG = 1;

        /* Draw a Bezier curve for each sector of 90 degrees */
        done = FALSE;
        while (!done) {
                d = NEG * (ang2-ang1);
                /*while (d < zero_f) d += (real32)360; 3/20/91; scchen */
                while (SIGN_F(d)) d += (real32)360.0;

                /* degernated case */
                FABS(tmp, d);
                if (tmp < (real32)1e-3) break;  /* 1e-4 => 1e-3;  12/14/88 */

                if(d <= (real32)90.) {
                        t = ang1 + NEG * d;
                        done = TRUE;
                } else
                        t = ang1 + NEG*90;

                /* create a bezier curve */
                bezier_list = arc_to_bezier (lx0, ly0, lr,
                                             F2L(ang1),F2L(t));

                if( ANY_ERROR() == LIMITCHECK ){
                        if (arc_list != NULLP) free_node(arc_list);
                        return (NULLP);
                }

                /* append it to arc_list */
                if (arc_list == NULLP) {
                        arc_list = bezier_list;
                } else {
                        node_table[(node_table[arc_list].SP_TAIL)].next =
                                bezier_list;
                        node_table[arc_list].SP_TAIL =
                                node_table[bezier_list].SP_TAIL;
                }
                ang1 = t;
        }
        return (arc_list);
}


/***********************************************************************
 * This module converts an arc, whose expanding angle is not larger than
 * 90 degrees, to a Bezier curve, and appends it to the input subpath.
 *
 * TITLE:       arc_to_bezier
 *
 * CALL:        arc_to_bezier(subpath, lx0, ly0, lr, lang1, lang2)
 *
 * PARAMETERS:  subpath    -- index to node_table, a subpath header
 *              x0, y0     -- coordinate of root
 *              r          -- radius of arc
 *              ang1, ang2 -- starting and ending angles
 *
 * INTERFACE:   arc
 *
 * CALLS:       transform, curveto
 *
 * RETURN:
 **********************************************************************/
/* struct vx_lst * arc_to_bezier (lx0, ly0, lr, lang1, lang2) @NODE */
SP_IDX arc_to_bezier (lx0, ly0, lr, lang1, lang2)
long32   lx0, ly0, lr, lang1, lang2;
{
        real32 x0, y0, r, ang1, ang2;
        real32 p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, tx, ty;
        real32 m1, m2;
        struct coord cp[3];
        struct nd_hdr FAR *pre_ptr;
        VX_IDX  first_vtx;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;   /* index to node_table for vertex */
        struct coord FAR *p;
        fix     i;
        real32  tmp;    /* @FABS */

        x0   = L2F(lx0);
        y0   = L2F(ly0);
        r    = L2F(lr);

        /* transform degrees to radius degree */
        ang1 = L2F(lang1) * PI / 180;
        ang2 = L2F(lang2) * PI / 180;

        /* Compute 4 control points of the approximated Bezier curve */
        /* First and last control points */
        p0x = x0 + r * (real32)cos(ang1);
        p0y = y0 + r * (real32)sin(ang1);
        p3x = x0 + r * (real32)cos(ang2);
        p3y = y0 + r * (real32)sin(ang2);

        /* Temporary point */
        tx = x0 + r * (real32)cos((ang1+ang2)/2);
        ty = y0 + r * (real32)sin((ang1+ang2)/2);

        /* Compute the other 2 control points (p1x, p1y) and (p2x, p2y)
         */
        tmp = (real32)cos(ang1);
        FABS(tmp, tmp);
        if(tmp < (real32)1e-4) {          /* cos(ang1) == 0 */
                m2 = (real32)tan(ang2);
                p2y = (8*ty - 4*p0y - p3y) / 3;
                p1y = p0y;
                p2x = p3x + m2*p3y - m2*p2y;
                p1x = (8*tx - p0x - p3x - 3*p2x) / 3;
        } else {
            tmp = (real32)cos(ang2);
            FABS(tmp, tmp);
            if (tmp < (real32)1e-4) {         /* cos(ang2) == 0 */
                m1 = (real32)tan(ang1);
                p2y = p3y;
                p1y = (8*ty - p0y - 4*p3y) / 3;
                p1x = p0x + m1 * (p0y-p1y);
                p2x = (8*tx - p0x - p3x - 3*p1x) / 3;
            } else {
                /* General case */
                m1 = (real32)tan(ang1);
                m2 = (real32)tan(ang2);
                p2y = (-8*tx - 8*m1*ty + 4*p0x + 4*m1*p0y + 4*p3x
                        + (3*m2 + m1) * p3y) / (3*(m2-m1));
                p1y = (-3*p2y + 8*ty - p0y - p3y) / 3;
                p1x = p0x + m1*p0y - m1*p1y;
                p2x = (8*tx - p0x - p3x - 3*p1x) /3;
            } /* @FABS */
        }

        /* Append the approximated curve to subpath */
        p = transform(F2L(p1x), F2L(p1y));
        cp[0].x = p->x;
        cp[0].y = p->y;
        p = transform(F2L(p2x), F2L(p2y));
        cp[1].x = p->x;
        cp[1].y = p->y;
        p = transform(F2L(p3x), F2L(p3y));
        cp[2].x = p->x;
        cp[2].y = p->y;

        /* loop to create 3 CURVETO nodes */
        for (i=0; i<3; i++) {
                /*
                 * Create a CURVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        if (i) free_node (first_vtx);
                        return (NULLP);
                }
                vtx = &node_table[ivtx];

                /* Set up a CURVETO node */
                vtx->VX_TYPE = CURVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = cp[i].x;
                vtx->VERTEX_Y = cp[i].y;

                if (i == 0) {
                        first_vtx = ivtx;
                } else {
                        pre_ptr->next = ivtx;
                }
                pre_ptr = vtx;
        }
        node_table[first_vtx].SP_NEXT = NULLP;
        node_table[first_vtx].SP_TAIL = ivtx;
        return (first_vtx);
}


/***********************************************************************
 * Given a Bezier curve which is represented by 4 control points, this
 * module creates a path contains several straight line segments to
 * approximate the curve. The input flatness will affect the accuracy of
 * the approximation.
 *
 * TITLE:       bezier_to_line
 *
 * CALL:        bezier_to_line (lflatness, lp0x, lp0y, lp1x, lp1y,
 *                              lp2x, lp2y, lp3x, lp3y)
 *
 * PARAMETERS:  lflatness -- accurency of approximation
 *              lp0x, lp0y .. lp3x, lp3y -- 4 control points of bezier curve
 *
 * INTERFACE:   Path_to_outline, flatten_subpath
 *
 * CALLS:       Bezier_split
 *
 * RETURN:      pointer to a vertex list, contains approximated line
 *              segments.
 **********************************************************************/
SP_IDX bezier_to_line(lflatness, lp0x, lp0y, lp1x, lp1y, lp2x,
                              lp2y, lp3x, lp3y)
long32    lflatness, lp0x, lp0y, lp1x, lp1y, lp2x, lp2y, lp3x, lp3y;
{
        SP_IDX b_vlist;
        struct  nd_hdr FAR *fcp, FAR *lcp;  /* first and last control points */
        VX_IDX  ifcp, ilcp;
        real32  flatness, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
        lfix_t  p1x_i, p1y_i, p2x_i, p2y_i, p3x_i, p3y_i;

        flatness = L2F(lflatness);
        p0x = L2F(lp0x);
        p0y = L2F(lp0y);
        p1x = L2F(lp1x);
        p1y = L2F(lp1y);
        p2x = L2F(lp2x);
        p2y = L2F(lp2y);
        p3x = L2F(lp3x);
        p3y = L2F(lp3y);

        /* Initialization */
        b_vlist = NULLP;

        /* Allocate a MOVETO node, fcp, for 1st control point */
        if((ifcp = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return (b_vlist);
        }
        fcp = &node_table[ifcp];

        fcp->VX_TYPE = MOVETO;
        fcp->next = NULLP;
        fcp->VERTEX_X = p0x;
        fcp->VERTEX_Y = p0y;

        /* Allocate a LINETO node, lcp, for last control point */
        if((ilcp = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                free_node (ifcp);
                return (b_vlist);
        }
        lcp = &node_table[ilcp];

        lcp->VX_TYPE = LINETO;
        lcp->next = NULLP;
        lcp->VERTEX_X = p3x;
        lcp->VERTEX_Y = p3y;

        /* chain these 2 nodes */
        fcp->next = ilcp;

        bezier_flatness = F2LFX (flatness);

        bezier_depth = 0;       /* initialization */

        /* Bezier curve approximation; by splitting Bezier hull into
         * smaller hulls recursively
         */
        bezier_x = p0x;
        bezier_y = p0y;
        p1x_i = F2LFX (p1x - p0x);
        p1y_i = F2LFX (p1y - p0y);
        p2x_i = F2LFX (p2x - p0x);
        p2y_i = F2LFX (p2y - p0y);
        p3x_i = F2LFX (p3x - p0x);
        p3y_i = F2LFX (p3y - p0y);
        bezier_split(ifcp, (lfix_t) 0, (lfix_t) 0, p1x_i, p1y_i, p2x_i,
                                                     p2y_i, p3x_i, p3y_i);
        if( ANY_ERROR() == LIMITCHECK ){
                free_node (ifcp);
                return (b_vlist);
        }

        /* save return b_vlist */
        b_vlist = fcp->next;
        node_table[b_vlist].SP_TAIL = ilcp;
        node_table[b_vlist].SP_NEXT = NULLP;

        /* remove the initial MOVETO node */
        fcp->next = NULLP;
        free_node (ifcp);

        return (b_vlist);
}


/*
 * SFX version of bezier interpolation                  @SFX_BZR
 * i.e. 4 control points in SFX format
 */
/* struct vx_lst  *bezier_to_line_sfx (flatness, @NODE */
SP_IDX bezier_to_line_sfx (flatness,
                                  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
lfix_t          flatness;
sfix_t          p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{

    lfix_t  p0x_i, p0y_i, p1x_i, p1y_i, p2x_i, p2y_i, p3x_i, p3y_i;
    /* real32  flatness; */
    struct nd_hdr   FAR *fcp, FAR *lcp; /* first and last control points */
    VX_IDX          ifcp, ilcp; /* index to node_table */
    /* static  struct vx_lst b_vlist;   (* should be static *) @NODE */
    SP_IDX b_vlist;

    /* Initialization */
    b_vlist = NULLP;

    /* Allocate a MOVETO node, fcp, for 1st control point */
    if ((ifcp = get_node()) == NULLP) {
        ERROR(LIMITCHECK);
        return (b_vlist);
    }
    fcp = &node_table[ifcp];

    fcp->VXSFX_TYPE = MOVETO;
    fcp->VXSFX_X    = p0x;
    fcp->VXSFX_Y    = p0y;
    fcp->next       = NULLP;

    /* Allocate a LINETO node, lcp, for last control point */
    if ((ilcp = get_node()) == NULLP) {
        ERROR(LIMITCHECK);
        free_node (ifcp);
        return (b_vlist);
    }
    lcp = &node_table[ilcp];

    lcp->VXSFX_TYPE = LINETO;
    lcp->VXSFX_X    = p3x;
    lcp->VXSFX_Y    = p3y;
    lcp->next       = NULLP;

    /* chain these 2 nodes */
    fcp->next = ilcp;

    bezier_flatness = flatness;

    bezier_depth = 0;           /* initialization */

    /* Bezier curve approximation; by splitting Bezier hull into
     * smaller hulls recursively
     */
    p0x_i = SFX2LFX (p0x);
    p0y_i = SFX2LFX (p0y);
    p1x_i = SFX2LFX (p1x);
    p1y_i = SFX2LFX (p1y);
    p2x_i = SFX2LFX (p2x);
    p2y_i = SFX2LFX (p2y);
    p3x_i = SFX2LFX (p3x);
    p3y_i = SFX2LFX (p3y);
    bezier_split_sfx (ifcp, p0x_i, p0y_i, p1x_i, p1y_i,
                                          p2x_i, p2y_i, p3x_i, p3y_i);
    if (ANY_ERROR() == LIMITCHECK) {
        free_node (ifcp);
        return (b_vlist);       /* return (&b_vlist); @NODE */
    }

    /* save return b_vlist */
    b_vlist = fcp->next;               /* skip 1st MOVETO node */
    node_table[b_vlist].SP_TAIL = ilcp;
    node_table[b_vlist].SP_NEXT = NULLP;

    /* remove the initial MOVETO node */
    fcp->next = NULLP;
    free_node (ifcp);

    return (b_vlist);
}

/***********************************************************************
 * Split a Bezier hull into 2 hulls
 *    (p0, p1, p2, p3) --> (q0, q1, q2, q3) and (r0, r1, r2, r3)
 *
 * TITLE:       bezier_split
 *
 * CALL:        bezier_split(ptr, flatness, p0x, p0y, p1x, p1y, p2x,
 *              p2y, p3x, p3y)
 *
 * PARAMETERS:  ifcp     -- index to node_table, the node of 1st control
 *                          point; a new approximated point will be
 *                          inserted after it.
 *              flatness -- accuracy to approximate curve
 *              p0x, p0y -- 1st control point of a bezier curve
 *              p1x, p1y -- 2nd control point of a bezier curve
 *              p2x, p2y -- 3rd control point of a bezier curve
 *              p3x, p3y -- 4th control point of a bezier curve
 *
 * INTERFACE:   Bezier_slpit
 *
 * CALLS:       Bezier_split
 *
 * RETURN:
 **********************************************************************/
static void near bezier_split(ifcp, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
VX_IDX ifcp;
lfix_t p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{
        lfix_t q1x, q1y, q2x, q2y;
        lfix_t r1x, r1y, r2x, r2y;
        lfix_t pmx, pmy;         /* new approximated point */
        lfix_t distance;
        lfix_t tempx, tempy;

        struct nd_hdr FAR *fcp, FAR *vtx;
        VX_IDX ivtx;

        /* initialize; get pointer of first control point */
        fcp = &node_table[ifcp];

        /* Compute a new approximated point (pmx, pmy) */
         pmx = DIV2(p1x + p2x);         pmy = DIV2(p1y + p2y);
         q1x = DIV2(p0x + p1x);         q1y = DIV2(p0y + p1y);
         r2x = DIV2(p2x + p3x);         r2y = DIV2(p2y + p3y);
         q2x = DIV2(q1x + pmx);         q2y = DIV2(q1y + pmy);
         r1x = DIV2(r2x + pmx);         r1y = DIV2(r2y + pmy);
         pmx = DIV2(r1x + q2x);         pmy = DIV2(r1y + q2y);

         /* Bezier curve function :
          * p(t) = (1-t)**3 * p0  +
          *     3 * t * (1-t)**2 * p1 +
          *     3 * t**2 * (1-t) * p2 +
          *     t**3 * p3
          */

        /* Compute the distance between point pm and line p0,p3 */
/*      temp =  pmx*p0y + p3x*pmy + p0x*p3y - p3x*p0y - pmx*p3y - p0x*pmy;
 *      distance = ABS(temp) / sqrt((p0x-p3x)*(p0x-p3x) +
 *                                  (p0y-p3y)*(p0y-p3y));
 */

        /* distance between point pm and midpoint of p0, p3 */
        tempx = pmx - DIV2(p0x + p3x);
        tempy = pmy - DIV2(p0y + p3y);
        distance = ABS(tempx) + ABS(tempy);

        /* Check exit condition */
        if((bezier_depth != 0) && (distance < bezier_flatness)) return;

        /* increase recurcive_depth */
        bezier_depth ++;

        /* Save the new approximated point */
        /* Allocate a node */
        if ((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VX_TYPE = LINETO;
        vtx->VERTEX_X = LFX2F(pmx) + bezier_x;
        vtx->VERTEX_Y = LFX2F(pmy) + bezier_y;

        /* insert this node to first control point(fcp) */
        vtx->next = fcp->next;
        fcp->next = ivtx;

        /* Split left portion recurcively */
        bezier_split (ifcp, p0x, p0y, q1x, q1y, q2x, q2y, pmx, pmy);
        if( ANY_ERROR() == LIMITCHECK ) return;

        /* Split right portion recurcively */
        bezier_split (ivtx, pmx, pmy, r1x, r1y, r2x, r2y, p3x, p3y);
}


/*
 * SFX version of bezier interpolation          @SFX_BZR
 * i.e. 4 control points in SFX format
 */
static void near bezier_split_sfx (ifcp, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
VX_IDX  ifcp;
lfix_t  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{
        lfix_t q1x, q1y, q2x, q2y;
        lfix_t r1x, r1y, r2x, r2y;
        lfix_t pmx, pmy;         /* new approximated point */
        lfix_t distance;
        lfix_t tempx, tempy;

        struct nd_hdr FAR *fcp, FAR *vtx;
        VX_IDX ivtx;

        /* initialize; get pointer of first control point */
        fcp = &node_table[ifcp];

        /* Compute a new approximated point (pmx, pmy) */
         pmx = DIV2(p1x + p2x);         pmy = DIV2(p1y + p2y);
         q1x = DIV2(p0x + p1x);         q1y = DIV2(p0y + p1y);
         r2x = DIV2(p2x + p3x);         r2y = DIV2(p2y + p3y);
         q2x = DIV2(q1x + pmx);         q2y = DIV2(q1y + pmy);
         r1x = DIV2(r2x + pmx);         r1y = DIV2(r2y + pmy);
         pmx = DIV2(r1x + q2x);         pmy = DIV2(r1y + q2y);

         /* Bezier curve function :
          * p(t) = (1-t)**3 * p0  +
          *     3 * t * (1-t)**2 * p1 +
          *     3 * t**2 * (1-t) * p2 +
          *     t**3 * p3
          */

        /* Compute the distance between point pm and line p0,p3 */
/*      temp =  pmx*p0y + p3x*pmy + p0x*p3y - p3x*p0y - pmx*p3y - p0x*pmy;
 *      distance = ABS(temp) / sqrt((p0x-p3x)*(p0x-p3x) +
 *                                  (p0y-p3y)*(p0y-p3y));
 */

        /* distance between point pm and midpoint of p0, p3 */
        tempx = pmx - DIV2(p0x + p3x);
        tempy = pmy - DIV2(p0y + p3y);
        distance = ABS(tempx) + ABS(tempy);

        /* Check exit condition */
        if((bezier_depth != 0) && (distance < bezier_flatness)) return;

        /* increase recurcive_depth */
        bezier_depth ++;

        /* Save the new approximated point */
        /* Allocate a node */
        if ((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VXSFX_TYPE = LINETO;
        vtx->VXSFX_X    = LFX2SFX_T(pmx);
        vtx->VXSFX_Y    = LFX2SFX_T(pmy);

        /* insert this node to first control point(fcp) */
        vtx->next = fcp->next;
        fcp->next = ivtx;

        /* Split left portion recurcively */
        bezier_split_sfx (ifcp, p0x, p0y, q1x, q1y, q2x, q2y, pmx, pmy);
        if( ANY_ERROR() == LIMITCHECK ) return;

        /* Split right portion recurcively */
        bezier_split_sfx (ivtx, pmx, pmy, r1x, r1y, r2x, r2y, p3x, p3y);
}


/***********************************************************************
 * This module creates a MOVETO node, and appends it to current path.
 *
 * TITLE:       moveto
 *
 * CALL:        moveto(lx, ly)
 *
 * PARAMETERS:  lx, ly -- coordinate to create a MOVETO node
 *
 * INTERFACE:   op_moveto, op_rmoveto, op_arc, op_arcn
 *
 * CALLS:       none
 *
 * RETURN:      none
 **********************************************************************/
void moveto(long32 lx, long32 ly)
/* long32   lx, ly;     @WIN */
{
        real32  x0, y0;
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;             /* index to node_table for vertex */

        x0 = L2F(lx);
        y0 = L2F(ly);
        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag; do nothing */
                /* 05/06/91 Peter */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;      /* new path */
        tail_sp = &node_table[path->tail];
        vtx = &node_table[tail_sp->SP_TAIL];

        /* Just update current node if current position is a MOVETO type
         * otherwise, create a new subpath
         */
        if (vtx->VX_TYPE == MOVETO) {
                /* Replace contents of current_node */
                vtx->VERTEX_X = x0;
                vtx->VERTEX_Y = y0;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                        tail_sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }
        } else {
                /*
                 * create a subpath header
                 */
create_node:
                /*
                 * Create a MOVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                vtx = &node_table[ivtx];

                /* Set up a MOVETO node */
                vtx->VX_TYPE = MOVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = x0;
                vtx->VERTEX_Y = y0;
                vtx->SP_FLAG = FALSE;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                        vtx->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* @NODE */
                /* Setup subpath header, and append current path */
                vtx->SP_TAIL = ivtx;
                vtx->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        /* tail_sp->next = ivtx; @NODE */
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;
        }

        /* Update current position */
        GSptr->position.x = x0;
        GSptr->position.y = y0;
}


/***********************************************************************
 *
 * This module creates a LINETO node, and appends it to current path.
 *
 * TITLE:       lineto
 *
 * CALL:        lineto(lx, ly)
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_lineto
 *              op_rlineto
 *              op_arc
 *              op_arcn
 *              op_arcto
 *
 * CALLS:
 *
 * RETURN:
 *
 **********************************************************************/
void lineto(long32 lx, long32 ly)       /*@WIN*/
/* long32   lx, ly;     @WIN */
{
        real32  x0, y0;
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp, FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;

        x0 = L2F(lx);
        y0 = L2F(ly);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;
        tail_sp = sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* create a new subpath if last node is a CLOSEPATH */
        if (vtx->VX_TYPE == CLOSEPATH) {
create_node:
                /* Create a pseudo moveto(PSMOVE) node */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                sp = vtx = &node_table[ivtx];

                /* Set up a PSMOVE node of current position */
                vtx->VX_TYPE = PSMOVE;
                vtx->next = NULLP;
                vtx->VERTEX_X = GSptr->position.x;
                vtx->VERTEX_Y = GSptr->position.y;
                vtx->SP_FLAG = FALSE;    /* @NODE */

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* @NODE */
                /* Setup subpath header, and append current path */
                sp->SP_TAIL = ivtx;
                sp->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;

        } /* if CLOSEPATH */

        /*
         * Create a LINETO node
         */
        /* Allocate a node */
        ivtx = get_node();
        if(ivtx == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VX_TYPE = LINETO;
        vtx->next = NULLP;
        vtx->VERTEX_X = x0;
        vtx->VERTEX_Y = y0;

        /* set sp_flag @SP_FLG */
        if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
        }

        /* Append this node to current_subpath */
        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        /* Update current position */
        GSptr->position.x = x0;
        GSptr->position.y = y0;
}



/***********************************************************************
 * This module creates 3 CURVETO nodes, and appends it to current path.
 *
 * TITLE:       curveto
 *
 * CALL:        curveto(subpath, cp)
 *
 * PARAMETERS:  cp      -- an array contains 3 coordinates of a bezier
 *                         curve
 *
 * INTERFACE:   op_curveto, arc_to_bezier
 *
 * CALLS:
 *
 * RETURN:      none
 **********************************************************************/
void curveto (long32 lx0, long32 ly0, long32 lx1,
long32 ly1, long32 lx2, long32 ly2)     /*@WIN*/
/* long32     lx0, ly0, lx1, ly1, lx2, ly2;     @WIN */
{
        struct coord cp[3];
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp, FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx, tail_ivtx;
        fix     i;

        cp[0].x = L2F(lx0);
        cp[0].y = L2F(ly0);
        cp[1].x = L2F(lx1);
        cp[1].y = L2F(ly1);
        cp[2].x = L2F(lx2);
        cp[2].y = L2F(ly2);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;
        tail_sp = sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* create a new subpath if last node is a CLOSEPATH */
        if (vtx->VX_TYPE == CLOSEPATH) {
create_node:
                /* Create a pseudo moveto(PSMOVE) node */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                sp = vtx = &node_table[ivtx];

                /* Set up a PSMOVE node of current position */
                vtx->VX_TYPE = PSMOVE;
                vtx->next = NULLP;
                vtx->VERTEX_X = GSptr->position.x;
                vtx->VERTEX_Y = GSptr->position.y;
                vtx->SP_FLAG = FALSE;    /* @NODE */

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* Setup subpath header, and append current path */
                sp->SP_TAIL = ivtx;
                sp->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        /* tail_sp->next = ivtx; @NODE */
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;
        } else {
                tail_ivtx = sp->SP_TAIL;
        } /* if CLOSEPATH */

        /* loop to create 3 CURVETO nodes */
        for (i=0; i<3; i++) {
                /*
                 * Create a CURVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                vtx = &node_table[ivtx];

                /* Set up a CURVETO node */
                vtx->VX_TYPE = CURVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = cp[i].x;
                vtx->VERTEX_Y = cp[i].y;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* Append this node to current_subpath */
                node_table[sp->SP_TAIL].next = ivtx;
                sp->SP_TAIL = ivtx;
        }

        /* set sp_flag @SP_FLG */
        sp->SP_FLAG |= SP_CURVE;

        /* Update current position */
        GSptr->position.x = cp[2].x;
        GSptr->position.y = cp[2].y;
}


/***********************************************************************
 * This module creates a path that reverses the direction and order of
 * the given subpath.
 *
 * TITLE:       reverse_subpath
 *
 * CALL:        reverse_subpath(in_subpath)
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_reversepath
 *
 * CALLS:
 *
 * RETURN:
 **********************************************************************/
SP_IDX reverse_subpath (first_vertex)
VX_IDX first_vertex;
{
        SP_IDX ret_vlist;
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx, inode, tail;
        real32   last_x, last_y;

        /* Initialize ret_vlist */
        ret_vlist = tail = NULLP;

        /* Traverse the input subpath, and create a new reversed subpath */
        for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {
                case MOVETO :
                case PSMOVE :
                        /* keep last position */
                        last_x = vtx->VERTEX_X;
                        last_y = vtx->VERTEX_Y;
                        break;
                case LINETO :
                case CURVETO :
                        /* Create a LINETO/CURVETO node with (last_x, last_y)*/
                        if((inode = get_node()) == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = vtx->VX_TYPE;
                        node->VERTEX_X = last_x;
                        node->VERTEX_Y = last_y;

                        /* preppend the node to ret_vlist */
                        if (ret_vlist == NULLP)
                                tail = inode;
                        else
                                node->next = ret_vlist;
                        ret_vlist = inode;

                        /* keep last position */
                        last_x = vtx->VERTEX_X;
                        last_y = vtx->VERTEX_Y;
                        break;
                case CLOSEPATH :
                        /* Create a CLOSEPATH node */
                        if((inode = get_node()) == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = CLOSEPATH;

                        /* append the node to ret_vlist */
                        if (tail == NULLP)
                                ret_vlist = inode;
                        else
                                node_table[tail].next = inode;
                        tail = inode; /* ret_vlist always not empty */
                        break;
                } /* switch */
        } /* for loop */

        /* Create a MOVETO node(last_x, last_y) for end of subpath */
        if((inode = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return (ret_vlist);
        }
        node = &node_table[inode];

        node->VX_TYPE = MOVETO;
        node->VERTEX_X = last_x;
        node->VERTEX_Y = last_y;
        node->SP_FLAG = node_table[first_vertex].SP_FLAG;

        /* preppend the node to ret_vlist */
        node->next = ret_vlist;
        node->SP_NEXT = NULLP;
        ret_vlist = inode;
        if (tail == NULLP)
                tail = inode;
        node->SP_TAIL = tail;
        return (ret_vlist);
}



/***********************************************************************
 * This module creates a path that preserves all straight line segments
 * but has all curve segments replaced by sequences of line segments
 * that approximate the given subpath.
 *
 * TITLE:       flatten_subpath
 *
 * CALL:        flatten_subpath(in_subpath)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Op_flattenpath
 *
 * CALLS:       Bezier_to_line
 *
 * RETURN:
 **********************************************************************/
SP_IDX flatten_subpath (first_vertex, lflatness)
VX_IDX first_vertex;
long32   lflatness;
{
        SP_IDX ret_vlist; /* should be static */
        SP_IDX b_vlist;
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx, inode, tail;
        real32   x1=0, y1=0, x2=0, y2=0, x3=0, y3=0, x4=0, y4=0;

        /* Initialize ret_vlist */
        ret_vlist = tail = NULLP;

        /* Traverse the input subpath, and create a new flattened subpath */
        for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {
                case MOVETO :
                case PSMOVE :
                case LINETO :
                case CLOSEPATH :
                        /* Copy the node */
                        inode = get_node();
                        if(inode == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = vtx->VX_TYPE;
                        node->VERTEX_X = vtx->VERTEX_X;
                        node->VERTEX_Y = vtx->VERTEX_Y;

                        /* Append the node to ret_vlist */
                        if (ret_vlist == NULLP) {
                                ret_vlist = inode;
                                node->SP_FLAG =
                                    node_table[first_vertex].SP_FLAG;
                        } else
                                node_table[tail].next = inode;
                        tail = inode;
                        break;
                case CURVETO :
                        x1 = x2;
                        y1 = y2;
                        x2 = vtx->VERTEX_X;
                        y2 = vtx->VERTEX_Y;

                        /* Get next two nodes: x3, y3, x4, y4 */
                        vtx = &node_table[vtx->next];
                        x3 = vtx->VERTEX_X;
                        y3 = vtx->VERTEX_Y;
                        vtx = &node_table[vtx->next];
                        x4 = vtx->VERTEX_X;
                        y4 = vtx->VERTEX_Y;

                        b_vlist = bezier_to_line(lflatness,F2L(x1),F2L(y1),
                             F2L(x2), F2L(y2),F2L(x3),F2L(y3),F2L(x4),F2L(y4));

                        if( ANY_ERROR() == LIMITCHECK ) return(ret_vlist);

                        /* append b_vlist to ret_vlist */
                        node_table[tail].next = b_vlist;
                        tail = node_table[b_vlist].SP_TAIL;
                        break;
                } /* switch */
                x2 = vtx->VERTEX_X;
                y2 = vtx->VERTEX_Y;
        } /* for */
        node_table[ret_vlist].SP_TAIL = tail;
        node_table[ret_vlist].SP_NEXT = NULLP;
        return (ret_vlist);
}



/***********************************************************************
 * This module enumerates the current subpath in order, executes one of
 * the four given procedures for each element in the subpath.
 *
 * TITLE:       dump_subpath
 *
 * CALL:        dump_subpath(moveto_proc, lineto_proc, curveto_proc,
 *              closepath_proc)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Op_pathforall
 *
 * CALLS:       Execute
 *
 * RETURN:
 **********************************************************************/
void dump_subpath (isubpath, objects)
SP_IDX isubpath;
struct object_def FAR objects[];
{
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;
        struct coord *p;
        union  four_byte x4, y4;
        fix     i;

        /* Traverse the current subpath, and dump all nodes */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {

                case MOVETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 2){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        /* Transform to user's space, and push to
                         * operand stack
                         */
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

                        if (interpreter(&objects[0])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }

                        break;

                case LINETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 2){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        /* Transform to user's space, and push to
                         * operand stack
                         */
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

                        if (interpreter(&objects[1])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }

                        break;

                case CURVETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 6){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        for (i=0; i<2; i++) {
                            /* check infinity 10/27/88 */
                            if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                                (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                    x4.ff = infinity_f;
                                    y4.ff = infinity_f;
                            } else {
                                    p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                          F2L(vtx->VERTEX_Y));
                                    x4.ff = p->x;
                                    y4.ff = p->y;
                            }
                            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                       0, x4.ll);
                            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                       0, y4.ll);
                            vtx = &node_table[vtx->next];
                        }
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                   0, x4.ll);
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                   0, y4.ll);

                        if (interpreter(&objects[2])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }
                        break;
                case CLOSEPATH :
                        if (interpreter(&objects[3])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }
                        break;
                } /* switch */
        } /* for loop */
}


void bounding_box (isubpath, bbox)
VX_IDX isubpath;
real32 far *bbox;                            /* real32 far bbox[]; */
{
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;

        /* find min. and max. values of current path */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                /* ignore single moveto node and under charpath 1/2/91; scchen */
                if (vtx->VX_TYPE == MOVETO &&
                    vtx->next == NULLP &&
                    path_table[GSptr->path].rf & P_NACC ) break;

                if (vtx->VX_TYPE == CLOSEPATH) break;
                        /* coord. in CLOSEPATH node is meaningless */

                if (vtx->VERTEX_X > bbox[2])            /* max_x */
                        bbox[2] = vtx->VERTEX_X;
                else if (vtx->VERTEX_X < bbox[0])       /* min_x */
                        bbox[0] = vtx->VERTEX_X;
                if (vtx->VERTEX_Y > bbox[3])            /* max_y */
                        bbox[3] = vtx->VERTEX_Y;
                else if (vtx->VERTEX_Y < bbox[1])       /* min_y */
                        bbox[1] = vtx->VERTEX_Y;
        } /* for each vertex */
}


/***********************************************************************
 *
 * TITLE:       get_node
 *
 * CALL:        get_node()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      node -- index of node_table contains a node
 *              -1   -- fail (no more nodes to get)
 *
 **********************************************************************/
VX_IDX get_node()
{
        fix     inode;
        struct nd_hdr FAR *node;

        if(freenode_list == NULLP) {
#ifdef DBG1
                printf("\07Warning, out of node_table\n");
#endif
                return(NULLP);
        }
        node = &node_table[freenode_list];
        inode = freenode_list;
        freenode_list = node->next;
        node->next = NULLP;
#ifdef DBG2
        printf("get node#%d\n", inode);
#endif
        return ((VX_IDX)inode);
}



/***********************************************************************
 *
 * TITLE:       free_node
 *
 * CALL:        free_node (inode)
 *
 * PARAMETERS:  inode -- a list of nodes to be freed
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void free_node (inode)
fix     inode;
{
        fix ind, inext;
        struct nd_hdr FAR *nd;

#ifdef DBG2
        printf("free nodes#");
#endif

        for (ind = inode; ind != NULLP; ind = inext) {
                nd = &node_table[ind];
                inext = nd->next;
                nd->next = freenode_list;
                freenode_list = (VX_IDX)ind;
#ifdef DBG2
                printf("%d, ", ind);
#endif
        }

#ifdef DBG2
        printf("\n");
#endif
}


/***********************************************************************
 * This module frees current path on current gsave level
 *
 * TITLE:       free_path
 *
 * CALL:        free_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   procedures want to free current path
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
void free_path()
{
        struct ph_hdr FAR *path;
        VX_IDX next;
        SP_IDX  isp;

        path = &path_table[GSptr->path];

        /* Free current path */
        for (isp = path->head; isp != NULLP; isp = next) {
                next = node_table[isp].SP_NEXT;
                free_node(isp);
        }
        path->head = path->tail = NULLP;

        /* initilize current path */
        path->previous = NULLP;
        path->rf = 0;

        /* free clip trazepoids which used by current path but has been freed
         * by clip_path @CPPH; 12/1/90
         */
        if (path->cp_path != NULLP) {
                if (path->cp_path != GSptr->clip_path.head)
                        free_node (path->cp_path);
                path->cp_path = NULLP;
        }
}


/***********************************************************************
 * This module gets current path.
 *
 * TITLE:       get_path
 *
 * CALL:        get_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   procedures want to free current path
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
void get_path(sp_list)
struct sp_lst FAR *sp_list;
{
        /* copy all subpaths to ret_list */
// DJC        traverse_path (copy_subpath, (fix FAR *)sp_list);
        traverse_path ((TRAVERSE_PATH_ARG1)(copy_subpath), (fix FAR *)sp_list);
}

static void far copy_subpath (isubpath, ret_list)    /* @TRVSE */
SP_IDX isubpath;
struct sp_lst *ret_list;
{
        struct nd_hdr FAR *vtx, FAR *nvtx;
        VX_IDX ivtx, invtx;
        VX_IDX head, tail;

        head = tail = NULLP;

        /* Traverse the current subpath, and copy all nodes */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                /* Allocate a node */
                if((invtx = get_node()) == NULLP) {
                        ERROR(LIMITCHECK);
                        free_node (head);
                        return;
                }
                nvtx = &node_table[invtx];

                /* copy contents of the node */
                nvtx->VX_TYPE = vtx->VX_TYPE;
                nvtx->next = NULLP;
                nvtx->VERTEX_X = vtx->VERTEX_X;
                nvtx->VERTEX_Y = vtx->VERTEX_Y;

                /* Append this node to current_subpath */
                if (tail == NULLP) {
                        head = invtx;
                        nvtx->SP_FLAG = vtx->SP_FLAG;
                        nvtx->SP_NEXT = NULLP;
                } else
                        node_table[tail].next = invtx;
                tail = invtx;
        } /* for loop */
        node_table[head].SP_TAIL = tail;

        /* Append this subpath to ret_list */
        if (ret_list->tail == NULLP)
                ret_list->head = head;
        else
                node_table[ret_list->tail].SP_NEXT = head;
        ret_list->tail = head;
}


/***********************************************************************
 * This module appends input subpaths to current path.
 *
 * TITLE:       append_path
 *
 * CALL:        append_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      none
 **********************************************************************/
void append_path(sp_list)
struct sp_lst FAR *sp_list;
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;

        path = &path_table[GSptr->path];

        if (path->tail == NULLP)
                path->head = sp_list->head;
        else {
                /* current path not empty, append sp_list */
                sp = &node_table[path->tail];   /* current subpath */
                if (node_table[sp->SP_TAIL].VX_TYPE == MOVETO) {
                        struct nd_hdr FAR *headsp;

                        /* the tail vertex is a MOVETO node,
                         * combine the current subpath with sp_list->head
                         */
                        /* free_node (sp->SP_TAIL); @NODE */

                        /* copy header of first subpath of sp_list
                         * to current subpath
                         */
                        headsp = &node_table[sp_list->head];
                        /* @NODE
                         * sp->SP_HEAD = headsp->SP_HEAD;
                         * sp->SP_TAIL = headsp->SP_TAIL;
                         * sp->next = headsp->next;
                         * sp->SP_FLAG = headsp->SP_FLAG;       (* 1/14/88 *)
                         */
                        *sp = *headsp;

                        /* free subpath header of sp_list->head */
                        headsp->next = NULLP;
                        free_node (sp_list->head);

                        /* update sp_list->tail, if it has been removed */
                        if (sp_list->tail == sp_list->head) {
                                sp_list->tail = path->tail;
                                if (headsp->SP_TAIL == sp_list->head)/* @NODE */
                                        sp->SP_TAIL = path->tail;
                        }
                } else
                        /* chain sp_list to current path normally */
                        /* node_table[path->tail].next = sp_list->head; @NODE */
                        node_table[path->tail].SP_NEXT = sp_list->head;
        }
        /* update the tail of current path */
        path->tail = sp_list->tail;

}




void set_inverse_ctm()
{
        real32  det_matrix;

        /* calculate the det(CTM) */
        _clear87() ;
        det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                     GSptr->ctm[1] * GSptr->ctm[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return;
        }

        /* calculate the value of INV(CTM) */
        inverse_ctm[0] =  GSptr->ctm[3] / det_matrix;
        CHECK_INFINITY(inverse_ctm[0]);

        inverse_ctm[1] = -GSptr->ctm[1] / det_matrix;
        CHECK_INFINITY(inverse_ctm[1]);

        inverse_ctm[2] = -GSptr->ctm[2] / det_matrix;
        CHECK_INFINITY(inverse_ctm[2]);

        inverse_ctm[3] =  GSptr->ctm[0] / det_matrix;
        CHECK_INFINITY(inverse_ctm[3]);

        inverse_ctm[4] = (GSptr->ctm[2] * GSptr->ctm[5] -
              GSptr->ctm[3] * GSptr->ctm[4]) / det_matrix;
        CHECK_INFINITY(inverse_ctm[4]);

        inverse_ctm[5] = (GSptr->ctm[1] * GSptr->ctm[4] -
              GSptr->ctm[0] * GSptr->ctm[5]) / det_matrix;
        CHECK_INFINITY(inverse_ctm[5]);

        /* set ctm_flag */
/*      if ((F2L(GSptr->ctm[1]) == F2L(zero_f)) &&      3/20/91; scchen
 *          (F2L(GSptr->ctm[2]) == F2L(zero_f))) {
 */
        if (IS_ZERO(GSptr->ctm[1]) && IS_ZERO(GSptr->ctm[2])){
                ctm_flag |= NORMAL_CTM;
        } else {
                ctm_flag &= ~NORMAL_CTM;
        }

        /* left-handed or right-handed system; @STKDIR */
        /*if (GSptr->ctm[0] < zero_f) {                  3/20/91; scchen
         *       if (GSptr->ctm[3] > zero_f)
         *               ctm_flag |= LEFT_HAND_CTM;      (* different signs *)
         *       else
         *               ctm_flag &= ~LEFT_HAND_CTM;     (* same signs *)
         *} else {
         *       if (GSptr->ctm[3] > zero_f)
         *               ctm_flag &= ~LEFT_HAND_CTM;     (* same signs *)
         *       else
         *               ctm_flag |= LEFT_HAND_CTM;      (* different signs *)
         *}
         */
        if (SIGN_F(GSptr->ctm[0]) == SIGN_F(GSptr->ctm[3]))
                ctm_flag &= ~LEFT_HAND_CTM;     /* same signs */
        else
                ctm_flag |= LEFT_HAND_CTM;      /* different signs */

}



static struct coord * near fast_inv_transform(lx, ly)
long32   lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;

        if (ctm_flag&NORMAL_CTM) {
                p.x = inverse_ctm[0]*x + inverse_ctm[4];
                CHECK_INFINITY(p.x);

                p.y = inverse_ctm[3]*y + inverse_ctm[5];
                CHECK_INFINITY(p.y);
        } else {
                p.x = inverse_ctm[0]*x + inverse_ctm[2]*y + inverse_ctm[4];
                CHECK_INFINITY(p.x);

                p.y = inverse_ctm[1]*x + inverse_ctm[3]*y + inverse_ctm[5];
                CHECK_INFINITY(p.y);
        }

        return(&p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\pfill.h ===
/* Pattern Mapping */
#ifdef DJC //Fix from history.log UPD0027
const
ufix16 pf_cell[] = {
    /* 00 - 0f */
    0xffff, 0xfffc, 0xfff3, 0xfff0,
    0xffcf, 0xffcc, 0xffc3, 0xffc0,
    0xff3f, 0xff3c, 0xff33, 0xff30,
    0xff0f, 0xff0c, 0xff03, 0xff00,
    /* 10 - 1f */
    0xfcff, 0xfcfc, 0xfcf3, 0xfcf0,
    0xfccf, 0xfccc, 0xfcc3, 0xfcc0,
    0xfc3f, 0xfc3c, 0xfc33, 0xfc30,
    0xfc0f, 0xfc0c, 0xfc03, 0xfc00,
    /* 20 - 2f */
    0xf3ff, 0xf3fc, 0xf3f3, 0xf3f0,
    0xf3cf, 0xf3cc, 0xf3c3, 0xf3c0,
    0xf33f, 0xf33c, 0xf333, 0xf330,
    0xf30f, 0xf30c, 0xf303, 0xf300,
    /* 30 - 3f */
    0xf0ff, 0xf0fc, 0xf0f3, 0xf0f0,
    0xf0cf, 0xf0cc, 0xf0c3, 0xf0c0,
    0xf03f, 0xf03c, 0xf033, 0xf030,
    0xf00f, 0xf00c, 0xf003, 0xf000,
    /* 40 - 4f */
    0xcfff, 0xcffc, 0xcff3, 0xcff0,
    0xcfcf, 0xcfcc, 0xcfc3, 0xcfc0,
    0xcf3f, 0xcf3c, 0xcf33, 0xcf30,
    0xcf0f, 0xcf0c, 0xcf03, 0xcf00,
    /* 50 - 5f */
    0xccff, 0xccfc, 0xccf3, 0xccf0,
    0xcccf, 0xcccc, 0xccc3, 0xccc0,
    0xcc3f, 0xcc3c, 0xcc33, 0xcc30,
    0xcc0f, 0xcc0c, 0xcc03, 0xcc00,
    /* 60 - 6f */
    0xc3ff, 0xc3fc, 0xc3f3, 0xc3f0,
    0xc3cf, 0xc3cc, 0xc3c3, 0xc3c0,
    0xc33f, 0xc33c, 0xc333, 0xc330,
    0xc30f, 0xc30c, 0xc303, 0xc300,
    /* 70 - 7f */
    0xc0ff, 0xc0fc, 0xc0f3, 0xc0f0,
    0xc0cf, 0xc0cc, 0xc0c3, 0xc0c0,
    0xc03f, 0xc03c, 0xc033, 0xc030,
    0xc00f, 0xc00c, 0xc003, 0xc000,
    /* 80 - 8f */
    0x3fff, 0x3ffc, 0x3ff3, 0x3ff0,
    0x3fcf, 0x3fcc, 0x3fc3, 0x3fc0,
    0x3f3f, 0x3f3c, 0x3f33, 0x3f30,
    0x3f0f, 0x3f0c, 0x3f03, 0x3f00,
    /* 90 - 9f */
    0x3cff, 0x3cfc, 0x3cf3, 0x3cf0,
    0x3ccf, 0x3ccc, 0x3cc3, 0x3cc0,
    0x3c3f, 0x3c3c, 0x3c33, 0x3c30,
    0x3c0f, 0x3c0c, 0x3c03, 0x3c00,
    /* a0 - af */
    0x33ff, 0x33fc, 0x33f3, 0x33f0,
    0x33cf, 0x33cc, 0x33c3, 0x33c0,
    0x333f, 0x333c, 0x3333, 0x3330,
    0x330f, 0x330c, 0x3303, 0x3300,
    /* b0 - bf */
    0x30ff, 0x30fc, 0x30f3, 0x30f0,
    0x30cf, 0x30cc, 0x30c3, 0x30c0,
    0x303f, 0x303c, 0x3033, 0x3030,
    0x300f, 0x300c, 0x3003, 0x3000,
    /* c0 - cf */
    0x0fff, 0x0ffc, 0x0ff3, 0x0ff0,
    0x0fcf, 0x0fcc, 0x0fc3, 0x0fc0,
    0x0f3f, 0x0f3c, 0x0f33, 0x0f30,
    0x0f0f, 0x0f0c, 0x0f03, 0x0f00,
    /* d0 - df */
    0x0cff, 0x0cfc, 0x0cf3, 0x0cf0,
    0x0ccf, 0x0ccc, 0x0cc3, 0x0cc0,
    0x0c3f, 0x0c3c, 0x0c33, 0x0c30,
    0x0c0f, 0x0c0c, 0x0c03, 0x0c00,
    /* e0 - ef */
    0x03ff, 0x03fc, 0x03f3, 0x03f0,
    0x03cf, 0x03cc, 0x03c3, 0x03c0,
    0x033f, 0x033c, 0x0333, 0x0330,
    0x030f, 0x030c, 0x0303, 0x0300,
    /* f0 - ff */
    0x00ff, 0x00fc, 0x00f3, 0x00f0,
    0x00cf, 0x00cc, 0x00c3, 0x00c0,
    0x003f, 0x003c, 0x0033, 0x0030,
    0x000f, 0x000c, 0x0003, 0x0000,
};
#endif

ufix32  PF_BASE[PF_BSIZE];      /* initial ?? */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\init.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/***********************************************************************
 *
 *      File Description
 *
 *      File Name:   init.c
 *
 *      Purpose: This file contains an initialization routine to be
 *               called by Interpreter at system start-up time.
 *
 *      Developer:      S.C.Chen
 *
 *      Modifications:
 *      Version     Date        Comment
 *                  5/23/88     @DEVICE: update framedevice & nulldevice
 *                              for correct operation under gsave/grestore.
 *                              append 4 fields in dev_hdr: width, hight,
 *                              chg_flg, and nuldev_flg.
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           long32, for parameter
 *                              4) introduce ATTRIBUTE_SET & TYPE_SET
 *                  7/22/88     rename init_Intel786 to init_physical (Y.C.)
 *      3.0         8/13/88     @SCAN_EHS: scan conversion enhancement
 *                              delete clip_et, clip_xt, fill_et, fill_ht
 *                  11/24/88    add GRAYUNIT & GRAYSCALE; value of transfer
 *                              is "* 16384" instead of "* 4096"
 *                  11/29/88    @ET: update edge_table structure
 *                              1) add edge_ptr structure
 *                              2) delete shape_et, shape_xt, shape_ht_first
 *                              3) delete init_edgetable()
 *                  8/22/89     init_gstack(): initialize device width &
 *                              height at depth 0 of graphics stack for
 *                              robustness.
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  12/4/90     @CPPH: init_pathtable(): Initialize cp_path to
 *                              be NULLP at system initializaton.
 *                  3/19/91     init_graphics(): call op_clear to clear stack
 *                              init_graytable(): directly init. gray_table,
 *                              not go through interpreter.
 *                  11/23/91    upgrade for higher resolution @RESO_UPGR
 *
 *    04-07-92   SCC   Add global allocate for gs_stack & gray_may tables
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include <math.h>
#include <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "graphics.def"

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
static void near init_pathtable(void);
static void near init_nodetable(void);
static void near init_gstack(void);
static void near init_graytable(void);
static void near alloc_memory(void);
#else
static void near init_pathtable();
static void near init_nodetable();
static void near init_gstack();
static void near init_graytable();
static void near alloc_memory();
#endif

extern real32 FAR * gray_map;    /* global allocate for image.c @WIN */

/***********************************************************************
 * Called once by initerpreter at system start-up time to initialize
 * tables.
 *
 * TITLE:       init_graphics
 *
 * CALL:        init_graphics()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void FAR init_graphics()
{
        /* allocate memory(fardata) for graphics tables */
        alloc_memory();

        current_save_level = 0;
        /* opnstktop = 0; scchen; 3/19/91 */
        op_clear();

        /* init. graphics tables */
        init_pathtable();
        init_nodetable();
        init_gstack();
        init_graytable();
        init_physical();
        init_halftone();

        op_initgraphics();
}


/**********************************************************************
 * Allocate space for tables.
 *
 * TITLE:       alloc_memory
 *
 * CALL:        alloc_memory()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near alloc_memory()
{
        path_table = (struct ph_hdr far *)
                     fardata((ufix32)(MAXGSL * sizeof(struct ph_hdr)));
        node_table = (struct nd_hdr far *)
                     fardata((ufix32)(MAXNODE * sizeof(struct nd_hdr)));
        edge_table = (struct edge_hdr far *)
                     fardata((ufix32)(MAXEDGE * sizeof(struct edge_hdr)));
        isp_table = (struct isp_data FAR *) edge_table; /* 3-16-91, Jack */
        last_isp_index = ((MAXEDGE * sizeof(struct edge_hdr)) / sizeof (struct isp_data)) - 1; /* 3-16-91, Jack */
        edge_ptr   = (struct edge_hdr far * far *)
                     fardata((ufix32)(MAXEDGE * sizeof(struct edge_hdr far *)));
        gray_table = (struct gray_hdr far *)
                     fardata((ufix32)(MAXGRAY * sizeof(struct gray_hdr)));
        spot_table = (ufix16 far *)
                     fardata((ufix32)(MAXSPOT * sizeof(ufix16)));
        gray_chain = (struct gray_chain_hdr far *)
                     fardata((ufix32)(MAXGRAYVALUE *
                     sizeof(struct gray_chain_hdr)));

        /* Global allocate for gs_stack & gray_map; @WIN */
        gs_stack = (struct gs_hdr far *)  /* takes from graphics.def */
                     fardata((ufix32)(MAXGSL * sizeof(struct gs_hdr)));
        gray_map = (real32 FAR *)         /* takes from image.c */
                     fardata((ufix32)(256 * sizeof(real32)));
}



/***********************************************************************
 * To initialize path-table.
 *
 * TITLE:       init_pathtable
 *
 * CALL:        init_pathtable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_pathtable()
{
        struct ph_hdr FAR *path;        /* @WIN */

        path = &path_table[0];
        path->rf = 0;
        path->flat = zero_f;
        path->head = path->tail = NULLP;
        path->previous = NULLP;
        path->cp_path = NULLP;          /* @CPPH */
}


/***********************************************************************
 * To initialize node-table.
 *
 * TITLE:       init_nodetable
 *
 * CALL:        init_nodetable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_nodetable()
{
        ufix  i;

        for(i=0; i<MAXNODE; i++) node_table[i].next = i + 1;
        node_table[MAXNODE-1].next = NULLP;
        freenode_list = 0;
}


/***********************************************************************
 * To initialize graphics-stack.
 *
 * TITLE:       init_gstack
 *
 * CALL:        init_gstack()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_gstack()
{
        GSptr = gs_stack;

        GSptr->path = 0;
        GSptr->clip_path.head = NULLP;
        GSptr->clip_path.tail = NULLP;
        GSptr->clip_path.inherit = FALSE;

        /* The following codes are to set up default graphics state.
         * It may be redundent, since at start-up time there is a PostScript
         * procedure to be loaded in the system for setting up the default
         * graphics state
         */

        /* set default CTM */
        GSptr->device.default_ctm[0] = (real32)(300. / 72.);
        GSptr->device.default_ctm[1] = (real32)0.0;
        GSptr->device.default_ctm[2] = (real32)0.0;
        GSptr->device.default_ctm[3] = (real32)(-300. / 72.);
        GSptr->device.default_ctm[4] = (real32)(-75.0);
        GSptr->device.default_ctm[5] = (real32)3268.0;

        GSptr->device.default_clip.lx = 0;
        GSptr->device.default_clip.ly = 0;
        /* @RESO_UPGR
        GSptr->device.default_clip.ux = 2399*8;
        GSptr->device.default_clip.uy = 3235*8;
        */
        GSptr->device.default_clip.ux = 2399 * ONE_SFX;
        GSptr->device.default_clip.uy = 3235 * ONE_SFX;

        GSptr->device.width  = 2400;            /* 8/22/89 */
        GSptr->device.height = 3236;            /* 8/22/89 */

        GSptr->device.chg_flg = TRUE;           /* @DEVICE */
        GSptr->device.nuldev_flg = NULLDEV;     /* 8-1-90 Jack Liaw */

        create_array(&GSptr->device.device_proc, 0);
        ATTRIBUTE_SET(&GSptr->device.device_proc, EXECUTABLE);

        GSptr->color.adj_gray = 0;       /* 9/22/1987 */
        GSptr->color.gray = (real32)0.0;
        TYPE_SET(&GSptr->font, NULLTYPE);
        GSptr->halftone_screen.chg_flag = TRUE;
        GSptr->halftone_screen.freq = (real32)60.0;
        GSptr->halftone_screen.angle = (real32)45.0;
        GSptr->halftone_screen.no_whites = -1;

        create_array(&GSptr->halftone_screen.proc, 0);
        ATTRIBUTE_SET(&GSptr->halftone_screen.proc, EXECUTABLE);

        GSptr->halftone_screen.spotindex = 0;

        create_array(&GSptr->transfer, 0);
        ATTRIBUTE_SET(&GSptr->transfer, EXECUTABLE);
        GSptr->flatness = (real32)1.0;

        /* dash pattern */
        GSptr->dash_pattern.pat_size = 0;       /* no dash pattern */
        GSptr->dash_pattern.dpat_on = TRUE;     /* solid line */

        /* gray mode 7-26-90 Jack Liaw */
        GSptr->graymode = FALSE;
        GSptr->interpolation = FALSE;
}

/***********************************************************************
 *
 * TITLE:       init_graytable
 *
 * CALL:        init_graytable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_graytable()
{
        fix     i;
        real32  tmp;

        for(i = 0; i < 256; i++){
           tmp = (real32)(i/255.);
           gray_table[GSptr->color.adj_gray].val[i] = (fix16)(tmp * GRAYSCALE);
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\savetpzd.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 * This file contains routines to save a trapezoid as new clippath or
 * stroe in command buffer for performing scan conversion and rendering
 * rendering the image by the lower level graphics primitives.
 *
 *      Name:       savetpzd.c
 *
 *      Purpose:
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         8/13/88     Scan conversion enhancement :
 *                              This file is to replace the original "gfill.c"
 *                              for scan conversion enhancement.
 *                  10/18/88    source file reorganization for saving trapezoids
 *                              in command buffer instead of scanlines, i.e.
 *                              defer scan conversion at lower level graphics
 *                              primitives:
 *                              split scanconv.c => savetpzd.c & fillgb.c
 *                              savetpzd -- save trapezoid in command buffer
 *                              fillgb   -- perform scan conversion
 *                  11/09/88    modify save_tpzd for checking if the format of
 *                              the trapezoid is correct; Temp. solution, should
 *                              be revised later
 *                  1/12/89     modify save_tpzd(): not need to truncate
 *                              endpoints to pixels
 *                  1/25/89     save_tpzd(): expand bounding box of trapezoid :
 *                              get floor of topy & ceil of btmy
 *                  11/19/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include        <math.h>
#include        <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "font.h"
#include "font.ext"

static struct  tpzd_info near fill_info;

/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near add_clip (struct tpzd FAR *);

#else
/* for no type checks of the parameters in function declarations */
static void near add_clip ();
#endif


/***********************************************************************
 * According to the type(fill_destination), this routine appends the input
 * trapezoid to current clip path, or calls lower level graphics primitives
 * fill_tpzd to render it to appropriate destination(cache, page, mask, or
 * seed pattern).
 *
 * TITLE:       save_tpzd
 *
 * CALL:        save_tpzd(tpzd)
 *
 * PARAMETERS:
 *              tpzd: a trapezoid
 *
 *              global variable: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *                      SAVE_CLIP  -- save the tpzd as a new clip path
 *
 * INTERFACE:
 *
 * CALLS:       fill_tpzd
 *
 * RETURN:      None
 **********************************************************************/
void save_tpzd(tpzd)
struct tpzd FAR *tpzd;
{

        /* fix     lx, ux; */
        sfix_t  lx, ux; /* @RESO_UPGR */

#ifdef DBG
        printf("save_tpzd(): dest=%d\n\ttpzd=\n", fill_destination);
        printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
        printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif

        /* modify trapezoid if it is generated by shape_reduction incorrectly.
         * for error recovery
         */
        if (tpzd->topxl > tpzd->topxr) {
#ifdef DBGwarn
                printf("\07save_tpzd() error!");
                printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                        SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
                printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                        SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif
                tpzd->topxl = tpzd->topxr;
        }

        /* save to current clip path */
        if (fill_destination == SAVE_CLIP) {
                add_clip(tpzd);
                return;
        }

        /* set bounding box of the trapezoid, used for lower level graphics
         * primitives
         */
        if (fill_destination == F_TO_CACHE) {
                /* bounding box is defined by cache mechanism */
                fill_info.BMAP = cache_info->bitmap;
                fill_info.box_w = cache_info->box_w;
                fill_info.box_h = cache_info->box_h;
        } else {
                lx = (tpzd->topxl < tpzd->btmxl) ? tpzd->topxl : tpzd->btmxl;
                ux = (tpzd->topxr > tpzd->btmxr) ? tpzd->topxr : tpzd->btmxr;
                lx = SFX2I_T(lx);  /* be consistent with gp_scanconv 2/12/92 */
                ux = SFX2I_T(ux);  /* be consistent with gp_scanconv 2/12/92 */
                fill_info.BOX_X = ALIGN_L(lx);
                fill_info.BOX_Y = SFX2I_T(tpzd->topy);  /* 1/25/89 */
                fill_info.box_w = ALIGN_R(ux) - fill_info.BOX_X + 1;
                /* fill_info.box_h = SFX2I(tpzd->btmy - tpzd->topy) + 1; */
                fill_info.box_h = SFX2I_T(tpzd->btmy + ONE_SFX - 1)
                                  - fill_info.BOX_Y + 1; /* 1/25/89 */
        }

        fill_tpzd (fill_destination, &fill_info, tpzd);

}


/***********************************************************************
 * Appends the input trapezoid to the new_clip structure. The new_clip is a
 * global variable, initialized by op_clip and op_eoclip, and will be set as
 * the new clip path in the graphics state after it has been set up.
 *
 * TITLE:       add_clip
 *
 * CALL:        add_clip(tpzd)
 *
 * PARAMETERS:
 *              tpzd: a trapezoid
 *
 *              global variable: new_clip, to save the new clip path
 *
 * INTERFACE:   Save_tpzd
 *
 * CALLS:       None
 *
 * RETURN:      None
 **********************************************************************/
static void near add_clip (tpzd)
struct tpzd FAR *tpzd;
{
        CP_IDX edge;
        struct nd_hdr FAR *ep;

        /* get a node */
        edge = get_node();
        if(edge == NULLP) {     /* 05/07/91, Out of node table */
                ERROR(LIMITCHECK);
                return;
        }
        ep = &node_table[edge];

        /* set up a new clip trapezoid */
        ep->CP_TOPY = tpzd->topy;
        ep->CP_TOPXL = tpzd->topxl;
        ep->CP_TOPXR = tpzd->topxr;
        ep->CP_BTMY = tpzd->btmy;
        ep->CP_BTMXL = tpzd->btmxl;
        ep->CP_BTMXR = tpzd->btmxr;
        if(new_clip.head == NULLP)
                new_clip.head = edge;
        else
                node_table[new_clip.tail].next = edge;
        new_clip.tail = edge;

        /* update bounding box of new_clip */
        if (ep->CP_TOPY < new_clip.bb_ly)
                new_clip.bb_ly = ep->CP_TOPY;
        if (ep->CP_TOPXL < new_clip.bb_lx)
                new_clip.bb_lx = ep->CP_TOPXL;
        if (ep->CP_TOPXR > new_clip.bb_ux)
                new_clip.bb_ux = ep->CP_TOPXR;
        if (ep->CP_BTMY > new_clip.bb_uy)
                new_clip.bb_uy = ep->CP_BTMY;
        if (ep->CP_BTMXL < new_clip.bb_lx)
                new_clip.bb_lx = ep->CP_BTMXL;
        if (ep->CP_BTMXR > new_clip.bb_ux)
                new_clip.bb_ux = ep->CP_BTMXR;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\shape.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   shape.c
 *
 *      Purpose: This file contains the following major modules:
 *               1) shape_approximation -- approximate current path if it
 *                  contains some curves, and set up edge table for shape_
 *                  reduction,
 *               2) shape_reduction -- reduce current path into a set of
 *                  trapezoids,
 *               3) convex_clipper -- clip a convex polygon against current
 *                  clip path, which is a set of trapezoids
 *               4) pgn_reduction -- reduce a clockwised polygon into a set
 *                  of trapezoids
 *
 *      Developer:      S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *
 *                  04/11/90    cross_with_horiz_line(): Fixed bug; set them as
 *                              cross points when the intersect points are same;
 *                              not need to be identical edges.
 *                  03/26/91    convex_clipper(): fix bug for very sharp clipping
 *                              triangle for case "doesall.cap".
 *                  04/17/91    change scany_table size from MAXEDGE(1500) to
 *                              2000.
 *                  04/19/91    Add a shell sort to replace quick sort for
 *                              sorintg edge_table; @SH_SORT
 *                  04/30/91    cross_with_horiz_line(): fix bug of shape
 *                              reduction for case "train.ps"
 *                  11/18/91    Add check node after get node and fix circle
 *                              at bottom coner ref: CNODE
 *                              Add fix very large circle for example:
 *                              "30000 30000 10000 0 360 arc fill"
 *                              We don't recommand to do this, but we keep the
 *                              code there. ref : @LC
 *                  11/18/91    upgrade for higher resolution @RESO_UPGR
 ***********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* -------------------- macro definition -------------- */

/* @INSIDE1 */
#define IN_CLIP 1
#define ON_CLIP -1
#define OUT_CLIP 0

/* -------------------- static function declartion ----------------- */
#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static bool near page_inside (struct coord, fix);
static struct coord * near page_intersect (struct coord,
                            struct coord, fix);
static struct edge_hdr FAR * near put_edge_table (sfix_t, sfix_t, sfix_t, sfix_t);
static void near sort_edge_table(void);     /* @ET */
static void near qsort (fix, fix);          /* @ET */
static void near shellsort(fix);        /* @SH_SORT */
static void near setup_intersect_points(void);      /* @ET; @WIN; prototype */
static void near put_in_xpnt_table(sfix_t, sfix_t, struct edge_hdr FAR *,
                                   struct edge_hdr FAR *);
static void near put_in_scany_table(sfix_t);    /* @XPNT */
static void near sort_scany_table(void);        /* @XPNT */
static void near scany_qsort (fix, fix);        /* @XPNT */
static void near horiz_partition (ufix);
static fix near cross_with_horiz_line (sfix_t);         /* @ET */
static void near set_wno (ufix);        /* @ET */
static void near get_pairs (sfix_t, fix);       /* @ET */
static void near degen_tpzd (sfix_t, sfix_t, sfix_t);   /* @ET */
static void near find_trapezoid (sfix_t, sfix_t, sfix_t, struct edge_hdr FAR *,
                                 struct edge_hdr FAR *);
static bool near inside(struct coord_i, fix);      /* @INSIDE */
static struct coord_i * near intersect (struct coord_i, struct coord_i,
                              fix);             /* @INSIDE */

#else

/* for no type checks of the parameters in function declarations */
static bool near page_inside ();
static struct coord * near page_intersect ();
static struct edge_hdr FAR * near put_edge_table (); /*@ET*/
static void near sort_edge_table();     /* @ET */
static void near qsort ();          /* @ET */
static void near shellsort();           /* @SH_SORT */
static void near setup_intersect_points();
static void near put_in_xpnt_table();
static void near put_in_scany_table();
static void near sort_scany_table();    /* @XPNT */
static void near scany_qsort ();        /* @XPNT */
static void near horiz_partition ();
static fix near cross_with_horiz_line ();
static void near set_wno ();
static void near get_pairs ();
static void near degen_tpzd ();                /* @ET */
static void near find_trapezoid ();
static bool near inside();
static struct coord_i * near intersect ();

#endif

/* ------------------------ static variables --------------------- */
struct clip_region {
            struct coord_i cp;
};                                              /* @INSIDE */
static struct clip_region clip[5];

static fix et_start, et_end, et_first, et_last;         /* @ET */
static fix xt_start, xt_end, xt_first;                  /* @ET */
/*
 * et_start   et_first    et_last    et_end   xt_end     xt_first    xt_start
 *    +-------------------------------+--------+---------------------------+
 *    |   |   |   |   |   |   |   |   | (free) |   |   |   |   |   |   |   |
 *    +-------------------------------+--------+---------------------------+
 *    0  ===> (et table grow)                      (xt table grow) <==== MAXEDGE
 */

/* distinct y-coord of endpoints (or intersect points) of edges @XPT */
/* static sfix_t scany_table[2000];        |* 04/17/91  phchen */
#define SCANY_TABLE_SZ 2000
static sfix_t scany_table[SCANY_TABLE_SZ];      /* @RESO_UPGR */
static fix st_end, st_first;

fix QSORT = 0;      /* for debugging; @SH_SORT */



//#define DBG1
//#define DBG2


/***********************************************************************
 * Given a subpath, a list of vertices, this module traverses it,
 * converts curves into lines, and places all edges to edge_table and
 * endpoint to cross-point-table(xpnt_table).
 * All the coordinates are under short fixed points domain. If the coordinate
 * is outside the domain it will be pre-clipped against a rectangle that covers
 * entire short fixed point domain.
 *
 * TITLE:       shape_approximation
 *
 * CALL:        shape_approximation (isubpath, param)
 *
 * PARAMETERS:  isubpath -- index to node_table, the header of
 *                          the input subpath(a list of vertices).
 *
 * INTERFACE:   op_clip, op_eoclip, op_fill, op_eofill, linejoin,
 *              linecap
 *
 * CALLS:       flatten_subpath, put_edge_table, put_in_scany_table
 *
 * RETURN:      none
 **********************************************************************/
void shape_approximation (isubpath, param)
SP_IDX isubpath;
fix FAR *   param;
{
        sfix_t  last_x, last_y, cur_x, cur_y;
        sfix_t  first_x, first_y;                       /* @ET */

        VX_IDX  ivtx, iflt_vtx;
        struct  nd_hdr FAR *vtx, FAR *fvtx;
        /* struct  vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct  nd_hdr FAR *sp;             /* TRVSE */

        VX_IDX  first_vertex;
        struct  edge_hdr FAR *first_edge, FAR *cur_edge, FAR *last_edge;
        bool    first_flag = TRUE;

/* @FCURVE --- BEGIN */
        sfix_t  x3, y3, x4, y4;
        struct  nd_hdr FAR *node;
        VX_IDX  inode, vlist_head;
        lfix_t flat;
/* @FCURVE --- END */

#ifdef DBG1
        printf("Shape_approximation():\n");
        dump_all_path (isubpath);
#endif

        sp = &node_table[isubpath];

        /* flatten the subpath before shape-approximation @PRE_CLIP @TRVSE */
        if (!(sp->SP_FLAG&SP_CURVE)) {         /* subpath contains no curves */
                /* iflt_vtx = sp->SP_HEAD; @NODE */
                iflt_vtx = isubpath;
        } else {

/* @FCURVE --- BEGIN */
#ifdef XXX
                /* vlist = flatten_subpath (sp->SP_HEAD, @NODE */
                vlist = flatten_subpath (isubpath,
                        F2L(GSptr->flatness));
                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return;
                }
                /* iflt_vtx = vlist->head; @NODE */
                iflt_vtx = vlist;
#endif
                iflt_vtx = isubpath;
                flat = F2LFX(GSptr->flatness);
/* @FCURVE --- END */

        }

        /* pre-clip subpath into page boundary @PRE_CLIP @TRVSE */
        if (!(sp->SP_FLAG & SP_OUTPAGE)) {      /* inside page boundary */
                first_vertex = iflt_vtx;
        } else {
            /* flatten curves before calling page_clipper() 11/18/91 CNODE */
                if (sp->SP_FLAG&SP_CURVE) {  /* subpath contains curves */
                   vlist = flatten_subpath (isubpath, F2L(GSptr->flatness));
                   if( ANY_ERROR() == LIMITCHECK ){
                      extern SP_IDX iron_subpath(VX_IDX); /* @WIN prototype */
                          free_node (vlist);
                          /*  return;             @LC 11/18/91 */
                          CLEAR_ERROR();                    /* @LC */
                          vlist = iron_subpath (isubpath);  /* @LC */
                          if( ANY_ERROR() == LIMITCHECK ){  /* @LC */
                                  free_node (vlist);        /* @LC */
                                  return;                   /* @LC */
                          }                                 /* @LC */
                   }
                   iflt_vtx = vlist;
                }
                first_vertex = page_clipper (iflt_vtx);
                if( ANY_ERROR() == LIMITCHECK || first_vertex == NULLP){ /* 11/18/91 CNODE */
                        /* @NODE
                         *if(sp->SP_FLAG&SP_CURVE) free_node (vlist->head);
                         */
/* @FCURVE --- BEGIN */
/*                      if(sp->SP_FLAG&SP_CURVE) free_node (vlist); */
/* @FCURVE --- END */
                        return;
                }
#ifdef DBG2
                /* @NODE
                 * printf("After page_clipper, original subpath =\n");
                 * ivtx = get_node();
                 * node_table[ivtx].next = NULLP;
                 * node_table[ivtx].SP_HEAD =node_table[ivtx].SP_TAIL =iflt_vtx;
                 * dump_all_path (ivtx);
                 */
                dump_all_path (iflt_vtx);

                printf(" new subpath =\n");
                /* @NODE
                 * node_table[ivtx].SP_HEAD = node_table[ivtx].SP_TAIL =
                 *                            first_vertex;
                 * dump_all_path (ivtx);
                 * free_node (ivtx);
                 */
                dump_all_path (first_vertex);
#endif
        }

        /* just return if the whole path has been clipped out 2/5/88 */
        if (first_vertex == NULLP) return;

        /* initialization */
        fvtx = &node_table[first_vertex];

        /* Traverse each edge of the path, and convert it to
         * edge_table
         */
        for (ivtx=first_vertex; ivtx!=NULLP; ivtx=vtx->next) {

                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {

                case MOVETO :
                case PSMOVE :
                      cur_x = F2SFX (vtx->VERTEX_X);  /* rounding for qty */
                      cur_y = F2SFX (vtx->VERTEX_Y);
                      first_x = cur_x;          /* @ET */
                      first_y = cur_y;
                      break;

                case LINETO :
                      cur_x = F2SFX (vtx->VERTEX_X);    /* @PRE_CLIP */
                      cur_y = F2SFX (vtx->VERTEX_Y);

                      cur_edge = put_edge_table(last_x, last_y, cur_x, cur_y);
                                                /* @SCAN_EHS, delete action */
                      if (first_flag) {                 /* @XPNT_TBL */
                          first_edge = cur_edge;
                          first_flag = FALSE;
                      } else {
                          /* @XPNT
                           * put_in_xpnt_table (last_x, last_y, last_edge,
                           *      cur_edge);   (* @ET ,&shape_xt.first); *)
                           */
                      }
                      break;

/* @FCURVE --- BEGIN */
                case CURVETO :
                    cur_x = F2SFX (vtx->VERTEX_X);
                    cur_y = F2SFX (vtx->VERTEX_Y);

                    /* Get next two nodes: x3, y3, x4, y4 */
                    vtx = &node_table[vtx->next];
                    x3 = F2SFX(vtx->VERTEX_X);
                    y3 = F2SFX(vtx->VERTEX_Y);
                    vtx = &node_table[vtx->next];
                    x4 = F2SFX(vtx->VERTEX_X);
                    y4 = F2SFX(vtx->VERTEX_Y);

                    vlist_head = bezier_to_line_sfx(flat, last_x, last_y,
                              cur_x, cur_y, x3, y3, x4, y4);

                    for (inode = vlist_head; inode != NULLP;
                        inode = node->next) {
                        node = &node_table[inode];

                        cur_x = node->VXSFX_X;
                        cur_y = node->VXSFX_Y;

#ifdef DBG
                        printf("%f %f clineto\n", SFX2F(cur_x), SFX2F(cur_y));
#endif

                        cur_edge = put_edge_table(last_x, last_y, cur_x, cur_y);
                        if (first_flag) {
                            first_edge = cur_edge;
                            first_flag = FALSE;
                        }
                        last_x = cur_x;
                        last_y = cur_y;
                        last_edge = cur_edge;

                        /* put y-coord in scany_table @XPNT */
                        put_in_scany_table (cur_y);

                    } /* for */

                    /* free vlist */
                    free_node (vlist_head);
                    break;
/* @FCURVE --- END */

                case CLOSEPATH :
                      goto close_edge;          /* @PRE_CLIP */

#ifdef DBGwarn
                default :
                    printf("\007Fatal error, shape_approximation(): node type =%d\n",
                           vtx->VX_TYPE);
#endif

                } /* switch */

                last_x = cur_x;
                last_y = cur_y;
                last_edge = cur_edge;   /* @XPNT_TBL */

                /* put y-coord in scany_table @XPNT */
                put_in_scany_table (cur_y);

        } /* for loop */

        /* Put close edge into edge_table if it is an open subpath */
close_edge:
        /* if ((fvtx->next != NULLP) &&
         *   (node_table[fvtx->next].VX_TYPE != CLOSEPATH)) {
         */
        /* should not contain only a MOVETO node, but if there are a MOVETO
         * and a CLOSEPATH then need to fill it.        1/10/89
         */
        if (fvtx->next != NULLP) {
                /* add a edge from first point to last point 1/10/89 */
                if (node_table[fvtx->next].VX_TYPE == CLOSEPATH) {
                    last_x++;
                    last_edge = first_edge = put_edge_table (first_x, first_y,
                        last_x, last_y);
                }

                cur_edge = put_edge_table (last_x, last_y,
                       first_x, first_y);

                /* @XPNT
                 * put_in_xpnt_table (last_x, last_y, last_edge, cur_edge);
                 * put_in_xpnt_table (first_x, first_y, cur_edge, first_edge);
                 */
        }

        /* release temp. subpaths @PRE_CLIP @TRVSE */
/* @FCURVE --- BEGIN */
/*      if (sp->SP_FLAG&SP_CURVE) {
 *              free_node (iflt_vtx);
 *      }
 */
/* @FCURVE --- END */
        if (sp->SP_FLAG&SP_OUTPAGE) {
                free_node (first_vertex);
                if (sp->SP_FLAG&SP_CURVE)   /* 11/18/91 CNODE */
                    free_node (vlist);
        }

#ifdef DBG2
        printf(" edge_list(after shape_approximation)-->\n");
        dump_all_edge (et_start, et_end);
#endif

}


void init_edgetable ()
{
        et_start = 0;
        et_end = -1;
        xt_start = MAXEDGE - 1;
        xt_end = MAXEDGE;
        st_end = -1;            /* @XPNT */
}

/***********************************************************************
 * Given a list of vertices, this routine clip it against a rectangle
 * that covers the entire short fixed point domain.
 *
 * TITLE:       page_clipper
 *
 * CALL:        page_clipper(ifvtx)
 *
 * PARAMETERS:  ifvtx -- index to node_table, the first vertex of
 *                       the input subpath(a list of vertices).
 *
 * INTERFACE:   shape_approximation
 *
 * CALLS:       page_inside, page_intersect
 *
 * RETURN:      a list of vertices
 **********************************************************************/
VX_IDX page_clipper (ifvtx)               /* 1/5/88 */
VX_IDX  ifvtx;
{
        fix     cb;     /* clip boundary(top, right, bottom, or left) */
        VX_IDX  head, tail, ivtx, inode;
        struct  nd_hdr  FAR *vtx, FAR *lvtx;
        bool    done;
        struct coord cp, lp, *isect;        /* current point, last point */

        /* copy the original subpath except the closepath node */
        inode = get_node();
        if (inode == NULLP) {                   /* 9/14/91 CNODE */
            ERROR(LIMITCHECK);
            return(NULLP);
        }
        node_table[inode] = node_table[ifvtx];
        head = tail = inode;
        for (ivtx = node_table[ifvtx].next; ivtx != NULLP;
                ivtx = node_table[ivtx].next) {
                if (node_table[ivtx].VX_TYPE == CLOSEPATH) break;
                                        /* skip close node */
                inode = get_node();
                if (inode == NULLP) {                   /* 9/14/91 CNODE */
                    ERROR(LIMITCHECK);
                    node_table[tail].next = NULLP;
                    free_node(head);
                    return(NULLP);
                }
                node_table[inode] = node_table[ivtx];
                node_table[tail].next = inode;
                tail = inode;
        }  /* for */
        node_table[tail].next = NULLP;

        /* clip subject to each clip boundary of the page */
        for (cb = 0; cb < 4; cb++) {    /* top, right, bottom, left */

            done = FALSE;
            lp.x = node_table[head].VERTEX_X;
            lp.y = node_table[head].VERTEX_Y;
            lvtx = &node_table[head];
            /* for each edge of subject(in_polygon) */
            for (ivtx = node_table[head].next; !done; ivtx = vtx->next) {
                if (ivtx == NULLP) {
                        ivtx = head;
                        done = TRUE;
                }
                vtx = &node_table[ivtx];
                cp.x = vtx->VERTEX_X;
                cp.y = vtx->VERTEX_Y;

                if (page_inside(cp, cb)) {

                    if (page_inside(lp, cb)) {
                            /* inside -> inside */
                            /* reserve original node */
                    } else {     /* outside -> inside */
                            /* output intersect point */
                            isect = page_intersect (lp, cp, cb);

                            /* preppend a node */
                            inode = get_node();
                            if (inode == NULLP) {
                                ERROR(LIMITCHECK);
                                free_node(head);        /* 9/14/91 CNODE */
                                return(NULLP);
                            }

                            node_table[inode].VERTEX_X = isect->x;
                            node_table[inode].VERTEX_Y = isect->y;
                            node_table[inode].VX_TYPE = LINETO;
                            node_table[inode].next = lvtx->next;
                            lvtx->next = inode;
                    }
                    lp = cp;    /* structure copy */
                } else {
                    if (page_inside(lp, cb)) {
                            /* inside -> outside */
                            /* output intersect point */
                            isect = page_intersect (lp, cp, cb);

                            /* update original node to new intersect node */
                            lp.x = vtx->VERTEX_X;
                            lp.y = vtx->VERTEX_Y;
                            vtx->VERTEX_X = isect->x;
                            vtx->VERTEX_Y = isect->y;


                    } else {    /* outside -> outside */
                            /* delete original node */
                            if (lvtx->next == NULLP) {
                                head = node_table[head].next;
                            } else {
                                lvtx->next = vtx->next;
                            }

                            lp.x = vtx->VERTEX_X;
                            lp.y = vtx->VERTEX_Y;
                            vtx->next = NULLP;
                            free_node(ivtx);
                            vtx = lvtx;
                    }
                }

                lvtx = vtx;

                /* return if the clipped path is empty 2/10/88 */
                if (head == NULLP) return(NULLP);

            } /* for each node of the subject */

#ifdef DBG2
                printf("In page_clipper, phase#%d  subpath =\n", cb);
                /* @NODE
                 * ivtx = get_node();
                 * node_table[ivtx].next = NULLP;
                 * node_table[ivtx].SP_HEAD = node_table[ivtx].SP_TAIL = head;
                 * dump_all_path (ivtx);
                 * free_node (ivtx);
                 */
                dump_all_path (head);
#endif

        } /* for each clip boundary */

        /* set first node being MOVETO node */
        node_table[head].VX_TYPE = MOVETO;
        return(head);
}


/*
 * Check if coordinate p is inside the clipping boundary cb.
 */
static bool near page_inside (p, cb)
struct coord p;
fix     cb;
{
        switch (cb) {
        case 0 :        /* top clip boundary */
                if (p.y >= (real32)PAGE_TOP) return(TRUE);
                else                return(FALSE);

        case 1 :        /* right clip boundary */
                if (p.x <= (real32)PAGE_RIGHT) return(TRUE);
                else                return(FALSE);

        case 2 :        /* bottom clip boundary */
                if (p.y <= (real32)PAGE_BTM) return(TRUE);
                else                return(FALSE);

        case 3 :        /* left clip boundary */
                if (p.x >= (real32)PAGE_LEFT) return(TRUE);
                else                return(FALSE);
        }

        // this should never happen!
        return(FALSE);
}


/*
 * Calculate the intersect point of the line(lp, cp) with clipping boundary cb.
 */
static struct coord * near page_intersect ( lp, cp, cb)
struct coord lp, cp;
fix     cb;
{
        static struct coord isect;  /* should be static */

        switch (cb) {
        case 0 :        /* top clip boundary */
                isect.x = lp.x + ((real32)PAGE_TOP - lp.y) *
                                 (cp.x - lp.x) / (cp.y - lp.y);
                isect.y = (real32)PAGE_TOP;
                break;

        case 1 :        /* right clip boundary */
                isect.x = (real32)PAGE_RIGHT;
                isect.y = lp.y + ((real32)PAGE_RIGHT - lp.x) *
                                 (cp.y - lp.y) / (cp.x - lp.x);
                break;

        case 2 :        /* bottom clip boundary */
                isect.x = lp.x + ((real32)PAGE_BTM - lp.y) *
                                 (cp.x - lp.x) / (cp.y - lp.y);
                isect.y = (real32)PAGE_BTM;
                break;

        case 3 :        /* left clip boundary */
                isect.x = (real32)PAGE_LEFT;
                isect.y = lp.y + ((real32)PAGE_LEFT - lp.x) *
                                 (cp.y - lp.y) / (cp.x - lp.x);
        }

        return (&isect);

}

/*
 * Some tricky routines to check if coordinates outside the boundary of SFX
 * format                                                        @OUT_PAGE
 */
bool too_small(f)
long32 f;
{
        ufix32 i;

        if (!SIGN(f)) return(FALSE);

        i = EXP(f);
/*      if ((i > 0x45800000L) || ((i == 0x45800000L) && MAT(f)))
                return (TRUE);          |* f < -4096 */
        if ((i > PG_CLP_IEEE) || ((i == PG_CLP_IEEE) && MAT(f)))
                return (TRUE);          /* @RESO_UPGR */
        return(FALSE);
}

bool too_large(f)
long32 f;
{
        ufix32 i;

        if (SIGN(f)) return(FALSE);

        i = EXP(f);
/*      if ((i > 0x45000000L) || ((i == 0x45000000L) && (MAT(f) > 0x7ff000)))
                return (TRUE);          |* f > 4095 */
        if ((i > PG_CLP_HALF_IEEE) ||
                ((i == PG_CLP_HALF_IEEE) && (MAT(f) > 0x7ff000)))
                return (TRUE);          /* @RESO_UPGR */
        return(FALSE);
}

bool out_page(f)
long32 f;
{
        ufix32 i;

        i = EXP(f);
        if (SIGN(f)) {  /* negtive */
                /* if ((i > 0x45800000L) || ((i == 0x45800000L) && MAT(f)))
                        return (TRUE);          |* f < -4096 */
                if ((i > PG_CLP_IEEE) || ((i == PG_CLP_IEEE) && MAT(f)))
                        return (TRUE);          /* @RESO_UPGR  */
        } else {
                /* if ((i > 0x45000000L) || ((i == 0x45000000L) && (MAT(f) > 0x7ff000)))
                        return (TRUE);          |* f > 4095 */
                if ((i > PG_CLP_HALF_IEEE) ||
                        ((i == PG_CLP_HALF_IEEE) && (MAT(f) > 0x7ff000)))
                        return (TRUE);          /* @RESO_UPGR */
        }
        return(FALSE);
}



/***********************************************************************
 * Depending on whether the given edge is horizontal, this module puts
 * the edge into edge_table in y_coordinates non_decreasing order.
 *
 * TITLE:       put_edge_table
 *
 * CALL:        put_edge_table(x0, y0, x1, y1)
 *
 * PARAMETERS:  x0, y0  -- starting point of edge
 *              x1, y1  -- ending point of edge
 *
 * INTERFACE:   shape_approximation
 *
 * CALLS:       none
 *
 * RETURN:      edge -- generated edge
 **********************************************************************/
static struct edge_hdr FAR * near put_edge_table (x0, y0, x1, y1)
sfix_t  x0, y0, x1, y1; /* @SCAN_EHS, delete action */
{
        struct  edge_hdr FAR *ep;

        /* Remove the degenerate edge */
        if((x0==x1) && (y0==y1)) return((struct edge_hdr FAR *) -1);

        /* allocate an entry of edge_table @ET */
        if (++et_end >= xt_end) {
                ERROR(LIMITCHECK);
                return((struct edge_hdr FAR *) -1);
        }
        ep = &edge_table[et_end];
        edge_ptr[et_end] = ep;
        ep->ET_FLAG = 0;        /* init */

        /* Put edge into edge_table or horiz_table in y_coordnate
         * non_decreasing order
         */
        if (y0 == y1) {         /* horizontal edge */

                ep->HT_Y = ep->ET_ENDY = y0;            /* ??? */
                if (x0 > x1) {
                        ep->HT_XR = x0;
                        ep->HT_XL = x1;
                } else {
                        ep->HT_XR = x1;
                        ep->HT_XL = x0;
                }

                /* set flag of horizontal edge @ET */
                ep->ET_FLAG |= HORIZ_EDGE;

        } else {
                /* Construct an entry of edge_table */
                if (y0 > y1) {
                    ep->ET_TOPY = ep->ET_LFTY = y1;
                    ep->ET_XINT = ep->ET_TOPX = ep->ET_LFTX = ep->ET_RHTX = x1;
                                                                /* @SRD */
                    ep->ET_ENDY = y0;
                    ep->ET_ENDX = x0;
                    ep->ET_FLAG |= WIND_UP;
                } else {
                    ep->ET_TOPY = ep->ET_LFTY = y0;
                    ep->ET_XINT = ep->ET_TOPX = ep->ET_LFTX = ep->ET_RHTX = x0;
                                                                /* @SRD */
                    ep->ET_ENDY = y1;
                    ep->ET_ENDX = x1;

                    ep->ET_FLAG &= ~WIND_UP;
                }

                /* set flag of horizontal edge @ET */
                ep->ET_FLAG &= ~HORIZ_EDGE;

        }
        return(ep);             /* @ET: et */
}



/*
 * sort edge_table: et_start => et_end
 */
static void near sort_edge_table()
{
        /* initialization for quick sort */
        if (et_end+1 >= xt_end) {
                ERROR(LIMITCHECK);
                return;
        }
        edge_table[et_end+1].ET_TOPY = MAX_SFX;  /* Important !!! */
        edge_ptr[et_end+1] = &edge_table[et_end+1];     /* 12/30/88 */

        if (QSORT)                  /* @SH_SORT */
            qsort (et_start, et_end);
        else
            shellsort(et_end+1);
}

/*
 * quick sort
 */
static void near qsort (m, n)
fix     m, n;
{
        fix     i, j;
        sfix_t  key;
        register struct edge_hdr far *t;        /* for swap */

        if (m < n) {
                i = m;
                j = n + 1;
                key = edge_ptr[m]->ET_TOPY;
                while(1) {
                        for (i++;edge_ptr[i]->ET_TOPY < key; i++);
                        for (j--;edge_ptr[j]->ET_TOPY > key; j--);
                        if (i < j) {
                                /* swap (i, j); */
                                t = edge_ptr[i];
                                edge_ptr[i] = edge_ptr[j];
                                edge_ptr[j] = t;
                        } else
                                break;
                }

                /* swap (m, j); */
                t = edge_ptr[m];
                edge_ptr[m] = edge_ptr[j];
                edge_ptr[j] = t;

                qsort (m, j-1);
                qsort (j+1, n);
        }
}

/*
 * shell sort           (* @SH_SORT *)
 */
/*void shellsort (v,n)
 *register int v[], n;
 */
static void near shellsort(n)
register fix n;
{
        register fix gap, i, j;
        register sfix_t temp;   /* @RESO_UPGR */
        register struct edge_hdr far *t;        /* for swap */

        gap = 1;
        do (gap = 3*gap + 1); while (gap <= n);
        for (gap /= 3; gap > 0; gap /= 3)
           for (i = gap; i < n; i++) {
              /*temp = v[i];*/
              temp = edge_ptr[i]->ET_TOPY;
              t = edge_ptr[i];
              /* for (j=i-gap; (j>=0)&&(v[j]>temp); j-=gap)
               *    v[j+gap] = v[j];
               * v[j+gap] = temp;
               */
              for (j=i-gap; (j>=0)&&(edge_ptr[j]->ET_TOPY>temp); j-=gap)
                 edge_ptr[j+gap] = edge_ptr[j];
              edge_ptr[j+gap] = t;
           }
}

/***********************************************************************
 * This module reduces the shape in edge_table to a set of trapezoids,
 * and clips each trapezoid to the current clipping path.
 *
 * TITLE:       shape_reduction
 *
 * CALL:        shape_reduction(winding_type)
 *
 * PARAMETERS:  winding_type -- NON_ZERO/EVEN_ODD
 *
 * INTERFACE:   op_clip, op_eoclip, op_fill, op_eofill, linejoin,
 *              linecap
 *
 * CALLS:       setup_intersect_points, horiz_partition
 *
 * RETURN:      none
 **********************************************************************/
void shape_reduction(winding_type)           /* @SCAN_EHS, delete action */
ufix    winding_type;
{

        /* do nothing for degenerate case, ie. just one point; @WIN */
        if (et_start > et_end) return;

        /* sort edge_table @ET */
        sort_edge_table();
#ifdef DBG1
        printf("After sort_edge_table():\n");
        printf(" et_start=%d, et_end=%d\n", et_start, et_end);
        dump_all_edge (et_start, et_end);
#endif

        /* Split intersecting edges: complicated graph ==> simple graphs */
        setup_intersect_points();

        if ( ANY_ERROR() == LIMITCHECK ) /* 05/07/91, Peter, out of scany_table */
            return;

        /* sort scany_table @XPNT */
        sort_scany_table();

#ifdef DBG1
        {
            fix     ixp;
            struct  edge_hdr FAR *xp;
            printf(" xpnt_table -->\n");
            printf("        X        Y        EDGE1        EDGE2\n");
            for (ixp = xt_start; ixp >= xt_end; ixp--) {
                xp = edge_ptr[ixp];
                printf(" %d)   %f   %f   %lx  %lx\n", ixp, xp->XT_X/8.0,
                        xp->XT_Y/8.0, xp->XT_EDGE1, xp->XT_EDGE2);
            }
            printf(" scany_table -->\n");
            printf("        X        Y        EDGE1        EDGE2\n");
            for (ixp = 0; ixp <= st_end; ixp++) {
                printf(" %d)   %f\n", ixp, SFX2F(scany_table[ixp]));
            }
        }
#endif

        /* partition the shape into a set of trapezoides, and paint or
         * save it due to action
         */
        horiz_partition (winding_type);

}



/***********************************************************************
 * This module splits inter_cross edges in edge_table.
 *
 * TITLE:       setup_intersect_points
 *
 * CALL:        setup_intersect_points()
 *
 * PARAMETERS:
 *
 * INTERFACE:   shape_reduction
 *
 * CALLS:       put_in_xpnt_table
 *
 * RETURN:      none
 **********************************************************************/
static void near setup_intersect_points()
{
        fix     current_edge, cross_edge;   /* @ET: ET_IDX */
        struct  edge_hdr FAR *cp, FAR *xp;

//      ET_IDX   first_horiz, horiz_edge;   /* HORZ_CLIP 3/28/88 */ @WIN
//      struct  edge_hdr FAR *hp;                                   @WIN

        sfix_t      x0, y0, x1, y1, x2, y2, x3, y3;     /* @PRE_CLIP */

        fix32    delta_x1, delta_y1, delta_x2, delta_y2;        /* 1/8/88 */
        fix32    delta_topx, delta_topy;
        sfix_t   int_x, int_y;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32 divider;
        fix32 s1, t1;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], dest3[2], dest4[2], dest5[2], dest6[2], dest7[2];
        long div_dif[2], s1_dif[2], t1_dif[2];
        real32 dividend, divider;
        real32 div_dif_f, s1_dif_f, t1_dif_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2], dest3[2], dest4[2], dest5[2], dest6[2], dest7[2];
        long div_dif[2], s1_dif[2], t1_dif[2];
        real32 dividend, divider;
        real32 div_dif_f, s1_dif_f, t1_dif_f;
#endif
        real32   s;             //@WIN

        /* Initialization */
        et_first = et_start;

        /* Get intersecting points of edges */
        for (current_edge=et_start; current_edge <= et_end; current_edge++) {
            cp = edge_ptr[current_edge];

            /* advance first_edge if it is impossible to intersect
             * with current edge
             */
            while ((et_first < et_end) &&
                   (cp->ET_TOPY >= edge_ptr[et_first]->ET_ENDY)) et_first++;

            /* special processing of horizontal edge(current_edge) @ET */
            if (cp->ET_FLAG & HORIZ_EDGE) {

                /* Get intersect points of current edge(horizontal) with all
                 * edges from et_first to current_edge - 1      @ET
                 */
                for (cross_edge = et_first; cross_edge < current_edge;
                     cross_edge++) {
                        xp = edge_ptr[cross_edge];

                        /* skip horizontal edges @ET */
                        if (xp->ET_FLAG & HORIZ_EDGE) continue;

                        /* Get end points of cross edge */
                        x2 = xp->ET_TOPX;
                        y2 = xp->ET_TOPY;
                        x3 = xp->ET_ENDX;
                        y3 = xp->ET_ENDY;

                        /* skip the horizontal edge if it can not intersect
                         * with current edge
                         */
                        if (((cp->HT_XL >= x2) && (cp->HT_XL >= x3)) ||
                            ((cp->HT_XR <= x2) && (cp->HT_XR <= x3))) {
                                continue;        /* x1 => x3,  1/13/89 */
                        }

                        /*
                         * Find cross point of current_edge and
                         * horizontal edge
                         */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        int_x = x2 + (sfix_t)((fix32)(x3 - x2) * (cp->HT_Y - y2) /
                                     (real32)(y3 - y2));
#elif  FORMAT_16_16
                        LongFixsMul((x3 - x2), (cp->HT_Y - y2), dest1);
                        int_x = x2 + LongFixsDiv((y3 - y2), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((x3 - x2), (cp->HT_Y - y2), dest1);
                        int_x = x2 + LongFixsDiv((y3 - y2), dest1);
#endif
                        if (int_x >= cp->HT_XL && int_x <= cp->HT_XR) {
                                /* put intersect point in xpnt_table */
                                put_in_xpnt_table(int_x, cp->HT_Y, cp, xp);
                                put_in_scany_table(cp->HT_Y);   /* @XPNT */

                        }
                } /* for */

            } else {    /* current edge is non-horizontal edge */

                /* Get end points of current edge */
                x0 = cp->ET_TOPX;
                y0 = cp->ET_TOPY;
                x1 = cp->ET_ENDX;
                y1 = cp->ET_ENDY;

                /* Get intersect points of current edge with all edges from
                 * first_edge to current_edge - 1
                 */
                for (cross_edge = et_first; cross_edge < current_edge;
                     cross_edge++) {
                        xp = edge_ptr[cross_edge];

                        /* skip horizontal edges @ET */
                        if (xp->ET_FLAG & HORIZ_EDGE) continue;

                        /* Get end points of cross edge */
                        x2 = xp->ET_TOPX;
                        y2 = xp->ET_TOPY;
                        x3 = xp->ET_ENDX;
                        y3 = xp->ET_ENDY;

                        /* Skip the edge coincides with current_edge at
                         * end point
                         */
                        if(y3 <= y0) {       /* end point1 < start point2 */
                                continue;
                        } else if ((x2 == x0) && (y2 == y0)) {
                                /* same start point */
                                continue;
                        } else if ((x3 == x1) && (y3 == y1)) {
                                /* same end point */
                                continue;
                        }

                        /*
                         * Find cross point of current_edge and
                         * cross_edge using parametric formula:
                         * current_edge = u + s * delta_u
                         * cross_edge   = v + t * delta_v
                         */

                        delta_x1 = (fix32)x1 - x0;
                        delta_y1 = (fix32)y1 - y0;
                        delta_x2 = (fix32)x3 - x2;
                        delta_y2 = (fix32)y3 - y2;
                        delta_topx = (fix32)x0 - x2;
                        delta_topy = (fix32)y0 - y2;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = (fix32)delta_x1 * delta_y2 -   /* @RPE_CLIP */
                                  (fix32)delta_x2 * delta_y1;

                        /* Collinear edges */
                        if(divider == 0) {               /* @PRE_CLIP */
                                continue;
                        }
#elif  FORMAT_16_16
                        LongFixsMul(delta_x1, delta_y2, dest2);
                        LongFixsMul(delta_x2, delta_y1, dest3);
                        if (dest2[0] == dest3[0] && dest2[1] == dest3[1])
                                continue;
#elif FORMAT_28_4
                        LongFixsMul(delta_x1, delta_y2, dest2);
                        LongFixsMul(delta_x2, delta_y1, dest3);
                        if (dest2[0] == dest3[0] && dest2[1] == dest3[1])
                                continue;
#endif
                        /* Solved parameters */
/* Enhancement of intersection point of line segments 4/19/89
 *
 *                      s = (((fix32)delta_x2 * delta_topy) -
 *                           ((fix32)delta_y2 * delta_topx) ) / (real32)divider;
 *                      t = (((fix32)delta_x1 * delta_topy) -
 *                           ((fix32)delta_y1 * delta_topx) ) / (real32)divider;
 *
 *                      (* Intersect just at one point *)
 *                      if(s>=(real32)0.0 && s<=(real32)1.0 &&
 *                         t>=(real32)0.0 && t<=(real32)1.0) {
 *                              (* Intersection point *)
 *                              int_x =(sfix_t)(x0 + s * delta_x1);
 *                              int_y =(sfix_t)(y0 + s * delta_y1);
 *
 *                              (* put intersect point in xpnt_table *)
 *                              put_in_xpnt_table(int_x, int_y, cp, xp);
 *                              put_in_scany_table(int_y);      (* @XPNT *)
 *
 *                      } (* if *)
 */

                        {
                                fix d_sign, s1_sign, t1_sign;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                s1 = ((fix32)delta_x2 * delta_topy) -
                                     ((fix32)delta_y2 * delta_topx);
                                t1 = ((fix32)delta_x1 * delta_topy) -
                                     ((fix32)delta_y1 * delta_topx);
                                d_sign = (divider >= 0) ? 0 : 1;
                                s1_sign = (s1 >= 0) ? 0 : 1;
                                t1_sign = (t1 >= 0) ? 0 : 1;
#elif  FORMAT_16_16
                                LongFixsMul(delta_x2, delta_topy, dest4);
                                LongFixsMul(delta_y2, delta_topx, dest5);
                                LongFixsMul(delta_x1, delta_topy, dest6);
                                LongFixsMul(delta_y1, delta_topx, dest7);

                                LongFixsSub(dest2, dest3, div_dif);
                                LongFixsSub(dest4, dest5, s1_dif);
                                LongFixsSub(dest6, dest7, t1_dif);

                                d_sign = (div_dif[0] < 0) ? 1 : 0;
                                s1_sign = (s1_dif[0] < 0) ? 1 : 0;
                                t1_sign = (t1_dif[0] < 0) ? 1 : 0;
#elif  FORMAT_28_4
                                LongFixsMul(delta_x2, delta_topy, dest4);
                                LongFixsMul(delta_y2, delta_topx, dest5);
                                LongFixsMul(delta_x1, delta_topy, dest6);
                                LongFixsMul(delta_y1, delta_topx, dest7);

                                LongFixsSub(dest2, dest3, div_dif);
                                LongFixsSub(dest4, dest5, s1_dif);
                                LongFixsSub(dest6, dest7, t1_dif);

                                d_sign = (div_dif[0] < 0) ? 1 : 0;
                                s1_sign = (s1_dif[0] < 0) ? 1 : 0;
                                t1_sign = (t1_dif[0] < 0) ? 1 : 0;
#endif

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                if ((d_sign ^ s1_sign) ||
                                    (d_sign ^ t1_sign) ||
                                    (LABS(s1) > LABS(divider)) ||
                                    (LABS(t1) > LABS(divider)))
                                    continue;

                                s = s1 / (real32)divider;
#elif  FORMAT_16_16
                                change_to_real(div_dif, &div_dif_f);
                                change_to_real(s1_dif,  &s1_dif_f);
                                change_to_real(t1_dif,  &t1_dif_f);

                                if ((d_sign ^ s1_sign)                  ||
                                    (d_sign ^ t1_sign)                  ||
                                    (LABS(s1_dif_f) > LABS(div_dif_f))  ||
                                    (LABS(t1_dif_f) > LABS(div_dif_f)))
                                        continue;
                                s = s1_dif_f / div_dif_f;
#elif  FORMAT_28_4
                                change_to_real(div_dif, &div_dif_f);
                                change_to_real(s1_dif,  &s1_dif_f);
                                change_to_real(t1_dif,  &t1_dif_f);

                                if ((d_sign ^ s1_sign)                  ||
                                    (d_sign ^ t1_sign)                  ||
                                    (LABS(s1_dif_f) > LABS(div_dif_f))  ||
                                    (LABS(t1_dif_f) > LABS(div_dif_f)))
                                        continue;
                                s = s1_dif_f / div_dif_f;
#endif
                                /* Intersection point */
                                int_x =(sfix_t)(x0 + s * delta_x1);
                                int_y =(sfix_t)(y0 + s * delta_y1);

                                /* put intersect point in xpnt_table */
                                put_in_xpnt_table(int_x, int_y, cp, xp);
                                put_in_scany_table(int_y);      /* @XPNT */
                        }
                } /* for cross edge */
            } /* if current_edge == horizontal */
        } /* for current edge */
        return;
}

/***********************************************************************
 * This module puts a point in xpnt_table.
 *
 * TITLE:       put_in_xpnt_table
 *
 * CALL:        put_in_xpnt_table(x, y, edge1, edge2, xt_addr)
 *
 * PARAMETERS:  x, y -- point
 *              edge1, edge2 -- point(x, y) is an endpoint of the edge
 *
 * INTERFACE:   setup_intersect_points
 *
 * CALLS:       none
 *
 * RETURN:      none
 **********************************************************************/
static void near put_in_xpnt_table(x, y, edge1, edge2)
sfix_t     x, y;
struct edge_hdr FAR *edge1, FAR *edge2;
{
        fix         i;
        struct      edge_hdr FAR *xp;

        /* create a new cross point, and put into xpnt_table
         */
        /* allocate an entry of edge_table @ET */
        if (--xt_end <= et_end) {
                ERROR(LIMITCHECK);
                return;
        }
        xp = &edge_table[xt_end];

        xp->XT_X = x;
        xp->XT_Y = y;
        xp->XT_EDGE1 = edge1;
        xp->XT_EDGE2 = edge2;

        /* Put it into xpnt_table in non_decreasing order */
        for (i=xt_end+1; i<=xt_start; i++) {
                if (y >= edge_ptr[i]->XT_Y) break;
                edge_ptr[i-1] = edge_ptr[i];
        }
        edge_ptr[i-1] = xp;

        /* add error tolerance of calculation of line intersection 4/19/89 */
        if ((i <= xt_start) && (y == edge_ptr[i]->XT_Y)) { /* check i 5/18/89 */
                if (ABS(x - edge_ptr[i]->XT_X) <= 3)
                        xp->XT_X = edge_ptr[i]->XT_X;
        }

        return;
}


static void near put_in_scany_table(y)          /* @XPNT */
sfix_t  y;
{

/*      (* Put it into scany_table in non_decreasing order *)
 *      for (i=st_end++; i>=0; i--) {
 *              if (y >= scany_table[i]) break;
 *              scany_table[i+1] = scany_table[i];
 *      }
 *      scany_table[i+1] = y;
 */
        if (st_end < (SCANY_TABLE_SZ - 1)) {
            scany_table[++st_end] = y;
        }
        else            /* 05/07/91, Peter */
        {
           ERROR(LIMITCHECK);
        }
}

/*
 * sort scany_table: 0 => st_end
 */
static void near sort_scany_table()
{
        /* initialization for quick sort */
        scany_table[st_end+1] = MAX_SFX;  /* Important !!! */

        scany_qsort (0, st_end);
}

/*
 * quick sort
 */
static void near scany_qsort (m, n)
fix     m, n;
{
        fix     i, j;
        sfix_t  key;
        register sfix_t t;    /* @RESO_UPGR */

        if (m < n) {
                i = m;
                j = n + 1;
                key = scany_table[m];
                while(1) {
                        for (i++;scany_table[i] < key; i++);
                        for (j--;scany_table[j] > key; j--);
                        if (i < j) {
                                /* swap (i, j); */
                                t = scany_table[i];
                                scany_table[i] = scany_table[j];
                                scany_table[j] = t;
                        } else
                                break;
                }

                /* swap (m, j); */
                t = scany_table[m];
                scany_table[m] = scany_table[j];
                scany_table[j] = t;

                scany_qsort (m, j-1);
                scany_qsort (j+1, n);
        }
}


/***********************************************************************
 * This module applies horizontal edges to partition the shape in
 * edge_table to a set of trapezoids.
 *
 * TITLE:       horiz_partition
 *
 * CALL:        horiz_partition(winding_type)
 *
 * PARAMETERS:  winding_type -- NON_ZERO/EVEN_ODD
 *
 * INTERFACE:   shape_reduction
 *
 * CALLS:       find_trapezoid, degen_trapezoid,
 *              convex_clipper
 *
 * RETURN:
 *
 * NOTE:        After calling this module, the caller should clear
 *              edge_tables.
 **********************************************************************/
static void near horiz_partition (winding_type) /* @SCAN_EHS, delete action */
ufix    winding_type;
{
        sfix_t   scan_y;                /* @ET, *bottom_scan; */
        fix      x_int_count, next, i, j, horiz_cnt;
        struct edge_hdr FAR *ep;

        /* Initialization */
        et_first = et_start;
        et_last = et_start - 1;
        xt_first = xt_start;
        st_first = 0;           /* @XPNT */

#ifdef DBG1
        printf(" horiz_partition():\n");
        printf(" et_start=%d, et_end=%d\n", et_start, et_end);
        dump_all_edge (et_start, et_end);
#endif

        /* Main loop, for each disjoint y_coordinate in edge_table */
        /* while (xt_first >= xt_end) { */
        while (st_first <= st_end) {    /* @XPNT */

            /* Find next horizontal scan line */
            /* scan_y = edge_ptr[xt_first]->XT_Y; */
            scan_y = scany_table[st_first];     /* @XPNT */

#ifdef DBG2
            printf(" scan_y = %f\n", scan_y/8.0);
#endif

            /* Advance last_edge to the next first entry with the
             * different y_coordinate
             */
            while (((next=et_last+1) <= et_end) &&
                   (edge_ptr[next]->ET_TOPY < scan_y)) et_last++;

            /* advance first edge @ET */
            //DJC The code below caused access problems, if the array was made
            //    up of  ALL FREE_EDGE bits then the array would be accesed beyond
            //    the end.
            //DJC ORIG while (edge_ptr[et_first]->ET_FLAG & FREE_EDGE) et_first++;

            //UPD059
            while (et_first < et_end && edge_ptr[et_first]->ET_FLAG & FREE_EDGE) et_first++;

            /*
             * Non-horizontal edges processing
             */
            if (et_first < et_last) {   /* Non-horizontal edges processing */

                /*
                 * the scan_y will try to intersect with all edges from
                 * et_first(included) to et_last(included).
                 */

                x_int_count = cross_with_horiz_line (scan_y);

                /* Assign winding_no for each intersecting edges */
                set_wno (winding_type);

                get_pairs (scan_y, x_int_count);

#ifdef DBG2
                printf(" edge_list(after trapedizing)-->\n");
                printf(" et_first=%d, et_last=%d\n", et_first, et_last);
                /*dump_all_edge (first_edge); @ET */
                dump_all_edge (et_first, et_last);
#endif
            }

            /*
             * Horizontal edges processing
             */
            /* sort horizontal edges in x-coord then non-horizontal ones */
            horiz_cnt=0;
            i = et_last + 1;
            while (((next=et_last+1) <= et_end) &&
                   (edge_ptr[next]->ET_TOPY == scan_y)) {
                et_last++;

                if (!(edge_ptr[et_last]->ET_FLAG & HORIZ_EDGE)) continue;

                ep = edge_ptr[et_last];

                /* free this hozizontal edge */
                ep->ET_FLAG |= FREE_EDGE;
                horiz_cnt++;

                for (j = et_last-1; j >= i; j--) {
                    if ((edge_ptr[j]->ET_FLAG & HORIZ_EDGE) &&
                        (ep->HT_XL >= edge_ptr[j]->HT_XL)) break;
                    edge_ptr[j+1] = edge_ptr[j];
                }
                edge_ptr[j+1] = ep;
            }
#ifdef DBG2
            printf(" edge_list(after sort horiz edges)-->\n");
            printf(" et_first=%d, et_last=%d\n", et_first, et_last);
            dump_all_edge (et_first, et_last);
#endif

            while ((--horiz_cnt) > 0) {      /* more than 2 horizontal edges */
                struct edge_hdr FAR *ep1, FAR *ep2;
                sfix_t xl, xr;

                /* the 2 consective horizontal edges that overay each other
                 * will construct a degnerate trapezoid
                 */

                ep1 = edge_ptr[i];
                ep2 = edge_ptr[++i];
                if ((ep1->HT_XR > ep2->HT_XL) &&
                    (ep1->HT_XL < ep2->HT_XR)) {
                    /* create a trapezoid:
                     *              (ep1->HT_XL, ep1->HT_Y),
                     *              (ep1->HT_XR, ep1->HT_Y),
                     *              (ep2->HT_XR, ep2->HT_Y),
                     *              (ep2->HT_XL, ep2->HT_Y)
                     */

                    /* get endpoints of the horizontal edge */
                    xl = (ep1->HT_XL < ep2->HT_XL) ?
                         ep1->HT_XL : ep2->HT_XL;
                    xr = (ep1->HT_XR > ep2->HT_XR) ?
                         ep1->HT_XR : ep2->HT_XR;
                    degen_tpzd (ep1->HT_Y, xl, xr);
                } /* if */
            } /* while */

            /* update xt_table @ET */
            /* while ((xt_first >= xt_end) &&           @XPNT
             *      (edge_ptr[xt_first]->XT_Y <= scan_y)) xt_first--;
             */
            while ((st_first <= st_end) &&
                   (scany_table[st_first] <= scan_y)) st_first++;

            /* update et_table @ET */
            for (i = et_first; i <= et_last; i++) {
                if ((ep=edge_ptr[i])->ET_ENDY <= scan_y)
                    ep->ET_FLAG |= FREE_EDGE;
            }

        } /* main loop */

        return;
}


static fix near cross_with_horiz_line (scan_y)
sfix_t  scan_y;
{
        struct   edge_hdr FAR *ep;
        ET_IDX   edge;
        fix      x_int_count = 0;
//      real32    temp;         @WIN

        struct  edge_hdr FAR *xp, FAR *ip;
        fix     i;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif  FORMAT_16_16
        long dest1[2];
#elif  FORMAT_28_4
        long dest1[2];
#endif


        /* initialize all edges */
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                edge_ptr[edge]->ET_FLAG &= ~CROSS_PNT;
        }

        while ((xt_first >= xt_end) &&                  /* Jul-18-91 SC */
               ((xp=edge_ptr[xt_first])->XT_Y < scan_y)) {
                xt_first--;
        }

        /* set intersect x_coordinate due to xpnt_table */
        while ((xt_first >= xt_end) &&
            ((xp=edge_ptr[xt_first])->XT_Y == scan_y)) {
            register struct edge_hdr FAR *p;

            if (!((p=xp->XT_EDGE1)->ET_FLAG & CROSS_PNT)) { /* once only */
                p->ET_XINT0 = p->ET_XINT;           /* @SRD */
                p->ET_XINT = xp->XT_X;
                p->ET_FLAG |= CROSS_PNT;
            } else {    /* @OLXPNT 7-31-91 scchen */
                if (p->ET_XINT0 > p->ET_XINT) { /* get max xint */
                    if (p->ET_XINT < xp->XT_X) p->ET_XINT = xp->XT_X;
                } else {
                    if (p->ET_XINT > xp->XT_X) p->ET_XINT = xp->XT_X;
                }
            }
            if (!((p=xp->XT_EDGE2)->ET_FLAG & CROSS_PNT)) { /* once only */
                p->ET_XINT0 = p->ET_XINT;           /* @SRD */
                p->ET_XINT = xp->XT_X;
                p->ET_FLAG |= CROSS_PNT;
            } else {    /* @OLXPNT 7-31-91 scchen */
                if (p->ET_XINT0 > p->ET_XINT) { /* get max xint */
                    if (p->ET_XINT < xp->XT_X) p->ET_XINT = xp->XT_X;
                } else {
                    if (p->ET_XINT > xp->XT_X) p->ET_XINT = xp->XT_X;
                }
            }
            xt_first--;
        }

        /* Intersect all edges with scan_y
         */
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                ep = edge_ptr[edge];

#ifdef DBG2
                printf("&edge:%lx   (%f, %f)  (%f, %f) %f  ", ep,
                       SFX2F(ep->ET_TOPX),
                       SFX2F(ep->ET_TOPY), SFX2F(ep->ET_ENDX),
                       SFX2F(ep->ET_ENDY), SFX2F(ep->ET_XINT));

                if (ep->ET_FLAG & HORIZ_EDGE) printf("- ");
                else if (ep->ET_FLAG & WIND_UP) printf("^ ");
                else printf("v ");
                if (ep->ET_FLAG & FREE_EDGE) printf("F ");
                if (ep->ET_FLAG & CROSS_PNT) printf("X ");
                if (ep->ET_WNO) printf("W ");
                printf("\n");
#endif

                /*
                 * intersect edge with scan_y
                 */
                if(ep->ET_FLAG & FREE_EDGE) {
                        continue;
                } else if (!(ep->ET_FLAG & CROSS_PNT)) {

                    /* check if end point @XPNT */
                    if (ep->ET_ENDY == scan_y) {
                        ep->ET_XINT0 = ep->ET_XINT;
                        ep->ET_XINT = ep->ET_ENDX;
                        ep->ET_FLAG |= CROSS_PNT;
                    } else {
#ifdef DBG2
                        printf(" Not end point\n");
#endif

                        /* Enhancement of intersection point of line segments
                         * 4/19/89
                         */
                        /*temp = (real32)(ep->ET_ENDX - ep->ET_TOPX) /
                         *             (ep->ET_ENDY - ep->ET_TOPY);
                         *ep->ET_XINT0 = ep->ET_XINT;
                         *ep->ET_XINT = ep->ET_TOPX +
                         *       ROUND((scan_y - ep->ET_TOPY) * temp);
                         */
                        ep->ET_XINT0 = ep->ET_XINT;             /* @SRD */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        ep->ET_XINT = (sfix_t)(ep->ET_TOPX +    /*@WIN*/
                                      (scan_y - ep->ET_TOPY) *
                                      (fix32)(ep->ET_ENDX - ep->ET_TOPX) /
                                      (fix32)(ep->ET_ENDY - ep->ET_TOPY));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - ep->ET_TOPY),
                                (ep->ET_ENDX - ep->ET_TOPX), dest1);
                        ep->ET_XINT = ep->ET_TOPX + LongFixsDiv(
                                        (ep->ET_ENDY - ep->ET_TOPY), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - ep->ET_TOPY),
                                (ep->ET_ENDX - ep->ET_TOPX), dest1);
                        ep->ET_XINT = ep->ET_TOPX + LongFixsDiv(
                                        (ep->ET_ENDY - ep->ET_TOPY), dest1);
#endif
                    } /* if end point @XPNT */
                } /* if FREE_EDGE */

#ifdef DBG2
                printf(" intersect scan_y(%f) with edge#%d at x_int =%f\n",
                        scan_y/8.0, edge, ep->ET_XINT/8.0);
#endif

                /* accumulate x_int_count */
                x_int_count++;

                /* Adjust the entry of edge in edge_table due to
                 * its value of intersect field;
                 */
                for (i=edge-1; i>=et_first; i--) {
                    ip = edge_ptr[i];

                    /* Skip non_intersecting edges @FRE_PAR */
                    if (!(ip->ET_FLAG & FREE_EDGE)) {
                        if (ep->ET_XINT > ip->ET_XINT) break;

/*                      (* Fixed bug; set them as cross points when the
 *                       * intersect points are same; not need to be identical
 *                       * edges. 4/11/90 *)
 *                      else if (ep->ET_XINT == ip->ET_XINT) {
 *                          if (ep->ET_XINT0 > ip->ET_XINT0) break;
 *                          else if (ep->ET_XINT0 == ip->ET_XINT0) {
 *                              (* identical edges; always partition *)
 *                              ep->ET_FLAG |= CROSS_PNT;
 *                              ip->ET_FLAG |= CROSS_PNT;
 *                              break;
 *                          } (* if == *)
 *                      } (* if > *)
 */
                        else if (ep->ET_XINT == ip->ET_XINT) {
                            ep->ET_FLAG |= CROSS_PNT;
                            ip->ET_FLAG |= CROSS_PNT;
                            /*if (ep->ET_XINT0 >= ip->ET_XINT0) break;4/30/91*/
                            if (ep->ET_XINT0 > ip->ET_XINT0) break;
                            if (ep->ET_XINT0 == ip->ET_XINT0 &&
                                !ip->ET_WNO) break;
                        } /* if > */

                    } /* if ! */
                    edge_ptr[i+1] = edge_ptr[i];
                }
                edge_ptr[i+1] = ep;

        } /* for */

#ifdef DBG2
        printf(" edge_list(After sorting in x_int)-->\n");
        printf(" et_first=%d, et_last=%d\n", et_first, et_last);
        dump_all_edge (et_first, et_last);
#endif

        return(x_int_count);

}


static void near set_wno (winding_type)
ufix    winding_type;
{
        fix     w_no;
        bool    done = FALSE;
        struct  edge_hdr FAR *ep;
        ET_IDX  edge;

        w_no = 0;
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                ep = edge_ptr[edge];

                /* check exit condition */
                /* Skip free edges @FRE_PAR */
                if (ep->ET_FLAG & FREE_EDGE) {
                        continue;
                }

                /* Accumulate winding_no due to its direction */
                if (ep->ET_FLAG & WIND_UP)
                        w_no++;
                else
                        w_no--;

                if (((winding_type == NON_ZERO) && (w_no != 0))
                    || ((winding_type == EVEN_ODD) &&
                    (w_no & 0x1))) {
                        ep->ET_WNO = 1;
                } else
                        ep->ET_WNO = 0;

        }
        return;
}


static void near get_pairs (scan_y, x_int_count)
sfix_t  scan_y;
fix     x_int_count;
{
        bool    split_flag;
        bool    split1, split2;         /* @SPLIT */
        ET_IDX  edge;
        struct  edge_hdr FAR *ep1, FAR *ep2;
        fix     cnt;

        for (cnt=0, edge = (ET_IDX)et_first; cnt < (x_int_count - 1); cnt++) {

            while ((ep1=edge_ptr[edge])->ET_FLAG & FREE_EDGE) edge++;

            while ((ep2=edge_ptr[++edge])->ET_FLAG & FREE_EDGE);

            /* Check winding number of the area between
             * edge1 and edge2
             */
            if (ep1->ET_WNO) {

                /* check endpoints:
                 * join at endpoint of either edges, then the area is required
                 */
                if (ep1->ET_FLAG & CROSS_PNT) {
                    /* Join at endpoint of edge1 */
                    /* get the trapezoid, and perform the action */
                    find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                   ep1, ep2);

                    /* check if need to modify edge2 */
                    /* if (!(ep2->ET_FLAG & CROSS_PNT)) { always setting @SRD */
                            /* not join at cross point; needs to modify */
                            ep2->ET_LFTX = ep2->ET_XINT;
                            ep2->ET_LFTY = scan_y;
                    /* } */

                } else { /* not join at endpoint of edge1 */
                    if (ep2->ET_FLAG & CROSS_PNT) {
                        /* Join at endpoint of edge2 */
                        /* get the trapezoid, and perform the action */
                        find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                       ep1, ep2);

                        /* modify edge1 */
                        ep1->ET_RHTX = ep1->ET_XINT;

                    } else {
                        /* not join at either endpoints */
                         fix i;
                         struct edge_hdr FAR *ip;

                         /* not join at either endpoints */
                         split_flag = FALSE;
                         split1 = split2 = FALSE;       /* @SPLIT */
                         for (i = et_last; i <= et_end; i++) {
                             ip = edge_ptr[i];
                             if (ip->ET_TOPY > scan_y) break;
                             if ((ip->ET_TOPX > ep1->ET_XINT) &&
                                 (ip->ET_TOPX < ep2->ET_XINT)) {
                                 split_flag = TRUE;
                                 break;
                             } else {   /* @SPLIT */
                                if (ip->ET_TOPX == ep1->ET_XINT) {
                                   split1 = TRUE;
                                   split_flag = TRUE;
                                }
                                if (ip->ET_TOPX == ep2->ET_XINT) {
                                   split2 = TRUE;
                                   split_flag = TRUE;
                                }
                                if (split_flag) break;
                             }
                         }

                         if (split_flag) {
                             /* slpit edge1 and edge2 */
                             find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                            ep1, ep2);

                             /* modify edge1 and edge2 */
                             ep1->ET_RHTX = ep1->ET_XINT;
                             ep2->ET_LFTX = ep2->ET_XINT;
                             ep2->ET_LFTY = scan_y;
                             /* @SPLIT; 7/29/91 */
                             if (split1) ep1->ET_LFTX = ep1->ET_XINT;
                             if (split2) ep2->ET_RHTX = ep2->ET_XINT;
                         } /* if split_flag */

                    } /* if endpoint of ep2 */
                } /* if endpoint of ep1 */
            } /* if winding_type */

            /* modify edge1 that is a cross point */
            if (ep1->ET_FLAG & CROSS_PNT) {
                /* modify edge1 */
                ep1->ET_RHTX = ep1->ET_LFTX = ep1->ET_XINT;
                ep1->ET_LFTY = scan_y;
            }

        } /* for */

        /* modify the last edge2 that is a cross point */
        if (ep2->ET_FLAG & CROSS_PNT) {
            /* modify edge2 */
            ep2->ET_RHTX = ep2->ET_LFTX = ep2->ET_XINT;
            ep2->ET_LFTY = scan_y;
        }

        return;
}



static void near degen_tpzd (y, xl, xr)                 /* @ET */
sfix_t  y, xl, xr;
{
        CP_IDX icp;
        struct nd_hdr FAR *cp;
        sfix_t  cp_xl, cp_xr, max_xl, min_xr;

#ifdef DBG2
                printf(" degen_tpzd(): y=%f, xl=%f, xr=%f\n", SFX2F(y),
                        SFX2F(xl), SFX2F(xr));
#endif
                /* Clip the edge to each clip trapezoid */
                for (icp = GSptr->clip_path.head; icp != NULLP;
                    icp = cp->next) {

                    cp = &node_table[icp];

#ifdef DBG2
                    printf(" Sub_clip#%d:", icp);
                    printf("(%f, %f, %f), ", cp->CP_TOPY/8.0,
                           cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0);
                    printf("(%f, %f, %f)\n", cp->CP_BTMY/8.0,
                           cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif
                    if ((y >= cp->CP_TOPY) &&
                        (y <= cp->CP_BTMY)) {
                        /* inside the clip trapezoid */

                        /* get endpoints  */
                        if ((cp->CP_TOPXL == cp->CP_BTMXL) &&      /* @EHS_HOZ */
                            (cp->CP_TOPXR == cp->CP_BTMXR)) {
                                cp_xl = cp->CP_TOPXL;
                                cp_xr = cp->CP_TOPXR;
                        } else if (cp->CP_TOPY == cp->CP_BTMY) {
                                cp_xl = (cp->CP_TOPXL < cp->CP_BTMXL) ?
                                         cp->CP_TOPXL : cp->CP_BTMXL;
                                cp_xr = (cp->CP_TOPXR < cp->CP_BTMXR) ?
                                         cp->CP_TOPXR : cp->CP_BTMXR;
                        } else {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                real32  r;
                                r = (real32)(y - cp->CP_TOPY) /
                                     (cp->CP_BTMY - cp->CP_TOPY);
                                cp_xl = cp->CP_TOPXL +
                                      (sfix_t)(r * (cp->CP_BTMXL-cp->CP_TOPXL));
                                cp_xr = cp->CP_TOPXR +
                                      (sfix_t)(r * (cp->CP_BTMXR-cp->CP_TOPXR));
#elif  FORMAT_16_16
                                long dest1[2];
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                                cp_xl = cp->CP_TOPXL +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                                cp_xr = cp->CP_TOPXR +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                                long dest1[2];
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                                cp_xl = cp->CP_TOPXL +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                                cp_xr = cp->CP_TOPXR +
                                        LongFixsDiv(
                                          (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                        }

                        /* check if intersect */
                        max_xl = (xl > cp_xl) ? xl : cp_xl;
                        min_xr = (xr < cp_xr) ? xr : cp_xr;
                        if (max_xl <= min_xr) {
                                /* the clipped edge: max_xl -> min_xr */
                                struct tpzd tpzd;

                                tpzd.topy = tpzd.btmy = y;
                                tpzd.topxl = tpzd.btmxl = max_xl;
                                tpzd.topxr = tpzd.btmxr = min_xr;
                                save_tpzd (&tpzd);

                                /* break if edge totally inside the clip */
                                if ((max_xl == xl) && (min_xr == xr)) break;
                        } /* if max_xl */
                    } /* if y */
                } /* for icp */
}



/***********************************************************************
 * Given two edges, this module finds a trapezoid confined by the two
 * edges, and saves the trapezoid or clips it against current clip according to
 * if it is totally inside the clipping region.
 *
 * TITLE:       find_trapezoid
 *
 * CALL:        find_trapezoid(winding_type, paint_flag, result_path)
 *
 * PARAMETERS:
 *
 * INTERFACE:   horiz_partition
 *
 * CALLS:       save_tpzd, convex_clipper
 *
 * RETURN:
 **********************************************************************/
static void near find_trapezoid (btm_y, btm_xl, btm_xr, ep1, ep2)
sfix_t btm_y, btm_xl, btm_xr;
struct edge_hdr FAR *ep1, FAR *ep2;
{
        struct polygon_i  t_polygon;

        /* Error recovery: modify left, right coord of edges that have
         * computation errors arose from integer arithmatics operations on
         * nearly-horizontal edges      @SRD
         */
        if (ep1->ET_RHTX > ep2->ET_LFTX) {
            sfix_t tmp, t1, t2;
#ifdef DBGwarn
            printf("\n\07find_trapezoid() warning!\n");
            printf("&edge1:%lx  RHTX=%f, LFTX=%f, LEFTY=%f, XINT0=%f\n", ep1,
                    SFX2F(ep1->ET_RHTX), SFX2F(ep1->ET_LFTX),
                    SFX2F(ep1->ET_LFTY), SFX2F(ep1->ET_XINT0));
            printf("&edge2:%lx  RHTX=%f, LFTX=%f, LEFTY=%f, XINT0=%f\n", ep2,
                    SFX2F(ep2->ET_RHTX), SFX2F(ep2->ET_LFTX),
                    SFX2F(ep2->ET_LFTY), SFX2F(ep2->ET_XINT0));
            printf("btm_y=%f, btm_xl=%f, btm_xr=%f\n",
                    SFX2F(btm_y), SFX2F(btm_xl), SFX2F(btm_xr));
#ifdef DBG1
            dump_all_edge (et_first, et_last);
#endif
#endif
            /* select the nearest point 4/19/89 */
            tmp = btm_xl/2 + btm_xr/2;
            t1 = ABS(ep1->ET_RHTX - tmp);
            t2 = ABS(ep2->ET_LFTX - tmp);
            if (t1 > t2)
                ep1->ET_RHTX = ep2->ET_LFTX;
            else
                ep2->ET_LFTX = ep1->ET_RHTX;

#ifdef DBGwarn
            printf("After modification: top left_x =%f, right_x =%f\n",
                    SFX2F(ep1->ET_RHTX), SFX2F(ep2->ET_LFTX));
#endif
        }

        /* save the trapezoid if it is inside the single rectangle clip */
        if ((GSptr->clip_path.single_rect) &&
            (ep2->ET_LFTY >= GSptr->clip_path.bb_ly) &&         /* top_y */
            (ep1->ET_RHTX >= GSptr->clip_path.bb_lx) &&         /* top_xl */
            (ep2->ET_LFTX <= GSptr->clip_path.bb_ux) &&         /* top_xr */
            (btm_y        <= GSptr->clip_path.bb_uy) &&         /* btm_y */
            (btm_xl       >= GSptr->clip_path.bb_lx) &&         /* btm_xl */
            (btm_xr       <= GSptr->clip_path.bb_ux)   ) {      /* btm_xr */
                struct tpzd tpzd;

#ifdef DBG1
        printf(" inside single rectangle clip\n");
#endif
                /* totally inside the clip region */
                tpzd.topy = ep2->ET_LFTY;
                tpzd.topxl = ep1->ET_RHTX;
                tpzd.topxr = ep2->ET_LFTX;
                tpzd.btmy = btm_y;
                tpzd.btmxl = btm_xl;
                tpzd.btmxr = btm_xr;
                save_tpzd(&tpzd);

        } else {
                /* clip the trapezoid against current clip path */

                /* Create a polygon contains the trapezoid:
                 */
                t_polygon.size = 4;
                t_polygon.p[0].x = ep1->ET_RHTX;
                t_polygon.p[1].x = ep2->ET_LFTX;
                t_polygon.p[0].y = t_polygon.p[1].y = ep2->ET_LFTY;
                t_polygon.p[2].x = btm_xr;
                t_polygon.p[3].x = btm_xl;
                t_polygon.p[2].y = t_polygon.p[3].y = btm_y;

                convex_clipper (&t_polygon, CC_TPZD);
                                /* CC_TPZD: a trapezoid */
        }
        return;
}


/***********************************************************************
 * Given a convex polygon, this module clips it against the clipping region, and
 * saves the result(clipped polygon) or calls pgn_reduction to reduce it to
 * a set of trapezoids.
 *
 * TITLE:       Convex_clipper
 *
 * CALL:        Convex_clipper(in_polygon, flag)
 *
 * PARAMETERS:  in_polygon -- polygon to be clipped
 *              flag -- CC_IMAGE : called from image operator
 *                      CC_TPZD  : in_polygon is a trapezoid
 *
 * INTERFACE:
 *
 * CALLS:       save_tpzd, pgn_reduction
 *
 * RETURN:      FALSE -- out of node table when sets up sample list for image
 *              TRUE  -- normal
 **********************************************************************/
bool convex_clipper (in_polygon, flag)     /* @SCAN_EHS, delete action */
struct polygon_i FAR *in_polygon;
bool    flag;
{
    fix i, ix, s, p;
    sfix_t cp_lx, cp_ly, cp_ux, cp_uy;
    sfix_t in_lx, in_ly, in_ux, in_uy;
    sfix_t min_x, max_x, min_y, max_y;

    struct polygon_i polygon1, polygon2;  /* working polygon */
    struct polygon_i FAR *in, FAR *out, FAR *tmp;   /*@WIN*/
    ET_IDX icp;
//  SP_IDX isp; /* index of sample list */      @WIN
    struct nd_hdr FAR *cp;
    struct tpzd tpzd;           /* @SCAN_EHS */

    ufix16  plcode, pucode;   /* pcode for checking if bounding box of
                               * in_polygon totally outside or inside the
                               * clip region.
                               * 4 bits for each variable:(see below)
                               *   bit 0: BOTTOM
                               *   bit 1: TOP
                               *   bit 2: RIGHT
                               *   bit 3: LEFT
                               */
#define BOTTOM 1
#define TOP    2
#define RIGHT  4
#define LEFT   8

    struct coord_i *isect;

#ifdef DBG1
        printf ("Convex_clipper(): flag=");
        if (flag == CC_IMAGE)
                printf("CC_IMAGE\n");
        else if (flag == CC_TPZD)
                printf("CC_TPZD\n");
        else
                printf("Not a TPZD\n");
        printf("polygon=");
        for (i=0; i < in_polygon->size; i++) {
                printf(" (%f,%f)", in_polygon->p[i].x/8.0,
                                   in_polygon->p[i].y/8.0);
        }
        printf("\n");
#endif

    /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of current clip */
    cp_lx = GSptr->clip_path.bb_lx;
    cp_ly = GSptr->clip_path.bb_ly;
    cp_ux = GSptr->clip_path.bb_ux;
    cp_uy = GSptr->clip_path.bb_uy;

    /* find bounding box(in_lx, in_ly), (in_ux, in_uy) of in_polygon
     */
    /* for in_ly & in_uy */
    if (flag == CC_TPZD) {                  /* if(tpzd_flag) {   @SCAN_EHS */
        /* trapezoid, boundary of y-coordinates is trival */
        in_ly = in_polygon->p[0].y;
        in_uy = in_polygon->p[2].y;

    } else {
        /* otherwise, needs to calculate */
        if (in_polygon->p[0].y >= in_polygon->p[1].y) {
                max_y = in_polygon->p[0].y;
                min_y = in_polygon->p[1].y;
        } else {
                max_y = in_polygon->p[1].y;
                min_y = in_polygon->p[0].y;
        }
        if (in_polygon->p[2].y >= in_polygon->p[3].y) {
                in_uy = in_polygon->p[2].y;
                in_ly = in_polygon->p[3].y;
        } else {
                in_uy = in_polygon->p[3].y;
                in_ly = in_polygon->p[2].y;
        }
        in_uy = (in_uy > max_y) ? in_uy : max_y;
        in_ly = (in_ly < min_y) ? in_ly : min_y;
    } /* if flag */

    /* for in_lx & in_ux */
    if (in_polygon->p[0].x >= in_polygon->p[1].x) {
            max_x = in_polygon->p[0].x;
            min_x = in_polygon->p[1].x;
    } else {
            max_x = in_polygon->p[1].x;
            min_x = in_polygon->p[0].x;
    }
    if (in_polygon->p[2].x >= in_polygon->p[3].x) {
            in_ux = in_polygon->p[2].x;
            in_lx = in_polygon->p[3].x;
    } else {
            in_ux = in_polygon->p[3].x;
            in_lx = in_polygon->p[2].x;
    }
    in_ux = (in_ux > max_x) ? in_ux : max_x;
    in_lx = (in_lx < min_x) ? in_lx : min_x;

    /* set up Pcode for (in_lx, in_ly), and (in_ux, in_uy) */
    /* initialization */
    plcode = pucode = 0;
    if (in_lx < cp_lx) plcode |= LEFT;
    if (in_lx > cp_ux) plcode |= RIGHT;
    if (in_ly < cp_ly) plcode |= TOP;
    if (in_ly > cp_uy) plcode |= BOTTOM;

    if (in_ux < cp_lx) pucode |= LEFT;
    if (in_ux > cp_ux) pucode |= RIGHT;
    if (in_uy < cp_ly) pucode |= TOP;
    if (in_uy > cp_uy) pucode |= BOTTOM;

    /* check if totally outside clip polygon */
    if (plcode && pucode && (plcode & pucode)) {
#ifdef DBG1
        printf(" outside clip\n");
#endif
            return(TRUE);   /* fine, do nothing */
    }

    /* Check if in_path totally inside the rectangle current clip */
    if (((plcode == 0) && (pucode == 0)) &&
            GSptr->clip_path.single_rect) {
#ifdef DBG1
        printf(" inside single rectangle clip\n");
#endif

            /*if (flag == CC_IMAGE) {     (* @IAMGE: move to image.c 1/16/89 *)
             *  (* set up sample list of image *)
             *  if((isp = get_node()) == NULLP) return(FALSE);
             *          (* out of node table, need to render sample list *)
             *  node_table[isp].SAMPLE_BB_LX = image_info.bb_lx;
             *  node_table[isp].SAMPLE_BB_LY = image_info.bb_ly;
             *  node_table[isp].SEED_INDEX   = image_info.seed_index;
             *                                  (* @#IMAGE 04-27-88  Y.C. *)
             *  node_table[isp].next =
             *          gray_chain[image_info.gray_level].start_seed_sample;
             *  gray_chain[image_info.gray_level].start_seed_sample = isp;
             *
             *} else if (flag == CC_TPZD) {
             */
            if (flag == CC_TPZD) {
                /* the polygon is a trapezoid, just need to save the trapezoid
                 */
                tpzd.topy = in_polygon->p[0].y;
                tpzd.topxl = in_polygon->p[0].x;
                tpzd.topxr = in_polygon->p[1].x;
                tpzd.btmy = in_polygon->p[3].y;
                tpzd.btmxl = in_polygon->p[3].x;
                tpzd.btmxr = in_polygon->p[2].x;
                save_tpzd(&tpzd);
            } else {
                /* in_polygon not a trapezoid, to reduce it to trapezoids */
                pgn_reduction(in_polygon);
            }

            return(TRUE);
    }

    /* Clip in_path to each clip trapezoid */
    for (icp = GSptr->clip_path.head; icp != NULLP; icp = cp->next) {

        cp = &node_table[icp];

#ifdef DBG2
        printf(" Sub_clip#%d:", icp);
        printf("(%f, %f, %f), ", cp->CP_TOPY/8.0,
               cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0);
        printf("(%f, %f, %f)\n", cp->CP_BTMY/8.0,
               cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

        /* Check if in_polygon totally outside the bounding box
         * of sub_clipping trapezoid
         */

        /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of
         * the trapezoid
         */
        cp_lx = (cp->CP_TOPXL < cp->CP_BTMXL) ?
                cp->CP_TOPXL : cp->CP_BTMXL;
        cp_ly = cp->CP_TOPY;
        cp_ux = (cp->CP_TOPXR > cp->CP_BTMXR) ?
                cp->CP_TOPXR : cp->CP_BTMXR;
        cp_uy = cp->CP_BTMY;

        /* set up Pcode for (in_lx, in_ly), and (in_ux, in_uy) */
        /* initialization */
        plcode = pucode = 0;
        if (in_lx < cp_lx) plcode |= LEFT;
        if (in_lx > cp_ux) plcode |= RIGHT;
        if (in_ly < cp_ly) plcode |= TOP;
        if (in_ly > cp_uy) plcode |= BOTTOM;

        if (in_ux < cp_lx) pucode |= LEFT;
        if (in_ux > cp_ux) pucode |= RIGHT;
        if (in_uy < cp_ly) pucode |= TOP;
        if (in_uy > cp_uy) pucode |= BOTTOM;

        if (plcode && pucode && (plcode & pucode)) {
#ifdef DBG2
        printf(" outside sub_clip#%d\n", icp);
#endif
                continue;
        }

        /* Check if in_polygon totally inside the rectangle
         * clipping trapezoid
         */
        if ((plcode == 0) && (pucode == 0) &&
                (cp->CP_TOPXL == cp->CP_BTMXL) &&
                (cp->CP_TOPXR == cp->CP_BTMXR)) {
#ifdef DBG2
                printf(" inside sub_clip#%d\n", icp);
#endif

                if (flag == CC_TPZD) {
                    /* the polygon is a trapezoid, just need to save the tpzd
                     */
                    tpzd.topy = in_polygon->p[0].y;
                    tpzd.topxl = in_polygon->p[0].x;
                    tpzd.topxr = in_polygon->p[1].x;
                    tpzd.btmy = in_polygon->p[3].y;
                    tpzd.btmxl = in_polygon->p[3].x;
                    tpzd.btmxr = in_polygon->p[2].x;
                    save_tpzd(&tpzd);
                } else {
                    /* in_polygon not a trapezoid, to reduce it to trapezoids */
                    pgn_reduction(in_polygon);
                }

                return(TRUE);   /* in_polygon totally inside a clipping
                                 * trapezoid, so it cannot intersect
                                 * with other clipping trapezoids.
                                 */
        }


        /*
         * Perform Sutherland-Hodgeman clipping algorithm
         */

        clip[0].cp.x = cp->CP_TOPXL;
        clip[0].cp.y = cp->CP_TOPY;
        clip[1].cp.x = cp->CP_TOPXR;
        clip[1].cp.y = cp->CP_TOPY;
        clip[2].cp.x = cp->CP_BTMXR;
        clip[2].cp.y = cp->CP_BTMY;
        clip[3].cp.x = cp->CP_BTMXL;
        clip[3].cp.y = cp->CP_BTMY;
        clip[4].cp.x = cp->CP_TOPXL;
        clip[4].cp.y = cp->CP_TOPY;

        polygon1.size = in_polygon->size;
        for (i = 0; i < in_polygon->size; i++) {
                polygon1.p[i].x = in_polygon->p[i].x;
                polygon1.p[i].y = in_polygon->p[i].y;
        }

        in = (struct polygon_i FAR *)&polygon1; /*@WIN*/
        out = (struct polygon_i FAR *)&polygon2;

        /* clip subject to each clip boundary of the clip trapezoid */
        for (i = 0; i < 4; i++) {
            bool flag;           /* @INSIDE1 */

            /* let s = last vertex of the subject polygon */
            s = (in->size) - 1;
            ix = 0;

            /* for each edge of subject(in_polygon) */
            for (p = 0; p < in->size; p++) {

                if (flag = inside(in->p[p], i)) {

                    if (inside(in->p[s], i)) {
                            /* inside -> inside */
                            out->p[ix].x = in->p[p].x;
                            out->p[ix].y = in->p[p].y;
                            ix++;

                    } else {     /* outside -> inside */
                            /* output intersect point */
                            if (flag != ON_CLIP) {      /* @INDISE1 */
                                /* create a intersect point only when the end
                                 * point(in->p[p]) is not on the clipping
                                 * boundary
                                 */
                                isect = intersect (in->p[s], in->p[p], i);
                                out->p[ix].x = isect->x;
                                out->p[ix].y = isect->y;
                                ix++;
                            }

                            /* output p */
                            out->p[ix].x = in->p[p].x;
                            out->p[ix].y = in->p[p].y;
                            ix++;

                    }
                } else {
                    if (flag = inside(in->p[s], i)) {
                            /* inside -> outside */
                            /* output intersect point */
                            if (flag != ON_CLIP) {      /* @INSIDE1 */
                                /* create a intersect point only when the start
                                 * point(in->p[s]) is not on the clipping
                                 * boundary
                                 */
                                isect = intersect (in->p[s], in->p[p], i);
                                out->p[ix].x = isect->x;
                                out->p[ix].y = isect->y;
                                ix++;
                            }

                    } /* else,  outside -> outside, do nothing */
                }

                s = p;

            } /* for each node of the subject */

            /* set up out polygon */
            out->size = (fix16)ix;

            /* swap in and out polygon */
            tmp = in;
            in = out;
            out = tmp;
#ifdef DBG2
            printf(" After clipping over clip edge:\n (%f, %f) --> (%f, %f)\n",
                clip[i].cp.x/8.0, clip[i].cp.y/8.0,
                clip[i+1].cp.x/8.0, clip[i+1].cp.y/8.0);
            printf(" polygon:");
            for (p = 0; p < in->size; p++) {
                printf(" (%f, %f),", in->p[p].x/8.0, in->p[p].y/8.0);
            }
            if (in->size > 8)
                printf("\n\07 size of polygon too large");
            printf("\n");
#endif

        } /* for each clip boundary */

        /* skip it if it is empty 12/11/87 */
        if (in->size == 0) continue;

        /* Fixed the bug for very sharp clipping triangle for case "doesall.cap"
           3/26/91 phchen */
        for (p = 0; p < in->size; p++) {
           if (in->p[p].x > cp_ux) in->p[p].x = cp_ux;
        }

        /* a clipped polygon has been generated, to reduce it to trapezoids */
        pgn_reduction(in);

    } /* for each trapezoid */
    return(TRUE);
}



/***********************************************************************
 * Given a point, to check if it is inside the clipping boundary. The
 * clipping boundary(a vector) is specified by the input parameter idx,
 * which is a index of the clipping region(global variable clip).
 *
 * TITLE:       Inside
 *
 * CALL:        Inside(p, idx)
 *
 * PARAMETERS:  p -- point
 *              idx -- index of global variable clip
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      IN_CLIP(1)  -- inside
 *              ON_CLIP(-1) -- on clipping boundary
 *              OUT_CLIP(0) -- outside
 **********************************************************************/
static bool near inside (p, idx)
struct coord_i p;
fix     idx;
{
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32    f;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], diff[2];
#elif  FORMAT_28_4
        long dest1[2], dest2[2], diff[2];
#endif
        struct coord_i s2, p2;

        /* clipping region is a trapezoid:
         * idx = 0 -- top clip boundary
         *       1 -- right clip boundary
         *       2 -- right clip boundary
         *       3 -- right clip boundary
         */

        switch (idx) {
        case 0 :        /* top clip boundary, trivial */
                if (p.y > clip[idx].cp.y) return(IN_CLIP);
                else if (p.y == clip[idx].cp.y) return(ON_CLIP);
                else    return(OUT_CLIP);

        case 2 :        /* bottom clip boundary, trivial */
                if (p.y < clip[idx].cp.y) return(IN_CLIP);
                else if (p.y == clip[idx].cp.y) return(ON_CLIP);
                else    return(OUT_CLIP);

        default :       /* right & left clipping boundaries */
                /* special treatment for degenerated clipping boundary */
                if (clip[0].cp.y == clip[3].cp.y) {     /* horizontal line */
                        if (idx == 1) {         /* right clip boundary */
                                if (p.x < clip[1].cp.x) return(IN_CLIP);
                                else if (p.x == clip[1].cp.x) return(ON_CLIP);
                                else    return(OUT_CLIP);
                        } else {                /* left clip boundary */
                                if (p.x > clip[0].cp.x) return(IN_CLIP);
                                else if (p.x == clip[0].cp.x) return(ON_CLIP);
                                else    return(OUT_CLIP);
                        }
                }

                /* condition :
                 *  f = vect(s2, p2) (*) vect(p2, p);
                 *  if f >= 0 --> inside
                 *  where, (*) is a operator of cross_product.
                 */
                s2 = clip[idx].cp;
                p2 = clip[idx+1].cp;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                f = (fix32)(p2.x - s2.x) * ((fix32)p.y - p2.y) -
                    (fix32)(p2.y - s2.y) * ((fix32)p.x - p2.x);
                if (f > 0 )  return (IN_CLIP);
                else if (f == 0 )  return (ON_CLIP);
                else    return (OUT_CLIP);
#elif  FORMAT_16_16
                LongFixsMul((p2.x - s2.x), (p.y - p2.y), dest1);
                LongFixsMul((p2.y - s2.y), (p.x - p2.x), dest2);
                LongFixsSub(dest1, dest2, diff);
                if (diff[0] == 0 && diff[1] == 0)
                        return (ON_CLIP);
                else if (diff[0] < 0)
                        return (OUT_CLIP);
                else
                        return (IN_CLIP);
#elif  FORMAT_28_4
                LongFixsMul((p2.x - s2.x), (p.y - p2.y), dest1);
                LongFixsMul((p2.y - s2.y), (p.x - p2.x), dest2);
                LongFixsSub(dest1, dest2, diff);
                if (diff[0] == 0 && diff[1] == 0)
                        return (ON_CLIP);
                else if (diff[0] < 0)
                        return (OUT_CLIP);
                else
                        return (IN_CLIP);
#endif
        }
}


/***********************************************************************
 * Given a line segment, to intersect it with the specified clipping
 * boundary(idx) of the clipping region.
 *
 * TITLE:       Intersect
 *
 * CALL:        Intersect(s1, p1, idx)
 *
 * PARAMETERS:  s1 -- starting point of the line segment
 *              p1 -- ending point of the line segment
 *              idx -- index of clipping region
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      intersect point
 **********************************************************************/
static struct coord_i * near intersect (s1, p1, idx)
struct coord_i s1, p1;
fix     idx;
{
        static struct coord_i isect;  /* should be static */
        fix32   dx1, dx2, dy1, dy2, dx, dy;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32    divider;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], dest3[2], dest4[2];
        long diff1[2], diff2[2];
        float diff1_f, diff2_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2], dest3[2], dest4[2];
        long diff1[2], diff2[2];
        float diff1_f, diff2_f;
#endif
        real32   s;

        struct coord_i s2, p2;

        s2 = clip[idx].cp;
        p2 = clip[idx+1].cp;

        switch (idx) {
        case 0 :        /* top clip boundary */
        case 2 :        /* bottom clip boundary */
                /* intersect with a horizontal line */
/*                               ((fix32)p1.x - s1.x) /(real32)(p1.y - s1.y);
 *                               (p1.y - s1.y) may exceed integer range @OVR_SFX
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                s =  ((fix32)s2.y - s1.y) *
                                 ((fix32)p1.x - s1.x) /((real32)p1.y - s1.y);
                isect.x = s1.x + ROUND(s);
#elif  FORMAT_16_16
                LongFixsMul((s2.y - s1.y), (p1.x - s1.x), dest1);
                isect.x = s1.x + LongFixsDiv((p1.y - s1.y), dest1);
#elif  FORMAT_28_4
                LongFixsMul((s2.y - s1.y), (p1.x - s1.x), dest1);
                isect.x = s1.x + LongFixsDiv((p1.y - s1.y), dest1);
#endif
                isect.y = s2.y;
                break;

        default :        /* right & left clip boundary */
                if ((dy2 = (fix32)p2.y - s2.y) == 0) {   /* vector is zero */
                        /* intersect with a vertical line */
/*                           ((fix32)p1.y - s1.y) /(real32)(p1.x - s1.x);
 *                             (p1.x - s1.x) may exceed integer range @OVR_SFX
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        s =  ((fix32)s2.x - s1.x) *
                             ((fix32)p1.y - s1.y) /((real32)p1.x - s1.x);
                        isect.y = s1.y + ROUND(s);
#elif  FORMAT_16_16
                        LongFixsMul((s2.x - s1.x), (p1.y - s1.y), dest1);
                        isect.y = s1.y + LongFixsDiv((p1.x - s1.x),dest1);
#elif  FORMAT_28_4
                        LongFixsMul((s2.x - s1.x), (p1.y - s1.y), dest1);
                        isect.y = s1.y + LongFixsDiv((p1.x - s1.x),dest1);
#endif
                        isect.x = s2.x;
                        break;
                } else {
                        dx1 = (fix32)p1.x - s1.x;
                        dx2 = (fix32)p2.x - s2.x;
                        dy1 = (fix32)p1.y - s1.y;
/*                      dy2 = (fix32)p2.y - s2.y; set at previous if statement*/
                        dx = (fix32)s1.x - s2.x;
                        dy = (fix32)s1.y - s2.y;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = (fix32)dx1 * dy2 - (fix32)dx2 * dy1;
                        s = ((fix32)dx2 * dy - (fix32)dy2 * dx) / (real32)divider;
#elif  FORMAT_16_16
                        LongFixsMul(dx1, dy2, dest1);
                        LongFixsMul(dx2, dy1, dest2);
                        LongFixsMul(dx2, dy,  dest3);
                        LongFixsMul(dx,  dy2, dest4);
                        LongFixsSub(dest3, dest4, diff1);
                        LongFixsSub(dest1, dest2, diff2);
                        change_to_real(diff1, &diff1_f);
                        change_to_real(diff2, &diff2_f);
                        s = diff1_f / diff2_f;
#elif  FORMAT_28_4
                        LongFixsMul(dx1, dy2, dest1);
                        LongFixsMul(dx2, dy1, dest2);
                        LongFixsMul(dx2, dy,  dest3);
                        LongFixsMul(dx,  dy2, dest4);
                        LongFixsSub(dest3, dest4, diff1);
                        LongFixsSub(dest1, dest2, diff2);
                        change_to_real(diff1, &diff1_f);
                        change_to_real(diff2, &diff2_f);
                        s = diff1_f / diff2_f;
#endif
                        isect.x = s1.x + ROUND(s * dx1);
                        isect.y = s1.y + ROUND(s * dy1);
                } /* if */
        } /* switch */

        return (&isect);

}


/***********************************************************************
 * This module reduces the input clockwised polygon to a set of trapezoids,
 * and saves each trapezoid.
 *
 * TITLE:       pgn_reduction
 *
 * CALL:        pgn_reduction(in_pgn)
 *
 * PARAMETERS:  in_pgn -- input clockwised polygon
 *
 * INTERFACE:   convex_clipper
 *
 * CALLS:       save_tpzd
 *
 * RETURN:      none
 **********************************************************************/
void pgn_reduction(in_pgn)
struct polygon_i FAR *in_pgn;
{

        struct {
                sfix_t  x0;             /* starting x coordinate */
                sfix_t  y0;             /* starting y coordinate */
                sfix_t  x1;             /* ending x coordinate */
                sfix_t  y1;             /* ending y coordinate */
                sfix_t  xint;           /* x coordinate that goes with scan_y */
        } left[4], right[4];
        fix     left_idx, right_idx;

        struct tpzd tpzd;

        sfix_t  scan_y, last_x, last_y;
        struct  coord_i FAR *ip;
        fix     i;
        fix     l, r;
        bool    done;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif  FORMAT_16_16
        long dest1[2];
#elif  FORMAT_28_4
        long dest1[2];
#endif
#ifdef DBG1
        printf("pgn_reduction():\n");
        for( i =0; i < in_pgn->size; i++) {
                printf(" (%f, %f),", in_pgn->p[i].x/8.0, in_pgn->p[i].y/8.0);
        }
        printf("\n");
#endif

        /* set up left and right edges for polygon reduction */

        last_x = in_pgn->p[0].x;
        last_y = in_pgn->p[0].y;
        left_idx = right_idx = -1;      /* init */

        done = FALSE;
        for (i = 1; !done;
             i++, last_x = ip->x, last_y = ip->y) {
                if (i == in_pgn->size) {
                        /* last edge */
                        ip = &in_pgn->p[0];
                        done = TRUE;
                } else {
                        ip = &in_pgn->p[i];
                }

                /* ignord horiz. edge */
                if (ip->y == last_y) continue;

                /* build edge_table */
                if (ip->y < last_y) {   /* left edge */
                        fix     j;

                        for (j=left_idx; j>=0; j--) {
                                if (ip->y < left[j].y0) {
                                        left[j+1] = left[j];
                                } else {
                                        break;
                                }
                        }
                        j++;

                        left[j].x0 = left[j].xint = ip->x;
                        left[j].y0 = ip->y;
                        left[j].x1 = last_x;
                        left[j].y1 = last_y;
                        left_idx++;

                } else {        /* right edge */
                        fix     j;

                        for (j=right_idx; j>=0; j--) {
                                if (last_y < right[j].y0) {
                                        right[j+1] = right[j];
                                } else {
                                        break;
                                }
                        }
                        j++;

                        right[j].x0 = right[j].xint = last_x;
                        right[j].y0 = last_y;
                        right[j].x1 = ip->x;
                        right[j].y1 = ip->y;
                        right_idx++;
                }

        } /* for */


#ifdef DBG1
        printf("Edge table:\n  idx)    x0     y0     x1     y1\n");
        printf("left edge[0:%d] :", left_idx);
        for (i = 0; i <= left_idx; i++) {
                printf("\t%d     %f      %f      %f      %f\n", i,
                        SFX2F(left[i].x0), SFX2F(left[i].y0),
                        SFX2F(left[i].x1), SFX2F(left[i].y1));
        }
        printf("right edge[0:%d] :", right_idx);
        for (i = 0; i <= right_idx; i++) {
                printf("\t%d     %f      %f      %f      %f\n", i,
                        SFX2F(right[i].x0), SFX2F(right[i].y0),
                        SFX2F(right[i].x1), SFX2F(right[i].y1));
        }
#endif

        /* special processing for degernate polygon: just a horiz. line */
        if (left_idx == -1) {
                sfix_t min_x, max_x;

                min_x = max_x = in_pgn->p[0].x;
                for( i =1; i < in_pgn->size; i++) {
                        if (in_pgn->p[i].x < min_x)
                                min_x = in_pgn->p[i].x;
                        else if (in_pgn->p[i].x > max_x)
                                max_x = in_pgn->p[i].x;
                }

                tpzd.topxl = tpzd.btmxl = min_x;
                tpzd.topxr = tpzd.btmxr = max_x;
                tpzd.btmy = tpzd.topy = in_pgn->p[0].y;
                save_tpzd(&tpzd);
                return;
        }


        /* Main loop, for each disjoint y_coordinate in edge_table */
        l = r = 0;
        for (last_y = left[0].y0; l <= left_idx; last_y = scan_y) {

                if (left[l].y1 == right[r].y1) {
                        scan_y = left[l].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;
                        tpzd.btmxl = left[l].x1;
                        tpzd.btmxr = right[r].x1;
                        l++;
                        r++;
                } else if (left[l].y1 < right[r].y1) {
                        scan_y = left[l].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;

/*                      temp = (real32)(right[r].x1 - right[r].x0) /
 *                                    (right[r].y1 - right[r].y0);
 *                      right[r].xint = right[r].x0 +
 *                              ROUND((scan_y - right[r].y0) * temp);
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        right[r].xint = right[r].x0 + (sfix_t)
                               (((fix32)(scan_y - right[r].y0)) *
                                (right[r].x1 - right[r].x0) /
                                (right[r].y1 - right[r].y0));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - right[r].y0),
                                (right[r].x1 - right[r].x0), dest1);
                        right[r].xint = right[r].x0 +
                           LongFixsDiv((right[r].y1 - right[r].y0), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - right[r].y0),
                                (right[r].x1 - right[r].x0), dest1);
                        right[r].xint = right[r].x0 +
                           LongFixsDiv((right[r].y1 - right[r].y0), dest1);
#endif

                        tpzd.btmxl = left[l].x1;
                        tpzd.btmxr = right[r].xint;
                        l++;
                } else {
                        scan_y = right[r].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;

/*                      temp = (real32)(left[l].x1 - left[l].x0) /
 *                                    (left[l].y1 - left[l].y0);
 *                      left[l].xint = left[l].x0 +
 *                              ROUND((scan_y - left[l].y0) * temp);
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        left[l].xint = left[l].x0 + (sfix_t)
                               (((fix32)(scan_y - left[l].y0)) *
                                (left[l].x1 - left[l].x0) /
                                (left[l].y1 - left[l].y0));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - left[l].y0),
                                        (left[l].x1 - left[l].x0), dest1);
                        left[l].xint = left[l].x0 +
                            LongFixsDiv((left[l].y1 - left[l].y0), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - left[l].y0),
                                        (left[l].x1 - left[l].x0), dest1);
                        left[l].xint = left[l].x0 +
                            LongFixsDiv((left[l].y1 - left[l].y0), dest1);
#endif
                        tpzd.btmxl = left[l].xint;
                        tpzd.btmxr = right[r].x1;
                        r++;
                }

                tpzd.btmy = scan_y;
                tpzd.topy = last_y;

                save_tpzd(&tpzd);

        } /* for */

}


/***********************************************************************
 * This module change CURVETO to LINETO nodes. This routine is for fixing
 * very large circle. @LC
 *
 * TITLE:       iron_subpath
 *
 * CALL:        shape_approximation()
 *
 * PARAMETERS:  first_vertex
 *
 * INTERFACE:   none
 *
 * CALLS:       none
 *
 * RETURN:      SP_IDX
 **********************************************************************/
SP_IDX iron_subpath (first_vertex)
VX_IDX first_vertex;
{
   SP_IDX ret_vlist; /* should be static */
   struct nd_hdr FAR *vtx, FAR *node;
   VX_IDX ivtx, inode, tail;

   printf ("Enter iron_subpath\n");
   st_countnode();

   /* Initialize ret_vlist */
   ret_vlist = tail = NULLP;

   /* Traverse input subpath, and create a new flattened subpath */
   for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
           vtx = &node_table[ivtx];
                   /* Copy the node */
                   inode = get_node();
                   if(inode == NULLP) {
                           ERROR(LIMITCHECK);
                           return (ret_vlist);
                   }
                   node = &node_table[inode];

                   node->next = NULLP;
                   if (vtx->VX_TYPE == CURVETO)
                       node->VX_TYPE = LINETO;
                   else
                       node->VX_TYPE = vtx->VX_TYPE;

                   node->VERTEX_X = vtx->VERTEX_X;
                   node->VERTEX_Y = vtx->VERTEX_Y;

                   /* Append the node to ret_vlist */
                   if (ret_vlist == NULLP) {
                           ret_vlist = inode;
                           node->SP_FLAG =
                               node_table[first_vertex].SP_FLAG;
                   } else
                           node_table[tail].next = inode;
                   tail = inode;
   } /* for */
   node_table[ret_vlist].SP_TAIL = tail;
   node_table[ret_vlist].SP_NEXT = NULLP;

   return (ret_vlist);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\scaling.c ===
/*
 * Copyright (c) 1991 Microsoft Corporation
 */

/***************************************************************************
 *
 *      Name:      scaling.c
 *
 *      Purpose:
 *
 *      Developer: S.Zhang
 *
 *      History:
 *         4/17/91      image_alloc(): return NIL if size not avavilabe
 *                      caller of image_alloc() should set ERROR(LIMITCHECK)
 *                      if return(NIL) from image_alloc.
 *      Version    Date        Comments
 *****************************************************************************/



// DJC added global include
#include "psglobal.h"



#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "image.h"
#include "halftone.h"
#include "fillproc.h"
#include "fillproc.ext"
#include                "win2ti.h"     /* @WIN */


#define     W_ALIGN(size) (((size) + sizeof(fix) - 1) & ~(sizeof(fix) - 1))
#define  register

/* macro for short word swap; @WIN 04-17-92 YM */
#ifdef  bSwap
#define ORSWAP(L)       ((ufix32) ((L) << 24) | ((L) >> 24) |            \
                (((L) << 8) & 0x00ff0000) | (((L) >> 8) & 0x0000ff00))
#define ANDNOTSWAP(L)   ((ufix32) ~(((L) << 24) | ((L) >> 24) |          \
                (((L) << 8) & 0x00ff0000) | (((L) >> 8) & 0x0000ff00)))
#else
#define ORSWAP(L)        (L)
#define ANDNOTSWAP(L)    (~L)
#endif  /*bSwap @WIN*/

// DJC move this structure definition above references by prototypes
struct OUTBUFFINFO
{
    fix16   repeat_y;       /* number of repeat in row */
    fix16  FAR *newdivc;    /* array of number of repeat in col for a pixel */
    ubyte  FAR *valptr0;    /* pointer to data */
    fix16   clipcol;        /* input col size */
    fix16   clipnewc;       /* output col size */
    fix16   clipx;          /* start data after clipping */
    ufix16  htsize;         /* halftone repeat pattern size */
    ufix16  httotal;        /* halftone size */
    ufix16  fbwidth;        /* frame buffer width in word */
    ufix16  fbheight;       /* height of the image @WIN_IM */
    ufix16  start_shift;    /* start position in a word */
    ubyte  FAR *htbound;    /* halftone pattern boundary in col */
    ubyte  FAR *htmin;      /* halftone pattern upper boundary in row */
    ubyte  FAR *htmax;      /* halftone pattern lower boundary in row */
    ubyte  FAR *htptr0;     /* halftone pattern pointer corresponding to data */
    ubyte  FAR *htmax0;     /* halftone pattern lower boundary in row for landscape*/
    ubyte  FAR *htmin0;     /* halftone pattern upper boundary in row for landscape*/
    ufix32 huge *outbuff0;   /* starting word of a line in frame buffer @WIN*/
    fix16   yout;           /* current line count of frame buffer */
    fix16   xout;           /* current col count of frame buffer */
    ubyte   gray[256];           /* convert gray_table for settransfer */
    ubyte   gray0;          /* gray value for 0 */
    ubyte   gray1;          /* gray value for 1 */
    ubyte   grayval;        /* current gray value */
};
/*********** functions declaration **********/
/* @WIN; add prototype */
void     Compress(IMAGE_INFOBLOCK FAR *);
void     Amplify(IMAGE_INFOBLOCK FAR *);
void     AmpInY(IMAGE_INFOBLOCK FAR *);
void     AmpInX(IMAGE_INFOBLOCK FAR *);
void     Calcmp(fix16 FAR *, fix16, float, fix16 FAR *, float);
void     Calamp(fix16 FAR *, fix16, float, fix16 FAR *, float);
void     Getdiv(fix16 FAR *, fix16, fix16, fix16 FAR *, fix16 FAR *);
void     CheckClip(fix16 FAR *, fix16 FAR *, fix16 FAR *,
         fix16 FAR *, fix16 FAR *, fix16 FAR * FAR *);
void     WriteImage(struct OUTBUFFINFO FAR *);
void     WriteImage1(struct OUTBUFFINFO FAR *);
byte     FAR *image_alloc(fix);      /*mslin*/

/***********  global vars  ***************/
#ifdef DBG_MS
  ufix32 dbgtm1,dbgtm2;
#endif


fix16         row, col;     /* raw image height(row) and width(col) */
float         xscale, yscale;       /* scale factor in x and y              */
static ubyte FAR *string;       /* pointer to I/O input  string         */
static int    cChar=0;      /* number of byte in string             */
static fix16 FAR *divr, FAR *divc;  /* pointer to the scaling factor array  */
static fix16  newc, newr;    /* new row and col value after scaling  */
static IMAGE_INFOBLOCK  FAR *image_scale_info;      /*mslin*/
static ubyte  smp_p_b;      /* samples per byte                     */
static ubyte  op_mode;      /* specify scale combinations,          */
static fix    RP_size;      /* repeat pattern size                  */
static ubyte FAR *HTRP;         /* repeat pattern                       */
static ubyte  xmove;        /* for rotation, draw from L->R or R->L */
static ubyte  ymove;        /* for rotation, draw from U->D or D->U */
byte         FAR *image_heap;       /* availabe free buffer                 */
ufix32        outbit;

/***********  extern declaration *********/

extern ubyte   image_dev_flag;     /*defined in image.c */
extern ubyte   image_logic_op;     /*defined in image.c */




/******************************************************************************
* This module read from the infoptr the matrix and other data for image scaling
* and rotation, prepare the halftone repeat pattern and call corresponding
* procedure to do the scale.

* TITLE      :  image_PortrateLandscape

* CALL       :  image_PortrateLandscape(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  scale_image_process()

* CALLS      :  Compress(), Amplify(), AmpInY(), AmpInX(), Calamp(), Calcmp()
                image_alloc()

* RETURN     : none

******************************************************************************/
void image_PortrateLandscape(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;

{
   fix16 i,j,k,l,m,n,ox,oy,x,y;
   ubyte FAR *gray;

/*mslin*/
#ifdef DBG
        {
        lfix_t       FAR *mtxptr;
        real32  m0, m1, m2, m3, m4, m5;

        mtxptr = infoptr->lfxm;
        m0 = LFX2F(mtxptr[0]);
        m1 = LFX2F(mtxptr[1]);
        m2 = LFX2F(mtxptr[2]);
        m3 = LFX2F(mtxptr[3]);
        m4 = LFX2F(mtxptr[4]);
        m5 = LFX2F(mtxptr[5]);
        printf("Enter image_PortrateLandscape\n");
        printf("[%f  %f  %f  %f  %f  %f]\n",
                m0, m1, m2, m3, m4, m5
        );
        printf("width=%d, height=%d, dev_buffer=%lx, dev_buffer_size=%lx\n",
                infoptr->raw_width, infoptr->raw_height, infoptr->dev_buffer,
                infoptr->dev_buffer_size);
        }

#endif

         image_scale_info = infoptr; /*mslin*/
         image_heap = (byte FAR *)image_scale_info->dev_buffer +
                image_scale_info->dev_buffer_size;

        /********  read first input data string ******************/

         if (interpreter(&infoptr->obj_proc))
            {
                ERROR(STACKUNDERFLOW);
                infoptr->ret_code = STACKUNDERFLOW;
                return;
            };
         /*mslin 5/02/91*/
         CHECK_STRINGTYPE();

         string = (ubyte FAR *) VALUE_OPERAND(0);
         if ((cChar = LENGTH_OPERAND(0)) == (ufix) 0)
            {
                infoptr->ret_code = NO_DATA;
                return;
            };

        /*********  Initialization       ***********************/

         smp_p_b = (ubyte) (8/infoptr->bits_p_smp);     //@WIN
         xmove = ymove =1;
         row = infoptr->raw_height;        /* original image height and width */
         col = infoptr->raw_width;
         RP_size = CGS_Patt_Size;

        /********* Build a gray table to map the spotorder
                      from 0 - (CGS_No_Pixels-1) to grayvalue from 0 - 255 ***/

         if ((gray = (ubyte FAR *)image_alloc(CGS_No_Pixels*sizeof(ubyte)))==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
         for(i=1; i<=CGS_No_Pixels;i++)
                   gray[i-1] = (ubyte) ((ufix32)(i*255)/CGS_No_Pixels); //@WIN

        /******** Build the halftone repeat pattern from the spotorder
                                       table CGS_SpotOrder *****************/

         HTRP = (ubyte FAR *)image_alloc(RP_size*RP_size*sizeof(ubyte));
         if (HTRP ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
         m = CGS_MajorFact*CGS_ScaleFact;
         n = CGS_MinorFact*CGS_ScaleFact;
         oy = 0;                                /* 5-2-91, shenzhi */
         ox = ((m==0)||(n==0)) ? 0:(RP_size-n); /* 5-2-91, shenzhi */
         for (k = 0; k < (RP_size/CGS_ScaleFact); k++)
               {
/*                ox = k*n; * 5-2-91, shenzhi */
/*                oy = k*m; * 5-2-91, shenzhi */
                  for (i=0; i< n; i++)
                    {
                       for (j=0; j< n; j++)
                         {
                           x = (ox+j)%(RP_size);
                           y = (oy+i)%(RP_size);
                           HTRP[y*RP_size+x] = gray[CGS_SpotOrder[i*n+j]];
                         };
                   };
                 l = n*n;
                 for (i=0; i< m; i++)
                   {
                      for (j=0; j< m; j++)
                        {
                          x = (ox+j+n)%(RP_size);
                          y = (oy+i)%(RP_size);
                          HTRP[y*RP_size+x] = gray[CGS_SpotOrder[i*m+l+j]];
                        };
                   };
                 ox+=n; /* 5-2-91, shenzhi */
                 oy+=m; /* 5-2-91, shenzhi */
               };

         if (image_dev_flag == PORTRATE)
          {
              /* [A 0 0 D Tx Ty] */
              xscale = LFX2F(infoptr->lfxm[0]);
              yscale = LFX2F(infoptr->lfxm[3]);
              if (xscale <0)
                     xmove = 0;           /*right to left */
              if (yscale <0)
                     ymove = 0;           /*bottom to top */
//            xscale = fabs(xscale);  @WIN
//            yscale = fabs(yscale);
              FABS(xscale, xscale);
              FABS(yscale, yscale);

          }
         else
          {
              /*[0 B C 0 Tx Ty] */
              xscale = LFX2F(infoptr->lfxm[1]);   /*x y scale is for image space */
              yscale = LFX2F(infoptr->lfxm[2]);   /* so read data remain unchanged */
              if (xscale <0)
                     ymove = 0;           /*bottom to top */
              if (yscale <0)
                     xmove = 0;           /*right to left */
//            xscale = fabs(xscale);    @WIN
//            yscale = fabs(yscale);
              FABS(xscale, xscale);
              FABS(yscale, yscale);

          };

        /************ alloc and init scaling factor arrays *****************/

         divr = (fix16 FAR *)image_alloc(sizeof(fix16)*row);        /* for row */
         if (divr==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

         divc = (fix16 FAR *)image_alloc(sizeof(fix16)*col);        /* for col */
         if (divc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

         for(i=0; i<row; i++)
            divr[i] = 0;
         for(i=0; i<col; i++)
            divc[i] = 0;
         if ((yscale >=(float)0.995) && (xscale >= (float)0.995)) //@WIN
           {
               if (yscale < (float)1.005)  /* if scaling within 1+- 0.005, regard it as 1 @WIN*/
                        yscale = (float)1.0;    //@WIN
                if (xscale < (float)1.005)      //@WIN
                        xscale = (float)1.0;    //@WIN
               //UPD055
               //Calamp(divr,row,yscale,&newr);
               Calamp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

               //UPD055
               //Calamp(divc,col,xscale,&newc);
               Calamp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));
               op_mode = 1;        /* amplify */
           }
          else
           {
               if ((yscale < (float)1.0) && (xscale < (float)1.0)) //@WIN
                 {
                    //UPD055
                    //Calcmp(divr,row,yscale,&newr);
                    Calcmp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                    //UPD055
                    //Calcmp(divc,col,xscale,&newc);
                    Calcmp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));

                    op_mode = 2;   /* compress */
                 }
                    else
                         if (yscale >=(float)1.0)       //@WIN
                            {
                               //UPD055
                               //Calamp(divr,row,yscale,&newr);
                               Calamp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                               //UPD055
                               //Calcmp(divc,col,xscale,&newc);
                               Calcmp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));

                               op_mode = 3;  /* amplify in y only */
                            }
                         else
                            {
                               //UPD055
                               //Calcmp(divr,row,yscale,&newr);
                               Calcmp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                               //UPD055
                               //Calamp(divc,col,xscale,&newc);
                               Calamp(divc,col,xscale,&newc, LFX2F(infoptr->lfxm[4]));

                                op_mode = 4;   /* amplify in x only */
                            };

           };
/* shenzhi
   printf("raw width high %d %d \n",col, row);
   printf("newc newr  %d %d  \n",newc, newr);
   printf("xscale yscale %f %f \n",xscale,yscale);
   printf("smp_p_b op_mode %d %d \n",smp_p_b, op_mode);
   printf("xorig,yorig %d %d\n",infoptr->xorig,infoptr->yorig);
*/

/****** according to op_mode value, call different procedure   ****/
/* these procedures are almost identical and they are seperated
   only for performance consideration                          ****/

   switch(op_mode)
    {
     case 0:
     case 1:
          Amplify(infoptr);
          break;
     case 2:
          Compress(infoptr);
          break;
     case 3:
          AmpInY(infoptr);
          break;
     case 4:
          AmpInX(infoptr);
    };
}


/******************************************************************************
* This module read input data and process the case xscale <1 and yscale <1.

* TITLE      :  Compress

* CALL       :  Compress(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/
void Compress(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,FAR *divcol,dx,ctIn,samps;
    fix16 i;
    fix16 y;
    fix16  slen;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16 xorig,yorig;
    struct OUTBUFFINFO writebuff;

    /************* initialization ***************/

    colval =newc;
      /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;        /* length of input string */
    ctIn =0;
    str = string;       /* begining of input string */
    samps = smp_p_b-1;  /* samples per byte -1 */
    /* alloc array for input data */
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

    strmax = string+slen;   /* end of input string */
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;  /* frame buffer width in word */
    writebuff.htsize = (ufix16)RP_size;       /* halftone repeat pattern size */
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.clipnewc = newc;
    writebuff.newdivc = (fix16 FAR *)image_alloc(newc*sizeof(fix16));
    if (writebuff.newdivc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

    writebuff.clipx = 0;
    /* default clipping bounding box */

    /***********if clipping, calculate new origin, width, starting data,etc ***/
    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));
    for (i=0; i< writebuff.clipnewc; i++)
        writebuff.newdivc[i] = 1;                /* compress, each pixel has at most only one output */
    writebuff.clipcol =writebuff.clipnewc ;

#ifdef DBG
    printf("new xyorig clipx clipnewc %d %d %d %d\n",xorig,yorig,writebuff.clipx,writebuff.clipnewc);
#endif
/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout =yorig;
    writebuff.xout = xorig;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;       /* up right boundary */
            writebuff.htmax = HTRP + writebuff.httotal;    /* bottom right boundary */
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);    /* corresponding to starting pixel */
            writebuff.htbound +=writebuff.htsize;          /* right boundary */
       }
    else
       {
            writebuff.htmin = HTRP-1;            /* up left boundary */
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;     /* bottom left */
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;               /* left boundary */
       };
    writebuff.htmin0 = HTRP;            /* htmin0 and htmax0 are for landscape */
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;    /* starting pixel position in a word (0 if at left most )*/
    outbit = ONE1_32 LSHIFT writebuff.start_shift;

    /************* mapping graylevel of input data to the gray_table ****/

    j= 1<<infoptr->bits_p_smp;      /****input data graylevel ***/
    for (i=0; i<j; i++)
      {
       writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
      };

    writebuff.gray1 = writebuff.gray[j-1]; /*gray1 and gray0 is the grayvalue for 1 bit case: 0, 1***/
    writebuff.gray0 = writebuff.gray[0];

    /************draw one line each time. ***********/
    /************for line i, there are divr[i] lines of input data for it****/

    writebuff.repeat_y = 1;
    for(i=0; i< newr; i++)
     {
             divcol = divc;
             valptr = writebuff.valptr0;
             colval=newc;
             do
              {
                *valptr++ = 0;           /* initialization */
              } while (--colval);
             switch(infoptr->bits_p_smp)
              {
                    case 1:               /* 1 bit case */
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;        /* count the # of pixel in a input byte */
                               divcol = divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;     /* number of input data */
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };

                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if((x==0) && (y==1))
                                     {
                                        if (val &0x80)
                                          *valptr = 1;
                                        valptr++;
                                     };
                                     val <<=1;
                                   };
                                } while (--colval);
                           };      /* end of preparing a output line */
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC          PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);

                          break;
                    case 2:           /*****2 bit case *******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol= divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/


                                     if((x==0) &&(y==1))
                                      {
                                        *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                      };
                                     val <<=2;
                                   };
                                } while (--colval);
                           };

                          break;
                    case 4:                    /**** 4 bit case *******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if ((x==0)&&(y==1))
                                      {
                                        *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                      };
                                     val <<=4;
                                   };
                                } while (--colval);
                           };
                          break;
                    case 8:                /***8 bit case ******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol=divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if ((x==0)&&(y==1))
                                        *valptr++ = *str;
                                     str++;
                                   };
                                } while (--colval);
                           };
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                  // WriteImage(&writebuff);      // @WIN_IM
                  if(bGDIRender)
                    // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                    // DJC                PROC_IMAGE, (LPSTR)&writebuff);
                    ; // DJC
                  else
                    WriteImage(&writebuff);
               };
     };

}


/******************************************************************************
* This module read input data and process the case xscale >=1 and yscale >=1.

* TITLE      :  Amplify

* CALL       :  Amplify(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void Amplify(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,ctIn,samps,FAR *divcol;
    fix16 i;
//  fix16 y;    @WIN
    fix16  slen;
    register ubyte FAR *valptr,val;
    register ubyte FAR *str,FAR *strmax;
    fix16 xorig,yorig;
    struct OUTBUFFINFO writebuff;
    fix16 WinXorig;                           // @WIN
    fix16 WinYorig;                           // @WIN

    /*******initiate **************/
    colval =col;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0= (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    WinXorig = xorig;                           // @WIN
    WinYorig = yorig;                           // @WIN
    writebuff.newdivc = divc;
    writebuff.clipnewc = newc;
    writebuff.clipcol = col;
    writebuff.clipx = 0;
    /* clipping bounding box */

    /***********if clipping, calculate new origin, width, starting data,etc ***/

    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
x = xorig;
    writebuff.yout = yorig;
    writebuff.xout = xorig;

    /***************same as Compress(), see comments of Compress() ****/

//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
    writebuff.gray1 = writebuff.gray[j-1];   /* 1 bit case, gray corresponding 1 */
    writebuff.gray0 = writebuff.gray[0];     /* 1 bit case, gray corresponding 0 */
#ifdef DBG_MS
    dbgtm1 = curtime();
#endif
    for(i=0; i< row; i++)
     {
             valptr = writebuff.valptr0;
             ctIn =0;
             colval = col;
             writebuff.repeat_y = divr[i];
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (val >=128)  /* equal to (val & 0x80) */
                                        *valptr++ = 1;
                                     else
                                        *valptr++ = 0;
                                     val <<=1;
                             } while (--colval);
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                            if (image_dev_flag == PORTRATE) {     //@WIN_IM
                               // DJC GDIBitmap(WinXorig, WinYorig,
                               // DJC          newc, writebuff.repeat_y, (ufix16)NULL,
                               // DJC          PROC_IMAGE1, (LPSTR)&writebuff);
                               WinYorig += writebuff.repeat_y;
                            } else {
                               // DJC GDIBitmap(WinXorig, WinYorig,
                               // DJC           writebuff.repeat_y, newc, (ufix16)NULL,
                               // DJC           PROC_IMAGE1, (LPSTR)&writebuff);
                               WinXorig += writebuff.repeat_y;
                            }
                          else
                            WriteImage1(&writebuff);
                          break;
                    case 2:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     *valptr++ = (ubyte)((val & 0xc0)>>6);//@WIN
                                     val <<=2;
                             } while (--colval);
                          break;
                    case 4:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     *valptr++ = (ubyte)((val & 0xf0)>>4); //@WIN
                                     val <<=4;

                             } while (--colval);
                          break;
                    case 8:
                          do
                             {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                        *valptr++ = *str++;
                             } while (--colval);
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                  // WriteImage(&writebuff);      // @WIN_IM
                  if(bGDIRender)
                      if (image_dev_flag == PORTRATE) {     //@WIN_IM
                         // DJC GDIBitmap(WinXorig, WinYorig,
                         // DJC           newc, writebuff.repeat_y, (ufix16)NULL,
                         // DJC           PROC_IMAGE, (LPSTR)&writebuff);
                         WinYorig += writebuff.repeat_y;
                      } else {
                         // DJC GDIBitmap(WinXorig, WinYorig,
                         // DJC           writebuff.repeat_y, newc, (ufix16)NULL,
                         // DJC          PROC_IMAGE, (LPSTR)&writebuff);
                         WinXorig += writebuff.repeat_y;
                      }
                  else
                      WriteImage(&writebuff);
               };
     };
#ifdef DBG_MS
     dbgtm2=curtime();
#endif
}

/******************************************************************************
* This module calculate the new origins, new size of col, starting point
* of input data, etc after clipping.

* TITLE      :  CheckClip

* CALL       :  CheckClip(xorig,yorig,clipnewc,clipcol,clipx,newdivc)

* PARAMETERS :  xorig,yorig: the x y origin of the image in frame buffer
                clipnewc   : new scaled width after clipping
                clipcol    : new non_sclaed width after clipping
                clipx      : new starting point of input data
                newdivc    : new scale factor array after clipping
* INTERFACE  :  Compress(), Amplify(), AmpInY(), AmpInX()

* CALLS      :  Getdiv()

* RETURN     : none

******************************************************************************/

void CheckClip(xorig,yorig,clipnewc,clipcol,clipx,newdivc)
fix16 FAR *xorig,FAR *yorig,FAR *clipnewc,FAR *clipcol,FAR *clipx,FAR * FAR *newdivc;
{
           fix16 lx,ly,ux,uy;
           fix16 x,y;

           ux = SFX2I(GSptr->clip_path.bb_ux);
           lx = SFX2I(GSptr->clip_path.bb_lx);
           uy = SFX2I(GSptr->clip_path.bb_uy);
           ly = SFX2I(GSptr->clip_path.bb_ly);

           if (image_dev_flag == PORTRATE)
              {
                 if (xmove)
                   {
                      x = *xorig +newc-1;
                      if ((*xorig >ux)|| (x < lx))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*xorig < lx)
                              {
                               *clipx = lx-*xorig;
                               *xorig = lx;
                              };
                            if (x>ux)
                              *clipnewc = ux - *xorig+1;
                            else
                              *clipnewc = x - *xorig+1;

          /*****scale factor needs to be recalculated only for amplifying case ***/
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };

                       };
                   }
                 else
                   {
                      x = *xorig -newc+1;
                      if ((*xorig <lx)|| (x >ux))
                         {
                            *clipcol = 0;
                            *clipnewc =0;
                         }
                      else
                       {
                            if (*xorig > ux)
                              {
                               *clipx = *xorig-ux;
                               *xorig = ux;
                              };
                            if (x<lx)
                              *clipnewc = *xorig-lx+1;
                            else
                              *clipnewc = *xorig-x+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   };
              }
           else
              {
                if (ymove)
                   {
                      y = *yorig +newc-1;
                      if ((*yorig >uy)|| (y <ly))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*yorig < ly)
                              {
                               *clipx = ly-*yorig;
                               *yorig = ly;
                              };
                            if (y>uy)
                              *clipnewc = uy - *yorig+1;
                            else
                              *clipnewc = y - *yorig+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                               *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                               Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   }
                else
                   {
                      y = *yorig -newc+1;
                      if ((*yorig <ly)|| (y >uy))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*yorig > uy)
                              {
                               *clipx = *yorig - uy;
                               *yorig = uy;
                              };
                            if (y<ly)
                              *clipnewc = *yorig -ly+1;
                            else
                              *clipnewc = *yorig -y+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   };
              };

}


/******************************************************************************
* This module calculate new scale factor array from the scalefactor array
* divc or divr by applying clipping to it.

* TITLE      :  Getdiv

* CALL       :  Getdiv(div, clipx,clipnewc,clipcol,newclipx)

* PARAMETERS :  div        : pointer to the new scale factor array
                clipx      : starting point of clipped output(0 if no clipping)
                clipnew    : clipped out put width.
                clipcol    : clipped input width
                newclipx   : starting point of clipped input(0 if no clipping)


* INTERFACE  :  CheckClip()

* CALLS      :  none

* RETURN     :  none

******************************************************************************/

void Getdiv(div, clipx,clipnewc,clipcol,newclipx)
fix16 FAR * div;
fix16 clipx;
fix16 clipnewc;
fix16 FAR *clipcol;
fix16 FAR *newclipx;
{
//  ufix16 a,b,i,j;     //@WIN
    fix16 a,b,i,j;

    a=b=i=j=0;
    while (a < clipx)
     {
        a+=divc[i++];
     };
    *newclipx = i;
    if (a>clipx)
         {
           div[j++] = a-clipx;
           *newclipx -=1;
           b = div[0];
         };
    while (b < clipnewc)
      {
         b+=divc[i];
         div[j++] = divc[i++];
      };
    if (b>clipnewc)
      div[j-1] -=(b-clipnewc);
    *clipcol = j;
}


/******************************************************************************
* This module calculate for each input pixel i, the number of output
* pixels div[i] corresponding to it.

* TITLE      :  Calamp

* CALL       :  Calamp(div,size,scale,newsize)

* PARAMETERS :  div    : pointer to scale factor array
                size   : input size(width or height)
                scale  : scale factor
                newsize: size after scaling

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  none

* RETURN     : none

******************************************************************************/

//void Calamp(div,size,scale,newsize)???@WIN; void the waring message from C6.0
//fix16 FAR * div;
//fix16 size;
//float scale;
//fix16 FAR *newsize;
void Calamp(fix16 FAR * div, fix16 size, float scale, fix16 FAR *newsize,float disp)
{
  fix32 cReal;
  fix32 cOut,cIn,scale1;
  //UPD055
  fix32 divsum;
  float f1;
  fix32 cOuttune;

  if ( disp < 0.0 ) {
      disp = (float)0.0;
  }


  scale1 = (fix32)(scale*256);
  cOut = (fix32)((((fix16)(disp / scale)) * scale) + .5);
  cOut = cOut << 8;

  cReal = (fix32) (disp * 256 + .5 );

  if ((cReal - cOut ) > 256 ) {
     f1 = scale / (fix32)(scale+.5);
     cOuttune = (fix32)(f1*256 + .5);
     cOut += cOuttune * ((fix32)floor((cReal - cOut) / cOuttune));
  }


  *newsize = 0;
  divsum = 0;


  for(cIn =0; cIn<size; cIn++)
      {
          cReal +=scale1;
          div[cIn] = (fix16) ((cReal+128 -cOut)>>8);    //@WIN
          //DJC cOut +=div[cIn]<<8;
          divsum += div[cIn];

          cOut +=((fix32)div[cIn]) << 8;
      };
  *newsize = (fix16)(divsum);  //@WIN
}



/******************************************************************************
* This module calculate for each output pixel i, the position of input
* pixel div[i] corresponding to it.

* TITLE      :  Calcmp

* CALL       :  Calcmp(div,size,scale,newsize)

* PARAMETERS :  div    : pointer to scale factor array
                size   : input size(width or height)
                scale  : scale factor
                newsize: size after scaling

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  none

* RETURN     : none

******************************************************************************/

//void Calcmp(div,size,scale,newsize)???@WIN; void the waring message from C6.0
//fix16 FAR * div;
//fix16 size;
//float scale;
//fix16 FAR *newsize;
void Calcmp(fix16 FAR * div, fix16 size, float scale, fix16 FAR *newsize, float disp)
{
  fix32 scale1,cReal;
  fix32 cIn, cOut,size1,cOut1;
  float f1;
  fix32 cOuttune;



  //UPD055
  scale1 = (fix32)(256.0 / scale + .5);
  cOut = ((lfix_t)(floor(((ROUND(disp) - disp)) * 256 + 0.5)));

  cOuttune = cOut;
  cReal = 0;
  cIn = 0;
  size1 = ((fix32)size << 8) + cOut;
  while( cOut < size1) {

     cReal += scale1;
     div[cIn] = (fix16) ((cReal + 128 - cOut) >> 8);
     cOut += (fix32) div[cIn++] << 8;
  }
  cOut = (cOut - cOuttune) >> 8;
  if (cOut > size) {
     div[cIn-1] -= (fix16)(cOut - size);
  }
  *newsize = (fix16)cIn;



#ifdef DJC_OLD_CODE
  cReal = 0;
  cOut = 0;
  cIn =0;
  //DJC size1 = size<<8;
  size1 = (fix32) size<<8;
  scale1 = (fix32)(256.0 /scale+0.5);
  while (cOut < size1 )
   {
       cReal +=scale1;
       div[cIn] = (fix16) ((cReal+cIn%5 - cOut)>>8);    //@WIN
       //DJC cOut +=div[cIn++]<<8;
       cOut +=(fix32)div[cIn++]<<8;
   };
  cOut >>=8;
  if (cOut > size)
       div[cIn-1] -=(fix16)(cOut-size); //@WIN
  *newsize = (fix16)cIn;        //@WIN
#endif

}


/******************************************************************************
* This module read input data and process the case xscale < 1 and yscale >=1.

* TITLE      :  AmpInY

* CALL       :  AmpInY(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void AmpInY(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,dx,ctIn,samps,FAR *divcol;
    fix16 i;
//  fix16 y;    @WIN
    fix16  slen;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16  xorig,yorig;
    struct OUTBUFFINFO writebuff;

    /* shenzhi */

    colval =newc;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.clipnewc = newc;
    writebuff.newdivc = (fix16 FAR *)image_alloc(newc*sizeof(fix16));
    if (writebuff.newdivc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    writebuff.clipx =0;
    /* clipping bounding box */

    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));
    for (i=0; i< writebuff.clipnewc; i++)
        writebuff.newdivc[i] = 1;                /* compress, each pixel has at most only one output */
    writebuff.clipcol =writebuff.clipnewc ;

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout =yorig;
    writebuff.xout = xorig;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
    writebuff.gray1 = writebuff.gray[j-1];
    writebuff.gray0 = writebuff.gray[0];
    for(i=0; i< row; i++)
     {
             writebuff.repeat_y = divr[i];
             valptr = writebuff.valptr0;
             divcol = divc;
             colval=newc;
             do
              {
                *valptr++ = 0;
              } while (--colval);
             valptr = writebuff.valptr0;
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          ctIn =0;
                          divcol = divc;
                          colval=newc;
                          do
                           {
                            dx = *divcol++;
                            for(x=0; x<dx;x++)
                              {
                                if (ctIn-- ==0)
                                  {
                                   if (str ==strmax )
                                     {
                                       POP(1);

                                       if (interpreter(&(infoptr->obj_proc)))
                                        {

                                           ERROR(STACKUNDERFLOW);
                                           infoptr->ret_code = STACKUNDERFLOW;
                                           return;
                                        }
                                       /*mslin 5/02/91*/
                                       CHECK_STRINGTYPE();
                                       str = (ubyte FAR *) VALUE_OPERAND(0);
                                       if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                        {
                                           infoptr->ret_code = NO_DATA;
                                           return;
                                        }
                                       strmax = str+slen;

                                     };
                                    val = *str++;
                                    ctIn = samps;
                                  };
                                if (x ==0)
                                 {
                                  if (val &0x80)
                                    *valptr = 1;
                                  valptr++;
                                 };
                                val <<=1;
                              };
                           } while (--colval);
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC        PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);
                          break;
                    case 2:
                               ctIn =0;
                               divcol= divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx;x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (x==0)
                                         *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                     val <<=2;
                                   };
                                } while (--colval);

                          break;
                    case 4:
                               ctIn =0;
                               divcol = divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (x==0)
                                        *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                     val <<=4;
                                   };
                                } while (--colval);
                          break;
                    case 8:
                               divcol=divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                     if (x==0)
                                          *valptr++ = *str;
                                     str++;
                                   };
                                } while (--colval);
                          break;
              };
             if (infoptr->bits_p_smp !=1)
                {
                     // WriteImage(&writebuff);      // @WIN_IM
                     if(bGDIRender)
                        // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                        // DJC       PROC_IMAGE, (LPSTR)&writebuff);
                        ; // DJC
                     else
                        WriteImage(&writebuff);
                };
     };

}






/******************************************************************************
* This module read input data and process the case xscale >= 1 and yscale < 1

* TITLE      :  AmpInX

* CALL       :  AmpInX(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void AmpInX(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,ctIn,samps,FAR *divcol;
    fix16 i;
    fix16 y;
    fix16  slen,thres;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16  xorig,yorig;
    struct OUTBUFFINFO writebuff;
    /* shenzhi */



    colval =col;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.newdivc = divc;
    writebuff.clipnewc = newc;
    writebuff.clipcol = col;
    writebuff.clipx = 0;

    if (image_logic_op & IMAGE_CLIP_BIT)
        CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout = yorig;
    writebuff.xout = xorig;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
                            /*** grayscale is 0x4000 */
    writebuff.gray1 = writebuff.gray[j-1];
    writebuff.gray0 = writebuff.gray[0];
    writebuff.repeat_y = 1;

    for(i=0; i< newr; i++)
     {
             divcol = divc;
             valptr = writebuff.valptr0;
             colval=col;
             thres = divr[i];
             do
              {
                *valptr++ = 0;
              } while (--colval);
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval=col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y == 1)
                                       {
                                         if (val & 0x80)
                                                *valptr = 1;
                                         valptr++;
                                       };
                                     val <<=1;
                                } while (--colval);
                           };
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC       PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);
                          break;
                    case 2:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol= divc;
                               colval=col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y==1)
                                         *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                     val <<=2;
                                } while (--colval);
                           };

                          break;
                    case 4:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval = col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y==1)
                                         *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                     val <<=4;
                                } while (--colval);
                           };
                          break;
                    case 8:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               divcol=divc;
                               colval = col;
                               do
                                {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                     if (y==1)
                                        *valptr++ = *str;
                                      str++;
                                } while (--colval);
                           };
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                     // WriteImage(&writebuff);      // @WIN_IM
                     if(bGDIRender)
                        // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                        // DJC       PROC_IMAGE, (LPSTR)&writebuff);
                        ; // DJC
                     else
                        WriteImage(&writebuff);
               };
     };

}


/******************************************************************************
* This procedure receives a data structure containing : number of repeat in row,
* number of repeat for a data in col, col length, pointer to data,
* starting word in frame buffer, starting position in a word,
* halftone pointer, halftone boundaries.
* Then output the data to frame buffer.

* TITLE      :  WriteImage

* CALL       :  WriteImage(writebuffptr)

* PARAMETERS :  writebuffptr: pointer to a data struct containing all infos
                for writing a line(or several lines) for a dataline.

* INTERFACE  :  Compress(), Amplify(), AmpInY(), ampInX()

* CALLS      :  none

* RETURN     : none

******************************************************************************/
void WriteImage(writebuffptr)
struct OUTBUFFINFO FAR *writebuffptr;
{
//  ufix16           y;         @WIN
    fix16           y;
    fix16           FAR *divcol;        /* array of number of repeat in col for a pixel */
    fix16            colval;
    register ubyte  FAR *valptr;        /* pointer to data */
    ufix16           htsize;         /* halftone repeat pattern size */
    ufix16           httotal;        /* halftone size */
    ufix16           fbwidth;        /* frame buffer width in word */
    register ubyte  FAR *htbound;        /* halftone pattern boundary in col */
    ubyte           FAR *htmin;          /* halftone pattern upper boundary in row */
    ubyte           FAR *htmax;          /* halftone pattern lower boundary in row */
    register ubyte  FAR *htptr1;
    ubyte           FAR *htmax0;         /* halftone pattern lower boundary in row for landscape*/
    ubyte           FAR *htmin0;         /* halftone pattern upper boundary in row for landscape*/
    register ufix32 huge *outbuff1;      /* starting word of a line in frame buffer @WIN*/
    register ufix32  dx,bt;
    register ubyte   val;
    register ubyte  FAR *gray;           /* convert gray_table for settransfer */
    fix16            ux,uy,lx,ly;


    htsize =writebuffptr->htsize;
    httotal =writebuffptr->httotal;
    fbwidth =writebuffptr->fbwidth;
    htbound =writebuffptr->htbound;
    htmin =writebuffptr->htmin;
    htmax =writebuffptr->htmax;
    htmax0 =writebuffptr->htmax0;
    htmin0 =writebuffptr->htmin0;
    gray =writebuffptr->gray;
    /* clipping bounding box */
    ux = SFX2I(GSptr->clip_path.bb_ux);
    lx = SFX2I(GSptr->clip_path.bb_lx);
    uy = SFX2I(GSptr->clip_path.bb_uy);
    ly = SFX2I(GSptr->clip_path.bb_ly);
    bt = outbit;
    if ((image_dev_flag == PORTRATE) && (xmove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0 + writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            bt = ONE1_32 LSHIFT writebuffptr->start_shift;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                /*check clipping in image row */
            if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
              {
               do
                  {
                                /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1++ > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         if ((bt LSHIFTEQ 1) ==0)
                           {
                              outbuff1++;
                              bt = ONE1_32;
                           };
                         if (htptr1 ==htbound)
                               htptr1 -=htsize;
                      } while (--dx);
                 } while (--colval);
              };
            if (ymove)
              {
                  htbound +=htsize;
                  writebuffptr->htptr0 += htsize;
                  writebuffptr->outbuff0 +=fbwidth;
                  if (htbound > htmax)
                     {
                         htbound = htmin;
                         writebuffptr->htptr0 -=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout++;
              }
            else
              {
                  htbound -=htsize;
                  writebuffptr->htptr0 -= htsize;
                  writebuffptr->outbuff0 -=fbwidth;
                  if (htbound < htmin)
                     {
                         htbound = htmax;
                         writebuffptr->htptr0 +=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout--;
              };
         };                           /* end if portrait */
    if ((image_dev_flag == PORTRATE)&& (!xmove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            bt = ONE1_32 LSHIFT writebuffptr->start_shift;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                      /*check clipping in image row */
            if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
             {
               do
                  {
                                      /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1-- > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         if ((bt RSHIFTEQ 1) ==0)
                           {
                              outbuff1--;
                              bt = ONE8000;
                           };
                         if (htptr1 ==htbound)
                               htptr1 +=htsize;
                      } while (--dx);
                 } while (--colval);
             };
            if (ymove)
              {
                  htbound +=htsize;
                  writebuffptr->htptr0 += htsize;
                  writebuffptr->outbuff0 +=fbwidth;
                  if (htbound > htmax)
                     {
                         htbound = htmin;
                         writebuffptr->htptr0 -=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout++;
              }
            else
              {
                  htbound -=htsize;
                  writebuffptr->htptr0 -= htsize;
                  writebuffptr->outbuff0 -=fbwidth;
                  if (htbound < htmin)
                     {
                         htbound = htmax;
                         writebuffptr->htptr0 +=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout--;
              };
         };                    /* end if updown */
    if ((image_dev_flag == LANDSCAPE)&&(ymove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                      /*check clipping in image row */
            if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
             {
               do
                  {
                                      /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1 > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         outbuff1 +=fbwidth;
                         if ((htptr1+=htsize) > htmax0)
                               htptr1 -=httotal;
                      } while (--dx);
                 } while (--colval);
             };
            if (xmove)
              {
                  if (++writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 -=htsize;
                  if ((bt LSHIFTEQ 1)==0)
                     {
                           bt = ONE1_32;
                           writebuffptr->outbuff0 +=1;
                     };
                  writebuffptr->xout++;
              }
            else
              {
                  if (--writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 +=htsize;
                  if ((bt RSHIFTEQ 1)==0)
                     {
                           bt = ONE8000;
                           writebuffptr->outbuff0 -=1;
                     };
                  writebuffptr->xout--;
              }

         };             /* end if top->down land */
    if ((image_dev_flag == LANDSCAPE) && (!ymove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                     /*check clipping in image row */
            if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
              {
               do
                  {
                                     /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1 > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         outbuff1 -=fbwidth;
                         if ((htptr1-=htsize) < htmin0)
                               htptr1 +=httotal;
                      } while (--dx);
                 } while (--colval);
              };
            if (xmove)
              {
                  if (++writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 -=htsize;
                  if ((bt LSHIFTEQ 1)==0)
                     {
                           bt = ONE1_32;
                           writebuffptr->outbuff0 +=1;
                     };
                  writebuffptr->xout++;
              }
            else
              {
                  if (--writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 +=htsize;
                  if ((bt RSHIFTEQ 1)==0)
                     {
                           bt = ONE8000;
                           writebuffptr->outbuff0 -=1;
                     };
                  writebuffptr->xout--;
              }

         };             /* end if bottom->up land */
         outbit = bt;


}



/******************************************************************************
* This procedure receives a data structure containing : number of repeat in row,
* number of repeat for a data in col, col length, pointer to data,
* starting word in frame buffer, starting position in a word,
* halftone pointer, halftone boundaries.
* Then output the data to frame buffer.
* This is the same as WriteImage except it for 1 bit case.

* TITLE      :  WriteImage1

* CALL       :  WriteImage1(writebuffptr)

* PARAMETERS :  writebuffptr: pointer to a data struct containing all infos
                for writing a line(or several lines) for a dataline.

* INTERFACE  :  Compress(), Amplify(), AmpInY(), ampInX()

* CALLS      :  none

* RETURN     : none

******************************************************************************/
void WriteImage1(writebuffptr)
struct OUTBUFFINFO FAR *writebuffptr;
{
//  ufix16           y;         @WIN
    fix16           y;
    fix16           FAR *divcol;        /* array of number of repeat in col for a pixel */
    fix16            colval;
    register ubyte  FAR *valptr;        /* pointer to data */
    ufix16           htsize;         /* halftone repeat pattern size */
    ufix16           httotal;        /* halftone size */
    ufix16           fbwidth;        /* frame buffer width in word */
    register ubyte  FAR *htbound;        /* halftone pattern boundary in col */
    ubyte           FAR *htmin;          /* halftone pattern upper boundary in row */
    ubyte           FAR *htmax;          /* halftone pattern lower boundary in row */
    register ubyte  FAR *htptr1;
    ubyte           FAR *htmax0;         /* halftone pattern lower boundary in row for landscape*/
    ubyte           FAR *htmin0;         /* halftone pattern upper boundary in row for landscape*/
    register ufix32 huge *outbuff1;      /* starting word of a line in frame buffer @WIN*/
    register ufix32  dx,bt;
    register ubyte   val;
    register ubyte  FAR *gray;           /* convert gray_table for settransfer */
    register ubyte   gray0;          /* gray value for 0 */
    register ubyte   gray1;          /* gray value for 1 */
    register ubyte   grayval;        /* current gray value */
    fix16            ux,uy,lx,ly;
    ubyte            fastflag =0;

    htsize =writebuffptr->htsize;
    httotal =writebuffptr->httotal;
    fbwidth =writebuffptr->fbwidth;
    htbound =writebuffptr->htbound;
    htmin =writebuffptr->htmin;
    htmax =writebuffptr->htmax;
    htmax0 =writebuffptr->htmax0;
    htmin0 =writebuffptr->htmin0;
    gray =writebuffptr->gray;
    gray0 =writebuffptr->gray0;
    gray1 =writebuffptr->gray1;
    grayval =writebuffptr->grayval;
    htptr1 = writebuffptr->htptr0;
    ux = SFX2I(GSptr->clip_path.bb_ux);
    lx = SFX2I(GSptr->clip_path.bb_lx);
    uy = SFX2I(GSptr->clip_path.bb_uy);
    ly = SFX2I(GSptr->clip_path.bb_ly);
    bt = outbit;
    if ((gray1 ==255) && (gray0==0) &&(image_logic_op & IMAGE_BIT))
        fastflag = 1;         /* in 1 bit case , no settransfer, no halftone */
    if ((grayval<=2) && !(image_logic_op & IMAGE_BIT)) /* grayval is black*/
        fastflag =1;          /* in 1 bit case , no settransfer, no halftone */


    if (fastflag)  /* no halftone needed */
       {
         if ((image_dev_flag == PORTRATE)&&(xmove))
           for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                            /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&& colval)
                    {
                     if (image_logic_op & IMAGE_BIT)
                      {
                       do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt LSHIFTEQ 1)==0)
                                     {
                                       bt = ONE1_32;
                                       outbuff1++;
                                     };
                               } while (--dx);
                         } while (--colval);
                      }
                     else
                      {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                                 /* if 0, apply current gray */
                                       if (val==0)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                       if (val)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                    } while (--dx);
                              } while (--colval);
                      };
                    };
                  if (ymove)
                    {
                      writebuffptr->outbuff0 +=writebuffptr->fbwidth;
                      writebuffptr->yout++;
                    }
                  else
                    {
                       writebuffptr->outbuff0 -=writebuffptr->fbwidth;
                       writebuffptr->yout--;
                    };
             };

         if ((image_dev_flag == PORTRATE)&&(!xmove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                              /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                     *outbuff1 |= ORSWAP(bt);
                                  if ((bt RSHIFTEQ 1)==0)
                                     {
                                       bt = ONE8000;
                                       outbuff1--;
                                     };
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                           if (image_logic_op & IMAGEMASK_FALSE_BIT)
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                              /* if 0, apply current gray */
                                        if (val==0)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                     } while (--dx);
                               } while (--colval);
                           else
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                        if (val )
                                          if (grayval <*htptr1)
//                                           *outbuff1 |=bt;     @WIN_IM; swap it
                                             *outbuff1 |= ORSWAP(bt);
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                     } while (--dx);
                               }  while (--colval);
                        };
                   };
                  if (ymove)
                            {
                               writebuffptr->outbuff0 +=writebuffptr->fbwidth;
                               writebuffptr->yout++;
                            }
                  else
                            {
                               writebuffptr->outbuff0 -=writebuffptr->fbwidth;
                               writebuffptr->yout--;
                            };
             };
         if ((image_dev_flag == LANDSCAPE)&& (ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0 + writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                                /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&& colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                       {
                        do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 +=fbwidth;
                               } while (--dx);
                         } while (--colval);
                       }
                     else
                       {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                           /* if 0, apply current gray */
                                       if (val==0)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       outbuff1 +=fbwidth;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                       if (val)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       outbuff1 +=fbwidth;
                                    } while (--dx);
                              } while (--colval);

                       };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                         writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                         writebuffptr->xout--;
                     }
             };
         if ((image_dev_flag == LANDSCAPE)&& (!ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                                    /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 -=fbwidth;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                            if (image_logic_op & IMAGEMASK_FALSE_BIT)
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                              /* if 0, apply current gray */
                                         if (val==0)
//                                            *outbuff1 |=bt;     @WIN_IM; swap it
                                              *outbuff1 |= ORSWAP(bt);
                                         outbuff1 -=fbwidth;
                                      } while (--dx);
                                } while (--colval);
                            else
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                         if (val)
//                                            *outbuff1 |=bt;     @WIN_IM; swap it
                                              *outbuff1 |= ORSWAP(bt);
                                         outbuff1 -=fbwidth;
                                      } while (--dx);
                                } while (--colval);
                        };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                        writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                        writebuffptr->xout--;
                     }
             };
         outbit = bt;
         return;
       };

    if ((image_dev_flag == PORTRATE)&&(xmove))
           for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                   /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&& colval)
                    {
                     if (image_logic_op & IMAGE_BIT)
                      {
                       do
                         {
                            if (*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1++ > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt LSHIFTEQ 1)==0)
                                     {
                                       bt = ONE1_32;
                                       outbuff1++;
                                     };
                                  if (htptr1 ==htbound)
                                      htptr1 -=htsize;
                               } while (--dx);
                         } while (--colval);
                      }
                     else
                      {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                              /* if 0, apply current gray */
                                       if (!val)
                                        {                    /* 5-2-91, shenzhi */
                                         if (grayval <*htptr1)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                         else                /* 5-2-91, shenzhi */
//                                          *outbuff1 &=~bt;    @WIN_IM; swap it
                                            *outbuff1 &= ANDNOTSWAP(bt);
                                        };                   /* 5-2-91, shenzhi */
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                       if (++htptr1 ==htbound)
                                          htptr1 -=htsize;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 1 , apply current gray */
                                       if (val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                                    *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                       if (++htptr1 ==htbound)
                                          htptr1 -=htsize;
                                    } while (--dx);
                              } while (--colval);
                      };
                    };
                  if (ymove)
                    {
                      writebuffptr->outbuff0 +=fbwidth;
                      writebuffptr->htptr0 +=htsize;
                      htbound +=htsize;
                      if (htbound > htmax)
                       {
                           htbound = htmin;
                           writebuffptr->htptr0 -=httotal;
                       };
                      writebuffptr->htbound = htbound;
                      writebuffptr->yout++;
                    }
                  else
                    {
                       writebuffptr->htptr0 -=htsize;
                   /*  writebuffptr->htbound -=htsize;    */
                       htbound -=htsize;     /* 4-26-91, shenzhi */
                       if (htbound < htmin)
                        {
                            htbound = htmax;
                            writebuffptr->htptr0 +=httotal;
                        };
                       writebuffptr->htbound = htbound;
                       writebuffptr->outbuff0 -=fbwidth;
                       writebuffptr->yout--;
                    };
             };
    if ((image_dev_flag == PORTRATE)&&(!xmove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr = writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                               /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            if(*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1-- > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt RSHIFTEQ 1)==0)
                                     {
                                       bt = ONE8000;
                                       outbuff1--;
                                     };
                                  if (htptr1 ==htbound)
                                      htptr1 +=htsize;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                           if (image_logic_op & IMAGEMASK_FALSE_BIT)
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                         /* if 0, apply current gray */
                                        if (!val)
                                                  {                   /* 5-2-91, shenzhi */
                                                   if (grayval <*htptr1)
//                                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                                     *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                  };                  /* 5-2-91, shenzhi */
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                        if (--htptr1 ==htbound)
                                           htptr1 +=htsize;
                                     } while (--dx);
                               } while (--colval);
                           else
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                           /* if 1 , apply current gray */
                                        if (val )
                                                   {                  /* 5-2-91, shenzhi */
                                                   if (grayval <*htptr1)
//                                                    *outbuff1 |=bt;     @WIN_IM; swap it
                                                      *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                   };                 /* 5-2-91, shenzhi */
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                        if (--htptr1 ==htbound)
                                           htptr1 +=htsize;
                                     } while (--dx);
                               }  while (--colval);
                        };
                   };
                  if (ymove)
                            {
                               writebuffptr->htptr0 +=htsize;
                               htbound +=htsize;
                               if (htbound > htmax)
                                {
                                    htbound = htmin;
                                    writebuffptr->htptr0 -=httotal;
                                };
                               writebuffptr->htbound = htbound;
                               writebuffptr->outbuff0 +=fbwidth;
                               writebuffptr->yout++;
                            }
                  else
                            {
                               writebuffptr->htptr0 -=htsize;
                               htbound -=htsize;
                               if (htbound < htmin)
                                {
                                    htbound = htmax;
                                    writebuffptr->htptr0 +=httotal;
                                };
                               writebuffptr->htbound = htbound;
                               writebuffptr->outbuff0 -=fbwidth;
                               writebuffptr->yout--;
                            };
             };
    if ((image_dev_flag == LANDSCAPE)&& (ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                 /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&& colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                       {
                        do
                         {
                            if (*valptr++)
                               val=gray1;
                            else
                               val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1 > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 +=fbwidth;
                                  if ((htptr1+=htsize) > htmax0)
                                        htptr1 -=httotal;
                               } while (--dx);
                         } while (--colval);
                       }
                     else
                       {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 0, apply current gray */
                                       if (!val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                                    *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       outbuff1 +=fbwidth;
                                       if ((htptr1+=htsize) > htmax0)
                                             htptr1 -=httotal;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 1 , apply current gray */
                                       if (val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                                     *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       outbuff1 +=fbwidth;
                                       if ((htptr1+=htsize) > htmax0)
                                             htptr1 -=httotal;
                                    } while (--dx);
                              } while (--colval);

                       };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                         if (++writebuffptr->htptr0 ==htbound)
                                  writebuffptr->htptr0 -=htsize;
                         writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                         if (--writebuffptr->htptr0 ==htbound)
                                  writebuffptr->htptr0 +=htsize;
                         writebuffptr->xout--;
                     }
             };
    if ((image_dev_flag == LANDSCAPE)&& (!ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                    /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            if (*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1 > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 -=fbwidth;
                                  if ((htptr1-=htsize) < htmin0)
                                        htptr1 +=httotal;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                            if (image_logic_op & IMAGEMASK_FALSE_BIT)
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                               /* if 0, apply current gray */
                                         if (!val)
                                                     {                  /* 5-2-91, shenzhi */
                                                    if (grayval < *htptr1)
//                                                     *outbuff1 |=bt;     @WIN_IM; swap it
                                                       *outbuff1 |= ORSWAP(bt);
                                                    else                /* 5-2-91, shenzhi */
//                                                     *outbuff1 &=~bt;    @WIN_IM; swap it
                                                       *outbuff1 &= ANDNOTSWAP(bt);
                                                     };                 /* 5-2-91, shenzhi */
                                         outbuff1 -=fbwidth;
                                         if ((htptr1-=htsize) < htmin0)
                                               htptr1 +=httotal;
                                      } while (--dx);
                                } while (--colval);
                            else
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                                         /* if 1 , apply current gray */
                                         if (val)
                                                     {                  /* 5-2-91, shenzhi */
                                                    if (grayval <*htptr1)
//                                                     *outbuff1 |=bt;     @WIN_IM; swap it
                                                       *outbuff1 |= ORSWAP(bt);
                                                    else                /* 5-2-91, shenzhi */
//                                                     *outbuff1 &=~bt;    @WIN_IM; swap it
                                                       *outbuff1 &= ANDNOTSWAP(bt);
                                                     };                 /* 5-2-91, shenzhi */
                                         outbuff1 -=fbwidth;
                                         if ((htptr1-=htsize) < htmin0)
                                               htptr1 +=httotal;
                                      } while (--dx);
                                } while (--colval);
                        };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                        if (++writebuffptr->htptr0 ==htbound)
                                 writebuffptr->htptr0 -=htsize;
                        writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                        if (--writebuffptr->htptr0 ==htbound)
                                 writebuffptr->htptr0 +=htsize;
                        writebuffptr->xout--;
                     }
             };
             outbit = bt;

}






/******************************************************************************

* TITLE      :  image_alloc

* CALL       :  image_alloc(p_size)

* PARAMETERS :  p_size: number of bytes required

* INTERFACE  :

* CALLS      :  none

* RETURN     : none

******************************************************************************/

/*mslin*/

byte    FAR *image_alloc(p_size)
fix     p_size;
{
//  byte        FAR *p1;        @WIN
    p_size = W_ALIGN(p_size);

    image_heap -= p_size;               /* update free heap pointer */
    if( (image_scale_info->dev_buffer_size -= p_size) < 0)
      return(NIL);
    return((byte FAR *)image_heap);

} /*image_alloc*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\trvse.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/***********************************************************************
 *
 *      File Name:   trvse.c
 *
 *      Purpose: This file contains routines to traverse current path,
 *               and execute the input routine for each subpath.
 *
 *      Developer:      S.C.Chen
 *
 *      Modifications:
 *      Version     Date        Comment
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           long32, for parameter
 *                              4) add compiling option: LINT_ARGS
 *                  8/11/88     add LINT_ARGS for traverse_path(), trvse_nest()
 *                  8/29/88     add global variables of floating constants:
 *                              zero_f, one_f.
 *                              fix trvse_nest() ==> void trvse_nest()
 *                              optimize trvse_nest() by deleting unnecessary
 *                              assignment of floating numbers: flat, n_flat
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  12/4/90     @CPPH: trvse_nest: traverse cp_path(clipping
 *                              trazepozids) if path stored in it.
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>

#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
//      static void near trvse_nest (void (*)(SP_IDX, fix *), fix *, PH_IDX, ufix, long32, fix);
        static void near trvse_nest (void (*)(SP_IDX, fix FAR *), fix FAR *,
               PH_IDX, ufix, long32, fix);
#else
        static void near trvse_nest ();
#endif

/***********************************************************************
 * This module traverses current path, and calls the input function for
 * each subpath traversed.
 *
 * TITLE:       traverse_path
 *
 * CALL:        traverse_path (fun, param)
 *
 * PARAMETERS:  fun   -- a function to be executed when traverses a
 *                       complete subpath
 *              param -- input parameter of fun
 *
 * INTERFACE:   op_pathforall -- &dump_subpath
 *              op_stroke, op_strokepath -- &path_to_outline
 *              op_clip, op_eoclip, op_fill, op_eofill --
 *                      &shape_approximation
 *
 * CALLS:       trvse_nest
 *
 * RETURN:
 **********************************************************************/
void traverse_path (fun, param)
#ifdef LINT_ARGS
//      void    (*fun)(SP_IDX, fix *);          @WIN
// DJC        void    (*fun)();
        void    (*fun)(SP_IDX, fix FAR *);
#else
        void    (*fun)();
#endif
fix     FAR *param;
{
// DJC        trvse_nest (fun, param, GSptr->path, 0, F2L(zero_f), 0);
        trvse_nest (fun,
                     param,
                     (PH_IDX)(GSptr->path),
                     (ufix)0,
                     (long32)(F2L(zero_f)),
                     (fix)0);
}


/***********************************************************************
 * A recurcive procedure to traverse path
 *
 * TITLE:       trvse_nest
 *
 * CALL:        trvse_nest (fun, param, path, ref, l_flat, depth)
 *
 * PARAMETERS:  fun     -- a function to be executed when traverses a
 *                         complete subpath
 *              param   -- input parameter of fun
 *              path    -- path header of a gsave level
 *              ref     -- reference flag
 *              l_flat  -- flatness
 *              depth   -- recursive depath
 *
 * INTERFACE:   traverse_path
 *
 * CALLS:       trvse_nest, flatten_subpath, reverse_subpath, *fun()
 *
 * RETURN:
 **********************************************************************/
static void near trvse_nest (fun, param, path, ref, l_flat, depth)
#ifdef LINT_ARGS
        void    (*fun)(SP_IDX, fix FAR *);
//      void    (*fun)();                       /* @WIN */
#else
        void    (*fun)();
#endif
fix     FAR *param;
PH_IDX  path;
ufix    ref;
long32    l_flat;
fix     depth;
{
        ufix    n_ref;
        long32  n_flat;
        struct  ph_hdr FAR *p;
        struct  nd_hdr FAR *sp;
        SP_IDX  isp;

        p = &path_table[path];
        if (p->previous != NULLP) {
                /* generate next reverse flag */
                n_ref = (ref & P_RVSE) ^ p->rf;

                /* generate next flat flag */
                n_ref = (n_ref & P_FLAT) | p->rf;
                if (ref & P_FLAT) n_flat = l_flat;
                if (p->rf & P_FLAT) n_flat = F2L(p->flat);

                /* traverse recursively */
                trvse_nest (fun, param, p->previous, n_ref, n_flat, depth+1);
        }

#ifdef DBG1
        printf(" Traverse all subpath on this level, p->head=%d\n",
               p->head);
#endif

        /* traverse cp_path, if path defined in it (by op_clippath) @CPPH */
        if (p->cp_path != NULLP) {
            CP_IDX itpzd;
            struct nd_hdr FAR *tpzd;
            real32 x[3], y[3];
            struct nd_hdr FAR *vtx;
            VX_IDX  ivtx, isp;
            fix i;

            /*
             * create current path that transforms from clipping trapezoids
             * each trapezoid generates one subpath :
             *      (TOP_XL, TOPY) +--------+ (TOPXR, TOPY)
             *                    /          \
             *                   /            \
             *    (BTMXL, BTMY) +--------------+ (BTMXR, BTMY)
             */
            for (itpzd = p->cp_path; itpzd != NULLP; itpzd = tpzd->next) {

                tpzd = &node_table[itpzd];

                x[0] = SFX2F(tpzd->CP_TOPXR);
                y[0] = SFX2F(tpzd->CP_TOPY);
                x[1] = SFX2F(tpzd->CP_BTMXR);
                y[1] = SFX2F(tpzd->CP_BTMY);
                x[2] = SFX2F(tpzd->CP_BTMXL);
                y[2] = SFX2F(tpzd->CP_BTMY);

                /* Create 5 nodes */
                for (i=0, isp=NULLP; i<5; i++) {
                        ivtx = get_node();
                        if(ivtx == NULLP) {
                            free_node(isp);
                            ERROR(LIMITCHECK);
                            return;
                        }
                        node_table[ivtx].next = isp;
                        isp = ivtx;
                }

                /* Set up a MOVETO node */
                vtx = &node_table[isp];
                vtx->VX_TYPE = MOVETO;
                vtx->VERTEX_X = SFX2F(tpzd->CP_TOPXL);
                vtx->VERTEX_Y = SFX2F(tpzd->CP_TOPY);
                vtx->SP_FLAG = FALSE;
                vtx->SP_NEXT = NULLP;

                /* 3 LINETO nodes */
                for (i=0, ivtx=vtx->next; i<3; i++) {
                        vtx = &node_table[ivtx];
                        vtx->VX_TYPE = LINETO;
                        vtx->VERTEX_X = x[i];
                        vtx->VERTEX_Y = y[i];
                        ivtx = vtx->next;
                }
                node_table[ivtx].VX_TYPE = CLOSEPATH;
                node_table[isp].SP_TAIL = ivtx;

                (*fun) (isp, param);

                free_node(isp);
            } /* for */
        } /* if */

        /* traverse all subpaths on this level */
        for (isp = p->head; isp != NULLP; isp = sp->SP_NEXT) {/* @NODE: next */
                /* struct vx_lst *vlist;       @NODE */
                SP_IDX iflt_sp, irvs_sp;       /* @TRVSE */

                sp = &node_table[isp];

                /* ignore incomplete tail subpath */
                if ((depth > 0) && (isp == p->tail) &&
                    ((sp->SP_FLAG & SP_DUP))) break;

                /* approximate a flattened subpath */
                if (ref & P_FLAT) {
                     /* @NODE
                      * vlist = flatten_subpath (sp->SP_HEAD, l_flat);
                      * (* allocate a subpath header    @SP_FLG *)
                      * iflt_sp = get_node();
                      * if(iflt_sp == NULLP) {
                      *         ERROR(LIMITCHECK);
                      *         return;
                      * }
                      * node_table[iflt_sp].next = NULLP;
                      * node_table[iflt_sp].SP_HEAD = vlist->head;
                      * node_table[iflt_sp].SP_TAIL = vlist->tail;
                      * node_table[iflt_sp].SP_FLAG = sp->SP_FLAG & (~SP_CURVE);
                      * isp = iflt_sp;
                      */
                        isp = iflt_sp = flatten_subpath (isp, l_flat);
                }

                /* approximate a reversed subpath */
                if (ref & P_RVSE) {
                     /* @NODE
                      * vlist = reverse_subpath (node_table[isp].SP_HEAD);
                      * (* allocate a subpath header    @SP_FLG *)
                      * irvs_sp = get_node();
                      * if(irvs_sp == NULLP) {
                      *         ERROR(LIMITCHECK);
                      *         return;
                      * }
                      * node_table[irvs_sp].next = NULLP;
                      * node_table[irvs_sp].SP_HEAD = vlist->head;
                      * node_table[irvs_sp].SP_TAIL = vlist->tail;
                      * isp = irvs_sp;
                      */
                        isp = irvs_sp = reverse_subpath (isp);
                }

                (*fun) (isp, param);

                if (ref & P_FLAT) {             /* @PRE_CLIP */
                        /* free_node (node_table[iflt_sp].SP_HEAD); @NODE */
                        free_node (iflt_sp);
                }

                if (ref & P_RVSE) {             /* @PRE_CLIP */
                        /* free_node (node_table[irvs_sp].SP_HEAD); @NODE */
                        free_node (irvs_sp);
                }

        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\arith.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */



// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <math.h>
#include        "global.ext"
#include        "arith.h"

#ifdef  _AM29K
#define FMIN31  -2147483648.0
#endif

static ufix32  random_seed = 1 ;
static ufix32  random_number ;

/* static function declaration */
#ifdef LINT_ARGS
/*
static  void    near  fraction_proc(fix16) ;
*/
static  void    near  ln_log(fix) ;
#else
/*
static  void    near  fraction_proc() ;
*/
static  void    near  ln_log() ;
#endif /* LINT_ARGS */

/***********************************************************************
**
** This module is used to return the sum of num1 and num2. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_add              Date:   00/00/87
** CALL:        op_add()            UpDate: 08/06/87
** PARAMETERS:  num1     ;  pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result   ;  pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_add()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       l_result.ll = kk1.ll + kk2.ll ;
       if ((!(kk1.ll & SIGNPATTERN) && !(kk2.ll & SIGNPATTERN) &&
           (l_result.ll & SIGNPATTERN)) || ((kk1.ll & SIGNPATTERN) &&
           (kk2.ll & SIGNPATTERN) && !(l_result.ll & SIGNPATTERN))) {
          /* overflow (+,+ => - or -,- => +) */
          is_float = REALTYPE ;
          kk1.ff = (real32)kk1.ll ;
          kk2.ff = (real32)kk2.ll ;
       } else
          goto exit_add ;
    } else {
       is_float = REALTYPE ;
       if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
          l_result.ll = INFINITY ;
          goto exit_add ;
       } else if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       else if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;
    }

    _clear87() ;
    l_result.ff = kk1.ff + kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_add:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_add() */

/***********************************************************************
**
** This operator is used to divides num1 by num2. The result is
** always a real.
**
** TITLE:       op_div              Date:   00/00/87
** CALL:        op_div()            Update: 08/13/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:
** RETURN:      quotient ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_div()
{
    struct  object_def  FAR *num1, FAR *num2 ;
    union   four_byte   l_quotient, kk1, kk2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;

    /* divide by zero  */
    if (!kk2.ll) {  /* == 0 */
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
    if (IS_INFINITY(num1))
       l_quotient.ll = INFINITY ;
    else if (IS_INFINITY(num2))
       l_quotient.ff = (real32)0.0 ;
    else {
       if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;

       _clear87() ;
       l_quotient.ff = kk1.ff / kk2.ff ;
       if (_status87() & PDL_CONDITION) {
          l_quotient.ll = INFINITY ;
          _clear87() ;
       }
    }
    POP(1) ;
    opnstack[opnstktop-1].value=l_quotient.ll;
    TYPE_SET(&opnstack[opnstktop-1],REALTYPE);

    return(0) ;
}   /* op_div() */

/***********************************************************************
**
** This operator is used to divide num1 by num2, and return the
** integer part of the quotient.
**
** TITLE:       op_idiv             Date:   00/00/87
** CALL:        op_idiv()           Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       error, float_div
** RETURN:      quotient ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_idiv()
{
    struct  object_def  FAR *num1, FAR *num2 ;
    union   four_byte   l_quotient, kk1, kk2 ;
    ufix32  l_temp ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;

    /* divide by zero  */
    if (!kk2.ll) { /* == 0 */
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
    if (IS_INFINITY(num1)) {
       if (kk2.ll) /* < 0 */
          l_quotient.ll = MIN31 ;
       else
          l_quotient.ll = MAX31 ;
    } else if (IS_INFINITY(num2))
       l_quotient.ll = 0 ;
    else {
       if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
          l_quotient.ll = kk1.ll / kk2.ll ;
          if (((fix32)l_quotient.ll == SIGNPATTERN) && ((fix32)kk2.ll == -1L)) {
             ERROR(UNDEFINEDRESULT) ;
             return(0) ;
          }
       } else {
          if (IS_INTEGER(num1))
             kk1.ff = (real32)kk1.ll ;
          else if (IS_INTEGER(num2))
             kk2.ff = (real32)kk2.ll ;

          l_quotient.ff = kk1.ff / kk2.ff ;
          l_temp = l_quotient.ll & VALUEPATTERN ;
          if (l_temp > MAX31PATTERN){
             if(l_quotient.ll & SIGNPATTERN)
                l_quotient.ll = MIN31 ;
             else
                l_quotient.ll = MAX31 ;
          }
          else
             l_quotient.ll = (fix32)l_quotient.ff ;
       }
    }

    POP(1) ;
    opnstack[opnstktop-1].value=l_quotient.ll;
    TYPE_SET(&opnstack[opnstktop-1],INTEGERTYPE);

    return(0) ;
}   /* op_idiv() */

/***********************************************************************
**
** This operator is used to return the remainder that results from
** dividing num1 by num2. Both operands must be integers ; the result
** is an integer.
**
** TITLE:       op_mod              Date:   00/00/87
** CALL:        op_mod()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       any_error, error
** RETURN:      remainder ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_mod()
{
    struct object_def FAR *num1 ;
    fix32   l_kk2 ;

    num1 = GET_OPERAND(1) ;
    l_kk2 = (fix32)VALUE(GET_OPERAND(0)) ;

    /* check if divided by zero */
    if (!l_kk2) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }

    VALUE(num1) = (ufix32) ((fix32)VALUE(num1) % l_kk2) ;
    POP(1) ;

    return(0) ;
}   /* op_mod() */

/***********************************************************************
**
** This operator is used to return the product of num1 and num2. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_mul              Date:   00/00/87
** CALL:        op_mul()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_mul()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;
    real64  d_result ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       if (IS_ARITH_MUL(kk1.ll) && IS_ARITH_MUL(kk2.ll))
          l_result.ll = kk1.ll * kk2.ll ;
       else {
          d_result = (real64)kk1.ll * (real64)kk2.ll ;
#ifdef  _AM29K
          if ((d_result > (real64)MAX31) || (d_result < (real64)FMIN31)) {
#else
          if ((d_result > (real64)MAX31) || (d_result < (real64)MIN31)) {
#endif
             l_result.ff = (real32)d_result ;
             is_float = REALTYPE ;
          } else
             l_result.ll = (fix32)d_result ;
       }
       goto exit_mul ;
    }

    /* either one is a real, or integer 'mul' overflow */
    is_float = REALTYPE ;
    if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
       l_result.ll = INFINITY ;
       goto exit_mul ;
    } else if (IS_INTEGER(num1))
       kk1.ff = (real32)kk1.ll ;
    else if (IS_INTEGER(num2))
       kk2.ff = (real32)kk2.ll ;

    _clear87() ;
    l_result.ff = kk1.ff * kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_mul:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_mul() */

/***********************************************************************
**
** This operator is used to subtract num2 from num1. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_sub              Date:   00/00/87
** CALL:        op_sub()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result       ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_sub()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       l_result.ll = kk1.ll - kk2.ll ;
       if ((!(kk1.ll & SIGNPATTERN) && (kk2.ll & SIGNPATTERN) &&
           (l_result.ll & SIGNPATTERN)) || ((kk1.ll & SIGNPATTERN) &&
           !(kk2.ll & SIGNPATTERN) && !(l_result.ll & SIGNPATTERN))) {
          /* overflow (+,- => - or -,+ => +) */
          is_float = REALTYPE ;
          kk1.ff = (real32)kk1.ll ;
          kk2.ff = (real32)kk2.ll ;
       } else
          goto exit_sub ;
    } else {
       is_float = REALTYPE ;
       if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
          l_result.ll = INFINITY ;
          goto exit_sub ;
       } else if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       else if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;
    }

    _clear87() ;
    l_result.ff = kk1.ff - kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_sub:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_sub() */

/***********************************************************************
**
** This operator is used to return the absolute value of num. The type
** of the result is the same as the type of num.
**
** TITLE:       op_abs              Date:   00/00/87
** CALL:        op_abs()            Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       error
** RETURN:      absnum   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_abs()
{
    ufix16  is_float ;
    struct  object_def  FAR *num ;
    union   four_byte   l_num ;

    num = GET_OPERAND(0) ;
    l_num.ll = (fix32)VALUE(num) ;

    /* initialize */
    is_float = REALTYPE ;

    /*  num is an INFINITY.0 or greater than or equal to zero */
    if (IS_INFINITY(num) || l_num.ll >= 0L)
       return(0) ;   /* nothing to do */

    if (IS_INTEGER(num)) {                  /* Integer */
       if (l_num.ll == MIN31) {             /* Max. negative integer */
          l_num.ff = (real32)l_num.ll ;
          l_num.ll &= MAX31 ;                /* clear sign bit */
       } else if( l_num.ll < 0L ) {
          l_num.ll = - l_num.ll ;            /* 2's complement */
          is_float = INTEGERTYPE ;
       }
    } else                                  /* Real */
        l_num.ll &= MAX31 ;                  /* clear sign bit */

    opnstack[opnstktop-1].value=l_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_abs() */

/***********************************************************************
**
** This operator is used to get the negative of num. The type of the
** result is the same as the type of the operand.
**
** TITLE:       op_neg              Date:   00/00/87
** CALL:        op_neg()            Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:
** RETURN:      negnum   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_neg()
{
    ufix16  is_float ;
    struct  object_def  FAR *num ;
    union   four_byte   l_num ;

    num = GET_OPERAND(0) ;
    l_num.ll = (fix32)VALUE(num) ;

    /* initialize */
    is_float = REALTYPE ;

    /*  num is an INFINITY.0  */
    if (IS_INFINITY(num))
       return(0) ;    /* nothing to do */

    if (IS_INTEGER(num)) {                  /* Integer */
       if (l_num.ll == MIN31) {             /* Max. negative integer */
          l_num.ff = (real32)l_num.ll ;
          l_num.ll &= MAX31 ;               /* clear sign bit */
       } else {
          l_num.ll = - l_num.ll ;           /* 2's complement */
          is_float = INTEGERTYPE ;
       }
    } else                                  /* Real */
       l_num.ll ^= SIGNPATTERN ;            /* complement sign bit */

    opnstack[opnstktop-1].value=l_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_neg() */

/***********************************************************************
**
** This operator is used to get the value greater than or equal to num.
** The type of the result is the same as the type of the operand.
**
** TITLE:       op_ceiling          Date:   00/00/87
** CALL:        op_ceiling()        Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      ceilnum ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_ceiling()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)ceil(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_ceiling() */

/***********************************************************************
**
** This operator is used to get the greatest integer value less
** than or equal to num. The type of the result is the same as the type
** of the operand.
**
** TITLE:       op_floor            Date:   00/00/87
** CALL:        op_floor()          Update: 08/06/87
** PARAMETERS:
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      floornum    ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_floor()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)floor(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_floor() */

/***********************************************************************
**
** This operator is used to get the integer value nearest to num.
** if num is equally close to its two nearest integers, Round_op
** returns the greater of the two. The type of the result is the same
** as the type of the operand.
**
** TITLE:       op_round            Date:   00/00/87
** CALL:        op_round()          Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      roundnum ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_round()  /* not complete */
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)floor(5.0e-1 + l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_round() */

/***********************************************************************
**
** This operator is used to truncate num toward zero by removing its
** fractional part. The type of the result is the same as the type
** of the operand.
**
** TITLE:       op_truncate         Date:   00/00/87
** CALL:        op_truncate()       Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      truncatenum  ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_truncate()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    if (l_ff.ff >= (real32)0.0)
       l_ff.ff = (real32)floor(l_ff.ff) ;
    else
       l_ff.ff = (real32)ceil(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_truncate() */

/* **********************************************************************
 *
 *  This operator is used to return the square root of num, which must
 *  be a non-negative number.
 *
 *  TITLE :     op_sqrt                 Date : 08/21/87
 *  CALL:       op_sqrt()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      sqrt(), ERROR()
 *  RETURN:     lf_num   ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_sqrt()
{
    struct  object_def  FAR *num ;
    union   four_byte   lf_num, l_ff ;

    num = GET_OPERAND(0) ;
    l_ff.ll = (fix32)VALUE(num) ;
/*
 *   operand is a negative number
 */
    if (l_ff.ll & SIGNPATTERN) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }
/*
 *   operand is infinity.0
 */
    if (IS_INFINITY(num))
       lf_num.ll = INFINITY ;
    else {
       if (IS_INTEGER(num))
          l_ff.ff = (real32)l_ff.ll ;
       lf_num.ff = (real32)sqrt(l_ff.ff) ;     /* double */
    }

    opnstack[opnstktop-1].value=lf_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],REALTYPE);

    return(0) ;
}   /* op_sqrt() */

/* **********************************************************************
 *
 *  This operator is used to return the angle(in degrees between 0 and 360)
 *  whose tangent is num/den. Either num or den may be zero, but not both.
 *  The signs of num and den determine the quadrant in which the result
 *  is lie: a positive num yields a result in the positive y plane ; a
 *  positive den yields a result in the positive x plane.
 *
 *  TITLE :     op_atan                 Date : 08/21/87
 *  CALL:       op_atan()
 *  PARAMETERS: num, den ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      atan2(), ERROR()
 *  RETURN:     lf_angle ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_atan()
{
    struct  object_def  FAR *num, FAR *den ;
    union   four_byte   lf_angle, lf_1, lf_2 ;
#ifdef _AM29K
    bool AMDCase = FALSE ;
#endif  /* _AM29K */
/*
 *  get 2 operands from stack
 */
    den = GET_OPERAND(0) ;
    num = GET_OPERAND(1) ;
    lf_2.ll = (fix32)VALUE(num) ;  /* y */
    lf_1.ll = (fix32)VALUE(den) ;  /* x */
/*
 *   either num and den may be zero, but not both
 */
    if (!lf_2.ll && !lf_1.ll) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
/*
 *   num is infinity.0
 */
    if (IS_INFINITY(num))
       lf_angle.ff = (real32)90.0 ;
/*
 *   den is infinity.0
 */
    else if (IS_INFINITY(den))
       lf_angle.ff = (real32)0.0 ;
/*
 *  call library atan2(y, x)
 */
    else {
#ifdef _AM29K
/* Bad handling of special cases in AMD29K atan2 function -- do it by hand */
       if (VALUE (num) == 0) {
         if (VALUE(den) & SIGNPATTERN) {
           lf_angle.ff = (real32)180. ;
         }
         else {
           lf_angle.ff = (real32)0. ;
         }
         AMDCase = TRUE ;
       }
       else if (VALUE (den) == 0) {
         if (VALUE(num) & SIGNPATTERN) {
           lf_angle.ff = (real32)270. ;
         }
         else {
           lf_angle.ff = (real32)90. ;
         }
         AMDCase = TRUE ;
       }

       if (AMDCase) {
          POP(2) ;
          PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_angle.ll) ;
          return(0) ;
       }
#endif  /* _AM29K */

       if (IS_INTEGER(num))
          lf_2.ff = (real32)lf_2.ll ;
       if (IS_INTEGER(den))
          lf_1.ff = (real32)lf_1.ll ;
       lf_angle.ff = (real32)atan2(lf_2.ff, lf_1.ff) ;
       lf_angle.ff *= (real32)180.0 / (real32)PI ;
/*
 *   the range of result is from 0 to 360
 */
       if (lf_angle.ll & SIGNPATTERN)
          lf_angle.ff = lf_angle.ff + (real32)360.0 ;
    }

    POP(2) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_angle.ll) ;

    return(0) ;
}   /* op_atan() */

/* *********************************************************************
 *
 *  This operator is used to return the cosine of angle, which is
 *  interpreted as an angle in degrees.
 *
 * TITLE:       op_cos              Date:   00/00/87
 * CALL:        op_cos()            UpDate: 08/06/87
 * PARAMETERS:  angle    ; pointer (4-byte) to object on operand stack
 * INTERFACE:
 * CALL:        ERROR(), cos()
 * RETURN:      lf_real  ; pointer (4-byte) to object on operand stack
 **********************************************************************/
fix
op_cos()
{
    struct  object_def  FAR *angle ;
    union   four_byte   lf_real, lf_1 ;
/*
 * get angle operand
 */
    angle = GET_OPERAND(0) ;
    lf_1.ll = (fix32)VALUE(angle) ;
/*
 *   ANGLE is infinity.0
 */
    if (IS_INFINITY(angle))
       lf_real.ll = INFINITY ;
    else {
       /* degree -> radius */
       if (IS_INTEGER(angle))
          lf_1.ff = (real32)(lf_1.ll % 360) ;
       else
          lf_1.ff -= (real32)floor(lf_1.ff / 360.0) * (real32)360.0 ;
       lf_real.ff = (real32)cos(lf_1.ff / 180.0 * PI) ;  /* double */
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_cos() */

/* *********************************************************************
 *
 *  This operator is used to return the sine of angle, which is
 *  interpreted as an angle in degrees.
 *
 * TITLE:       op_sin              Date:   08/21/87
 * CALL:        op_sin()
 * PARAMETERS:  angle    ; pointer (4-byte) to object on operand stack
 * INTERFACE:
 * CALL:        ERROR(), sin()
 * RETURN:      result   ; pointer (4-byte) to object on operand stack
 **********************************************************************/
fix
op_sin()
{
    struct  object_def  FAR *angle ;
    union   four_byte   lf_real, lf_1 ;
    union   four_byte   temp ;
/*
 * get angle operand
 */
    angle = GET_OPERAND(0) ;
    temp.ll = lf_1.ll = (fix32)VALUE(angle) ;

/*
 *   ANGLE is infinity.0
 */
    if (IS_INFINITY(angle))
       lf_real.ll = INFINITY ;
    else {
       /* degree -> radius */
       if (IS_INTEGER(angle)) {
          lf_1.ff = (real32)(lf_1.ll % 360) ;
          if (temp.ll && lf_1.ff == (real32)0.0)  /* N * 360, N > 1 */
             lf_1.ff = (real32)360.0 ;
       } else {                           /* TYPE == REAL */
          lf_1.ff -= (real32)floor(lf_1.ff / 360.0) * (real32)360.0 ;
          if (temp.ff != (real32)0.0 && lf_1.ff == (real32)0.0) /* N * 360.0, N > 1 */
             lf_1.ff = (real32)360.0 ;
       }
       lf_real.ff = (real32)sin(lf_1.ff / 180.0 * PI) ; /* double */
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_sin() */

/* *********************************************************************
 *
 *  This operator is used to raise base to the exponent power.
 *  The operands may be either integers or reals (if the exponent has
 *  a fractional part, the result is meaningful only if the base is
 *  non-negative).
 *
 *  TITLE :     op_exp                  Date : 08/21/87
 *  CALL:       op_exp()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      pow(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_exp()
{
    struct  object_def  FAR *base, FAR *exp ;
    union   four_byte   lf_real, l_num1, l_num2 ;

    base = GET_OPERAND(1) ;
    exp  = GET_OPERAND(0) ;
    l_num1.ll = (fix32)VALUE(base) ;
    l_num2.ll = (fix32)VALUE(exp) ;
/*
 *   BASE is zero and EXPONENT is zero
 */
    if (!l_num1.ll && !l_num2.ll) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
/*
 *   BASE is zero
 */
    if (!l_num1.ll) {
       lf_real.ff = (real32)0.0 ;
       goto l_exp1 ;
    }
/*
 *   EXPONENT is zero
 */
    if (!l_num2.ll) {
       lf_real.ff = (real32)1.0 ;
       goto l_exp1 ;
    }
/*
 *  one of operand is infinity.0
 */
    if (IS_INFINITY(base) || IS_INFINITY(exp)) {
       lf_real.ll = INFINITY ;
       goto l_exp1 ;
    }
/*
 *  BASE is zero, EXPONENT is negative
 */
 /*
 /*
    if (!l_num1.ll && (l_num2.ll & SIGNPATTERN)) {
       lf_real.ll = INFINITY ;
       ERROR(RANGECHECK) ;
       return(0) ;
    }
 */
/*
 *  BASE is negative, and EXPONENT has fraction part
 */
 /*
    if (((IS_INTEGER(base) && (l_num1.ll < 0L)) ||
        (IS_REAL(base) && (l_num1.ff < (real32)0))) && IS_REAL(exp)) {
  */
    if ((l_num1.ll & SIGNPATTERN) && IS_REAL(exp) &&
                             (l_num2.ff != (real32)floor(l_num2.ff))) {
          /* error returned on C library call */
          lf_real.ll = INFINITY ;
          ERROR(UNDEFINEDRESULT) ;
          return(0) ;
    }

    if (IS_INTEGER(base))
       l_num1.ff = (real32)l_num1.ll ;
    if (IS_INTEGER(exp))
       l_num2.ff = (real32)l_num2.ll ;

    _clear87() ;
    lf_real.ff = (real32)pow(l_num1.ff, l_num2.ff) ;
/*
 *   condition occur at operation
 */
    if (_status87() & PDL_CONDITION) {
       lf_real.ll = INFINITY ;
       _clear87() ;
    }

l_exp1:
    POP(2) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_exp() */

/* *********************************************************************
 *
 * This operator is used to return the natural logarithm(base e) of num.
 *  The result is a real.
 *
 *  TITLE :     op_ln                   Date : 08/21/87
 *  CALL:       op_ln()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      ln_log(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_ln()
{
    ln_log(LN) ;

    return(0) ;
}   /* op_ln() */

/* *********************************************************************
 *
 *  This operator is used to return the common logarithm(base 10) of num.
 *  The result is a real.
 *
 *  TITLE :     op_log                  Date : 08/24/87
 *  CALL:       op_log()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      ln_log(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_log()
{
    ln_log(LOG) ;

    return(0) ;
}   /* op_log() */

/***********************************************************************
**
** This operator is used to return a random integer in the range 0 to
** 2**31-1, produced by a pseudo-random number generator. The random
** number generator's state can be  reset by srand and interrogated
** by rrand.
** random_number = u1(high word)  u2(low word)
** g(D) = 1 + D**3 + D**7 + D**11 + D**15 + D**19 + D*23 + D**27 + D**31
**            bit29  bit25  bit21   bit17   bit13   bit9   bit5    bit1
**
** TITLE:       op_rand()           Date:   10/13/87
** CALL:        op_rand()
** PARAMETERS:  none.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      random number on the operand stack.
** update: 7-12-88 change bitfield
***********************************************************************/
fix
op_rand()
{
    ufix32  u1, temp ;
    fix     i, rand_shift ;

    if (random_seed == 1) {
        random_number = 2011148374L ;
        rand_shift = 7 ;
    } else {
        if (random_seed & SIGNPATTERN)
            rand_shift = 13 ;
        else
            rand_shift = 7 ;
        random_number = random_seed & 0x7FFFFFFF ;

        for (i = 0 ; i < rand_shift ; i++) {
            u1 = random_number ;

            /* operate on LSB of temp */
            temp = u1 ^ (u1 >> 4) ^ (u1 >> 8) ^
                   (u1 >> 12) ^ (u1 >> 16) ^ (u1 >> 20) ^
                   (u1 >> 24) ^ (u1 >> 28) ;
            u1 = u1 >> 1 ;
            u1 |= (temp & 0x1) << 30 ;    /* bit feedback into bit31 */
            u1 &= 0x7FFFFFFF ;            /* clear MSB of u1 */

            random_number = u1 ;
            if (random_number == 0)
               random_number = 0x0F0F0F0F ;
        } /* for */
    } /* else */
    /*
     * push random_number to operand stack.
     */
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, random_number) ;

    if (rand_shift == 13)
       random_seed = random_number ;
    else
       random_seed = random_number | SIGNPATTERN ;

    return(0) ;
}   /* op_rand() */

/***********************************************************************
**
** This operator is used to initialize the random number generators
** with the seed integer number on operand stack.
**
** TITLE:       op_srand()           Date:   10/13/87
** CALL:        op_srand()
** PARAMETERS:  seed integer number.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      none.
***********************************************************************/
fix
op_srand()
{
/*
 * get seed number and store to static global variable : random_seed
 */
    random_seed = (fix32)VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_srand() */

/***********************************************************************
**
** This operator is used to return an integer representing the current
** state of the random number generator used by rand operator.
**
** TITLE:       op_rrand()           Date:   10/13/87
** CALL:        op_rrand()
** PARAMETERS:  none.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      random generator's seed number.
***********************************************************************/
fix
op_rrand()
{
/*
 * push random number seed to operand stack
 */
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, random_seed) ;

    return(0) ;
}   /* op_rrand() */


/***********************************************************************
**
**  This routine called by op_ceiling(), op_floor(),
**  op_truncate().
**  It get one operand from operand stack, then calculate the result
**  according to the parameter : mode selection and push the result
**  to operand stack.
**
** TITLE:       fraction_proc
** CALL:        fraction_proc(mode)
** PARAMETERS:  mode    ; 1  for ceiling
**                      ; 2  for floor
**                      ; 3  for round
**                      ; 4  for truncate
** CALLS:       any_error, error, gauss_num
** RETURN:      none
***********************************************************************/
/*
static void near
fraction_proc(mode)
 fix16   mode ;
{
    struct  object_def  FAR *num ;
    union   four_byte   l_ff ;

    num = GET_OPERAND(0) ;
    if (IS_INTEGER(num) || IS_INFINITY(num)) {
       return ; |* nothing to do *|
    }

    |* initialize *|
    l_ff.ll = (fix32)VALUE(num) ;

    |* num is real and not an INFINITY *|
    _clear87() ;
    switch(mode) {
    case CEIL:
         l_ff.ff = (real32)ceil(l_ff.ff) ;
         break ;

    case FLOOR:
         l_ff.ff = (real32)floor(l_ff.ff) ;
         break ;

    case ROND:
         l_ff.ff = (real32)floor(5.0e-1 + l_ff.ff) ;
         break ;

    case TRUNCATE:
         if (l_ff.ff >= (real32)0)
            l_ff.ff = (real32)floor(l_ff.ff) ;
         else
            l_ff.ff = (real32)ceil(l_ff.ff) ;
    } |* switch *|

    if (_status87() & PDL_CONDITION) {
       l_ff.ll = INFINITY ;
       _clear87() ;
    }

    VALUE(num) = l_ff.ll ;

    return ;
} *//* fraction_proc() */

/* *********************************************************************
 *
 *  This routine is called by op_ln(), op_log() to do the natural and
 *  common logarithm. If mode = 1, then do natural logarithm
 *                       mode = 2, then do common logarithm.
 *  It get the operand from operand stack, then push the result value
 *  to operand stack after calcultion completed.
 *
 *  TITLE :     ln_log                  Date : 08/24/87
 *  CALL:       ln_log()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      log(), log10(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
static void near
ln_log(mode)
 fix     mode ;
{
    struct  object_def  FAR *num ;
    union   four_byte   lf_real, lf_num1 ;

    num = GET_OPERAND(0) ;
    lf_num1.ll = (fix32)VALUE(num) ;
/*
 *   operand is zero or negative
 */
    if ((!lf_num1.ll) || (lf_num1.ll & SIGNPATTERN)) {
       ERROR(RANGECHECK) ;
       return ;
    }
/*
 *   operand is Infinity
 */
    if (IS_INFINITY(num))
       lf_real.ll = INFINITY ;
/*
 *   base e , normal value process
 */
    else {
       _clear87() ;
       if (IS_INTEGER(num))
          lf_num1.ff = (real32)lf_num1.ll ;
       if (mode == LN)
          lf_real.ff = (real32)log(lf_num1.ff) ;
       else
          lf_real.ff = (real32)log10(lf_num1.ff) ;
       if (_status87() & PDL_CONDITION) {
          lf_real.ll = INFINITY ;
          _clear87() ;
       }
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return ;
}   /* ln_log() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\arith.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* arith.h */

/* set 87 control word to a default value */
#ifdef _AM29K
#define     CW_PDL              0
#define     PDL_INFINITY        4+8
/* Define or appropriate bits for 29027 -- zero divide (bit 5),
 * overflow (bit 2), reserved (bit 1), and invalid (bit 0).
 */
#define PDL_CONDITION   32+4+2+1        /* phchen 03/26/91 */
#define     _clear87()          _clear_fp()
#define     _status87()         _status_fp()
extern      _clear_fp(), _status_fp();
#else
#define     CW_PDL              IC_AFFINE+RC_NEAR+PC_64+MCW_EM
#define     PDL_INFINITY        SW_OVERFLOW+SW_UNDERFLOW
#define     PDL_CONDITION       SW_ZERODIVIDE+SW_OVERFLOW+SW_INVALID
#endif  /* _AM29K */

#define     IS_INFINITY(obj)\
            ((TYPE(obj) == REALTYPE) && (VALUE(obj) == INFINITY))
#define     IS_NUM_OBJ(obj)\
            ((TYPE(obj) == REALTYPE) || (TYPE(obj) == INTEGERTYPE))
#define     IS_INTEGER(obj)\
            (TYPE(obj) == INTEGERTYPE)
#define     IS_REAL(obj)\
            (TYPE(obj) == REALTYPE)
#define     IS_ARITH_MUL(val)\
            (!(val & 0xFFFF8000) || ((val & 0xFFFF8000) == 0xFFFF8000))

#define     CEIL                1
#define     FLOOR               2
#define     ROND                3
#define     TRUNCATE            4

#define     LN                  1
#define     LOG                 2

#define     MAX31PATTERN        0x4F000000
#define     VALUEPATTERN        0x7FFFFFFF
#define     SIGNPATTERN         0x80000000


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\2eq.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              2EQ.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * 7/13/90 ; ccteng ; add fontnotfound in op_findfont
 * 8/8/90 ; scchen ; changed op_findfont(): added substitutefont feature
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <string.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geierr.h"
#include    "language.h"
#include    "user.h"
#include    "file.h"

#ifdef LINT_ARGS
static bool near typeprint(struct object_def) ;
static void near tprint(byte FAR *, ufix) ;
static void near one_typeprint(void) ;
#else
static bool near typeprint() ;
static void near tprint() ;
static void near one_typeprint() ;
#endif /* LINT_ARGS */

static  ufix16 near cp, tp_depth ;

/************************************
 *  two_equal
 ************************************/
fix
two_equal()
{
    struct object_def   l_obj ;

    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    tp_depth = 0 ;
    cp = 0 ;

    if(! typeprint(l_obj)) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        POP(1) ;
    }

    return(0) ;
}   /* two_equal */

/************************************
 *  tprint
 ************************************/
static void near
tprint(p_str, p_len)
byte    FAR *p_str ;
ufix    p_len ;
{
    ufix16  tcp ;

    tcp = cp ;
    cp += (ufix16)p_len ;
    if(cp >= 80) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        GEIio_write(GEIio_stdout, p_str, 80 - tcp) ;
        p_str += (80 - tcp) ;
        cp -= 80 ;
        while(cp/80) {
            GEIio_write(GEIio_stdout, p_str, 80) ;
            p_str += 80 ;
            cp -= 80 ;
        }
        GEIio_write(GEIio_stdout, p_str, cp) ;
        GEIio_write(GEIio_stdout, "\n", 1) ;
    } else
        GEIio_write(GEIio_stdout, p_str, p_len) ;

    return ;
}   /* tprint */

/************************************
 *  typeprint
 ************************************/
static bool near
typeprint(p_obj)
struct object_def p_obj ;
{
    fix     l_i ;
    ufix16  l_type ;
    byte    FAR *l_str, l_buffer[30] ;
    real64  l_double ;
    struct  object_def  l_anyobj ;
    union   four_byte   l_num ;

    if(++tp_depth > 100) {
        ERROR(LIMITCHECK) ;
        return(1) ;
    }

    l_type = TYPE(&p_obj) ;
    switch(l_type) {
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            if( ACCESS(&p_obj) <= READONLY ) {
                if( ATTRIBUTE(&p_obj) == EXECUTABLE ) {
                    tprint("{", 1) ;
                    for(l_i=0 ; (ufix)l_i < LENGTH(&p_obj) ; l_i++) { //@WIN
                        get_array(&p_obj, l_i, &l_anyobj) ;
                        if(typeprint(l_anyobj))
                            return(1) ;
                        else
                            tp_depth-- ;
                    }   /* for(l_i) */
                    tprint("}", 1) ;
                } else {
                    tprint("[", 1) ;
                    for(l_i=0 ; (ufix)l_i < LENGTH(&p_obj) ; l_i++) { //@WIN
                        get_array(&p_obj, l_i, &l_anyobj) ;
                        if(typeprint(l_anyobj))
                            return(1) ;
                        else
                            tp_depth-- ;
                    }   /* for(l_i) */
                    tprint("]", 1) ;
                }
                return(0) ;
            }   /* access */
            else {
                if(l_type == ARRAYTYPE)
                    l_str = "-array-" ;
                else
                    l_str = "-packedarray-" ;
            }
            break ;

        case BOOLEANTYPE:
            if(VALUE(&p_obj) == TRUE)
                l_str = "true" ;
            else
                l_str = "false" ;
            break ;

        case DICTIONARYTYPE:
            l_str = "-dictionary-" ;
            break ;

        case FILETYPE:
            l_str = "-filestream-" ;
            break ;

        case FONTIDTYPE:
            l_str = "-fontid-" ;
            break ;

        case INTEGERTYPE:
            l_str = (byte FAR *)ltoa( (fix32)VALUE(&p_obj),
                                      (char FAR *)l_buffer, 10) ;  /*@WIN*/
            break ;

        case MARKTYPE:
            l_str = "-mark-" ;
            break ;

        case NAMETYPE:
            l_i = (fix)VALUE(&p_obj) ;
            l_str = name_table[l_i]->text ;
            if(ATTRIBUTE(&p_obj) != EXECUTABLE)
                tprint("/", 1) ;
            tprint(l_str, name_table[l_i]->name_len) ;
            tprint(" ", 1) ;
            return(0) ;

        case NULLTYPE:
            l_str = "-null-" ;
            break ;

        case OPERATORTYPE:
            l_i = LENGTH(&p_obj) ;
/* qqq, begin */
            /*
            switch( ROM_RAM(&p_obj) ) {
                case RAM:
                    l_str = systemdict_table[l_i].key ;
                    break ;

                case ROM:
                    l_str = oper_table[l_i].name ;
                    break ;

                default:
                    l_str = "Error: OPERATORTYPE" ;
            }   |* switch *|
            */
            l_str = systemdict_table[l_i].key ;
/* qqq, end */

            tprint("--", 2) ;
            tprint(l_str, lstrlen(l_str)) ;     /* @WIN */
            tprint("--", 2) ;
            return(0) ;

        case REALTYPE:
            l_num.ll = (fix32)VALUE(&p_obj) ;
            if(l_num.ll == INFINITY)
                l_str = "Infinity.0" ;
            else {
                l_double = l_num.ff ;
                l_str = (byte FAR *)gcvt(l_double, 6, (byte FAR *)l_buffer) ;
            }
            break ;

        case SAVETYPE:
            l_str = "-savelevel-" ;
            break ;

        case STRINGTYPE:
            if( ACCESS(&p_obj) <= READONLY ) {
                tprint("(", 1) ;
                l_str = (byte FAR *)VALUE(&p_obj) ;
                if( LENGTH(&p_obj) )
                    tprint(l_str, LENGTH(&p_obj)) ;
                tprint(")", 1) ;
                return(0) ;
            }
            else
                l_str = "-string-" ;
            break ;

        default:
            l_str = "%%[ Error: in typeprint ]%%" ;
    }   /* switch */

    tprint(l_str, lstrlen(l_str)) ;     /* @WIN */
    tprint(" ", 1) ;

    return(0) ;
}   /* typeprint */

/************************************
 *  op_pstack
 ************************************/
fix
op_pstack()
{
    fix     l_i ;
    struct  object_def  l_anyobj ;

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* copy and print out the content of operand stack from top most */
    for(l_i=0 ; (ufix)l_i < COUNT() ; l_i++) {          //@WIN
        COPY_OBJ(GET_OPERAND(l_i), &l_anyobj) ;
        PUSH_OBJ(&l_anyobj) ;
        two_equal() ;
    }   /* for */

    return(0) ;
}   /* op_pstack */

/************************************
 *  one_equal
 ************************************/
fix
one_equal()
{
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    one_typeprint() ;

    if( ! ANY_ERROR() ) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        POP(1) ;
    }

    return(0) ;
}   /* one_equal */

/************************************
 *  one_typeprint
 ************************************/
static void near
one_typeprint()
{
    fix     l_i ;
    ufix16  l_type ;
    byte    FAR *l_str, l_buffer[30] ;
    real64  l_double ;
    union   four_byte   l_num ;

    l_type = TYPE_OP(0) ;
    switch(l_type) {
        case STRINGTYPE:
            if( ACCESS_OP(0) <= READONLY ) {
                l_str = (byte FAR *)VALUE_OP(0) ;
                GEIio_write(GEIio_stdout, l_str, LENGTH_OP(0)) ;
            } else
                ERROR(INVALIDACCESS) ;
            return ;

        case BOOLEANTYPE:
            if(VALUE_OP(0) == TRUE)
                l_str = "true" ;
            else
                l_str = "false" ;
            break ;

        case INTEGERTYPE:
            l_str = (byte FAR *)ltoa( (fix32)VALUE_OP(0),
                                      (char FAR *)l_buffer, 10) ;    /*@WIN*/
            break ;

        case NAMETYPE:
            l_i = (fix)VALUE_OP(0) ;
            l_str = name_table[l_i]->text ;
            GEIio_write(GEIio_stdout, l_str, name_table[l_i]->name_len) ;
            return ;

        case OPERATORTYPE:
            l_i = LENGTH_OP(0) ;
/* qqq, begin */
            /*
            switch( ROM_RAM_OP(0) ) {
                case RAM:
                    l_str = systemdict_table[l_i].key ;
                    break ;

                case ROM:
                    l_str = oper_table[l_i].name ;
                    break ;

                default:
                    l_str = "Error: OPERATORTYPE" ;
            }   |* switch *|
            */
            l_str = systemdict_table[l_i].key ;
/* qqq, end */
            break ;

        case REALTYPE:
            l_num.ll = (fix32)VALUE_OP(0) ;
            if(l_num.ll == INFINITY)
                l_str = "Infinity.0" ;
            else {
                l_double = l_num.ff ;
                l_str = (byte FAR *)gcvt(l_double, 6, (byte FAR *)l_buffer) ;
            }
            break ;

        default:
            l_str = "--nostringval--" ;
    }   /* switch */

    GEIio_write(GEIio_stdout, l_str, lstrlen(l_str)) ;          /* @WIN */

    return ;
}   /* one_typeprint */

/************************************
 *  op_stack
 ************************************/
fix
op_stack()
{
    fix     l_i ;
    struct  object_def  l_anyobj ;

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* copy and print out the content of operand stack from top most */
    for(l_i=0 ; (ufix)l_i < COUNT() ; l_i++) {          //@WIN
        COPY_OBJ(GET_OPERAND(l_i), &l_anyobj) ;
        PUSH_OBJ(&l_anyobj) ;
        one_equal() ;
    }   /* for */

    return(0) ;
}   /* op_stack */

/************************************
 *  one_equal_print
 ************************************/
fix
one_equal_print()
{
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    /* without a new line */
    one_typeprint() ;

    if( ! ANY_ERROR() )
        POP(1) ;

    return(0) ;
}   /* one_equal_print */

/************************************
 *  op_findfont
 ************************************/
fix
op_findfont()
{
    struct  object_def  FAR *l_fontdir, FAR *l_fontdict ;
    struct  object_def  l_newfont, FAR *l_tmpobj ;

    l_newfont.bitfield = 0;     /*@WIN; add for init*/
    /* push FontDirectory on the operand stack */
    get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir) ;

#ifdef FIND_SUB
    {
    struct  object_def  str_obj, key_obj ;
    ufix32  key_idx ;
    char    string1[80], string2[80] ;
    char    FAR *string ;

    COPY_OBJ(GET_OPERAND(0), &key_obj) ;
    POP(1) ;

    /* check if font name was found */
    if ( !get_dict(l_fontdir, &key_obj, &l_fontdict) ) {

        /* do open_file and using selectfont */
        /* AppendName */
        key_idx = VALUE(&key_obj) ;
        string = (byte FAR *)alloc_vm((ufix32)80) ;
        memcpy(string2, name_table[(fix)key_idx]->text,
                        name_table[(fix)key_idx]->name_len) ;
        string2[name_table[(fix)key_idx]->name_len] = '\0' ;
        lstrcpy(string, (char FAR *)"fonts/") ;         /* @WIN */
        strcat(string, string2) ;

        /* put file name into operandstack */
        TYPE_SET(&str_obj, STRINGTYPE) ;
        ACCESS_SET(&str_obj, UNLIMITED) ;
        ATTRIBUTE_SET(&str_obj, LITERAL) ;
        ROM_RAM_SET(&str_obj, RAM) ;
        LEVEL_SET(&str_obj, current_save_level) ;
        LENGTH(&str_obj) = lstrlen(string) ;            /* @WIN */
        VALUE(&str_obj) = (ufix32)string ;
        PUSH_OBJ(&str_obj) ;

        /* run disk file 'fonts/XXX' */
        op_run() ;
        if (ANY_ERROR()){      /* if file not found */
            if (ANY_ERROR() != UNDEFINEDFILENAME)
                return(0) ;
            CLEAR_ERROR() ;
            POP(1) ;            /* pop the file name */

           /* not found, using subsitute font */
            PUSH_OBJ(&key_obj) ;
            st_selectsubstitutefont() ;   /* call font_op5.c of msfont */

            key_idx = VALUE(GET_OPERAND(0)) ;
            memcpy(string1, name_table[(fix)key_idx]->text,
                            name_table[(fix)key_idx]->name_len) ;
            string1[name_table[(fix)key_idx]->name_len] = '\0' ;
            get_dict_value(FONTDIRECTORY, string1, &l_fontdict) ;
            POP(1) ;

            GEIio_write(GEIio_stdout, string2, lstrlen(string2)) ; /* @WIN */
            GEIio_write(GEIio_stdout, " not found, using ", (fix)18) ;
            GEIio_write(GEIio_stdout, string1, lstrlen(string1)) ; /* @WIN */
            GEIio_write(GEIio_stdout, ".\n", (fix)2) ;
            op_flush() ;
         }    /* if -- any error */
         else {
             /* Disk font is found & executed */
             /* get the font name from fontdirectory */
             if( !get_dict(l_fontdir, &key_obj, &l_fontdict) ){
                 PUSH_OBJ(&key_obj) ;
                 ERROR(UNDEFINED) ;
                 return(0) ;
             }
             if (COUNT() > 0)    POP(1) ;
             else {
                 ERROR(STACKUNDERFLOW) ;
                 return(0) ;
             }
         }  /* else --any error */
    }       /* fontname not found in FontDirectory  */

    /* push the font dictionary */
    PUSH_ORIGLEVEL_OBJ(l_fontdict) ;
    return(0) ;
    }
}
#else
    /* check if font name was found */
    if ( get_dict(l_fontdir, GET_OPERAND(0), &l_fontdict) ) {
        /* found */
        POP(1) ;
    } else {
        if (FRCOUNT() < 1) {
            ERROR(STACKOVERFLOW) ;
            return(0) ;
        }
        get_name(&l_newfont, "Courier", 7, FALSE) ;
        PUSH_OBJ(&l_newfont) ;
        get_dict_value(MESSAGEDICT, "fontnotfound", &l_tmpobj) ;
        interpreter(l_tmpobj) ;
        get_dict(l_fontdir, &l_newfont, &l_fontdict) ;
    } /* if */
    op_flush() ;
    /* push the font dictionary */
    PUSH_ORIGLEVEL_OBJ(l_fontdict) ;

    return(0) ;
}   /* op_findfont */
#endif /* FIND_SUB */

/************************************
 *  np_Run
 ************************************/
fix
np_Run()
{
    struct object_def   l_obj ;

    /* print the input string name (file name): dup == */
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    tp_depth=0 ;
    cp = 0 ;

    if(! typeprint(l_obj))
        GEIio_write(GEIio_stdout, "\n", 1) ;

    op_flush() ;

    /* execute "run" operator */
    op_run() ;

    return(0) ;
}   /* np_Run */

/*
 *----------------------------------------------------------------------
 * change_status()
 *----------------------------------------------------------------------
 */
void
change_status()
{
    struct object_def   FAR *l_tmpobj, l_job ;
    ufix16 l_len ;

    get_dict_value(STATUSDICT, "jobname", &l_tmpobj) ;
    if ((l_len = LENGTH(l_tmpobj)) > 0) {
        //DJC add from history.log UPD023
        if (l_len > MAXJOBNAME-3) l_len = MAXJOBNAME-3;
        lstrncpy(job_name, (byte FAR *)VALUE(l_tmpobj), l_len) ; /*@WIN*/
        job_name[l_len] = ';' ;
        job_name[l_len + 1] = ' ' ;
        job_name[l_len + 2] = '\0' ;
    }
    else job_name[0] = '\0' ;

    l_len = lstrlen(job_state) - 2 ;            /* @WIN */
    TYPE_SET(&l_job, STRINGTYPE) ;
    ATTRIBUTE_SET(&l_job, LITERAL) ;
    ACCESS_SET(&l_job, READONLY) ;
    LENGTH(&l_job) = l_len ;
    VALUE(&l_job) = (ULONG_PTR)job_state ;
    put_dict_value1(STATUSDICT, "jobstate", &l_job) ;

#ifdef  DBG
    get_dict_value(STATUSDICT, "jobname", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
    get_dict_value(STATUSDICT, "jobstate", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
    get_dict_value(STATUSDICT, "jobsource", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
#endif  /* DBG */

    return ;
}   /* change_status */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\graph\stroke.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:       stroke.c
 *
 *      Purpose:
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         10/5/88     seperate this file from path.c
 *                              @STK_CIR: stroke enhancement of round linejoin
 *                              & linecap by caching the bitmap of the circle:
 *                              add routines: circle_ctl_points, circle_list,
 *                              flatten_circle
 *                  10/12/88    add a trick of comparision with float 1.0
 *                  10/19/88    update linetour_i of dash line:
 *                              still use floating point arith for each starting
 *                              and end point of dash segment
 *                  10/20/88    add an error tolerance to length of line segment
 *                              for dash line
 *                  10/20/88    round_point(): revise calculation of bounding
 *                              box of the circle cache
 *                  10/21/88    @THIN_STK: add routines for thin stroke:
 *                              1. is_thinstroke: check if thin linewidth
 *                              2. path_to_outline_t(): thin stroke
 *                              3. calling new routine: fill_line();
 *                  10/24/88    paint_or_save(): add checking of infinitive
 *                              numbers
 *                  10/26/88    linetour & linetour_i: set rect2.vct_u for
 *                              calling linecap
 *                  10/27/88    change x = y = z; ==> x = z; y = z;
 *                              when x, y, and z are float numbers
 *                  10/28/88    @CRC: update circle cache for putting bitmap in
 *                              correct position:
 *                              1. revise
 *                                 1) round_point for setting ref_x & ref_y,
 *                                    and calling fill_shape(.., F_FROM_CRC)
 *                                 2) fill_shape: add another type F_FROM_CRC
 *                  10/28/88    update path_to_outline_i & path_to_outline_t:
 *                              F2SFX ==> F2SFX_T, truncation instead of
 *                              rounding for circle cache in correct position
 *                  10/28/88    F_SFX ==> F2SFX_T
 *                  11/07/88    initialize status87 at init_stroke
 *                  11/08/88    update flatten_circle(): for big circle
 *                              flt_vlist just a pointer; no structure space
 *                  11/18/88    init_stroke():
 *                              clear status87 after each inst. that may arouse
 *                              integer overflow
 *                  11/21/88    delete inverse_ctm_i:
 *                              1) get_rect_points(), get_rect_points_i():
 *                                 calculate slope m from ctm instead of inverse
 *                                 ctm.  ==> not need to use inverse_ctm_i
 *                              2) linetour(), linetour_i():
 *                                 derive ratio of advanving units from
 *                                 rect_info to enhance dash line
 *                              3) linecap_i():
 *                                 use floating inverse_ctm[]
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/30/88    round_point(): call init_edgetable before
 *                              shape_approximation
 *                  12/19/88    @FLT_CVE: path_to_outline, path_to_outline_i,
 *                              path_to_outline_t: flatten and process each
 *                              curveto node instead of flattening the whole
 *                              subpath
 *                  12/23/88    update round_point => circle_cache only for
 *                              from_cache_to_page, i.e. if to_cache then
 *                              no circle_cache
 *                  1/5/89      update get_rect_point_i(): multiply of long
 *                              integer for more acuracy
 *                  1/5/89      linetour() & linetour_i(): revise the
 *                              calculation of length of line segment for
 *                              thin line with dash pattern
 *                  1/9/89      path_to_outline_t: skip degenerated case of path
 *                              containing only a moveto and closepath node
 *                  1/12/89     round_point(): shrink circle cache 1 pixel for
 *                              quality
 *                  1/26/89     init_stroke(): add checking of inifinity
 *                  1/26/89     @CAP: update linetour & linetour_i() -- revise
 *                              SQUARE_CAP rectangle of dash line
 *                  1/27/89     linecap_i(): revise tolrence of computing
 *                              expansion of SQUARE_CAP for consistency with
 *                              linecap()
 *                  1/28/89     path_to_outline, path_to_outline_i &
 *                              path_to_outline_t(): save value of return
 *                              structure after calling bezier_to_line
 *                  4/22/89     @RND: F2SFX_T => F2SFX
 *                  5/9/89      update coord. of fill_line() from pixel to
 *                              1/8 pixel
 *                  5/9/89      round_point(): adjust flatness of circle cache
 *                              for quality
 *                  5/26/89     apply new macro for zero comparison of floating
 *                              points; macro: IS_ZERO()
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  1/10/90     init_stroke(): modify stroke flatness; not needs
 *                              so accurate
 *                  4/6/90      linejoin_i(): fixed the bug of short integer
 *                              overflow; sfix_t ==> lfix_t.
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  10/15/90    updated for one point thin line stroke of round cap
 *                  11/29/90    updated for negative offset of init_dash_pattern
 *                  12/8/90     Dash pattern changed with the array
 *                  12/18/90    draw_line(): update for single point
 *                  02/04/91    update circle_ctl_points, [r, c] * CTM, not
 *                              CTM * [r, c]
 *                  3/20/91     refine the tolerance check:
 *                              f <  0 --> SIGN_F(f)
 *                  4/17/91     round_point(): limit check for edge table
 *                  11/11/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "fillproc.h"
#include "fillproc.ext"
#include "font.h"
#include "font.ext"

/* @WIN; prototype */
void fill_box (struct coord_i FAR *, struct coord_i FAR *);     /*@WIN*/
void fill_rect (struct line_seg_i FAR *);                       /*@WIN*/

/* **************** local structure *************** *)
(* line_segment structure:
 *                      pgn[1]                           pgn[2]
 *                            +------------------------+
 *                      p0    +------------------------+ p1
 *                            +------------------------+
 *                      pgn[0]                           pgn[3]
 *)
struct  line_seg {
        struct coord p0;        (* starting point of central line *)
        struct coord p1;        (* ending point of central line *)
        struct coord vct_u;     (* vector of p0 -> pgn[0] in user space *)
        struct coord vct_d;     (* vector of p0 -> pgn[0] in device space *)
        struct coord pgn[4];    (* outline of the line segment *)
};
struct  line_seg_i {      (* @STK_INT *)
        struct coord_i p0;        (* starting point of central line *)
        struct coord_i p1;        (* ending point of central line *)
        struct coord   vct_u;     (* vector of p0 -> pgn[0] in user space *)
        struct coord_i vct_d;     (* vector of p0 -> pgn[0] in device space *)
        struct coord_i pgn[4];    (* outline of the line segment *)
};      * commented due to enhancement by jwm, 3-28-91, Jack */


/* **************** static variables *************** */
/* parameters used by stroke/strokepath @STK_INFO */
static struct {
        real32 ctm[4];         /* CTM */
        real32 width;          /* line width */
        real32 limit;          /* miter limit */
        real32 flatness;       /* flatness */
                               /* above items are copied from graphics
                                * state for checking if this structure
                                * need to re-calculate for the stroke
                                */
        real32 half_width;     /* half of line width */
        sfix_t half_width_i;   /* half of line width, SFX format @STK_INT */
        real32 flat;           /* flatness for stroke */
        lfix_t flat_l;         /* LFX format of flatness @FLT_CVE */
        real32 miter;          /* internal miter value */
        real32 miter0;         /* internal min. miter value */
        bool   change_circle;  /* circle need to re-generate */
        real32 exp_widthx,     /* max expanding width in device space 11/22/88*/
               exp_widthy;
        real32 exp_miterx,     /* max expanding miter in device space 11/22/88*/
               exp_mitery;

} stk_info = {  /* set init values */
        (real32)0., (real32)0., (real32)0., (real32)0.,
        (real32)0.,
        (real32)0.,
        (real32)0.,
        (real32)0.,
        (sfix_t)0,              /* @STK_INT */
        (real32)0.,
        (lfix_t)0,              /* @FLT_CVE */
        (real32)0.,
        (real32)0.,
        TRUE,
        (real32)0., (real32)0.,
        (real32)0., (real32)0.
};

/* variables to save the circle for ronud join and cap */
static struct coord curve[4][3];        /* 4 bezier curves of the circle */
static real32 near circle_bbox[4];      /* bounding box */
static SP_IDX near circle_sp = NULLP;   /* subpath of flattened circle */
static struct coord circle_root;        /* root of the circle @TOUR */
static ufix circle_flag;                /* flag of circle bitmap; see below */


/* variables for circle cache */
static struct Char_Tbl near cir_cache_info;    /* cache_info of circle bitmap */
static struct Char_Tbl FAR * near save_cache_info; /* saved cache information */
static struct cp_hdr save_clip;
static ufix near save_dest;

static sfix_t near stroke_ctm[6];       /* interger version of current CTM;
                                         * SFIX13 format, @STK_INT
                                         */
//static  ufix near inside_clip_flag; /* inside single clip region @STK_INT */
static  ULONG_PTR inside_clip_flag;     /* inside single clip region @STK_INT @WIN*/

/* local variables for specifing paint type(ACT_PAINT)
 * initialized by "path_to_outline", referenced by "paint_or_save"
 */
// static  ufix near paint_flag;
static  ULONG_PTR paint_flag;              /* @WIN */

/* side selection of two sides of the line segment to derive the join point */
#define LINE03  0
#define LINE12  1

/* selection of endpoint for linecap */
#define START_POINT     0
#define END_POINT       1

/* property of CTM */
#define NORMAL_CTM      1
#define LEFT_HAND_CTM   2

/* flag of circle bitmap */
#define CIR_UNSET_CACHE 0       /* circle does not generate yet */
#define CIR_IN_CACHE    1       /* circle in cache */
#define CIR_OUT_CACHE   2       /* circle too large to put in cache */

/* ********** static function declartion ********** */

#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static void near draw_line (sfix_t, sfix_t, sfix_t, sfix_t); /* @FLT_CVE */
static void near linetour (struct line_seg FAR *);      /*@WIN*/
static void near linetour_i (struct line_seg_i FAR *);      /*@WIN*/
static void near linejoin (struct line_seg FAR*, struct line_seg FAR*);
static void near linejoin_i (struct line_seg_i FAR*, struct line_seg_i FAR*);
static void near linecap (struct line_seg FAR *, fix);  /*@WIN*/
static void near linecap_i (struct line_seg_i FAR *, fix);      /*@WIN*/
static void near get_rect_points (struct line_seg FAR*);        /*@WIN*/
static void near get_rect_points_i (struct line_seg_i FAR*);    /*@WIN*/
static void near paint_or_save (struct coord FAR *);            /*@WIN*/
static void near paint_or_save_i (struct coord_i FAR *);        /*@WIN*/
static void near round_point(long32, long32);
static void near circle_ctl_points(void);
/* static struct vx_lst * near circle_list(long32, long32); @NODE */
static SP_IDX near circle_list(long32, long32);
/* static void near flatten_circle (struct vx_lst *); @NODE */
static void near flatten_circle (SP_IDX);
/* static SP_IDX near vlist_to_subp (struct vx_lst *); @NODE */
static SP_IDX near subpath_gen(struct coord FAR *);     /*@WIN*/
#ifdef  _AM29K
static void near   dummy(void);
#endif
#else

/* for no type checks of the parameters in function declarations */
static void near draw_line (); /* @FLT_CVE */
static void near linetour ();
static void near linetour_i ();
static void near linejoin ();
static void near linejoin_i ();
static void near linecap ();
static void near linecap_i ();
static void near get_rect_points ();
static void near get_rect_points_i ();
static void near paint_or_save ();
static void near paint_or_save_i ();
static void near round_point();
static void near circle_ctl_points();
/* static struct vx_lst * near circle_list(); @NODE */
static SP_IDX near circle_list();
static void near flatten_circle ();
/* static SP_IDX near vlist_to_subp (); @NODE */
static SP_IDX near subpath_gen();
#ifdef  _AM29K
static void near   dummy();
#endif

#endif


/***********************************************************************
 * Given a subpath and a paint_flag, this module constructs an outline
 * of the subpath, and fills the outline in case of paint_flag is true,
 * otherwise creates a new path of the outline.
 * For performance consideration, there are 3 routines provided:
 * 1) path_to_outline   -- for strokepath & worse case of stroke; floating points
 *                         arith.
 * 2) path_to_outline_i -- for integer stroke; fixed points arith.
 * 3) path_to_outline_t -- for thin stroke; fixed points arith. & no
 *                         linejoin/linecap
 *
 * TITLE:       path_to_outline
 *              path_to_outline_i
 *              path_to_outline_t
 *
 * CALL:        path_to_outline  (isubpath, param)
 *              path_to_outline_i(isubpath, param)
 *              path_to_outline_t(isubpath, param)
 *
 * PARAMETERS:  isubpath -- input subpath
 *              param -- TRUE : stroke command
 *                       FALSE: strokepath command
 *
 * INTERFACE:   op_strokepath
 *              stroke_shape
 *
 * CALLS:       flatten_subpath, linetour, linejoin, linecap, get_rect_points
 *
 * RETURN:      None
 **********************************************************************/
void path_to_outline (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    real32   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;
    real32   first_x, first_y;
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_pat_on;   /* if first line segment not a gap */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg rect0, rect1, rect_first;
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    real32  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = (ULONG_PTR) param;  /* initialize paint_flag @WIN */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("%f %f moveto\n", x2, y2);
#endif

            /*
             * Set up starting dash pattern in actdp struct
             * (copy from init_dash_pattern to active_dash_pattern)
             *  initdp => actdp
             */
            actdp.dpat_on = GSptr->dash_pattern.dpat_on;
            actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
            actdp.dpat_index = GSptr->dash_pattern.dpat_index;

            /* keep first dpat_on flag, for last line cap testing */
            first_pat_on = actdp.dpat_on;

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("%f %f lineto\n", x2, y2);
#endif

            /* ignore this node if it coincides with the next node */
            if ((F2L(x1) == F2L(x2)) && (F2L(y1) == F2L(y2))){
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points ((struct  line_seg FAR *)&rect1);   /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                /* Create a linejoin path for last_node
                 */
                linejoin ((struct  line_seg FAR *)&rect0,       /*@WIN*/
                        (struct  line_seg FAR *)&rect1);        /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */
            linetour ((struct  line_seg FAR *)&rect1);  /*@WIN*/

            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif

            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = vtx->VERTEX_X;
            y3 = vtx->VERTEX_Y;
            vtx = &node_table[vtx->next];
            x4 = vtx->VERTEX_X;
            y4 = vtx->VERTEX_Y;

            /* @NODE
             * vlist = bezier_to_line(F2L(stk_info.flat), F2L(x1), F2L(y1),
             */
            vlist_head = bezier_to_line(F2L(stk_info.flat), F2L(x1), F2L(y1),
                      F2L(x2), F2L(y2), F2L(x3), F2L(y3), F2L(x4), F2L(y4));

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VERTEX_X;
                y2 = node->VERTEX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", x2, y2);
#endif

                /* ignore this node if it coincides with the next node */
                if ((F2L(x1) == F2L(x2)) && (F2L(y1) == F2L(y2))){
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points ((struct  line_seg FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin ((struct  line_seg FAR *)&rect0, /*@WIN*/
                            (struct  line_seg FAR *)&rect1);  /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
                linetour ((struct  line_seg FAR *)&rect1);      /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :
#ifdef DBG3
            printf("closepath\n");
#endif

            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((F2L(x1) != F2L(x2)) || (F2L(y1) != F2L(y2))){
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;
                    get_rect_points ((struct  line_seg FAR *)&rect1); /*@WIN*/
                                /* input: p0, p1; output: pgn[4] */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             */
                            linejoin ((struct  line_seg FAR *)&rect0, /*@WIN*/
                                (struct  line_seg FAR *)&rect1); /*@WIN*/
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    linetour ((struct  line_seg FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin ((struct  line_seg FAR *)&rect1,   /*@WIN*/
                (struct  line_seg FAR *)&rect_first);   /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        /* make sure the last line segment is not a gap */
        if (GSptr->dash_pattern.pat_size == 0) {
                /* solid line, always creates a cap */
                linecap ((struct  line_seg FAR *)&rect1, END_POINT); /*@WIN*/

        } else {
                /* check dpat_on flag of last segment */
                if(IS_ZERO(actdp.dpat_offset)) {        /* 5/26/89 */
                    /* actdp.dpat_on is for next line segment, so
                     * its inverse is ones for last line segment
                     */
                    if(!actdp.dpat_on)          /*@WIN*/
                        linecap ((struct  line_seg FAR *)&rect1, END_POINT);
                } else {
                    if(actdp.dpat_on)           /*@WIN*/
                        linecap ((struct  line_seg FAR *)&rect1, END_POINT);
                }
        }

        /* Create a linecap_path for sub_head node; */
        /* make sure the first line segment is not a gap */
        if (first_pat_on) {     /*@WIN*/
            linecap ((struct  line_seg FAR *)&rect_first, START_POINT);
                    /* create a cap at starting point */
        } /* if first_pat_on */

    } /* if !close_flag */

}


/*
 * Integer operation version
 */
void path_to_outline_i (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    /* struct  vx_lst *b_vlist; @NODE */
    sfix_t   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y;                                  /* @STK_INT */
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_pat_on;   /* if first line segment not a gap */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg_i rect0, rect1, rect_first;                /* @STK_INT */
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = (ULONG_PTR) param;/* initialize inside_clip_flag @STK_INT */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);          /* use rounding for quality */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f moveto\n", SFX2F(x2), SFX2F(y2));
#endif

            /*
             * Set up starting dash pattern in actdp struct
             * (copy from init_dash_pattern to active_dash_pattern)
             *  initdp => actdp
             */
            actdp.dpat_on = GSptr->dash_pattern.dpat_on;
            actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
            actdp.dpat_index = GSptr->dash_pattern.dpat_index;

            /* keep first dpat_on flag, for last line cap testing */
            first_pat_on = actdp.dpat_on;

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f lineto\n", SFX2F(x2), SFX2F(y2));
#endif


            /* ignore this node if it coincides with the next node */
            if ((x1 == x2) && (y1 == y2)){              /* @STK_INT */
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points_i((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1);  /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */
            linetour_i ((struct  line_seg_i FAR *)&rect1);      /*@WIN*/

            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif


            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                      x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", SFX2F(x2), SFX2F(y2));
#endif


                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)){          /* @STK_INT */
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                        /* Create a linejoin path for last_node
                         */
                        linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1); /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
                linetour_i ((struct  line_seg_i FAR *)&rect1);  /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :

#ifdef DBG3
            printf("closepath\n");
#endif


            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((x1 != x2) || (y1 != y2)){              /* @STK_INT */
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;
                    get_rect_points_i ((struct  line_seg_i FAR *)&rect1);
                                /* input: p0, p1; output: pgn[4] @WIN */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             */
                            linejoin_i (&rect0, &rect1);
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    linetour_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin_i ((struct  line_seg_i FAR *)&rect1,       /*@WIN*/
                    (struct  line_seg_i FAR *)&rect_first);     /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        /* make sure the last line segment is not a gap */
        if (GSptr->dash_pattern.pat_size == 0) {
                /* solid line, always creates a cap @WIN*/
                linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);

        } else {
                /* check dpat_on flag of last segment */
                if(IS_ZERO(actdp.dpat_offset)) {        /* 5/26/89 */
                    /* actdp.dpat_on is for next line segment, so
                     * its inverse is ones for last line segment
                     */
                    if(!actdp.dpat_on)          /*@WIN*/
                        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);
                } else {
                    if(actdp.dpat_on)           /*@WIN*/
                        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);
                }
        }

        /* Create a linecap_path for sub_head node; */
        /* make sure the first line segment is not a gap */
        if (first_pat_on) {             /*@WIN*/
            linecap_i ((struct  line_seg_i FAR *)&rect_first, START_POINT);
                    /* create a cap at starting point */
        } /* if first_pat_on */

    } /* if !close_flag */

}


/*
 * 'quick' version : integer operation, solid line  -jwm, 3/18/91, -begin-
 */
void path_to_outline_q (isubpath, param)
SP_IDX  isubpath;
fix     *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    /* struct  vx_lst *b_vlist; @NODE */
    sfix_t   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y, i;                                  /* @STK_INT */
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg_i rect0, rect1, rect_first;
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */
    struct  coord_i ul_coord, lr_coord;

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = TRUE;          /* inside_clip_flag always true */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);          /* use rounding for quality */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f moveto\n", SFX2F(x2), SFX2F(y2));
#endif

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f lineto\n", SFX2F(x2), SFX2F(y2));
#endif


            /* ignore this node if it coincides with the next node */
            if ((x1 == x2) && (y1 == y2)){              /* @STK_INT */
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                        (struct  line_seg_i FAR *)&rect1);      /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */

            if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91*/
                ul_coord = rect1.pgn[0];
                lr_coord = rect1.pgn[0];
                for (i = 1; i < 4; i++) {
                    if (rect1.pgn[i].x < ul_coord.x)
                        ul_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y < ul_coord.y)
                        ul_coord.y = rect1.pgn[i].y;
                    if (rect1.pgn[i].x > lr_coord.x)
                        lr_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y > lr_coord.y)
                        lr_coord.y = rect1.pgn[i].y;
                    }
                fill_box ((struct coord_i FAR *)&ul_coord,      /*@WIN*/
                    (struct coord_i FAR *)&lr_coord);           /*@WIN*/
                }
            else
                fill_rect ((struct  line_seg_i FAR *)&rect1);   /*@WIN*/
            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif


            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                        x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", SFX2F(x2), SFX2F(y2));
#endif


                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)){          /* @STK_INT */
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                        /* Create a linejoin path for last_node
                         */
                        linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1);  /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
            if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91 */
                ul_coord = rect1.pgn[0];
                lr_coord = rect1.pgn[0];
                for (i = 1; i < 4; i++) {
                    if (rect1.pgn[i].x < ul_coord.x)
                        ul_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y < ul_coord.y)
                        ul_coord.y = rect1.pgn[i].y;
                    if (rect1.pgn[i].x > lr_coord.x)
                        lr_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y > lr_coord.y)
                        lr_coord.y = rect1.pgn[i].y;
                    }
                fill_box ((struct coord_i FAR *)&ul_coord,      /*@WIN*/
                    (struct coord_i FAR *)&lr_coord);       /*@WIN*/
                }
            else
                fill_rect ((struct  line_seg_i FAR *)&rect1);   /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :

#ifdef DBG3
            printf("closepath\n");
#endif


            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((x1 != x2) || (y1 != y2)){              /* @STK_INT */
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;                    /*@WIN*/
                    get_rect_points_i ((struct  line_seg_i FAR *)&rect1);
                                /* input: p0, p1; output: pgn[4] */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             @WIN */
                            linejoin_i ((struct  line_seg_i FAR *)&rect0,
                                (struct  line_seg_i FAR *)&rect1);
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91 */
                        ul_coord = rect1.pgn[0];
                        lr_coord = rect1.pgn[0];
                        for (i = 1; i < 4; i++) {
                            if (rect1.pgn[i].x < ul_coord.x)
                                ul_coord.x = rect1.pgn[i].x;
                            if (rect1.pgn[i].y < ul_coord.y)
                                ul_coord.y = rect1.pgn[i].y;
                            if (rect1.pgn[i].x > lr_coord.x)
                                lr_coord.x = rect1.pgn[i].x;
                            if (rect1.pgn[i].y > lr_coord.y)
                                lr_coord.y = rect1.pgn[i].y;
                            }
                        fill_box ((struct coord_i FAR *)&ul_coord, /*@WIN*/
                            (struct coord_i FAR *)&lr_coord);  /*@WIN*/
                        }
                    else
                        fill_rect ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin_i ((struct  line_seg_i FAR *)&rect1,       /*@WIN*/
                (struct  line_seg_i FAR *)&rect_first);         /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT); /*@WIN*/

        /* Create a linecap_path for sub_head node; */
        linecap_i ((struct  line_seg_i FAR *)&rect_first, START_POINT); /*@WIN*/

    } /* if !close_flag */

}
/*
 * 'quick' version : integer operation, solid line  -jwm, 3/18/91, -end-
 */

/*
 * Thin stroke version
 * Features: 1. always in clip region, ie. no clipping
 *           2. no linejoin, linecap
 *           3. should delt with dash
 */
void path_to_outline_t (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx;
    sfix_t   x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y;                                  /* @STK_INT */
    bool    first_seg_exist;   /* if first line segment has been created */
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = (ULONG_PTR) param;  /* initialize inside_clip_flag @STK_INT */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     */
    first_vertex = isubpath;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            if (GSptr->dash_pattern.pat_size != 0) { /* dash line */
                /*
                 * Set up starting dash pattern in actdp struct
                 * (copy from init_dash_pattern to active_dash_pattern)
                 *  initdp => actdp
                 */
                actdp.dpat_on = GSptr->dash_pattern.dpat_on;
                actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
                actdp.dpat_index = GSptr->dash_pattern.dpat_index;
            }
            continue;   /* jump to for loop */

        case LINETO :
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            if (!first_seg_exist) {
                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;
                    first_seg_exist = TRUE;
            }

            /* ignore this node if it coincides with the next node */
            /* the following line is corrected by Jack, degenerate case,
               ref. p.229 of PLRM, 10-15-90 */
/*          if ((x1 == x2) && (y1 == y2)) continue;     (* jump to for loop */

//DJC UPD050, delete following line
//            if ((x1 == x2) && (y1 == y2) && (GSptr->line_cap != 1)) continue;

            draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                      x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;

                if (!first_seg_exist) {
                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;
                        first_seg_exist = TRUE;
                }

                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)) continue;
                draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */
            break;

        case CLOSEPATH :
            if (!first_seg_exist) break;
                                   /* degernated case; just return 1/9/89 */
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif
        } /* switch */
    } /* subpath loop */

}



/*
 * Draw line segment (x1, y1) => (x2, y2)
 */
static void near draw_line (x1, y1, x2, y2)
sfix_t  x1, y1, x2, y2;
{
        struct  line_seg_i rect1;                /* @STK_INT */

/*      if (GSptr->dash_pattern.pat_size == 0) { (* solid line */
        if ((GSptr->dash_pattern.pat_size == 0) ||      /* solid line */
            ((x1==x2) && (y1==y2))) {   /* or just a single point 12/18/90 */
            struct  tpzd_info fill_info;

            /* if not to fill a thin line(degernated trapezoid), but to
             * calculate the true rectangle outline for filling, then use the
             * following code
             *   rect1.p0.x = x1;
             *   rect1.p0.y = y1;
             *   rect1.p1.x = x2;
             *   rect1.p1.y = y2;
             *   get_rect_points_i (&rect1);
             *   paint_or_save_i (rect1.pgn);
             */

            /* set cache info */
            if (fill_destination == F_TO_CACHE) {
                    /* bounding box is defined by cache mechanism */
                    fill_info.BMAP = cache_info->bitmap;
                    fill_info.box_w = cache_info->box_w;
                    fill_info.box_h = cache_info->box_h;
            }

            fill_line (fill_destination, &fill_info, x1, y1, x2, y2);

        } else {        /* dash line, needs to call linetour */

            /* generate a degernated rectangle(a line) for filling */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            rect1.vct_u.x = zero_f;
            rect1.vct_u.y = zero_f;
            rect1.vct_d.x = rect1.vct_d.y = 0;
            rect1.pgn[0].x = rect1.pgn[1].x = x1;
            rect1.pgn[0].y = rect1.pgn[1].y = y1;
            rect1.pgn[2].x = rect1.pgn[3].x = x2;
            rect1.pgn[2].y = rect1.pgn[3].y = y2;
            linetour_i ((struct  line_seg_i FAR *)&rect1);      /*@WIN*/
        } /* if */
}

/***********************************************************************
 * This module is to check if the linewidth is thin enough to apply special
 * stroke routine.
 *
 * TITLE:       is_thinstroke
 *
 * CALL:        is_thinstroke()
 *
 * PARAMETERS:
 *
 * INTERFACE:   stroke_shape
 *
 * CALLS:       None
 *
 * RETURN:      TRUE  -- Yes, may use thin stroke approach
 *              FALSE -- No
 *
 **********************************************************************/
bool is_thinstroke()
{
        /* thin stroke only for no halftoning */
        if (HTP_Type != HT_WHITE && HTP_Type != HT_BLACK) return(FALSE);

        if ((MAGN(stk_info.exp_widthx) > 0x3f000000L) || /*trick:0.5 11/23/88 */
            (MAGN(stk_info.exp_widthy) > 0x3f000000L)) return(FALSE);

        return(TRUE);
}


/***********************************************************************
 * This module is to initialize the dash pattern for each setdash command
 *
 * TITLE:       init_dash_pattern
 *
 * CALL:        init_dash_pattern()
 *
 * PARAMETERS:  None
 *
 * INTERFACE:   op_setdash
 *
 * CALLS:       None
 *
 * RETURN:      None
 **********************************************************************/
void  init_dash_pattern()
{
        fix     i;
        real32   total_length;
        real32  pattern[11];             /* 12-8-90, compatibility */

        /* return for solid line */
        if (GSptr->dash_pattern.pat_size == 0) {
                return;
        }

        /* initialization */
        GSptr->dash_pattern.dpat_on = TRUE;

        if( !get_array_elmt(&GSptr->dash_pattern.pattern_obj,
             GSptr->dash_pattern.pat_size, pattern, G_ARRAY) )
             return;                     /* 12-8-90, compatibility */
        for(i = 0; i < GSptr->dash_pattern.pat_size; i++){
            GSptr->dash_pattern.pattern[i] = pattern[i];
        }                                /* 12-8-90, compatibility */

        /*
         * Set up starting dash pattern in initdp struct
         * Initialize current dash pattern element :
         * dpat_index, dpat_offset, and dpat_on
         */
        /* Accumulate total length in pattern array */
        total_length = zero_f;
        for (i=0; i<GSptr->dash_pattern.pat_size; i++) {
                total_length +=
                GSptr->dash_pattern.pattern[i];
        }

        /*
         * Find starting point of pattern array
         */
        /* wrap around offset over pattern size */
/*      GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;*/
        if (GSptr->dash_pattern.offset >= 0)   /* -begin- */
            GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;
        else {                                 /* negative offset, 11-29-90 */
            for (GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;
                 GSptr->dash_pattern.dpat_offset < 0;
                 GSptr->dash_pattern.dpat_offset += total_length,
                 GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on);
        }                                      /* -end- */

        if (IS_NOTZERO(total_length)) {  /* only for non_empty pattern 5/26/89*/
                real32   wrap;
                fix     iwrap;

                if (GSptr->dash_pattern.dpat_offset >= total_length) {
                        wrap = (real32)(floor (GSptr->dash_pattern.dpat_offset /
                                              total_length));
                        if (wrap < (real32)65536.0)
                                iwrap = (fix) wrap;
                        else
                                iwrap = 0;
                        GSptr->dash_pattern.dpat_offset -= wrap * total_length;
                        if ((iwrap & 0x1) &&
                            (GSptr->dash_pattern.pat_size & 0x1))
                            GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on;
                            /* when numbers of pattern elements and wraps
                             * are odds, inverse the dpat_on flag @DASH
                             */
                } /* if */
        }

        for (i=0; i < GSptr->dash_pattern.pat_size; i++) {
                GSptr->dash_pattern.dpat_offset -=
                        GSptr->dash_pattern.pattern[i];
                if(GSptr->dash_pattern.dpat_offset <= zero_f){
                        GSptr->dash_pattern.dpat_offset +=
                                GSptr->dash_pattern.pattern[i];
                        break;
                }
                GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on;
        }
        GSptr->dash_pattern.dpat_index = (i >= GSptr->dash_pattern.pat_size) ?
                           0 : i;
}



/*
 * Initialize stroke parameters; called by stroke_shape(from op_stroke) and
 * op_strokepath
 */
#define CHANGE_WIDTH    1
#define CHANGE_MITER    2
#define CHANGE_FLAT     4
#define CHANGE_CTM      8

void init_stroke()
{
    real32      ctm_scale, tmp;         /* @EHS_STK */
    bool        change_flg = FALSE;
    fix         i;
    static real32 w2;           /* line_width ** 2 */
    real32      tmp0, tmp1;     /* @FABS */

    /* set parameters only circumstance has changed @STK_INFO */
    if (F2L(GSptr->line_width) != F2L(stk_info.width)) {
        stk_info.width = GSptr->line_width;
        change_flg |= CHANGE_WIDTH;     /* change_width = TRUE; */
    }
    if (F2L(GSptr->miter_limit) != F2L(stk_info.limit)) {
        stk_info.limit = GSptr->miter_limit;
        change_flg |= CHANGE_MITER;     /* change_miter = TRUE; */
    }
    if (F2L(GSptr->flatness) != F2L(stk_info.flatness)) {
        stk_info.flatness = GSptr->flatness;
        change_flg |= CHANGE_FLAT;      /* change_flat = TRUE; */
    }
    if ((F2L(GSptr->ctm[0]) != F2L(stk_info.ctm[0])) ||
        (F2L(GSptr->ctm[1]) != F2L(stk_info.ctm[1])) ||
        (F2L(GSptr->ctm[2]) != F2L(stk_info.ctm[2])) ||
        (F2L(GSptr->ctm[3]) != F2L(stk_info.ctm[3]))) {
        stk_info.ctm[0] = GSptr->ctm[0];
        stk_info.ctm[1] = GSptr->ctm[1];
        stk_info.ctm[2] = GSptr->ctm[2];
        stk_info.ctm[3] = GSptr->ctm[3];
        change_flg |= CHANGE_CTM;       /* change_ctm = TRUE; */
    }

    /* init dash pattern, 12-8-90, compatibility */
    init_dash_pattern();

    /* calculate flatness for stroke */
    if (change_flg & (CHANGE_WIDTH|CHANGE_FLAT|CHANGE_CTM)) {

        /* Calculate flatness of the curve which depends on the
         * linewidth.       (??? should be revised later)
         */
        ctm_scale = (real32)sqrt (GSptr->ctm[0] * GSptr->ctm[0] +
                                 GSptr->ctm[3] * GSptr->ctm[3]);
        /* tmp = (real32)(GSptr->line_width * ctm_scale); 1/10/90 */
        tmp = (real32)sqrt (GSptr->line_width * ctm_scale * 4);
        if (tmp <= one_f)
                /* stroke_flatness should not greater than flatness 3/11/88 */
                stk_info.flat = GSptr->flatness;        /* stroke_flat = */
        else
                stk_info.flat = GSptr->flatness / tmp;

        /* adjust flatness value */
        if( stk_info.flat < (real32)0.2 )        stk_info.flat = (real32)0.2;
        else if( stk_info.flat > (real32)100.  ) stk_info.flat = (real32)100.;
        stk_info.flat_l = F2LFX(stk_info.flat);       /* @FLT_CVE 12/19/88 */

        /* circle defined in curve[][] array cannont use for this stroke */
        stk_info.change_circle = TRUE;
        circle_flag = CIR_UNSET_CACHE;  /* circle not put in cache yet */
    }

    /* pre-set half of linewidth */
    if (change_flg & CHANGE_WIDTH) {
        stk_info.half_width = GSptr->line_width / 2;
        stk_info.half_width_i = F2SFX(stk_info.half_width);     /* @STK_INT */
        _clear87();    /* clear the status87 of last inst. 11/18/88 */

        w2 = (GSptr->line_width * GSptr->line_width) /4;
        stk_info.miter0 = w2 * (real32)0.9659258;       /* cos(15) */
    }

    /* calculate miter limit value */
    if (change_flg & (CHANGE_WIDTH|CHANGE_MITER)) {
        /* pre-calculate miter limit value  @EHS_JOIN
         *    miter_value = (2/(m*m) - 1) * w*w
         *    where, m: miter limit
         *           w: linewidth / 2
         */
        FABS(tmp0, GSptr->miter_limit);
        if (tmp0 < (real32)TOLERANCE)
             stk_info.miter = (real32)EMAXP;    /* @STK_INFO: miter_value */
        else
             stk_info.miter =  (2 / (GSptr->miter_limit * GSptr->miter_limit) - 1)
                          * w2;
    }

    /* set up inverse CTM[0:3], extracted from set_inverse_ctm(); @STK_INFO */
    if (change_flg & CHANGE_CTM) {
       set_inverse_ctm();   /* ???to be updated later, for deleting ctm[4:5] */
       for (i=0; i<4; i++) {                            /* @STK_INT */
               stroke_ctm[i] = (sfix_t)F2SFX12_T(GSptr->ctm[i]); //@WIN
       }
    }

    /* calculate expanding coord of line width 11/22/88 */
    if (change_flg & (CHANGE_WIDTH|CHANGE_CTM)) {
        FABS(tmp0, GSptr->ctm[0]);
        FABS(tmp1, GSptr->ctm[2]);
        stk_info.exp_widthx = stk_info.half_width * (tmp0 + tmp1);
        CHECK_INFINITY(stk_info.exp_widthx);    /* check inifinity 1/26/89 */
        FABS(tmp0, GSptr->ctm[1]);
        FABS(tmp1, GSptr->ctm[3]);
        stk_info.exp_widthy = stk_info.half_width * (tmp0 + tmp1);
        CHECK_INFINITY(stk_info.exp_widthy);    /* check inifinity 1/26/89 */
    }

    /* calculate max expanding coord of miter join 11/22/88 */
    if (change_flg & (CHANGE_WIDTH|CHANGE_CTM|CHANGE_MITER)) {
        stk_info.exp_miterx = GSptr->miter_limit * stk_info.exp_widthx;
        CHECK_INFINITY(stk_info.exp_miterx);    /* check inifinity 1/26/89 */
        stk_info.exp_mitery = GSptr->miter_limit * stk_info.exp_widthy;
        CHECK_INFINITY(stk_info.exp_mitery);    /* check inifinity 1/26/89 */
    }

    /* setup cache_info for circle cache @CIR_CACHE */
    if (circle_flag == CIR_IN_CACHE) {
        save_cache_info = cache_info;   /* save old cache_info */
        cache_info = &cir_cache_info;
    }

    /* clear the status87 for initialization 11/07/88 */
    _clear87();
}


/*
 * end of stroke; called by stroke_shape(from op_stroke)
 */
void end_stroke()
{
    /* restore cache_info */
    if (circle_flag == CIR_IN_CACHE) {
        cache_info = save_cache_info;
    }

}


/*
 * calculate the max expanding bounding box when performs stroking
 * called by stroke_shape(from op_stroke)
 */
void expand_stroke_box (bbox)
real32    FAR bbox[];
{
    /* add with the max expanding points of join points */
    bbox[0] -= stk_info.exp_miterx;
    bbox[1] -= stk_info.exp_mitery;
    bbox[2] += stk_info.exp_miterx;
    bbox[3] += stk_info.exp_mitery;
}


/***********************************************************************
 * This module is to create a dash_line of a line segment.
 *
 * TITLE:       linetour
 *
 * CALL:        linetour(dx0, dy0, dx1, dy1)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *
 * CALLS:       Inverse_transform
 *              Rectangle
 *              Linecap
 *
 * RETURN:
 *
 **********************************************************************/
static void near linetour (rect1)
struct line_seg FAR *rect1;     /*@WIN*/
{
    struct  line_seg rect2;
    real32       cx, cy, nx, ny; /* current and next point */
    real32       dx, dy;         /* for calculating distance btwn
                                  * (cx, cy) and (x1, y1) only
                                  */
    real32      w, d, tx, ty;
    bool        done;
    real32      tmp;    /* @FABS */
    bool        first_seg;               /* first line segment @CAP */

    /* if solid line just fill it */
    if (GSptr->dash_pattern.pat_size == 0) { /* solid line */
        /* create a polygon contains the
         * rectangle
         */
        paint_or_save (rect1->pgn);

        return;
    }


    dx = rect1->p1.x - rect1->p0.x;                 /* device space */
    dy = rect1->p1.y - rect1->p0.y;

    /* derive tx, ty from rect information 11/21/88
     * since,
     *      rect1->vct_u.x == (w0 * |uy|) / sqrt(ux*ux + uy*uy)
     *                                  (* ref. get_rect_points() *)
     * so,  w = sqrt(ux*ux + uy*uy)
     *        = (w0 * |uy|) / rect1->vct_u.x
     * or,    = |ux| (when rect1->vct_u.x == 0)
     * where, w0 = half of line width
     */

    FABS(tmp, rect1->vct_u.x);
    if (tmp < (real32)1e-3) {
        if (IS_ZERO(rect1->vct_d.y) && IS_ZERO(rect1->vct_d.x)) { /* 5/26/89 */
            /* for thin line, need to compute the actual length under user space
             * scince rect1->vct_u.x is always zero     (* 1/5/89 *)
             */
            real32 ux, uy;
            ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
            w = (real32)sqrt(ux*ux + uy*uy);
        } else {
            w = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            FABS(w, w);
        }
    } else {
        w = (dx * inverse_ctm[1] + dy * inverse_ctm[3]) *
            stk_info.half_width / rect1->vct_u.x;
        FABS(w, w);
    }

    tx = dx / w;        /* vector of advancing a user unit */
    ty = dy / w;

    cx = rect1->p0.x;
    cy = rect1->p0.y;
    rect2.vct_d = rect1->vct_d;
    rect2.vct_u = rect1->vct_u;

    /* add an error tolerance to length of line segment 10/20/88 */
    w = w + (real32)1e-3;               /* For case:
                                 * [10 5] 5 setdash
                                 * 480 650 moveto
                                 * 10 0 rlineto
                                 * stroke
                                 */
    done = FALSE;
    first_seg = TRUE;   /* for SQUARE_CAP & ROUND_CAP @CAP */

    while (1) {
        d = GSptr->dash_pattern.pattern[actdp.dpat_index] - actdp.dpat_offset;
        if (d > w) {
            d = w;
            done = TRUE;
        }

        nx = cx + tx * d;
        ny = cy + ty * d;

        if (actdp.dpat_on) {
                /* set current rectangle information */
                if (GSptr->line_cap == SQUARE_CAP) {
                        /* expand rectangle for square cap @CAP */
                        real32  x0, y0, x1, y1, tmpx, tmpy;

                        /* offset of expansion */
                        tmpx = tx * stk_info.half_width;
                        tmpy = ty * stk_info.half_width;

                        /* not expand line segment at start point */
                        if (first_seg) {
                            x0 = cx;
                            y0 = cy;
                        } else {
                            x0 = cx - tmpx;
                            y0 = cy - tmpy;
                        }

                        /* not expand line segment at end point */
                        if (done) {
                            x1 = nx;
                            y1 = ny;
                        } else {
                            x1 = nx + tmpx;
                            y1 = ny + tmpy;
                        }

                        rect2.p0.x = x0;
                        rect2.p0.y = y0;
                        rect2.p1.x = x1;
                        rect2.p1.y = y1;

                        rect2.pgn[0].x = x0 + rect1->vct_d.x;
                        rect2.pgn[0].y = y0 + rect1->vct_d.y;
                        rect2.pgn[1].x = x0 - rect1->vct_d.x;
                        rect2.pgn[1].y = y0 - rect1->vct_d.y;
                        rect2.pgn[2].x = x1 - rect1->vct_d.x;
                        rect2.pgn[2].y = y1 - rect1->vct_d.y;
                        rect2.pgn[3].x = x1 + rect1->vct_d.x;
                        rect2.pgn[3].y = y1 + rect1->vct_d.y;

                } else {        /* for BUTT & ROUND cap */
                        rect2.p0.x = cx;
                        rect2.p0.y = cy;
                        rect2.p1.x = nx;
                        rect2.p1.y = ny;

                        rect2.pgn[0].x = cx + rect1->vct_d.x;
                        rect2.pgn[0].y = cy + rect1->vct_d.y;
                        rect2.pgn[1].x = cx - rect1->vct_d.x;
                        rect2.pgn[1].y = cy - rect1->vct_d.y;
                        rect2.pgn[2].x = nx - rect1->vct_d.x;
                        rect2.pgn[2].y = ny - rect1->vct_d.y;
                        rect2.pgn[3].x = nx + rect1->vct_d.x;
                        rect2.pgn[3].y = ny + rect1->vct_d.y;
                }

                /* put a circle at start point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!first_seg)) {
                        /* no circle cap at start point @WIN*/
                        linecap ((struct line_seg FAR *)&rect2, START_POINT);
                }

                /* create a rectangle covers (cx, cy) -> (nx, ny) @CAP */
                paint_or_save ((struct coord FAR *)rect2.pgn);  /*@WIN*/

                /* put a circle at end point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!done)) {
                        /* no circle cap at end point @WIN*/
                        linecap ((struct line_seg FAR *)&rect2, END_POINT);
                }

        }

        /* Update next pattern element */
        if (done) {
            actdp.dpat_offset += w;    /* this line segment took more w units */
            break;
        } else {
            actdp.dpat_offset = zero_f;
            actdp.dpat_on = ! actdp.dpat_on;
            actdp.dpat_index++;
            if (actdp.dpat_index >= GSptr->dash_pattern.pat_size)
                    actdp.dpat_index = 0;
        }

        cx = nx;
        cy = ny;
        w -= d;
        first_seg = FALSE;              /* @CAP */
    } /* while */

}


/*
 * Integer operation version
 */
static void near linetour_i (rect1)
struct line_seg_i FAR *rect1;           /*@WIN*/
{
    struct  line_seg_i rect2;                   /* @STK_INT */
    real32       cx, cy, nx, ny; /* current and next point, @STK_INT */
    sfix_t       cx_i, cy_i, nx_i, ny_i;        /* SFX format */

    fix32        dx, dy;         /* for calculating distance btwn @STK_INT
                                  * (cx, cy) and (x1, y1) only
                                  */
    real32   w, d, tx, ty;
    bool        done;
    real32      tmp;    /* @FABS */
    bool        first_seg;               /* first line segment @CAP */

    /* if solid line just fill it */
    if (GSptr->dash_pattern.pat_size == 0) { /* solid line */
        /* create a polygon contains the
         * rectangle
         */
        paint_or_save_i (rect1->pgn);

        return;
    }

    dx = (fix32)rect1->p1.x - rect1->p0.x;              /* @STK_INT */
    dy = (fix32)rect1->p1.y - rect1->p0.y;

    /* derive tx, ty from rect information 11/21/88
     * since,
     *      rect1->vct_u.x == (w0 * |uy|) / sqrt(ux*ux + uy*uy)
     *                                  (* ref. get_rect_points() *)
     * so,  w = sqrt(ux*ux + uy*uy)
     *        = (w0 * |uy|) / rect1->vct_u.x
     * or,    = |ux| (when rect1->vct_u.x == 0)
     * where, w0 = half of line width
     */

    FABS(tmp, rect1->vct_u.x);
    if (tmp < (real32)1e-3) {

        if ((rect1->vct_d.y == 0) && (rect1->vct_d.x == 0)) {
            /* for thin line, need to compute the actual length under user space
             * scince rect1->vct_u.x is always zero     (* 1/5/89 *)
             */
            real32 ux, uy;
            ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
            w = (real32)sqrt(ux*ux + uy*uy) / ONE_SFX;
        } else {
            w = (dx * inverse_ctm[0] + dy * inverse_ctm[2]) / ONE_SFX;
            FABS(w, w);
        }
    } else {
        w = ((dx * inverse_ctm[1] + dy * inverse_ctm[3]) *
             stk_info.half_width / rect1->vct_u.x) / ONE_SFX;
        FABS(w, w);
    }

    tx = dx / w;        /* vector of advancing a user unit */
    ty = dy / w;

    cx = (real32)rect1->p0.x;
    cy = (real32)rect1->p0.y;
    rect2.vct_d = rect1->vct_d;
    rect2.vct_u = rect1->vct_u;

    /* add an error tolerance to length of line segment 10/20/88 */
    w = w + (real32)1e-3;               /* For case:
                                 * [10 5] 5 setdash
                                 * 480 650 moveto
                                 * 10 0 rlineto
                                 * stroke
                                 */
    done = FALSE;
    first_seg = TRUE;   /* for SQUARE_CAP & ROUND_CAP @CAP */

    while (1) {
        d = GSptr->dash_pattern.pattern[actdp.dpat_index] - actdp.dpat_offset;
        if (d > w) {
            d = w;
            done = TRUE;
        }

        nx = cx + tx * d;
        ny = cy + ty * d;

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif

        cx_i = (sfix_t)cx;      /* SFX format */
        cy_i = (sfix_t)cy;
        nx_i = (sfix_t)nx;
        ny_i = (sfix_t)ny;

        if (actdp.dpat_on) {
                /* set current rectangle information */
                if (GSptr->line_cap == SQUARE_CAP) {
                        /* expand rectangle for square cap @CAP */
                        sfix_t  x0, y0, x1, y1, tmpx, tmpy;

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif
                        /* offset of expansion */
                        tmpx = (sfix_t)(tx * stk_info.half_width);
                        tmpy = (sfix_t)(ty * stk_info.half_width);

                        /* not expand line segment at start point */
                        if (first_seg) {
                            x0 = cx_i;
                            y0 = cy_i;
                        } else {
                            x0 = cx_i - tmpx;
                            y0 = cy_i - tmpy;
                        }

                        /* not expand line segment at end point */
                        if (done) {
                            x1 = nx_i;
                            y1 = ny_i;
                        } else {
                            x1 = nx_i + tmpx;
                            y1 = ny_i + tmpy;
                        }

                        rect2.p0.x = x0;
                        rect2.p0.y = y0;
                        rect2.p1.x = x1;
                        rect2.p1.y = y1;

                        rect2.pgn[0].x = x0 + rect1->vct_d.x;
                        rect2.pgn[0].y = y0 + rect1->vct_d.y;
                        rect2.pgn[1].x = x0 - rect1->vct_d.x;
                        rect2.pgn[1].y = y0 - rect1->vct_d.y;
                        rect2.pgn[2].x = x1 - rect1->vct_d.x;
                        rect2.pgn[2].y = y1 - rect1->vct_d.y;
                        rect2.pgn[3].x = x1 + rect1->vct_d.x;
                        rect2.pgn[3].y = y1 + rect1->vct_d.y;

                } else {        /* for BUTT & ROUND cap */
                        rect2.p0.x = cx_i;
                        rect2.p0.y = cy_i;
                        rect2.p1.x = nx_i;
                        rect2.p1.y = ny_i;

                        rect2.pgn[0].x = cx_i + rect1->vct_d.x;
                        rect2.pgn[0].y = cy_i + rect1->vct_d.y;
                        rect2.pgn[1].x = cx_i - rect1->vct_d.x;
                        rect2.pgn[1].y = cy_i - rect1->vct_d.y;
                        rect2.pgn[2].x = nx_i - rect1->vct_d.x;
                        rect2.pgn[2].y = ny_i - rect1->vct_d.y;
                        rect2.pgn[3].x = nx_i + rect1->vct_d.x;
                        rect2.pgn[3].y = ny_i + rect1->vct_d.y;
                }

                /* put a circle at start point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!first_seg)) {
                    /* no circle cap at start point @WIN*/
                    linecap_i ((struct  line_seg_i FAR *)&rect2, START_POINT);
                }

                /* create a rectangle covers (cx_i, cy_i) -> (nx_i, ny_i) @CAP*/
                paint_or_save_i ((struct coord_i FAR *)rect2.pgn);

                /* put a circle at end point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!done)) {
                    /* no circle cap at end point @WIN*/
                    linecap_i ((struct line_seg_i FAR *)&rect2, END_POINT);
                }

        }

        /* Update next pattern element */
        if (done) {
            actdp.dpat_offset += w;    /* this line segment took more w units */
            break;
        } else {
            actdp.dpat_offset = zero_f;
            actdp.dpat_on = ! actdp.dpat_on;
            actdp.dpat_index++;
            if (actdp.dpat_index >= GSptr->dash_pattern.pat_size)
                    actdp.dpat_index = 0;
        }

        cx = nx;
        cy = ny;
        w -= d;
        first_seg = FALSE;              /* @CAP */
    } /* while */

}




/***********************************************************************
 * Given 3 points (dx0, dy0), (dx1, dy1), and (dx2, dy2), this module
 * creates a appropriate path at the corner(dx1, dy1).
 *
 * TITLE:       linejoin
 *
 * CALL:        linejoin(dx0, dy0, dx1, dy1, dx2, dy2)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *
 * CALLS:       transform, inverse_transform, endpoint, arc,
 *              shape_approximation, shape_reduction, convex_clipper
 *
 * RETURN:
 **********************************************************************/
static void near linejoin (rect0, rect1)
struct  line_seg FAR *rect0, FAR *rect1;        /*@WIN*/
{
        real32 px0, py0, px1, py1, px2, py2;
        real32 miter;

        real32 sx0, sy0, sx1, sy1;
        real32 delta_x1, delta_y1, delta_x2, delta_y2;
        real32 delta_topx, delta_topy, divider, s;

        struct coord pgn[4];

        real32   dot_product;            /* @DOT_PRO */
        fix     select;                 /* @DOT_PRO */
        real32  tmp1, tmp2;

        /* Check if null line join,
         * i.e. the last line segment is a gap
         */
        if (GSptr->dash_pattern.pat_size != 0) {
                /* not for solid line */

               if(IS_ZERO(actdp.dpat_offset)) {         /* 5/26/89 */
                       /* actdp.dpat_on is for next line segment, so
                        * its inverse is ones for last line segment
                        */
                       if(actdp.dpat_on) return;

                               /* i.e. if (!(!actdp.doat_on)) return;*/
               } else {
                       if(!actdp.dpat_on) return;
               }
        }

        /* initialization for miter and bevel joins */
        if (GSptr->line_join != ROUND_JOIN) {   /* miter or bevel join */

                /* determine the lines of rect0, and rect1 to calculate join
                 * point for bevel and miter joins            @DOT_PRO
                 */
                dot_product = (rect0->p1.x - rect0->p0.x) *     /* 10/4/88 */
                              (rect1->p1.y - rect1->p0.y) -
                              (rect0->p1.y - rect0->p0.y) *
                              (rect1->p1.x - rect1->p0.x);
                /*select = (dot_product < zero_f) ? LINE03 : LINE12; 3/20/91 */
                select = (SIGN_F(dot_product)) ? LINE03 : LINE12;
        }

        /* Create line joint due to the type of current_linejoin */
        switch (GSptr->line_join) {

        case ROUND_JOIN :    /* for round linejoin */

                round_point(F2L(rect0->p1.x), F2L(rect0->p1.y));

                break;

        case BEVEL_JOIN :    /* for bevel linejoin */

                if (select == LINE03) {
                        pgn[0] = rect0->pgn[3];
                        pgn[1] = pgn[2] = rect0->p1;
                        pgn[3] = rect1->pgn[0];

                } else {        /* select == LINE12 */
                        pgn[0] = rect0->pgn[2];
                        pgn[1] = rect1->pgn[1];
                        pgn[2] = pgn[3] = rect0->p1;
                }

                /* Fill the outline or save it */
                paint_or_save ((struct coord FAR *)pgn);
                break;

        case MITER_JOIN :
                /* Find end points of edge1, edge2:
                 * edge1: (sx0, sy0) --> (px0, py0)
                 * edge2: (sx1, sy1) --> (px1, py1)
                 */
                if (select == LINE03) {
                        sx0 = rect0->pgn[0].x;
                        sy0 = rect0->pgn[0].y;
                        px0 = rect0->pgn[3].x;
                        py0 = rect0->pgn[3].y;
                        px1 = rect1->pgn[0].x;
                        py1 = rect1->pgn[0].y;
                        sx1 = rect1->pgn[3].x;
                        sy1 = rect1->pgn[3].y;
                } else {        /* select == LINE12 */
                        sx0 = rect0->pgn[1].x;
                        sy0 = rect0->pgn[1].y;
                        px0 = rect0->pgn[2].x;
                        py0 = rect0->pgn[2].y;
                        px1 = rect1->pgn[1].x;
                        py1 = rect1->pgn[1].y;
                        sx1 = rect1->pgn[2].x;
                        sy1 = rect1->pgn[2].y;
                }

                /* check if join point is too small 8/24/88 */
                tmp1 = rect0->vct_d.x - rect1->vct_d.x;     /* 10/5/88 */
                tmp2 = rect0->vct_d.y - rect1->vct_d.y;
                if ((EXP(F2L(tmp1)) < 0x3f800000L) &&
                    (EXP(F2L(tmp2)) < 0x3f800000L)) goto bevel_miter;

                /* Check if the expanded segment is too sharp @EHS_JOIN */
                /* if  dot(a, b) < stk_info.miter
                 *      where a = rect0->vct_u          (* (px0-x1, py0-y1) *)
                 *            b = rect1->vct_u          (* (px1-x1, py1-y1) *)
                 */
                miter = rect0->vct_u.x * rect1->vct_u.x +
                        rect0->vct_u.y * rect1->vct_u.y;

                if ((miter < stk_info.miter) || (miter > stk_info.miter0)) {
                        /* Create a bevel triangle polygon contains
                         * (dx1, dy1), (px0, py0)', and (px1, py1)'.
                         */
bevel_miter:
                        pgn[0].x = px0;
                        pgn[0].y = py0;

                        if(select == LINE03) {
                                pgn[1] = pgn[2] = rect0->p1;
                                pgn[3].x = px1;
                                pgn[3].y = py1;
                        }
                        else{   /* select == LINE12 */
                                pgn[1].x = px1;
                                pgn[1].y = py1;
                                pgn[2] = pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it */
                        paint_or_save ((struct coord FAR *)pgn);

                } else { /* miter join */

                        /* Find the third point(px2, py2) */
                        /*
                         * Find cross point of edge1 and
                         * edge2 using parametric formula:
                         * edge1 = u + s * delta_u
                         * edge2 = v + t * delta_v
                         */
                        delta_x1 = px0 - sx0;
                        delta_y1 = py0 - sy0;
                        delta_x2 = px1 - sx1;
                        delta_y2 = py1 - sy1;
                        delta_topx = sx0 - sx1;
                        delta_topy = sy0 - sy1;
                        divider = delta_x1 * delta_y2 - delta_x2 *
                                  delta_y1;

                        /* Collinear edges */
                        FABS(tmp1, divider);
                        if(tmp1 < (real32)1e-3) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;       /* 10/30/87 */
                        } else {

                                /* Solved parameters */
                                s = ((delta_x2 * delta_topy) -
                                      (delta_y2 * delta_topx) ) / divider;
                                if (EXP(F2L(s)) < 0x3f800000L) {   /* s < 1.0 */
#ifdef DBGwarn
                                        printf("\07Linejoin(), s <= 1\n");
#endif
                                        goto bevel_miter;       /* 02/29/88 */
                                }

                                px2 = sx0 + s * delta_x1;
                                py2 = sy0 + s * delta_y1;
                        }

                        /* Create a miter rectangle subpath */
                        pgn[0].x = px0;
                        pgn[0].y = py0;
                        pgn[2].x = px1;
                        pgn[2].y = py1;
                        if(select == LINE03) {
                                pgn[1] = rect0->p1;
                                pgn[3].x = px2;
                                pgn[3].y = py2;
                        } else {   /* select == LINE12 */
                                pgn[1].x = px2;
                                pgn[1].y = py2;
                                pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save ((struct coord FAR *)pgn);
                } /* if miter */
        } /* switch */
}


/*
 * Integer operation version
 */
static void near linejoin_i (rect0, rect1)
struct  line_seg_i FAR *rect0, FAR *rect1;      /*@WIN*/
{
        sfix_t px0, py0, px1, py1, px2, py2;                    /* @STK_INT */
        real32 miter;

        sfix_t sx0, sy0, sx1, sy1;                    /* @STK_INT */
        fix32  delta_x1, delta_y1, delta_x2, delta_y2;          /* @STK_INT */
        fix32  delta_topx, delta_topy;                          /* @STK_INT */
        real32 s;                                               /* @STK_INT */

        struct coord_i pgn[4];                                  /* @STK_INT */

        fix32    dot_product;                                   /* @STK_INT */
        fix     select;                 /* @DOT_PRO */
/*      real32  tmp;                                               @STK_INT */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32 divider;
#elif  FORMAT_16_16
        long dest1[2], dest2[2];
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 divider, dividend;

        long temp1[2], temp2[2];
        real32 temp1_f, temp2_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2];
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 divider, dividend;

        long temp1[2], temp2[2];
        real32 temp1_f, temp2_f;
#endif
        /* Check if null line join,
         * i.e. the last line segment is a gap
         */
        if (GSptr->dash_pattern.pat_size != 0) {
                /* not for solid line */

               if(IS_ZERO(actdp.dpat_offset)) {         /* 5/26/89 */
                       /* actdp.dpat_on is for next line segment, so
                        * its inverse is ones for last line segment
                        */
                       if(actdp.dpat_on) return;

                               /* i.e. if (!(!actdp.doat_on)) return;*/
               } else {
                       if(!actdp.dpat_on) return;
               }
        }

        /* initialization for miter and bevel joins */
        if (GSptr->line_join != ROUND_JOIN) {   /* miter or bevel join */

                /* determine the lines of rect0, and rect1 to calculate join
                 * point for bevel and miter joins            @DOT_PRO
                 */
                /* dot_product = ((fix32)rect0->p1.x - rect0->p0.x) *  |* 10/4/88 *|
                              ((fix32)rect1->p1.y - rect1->p0.y) -
                              ((fix32)rect0->p1.y - rect0->p0.y) *
                              ((fix32)rect1->p1.x - rect1->p0.x);
                */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                dot_product = ((fix32)rect0->p1.x - rect0->p0.x) *
                              ((fix32)rect1->p1.y - rect1->p0.y) -
                              ((fix32)rect0->p1.y - rect0->p0.y) *
                              ((fix32)rect1->p1.x - rect1->p0.x);
                select = (dot_product < 0) ? LINE03 : LINE12;   /* @STK_INT */
#elif  FORMAT_16_16
                LongFixsMul((rect0->p1.x - rect0->p0.x),
                            (rect1->p1.y - rect1->p0.y), dest1);
                LongFixsMul((rect0->p1.y - rect0->p0.y),
                            (rect1->p1.x - rect1->p0.x), dest2);

                LongFixsSub(dest1, dest2, temp1);

                if (temp1[0] < 0)
                        select = LINE03;
                else
                        select = LINE12;
#elif  FORMAT_28_4
                LongFixsMul((rect0->p1.x - rect0->p0.x),
                            (rect1->p1.y - rect1->p0.y), dest1);
                LongFixsMul((rect0->p1.y - rect0->p0.y),
                            (rect1->p1.x - rect1->p0.x), dest2);

                LongFixsSub(dest1, dest2, temp1);

                if (temp1[0] < 0)
                        select = LINE03;
                else
                        select = LINE12;
#endif
        }

        /* Create line joint due to the type of current_linejoin */
        switch (GSptr->line_join) {
        real32 tx, ty;

        case ROUND_JOIN :    /* for round linejoin */

                tx = SFX2F(rect0->p1.x);               /* @CIR_CACHE */
                ty = SFX2F(rect0->p1.y);
                round_point(F2L(tx), F2L(ty));

                break;

        case BEVEL_JOIN :    /* for bevel linejoin */

                if (select == LINE03) {
                        pgn[0] = rect0->pgn[3];
                        pgn[1] = pgn[2] = rect0->p1;
                        pgn[3] = rect1->pgn[0];

                } else {        /* select == LINE12 */
                        pgn[0] = rect0->pgn[2];
                        pgn[1] = rect1->pgn[1];
                        pgn[2] = pgn[3] = rect0->p1;
                }

                /* Fill the outline or save it @WIN*/
                paint_or_save_i ((struct coord_i FAR *)pgn);
                break;

        case MITER_JOIN :
                /* Find end points of edge1, edge2:
                 * edge1: (sx0, sy0) --> (px0, py0)
                 * edge2: (sx1, sy1) --> (px1, py1)
                 */
                if (select == LINE03) {
                        sx0 = rect0->pgn[0].x;
                        sy0 = rect0->pgn[0].y;
                        px0 = rect0->pgn[3].x;
                        py0 = rect0->pgn[3].y;
                        px1 = rect1->pgn[0].x;
                        py1 = rect1->pgn[0].y;
                        sx1 = rect1->pgn[3].x;
                        sy1 = rect1->pgn[3].y;
                } else {        /* select == LINE12 */
                        sx0 = rect0->pgn[1].x;
                        sy0 = rect0->pgn[1].y;
                        px0 = rect0->pgn[2].x;
                        py0 = rect0->pgn[2].y;
                        px1 = rect1->pgn[1].x;
                        py1 = rect1->pgn[1].y;
                        sx1 = rect1->pgn[2].x;
                        sy1 = rect1->pgn[2].y;
                }
#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif

                /* check if join point is too small 8/24/88 */
                if ((ABS(rect0->vct_d.x - rect1->vct_d.x) < ONE_SFX) &&
                    (ABS(rect0->vct_d.y - rect1->vct_d.y) < ONE_SFX))
                        goto bevel_miter;
                                        /* ONE_SFX: 1 unit in SFX @STK_INT */

                /* Check if the expanded segment is too sharp @EHS_JOIN */
                /* if  dot(a, b) < stk_info.miter
                 *      where a = rect0->vct_u          (* (px0-x1, py0-y1) *)
                 *            b = rect1->vct_u          (* (px1-x1, py1-y1) *)
                 */
                miter = rect0->vct_u.x * rect1->vct_u.x +
                        rect0->vct_u.y * rect1->vct_u.y;

                if ((miter < stk_info.miter) || (miter > stk_info.miter0)) {
                        /* Create a bevel triangle polygon contains
                         * (dx1, dy1), (px0, py0)', and (px1, py1)'.
                         */
bevel_miter:
                        pgn[0].x = px0;
                        pgn[0].y = py0;

                        if(select == LINE03) {
                                pgn[1] = pgn[2] = rect0->p1;
                                pgn[3].x = px1;
                                pgn[3].y = py1;
                        }
                        else{   /* select == LINE12 */
                                pgn[1].x = px1;
                                pgn[1].y = py1;
                                pgn[2] = pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save_i ((struct coord_i FAR *)pgn);

                } else { /* miter join */

                        /* Find the third point(px2, py2) */
                        /*
                         * Find cross point of edge1 and
                         * edge2 using parametric formula:
                         * edge1 = u + s * delta_u
                         * edge2 = v + t * delta_v
                         */
                        delta_x1 = (fix32)px0 - sx0;            /* @STK_INT */
                        delta_y1 = (fix32)py0 - sy0;            /* @STK_INT */
                        delta_x2 = (fix32)px1 - sx1;            /* @STK_INT */
                        delta_y2 = (fix32)py1 - sy1;            /* @STK_INT */
                        delta_topx = (fix32)sx0 - sx1;          /* @STK_INT */
                        delta_topy = (fix32)sy0 - sy1;          /* @STK_INT */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = delta_x1 * delta_y2 - delta_x2 *
                                  delta_y1;                     /* @STK_INT */

                        /* Collinear edges */
                        if(divider == 0) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;       /* 10/30/87 */
                        } else {

                                /* Solved parameters */
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                                                /* @STK_INT */
                                if (EXP(F2L(s)) < 0x3f800000L) {   /* s < 1.0 */

                                        goto bevel_miter;       /* 02/29/88 */
                                }
#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif

                                /* px2 = sx0 + (sfix_t)(s * delta_x1);
                                 * py2 = sy0 + (sfix_t)(s * delta_y1);
                                 *    (fixing short_fixed overflow bugs 4/6/90)
                                 */
                                px2 = (sfix_t)(sx0 + (lfix_t)(s * delta_x1));//@WIN
                                py2 = (sfix_t)(sy0 + (lfix_t)(s * delta_y1));//@WIN
                        }
#elif  FORMAT_16_16
                        LongFixsMul(delta_x1, delta_y2, dest3);
                        LongFixsMul(delta_x2, delta_y1, dest4);
                        if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;
                        }
                        else {
                                /* Solved parameters
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                */
                                LongFixsMul(delta_x2, delta_topy, dest5);
                                LongFixsMul(delta_y2, delta_topx, dest6);

                                LongFixsSub(dest5, dest6, temp1);
                                LongFixsSub(dest3, dest4, temp2);

                                change_to_real(temp1, &temp1_f);
                                change_to_real(temp2, &temp2_f);

                                if (LABS(temp1_f) < LABS(temp2_f))
                                        goto bevel_miter;

#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif

                                s = temp1_f / temp2_f;
                                px2 = sx0 + (lfix_t)(s * delta_x1); /*@STK_INT*/
                                py2 = sy0 + (lfix_t)(s * delta_y1); /*@STK_INT*/
                        }
#elif  FORMAT_28_4
                        LongFixsMul(delta_x1, delta_y2, dest3);
                        LongFixsMul(delta_x2, delta_y1, dest4);
                        if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;
                        }
                        else {
                                /* Solved parameters
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                */
                                LongFixsMul(delta_x2, delta_topy, dest5);
                                LongFixsMul(delta_y2, delta_topx, dest6);

                                LongFixsSub(dest5, dest6, temp1);
                                LongFixsSub(dest3, dest4, temp2);

                                change_to_real(temp1, &temp1_f);
                                change_to_real(temp2, &temp2_f);

                                if (LABS(temp1_f) < LABS(temp2_f))
                                        goto bevel_miter;

#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif
                                s = temp1_f / temp2_f;
                                px2 = sx0 + (lfix_t)(s * delta_x1); /*@STK_INT*/
                                py2 = sy0 + (lfix_t)(s * delta_y1); /*@STK_INT*/
                        }
#endif

                        /* Create a miter rectangle subpath */
                        pgn[0].x = px0;
                        pgn[0].y = py0;
                        pgn[2].x = px1;
                        pgn[2].y = py1;
                        if(select == LINE03) {
                                pgn[1] = rect0->p1;
                                pgn[3].x = px2;
                                pgn[3].y = py2;
                        } else {   /* select == LINE12 */
                                pgn[1].x = px2;
                                pgn[1].y = py2;
                                pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save_i ((struct coord_i FAR *)pgn);
                } /* if miter */
        } /* switch */
}


/***********************************************************************
 * Given a line segment whose 2 end points are (dx1, dy1) and (dx2, dy2)
 * respectively, this module creates an rectangle that expands at point
 * (dx2, dy2).
 *
 * TITLE:       linecap
 *
 * CALL:        linecap(dx1, dy1, dx2, dy2)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *              Linetour
 *
 * CALLS:       Inverse_transform
 *              Rectangle
 *              Arc
 *              Shape_approximation
 *              Shape_painting
 *              Convex_clipper
 *              Filler
 *
 * RETURN:
 *
 **********************************************************************/
static void near linecap (rect1, select)
struct  line_seg FAR *rect1;    /*@WIN*/
fix     select;
{
        real32 x1, y1, x2, y2, dx, dy, nx, ny, t;
        struct coord pgn[4];
        real32 ux, uy;
        real32 abs;     /* @FABS */

        /* ignore butt linecap */
        if (GSptr->line_cap == BUTT_CAP) return;

        /* ignore linecap for too small line width */
        if (GSptr->line_width < (real32)1e-3) return;

        /* get endpoint */
        if (select == END_POINT) {
                x1 = rect1->p0.x;
                y1 = rect1->p0.y;
                x2 = rect1->p1.x;
                y2 = rect1->p1.y;
        } else {
                x1 = rect1->p1.x;
                y1 = rect1->p1.y;
                x2 = rect1->p0.x;
                y2 = rect1->p0.y;
        }
                /* create linecap at point (x2, y2) */

        /* Create line cap due to the type of current_linecap */
        switch (GSptr->line_cap) {

        case ROUND_CAP :    /* for round linecap, ROUND = 1 */
                round_point(F2L(x2), F2L(y2));
                break;

        case SQUARE_CAP :   /* for square linecap, SQUARE = 2 */
                dx = x2 - x1;
                dy = y2 - y1;
                /* derive t from rect information 9/8/88 */
                uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
                FABS(abs, uy);
                if (abs < (real32)1e-3) {
                        ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
                        t = stk_info.half_width / ux;
                        FABS(t, t);
                        t += one_f;
                } else {
                        t = rect1->vct_u.x / uy;
                        FABS(t, t);
                        t += one_f;
                }

                /* create a rectangle covers (x2, y2) -> (x1+t*dx, y1+t*dy) */
                nx = x1 + t * dx;
                ny = y1 + t * dy;
                if (select == END_POINT) {
                        ux = rect1->vct_d.x;  /* unit vector of countour points */
                        uy = rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[3].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[3].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[2].x;
                        pgn[1].y = rect1->pgn[2].y;
                } else {
                        ux = -rect1->vct_d.x;
                        uy = -rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[1].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[1].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[0].x;
                        pgn[1].y = rect1->pgn[0].y;
                }
                pgn[2].x = nx - ux;
                pgn[2].y = ny - uy;
                pgn[3].x = nx + ux;
                pgn[3].y = ny + uy;
                paint_or_save ((struct coord FAR *)pgn); /*@WIN*/

                break;
        }
}


/*
 * Integer operation version
 */
static void near linecap_i (rect1, select)
struct  line_seg_i FAR *rect1;          /*@WIN*/
fix     select;
{
        sfix_t x1, y1, x2, y2, nx, ny, ux, uy;          /* @STK_INT */
        fix32  dx, dy;                                  /* @STK_INT */
        real32 t;                                       /* @STK_INT */
        struct coord_i pgn[4];                          /* @STK_INT */
        real32 tmp;

        /* ignore butt linecap */
        if (GSptr->line_cap == BUTT_CAP) return;

        /* ignore linecap for too small line width */
        if (GSptr->line_width < (real32)1e-3) return;

        /* get endpoint */
        if (select == END_POINT) {
                x1 = rect1->p0.x;
                y1 = rect1->p0.y;
                x2 = rect1->p1.x;
                y2 = rect1->p1.y;
        } else {
                x1 = rect1->p1.x;
                y1 = rect1->p1.y;
                x2 = rect1->p0.x;
                y2 = rect1->p0.y;
        }
                /* create linecap at point (x2, y2) */

        /* Create line cap due to the type of current_linecap */
        switch (GSptr->line_cap) {
        real32 tx, ty;

        case ROUND_CAP :    /* for round linecap, ROUND = 1 */
                tx = SFX2F(x2);                        /* @CIR_CACHE */
                ty = SFX2F(y2);
                round_point(F2L(tx), F2L(ty));
                break;

        case SQUARE_CAP :   /* for square linecap, SQUARE = 2 */
                dx = (fix32)x2 - x1;            /* @STK_INT */
                dy = (fix32)y2 - y1;            /* @STK_INT */
                /* derive t from rect information 9/8/88 */
                tmp = dx * inverse_ctm[1] + dy * inverse_ctm[3];
                FABS(tmp, tmp);
                /* if (tmp < (real32)1e-3) {
                 *                dx, dy in SFX format(multiplied by 8),
                 *                so tolrence should also be *8 for consistency
                 *                with floating version 1/27/89
                 */
                /* if (tmp < (real32)8e-3) { */
                if (tmp < ((real32)1e-3 * (real32)ONE_SFX)) {  /* @RESO_UPGR */
                        tmp = dx * inverse_ctm[0] + dy * inverse_ctm[2];
                        FABS(tmp, tmp);
                        t = one_f + (stk_info.half_width / tmp) * ONE_SFX;
                } else {
                        t = (rect1->vct_u.x / tmp) * ONE_SFX;
                        FABS(t, t);
                        t += one_f;
                }

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif
                /* create a rectangle covers (x2, y2) -> (x1+t*dx, y1+t*dy) */
                nx = x1 + (sfix_t)(t * dx);             /* @STK_INT */
                ny = y1 + (sfix_t)(t * dy);
                if (select == END_POINT) {
                        ux = rect1->vct_d.x;  /* unit vector of countour points */
                        uy = rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[3].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[3].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[2].x;
                        pgn[1].y = rect1->pgn[2].y;
                } else {
                        ux = -rect1->vct_d.x;
                        uy = -rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[1].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[1].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[0].x;
                        pgn[1].y = rect1->pgn[0].y;
                }
                pgn[2].x = nx - ux;
                pgn[2].y = ny - uy;
                pgn[3].x = nx + ux;
                pgn[3].y = ny + uy;
                paint_or_save_i ((struct coord_i FAR *)pgn);    /*@WIN*/

                break;
        }
}


static void near get_rect_points (rect1)
struct line_seg FAR *rect1;     /*@WIN*/
{
        real32   m, c, mc;
        bool16   horiz_line;
        real32   dx, dy, ux, uy, tmp;
        real32   abs;   /* @FABS */

        /* Compute 4 endpoints of the rectangle */

        /*
         * compute delta-vector in user space
         * delta-vector = (c, mc)
         * m = (u0x - u1x) / (u1y - u0y)
         *   = ((a*x0 + c*y0 + e) - (a*x1 + c*y1 + e)) /
         *     ((b*x1 + d*y1 + f) - (b*x0 + d*y0 + f))
         *   = (a * (x0-x1) + c * (y0-y1)) /
         *     (b * (x1-x0) + d * (y1-y0))
         *
         * where, (ux0, uy0) in user space = (x0, y0) in device space
         *        inverse_ctm = [a b c d e f]
         *
         * Revised for using ctm to get slope instead of inverse_ctm  11/21/88
         * since, inverse_ctm = [a b c d] = [D/M -B/M -C/M A/M]
         *        where, ctm = [A B C D],
         *               M = A * D - B * C
         * so,
         * m = (D/M * (x0-x1) + (-C/M) * (y0-y1)) /
         *     ((-B/M) * (x1-x0) + A/M * (y1-y0))
         *   = (-D * dx + C * dy) /
         *     (-B * dx + A * dy)
         */

        dx = rect1->p1.x - rect1->p0.x;
        dy = rect1->p1.y - rect1->p0.y;

        horiz_line = FALSE;
        if (ctm_flag&NORMAL_CTM) {      /* CTM = [a 0 0 d e f] */
                tmp = dy * GSptr->ctm[0];
                FABS(abs, tmp);
                if (abs < (real32)TOLERANCE) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * GSptr->ctm[3]) / tmp;
                }
        } else {
                tmp = -dx * GSptr->ctm[1] + dy * GSptr->ctm[0];
                FABS(abs, tmp);
                if (abs < (real32)TOLERANCE) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * GSptr->ctm[3] + dy * GSptr->ctm[2])
                            / tmp;
                }
        }

        /* get vector(ux, uy) that is perpendicular with (dx, dy) */
        if ( horiz_line) {
                /* transform delta-vector(0, stk_info.half_width) to device space */
                ux = GSptr->ctm[2] * stk_info.half_width;
                uy = GSptr->ctm[3] * stk_info.half_width;
                rect1->vct_u.x = zero_f;             /* vector in user space */
                rect1->vct_u.y = stk_info.half_width;

        } else {
                c = stk_info.half_width * (real32)sqrt(1 / (1 + m*m));
                mc = m * c;

                /* transform delta-vector(c, mc) to device space */
                ux = c*GSptr->ctm[0] + mc*GSptr->ctm[2];
                uy = c*GSptr->ctm[1] + mc*GSptr->ctm[3];

                rect1->vct_u.x = c;             /* vector in user space */
                rect1->vct_u.y = mc;            /* for check miter limit */
        }

        /* set clockwise direction */
        /* condition:
         *      (dx, dy) * (ux, uy) > 0,        *: cross product
         *
         *      =>   dx * uy - dy * ux > 0
         */
        if ((dx * uy) < (dy * ux)) {    /* reverse direction */
                ux = -ux;
                uy = -uy;
                rect1->vct_u.x = -rect1->vct_u.x;
                rect1->vct_u.y = -rect1->vct_u.y;
        }
        rect1->vct_d.x = ux;
        rect1->vct_d.y = uy;

        /* put in rect1 */
        rect1->pgn[0].x = rect1->p0.x + ux;
        rect1->pgn[0].y = rect1->p0.y + uy;
        rect1->pgn[1].x = rect1->p0.x - ux;
        rect1->pgn[1].y = rect1->p0.y - uy;
        rect1->pgn[2].x = rect1->p1.x - ux;
        rect1->pgn[2].y = rect1->p1.y - uy;
        rect1->pgn[3].x = rect1->p1.x + ux;
        rect1->pgn[3].y = rect1->p1.y + uy;

}



/*
 * Integer operation version
 */
static void near get_rect_points_i (rect1)
struct line_seg_i FAR *rect1;   /*@WIN*/
{
        real32   m;
        real32   c, mc;
        bool16   horiz_line;
        fix32    dx, dy, tmp;
        sfix_t   ux, uy;        /* @STK_INT */
#ifdef FORMAT_13_3
#elif FORMAT_16_16
        long dest1[2], dest2[2];   /* @RESO_UPGR */
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 dividend, divider;
        long quotient;
        long temp1[2], temp2[2];
#elif FORMAT_28_4
        long dest1[2], dest2[2];   /* @RESO_UPGR */
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 dividend, divider;
        long quotient;
        long temp1[2], temp2[2];
#endif
        /* Compute 4 endpoints of the rectangle */

        /*
         * compute delta-vector in user space
         * delta-vector = (c, mc)
         * m = (u0x - u1x) / (u1y - u0y)
         *   = ((a*x0 + c*y0 + e) - (a*x1 + c*y1 + e)) /
         *     ((b*x1 + d*y1 + f) - (b*x0 + d*y0 + f))
         *   = (a * (x0-x1) + c * (y0-y1)) /
         *     (b * (x1-x0) + d * (y1-y0))
         *
         * where, (ux0, uy0) in user space = (x0, y0) in device space
         *        inverse_ctm = [a b c d e f]
         *
         * Revised for using ctm to get slope instead of inverse_ctm  11/21/88
         * since, inverse_ctm = [a b c d] = [D/M -B/M -C/M A/M]
         *        where, ctm = [A B C D],
         *               M = A * D - B * C
         * so,
         * m = (D/M * (x0-x1) + (-C/M) * (y0-y1)) /
         *     ((-B/M) * (x1-x0) + A/M * (y1-y0))
         *   = (-D * dx + C * dy) /
         *     (-B * dx + A * dy)
         */

        dx = (fix32)rect1->p1.x - rect1->p0.x;
        dy = (fix32)rect1->p1.y - rect1->p0.y;

        horiz_line = FALSE;
        if (ctm_flag&NORMAL_CTM) {      /* CTM = [a 0 0 d e f] */
                /* some code improvement. @RESO_UPGR */
                if (dy == 0 || stroke_ctm[0] == 0) {
                        horiz_line = TRUE;
                } else {
#ifdef FORMAT_13_3
                        tmp = dy * stroke_ctm[0];
                        m = (-dx * stroke_ctm[3]) / (real32)tmp;
#elif FORMAT_16_16
                        LongFixsMul(-dx, stroke_ctm[3], dest1);
                        quotient = LongFixsDiv(stroke_ctm[0], dest1);
                        m = (real32)quotient / (real32)dy;
#elif FORMAT_28_4
                        LongFixsMul(-dx, stroke_ctm[3], dest1);
                        quotient = LongFixsDiv(stroke_ctm[0], dest1);
                        m = (real32)quotient / (real32)dy;
#endif
                }
        } else {
#ifdef FORMAT_13_3
                tmp = -dx * stroke_ctm[1] + dy * stroke_ctm[0];
                if (tmp == 0) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * stroke_ctm[3] + dy * stroke_ctm[2])
                            / (real32)tmp;      /* @STK_INT */
                }
#elif FORMAT_16_16
                LongFixsMul(dx, stroke_ctm[1], dest3);
                LongFixsMul(dy, stroke_ctm[0], dest4);

                if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                        horiz_line = TRUE;
                } else {
                        LongFixsMul(dx, stroke_ctm[3], dest5);
                        LongFixsMul(dy, stroke_ctm[2], dest6);

                        LongFixsSub(dest6, dest5, temp1);
                        LongFixsSub(dest4, dest3, temp2);

                        change_to_real(temp1, &dividend);
                        change_to_real(temp2, &divider);
                        m = dividend / divider;
                }
#elif FORMAT_28_4
                LongFixsMul(dx, stroke_ctm[1], dest3);
                LongFixsMul(dy, stroke_ctm[0], dest4);

                if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                        horiz_line = TRUE;
                } else {
                        LongFixsMul(dx, stroke_ctm[3], dest5);
                        LongFixsMul(dy, stroke_ctm[2], dest6);

                        LongFixsSub(dest6, dest5, temp1);
                        LongFixsSub(dest4, dest3, temp2);

                        change_to_real(temp1, &dividend);
                        change_to_real(temp2, &divider);

                        m = dividend / divider;
                }
#endif
        }

        /* get vector(ux, uy) that is perpendicular with (dx, dy) */
        if ( horiz_line) {
                /* transform delta-vector(0, stk_info.half_width) to device space
                */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                */
                tmp = (fix32)(stk_info.half_width_i << 1);
                ux = LFX2SFX(stroke_ctm[2] * tmp); /* @STK_INT*/
                uy = LFX2SFX(stroke_ctm[3] * tmp);
#elif FORMAT_16_16
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                   ....... ATTENTION ........  The hard-coded constant 12.
                */
                LongFixsMul(stk_info.half_width_i, stroke_ctm[2], dest1);
                ux = LongFixsDiv((1L << 12), dest1);
                LongFixsMul(stk_info.half_width_i, stroke_ctm[3], dest1);
                uy = LongFixsDiv((1L << 12), dest1);
#elif FORMAT_28_4
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                   ....... ATTENTION ........  The hard-coded constant 12.
                */
                LongFixsMul(stk_info.half_width_i, stroke_ctm[2], dest1);
                ux = LongFixsDiv((1L << 12), dest1);
                LongFixsMul(stk_info.half_width_i, stroke_ctm[3], dest1);
                uy = LongFixsDiv((1L << 12), dest1);
#endif
                rect1->vct_u.x = zero_f;          /* vector in user space */
                rect1->vct_u.y = stk_info.half_width;

        } else {
                lfix_t tmpc, tmpmc;     /* for more acuracy 1/5/89 */
                c = stk_info.half_width * (real32)sqrt(1 / (1 + m*m));
                mc = m * c;
                tmpc = F2LFX8_T(c);
                tmpmc = F2LFX8_T(mc);

                /* transform delta-vector(c, mc) to device space */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                */
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
#elif FORMAT_16_16
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
                The (16 - L_SHIFT) is for if LFX is not .16 format
                */
                ux = LFX2SFX(((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
                uy = LFX2SFX(((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
#elif FORMAT_28_4
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
                The (16 - L_SHIFT) is for if LFX is not .16 format
                */
                ux = LFX2SFX(((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
                uy = LFX2SFX(((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
#endif
                rect1->vct_u.x = c;      /* tmpc >> 1; vector in user space */
                rect1->vct_u.y = mc;     /* tmpmc >> 1; for check miter limit */
        }

        /* set clockwise direction */
        /* condition:
         *      (dx, dy) * (ux, uy) > 0,        *: cross product
         *
         *      =>   dx * uy - dy * ux > 0
         */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        if ((dx * uy) < (dy * ux)) {    /* reverse direction */
#elif FORMAT_16_16
        LongFixsMul(dx, uy, dest1);
        LongFixsMul(dy, ux, dest2);
        LongFixsSub(dest1, dest2, temp1);
        if (temp1[0] < 0) {
#elif FORMAT_28_4
        LongFixsMul(dx, uy, dest1);
        LongFixsMul(dy, ux, dest2);
        LongFixsSub(dest1, dest2, temp1);
        if (temp1[0] < 0) {
#endif
                ux = -ux;
                uy = -uy;
                rect1->vct_u.x = -rect1->vct_u.x;
                rect1->vct_u.y = -rect1->vct_u.y;
        }
        rect1->vct_d.x = ux;
        rect1->vct_d.y = uy;

        /* put in rect1 */
        rect1->pgn[0].x = rect1->p0.x + ux;
        rect1->pgn[0].y = rect1->p0.y + uy;
        rect1->pgn[1].x = rect1->p0.x - ux;
        rect1->pgn[1].y = rect1->p0.y - uy;
        rect1->pgn[2].x = rect1->p1.x - ux;
        rect1->pgn[2].y = rect1->p1.y - uy;
        rect1->pgn[3].x = rect1->p1.x + ux;
        rect1->pgn[3].y = rect1->p1.y + uy;

}

/***********************************************************************
 * Given a paint_flag and a polygon, this module creates a subpath of
 * the polygon and appends it to new_path, or clips it to clipping path
 * and paints it out.
 *
 * TITLE:       paint_or_save
 *
 * CALL:        paint_or_save (pgn);
 *
 * PARAMETERS:
 *              pgn
 *
 * INTERFACE:   Linetour
 *
 * CALLS:       Transform
 *              Convex_clipper
 *              Filler
 *
 * RETURN:
 **********************************************************************/
static void near paint_or_save (pgn)
struct coord FAR *pgn;          /*@WIN*/
{
        SP_IDX  subpath;
        fix     i;

        /* check infinitive number 10/24/88 */
        if(_status87() & PDL_CONDITION){
                /* do nothing for stroking infinitive coords */
                if (paint_flag) {
                        _clear87();
                        return;
                }

                for (i=0; i<4; i++) {
                        pgn[i].x = infinity_f;
                        pgn[i].y = infinity_f;
                }
                _clear87();
        }


        if (paint_flag) {
            bool    outpage = FALSE;
            struct  polygon_i ipgn;
            VX_IDX  head, tail, inode, ivtx, first_vertex;
            struct  nd_hdr  FAR *vtx;

            /* check if polygon inside the page */
            for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                    if (out_page(F2L(pgn[i].x)) ||     /* @OUT_PAGE */
                        out_page(F2L(pgn[i].y))) {     /* @TOUR */
                            outpage = TRUE;
                            break;
                    }
            }

            if (outpage) {

                /* transform polygon to subpath */
                inode = get_node();
                node_table[inode].VX_TYPE = MOVETO;        /* 2/9/88 */
                node_table[inode].VERTEX_X = pgn[0].x;  /* @TOUR */
                node_table[inode].VERTEX_Y = pgn[0].y;
                head = tail = inode;
                for (i=1; i<4; i++) {           /* pgn->size @TOUR */
                        inode = get_node();
                        node_table[inode].VX_TYPE = LINETO; /* 2/9/88 */
                        node_table[inode].VERTEX_X = pgn[i].x; /*@TOUR*/
                        node_table[inode].VERTEX_Y = pgn[i].y;
                        node_table[tail].next = inode;
                        tail = inode;
                }  /* for */
                node_table[tail].next = NULLP;

                /* clip to page boundary */
                first_vertex = page_clipper (head);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_node(head);
                        return;
                }

                /* just return if the whole path has been clipped out */
                if (first_vertex == NULLP) {    /* 2/10/88 */
                        /* release temp. subpath */
                        free_node(head);
                        return;
                }


                /* transform clipped subpath to polygon */
                for (i=0, ivtx=first_vertex; ivtx!=NULLP;
                        i++, ivtx=vtx->next) {
                        vtx = &node_table[ivtx];
                        ipgn.p[i].x = F2SFX(vtx->VERTEX_X);     /* @RND */
                        ipgn.p[i].y = F2SFX(vtx->VERTEX_Y);
                }
                ipgn.size = (fix16)i;

                /* release temp. subpaths */
                free_node(head);
                free_node(first_vertex);

            } else {
                for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                        ipgn.p[i].x = F2SFX(pgn[i].x);          /* @RND */
                        ipgn.p[i].y = F2SFX(pgn[i].y);
                }
                ipgn.size = 4;

                /* check if totally inside clip region, then
                 * call pgn_reduction() directly 9/6/88
                 */
                if (GSptr->clip_path.single_rect) {
                    for (i=0; i<4; i++) {
                        if (ipgn.p[i].x < GSptr->clip_path.bb_lx) break;
                        else if (ipgn.p[i].x > GSptr->clip_path.bb_ux) break;

                        if (ipgn.p[i].y < GSptr->clip_path.bb_ly) break;
                        else if (ipgn.p[i].y > GSptr->clip_path.bb_uy) break;
                    } /* for */

                    if (i>=4) {
#ifdef DBG1
                        printf(" inside single rectangle clip\n");
#endif
                        pgn_reduction(&ipgn);
                        return;
                    } /* if i<4 */
                } /* if single_rect */

            } /* if outpage */

            /* clip and fill the polygon */
            convex_clipper(&ipgn, FALSE);
                            /* FALSE: the polygon is not a trapezoid */

        } else {
            /* Create a subpath */
            if ((subpath = subpath_gen(pgn)) == NULLP) {
                            ERROR(LIMITCHECK);
                            return;
            }

            /* Append subpath to new_path */
            if (new_path.head == NULLP)
                    new_path.head = subpath;
            else
                    /* node_table[new_path.tail].next = @NODE */
                    node_table[new_path.tail].SP_NEXT =
                    subpath;
            new_path.tail = subpath;
        }
}


/*
 * Integer operation version
 */
static void near paint_or_save_i (pgn)
struct coord_i FAR *pgn;    /* @WIN STK_INT */
{

        fix     i;
        struct  polygon_i ipgn;

        for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                ipgn.p[i].x = pgn[i].x;                 /* @STK_INT */
                ipgn.p[i].y = pgn[i].y;
        }
        ipgn.size = 4;

        /* check if totally inside clip region, then
         * call pgn_reduction() directly 9/6/88
         */
        if (inside_clip_flag) {
#ifdef DBG1
                printf(" inside single rectangle clip\n");
#endif
                pgn_reduction(&ipgn);
                return;
        }

        if (GSptr->clip_path.single_rect) {
            for (i=0; i<4; i++) {
                if (ipgn.p[i].x < GSptr->clip_path.bb_lx) break;
                else if (ipgn.p[i].x > GSptr->clip_path.bb_ux) break;

                if (ipgn.p[i].y < GSptr->clip_path.bb_ly) break;
                else if (ipgn.p[i].y > GSptr->clip_path.bb_uy) break;
            } /* for */

            if (i>=4) {
#ifdef DBG1
                printf(" inside single rectangle clip\n");
#endif
                pgn_reduction(&ipgn);
                return;
            } /* if i<4 */
        } /* if single_rect */


        /* clip and fill the polygon */
        convex_clipper(&ipgn, FALSE);
                        /* FALSE: the polygon is not a trapezoid */

}



/***********************************************************************
 *
 * TITLE:       round_point
 *
 * CALL:        round_point (paint_flag, x, y)
 *
 * PARAMETERS:  paint_flag -- paint/save
 *              x, y -- coordinate of root
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:
 **********************************************************************/
static void near round_point(lx0, ly0)
long32 lx0, ly0;
{
        fix    dx_i, dy_i, width, heigh;
        real32  x0, y0;
        real32  dx, dy;
        /* struct  vx_lst *arc_vlist; @NODE */
        SP_IDX arc_vlist;
        VX_IDX ivtx;
        struct nd_hdr FAR *vtx, FAR *sp;
        SP_IDX subpath;
        real32 save_flat;

        x0   = L2F(lx0);
        y0   = L2F(ly0);

        /* check if circle has changed */
        if (stk_info.change_circle) {
                            /* stk_info.change_circle:
                             *   set by "init_stroke"
                             */
            /* set up control points of the circle */
            circle_ctl_points();

            /* clear stk_info.change_circle flag */
            stk_info.change_circle = FALSE;
        }

        /* paint a circle or save it due to paint_flag */
        if (paint_flag) {

            /* try to set circle in cache */
            if (circle_flag == CIR_UNSET_CACHE) {
                fix i, j;

                /* only for cache_to_page 12/23/88 */
                if (fill_destination == F_TO_CACHE) goto out_cache;

                /* bounding box of the circle */
                dx = curve[0][0].x;     /* init. */
                dy = curve[0][0].y;
                for (i=0; i<2; i++) {
                        for (j=0; j<3; j++) {
                                if (MAGN(curve[i][j].x) > MAGN(dx))
                                        dx = curve[i][j].x;
                                if (MAGN(curve[i][j].y) > MAGN(dy))
                                        dy = curve[i][j].y;
                        }
                }

                F2L(dx) = MAGN(dx);      /* absolute value */
                F2L(dy) = MAGN(dy);
                dx_i = ROUND(dx);
                dy_i = ROUND(dy);

                /* check if circle bitmap is too large to cache */
                if (dx*dy <= (real32)(CRC_SIZE * 8 / 4)) {
                                        /* dx*dx is 1/4 of the whole bitmap */

                        /* setup cache information of circle bitmap */
                        width = ALIGN_R(dx_i * 2) + 1;
                        heigh = (dy_i * 2) + 1;
                        cir_cache_info.ref_x = F2SFX(dx);
                        cir_cache_info.ref_y = F2SFX(dy);
                                                /* F2SFX should be consistent
                                                 * with getting of linewidth
                                                 * in init_stroke()
                                                 */

                        cir_cache_info.box_w = (fix16)width;
                        cir_cache_info.box_h = (fix16)heigh;
                        cir_cache_info.bitmap = CRC_BASE;

                        /* save old graphics state */
                        save_cache_info = cache_info;   /* cache information */
                        save_clip = GSptr->clip_path;   /* clip path */
                        save_dest = fill_destination;
#ifdef DBG1
                        printf("To build a circle cache, cache_info =\n");
                        printf("\tref_x=%d, ref_y=%d, box_w=%d, box_h=%d\n",
                               cir_cache_info.ref_x, cir_cache_info.ref_y,
                               cir_cache_info.box_w, cir_cache_info.box_h);
                        printf("\tbitmap=%lx\n", cir_cache_info.bitmap);
#endif
                        /* clear circle cache */
                        init_char_cache (&cir_cache_info);

                        /* set new graphics state for caching */
                        cache_info = &cir_cache_info;   /* cache information */
                        GSptr->clip_path.bb_ly = 0;     /* clip path */
                        GSptr->clip_path.bb_lx = 0;
                        GSptr->clip_path.bb_ux = I2SFX(width);
                        GSptr->clip_path.bb_uy = I2SFX(heigh);
                        GSptr->clip_path.single_rect = TRUE;
                        fill_destination = F_TO_CACHE;

                        /* build circle bitmap */
                        /* shrink circle 1 pixel for quality 1/12/89 */
                        dy += (real32)0.5;
                        dx += (real32)0.5;
                        curve[0][0].x -= (real32)0.5;
                        curve[0][0].y -= (real32)0.5;
                        curve[0][1].x -= (real32)0.5;
                        curve[0][1].y -= (real32)0.5;
                        curve[0][2].y -= (real32)0.5;

                        curve[1][0].x += (real32)0.5;
                        curve[1][0].y -= (real32)0.5;
                        curve[1][1].x += (real32)0.5;
                        curve[1][1].y -= (real32)0.5;
                        curve[1][2].x += (real32)0.5;

                        curve[2][0].x += (real32)0.5;
                        curve[2][0].y += (real32)0.5;
                        curve[2][1].x += (real32)0.5;
                        curve[2][1].y += (real32)0.5;
                        curve[2][2].y += (real32)0.5;

                        curve[3][0].x -= (real32)0.5;
                        curve[3][0].y += (real32)0.5;
                        curve[3][1].x -= (real32)0.5;
                        curve[3][1].y += (real32)0.5;
                        curve[3][2].x -= (real32)0.5;

                        arc_vlist = circle_list (F2L(dx), F2L(dy));
                        if( ANY_ERROR() == LIMITCHECK ) return;

                        /* create a subpath consists of arc_vlist for
                         * shape_approxiamtion
                         */
                        /* subpath = vlist_to_subp (arc_vlist); @NODE */
                        subpath = arc_vlist;

                        if( ANY_ERROR() == LIMITCHECK ) return;
                        sp = &node_table[subpath];
                        sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */

                        /* initialize edge table 11/30/88 */
                        init_edgetable();       /* in "shape.c" */

                        /* adjust flatness for smoothing the circle 5/9/89 */
                        save_flat = GSptr->flatness;
                        GSptr->flatness *= (real32)0.7;

                        shape_approximation (subpath, (fix *)NULLP);

                        /* restore flatness 5/9/89 */
                        GSptr->flatness = save_flat;

                        if(ANY_ERROR() == LIMITCHECK){ /* out of edge table */
                                 return;                        /* 4/17/91 */
                        }

                        shape_reduction (NON_ZERO);

                        if(ANY_ERROR() == LIMITCHECK){ /* out of scany_table */
                                 return;               /* 05/07/91, Peter */
                        }

                        /* restore graphics state */
                        GSptr->clip_path = save_clip;
                        fill_destination = save_dest;
                                        /* cache_info will be restored at end
                                         * of stroke command
                                         */
                        /* free the curve circle */
                        /* free_node (sp->SP_HEAD); @NODE */
                        free_node (subpath);

                        /* now cicle bitmap is in cache */
                        circle_flag = CIR_IN_CACHE;

                } else {        /* circle too big to cache */
out_cache:
                        circle_flag = CIR_OUT_CACHE;

                        /* create a list of circle consists of curves */
                        arc_vlist = circle_list (lx0, ly0);
                        if( ANY_ERROR() == LIMITCHECK ) return;

                        /* set up a flattened circle as a pattern for stroke */
                        flatten_circle (arc_vlist);
                                /* the flattened circle been set up in
                                 * circle_sp and circle_bbox @STK_INFO
                                 * arc_vlist was freed
                                 */

                        /* free the curve circle @STK_INFO */
                        /* free_node (arc_vlist->head);
                         *                (* be freed in flatten_circle() *)
                         *                10/12/88
                         */

                        /* keep root of the circle */
                        circle_root.x = x0;
                        circle_root.y = y0;
                }

            } /* if circle_flag == CIR_UNSET_CACHE */

            if (circle_flag == CIR_IN_CACHE) {

                GSptr->position.x = x0;
                GSptr->position.y = y0;
                fill_shape (NON_ZERO, F_FROM_CRC, F_TO_PAGE);

            } else {

                /* get the new circle by adding offset from circle
                 * pattern
                 */
                sp = &node_table[circle_sp];

                /* offset */
                dx = x0 - circle_root.x;
                dy = y0 - circle_root.y;

                /* for (ivtx = sp->SP_HEAD; ivtx!=NULLP; @NODE */
                for (ivtx = circle_sp; ivtx!=NULLP;
                     ivtx = vtx->next) {
                        vtx = &node_table[ivtx];
                        /* set sp_flag @SP_FLG */
                        vtx->VERTEX_X += dx;
                        vtx->VERTEX_Y += dy;
                }

                /* modify root coord of the circle @TOUR */
                circle_root.x = x0;
                circle_root.y = y0;

                /* update the bounding box */
                circle_bbox[0] += dx;
                circle_bbox[1] += dy;
                circle_bbox[2] += dx;
                circle_bbox[3] += dy;

                /* check if the circle is outside the page boundary */
                if (too_small(F2L(circle_bbox[0])) ||   /* @OUT_PAGE */
                    too_small(F2L(circle_bbox[1])) ||
                    too_large(F2L(circle_bbox[2])) ||
                    too_large(F2L(circle_bbox[3])))
                        node_table[circle_sp].SP_FLAG |= SP_OUTPAGE;

                /* initialize edge table 11/30/88 */
                init_edgetable();       /* in "shape.c" */

                shape_approximation (circle_sp, (fix *)NULLP);
                if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                       return;
                }
                shape_reduction (NON_ZERO);
                                /* should not free circle_sp */
            } /* if circle_flag */



        } else { /* save */

            /* save the circle in new_path */
            /* Create an arc at the join point */
            arc_vlist = circle_list (lx0, ly0);
            if( ANY_ERROR() == LIMITCHECK ) return;

            /* create a subpath consists of arc_vlist */
            /* subpath = vlist_to_subp (arc_vlist); @NODE */
            subpath = arc_vlist;
            if( ANY_ERROR() == LIMITCHECK ) return;

            sp = &node_table[subpath];
            /* set sp_flag @SP_FLG 1/8/88 */
            sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
            sp->SP_FLAG &= ~SP_OUTPAGE;     /* init. in page */
            /* for (ivtx = sp->SP_HEAD; ivtx!=NULLP; @NODE */
            for (ivtx = subpath; ivtx!=NULLP; /* check OUTPAGE flag */
                 ivtx = vtx->next) {
                    vtx = &node_table[ivtx];

                    /* break if closepath node 9/07/88 */
                    if (vtx->VX_TYPE == CLOSEPATH) break;

                    /* set sp_flag @SP_FLG */
                    if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                        out_page(F2L(vtx->VERTEX_Y))) {
                            sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
#ifdef DBG1
                            printf("Outpage\n");
                            dump_all_path (subpath);
#endif
                            break;                  /* 1/29/88 */
                    }
            }


            /* Append the subpath to new_path */
            if (new_path.head == NULLP)
                    new_path.head = subpath;
            else
                    /* node_table[new_path.tail].next = subpath; @NODE */
                    node_table[new_path.tail].SP_NEXT = subpath;
            new_path.tail = subpath;

        }
}





/*
 * setup control points of a circle
 */
static void near circle_ctl_points()
{
        real32 h0, h1, h2, h3, c0, c1, c2, c3;
        real32  ctl_pnt_width;  /* @STK_INFO */

        ctl_pnt_width = (real32)0.5522847 * stk_info.half_width;
                        /* 0.5522847 = 4 / 3 * (sqrt(2) -1) */

        /* set up control points of curvetoes: in device space
         *
         *                   +--------+--------+         y1
         *                  /         |         \
         *                /           |           \
         *               /            |            \
         *              +             |              +   y2
         *              |             |              |
         *              +-------------+--------------+   y0
         *              |             |              |
         *              +             |              +   y4
         *               \            |             /
         *                \           |            /
         *                  \         |          /
         *                    +-------+---------+        y3
         *
         *             x3     x4      x0        x2   x1
         */
        /* 12 control point vectors: in user space => device space
         *      ( h,  0)       -( h,  0)
         *      ( h, -c)       -( h, -c)
         *      ( c, -h)       -( c, -h)
         *      ( 0, -h)       -( 0, -h)
         *      (-c, -h)       -(-c, -h)
         *      (-h, -c)       -(-h, -c)
         */

        h0 = stk_info.half_width * GSptr->ctm[0];
        h1 = stk_info.half_width * GSptr->ctm[1];
        h2 = stk_info.half_width * GSptr->ctm[2];
        h3 = stk_info.half_width * GSptr->ctm[3];
        c0 = ctl_pnt_width * GSptr->ctm[0];
        c1 = ctl_pnt_width * GSptr->ctm[1];
        c2 = ctl_pnt_width * GSptr->ctm[2];
        c3 = ctl_pnt_width * GSptr->ctm[3];

        /* for clockwise direction */
        if (ctm_flag & LEFT_HAND_CTM) {         /* @STKDIR */
/*              curve[0][0].x =  h0 - c1;     curve[0][0].y =  h2 - c3;
                curve[0][1].x =  c0 - h1;     curve[0][1].y =  c2 - h3;
                curve[0][2].x =      -h1;     curve[0][2].y =      -h3;

                curve[1][0].x = -c0 - h1;     curve[1][0].y = -c2 - h3;
                curve[1][1].x = -h0 - c1;     curve[1][1].y = -h2 - c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h2     ;

                curve[2][0].x = -h0 + c1;     curve[2][0].y = -h2 + c3;
                curve[2][1].x = -c0 + h1;     curve[2][1].y = -c2 + h3;
                curve[2][2].x =       h1;     curve[2][2].y =       h3;

                curve[3][0].x =  c0 + h1;     curve[3][0].y =  c2 + h3;
                curve[3][1].x =  h0 + c1;     curve[3][1].y =  h2 + c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h2     ;*/

                /* user space => device space, - begin -, 2-4-91 */
                curve[0][0].x =  h0 - c2;     curve[0][0].y =  h1 - c3;
                curve[0][1].x =  c0 - h2;     curve[0][1].y =  c1 - h3;
                curve[0][2].x =      -h2;     curve[0][2].y =      -h3;

                curve[1][0].x = -c0 - h2;     curve[1][0].y = -c1 - h3;
                curve[1][1].x = -h0 - c2;     curve[1][1].y = -h1 - c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h1     ;

                curve[2][0].x = -h0 + c2;     curve[2][0].y = -h1 + c3;
                curve[2][1].x = -c0 + h2;     curve[2][1].y = -c1 + h3;
                curve[2][2].x =       h2;     curve[2][2].y =       h3;

                curve[3][0].x =  c0 + h2;     curve[3][0].y =  c1 + h3;
                curve[3][1].x =  h0 + c2;     curve[3][1].y =  h1 + c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h1     ;
                /* user space => device space, - end -, 2-4-91 */
        } else {
/*              curve[0][0].x =  h0 + c1;     curve[0][0].y =  h2 + c3;
                curve[0][1].x =  c0 + h1;     curve[0][1].y =  c2 + h3;
                curve[0][2].x =       h1;     curve[0][2].y =       h3;

                curve[1][0].x = -c0 + h1;     curve[1][0].y = -c2 + h3;
                curve[1][1].x = -h0 + c1;     curve[1][1].y = -h2 + c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h2     ;

                curve[2][0].x = -h0 - c1;     curve[2][0].y = -h2 - c3;
                curve[2][1].x = -c0 - h1;     curve[2][1].y = -c2 - h3;
                curve[2][2].x =      -h1;     curve[2][2].y =      -h3;

                curve[3][0].x =  c0 - h1;     curve[3][0].y =  c2 - h3;
                curve[3][1].x =  h0 - c1;     curve[3][1].y =  h2 - c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h2     ;*/

                /* user space => device space, - begin -, 2-4-91 */
                curve[0][0].x =  h0 + c2;     curve[0][0].y =  h1 + c3;
                curve[0][1].x =  c0 + h2;     curve[0][1].y =  c1 + h3;
                curve[0][2].x =       h2;     curve[0][2].y =       h3;

                curve[1][0].x = -c0 + h2;     curve[1][0].y = -c1 + h3;
                curve[1][1].x = -h0 + c2;     curve[1][1].y = -h1 + c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h1     ;

                curve[2][0].x = -h0 - c2;     curve[2][0].y = -h1 - c3;
                curve[2][1].x = -c0 - h2;     curve[2][1].y = -c1 - h3;
                curve[2][2].x =      -h2;     curve[2][2].y =      -h3;

                curve[3][0].x =  c0 - h2;     curve[3][0].y =  c1 - h3;
                curve[3][1].x =  h0 - c2;     curve[3][1].y =  h1 - c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h1     ;
                /* user space => device space, - end -, 2-4-91 */
        }

#ifdef DBG1
        {
                fix     i, j;
                printf("circle_ctl_points():\n");
                for (i=0; i<4; i++) {
                        printf("curve[%d] = ", i);
                        for (j=0; j<3; j++) {
                            printf("  (%f, %f)", curve[i][j].x, curve[i][j].y);
                        }
                        printf("\n");
                }

        }
#endif

}



/* static struct vx_lst * near circle_list(lx0, ly0) @NODE */
static SP_IDX near circle_list(lx0, ly0)
long32 lx0, ly0;
{
        fix    i, bz;
        real32  x0, y0;
        /* static struct vx_lst ret_list; @NODE */
        SP_IDX ret_list;                /* return data; should be static
                                         * otherwise, it will be erased
                                         * after returns
                                         */
        VX_IDX  ivtx;
        struct nd_hdr FAR *vtx;
        VX_IDX tail;            /* @NODE */

        x0   = L2F(lx0);
        y0   = L2F(ly0);

        /* ret_list.head = ret_list.tail = NULLP; @NODE */
        ret_list = tail = NULLP;
        /*
         * Create a MOVETO node
         */
        /* Allocate a node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                /* return (&ret_list); @NODE */
                return (ret_list);
        }
        vtx = &node_table[ivtx];

        /* Set up a MOVETO node */
        vtx->VX_TYPE = MOVETO;
        /* ret_list.head = ret_list.tail = ivtx; @NODE */
        ret_list = tail = ivtx;

        vtx->VERTEX_X = x0 + curve[3][2].x;
        vtx->VERTEX_Y = y0 + curve[3][2].y;

        /* loop to generate 4 bezier curvetoes */
        for (bz = 0; bz < 4; bz++) {

            /* loop to create 3 CURVETO nodes */
            for (i=0; i<3; i++) {
                    /*
                     * Create a CURVETO node
                     */
                    /* Allocate a node */
                    ivtx = get_node();
                    if(ivtx == NULLP) {
                            ERROR(LIMITCHECK);

                            /* @NODE
                             * free_node (ret_list.head);
                             * ret_list.head = ret_list.tail = NULLP;
                             * return (&ret_list);
                             */
                            free_node (ret_list);
                            ret_list = NULLP;
                            return (ret_list);
                    }
                    vtx = &node_table[ivtx];

                    /* Set up a CURVETO node */
                    vtx->VX_TYPE = CURVETO;
                    vtx->next = NULLP;

                    vtx->VERTEX_X = x0 + curve[bz][i].x;
                    vtx->VERTEX_Y = y0 + curve[bz][i].y;

                    /* Append this node to bezier_list */
                    /* @NODE
                     * node_table[ret_list.tail].next = ivtx;
                     * ret_list.tail = ivtx;
                     */
                    node_table[tail].next = ivtx;
                    tail = ivtx;

            } /* for i */
        } /* for bz */

        /* return (&ret_list); @NODE */
        node_table[ret_list].SP_TAIL = tail;    /* @NODE */
        node_table[ret_list].SP_NEXT = NULLP;   /* @NODE */
        node_table[ret_list].SP_FLAG = SP_CURVE;/* @NODE */
        return (ret_list);                      /* @NODE */

}

static void near flatten_circle (arc_vlist)
/* struct vx_lst *arc_vlist; @NODE */
SP_IDX arc_vlist;
{
        /* struct vx_lst *flt_vlist; @NODE */
        SP_IDX flt_vlist;
        VX_IDX ivtx;
        struct nd_hdr FAR *vtx;

        /*  free old subpath of circle for round join & cap @STK_INFO */
        if (circle_sp != NULLP) {
                /* free_node (node_table[circle_sp].SP_HEAD); @NODE */
                free_node (circle_sp);
        }

        /* @NODE
         * (* allocate a subpath header    @TRVSE *)
         * circle_sp = get_node();
         * if(circle_sp == NULLP) {
         *         ERROR(LIMITCHECK);
         *         return;
         * }
         * node_table[circle_sp].next = NULLP;
         * node_table[circle_sp].SP_HEAD = arc_vlist->head;
         * node_table[circle_sp].SP_TAIL = arc_vlist->tail;
         * node_table[circle_sp].SP_FLAG = SP_CURVE; (* 10/12/88 *)
         */
        circle_sp = arc_vlist;
        node_table[circle_sp].SP_FLAG = SP_CURVE; /* 10/12/88 */

#ifdef DBG1
        printf("flatten_circle():\nOrig. circle_sp =\n");
        dump_all_path (circle_sp);
#endif
        /* calculate the bounding_box of the circle
         */
        /* initialize bounding_box */
        circle_bbox[0] = (real32)EMAXP;
        circle_bbox[1] = (real32)EMAXP;
        circle_bbox[2] = (real32)EMINN;
        circle_bbox[3] = (real32)EMINN;
//      bounding_box (circle_sp, (real32 far *)circle_bbox);    @C6.0
        bounding_box (circle_sp, (real32     *)circle_bbox);
                        /* may place after flattened for more
                         * accurate
                         */

        /*
         * flatten the circle:
         * if the radius is too large then just treat the control
         * points of the curves as lineto points and does not
         * need to flatten it. @BIG_CIR
         */
        if (stk_info.half_width > (real32)4096.0) {
                                /* 4096: any larger number, tunable */
            /* change curveto nodes to lineto nodes in the circle */
            /* for (ivtx = arc_vlist->head; ivtx != NULLP; @NODE */
            for (ivtx = circle_sp; ivtx != NULLP;
                    ivtx = vtx->next) {
                    vtx = &node_table[ivtx];

                    if (vtx->VX_TYPE == CURVETO)
                            vtx->VX_TYPE = LINETO;
            } /* for */

            /* set outpage flag 10/12/88 */
            node_table[circle_sp].SP_FLAG |= SP_OUTPAGE;    /* outside page */

        } else {
            /* flatten the circle @CIR_FLAT*/
            /* flt_vlist = flatten_subpath(node_table[circle_sp].SP_HEAD,@NODE*/
            flt_vlist = flatten_subpath (circle_sp,
                    F2L(GSptr->flatness)); /* use current flatness */

            if( ANY_ERROR() == LIMITCHECK ){
                    /* free_node (arc_vlist->head); @NODE */
                    free_node (circle_sp);
                    circle_sp = NULLP;          /* @NODE */
                    return;
            }

            /* @NODE
             * free the curve circle, only need to save flattened
             * circle
             *
             * free_node (arc_vlist->head);
             *
             * arc_vlist->head = flt_vlist->head;  (* 11/09/88 *)
             * arc_vlist->tail = flt_vlist->tail;
             */
            free_node (circle_sp);                              /* @NODE */
            circle_sp = flt_vlist;  /* 11/09/88 */              /* @NODE */
        }

        /* save the flattened circle
         */
        /* use the previous subpath header */
        /* @NODE
         * node_table[circle_sp].next = NULLP;
         * node_table[circle_sp].SP_HEAD = arc_vlist->head;     (* 11/09/88 *)
         * node_table[circle_sp].SP_TAIL = arc_vlist->tail;     (* 11/09/88 *)
         * node_table[circle_sp].SP_FLAG &= ~SP_CURVE;
         */
        node_table[circle_sp].SP_FLAG &= ~SP_CURVE;         /* @NODE */

#ifdef DBG1
        printf("Flattened circle_sp =\n");
        dump_all_path (circle_sp);
#endif

}


/***********************************************************************
 * Given a polygon, this module generates a subpath of the polygon.
 *
 * TITLE:       subpath_gen
 *
 * CALL:        subpath_gen(pgn)
 *
 * PARAMETERS:  polygon -- a quadrangle contains 4 coordinates
 *
 * INTERFACE:
 *
 * CALLS:       get_node
 *
 * RETURN:      subpath -- index of node_table contains a subpath
 *              NULLP   -- fail (no more nodes to generate subpath)
 **********************************************************************/
static SP_IDX near subpath_gen(pgn)
struct coord FAR *pgn;                  /*@WIN*/
{
        struct nd_hdr FAR *sp, FAR *vtx;
        SP_IDX isp;
        VX_IDX ivtx;
        fix    i;

        /* @NODE
         * (* subpath header *)
         * if((isp = get_node()) == NULLP){
         *         ERROR(LIMITCHECK);
         *         return(NULLP);
         * }
         * sp = &node_table[isp];
         * sp->next = NULLP;
         * sp->SP_FLAG = FALSE;    (* initialization 1/19/88 *)
         */

        /* create MOVETO node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                /* free_node (isp); @NODE */
                return(NULLP);
        }
        vtx = &node_table[ivtx];

        vtx->VX_TYPE = MOVETO;
        vtx->next = NULLP;
        vtx->VERTEX_X = pgn[0].x;       /* @TOUR */
        vtx->VERTEX_Y = pgn[0].y;

        /* initialize list @NODE */
        isp = ivtx;
        sp = vtx;
        sp->SP_NEXT = NULLP;
        sp->SP_FLAG = FALSE;    /* initialization 1/19/88 */

        /* set sp_flag @SP_FLG 1/19/88 */
        if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
            out_page(F2L(vtx->VERTEX_Y))) {
                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
        }

        /* sp->SP_HEAD = ivtx; @NODE */
        sp->SP_TAIL = ivtx;

        /* loop to create LINETO nodes */
        for(i = 1; i < 4; i++) {                /* pgn->size @TOUR */
                if((ivtx = get_node()) == NULLP) {
                        ERROR(LIMITCHECK);
                        free_node (isp);
                        /* free_node (sp->SP_HEAD); @NODE */
                        return(NULLP);
                }
                vtx = &node_table[ivtx];

                vtx->VX_TYPE = LINETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = pgn[i].x;       /* @TOUR */
                vtx->VERTEX_Y = pgn[i].y;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                node_table[sp->SP_TAIL].next = ivtx;
                sp->SP_TAIL = ivtx;
        }

        /* create a CLOSEPATH node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                free_node (isp);
                /* free_node (sp->SP_HEAD); @NODE */
                return(NULLP);
        }
        vtx = &node_table[ivtx];

        vtx->VX_TYPE = CLOSEPATH;
        vtx->next = NULLP;

        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        return(isp);

}

#ifdef  _AM29K
static void near
dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\async.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
**********************************************************************
*  File:        ASYNC.C
*
*  History:
**********************************************************************
*/
/*
*   Function:
*       init_asyncio
*       check_interrupt     ?? current port
*       check_Control_C
*       ctrlC_report
*       stdingetc           ?? delete
*       getline
*       linegetc
*       getstatement
*       statementgetc
*       set_echo
*       reset_cookbuf
*       line_editor
*       stmt_editor
*       kputc
*       kgetc
*       kskipc
*       echo_a_char
*       echo_BS
*       echo_ctrlR
*       kskipc
*       kskipc
*/


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>
#include    <string.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geierr.h"
#include    "language.h"
#include    "file.h"

/* special chars */
#define         Crtl_C_Char     3
#define         EOF_Char        -1
#define         BELL_Char       7
#define         BS_Char         8
#define         NL_Char         10
#define         CR_Char         13
#define         Crtl_R_Char     18
#define         Crtl_U_Char     21
#define         US_Char         31
#define         DEL_Char        127

/* define variables */
static  fix16   cook_head = 0 ;
static  fix16   cook_tail = 0 ;
static  fix16   cook_count = 0 ;
static  fix16   line_head = 0 ;
static  fix16   line_count = 0 ;

static  fix16   echo_flag = 0 ;
static  fix16   line_del = 0 ;
static  fix16   stmt_del = 0 ;

static  fix16   lpair = 0 ;          /* indicator for { } pair */
static  fix16   spair = 0 ;          /* indicator for ( ) pair */
static  fix16   hpair = 0 ;          /* indicator for < > pair */
static  fix16   comment_flag = 0 ;   /* indicator for % */
static  fix16   bslash_flag = 0 ;    /* indicator for \ */

static  fix16   crlf_flag = 0 ;

#define         MAXCOOKBUFSZ    4096

static  byte    far * near cookbuf ; /* for fardata version */

#define         NL_TERM         0
#define         EOF_TERM        1
static  byte    near NL_or_EOF ;

extern  bool16  int_flag ;
extern  bool16  eable_int ;
extern  bool16  chint_flag ;

#ifdef LINT_ARGS
   static  fix   near  line_editor(byte) ;
   static  bool  near  stmt_editor(byte) ;
   static  void  near  echo_a_char(byte) ;
   static  void  near  echo_crtlR(void) ;
   static  void  near  echo_BS(void) ;
   static  void  near  kputc(byte) ;
   static  fix16 near  kgetc(void) ;
   static  void  near  kskipc(void) ;
#else
   static  fix   near  line_editor() ;
   static  bool  near  stmt_editor() ;
   static  void  near  echo_a_char() ;
   static  void  near  echo_crtlR() ;
   static  void  near  echo_BS() ;
   static  void  near  kputc() ;
   static  fix16 near  kgetc() ;
   static  void  near  kskipc() ;
#endif /* LINT_ARGS */

/*
       **********************************
       *                                *
       *  init & close serial I/O port  *
       *                                *
       **********************************
*/
/*
**********************************************************************
*   Name:       init_sio
*   Called:
*   Calling:
**********************************************************************
*/
void
init_asyncio()
{
    cookbuf = fardata((ufix32)MAXCOOKBUFSZ) ;
} /* init_sio */

/*
**********************************************************************
*   Name:       check_interrupt
*   Called:
*   Calling:
*
*   Output:     bool
**********************************************************************
*/
bool
check_interrupt()
{
    fix16  flag ;

    flag = int_flag && eable_int ;

    if (flag) {
        GEIio_write(GEIio_stdout, "^C\n", 3) ;
        GEIio_flush(GEIio_stdout) ;
        int_flag = 0 ;
        chint_flag = flag ;
    }

    //return(flag) ;            @WIN; always no interrupt
    return 0;
}   /* check_interrupt */

/*
**********************************************************************
*   Name:       check_Control_C
*   Called:
*   Calling:    -
*
*   Output:     bool
**********************************************************************
*/
bool
check_Control_C()
{
    return(int_flag && eable_int) ;
}   /* check_Control_C */

/*
**********************************************************************
*   Name:       ctrlC_report
*   Called:
*   Calling:    -
*
**********************************************************************
*/
void
ctrlC_report()
{
    int_flag = TRUE ;

    return ;
}   /* ctrlC_report */

/*
**********************************************************************
*
*   This module get a line from the cook buffer.
*         nchar > 0 : OK and return number of character in line,
*                     line delimiter is newline
*         nchar = 0 : no line
*         nchar < 0 : OK and return number of character in line,
*                     line delimiter is Control-D
*
*   Name:       getline
*   Called:
*   Calling:    stream_input
*               line_editor
*               reset_cookbuf
*               create_string
*               strncpy
*
*   Input:      fix16 *
*   Output:     bool
*
*   ?? ^C, ^D, CR
**********************************************************************
*/
bool
getline(nbyte)
fix  FAR *nbyte ;
{
    byte   c1 ;
    struct object_def   l_obj ;

    if (line_del) {
        if (NL_or_EOF == NL_TERM)
            *nbyte = cook_count ;
        else
            *nbyte = -cook_count ;
        return(TRUE) ;
    } else {
        /* ?? Big Change */
        /* Can we get ^C */
        for( ; ;) {
            if( c1 = GEIio_getc(GEIio_stdin) ) {
                switch(line_editor((byte)(c1 & 0xFF))) {
                case 0:             /* edit command char */
                    continue ;

                case 1:             /* NL, CR, or ^C(??) */
                    line_del++ ;
                    NL_or_EOF = NL_TERM ;
                    *nbyte = cook_count ;
                    return(TRUE) ;

                case 2:             /* S/W IOERROR */
                    reset_cookbuf() ;
                    return(FALSE) ;

                case 3:
                    NL_or_EOF = EOF_TERM ;
                    *nbyte = -cook_count ;
                    if (cook_count)
                        line_del++ ;
                    return(TRUE) ;

                case 4:         /* ERROR */
                    break ;
                }   /* switch */
            }

            /*
            * timeout
            * ioerror
            * EOF
            */
            if( ! ANY_ERROR() ) {
                if(cook_count) {
                    line_del++ ;
                    *nbyte = -cook_count ;
                } else
                    *nbyte = 0 ;
                return(TRUE) ;               /* ?? EOF */
            }

            reset_cookbuf() ;
            if( ANY_ERROR() == TIMEOUT ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if (create_string(&l_obj, (ufix16)7)) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            }
            /* ?? need close file */
            return(TRUE) ;
        }   /* for */
    }
}   /* getline */

/*
**********************************************************************
*
*   This module get a char from the cook buffer.
*   The return integer is used as the following descriptions:
*
*            c = -1 : no character in line
*            c = ASCII code (low byte)
*
*   Name:       linegetc
*   Called:
*   Calling:    kgetc
*               reset_cookbuf
*
*   Output:     fix16
*
**********************************************************************
*/
fix16
linegetc()
{
    fix16  c ;

    if (line_del) {
        c = kgetc() ;
        if (!cook_count) {
            line_del-- ;
            reset_cookbuf() ;
        }
        return(c) ;
    } else
        return(-1) ;
}   /* linegetc */

/*
**********************************************************************
*
*   This module get a statement from the cook buffer.
*         nchar > 0 : OK and return number of character in line,
*                     line delimiter is newline
*         nchar = 0 : no line
*         nchar < 0 : OK and return number of character in line,
*                     line delimiter is Control-D
*
*   Name:       getstatement
*   Called:
*   Calling:    stream_input
*               stmt_editor
*               reset_cookbuf
*               create_string
*               strncpy
*
*   Input:      fix *
*   Output:     bool
*
*   ?? ^C, ^D, CR
**********************************************************************
*/
bool
getstatement(nbyte)
fix  FAR *nbyte ;
{
    byte   c1 ;
    struct object_def   l_obj ;

    if (stmt_del) {
        if (NL_or_EOF == NL_TERM)
            *nbyte = cook_count ;
        else
            *nbyte = -cook_count ;
        return(TRUE) ;
    } else {
        for( ; ;) {
            if( c1 = GEIio_getc(GEIio_stdin) ) {
                switch(stmt_editor((byte)(c1 & 0xFF))) {
                case 0:             /* edit command char/special char */
                    continue ;

                case 1:             /* NL, CR, or ^C(flag ??) */
                    stmt_del++ ;
                    NL_or_EOF = NL_TERM ;
                    *nbyte = cook_count ;
                    return(TRUE) ;

                case 2:             /* S/W IOERROR */
                    reset_cookbuf() ;
                    return(FALSE) ;

                case 3:
                    NL_or_EOF = EOF_TERM ;
                    *nbyte = -cook_count ;
                    if (cook_count)
                        stmt_del++ ;
                    return(TRUE) ;

                case 4:         /* ERROR */
                    break ;
                }   /* switch */
            }

            /*
            * timeout
            * ioerror
            * EOF
            */
            if( ! ANY_ERROR() ) {
                if(cook_count) {
                    stmt_del++ ;
                    *nbyte = -cook_count ;
                } else
                    *nbyte = 0 ;
                return(TRUE) ;
            }

            reset_cookbuf() ;
            if( ANY_ERROR() == TIMEOUT ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if (create_string(&l_obj, (ufix16)7)) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            }
            /* ?? need close file */
            return(FALSE) ;
        }   /* for */
    }   /* else */
}   /* getstatement */

/*
**********************************************************************
*
*   This module get a char from the cook buffer.
*   The return integer is used as the following descriptions:
*
*            c = -1 : no character in line
*            c = ASCII code (low byte)
*
*   Name:       statementgetc
*   Called:
*   Calling:    kgetc
*               reset_cookbuf
*
*   Output:     fix16
**********************************************************************
*/
fix16
statementgetc()
{
    fix16  c ;

    if (stmt_del) {
        c = kgetc() ;
        if (!cook_count) {
            stmt_del-- ;
            reset_cookbuf() ;
        }
        return(c) ;
    } else
        return(-1) ;
}   /* statementgetc */

/*
**********************************************************************
*
*   This module is used to set/reset the echo mode.
*
*            mode = 0 :  no echo
*            mode != 0 : echo
*
*   Name:       set_echo
*   Called:
*   Calling:    -
*
*   Input:      bool16
**********************************************************************
*/
void
set_echo(mode)
bool16  mode ;
{
    echo_flag = mode ;

    return ;
}   /* set_echo */

/*
**********************************************************************
*   Name:       reset_cookbuf
*   Called:
*   Calling     -
**********************************************************************
*/
void
reset_cookbuf()
{
    cook_head = cook_tail = line_head = 0 ;
    cook_count = line_count = 0 ;
    lpair = spair = hpair = 0 ;
    comment_flag = bslash_flag = 0 ;

    return ;
}   /* reset_cookbuf */

/*
       *******************************************
       *                                         *
       *  editor related manipulation routines   *
       *                                         *
       *******************************************
*/
/*
**********************************************************************
*   Name:       line_editor
*   Called:
*   Calling:    kputc
*               echo_ctrlR
*               echo_BS
*               kskipc
*               echo_a_char
*
*   Input:      byte
*   Output:     fix
*
*   c != ^C  &&  c != ^D
**********************************************************************
*/
static fix near
line_editor(c)
byte  c ;
{
    switch (c) {
    case Crtl_C_Char :
            if(check_interrupt()) {
                reset_cookbuf();
            }
            kputc((byte)NL_Char) ;
            return(1) ;

    case Crtl_R_Char :
            echo_crtlR() ;
            break ;
    case Crtl_U_Char :
            while( line_count ) {
                echo_BS() ;
                kskipc() ;
            }
            break ;
    case BS_Char :
    case DEL_Char :
            echo_BS() ;
            kskipc() ;
            break ;

    default :
            if (c == NL_Char && crlf_flag) {
                crlf_flag = 0 ;
                return(0) ;
            } else crlf_flag = 0 ;

            if( c == CR_Char ) {
                c = NL_Char ;
                crlf_flag = 1 ;
            }

            if( GEIio_eof(GEIio_stdin) )
                return(3) ;

            kputc(c) ; echo_a_char(c) ;

            if ( c == NL_Char && cook_tail > 1 )
                return(1) ;
            else if (cook_tail > MAXCOOKBUFSZ) {
                ERROR(IOERROR) ;
                return(2) ;
            }
    } /* switch */

    return(0) ;
}   /* line_editor */

/*
**********************************************************************
*   Name:       stmt_editor
*   Called:
*   Calling:    kputc
*               echo_ctrlR
*               echo_BS
*               kskipc
*               echo_a_char
*
*   Input:      byte
*   Output:     bool
*
*   ?? ^C, ^D, CR
*   c != ^C  &&  c != ^D
**********************************************************************
*/
static fix near
stmt_editor(c)
byte  c ;
{
    switch (c) {
    case Crtl_C_Char :
            if(check_interrupt()) {
                reset_cookbuf();
            }
            kputc((byte)NL_Char) ;
            return(1) ;

    case Crtl_R_Char :
            echo_crtlR() ;
            break ;

    case Crtl_U_Char :
            while (line_count) {
                echo_BS() ;
                kskipc() ;
            }
            break ;

    case BS_Char :
    case DEL_Char :
            if( cook_count && (cookbuf[cook_tail - 1] == NL_Char) ) {
                fix16  i, back ;

                kskipc() ;
                back = cook_tail - 1 ;
                while (1) {
                    if (back == cook_head)
                        break ;
                    else if( cookbuf[back] == NL_Char ) {
                        back++ ; break ;
                    } else
                        back-- ;
                }   /* while */
                GEIio_putc(GEIio_stdout, NL_Char) ;
                for (i = back ; i < cook_tail ; i++)
                    echo_a_char(cookbuf[i]) ;
                line_count = cook_tail - back ;
                line_head = back ;
            } else {
                echo_BS() ; kskipc() ;
            }
            break ;

    default:
            if (c == NL_Char && crlf_flag) {
                crlf_flag = 0 ;
                return(0) ;
            } else crlf_flag = 0 ;

            if( c == CR_Char ) {
                c = NL_Char ;
                crlf_flag = 1 ;
            }

            if( GEIio_eof(GEIio_stdin) )
                return(3) ;

            kputc(c) ; echo_a_char(c) ;

            if (cook_tail > MAXCOOKBUFSZ) {
                ERROR(IOERROR) ;
                return(2) ;
            }
            if (hpair) {
                switch (c) {
                case '>' :
                     hpair-- ;
                     break ;
                case NL_Char:
                     line_count = 0 ;
                     line_head = cook_tail ;
                     break ;
                default :
                     if (!ISHEXDIGIT(c) && !ISWHITESPACE(c))
                        hpair-- ;
                     break ;
                } /* switch */
            } else {
                switch (c) {
                case '(' :
                    if (!comment_flag && !bslash_flag)
                        spair++ ;
                    break ;
                case ')' :
                    if (!comment_flag && !bslash_flag)
                        spair-- ;
                    break ;
                case '{' :
                    if (spair <= 0 && !comment_flag)
                        lpair++ ;
                    break ;
                case '}' :
                    if (spair <= 0 && !comment_flag)
                        lpair-- ;
                    break ;
                case '<' :
                    if (spair <= 0 && !comment_flag)
                        hpair++ ;
                    break ;
                case '%' :
                    if (spair <= 0 && !comment_flag)
                        comment_flag++ ;
                    break ;
                case '\\' :
                    if (!comment_flag && spair && !bslash_flag)
                        bslash_flag += 2 ;
                    break ;
                case '\f' :
                    if (comment_flag)
                        comment_flag-- ;
                    break ;
                case NL_Char:
                    if (comment_flag)
                        comment_flag-- ;
                    if (lpair <= 0 && spair <= 0)
                        return(1) ;
                    else {
                        line_count = 0 ;
                        line_head = cook_tail ;
                    }
                default :
                    break ;
                } /* switch */
                if (bslash_flag)
                    bslash_flag-- ;
            }   /* else */
    }   /* switch */

    return(0) ;
} /* stmt_editor */

/*
**********************************************************************
*   Name:       kputc
*   Called:
*   Calling:
**********************************************************************
*/
static void near
kputc(c)
byte  c ;
{
    if (cook_tail <= MAXCOOKBUFSZ) {
        cookbuf[cook_tail++] = c ;
        cook_count++ ; line_count++ ;
    }

    return ;
}   /* kputc */

/*
**********************************************************************
*   Name:       kgetc
*   Called:
*   Calling:    -
**********************************************************************
*/
static fix16 near
kgetc()
{
    if (cook_count) {
        cook_count-- ;
        return(cookbuf[cook_head++]) ;
    } else
        return(-1) ;
} /* kgetc */

/*
**********************************************************************
*   Name:       kskipc
*   Called:
*   Calling:    -
**********************************************************************
*/
static void near
kskipc()
{
    byte  c ;

    if (cook_count) {
        c = cookbuf[cook_tail - 1] ;
        switch (c) {
        case '{' :
            if (!spair)
                lpair-- ;
            break ;
        case '}' :
            if (!spair)
                lpair++ ;
            break ;
        case '(' :
        case ')' :
        {
            fix16  i, j, k ;
            if (cook_count > 1 && cookbuf[cook_tail - 2] == '\\') {
                for (i = cook_head, j = cook_tail - 1, k = 0 ; i < j ; i++)
                    if (cookbuf[i] == '(')
                        k++ ;
                if (!k) {
                    if (c == '(')
                        spair-- ;
                    else
                        spair++ ;
                }
            } else {
                if (c == '(')
                    spair-- ;
                else
                    spair++ ;
            }
            break ;
        }
        case '<' :
            if (!spair)
                hpair-- ;
        default :
            break ;
        }   /* switch */
        cook_tail-- ;
        cook_count-- ; line_count-- ;
    }

    return ;
}   /* kskipc */

/*
**********************************************************************
*   Name:       echo_a_char
*   Called:
*
*   Input:      byte
**********************************************************************
*/
static void near
echo_a_char(c)
byte  c ;
{
    if (echo_flag) {
        if (c == EOF_Char)
            return ;
        if ( ((ubyte)c > US_Char) || (c == '\t') || (c == '\n') )
            GEIio_putc(GEIio_stdout, c) ;
        else {
            c = c + (byte)64 ;          //@WIN
            GEIio_putc(GEIio_stdout, '^') ;
            GEIio_putc(GEIio_stdout, c) ;
        }
        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_a_char */

/*
**********************************************************************
*   Name:       echo_BS
*   Called:
**********************************************************************
*/
static void near
echo_BS()
{
    byte  c ;

    if (echo_flag) {
        if (line_count) {
            if ((c = cookbuf[cook_tail - 1]) > US_Char || c == '\t') {
                GEIio_write(GEIio_stdout, "\010 \010", 3) ;
            } else {         /* control chars */
                GEIio_write(GEIio_stdout, "\010 \010\010 \010", 6) ;
            }
        } else
            GEIio_putc(GEIio_stdout, BELL_Char) ;

        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_BS */

/*
**********************************************************************
*   Name:       echo_ctrlR
*   Called:
*               echo_a_char
**********************************************************************
*/
static void near
echo_crtlR()
{
    fix16  i, j ;

    if (echo_flag) {
        GEIio_putc(GEIio_stdout, NL_Char) ;
        for (i = 0, j = line_head ; i < line_count ; i++, j++)
            echo_a_char(cookbuf[j]) ;

        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_crtlR */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\blib.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              BLIB.C
 *
 * revision history:
 *    04-07-92   SCC   Move out fardata() to setvm.c
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include "global.ext"

#ifdef _AM29K
#include        <stdarg.h>
#include        <float.h>
#define va_dcl va_list va_alist ;
#endif  /* _AM29K */

#ifndef NULL
#define NULL    0
#endif

/*
 * added by M. S. Lin, Date : 11/20/87
 *                            1/14/88  fardata()
 */
/* ************************************************************************ *
 *                                                                          *
 *   Module : fardata                                                       *
 *                                                                          *
 *   Date   : Jan. 8, 1988     By  M. S. Lin                                *
 *                                                                          *
 *   Function : Allocates a memory block of at least size bytes.            *
 *                                                                          *
 *   Declaration : ubyte        far  *fardata(unsigned long) ;               *
 *                 ( in \pdl\include\global.ext )                           *
 *                                                                          *
 *   Call     : fardata(size)                                               *
 *                                                                          *
 *   Input    : unsigned long size of bytes                                 *
 *                                                                          *
 *   Return Value : The storage space pointed to by the return value is     *
 *                  guaranteed to be suitably aligned for storage of        *
 *                  any type of object. To get a pointer to a type other    *
 *                  than char, use a type cast on the return value.         *
 *                  Return 4 bytes far pointer with allignment to even      *
 *                  address if successful.                                  *
 *                  Return NULL if insufficient memory.                     *
 *                                                                          *
 *   Example : allocate space for 20 integers array.                        *
 *                                                                          *
 *      #include        "..\..\include\global.ext"                          *
 *      int  far   *intarray ;                                               *
 *                                                                          *
 *      intarray = (int far *)fardata(20 * sizeof(int)) ;                    *
 *                                                                          *
 *   Note : You must use as far pointer, otherwise will get the wrong       *
 *          pointer since compiler option /AM will be used.                 *
 *                                                                          *
 * ************************************************************************ */

#ifdef LINT_ARGS
static  byte FAR * near  printfield(byte FAR *, ufix32, ufix32, ufix32) ;
#else
static  byte FAR * near  printfield() ;
#endif /* LINT_ARGS */

/* @WIN move this function to "setvm.c" for function consistency */
#ifdef XXX
byte FAR *
fardata(size)
ufix32  size ;
{
    ufix32  ret_val, old_ptr, p1 ;
    fix32   l_diff ;

#ifdef DBG
   printf("Fardata(%lx): old fardata_ptr=%lx\n", size, fardata_ptr) ;
#endif

    old_ptr = fardata_ptr ;

   /*
    * make sure even allignment, allocate at least size bytes
    */
    size = WORD_ALIGN(size) ;

#ifdef  SOADR
   /*
    * if size > 0xfff0, make paragraph allignment, i.e, offset = 0
    * for cannonical form
    */
    if ((size > 0xfff0L) && (fardata_ptr & 0xf))
       fardata_ptr = (fardata_ptr & 0xffff0000) + 0x10000L ;
#endif  /* SOADR */

   /*
    * save current location as return value if successful
    */
    ret_val = fardata_ptr ;

    DIFF_OF_ADDRESS(l_diff, fix32, FARDATA_END, fardata_ptr) ;
    if (l_diff <= size) {
       fardata_ptr = old_ptr ;
       printf("Fatal Error : fardata() cannot allocate enough memory\n") ;
       return(NULL) ;
    } else {
       fardata_ptr += size ;
       ADJUST_SEGMENT(fardata_ptr, p1) ;
       fardata_ptr = p1 ;
#ifdef  DBG
   printf("\n\tfardata() : allocate address = %lx\n", ret_val) ;
   printf("\t                     size    = %lx\n", size) ;
#endif
      return((byte FAR *)ret_val) ;
    }
}   /* fardata() */
#endif

static byte far  digit[] =
{
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
    'W','X','Y','Z'
} ;

static byte FAR * near
printfield(cursor, number, divide, radix)
byte      FAR *cursor ;
ufix32    number ;
ufix32    divide ;
ufix32    radix ;
{
    byte      c ;
    fix       notzero = 0 ;

    for ( ; divide >= 1L ;) {
        c = digit[(fix)(number / divide)] ;
        if (c != '0' || notzero) {
           notzero = 1 ;
           *cursor++ = c ;
        }
        number = number % divide ;
        divide = divide / radix ;
    }

    if (!notzero)
       *cursor++ = '0' ;

    return(cursor) ;
}   /* printfield() */

/*
 ***************************************
 *                                     *
 *     gcvt()                          *
 *                                     *
 ***************************************
 */
byte FAR *
gcvt(val, sig, buf)
real64 val ;
fix    sig ;       /* no used, it is always 6 in following using */
byte   FAR *buf ;
{
    fix    sign, exp ;
    fix32  long_val, base ;
    byte   FAR *dest, FAR *src, FAR *end_ptr ;

    /* get absolute value */
    if (val == (real64)0.0) {
       lstrcpy(buf, (byte FAR *)"0.0") ;            /* @WIN */
       return(buf) ;
    } else if (val > (real64)0.0)
       sign = 0 ;
    else {
       sign = 1 ;
       val = -val ;
    }

    /* get EXP value */
    exp = 0 ;
    if (val >= (real64)10000000.0)
       while ((real32)val >= (real32)10000000.0) {
             val /= 10.0 ;
             exp++ ;
       }
    else
       while ((real32)val < (real32)1000000.0) {
             val *= 10.0 ;
             exp-- ;
       }
    exp += 6 ;

    /* insert sign byte */
    dest = buf ;
    if (sign == 1) {
       *dest = '-' ;
       dest++ ;
    }
    *dest = '.' ;

    /* transform into string */
    long_val = (fix32)val ;
    base = 1000000 ;
    while (base > 0) {
          dest++ ;
          *dest = (byte)((long_val / base) + '0') ;
          long_val %= base ;
          base /= 10 ;
    } /* get precision = 7 */

    end_ptr = dest ;
    /* reduce precision */
    if (*dest >= '5') {
       do {
          *dest = '0' ; dest-- ;
       } while (*dest == '9') ;
       if (*dest != '.')
          (*dest)++ ;
       else { /* carrying... */
          exp++ ;
          *(++dest) = '1' ;
          *(++dest) = '0' ;
       }
    }

    /* expand EXP +5 -- -4 */
    if (exp < 6 && exp > -5) {
       if (exp > 0) { /* expand +5 -- +1 (change "." position) */
          if (exp == 5)
             end_ptr++ ;
          dest = buf ;
          if (*dest == '-')
             dest++ ;
          while (exp >= 0) {
                *dest = *(dest + 1) ;
                dest++ ;
                exp-- ;
          }
          *dest = '.' ;
          exp++ ;
       } /* if */
       else if (exp < 0) { /* expand -4 -- -1 */
          src = dest = end_ptr ;
          dest -= exp ;
          end_ptr = dest ;
          while (*src != '.')
                *dest-- = *src-- ;
          while (exp < -1) {
                *dest-- = '0' ;
                exp++ ;
          }
          *src++ = '0' ;
          *src = '.' ;
          exp++ ;
       } else { /* EXP 0 */
           dest = buf ;
           if (*buf == '-')
              dest++ ;
           *dest = *(dest + 1) ;
           dest++ ;
           *dest = '.' ;
       }
    } else {
       dest = buf ;
       if (*buf == '-')
          dest++ ;
       *dest = *(dest + 1) ;
       dest++ ;
       *dest = '.' ;
    }

    src = end_ptr ;
    src-- ;

    if (*src == '0') { /* suppress tailing 0 */
       src-- ;
       while (*src == '0')
             src-- ;
       if (*src == '.')
          if (exp)     /* exp != 0 */
             src-- ;
          else         /* leave one '0' in exp == 0 */
             src++ ;
    }
    src++ ;

    if (exp == 0) {
       *src = '\0' ;
       return(buf) ;
    }

    dest = src ;
    /* append EXP into string */
    *dest = 'e' ;
    dest++ ;

    if (exp > 0)
       *dest = '+' ;
    else {
       *dest = '-' ;
       exp = -exp ;
    }

    *(++dest) = (byte )('0' + exp / 10) ;
    *(++dest) = (byte )('0' + exp % 10) ;
    *(++dest) = (byte )'\0' ;

    return(buf) ;
}   /* gcvt() */

byte FAR *ltoa(number, buffer, radix)
fix32 number ;
byte FAR *buffer ;
fix   radix ;
{
    byte       FAR *cursor ;
    ufix32     divide, maxdiv ;

    cursor = buffer ;
    if ( (number < 0) && (radix == 10) ) {
        number = -number ;
        *cursor++= '-' ;
    }

    divide = 1 ;
    maxdiv = MAX31 / radix ;

    while(divide < maxdiv)
        divide *= radix ;

    cursor = printfield(cursor, (ufix32)number, divide, (ufix32)radix) ;
    *cursor = '\0' ;

    return(buffer) ;
}   /* *ltoa() */

real64 strtod(str, endptr)
char FAR *str ;
char FAR * FAR *endptr ;
{
    fix     i, eminus ,minus ;
    real64  eresult, result ,exp_10, float10 ;
    byte    FAR *nptr ;

    eminus = minus = 0 ;
    nptr = str ;
    result = eresult = 0 ;
    float10 = .1 ;
    exp_10 = 1 ;

l1:
    if (*nptr == ' ') {
        nptr++ ;
        goto l1 ;
    }

    if (*nptr == '-' ) {
        minus++ ;
        nptr++ ;
    } else if (*nptr == '+') {
        nptr++ ;
    }

l2:
    if (*nptr >= 48 && *nptr <= 57) {
        result = result * 10 + (*nptr) - 48 ;
        nptr++ ;
        goto l2 ;
    } else if (*nptr == '.') {
        nptr++ ;
    }

l3:
    if (*nptr >= 48 && *nptr <= 57) {
        result = result + ((*nptr) - 48) * float10 ;
        float10 = float10 / 10 ;
        nptr++ ;
        goto l3 ;
    }

    if (*nptr == 'e' || *nptr == 'E' || *nptr == 'd' || *nptr == 'D') {
        nptr++ ;
    }

    if (*nptr == '-' ) {
        eminus++ ;
        nptr++ ;
    } else if (*nptr == '+') {
        nptr++ ;
    }

l4:
    if (*nptr >= 48 && *nptr <= 57) {
        eresult = eresult * 10 + (*nptr) - 48 ;
        nptr++ ;
        goto l4 ;
    }

    for (i = 1 ; i <= (int)eresult ; i++) {       /* @WIN; add cast */
        exp_10 = exp_10 * 10 ;
    }

    if (eminus)
        exp_10 = 1/exp_10 ;

    result = result * exp_10 ;

    if (minus)
        result = -result ;

    *endptr = nptr ;

    return result ;
}   /* strtod() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\array.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              ARRAY.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/***********************************************************************
**
** This operator is used to create an array of length num, each of
** whose elements is initialized with a null object, and pushes this
** string on the operand stack. The num operand must be a non-negative
** integer not greater than the maximum allowable array length.
**
** TITLE:       op_array                    Date:   08/01/87
** CALL:        op_array()                  UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS        create_array:   5.3.1.3.1.1
***********************************************************************/
fix
op_array()
{
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) )
        ERROR(RANGECHECK) ;
    /*
     *  this operand must be a non-negative integer and not greater
     *  than the maximum allowable array length
     */
    else
        if( create_array(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;

    return(0) ;
}   /* op_array */

/***********************************************************************
**
** This operator is used to push a mark object on the operand stack.
**
** TITLE:       op_l_bracket                Date:   08/01/87
** CALL:        op_l_bracket()              UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_l_bracket()
{
    if( FRCOUNT() < 1  )
        ERROR(STACKOVERFLOW) ;
    else
        /*  push 'markobj' to operand stack */
        PUSH_VALUE(MARKTYPE, 0, LITERAL, 0, LEFTMARK) ;

    return(0) ;
}   /* op_l_bracket */

/***********************************************************************
**
**  This operator is used to create a new array of n elements, where n is
**  the number of elements above the topmost mark on the operand stack,
**  store those elements into the array, and return the array on the
**  operand stack.The R_bracket_op operator stores the topmost object
**  from the stack into element n-1 of array and the bottommost one into
**  element 0 of array. It removes all the array elements from the stack,
**  as well as the mark object.
**
** TITLE:       op_r_bracket                Date:   08/01/87
** CALL:        op_r_bracket()              UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       alloc_vm:       5.3.1.10.5
***********************************************************************/
fix
op_r_bracket()
{
    fix     l_i, l_j ;
    ubyte   FAR *l_array ;
    struct  object_def  huge *l_temp ;

    for (l_i = 0 ; (ufix)l_i < COUNT() ; l_i++) {       //@WIN
        /*
         *   SEARCH FIRST LEFT MARK && count l_i
         */
        if( (TYPE_OP(l_i) == MARKTYPE) &&
            (VALUE_OP(l_i) == LEFTMARK) ) {
            if(l_i == 0)
                l_array = NIL ;
            else {  /* l_i > 0 */
                l_array = (ubyte FAR *)extalloc_vm((ufix32)l_i *
                                   sizeof(struct object_def)) ;
                if( (l_array != NIL) ) {
                    /*
                     *   BUILD 'ary_obj'
                     *
                     *  array: from bottom to top(l_k)
                     *  stack: from top to bottom(l_j)
                     */
                    l_temp = (struct object_def huge *)l_array + (l_i - 1) ;
                    for(l_j = 0 ; l_j < l_i ; l_j++, l_temp--) {
                        COPY_OBJ( GET_OPERAND(0),
                                  (struct object_def FAR *)l_temp ) ;
                        LEVEL_SET(l_temp, current_save_level) ;
                        POP(1) ;
                    }
                } else
                    return(0) ;         /* VMERROR */
            }   /* else */

            POP(1) ;                    /* pop left mark */
            PUSH_VALUE(ARRAYTYPE, UNLIMITED, LITERAL, l_i, l_array) ;
            return(0) ;
        }    /* if */
    }   /* for(l_i) */

    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_r_bracket */

/***********************************************************************
**
** This operator is used to create a new array or string object whose
** value consists of some subsequence of the original array or string.
** The subsequence consists of count elements starting at the specified
** index in the original array or string. The elements in the subsequence
** are shared between the original and new objects.
**
** Getinterval_op requires index to be a valid index in the original array
** or string and count to be a non-negative integer such that index+count
** is not greater than the length of the original array or string.
**
** TITLE:       op_getinterval                  Date:   08/01/87
** CALL:        op_getinterval()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              getinterval_array:  5.3.1.3.7.1
**              getinterval_string: 5.3.1.5.12
***********************************************************************/
fix
op_getinterval()
{
    ufix16  l_index, l_count ;
    struct  object_def  l_save ;
    bool    l_bool = FALSE ;

    if( ((fix32)VALUE_OP(1) < 0) ||
        ((ufix32)VALUE_OP(1) > MAXARYCAPSZ) ||
        ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    /* executeonly or noaccess */
    if( ACCESS_OP(2) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
    } else {
        l_index = (ufix16)VALUE_OP(1) ;
        l_count = (ufix16)VALUE_OP(0) ;
        if( TYPE_OP(2) == STRINGTYPE )
            l_bool = getinterval_string(GET_OPERAND(2), l_index,
                                        l_count, &l_save ) ;
        else
            l_bool = getinterval_array(GET_OPERAND(2), l_index,
                                        l_count, &l_save ) ;
    }
    /*
     *  SUCCESS
     */
    if(  ! ANY_ERROR() && l_bool ) {
        POP(3) ;
        PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }

    return(0) ;
}   /* op_getinterval */

/***********************************************************************
**
**  This operator is used to replace a subsequence of the elements of
**  the first array or string by the entire contents of the second
**  array or string. The subsequence that is replaced begins at the
**  specified index in the first array or string ; its length is the
**  same as the length of the second array or string.
**
**  Putinterval_op requires index to be a valid index in ary_str1 such
**  that index plus the length of ary_str2 is not greater than the length
**  of ary_str1.
**
** TITLE:       op_putinterval                  Date:   08/01/87
** CALL:        op_putinterval()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              putinterval_array:  5.3.1.3.8.1
**              putinterval_string: 5.3.1.5.13
***********************************************************************/
fix
op_putinterval()
{
    bool    l_bool ;
    ufix16  l_index ;

    /* index */
    if( ((fix32)VALUE_OP(1) < 0) ||
        ((ufix32)VALUE_OP(1) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    /* executeonly or noaccess */
    if( (ACCESS_OP(2) != UNLIMITED) ||
        (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_index = (ufix16)VALUE_OP(1) ;

    if( TYPE_OP(0) == STRINGTYPE )
        l_bool = putinterval_string( GET_OPERAND(2),
                                     l_index, GET_OPERAND(0) ) ;
    else
        l_bool = putinterval_array( GET_OPERAND(2),
                                    l_index, GET_OPERAND(0) ) ;

    /* SUCCESS */
    if( (! ANY_ERROR()) && l_bool )
        POP(3) ;

    return(0) ;
}   /* op_putinterval */

/***********************************************************************
**
** This operator is used to push all n elements of array on the operand
** stack successively, and finally push array itself.
**
** TITLE:       op_aload                        Date:   08/01/87
** CALL:        op_aload()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_pk_object:      5.3.1.3.25
***********************************************************************/
fix
op_aload()
{
    ubyte   FAR *l_pointer ;
    ufix16  l_index, l_length ;
    struct  object_def  l_save ;
    struct  object_def  FAR *l_array, huge *l_temp ;

    /* executeonly or noaccess */
    if( ACCESS_OP(0) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if((ufix)FRCOUNT() <= LENGTH_OP(0)) { /* cauesd by opn_stack is 501 @WIN*/
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    l_length = LENGTH_OP(0) ;
    l_array = (struct object_def FAR *)VALUE_OP(0) ;
    COPY_OBJ(GET_OPERAND(0), &l_save) ;     /* save this array object */
    POP(1) ;

    /* push object to operand stack */
    if(TYPE(&l_save) == ARRAYTYPE) {
        for(l_index = 0, l_temp = l_array ; l_index++ < l_length ; l_temp++)
                PUSH_ORIGLEVEL_OBJ((struct object_def FAR *)l_temp) ;
#ifdef  DBG
    printf("ALOAD<level:%d>\n", LEVEL(l_temp)) ;
#endif  /* DBG */
    } else {
        for(l_index = 0, l_pointer = (ubyte FAR *)l_array ; l_index++ < l_length ; )
/* qqq, begin */
            /*
            l_pointer = get_pk_object(l_pointer, &opnstack[opnstktop++], LEVEL(&l_save)) ;
            */
        {
            l_pointer = get_pk_object(l_pointer, opnstkptr, LEVEL(&l_save)) ;
            INC_OPN_IDX();
        }
/* qqq, end */
    }

    PUSH_ORIGLEVEL_OBJ(&l_save) ;

    return(0) ;
}   /* op_aload */

/***********************************************************************
**
** This operator is used to store the object any0 through any(n-1) from
** the operand stack into array, where n is the length of array. The
** Astore_op operator first removes the array operand from the stack and
** determines its length. It then removes that number of objects from
** the stack, storing the topmost one into element n-1 of array and the
** bottonmost one into element 0 of array. Finally, it pushes array back
** on the stack.
**
** TITLE:       op_astore                       Date:   08/01/87
** CALL:        op_astore()                     UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       astore_array:   5.3.1.3.18
***********************************************************************/
fix
op_astore()
{
    struct  object_def  l_save ;

    if( COUNT() <= LENGTH_OP(0) ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( ACCESS_OP(0) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_save) ;
    POP(1) ;                                      /* pop array object */

    astore_array(&l_save) ;
    PUSH_ORIGLEVEL_OBJ(&l_save) ;

    return(0) ;
}   /* op_astore */

/***********************************************************************
**
** TITLE:       getinterval_array               Date:   08/01/87
** CALL:        getinterval_array()             UpDate: Jul/12/88
** INTERFACE:   op_getinterval: 5.3.1.3.7
** CALLS:       get_pk_array:   5.3.1.3.26
***********************************************************************/
bool
getinterval_array(p_array, p_index, p_count, p_retobj)
struct  object_def  FAR *p_array, FAR *p_retobj ;
ufix  p_index, p_count ;
{
    struct  object_def  huge *l_temp ;

    /*
    **  index must be a valid index in the original array and
    **  count to be a non-negative integer, and index+count is not
    **  greater than the length of the original array
    */
    if( ((ufix32)p_count + p_index) > LENGTH(p_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (struct object_def huge *)VALUE(p_array) ;

    if(TYPE(p_array) == ARRAYTYPE)
        l_temp += p_index ;
    else
        l_temp = (struct object_def huge *)get_pk_array((ubyte FAR*)l_temp, p_index) ;
   /*
    **  MAKE A NEW OBJECT
    */
    COPY_OBJ(p_array, p_retobj) ;
    VALUE(p_retobj) = (ULONG_PTR)l_temp ;
    /* LEVEL(p_retobj) = current_save_level ; */
    LENGTH(p_retobj) = (ufix16)p_count ;

    return(TRUE) ;
}   /* getinterval_array */

/***********************************************************************
**
** TITLE:       putinterval_array               Date:   08/01/87
** CALL:        putinterval_array()             UpDate: Jul/12/88
** INTERFACE:   op_putinterval:         5.3.1.3.8
**              op_copy:                5.3.1.1.4
** CALLS:       create_new_saveobj:     5.3.1.1.12
**              get_pk_object:          5.3.1.3.25
***********************************************************************/
bool
putinterval_array(p_d_array, p_index, p_s_array)
struct  object_def  FAR *p_s_array, FAR *p_d_array ;
ufix  p_index ;
{
    fix     l_i, l_length ;
    struct  object_def  huge *l_sptr, huge *l_dptr ;

    l_length = LENGTH(p_s_array) ;

    /*
    **  index to be a valid index in array1, index plus the length
    **  of p_d_array is not greater than the length of p_s_array
    */
    /* ?? if overflow */
    if( ((ufix32)p_index + l_length) > LENGTH(p_d_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_dptr = (struct object_def huge *)VALUE(p_d_array) + p_index ;

    l_sptr = (struct object_def huge *)VALUE(p_s_array) ;

    /* SOURCE ARRAY ==> DESTINATION ARRAY */
    if(TYPE(p_s_array) == ARRAYTYPE) {
        /* Apr-29-88 by PJSu, whether save or not */
        /* 10-24-1990 by Erik */
        if ((l_sptr + l_length) < l_dptr) {
            for(l_i = 0 ; l_i < l_length ; l_i++, l_sptr++, l_dptr++) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_dptr) != current_save_level )
                if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                    if(! save_obj(l_dptr) ) return(FALSE) ;
                COPY_OBJ( (struct object_def FAR *)l_sptr,
                          (struct object_def FAR *)l_dptr ) ;
                //DJC UPD046
                LEVEL_SET(l_dptr, current_save_level);
            }   /* for */
        } else {
            l_sptr += l_length - 1 ;
            l_dptr += l_length - 1 ;
            for(l_i = l_length ; l_i > 0 ; l_i--, l_sptr--, l_dptr--) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_dptr) != current_save_level )
                if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                    if(! save_obj(l_dptr) ) return(FALSE) ;
                COPY_OBJ( (struct object_def FAR *)l_sptr,
                          (struct object_def FAR *)l_dptr ) ;
                //DJC UPD046
                LEVEL_SET(l_dptr, current_save_level);
            }   /* for */
        }
    } else {
        for(l_i = 0 ; l_i < l_length ; l_i++, l_dptr++) {
// DJC signed/unsigned mismatch warning
// DJC      if( LEVEL(l_dptr) != current_save_level )
            if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                if(! save_obj(l_dptr) ) return(FALSE) ;
            l_sptr = (struct object_def huge *)get_pk_object((ubyte FAR*)l_sptr, l_dptr, LEVEL(p_s_array)) ;

            //DJC UPD046
            LEVEL_SET(l_dptr, current_save_level);
        }
    }

    return(TRUE) ;
}   /* putinterval_array */

/***********************************************************************
**
** TITLE:       forall_array                    Date:   08/01/87
** CALL:        forall_array()                  UpDate: Jul/12/88
** INTERFACE:   op_forall:      5.3.1.4.13
***********************************************************************/
bool
forall_array(p_array, p_proc)
struct  object_def  FAR *p_array, FAR *p_proc ;
{
    if( FREXECOUNT() < 3 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_OBJ(p_array) ;
    PUSH_EXEC_OP(AT_ARRAYFORALL) ;

    return(TRUE) ;
}   /* forall_array */

/***********************************************************************
**
** TITLE:       create_array                    Date:   08/01/87
** CALL:        create_array(obj, size)         UpDate: Jul/12/88
** INTERFACE:   op_array:       5.3.1.3.1
** CALLS:       alloc_vm:       5.3.1.10.5
***********************************************************************/
bool
create_array(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix  p_size ;
{
    ubyte   FAR *l_array ;
    ufix16  l_i  ;
    struct  object_def  huge *l_temp ;

    if( p_size != 0 ) {
        l_array = (ubyte FAR *)extalloc_vm( (ufix32)p_size *
                                         sizeof(struct object_def) ) ;
        if(l_array != NIL) {
            l_temp = (struct object_def huge *)l_array ;
            for(l_i=0 ; l_i < p_size ; l_i++, l_temp++) {
                TYPE_SET(l_temp, NULLTYPE) ;
                LEVEL_SET(l_temp, current_save_level) ;
                ROM_RAM_SET(l_temp, RAM) ;

                //UPD057
                P1_ATTRIBUTE_SET( l_temp, P1_LITERAL);
                LENGTH(l_temp) = 0;

            }
        } else
            return(FALSE) ;
    } else
        l_array = NULL_OBJ ;

    TYPE_SET(p_obj, ARRAYTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = (ufix16)p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_array ;

    return(TRUE) ;
}   /* create_array */

/***********************************************************************
**
** This function is used to copy objects from operand stack to
** an empty array.
**
** TITLE:       astore_array                    Date:   08/01/87
** CALL:        astore_array(p_array)           UpDate: Jul/12/88
** INTERFACE:   op_astore:      5.3.1.3.10
***********************************************************************/
bool
astore_array(p_array)
struct  object_def  FAR *p_array ;
{
    ufix16  l_length, l_i ;

    l_i = l_length = LENGTH(p_array) ;
    while (l_length--) {
          put_array(p_array, --l_i, GET_OPERAND(0)) ;
          POP(1) ;
    }

    return(TRUE) ;
}   /* astore_array */

/***********************************************************************
**
** TITLE:       get_array                   Date:   08/01/87
** CALL:        get_array()                 UpDate: Jul/12/88
** PARAMETERS:
** INTERFACE:   op_get:             5.3.1.4.9
** CALLS:       get_pk_array:       5.3.1.3.26
**              get_pk_object:      5.3.1.3.25
***********************************************************************/
bool
get_array(p_array, p_index, p_any)
struct  object_def  FAR *p_array, FAR *p_any ;
ufix  p_index ;
{
    struct  object_def  huge *l_temp ;

    l_temp = (struct object_def huge *)VALUE(p_array) ;

    if(TYPE(p_array) == ARRAYTYPE) {
        l_temp += p_index ;
        COPY_OBJ( (struct object_def FAR *)l_temp, p_any ) ;
    } else
        get_pk_object(get_pk_array((ubyte FAR *)l_temp, p_index), p_any,
                                   LEVEL(p_array)) ;

    return(TRUE) ;
}   /* get_array */

/***********************************************************************
**
** TITLE:       put_array                   Date:   08/01/87
** CALL:        put_array()                 UpDate: Jul/12/88
** INTERFACE:   op_put:     5.3.1.4.10
***********************************************************************/
bool
put_array(p_array, p_index, p_any)
struct  object_def  FAR *p_array, FAR *p_any ;
ufix  p_index ;
{
    struct  object_def  huge *l_temp ;

    /*  readonly ? executeonly ? noaccess ? */
    if( ACCESS(p_array) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    /* the index is greater than the array length */
    if( p_index >= LENGTH(p_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (struct object_def huge *)VALUE(p_array) + p_index ;
// DJC signed/unsigned mismatch warning
// DJC if( LEVEL(l_temp) != current_save_level )
    if( (ufix16)(LEVEL(l_temp)) != current_save_level )
        if(! save_obj(l_temp) ) return(FALSE) ;
    COPY_OBJ( p_any, (struct object_def FAR *)l_temp ) ;
    LEVEL_SET(l_temp, current_save_level) ;

    return(TRUE) ;
}   /* put_array */

/***********************************************************************
**
** TITLE:       op_setpacking               Date:   08/01/87
** CALL:        op_setpacking()             UpDate: Jul/12/88
** INTERFACE:   interpreter:
** History: Add compile option for NO packing, 11-24-88
***********************************************************************/
fix
op_setpacking()
{
#ifdef  NOPK
    packed_flag = (bool8)FALSE ;
#else
    packed_flag = (bool8)VALUE_OP(0) ;
#endif  /* NOPK */
    POP(1) ;

    return(0) ;
}   /* op_setpacking */

/***********************************************************************
**
** TITLE:       op_currentpacking           Date:   08/01/87
** CALL:        op_currentpacking()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_currentpacking()
{
    if( FRCOUNT() < 1  )
        ERROR(STACKOVERFLOW) ;
    else {
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, (ufix32)packed_flag) ;
    }

    return(0) ;
}   /* op_currentpacking */

/***********************************************************************
**
** TITLE:       op_packedarray              Date:   08/01/87
** CALL:        op_packedarray()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_pk_array:    5.3.1.3.24
***********************************************************************/
fix
op_packedarray()
{
#ifndef NOPK
    ufix16  l_n ;
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    l_n = (ufix16)VALUE_OP(0) ;
// DJC signed/unsigned mismatch
// DJC    if( l_n > COUNT() - 1 ) {
    if( l_n > (ufix16)(COUNT() - 1 )) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    /*
     *  this operand must be a non-negative integer and not greater
     *  than the maximum allowable array length
     */
    if( create_pk_array(&l_save, (ufix16)l_n) ) {
        POP(l_n + 1) ;
        PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }
#endif  /* NOPK */

    return(0) ;
}   /* op_packedarray */

/***********************************************************************
**
** THis function is used to create a packed array with n objects.
**
** TITLE:       create_pk_array                  Date:   08/01/87
** CALL:        create_pk_array()                UpDate: Jul/12/88
** INTERFACE:   op_packedarray:     5.3.1.3.23
***********************************************************************/
bool
create_pk_array(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix16  p_size ;
{
    fix     l_objsize ;
    ufix16  l_i ;
    ULONG_PTR   l_value;
    ufix32  l_vmsize, l_j ;
    ubyte   huge *l_array, huge *l_pointer ;

    if(p_size == 0)
        l_array = NULL_OBJ ;
    else {
        l_vmsize = 0 ;
        for(l_i=p_size ; l_i>0 ; l_i-- ) {   /* l_i > 0 */
            l_value = VALUE_OP(l_i) ;
            switch(TYPE_OP(l_i)) {
                case INTEGERTYPE:
                    if( ((fix32)l_value < -1) ||        /* ?? 0 ~ 31 */
                        ((fix32)l_value > 18) ) {
                        l_objsize = PK_C_SIZE ;
                        break ;
                    }
                case BOOLEANTYPE:
                    l_objsize = PK_A_SIZE ;
                    break ;

                case NAMETYPE:
                case OPERATORTYPE:
                    l_objsize = PK_B_SIZE ;
                    break ;

                case REALTYPE:
                case NULLTYPE:
                case FONTIDTYPE:
                case MARKTYPE:
                case SAVETYPE:
                    l_objsize = PK_C_SIZE ;
                    break ;

                default:
                    l_objsize = PK_D_SIZE ;

            }   /* switch */
            l_vmsize += l_objsize ;
        }   /* for */
        l_array = (ubyte huge *)extalloc_vm(l_vmsize) ;

        if( (l_array != NIL) ) {
            /*
             *   BUILD 'ary_obj'
             */
            l_pointer = l_array ;
            for(l_j=0 ; l_j < l_vmsize ; l_j++)   /* initialize */
                *l_pointer++ = 0 ;

            l_pointer = l_array ;
            for(l_i=p_size ; l_i>0 ;l_i-- ) {  /* l_i > 0 */
                l_value = VALUE_OP(l_i) ;
                switch(TYPE_OP(l_i)) {

                /* A_TYPE */
                    case INTEGERTYPE:
                        if( ((fix32)l_value < -1) ||
                            ((fix32)l_value > 18) ) {
                            ubyte       huge *l_stemp, huge *l_dtemp ;
                            *l_pointer++ = (ubyte)LINTEGERPACKHDR ;
                            l_stemp = (ubyte huge *)&l_value ;   /*@WIN*/
                            l_dtemp = l_pointer ;
                            COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def) ;
                            l_pointer += (PK_C_SIZE - 1) ;
                            break ;
                        }
                        l_value++ ;
                        *l_pointer++ = (ubyte)(l_value | SINTEGERPACKHDR);//@WIN
                        break ;
                    case BOOLEANTYPE:
                        *l_pointer++ = (ubyte)(l_value | BOOLEANPACKHDR);//@WIN
                        break ;

                /* B_TYPE */
                    case NAMETYPE:
                        *l_pointer = (ubyte)(l_value >> 8) ;
                        if(ATTRIBUTE_OP(l_i) == LITERAL)
                            *l_pointer++ |= (ubyte)LNAMEPACKHDR ;
                        else
                            *l_pointer++ |= (ubyte)ENAMEPACKHDR ;
                        *l_pointer++ = (ubyte)l_value ;
                        break ;

                    case OPERATORTYPE:
                        *l_pointer = (ubyte)(LENGTH_OP(l_i) >> 8) ;
                        *l_pointer++ |= (ubyte)SYSOPERATOR ; /* systemdict */
                        *l_pointer++ = (ubyte)LENGTH_OP(l_i) ;
                        break ;

                /* C_TYPE */
                    case REALTYPE:
                        *l_pointer = (ubyte)REALPACKHDR ;
                        goto label_c ;
                    case NULLTYPE:
                        *l_pointer = (ubyte)NULLPACKHDR ;
                        goto label_c ;
                    case FONTIDTYPE:
                        *l_pointer = (ubyte)FONTIDPACKHDR ;
                        goto label_c ;
                    case MARKTYPE:
                        *l_pointer = (ubyte)MARKPACKHDR ;
   label_c:
                    {
                        ubyte   huge *l_stemp, huge *l_dtemp ;

                        l_stemp = (ubyte huge *)&l_value ;      /*@WIN*/
                        l_dtemp = ++l_pointer ;
                        COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
                        l_pointer += (PK_C_SIZE - 1) ;
                        break ;
                    }

                /* D_TYPE */
                    case SAVETYPE:
                        *l_pointer = (ubyte)SAVEPACKHDR ;
                        goto label_d ;
                    case ARRAYTYPE:
                        *l_pointer = (ubyte)ARRAYPACKHDR ;
                        goto label_d ;
                    case PACKEDARRAYTYPE:
                        *l_pointer = (ubyte)PACKEDARRAYPACKHDR ;
                        goto label_d ;
                    case DICTIONARYTYPE:
                        *l_pointer = (ubyte)DICTIONARYPACKHDR ;
                        goto label_d ;
                    case FILETYPE:
                        *l_pointer = (ubyte)FILEPACKHDR ;
                        goto label_d ;
                    case STRINGTYPE:
                        *l_pointer = (ubyte)STRINGPACKHDR ;
   label_d:
                    {
                        ubyte   huge *l_stemp, huge *l_dtemp ;

                        l_stemp = (ubyte FAR *)GET_OPERAND(l_i) ;
                        l_dtemp = ++l_pointer ;
                        COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def ) ;
                        l_dtemp = l_pointer ;
                        LEVEL_SET_PK_OBJ(l_dtemp, current_save_level) ;

                        l_pointer += (PK_D_SIZE - 1) ;
                    }
                }   /* switch */
            }   /* for */
        } else
            return(FALSE) ;             /* VMERROR */
    }   /* else */

    TYPE_SET(p_obj, PACKEDARRAYTYPE) ;
    ACCESS_SET(p_obj, READONLY) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_array ;

    return(TRUE) ;
}   /* create_pk_array */

/***********************************************************************
**
** This function is used to get an ordinary object that is encoding from
** a packed object, and it returns an address of next packed object.
**
** TITLE:       get_pk_object                    Date:   08/01/87
** CALL:        get_pk_object                    UpDate: Jul/12/88
** INTERFACE:   putinterval_array:  5.3.1.3.14
**              get_array:          5.3.1.3.19
**              op_aload:           5.3.1.3.9
**              op_get:             5.3.1.4.9
***********************************************************************/
ubyte
FAR *get_pk_object(p_position, p_retobj, p_level)
 ubyte   FAR *p_position ;
 ufix    p_level ;
struct  object_def  FAR *p_retobj ;
{
    ufix16  l_attribute, l_length ;
    ULONG_PTR  l_value ;
    ufix16  l_type = 0 ;

    ROM_RAM_SET(p_retobj, RAM) ;

    /* initialize */
    l_attribute = LITERAL ;
    l_length = 0 ;

    switch(*p_position & 0xE0) {
        case SINTEGERPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f)  ;
            l_value-- ;
            l_type = INTEGERTYPE ;
            break ;

        case BOOLEANPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) ;
            l_type = BOOLEANTYPE ;
            break ;

        case LNAMEPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) << 8 ;
            l_value |= *p_position++ ;
            l_type = NAMETYPE ;
            break ;

        case ENAMEPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) << 8 ;
            l_value |= *p_position++ ;
            l_attribute = EXECUTABLE ;
            l_type = NAMETYPE ;
            break ;

        case OPERATORPACKHDR:
            l_length = (ufix16)(*p_position++ & 0x07) << 8 ;
            l_length |= *p_position++ ;
            l_attribute = EXECUTABLE ;
            l_value = (ULONG_PTR)VALUE(&systemdict_table[l_length]) ;
            l_type = OPERATORTYPE ;
            break ;

        case _5BYTESPACKHDR:
            switch(*p_position) {
                case LINTEGERPACKHDR:
                    l_type = INTEGERTYPE ;
                    goto label_c ;
                case REALPACKHDR:
                    l_type = REALTYPE ;
                    goto label_c ;
                case FONTIDPACKHDR:
                    l_type = FONTIDTYPE ;
                    goto label_c ;
                case NULLPACKHDR:
                    l_type = NULLTYPE ;
                    goto label_c ;
                case MARKPACKHDR:
                    l_type = MARKTYPE ;
            }   /* switch */
label_c:
        {
            ubyte   huge *l_stemp, huge *l_dtemp ;

            l_stemp = ++p_position ;
            l_dtemp = (ubyte huge *)&l_value ;  /*@WIN*/
            COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
            p_position += (PK_C_SIZE - 1) ;
            break ;
        }

        default:
        {
            ubyte   huge *l_stemp, huge *l_dtemp ;

            l_stemp = ++p_position ;
            l_dtemp = (ubyte FAR *)p_retobj ;
            COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def) ;
            p_position += (PK_D_SIZE - 1) ;
            return(p_position) ;
        }
    }   /* switch */

    TYPE_SET(p_retobj, l_type) ;
    ATTRIBUTE_SET(p_retobj, l_attribute) ;
    LEVEL_SET(p_retobj, p_level) ;
    ACCESS_SET(p_retobj, 0) ;
    LENGTH(p_retobj) = l_length ;
    VALUE(p_retobj) = l_value ;

    return(p_position) ;
}   /* get_pk_object */

/***********************************************************************
**
** This function is used to get the address of the nth object
** of a packedarray.
**
** TITLE:       get_pk_array                     Date:   08/01/87
** CALL:        get_pk_array                     UpDate: Jul/12/88
** INTERFACE:   getinterval_array:  5.3.1.3.13
**              get_array:          5.3.1.3.19
**              op_get:             5.3.1.4.9
***********************************************************************/
ubyte
FAR *get_pk_array(p_position, p_index)
 ubyte   FAR *p_position ;
 ufix  p_index ;
{
    ufix16  l_i ;
    ufix32  l_objsize ;

    for(l_i= 0 ; l_i < p_index ; l_i++) {
        switch(*p_position & 0xE0) {
            case SINTEGERPACKHDR:
            case BOOLEANPACKHDR:
                l_objsize = PK_A_SIZE ;
                break ;

            case LNAMEPACKHDR:
            case ENAMEPACKHDR:
            case OPERATORPACKHDR:
                l_objsize = PK_B_SIZE ;
                break ;

            case LINTEGERPACKHDR:
            case REALPACKHDR:
            case FONTIDPACKHDR:
            case NULLPACKHDR:
            case MARKPACKHDR:
                l_objsize = PK_C_SIZE ;
                break ;

            default:
                l_objsize = PK_D_SIZE ;
        }   /* switch */
        p_position += l_objsize ;
    }   /* for(l_i) */

    return(p_position) ;
}   /* get_pk_array */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\com.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              COM.H
 *      Author:                 Jonesw
 *      Owner:                  Microsoft Co.
 *      Description: header file for communication operators
 *
 * revision history:
 ************************************************************************
 */
#define B0              0
#define B110            110
#define B300            300
#define B600            600
#define B1200           1200
#define B2400           2400
#define B4800           4800
#define B9600           9600
#define B19200          19200
#define B38400          38400
#define B57600          57600

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\control.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              CONTROL.C
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include  "global.ext"
#include  <string.h>
#include  <stdio.h>
#include        "user.h"                  /* include by Falco for SYSTEMDICT */
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"

extern void GEIio_restart(void);        /* @WIN */
/* Submodule op_exec
**
** Function Description
**
** This submodule implement the operator exec.
** its operand and result on the operand stack are:
**     proc -exec-
** it push the operand onto the execution stack, and executing it immediately.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_exec()
{
    struct object_def  FAR *cur_obj ;

    if (FREXECOUNT() < 1)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       cur_obj = GET_OPERAND(0) ;
       if (ACCESS(cur_obj) == NOACCESS)
          ERROR(INVALIDACCESS) ;
       else {
/* qqq, begin */
          /*
          PUSH_EXEC_OBJ(cur_obj) ;
          POP(1) ;
          */
          if( P1_ATTRIBUTE(cur_obj) == P1_EXECUTABLE ) {
              PUSH_EXEC_OBJ(cur_obj);
              POP(1);
          }
/* qqq, end */
       }
    }

    return(0) ;
}   /* op_exec() */

/* Submodule op_if
**
** Function Description
**
** This submodule implement the operator if.
** its operands on the operand stack are:
**     boolean proc -if-
** it remove operands from the operand stack, and then executes the proc
** if the boolean is true.
**
** Interface with Other Modules
**     Input   :
**         1. A boolean and a procedure objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_if()
{
    if (VALUE(GET_OPERAND(1)) == TRUE) {
          if (FREXECOUNT() < 1)
             ERROR(EXECSTACKOVERFLOW) ;
          else {
             PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
             POP(2) ;
          }
    } else
      POP(2) ;

    return(0) ;
}   /* op_if() */

/* Submodule op_ifelse
**
** Function Description
**
** This submodule implement the operator ifelse.
** its operands on the operand stack are:
**     bool proc1 proc2 -ifelse-
** it removes all operands from the operand stack, executes proc1
** if the bool is true or proc2 if bool is false.
**
** Interface with Other Modules
**     Input   :
**         1. Two procedure and a boolean objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_ifelse()
{
    if (FREXECOUNT() < 1)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       if (VALUE(GET_OPERAND(2)) == TRUE) {
          PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
       } else
          PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
       POP(3) ;
    }

    return(0) ;
}   /* op_ifelse() */

/* Submodule op_for
**
** Function Description
**
** This submodule implement the operator for.
** its operands on the operand stack are:
**     init incr limit proc -for-
** it executes the proc repeatedly, passing it a sequence of values
** from initial by steps of increment to limit.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure and three number objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_for()
{
    ufix16  type1, type2, type3 ;
    union four_byte  temp ;
    struct object_def  temp_obj ;

    type1 = TYPE(GET_OPERAND(1)) ;
    type2 = TYPE(GET_OPERAND(2)) ;
    type3 = TYPE(GET_OPERAND(3)) ;
    if (FREXECOUNT() < 5)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
       if (type2 == REALTYPE || type3 == REALTYPE) {
          if (type1 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(1))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(1), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
          if (type2 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(2))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(2), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(2)) ;
          if (type3 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(3))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(3), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(3)) ;
          PUSH_EXEC_OP(AT_RFOR) ;          /* push @rfor */
       } else {         /* integer for */
          if (type1 == REALTYPE) {
             temp.ll = (fix32)VALUE(GET_OPERAND(1)) ;
             COPY_OBJ(GET_OPERAND(1), &temp_obj) ;
             TYPE_SET(&temp_obj, INTEGERTYPE) ;
             temp_obj.value = (ufix32)temp.ff ;          /* cast to integer */
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
          PUSH_EXEC_OBJ(GET_OPERAND(2)) ;   /* push incr */
          PUSH_EXEC_OBJ(GET_OPERAND(3)) ;   /* push init */
          PUSH_EXEC_OP(AT_IFOR) ;           /* push @ifor */
       }
       POP(4) ;
    } /* else */

    return(0) ;
}   /* op_for() */

/* Submodule op_repeat
**
** Function Description
**
** This submodule implement the operator repeat.
** its operands on the operand stack are:
**     int proc -repeat-
** it executes the proc int times.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure and an integer objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_repeat()
{
    if ((fix32)VALUE(GET_OPERAND(1)) < 0)
       ERROR(RANGECHECK) ;
    else if (FREXECOUNT() < 3)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
      PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
      PUSH_EXEC_OBJ(GET_OPERAND(1)) ;   /* push int */
      PUSH_EXEC_OP(AT_REPEAT) ;         /* push @repeat */
      POP(2) ;
    }

    return(0) ;
}   /* op_repeat() */

/*
** Submodule op_loop
**
** Function Description
**
** This submodule implement the operator loop.
** its operand on the operand stack is:
**     proc -loop-
** it repeatedly executes proc until a operator exit is executed in the
** procedure.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_loop()
{
    if (FREXECOUNT() < 2)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
      PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
      PUSH_EXEC_OP(AT_LOOP) ;           /* push @loop */
      POP(1) ;
    }

    return(0) ;
}   /* op_loop() */

/* Submodule op_exit
**
** Function Description
**
** This submodule implement the operator exit.
**     -exit-
** it terminates execution of innermost dynamically enclosing instance of
** a looping context. A looping context is a procedure invoked repeatedly
** by one of the control operators for, loop, repeat, forall, pathforall.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         None
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_exit()
{
    struct object_def  FAR *cur_obj ;

    for ( ; ;) {
        /*
        ** remove the topmost object of the execution stack until
        ** a looping operator is encourdered.
        */
/* qqq, begin */
        /*
        cur_obj = &execstack[execstktop - 1];
        if ((TYPE(cur_obj) == OPERATORTYPE) && (ROM_RAM(cur_obj) == ROM)) {
        */
        cur_obj = GET_EXECTOP_OPERAND();
        if( (P1_ROM_RAM(cur_obj) == P1_ROM) &&
            (TYPE(cur_obj) == OPERATORTYPE) ) {
/* qqq, end */
        /*
         * special treatment for @_operator
         */
           switch (LENGTH(cur_obj)) {

           case AT_EXEC :
                ERROR(INVALIDEXIT) ;
               /*
                * set access field be NOACESSS for following operators
                * in case of invalidexit, in order to distinguish from
                * normally exit.
                *
                * ATT : the handling for run is different from LaserWriter.
                *
                * -- image, imagemask, settransfer, kshow, BuildChar,
                *    setscreen, pathforall, run(*)
                */
                ACCESS_SET(cur_obj, NOACCESS) ;
                return(-4) ;          /* op_exit-2 */

           case AT_STOPPED :
                ERROR(INVALIDEXIT) ;
                break ;

           case AT_IFOR :
           case AT_RFOR :
                POP_EXEC(5) ;
                break ;

           case AT_LOOP :
                POP_EXEC(2) ;
                break ;

           case AT_REPEAT :
                POP_EXEC(3) ;
                break ;

           case AT_DICTFORALL :
                POP_EXEC(4) ;
                break ;

           case AT_ARRAYFORALL :
           case AT_STRINGFORALL :
                POP_EXEC(3) ;

           default :
                break ;
           } /* switch */
           break ;
        } else
           POP_EXEC(1) ;
    } /* for */

    return(0) ;
}   /* op_exit() */

/*
** Submodule  op_stop
**
** Function Description
**
** This submodule implement the operator stop.
**      -stop-
** it terminates execution of the innermost dynamically enclosing instance
** of a stopped context.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_stop()
{
    struct object_def FAR *cur_obj, FAR *temp_obj ;

/* qqq, begin */
    /*
    cur_obj = &execstack[execstktop];      |* get this "op_stop" object *|
    */
    cur_obj = execstkptr;
/* qqq, end */
    while (1) {
       if (execstktop) {
/* qqq, begin */
          /*
          temp_obj = &execstack[execstktop - 1];   |* get next object *|
          if ((TYPE(temp_obj) == OPERATORTYPE) && (ROM_RAM(temp_obj) == ROM)) {
          */
          temp_obj = GET_EXECTOP_OPERAND();
          if( (P1_ROM_RAM(temp_obj) == P1_ROM) &&
              (TYPE(temp_obj) == OPERATORTYPE) ) {
/* qqq, end */
             if (LENGTH(temp_obj) == AT_EXEC) {
/* qqq, begin */
                /*
                POP_EXEC(1);
                PUSH_EXEC_OBJ(cur_obj);    |* replaced @exec by op_stop *|
                */
                COPY_OBJ(cur_obj, GET_EXECTOP_OPERAND());
/* qqq, end */
                return(-1) ;                /* error code - stop happen */
             } else if (LENGTH(temp_obj) == AT_STOPPED) {
                ACCESS_SET(temp_obj, NOACCESS) ;
                return(0) ;                 /* normal exit */
             }
          }
          POP_EXEC(1) ;
       } else                   /* no enclosing stopped is found til bottom */
          return(op_quit()) ;    /* terminate operation of the interpreter */
    } /* while */
}   /* op_stop() */

/*
 * terminate operation of the interpreter permanently, the precise action
 * of this quit depends on the environment in which the PostScript interpreter
 * is running
 */
fix
op_quit()
{
#ifdef DBG
    printf("PostScript Interpreter Requested Printer To Reboot.\n") ;
#endif

    if (current_save_level) {
        struct object_def FAR *l_stopobj;
        get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
        PUSH_EXEC_OBJ(l_stopobj) ;
        return(0) ;
    }

    GEIio_restart(); /* erik chen 5-13-1991 */

    return(0) ;
/*  return(-3) ; */
}   /* op_quit() */

/*
** Submodule op_stopped
**
** Function Description
**
** This submodule implement the operator stopped.
** its operand and result on the operand stack are:
            GEIio_ioctl(GEIio_stdout, _FIONRESET, (char*)0) ;
**     any -stopped- boolean
** the any is a stopped context, if this any runs to completion normally,
** it returns false, if any terminates prematurely as a result of executing
** stop, it return true.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_stopped()
{
    if (FREXECOUNT() < 2)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       PUSH_EXEC_OP(AT_STOPPED) ;
       PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
       POP(1) ;
    }

    return(0) ;
}   /* op_stopped() */

/*
** Submodule op_countexecstack
**
** Function Description
**
** This submodule implement the operator countexecstack.
** its result on the operand stack is:
**     -countexcstack- integer
** it counts the number of object on the execution stack, and pushes this
** this count on the operand stack.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         1. An integer object on the operand stack
**         2. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_countexecstack()
{
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
     /*
      * push an integer object indicating the depth of the execution stack
      */
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, execstktop) ;

    return(0) ;
}   /* op_countexecstack() */

/*
** Submodule op_execstack
**
** Function Description
**
** This submodule implement the operator execstack.
** its operand and result on the operand stack are:
**     array -execstack- subarray
** it stores all elements of the execution stack into the array and
** returns an object describing the initial n-element subarray of array.
**
** Interface with Other Modules
**     Input   :
**         1. An array object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Accessed
*/
fix
op_execstack()
{
    if (TYPE(GET_OPERAND(0)) == PACKEDARRAYTYPE)
       ERROR(INVALIDACCESS) ;
    else if (LENGTH(GET_OPERAND(0)) < execstktop)
       ERROR(RANGECHECK) ;
    else        /* execstackoverflow */
       astore_stack(GET_OPERAND(0), EXECMODE) ;

    return(0) ;
}   /* op_execstack() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\constant.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * "Constant.h"
 *  Date:       08/11/87
 *              4/2/91: Move floating point flag from "float.h"; scchen
 */

/* @WIN: turn near, huge, and huge on */
//#define     near
//#define     far
//#define     huge

#ifndef TRUE
#define     TRUE        1
#define     FALSE       0
#endif

#define     NIL         0L         /* nil pointer */

#define     MAX15       32767
#define     MIN15       -32768
#define     UMAX16      65535

#define     MAX31       2147483647L
#define     MIN31       0x80000000
#define     UMAX32      4294967295L

#define     EMAXP       1e38
#define     EMINP       1e-38
#define     EMAXN       -1e-38
#define     EMINN       -1e38
#define     INFINITY    0x7f800000L   /* infinity number: IEEE format */
/*
#define     INFINITY    0x7f7fffffL   |* infinity number, for FPa option */
#define     PI          (float)3.1415926

/*****************
 |  OBJECT TYPE  |
 *****************/
#define     EOFTYPE             0
#define     ARRAYTYPE           1
#define     BOOLEANTYPE         2
#define     DICTIONARYTYPE      3
#define     FILETYPE            4
#define     FONTIDTYPE          5
#define     INTEGERTYPE         6
#define     MARKTYPE            7
#define     NAMETYPE            8
#define     NULLTYPE            9
#define     OPERATORTYPE        10
#define     REALTYPE            11
#define     SAVETYPE            12
#define     STRINGTYPE          13
#define     PACKEDARRAYTYPE     14

/***************
 |  ATTRIBUTE  |
 ***************/
#define     LITERAL             0
#define     EXECUTABLE          1
#define     IMMEDIATE           2       /* use by scanner */

#define     P1_LITERAL          0               /* qqq */
#define     P1_EXECUTABLE       0x0010          /* qqq */
#define     P1_IMMEDIATE        0x0020          /* qqq */
/************
 |  ACCESS  |
 ************/
/*
 * ATT:
 * for @_stopped object, the access field is used to record the result of
 * executing stopped context, UNLIMITED means it runs to completion normally,
 * and NOACCESS means it terminates prematurely by executing stop
 */
#define     UNLIMITED           0
#define     READONLY            1
#define     EXECUTEONLY         2
#define     NOACCESS            3

#define     P1_UNLIMITED        0               /* qqq */
#define     P1_READONLY         0x2000          /* qqq */
#define     P1_EXECUTEONLY      0x4000          /* qqq */
#define     P1_NOACCESS         0x6000          /* qqq */
/*************
 |  RAM/ROM  |
 *************/
/*
 * ATT:
 * for operator object, the rom_ram field is used to indicate operator type,
 * ROM means @_operator, RAM means normal PostScript operator, and
 * STA means status_dict resident operator
 */
#define     RAM                 0
#define     ROM                 1
#define     KEY_OBJECT          2       /* used by key object of dictionary */

#define     P1_RAM              0               /* qqq */
#define     P1_ROM              0x0040          /* qqq */
#define     P1_KEY_OBJECT       0x0080          /* qqq */

/*
 * position of object's bitfield
 *
 *   1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 *   5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *  | ACCESS | LEVEL        | ROM | ATT | TYPE      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *
 */
#define     TYPE_BIT            0
#define     ATTRIBUTE_BIT       4
#define     ROM_RAM_BIT         6
#define     LEVEL_BIT           8
#define     ACCESS_BIT          13

#define     TYPE_ON             0x000F
#define     ATTRIBUTE_ON        0x0003
#define     ROM_RAM_ON          0x0003
#define     LEVEL_ON            0x001F
#define     ACCESS_ON           0x0007

#define     TYPE_OFF            0xFFF0
#define     ATTRIBUTE_OFF       0xFFCF
#define     ROM_RAM_OFF         0xFF3F
#define     LEVEL_OFF           0xE0FF
#define     ACCESS_OFF          0x1FFF

#define     P1_TYPE_ON          0x000F          /* qqq */
#define     P1_ATTRIBUTE_ON     0x0030          /* qqq */
#define     P1_ROM_RAM_ON       0x00C0          /* qqq */
#define     P1_LEVEL_ON         0x01F0          /* qqq */
#define     P1_ACCESS_ON        0xE000          /* qqq */

/************
 |  STACK   |
 ************/
#define     OPNMODE             0
#define     DICTMODE            1
#define     EXECMODE            2

/********************************
 |  PACKED ARRAY OBJECT HEADER  |
 ********************************/
#define     SINTEGERPACKHDR     0x00    /* -1 ~ 18, 1 byte */
#define     BOOLEANPACKHDR      0x20
#define     LNAMEPACKHDR        0x40    /* Literal Name */
#define     ENAMEPACKHDR        0x60    /* Executable Name */
#define     OPERATORPACKHDR     0x80    /* 5 bytes objects */
#define     LINTEGERPACKHDR     0xA0
#define     REALPACKHDR         0xA1
#define     FONTIDPACKHDR       0xA2
#define     NULLPACKHDR         0xA4
#define     MARKPACKHDR         0xA5
#define     _9BYTESPACKHDR      0xC0    /* 9 bytes objects */
#define     SAVEPACKHDR         0xC0
#define     ARRAYPACKHDR        0xC0
#define     PACKEDARRAYPACKHDR  0xC0
#define     DICTIONARYPACKHDR   0xC0
#define     FILEPACKHDR         0xC0
#define     STRINGPACKHDR       0xC0


// DJC DJC
// moved to PSGLOBAL.H to allow for common error codes
// between PSTODIB and interpreter
#ifdef MOVED_ERROR_CODES
/****************
 |  ERROR CODE  |
 ****************/
#ifndef	NOERROR
#define     NOERROR             0
#endif
#define     DICTFULL            1
#define     DICTSTACKOVERFLOW   2
#define     DICTSTACKUNDERFLOW  3
#define     EXECSTACKOVERFLOW   4
#define     HANDLEERROR         5
#define     INTERRUPT           6
#define     INVALIDACCESS       7
#define     INVALIDEXIT         8
#define     INVALIDFILEACCESS   9
#define     INVALIDFONT         10
#define     INVALIDRESTORE      11
#define     IOERROR             12
#define     LIMITCHECK          13
#define     NOCURRENTPOINT      14
#define     RANGECHECK          15
#define     STACKOVERFLOW       16
#define     STACKUNDERFLOW      17
#define     SYNTAXERROR         18
#define     TIMEOUT             19
#define     TYPECHECK           20
#define     UNDEFINED           21
#define     UNDEFINEDFILENAME   22
#define     UNDEFINEDRESULT     23
#define     UNMATCHEDMARK       24
#define     UNREGISTERED        25
#define     VMERROR             26

#endif // DJC ifdef MOVED_ERROR_CODES

/**************************
 |  @_OPERATOR TYPE CODE  |
 **************************/
#define     AT_EXEC             0
#define     AT_IFOR             1
#define     AT_RFOR             2
#define     AT_LOOP             3
#define     AT_REPEAT           4
#define     AT_STOPPED          5
#define     AT_ARRAYFORALL      6
#define     AT_DICTFORALL       7
#define     AT_STRINGFORALL     8

/**********************
 |  SYSTEM PARAMETER  |
 **********************/
#define     HASHPRIME           7600   /* hash prime no# -- 85% * MAXHASHSZ */
#define     MAXHASHSZ           8980   /* Max. no# of the name table */

#define     MAXOPERSZ           9      /* Max. no# of the @_operator table */
#define     MAXSYSDICTSZ        280    /* Max. key_value pair on systemdict */
#define     MAXSTATDICTSZ       180    /* Max. key_value pair on statusdict */
#define     MAXUSERDICTSZ       200    /* Max. key_value pair on userdict */
#define     MAX_VM_CACHE_NAME   30     /* qqq */

#define     MAXARYCAPSZ         65535  /* Max. length of an array */
#define     MAXDICTCAPSZ        65535  /* Max. capacity of a dictionary */
#define     MAXSTRCAPSZ         65535  /* Max. length of a string */
#define     MAXNAMESZ           128    /* Max. no# of chars in a name */
#define     MAXFILESZ           11     /* Max. no# of open files */
#define     MAXOPNSTKSZ         500    /* Max. depth of the operand stack */
#define     MAXDICTSTKSZ        20     /* Max. depth of the dictionary stack */
#define     MAXEXECSTKSZ        250    /* Max. depth of the execution stack */
#define     MAXINTERPRETSZ      15     /* Max. no# of re_call interpreter */
#define     MAXSAVESZ           15     /* Max. no# of active save */
#define     MAXGSAVESZ          31     /* Max. no# of active gsave */

//DJCold#define     MAXPATHSZ           1500   /* Max. no# of points in path descr. */
#define     MAXPATHSZ           2500   /* Max. no# of points in path descr. */
#define     MAXDASHSZ           11     /* Max. no# of element in dash patt. */


/*******************************
 |  Floating point status flag |
 *******************************/
/* define for PDL _control87 routine */
#define     IC_AFFINE           0x1000          /*   affine */
#define     RC_NEAR             0x0000          /*   near */
#define     PC_64               0x0300          /*    64 bits */
#define     MCW_EM              0x003f          /* interrupt Exception Masks */

/* define for PDL CHECK_INFINITY macro */
/*  User Status Word Bit Definitions  */
#define SW_INVALID              0x0001          /*   invalid */
#define SW_DENORMAL             0x0002          /*   denormal */
#define SW_ZERODIVIDE           0x0004          /*   zero divide */
#define SW_OVERFLOW             0x0008          /*   overflow */
#define SW_UNDERFLOW            0x0010          /*   underflow */
#define SW_INEXACT              0x0020          /*   inexact (precision) */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\com.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              COM.C
 *      Author:                 Jones
 *      Date:                   11/20/90
 *      Owner:                  Microsoft Co.
 *      Description: this file contains communication operators
 *
 * revision history:
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        "global.ext"
#include        "language.h"
#include        "geiioctl.h"
#include        "com.h"
#include        "geipm.h"
#include        "geisig.h"
#include        <string.h>

#ifdef  _AM29K
extern unsigned char         sccbatch_set ;
#endif

fix
st_setsccbatch()
{
    GEIioparams_t     ioparams ;
    fix8              l_options ;
    ufix8             l_byte ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_options = (ufix8)VALUE_OP(0) ;
    /*
    if ((l_options ==0) || (l_options ==3) ||
       (l_options ==7) || (l_options ==67))
       l_options = 64;
    */
#ifdef  _AM29K
    ioparams.u.s.parity=l_options & 0x03 ;
    ioparams.u.s.flowcontrol=(l_options & 0x0C)>>2 ;
    ioparams.u.s.stopbits=(l_options & 0x80)>>7 ;
    ioparams.u.s.databits=(l_options & 0x60)>>5 ;
    ioparams.u.s.baudrate= (ufix8)VALUE_OP(1) ;
#else
    ioparams.s.parity=(unsigned char)(l_options & 0x03);           //@WIN
    ioparams.s.flowcontrol=(unsigned char)((l_options & 0x0C)>>2); //@WIN
    ioparams.s.stopbits=(unsigned char)((l_options & 0x80)>>7);    //@WIN
    ioparams.s.databits=(unsigned char)((l_options & 0x60)>>5);    //@WIN
    ioparams.s.baudrate= (ufix8)VALUE_OP(1) ;
#endif

     switch ((ufix16)VALUE_OP(1)) {
#ifdef  _AM29K
        case B0:
            ioparams.u.s.baudrate=0 ;
            break ;
        case B110:
            ioparams.u.s.baudrate=1 ;
            break ;
        case B300:
            ioparams.u.s.baudrate=2 ;
            break ;
        case B1200:
            ioparams.u.s.baudrate=3 ;
            break ;
        case B2400:
            ioparams.u.s.baudrate=4 ;
            break ;
        case B4800:
            ioparams.u.s.baudrate=5 ;
            break ;
        case B9600:
            ioparams.u.s.baudrate=6 ;
            break ;
        case B19200:
            ioparams.u.s.baudrate=7 ;
            break ;
        case B38400:
            ioparams.u.s.baudrate=8 ;
            break ;
        case B57600:
            ioparams.u.s.baudrate=9 ;
            break ;
#else
        case B0:
            ioparams.s.baudrate=0 ;
            break ;
        case B110:
            ioparams.s.baudrate=1 ;
            break ;
        case B300:
            ioparams.s.baudrate=2 ;
            break ;
        case B1200:
            ioparams.s.baudrate=3 ;
            break ;
        case B2400:
            ioparams.s.baudrate=4 ;
            break ;
        case B4800:
            ioparams.s.baudrate=5 ;
            break ;
        case B9600:
            ioparams.s.baudrate=6 ;
            break ;
        case B19200:
            ioparams.s.baudrate=7 ;
            break ;
        case B38400:
            ioparams.s.baudrate=8 ;
            break ;
        case B57600:
            ioparams.s.baudrate=9 ;
            break ;
#endif
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */

    switch (VALUE_OP(2)) {
        case 9:
//          GEIpm_ioparams_write("%SERIAL9%",(char *)&ioparams,1) ; @WIN; wrong cast
            GEIpm_ioparams_write("%SERIAL9%",&ioparams,1) ;
            break ;
        case 25:
//          GEIpm_ioparams_write("%SERIAL25%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_write("%SERIAL25%",&ioparams,1) ;
            break ;
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */
        l_byte = (ufix8)VALUE_OP(0);    //@WIN
        GEIpm_write(PMIDofSCCBATCH,&l_byte,sizeof(unsigned char)) ;
    POP(3) ;
    /*
    GEIsig_raise(GEISIGSCC, 1) ;  */     /* Raise SCC changed */
#ifdef  _AM29K
    sccbatch_set=1 ;
#endif

    return(0) ;
}   /* st_setsccbatch */

fix
st_sccbatch()
{
    ufix8               l_options ;
    GEIioparams_t       ioparams ;
//  fix16               tmp_baudrate = 0 ;      @WIN
    ufix32              tmp_baudrate = 0 ;

    if (FRCOUNT()<1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    switch (VALUE_OP(0)) {
        case 9:
//          GEIpm_ioparams_read("%SERIAL9%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_read("%SERIAL9%",&ioparams,1) ;
            break ;
        case 25:
//          GEIpm_ioparams_read("%SERIAL25%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_read("%SERIAL25%",&ioparams,1) ;
            break ;
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */

#ifdef  _AM29K
    l_options = ioparams.u.s.parity | ioparams.u.s.flowcontrol<<2 |
                ioparams.u.s.stopbits<<7 | ioparams.u.s.databits<<5 ;
    POP(1) ;
#else
    l_options = (unsigned char)(ioparams.s.parity |
                ioparams.s.flowcontrol<<2 |
                ioparams.s.stopbits<<7 |
                ioparams.s.databits<<5);                //@WIN
    POP(1) ;
#endif

#ifdef  _AM29K
    switch (ioparams.u.s.baudrate){
#else
    switch (ioparams.s.baudrate){
#endif
    case _B110:
        tmp_baudrate= 110 ;
        break ;
    case _B300:
        tmp_baudrate= 300 ;
        break ;
    case _B600:
        tmp_baudrate= 600 ;
        break ;
    case _B1200:
        tmp_baudrate= 1200 ;
        break ;
    case _B2400:
        tmp_baudrate= 2400 ;
        break ;
    case _B4800:
        tmp_baudrate= 4800 ;
        break ;
    case _B9600:
        tmp_baudrate= 9600 ;
        break ;
    case _B19200:
        tmp_baudrate= 19200 ;
        break ;
    case _B38400:
        tmp_baudrate= 38400 ;
        break ;
    case _B57600:
        tmp_baudrate= 57600 ;
        break ;
    default:
        ERROR(RANGECHECK) ;
    }

/*  GEIpm_read(PMIDofSCCBATCH,&l_options,sizeof(unsigned char)) ; */
    PUSH_VALUE(INTEGERTYPE, 0, 0, 0, (ufix32)tmp_baudrate) ;
    PUSH_VALUE(INTEGERTYPE, 0, 0, 0, (ufix32)l_options) ;

    return(0) ;
}   /* st_sccbatch */

fix
st_setsccinteractive()
{
    return(st_setsccbatch()) ;
}   /* st_setsccinteractive */

fix
st_sccinteractive()
{
    return(st_sccbatch()) ;
}   /* st_sccinteractive */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\dict.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DICT.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"

#include  <stdio.h>
#include    "global.ext"
#include    "language.h"
#include    "dict.h"

#ifdef MYPSDEBUG
VOID DJC_testerror( int x )
{
   global_error_code = (ufix16)x;
}
#endif

/***********************************************************************
**
** This submodule implements the operator dict.
** Its operand and result objects are:
**     integer  -dict- dictioanry
** It creates a dictionary object in which the number of key-value pairs,
** specified by the input integer object, is defined.
**
** TITLE:       op_dict             Date:   08/01/87
** CALL:        op_dict()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_dict:    5.3.1.4.23
***********************************************************************/
fix
op_dict()
{
    struct  object_def  l_save ;

    /*
    ** check operands
    ** the key-value pairs in the dictionary must be less than 64K
    */
    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXDICTCAPSZ) )
        ERROR(RANGECHECK) ;
    else {
        /* SUCCESS */
        if( create_dict(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;
    }

    return(0) ;
}   /* op_dict */

/***********************************************************************
**
** This submodule implements the operator length.
** Its operand and result objects are:
**     dictionary -length- integer
**     string     -length- integer
**     array      -length- integer
** It returns the number of the characters if the input object is a
** string object.
** It returns the number of the elements if the input object is a array.
** It returns the number of the defined key-value pairs if the input object
** is a dictionary object.
**
** TITLE:       op_length           Date:   08/01/87
** CALL:        op_length()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_length()
{
    struct  object_def  FAR *l_composite ;
    struct  dict_head_def   FAR *l_dhead ;
    ufix16  l_count = 0 ;

    l_composite = GET_OPERAND(0) ;
    switch(TYPE(l_composite)) {
        case DICTIONARYTYPE:
            l_dhead = (struct dict_head_def FAR *)VALUE(l_composite) ;
            if(DACCESS(l_dhead) == NOACCESS) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }
            l_count = l_dhead->actlength ;
            break ;

        case STRINGTYPE:
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            /* executeonly or noaccess */
            if(ACCESS(l_composite) >= EXECUTEONLY) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            l_count = LENGTH(l_composite) ;
            break ;

        case NAMETYPE:
            l_count =name_table[VALUE_OP(0)]->name_len ;

    }   /* switch */

    /* pop the operand object off the operand stack
    ** make and push the integer object
    */
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_count) ;

    return(0) ;
}   /* op_length */

/***********************************************************************
**
** This submodule implements the operator maxlength.
** Its operand and result objects are:
**     dictionary -maxlength- integer
** It returs the maximum key-value pairs that that dictionary can hold.
**
** TITLE:       op_maxlength        Date:   08/01/87
** CALL:        op_maxlength()      UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_maxlength()
{
    ufix16  l_maxlength ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE_OP(0) ;

    if( DACCESS(l_dhead) == NOACCESS )
        ERROR(INVALIDACCESS) ;
    else {
        /*
         * pop the operand object off the operand stack
         * and make and push the length object
         */
        l_maxlength = LENGTH_OP(0) ;
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_maxlength) ;
    }

    return(0) ;
}   /* op_maxlength */

/***********************************************************************
**
** This submodule implements the operator begin.
** Its operand and result objects are:
**     dictionary  -begin-
** It pushes the dictionary on the dictionary stack,
** making it the currrent dictionary.
**
** TITLE:       op_begin            Date:   08/01/87
** CALL:        op_begin()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       change_dict_stack:      5.3.1.4.24
***********************************************************************/
fix
op_begin()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dictobj = GET_OPERAND(0) ;
    /* check operand and the depth of the dictionary stack */
    if( FRDICTCOUNT() < 1 )  {
        POP(1) ;                                /* reserve space */
        ERROR(DICTSTACKOVERFLOW) ;
    }
    else {
        l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
        if( DACCESS(l_dhead) == NOACCESS )
            ERROR(INVALIDACCESS) ;
        else {
            /*
             * push the dictionary object onto the dictionary stack
             * pop the dictionary operand off the operand stack
             */
            PUSH_DICT_OBJ(l_dictobj) ;
#ifdef  DBG
    printf("BEGIN<level:%d>\n", LEVEL(l_dictobj)) ;
#endif  /* DBG */
            POP(1) ;

            /* change the global_dictstkchg to indicate some dictionaries
             * in the dictionary stack have been changed
             */
            change_dict_stack() ;
        }   /* else */
    }

    return(0) ;
}   /* op_begin */

/***********************************************************************
**
** This submodule implements the operator end.
** The operator has no operands and result objects.
** It pops the current dictionary off the dictionary stack,
** making the dictionary below it the current dictionary.
**
** TITLE:       op_end              Date:   08/01/87
** CALL:        op_end()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       change_dict_stack:      5.3.1.4.24
***********************************************************************/
fix
op_end()
{
    /*
     *  it can't pop the last two dictioanries, userdict and systemdict,
     *  off the operand stack
     */
    if( dictstktop <= 2 )
        ERROR(DICTSTACKUNDERFLOW) ;
    else {
        /*
         *  change the confirm number to indicate some dictionaries
         *  in the dictionary stack have been changed
         */
        POP_DICT(1) ;
        change_dict_stack() ;
    }

    return(0) ;
}   /* op_end */

/***********************************************************************
**
** This submodule implements the operator def.
** Its operand and result objects are:
**     key  value -def-
** It defines the key and value on the current dictionary.
**
** TITLE:       op_def                          Date:   08/01/87
** CALL:        op_def()                        UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       put_dict1:      5.3.1.4.26
***********************************************************************/
fix
op_def()
{
    struct  object_def  FAR *l_dictobj, l_value ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dictobj = &dictstack[dictstktop - 1] ;
    l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
    if( DACCESS(l_dhead) >= READONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    COPY_OBJ(GET_OPERAND(0), &l_value) ;
    /* TRUE -> dict_found field is true */
    /* SUCCESS */
    if( put_dict1(l_dictobj, GET_OPERAND(1), &l_value, TRUE) )
        POP(2) ;

    return(0) ;
}   /* op_def */

/***********************************************************************
**
** This submodule implements the operator load.
** Its operand and result objects are:
**     key -load- value
** It searches the dictionary stack for the given key and push
** the value object on the operand stack if found.
**
** TITLE:       op_load             Date:   08/01/87
** CALL:        op_load()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       load_dict1:     5.3.1.4.27
**              free_new_name:
***********************************************************************/
fix
op_load()
{
    bool    l_flag ;
    struct  object_def   FAR *l_value ;

    l_flag = (bool)FALSE ;
    /*
     * SUCCESS
     */
    if( load_dict1(GET_OPERAND(0), &l_value, (bool FAR *)&l_flag) ) { /*@WIN*/
        /* found but invalidaccess */
        if(l_flag)
            ERROR(INVALIDACCESS) ;
        else {
            /*
             *  pop the key object off the operand stack
             *  push the value object onto the operand stack
             */
            POP(1) ;
            PUSH_ORIGLEVEL_OBJ(l_value) ;
        }
    }

    return(0) ;
}   /* op_load */

/***********************************************************************
**
** This submodule implements the operator store.
** Its operand and result objects are:
**     key value -store-
** It searches the dictionary stack for the given key object.
** If found, it replaces the vlaue with a new one ; otherwise,
** it defines the key and the value object in the current dictionary.
**
** TITLE:       op_store            Date:   08/01/87
** CALL:        op_store()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              put_dict1:  5.3.1.4.26
**              where:      5.3.1.4.21
***********************************************************************/
fix
op_store()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    /*
     *  l_dictobj is pointer to a dictionary object
     *
     *  the key has not be defined, defined the key on
     *  the current dictioanry
     */
    if( where(&l_dictobj, GET_OPERAND(1)) ) {
        if(global_error_code != NOERROR) return(0) ;
    } else
        l_dictobj = &dictstack[dictstktop-1] ;  /* strore to current dict */
    l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
    if( DACCESS(l_dhead) >= READONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /*
     *  put this key-value pair to current dictionary
     *  this dict is in dictionary stack, so TRUE (do change dict_found)
     *
     *  SUCCESS
     */
    if( put_dict1(l_dictobj, GET_OPERAND(1), GET_OPERAND(0), TRUE) )
        POP(2) ;

    return(0) ;
}   /* op_store */

/***********************************************************************
**
** This submodule implements the operator get.
** Its operand and result objects are:
**     dictionary key   -get- value
**     array      index -get- value
**     string     index -get- value
** If the first operand is an array or string, it treats the second operand
** as an index and returns the array or string element identified by the index.
** If the first operand is a dictionary, it looks up the second as a key in
** the dictionary and returns the associated value.
**
** TITLE:       op_get              Date:   08/01/87
** CALL:        op_get()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_dict        5.3.1.4.17
**              get_array       5.3.1.3.19
**              free_new_name:
**              get_pk_array:   5.3.1.3.26
**              get_pk_object:  5.3.1.3.25
***********************************************************************/
fix
op_get()
{
    ufix16  l_index ;
    struct  object_def  FAR *l_composite, FAR *l_value ;
    union   obj_value   l_ptr ;

    l_composite = GET_OPERAND(1) ;
    switch( TYPE(l_composite) ) {
        case DICTIONARYTYPE:
            l_ptr.dd = (struct dict_head_def FAR *)VALUE(l_composite) ;
            if( DACCESS(l_ptr.dd) == NOACCESS ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }

            /* the key object cannot be a null object */
            /* no key in dict */
            if( l_ptr.dd->actlength == 0 ) {
                /* POP_KEY ; 12-3-87 */
                /* POP(1) ;  12-9-87 */
                /* only leave key in stack for compatible with NTX; @WIN */

                POP(2);				//UPD044, by printer group
                PUSH_ORIGLEVEL_OBJ(l_composite);

                ERROR(UNDEFINED) ;
                break ;
            }

            /*
            ** GET A VALUE OBJECT
            **
            **  SUCCESS
            */
            if( get_dict(l_composite, GET_OPERAND(0), &l_value) ) {
                POP(2) ;
                PUSH_ORIGLEVEL_OBJ(l_value) ;
            }  else {
                /* leave the key in stack if UNDEFINED error */
                if(ANY_ERROR() != LIMITCHECK)
                    /* only leave key in stack for compatible with NTX; @WIN */

                    POP(2) ;			//UPD044, by printer group
                    PUSH_ORIGLEVEL_OBJ(l_composite);

                    ERROR(UNDEFINED) ;
            }
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case STRINGTYPE:
            /* the index is greater than the length of array or string */
            if( ((fix32)VALUE_OP(0) < 0) ||
                ((ufix32)VALUE_OP(0) >= (ufix32)LENGTH(l_composite)) ) {
                ERROR(RANGECHECK) ;
                break ;
            }

            /* executeonly ? noacces ? */
            if( ACCESS(l_composite) >= EXECUTEONLY ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }
            l_ptr.oo = (struct object_def FAR *)VALUE(l_composite) ;
            l_index = (ufix16)VALUE_OP(0) ;
            POP(2) ;

            /*
             *  STRING
             */
            if( TYPE(l_composite) == STRINGTYPE ) {
                l_ptr.ss += l_index ;
                /*  push the integer object representing the character */
                PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0,
                           ((ufix32)*l_ptr.ss & 0x000000FF)) ;
            }
            /*
             *  ARRAY
             */
            else if( TYPE(l_composite) == ARRAYTYPE ) {
                l_ptr.oo += l_index ;
                PUSH_ORIGLEVEL_OBJ((struct object_def FAR *)l_ptr.oo) ;
            }
            /*
             *  PACKEDARRAY
             */
            else {
                l_ptr.ss = get_pk_array(l_ptr.ss, l_index) ;
/* qqq, begin */
                /*
                get_pk_object( l_ptr.ss, &opnstack[opnstktop++],
                               LEVEL(l_composite) ) ;
                */
                get_pk_object( l_ptr.ss, opnstkptr, LEVEL(l_composite) ) ;
                INC_OPN_IDX();
/* qqq, end */
            }
    }   /* switch */

    return(0) ;
}   /* op_get */

/***********************************************************************
**
** This submodule implements the operator put.
** Its operand and result objects are:
**     dictionary key   value -put-
**     array      index value -put-
**     string     index value -put-
** It defines a key-value pair in the current dictionary.
**
** TITLE:       op_put              Date:       08/01/87
** CALL:        op_put()            UpDate:     Jul/12/88
** INTERFACE:   interpreter:
** CALL:
**              put_dict1:  5.3.1.4.26
**              put_array:  5.3.1.3.20
** Modified by J. Lin, 9-02-1988
***********************************************************************/
fix
op_put()
{
    ufix16  l_index ;
    struct  object_def  FAR *l_composite ;
    union   obj_value   l_ptr ;

    l_composite = GET_OPERAND(2) ;
    switch(TYPE(l_composite)) {
        case DICTIONARYTYPE:
            /* pointer to a dictionary structure */
            l_ptr.dd = (struct dict_head_def FAR *)VALUE(l_composite) ;

            /* the key cannot be a null object */
            if (DACCESS(l_ptr.dd) != UNLIMITED) {
                ERROR(INVALIDACCESS) ;
                break ;
            }
            /*
             * change dict_found filed of name_table
             * dict may be not in dictctionary stack
             * SUCCESS
             */
            if( put_dict1(l_composite, GET_OPERAND(1), GET_OPERAND(0), FALSE) )
                POP(3) ;
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case STRINGTYPE:
            /* the index is greater than the array length */
            if( ((fix32)VALUE_OP(1) < 0) ||
                ((ufix32)VALUE_OP(1) >= (ufix32)LENGTH(l_composite)) ) {
                ERROR(RANGECHECK) ;
                break ;
            }

            /*  readonly ? executeonly ? noaccess ? */
            if( ACCESS(l_composite) != UNLIMITED ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }

            l_ptr.oo = (struct object_def FAR *)VALUE(l_composite) ;
            l_index = (ufix16)VALUE_OP(1) ;
            /*
            **  STRING
            */
            if (TYPE(l_composite) == STRINGTYPE) {
                /* the value is out of the arrange of character code */
                if((ufix32)VALUE_OP(0) > 255) {
                    ERROR(RANGECHECK) ;
                    return(0) ;
                }
                l_ptr.ss += l_index ;
                *l_ptr.ss = (ubyte)VALUE_OP(0) ;
            }   /* string */
            /*
            **  ARRAY
            */
            else {
                l_ptr.oo += l_index ;
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_ptr.oo) != current_save_level )
                if( (ufix16)(LEVEL(l_ptr.oo)) != current_save_level )
                    if(! save_obj(l_ptr.oo) ) return(FALSE) ;
                COPY_OBJ(GET_OPERAND(0), (struct object_def FAR *)l_ptr.oo) ;
                LEVEL_SET(l_ptr.oo, current_save_level) ;
            }   /* array */

            POP(3) ;
    }   /* switch */

    return(0) ;
}   /* op_put */

/***********************************************************************
**
** This submodule implements the operator known.
** Its operand and result objects are:
**     dictionary key -known- boolean
** It returns a boolean object indicating if the key is defined in
** the dictionary.
**
** TITLE:       op_known            Date:   08/01/87
** CALL:        op_known()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_dict:           5.3.1.4.17
**              free_new_name:
***********************************************************************/
fix
op_known()
{
    struct  object_def  FAR *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE_OP(1) ;
    if( DACCESS(l_dhead) == NOACCESS) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if( get_dict(GET_OPERAND(1), GET_OPERAND(0), &l_vtemp) ) {
        POP(2) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    } else {
        if(global_error_code == NOERROR) {      /* undefined */
            POP(2) ;                            /* pop dict & key */
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    }

    return(0) ;
}   /* op_known */

/***********************************************************************
**
** This submodule implements the operator where.
** Its operand and result objects are:
**     key -where- dictionary true
**                 or false
** It searches the dictioanry stack for a given key. If the key is defined in
** some dictionary, it returns the dictionary and a boolean object ; otherwise,
** it returns a false object.
**
** TITLE:       op_where            Date:   08/01/87
** CALL:        op_where()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       where:      5.3.1.4.21
***********************************************************************/
fix
op_where()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    if( where(&l_dictobj, GET_OPERAND(0)) ) {
        if(global_error_code != NOERROR) return(0) ;
        l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
        if( DACCESS(l_dhead) == NOACCESS ) {
            ERROR(INVALIDACCESS) ;
            return(0) ;
        }

        if( FRCOUNT() < 1 ) {
            POP(1) ;                /* ?? */
            ERROR(STACKOVERFLOW) ;
        }
        else {
            POP(1) ;
            PUSH_ORIGLEVEL_OBJ(l_dictobj) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        }
    } else {
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_where */

/***********************************************************************
**
** This submodue implements the operator forall
** Its operand and result objects are:
**     array      proc -forall-
**     dictionary proc -forall-
**     string     proc -forall-
** It enumerates the elements of the first operand, executing the procedure
** for each element.
**
** TITLE:       op_forall           Date:   08/01/87
** CALL:        op_forall()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              forall_array:   5.3.1.3.16
**              forall_dict:    5.3.1.4.20
**              forall_string:  5.3.1.5.15
***********************************************************************/
fix
op_forall()
{
    struct  dict_head_def   FAR *l_dhead ;

    if( ACCESS_OP(0) == NOACCESS ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /* if success, pop elements are executed by subprocedure */
    switch( TYPE_OP(1) ) {
        case DICTIONARYTYPE:
            l_dhead = (struct dict_head_def FAR *)VALUE_OP(1) ;
            if( DACCESS(l_dhead) == NOACCESS ) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            /* NOTHING in dict */
            if( l_dhead->actlength == 0 ) {
                POP(2) ;
                return(0) ;
            }

            forall_dict(GET_OPERAND(1), GET_OPERAND(0)) ;
            break ;

        case STRINGTYPE:
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            if( ACCESS_OP(1) >= EXECUTEONLY ) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            if( LENGTH_OP(1) == 0 ) {
                POP(2) ;
                return(0) ;
            }

            if( TYPE_OP(1) == STRINGTYPE )
                forall_string( GET_OPERAND(1), GET_OPERAND(0) ) ;
            else
                forall_array( GET_OPERAND(1), GET_OPERAND(0) ) ;
    }   /* switch */

    if( ! ANY_ERROR() )
        POP(2) ;

    return(0) ;
}   /* op_forall */

/***********************************************************************
**
** This submodue implements the operator currentdict.
** This operator has no operands or result objects.
** It returns the current dictionary on the operand stack.
**
** TITLE:       op_currentdict              Date:   08/01/87
** CALL:        op_currentdict()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_currentdict()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;

    /*  push the current dictionary object onto the opernad stack */
    else
        PUSH_ORIGLEVEL_OBJ(&dictstack[dictstktop-1]) ;

    return(0) ;
}   /* op_currentdict */

/***********************************************************************
**
** This submodule implements the operator countdictstack.
** It returns the number of dictionaries on the dictionary stack.
** This operator has no operands or result objects.
**
** TITLE:       op_countdictstack               Date:   08/01/87
** CALL:        op_countdictstack()             UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_countdictstack()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    /*
    **  push the integer object, its the depth of dictionary stack,
    **  onto operand stack
    */
    else
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)dictstktop) ;

    return(0) ;
}   /* op_countdictstack */

/***********************************************************************
**
** This submodule implements the operator dictstack.
** Its operand and result objects are:
**     array  -dictstack- subarray
** It copies the dictionaries on the dictionary stack to a given array.
**
** TITLE:       op_dictstack                    Date:   08/01/87
** CALL:        op_dictstack()                  UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_dictstack()
{
    if( ACCESS_OP(0) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /*
     *  the length of array is less than the
     *  depth of the dictionary stack
     */
    if( (ufix16)LENGTH_OP(0) < dictstktop )     /* may be deleted */
        ERROR(RANGECHECK) ;

    /*
    ** copy the dictionaries in dictionary stack
    ** to the array in the operand stack
    */
    /* for dictstackoverflow */
    else
        astore_stack(GET_OPERAND(0), DICTMODE) ;

    return(0) ;
}   /* op_dictstack */

/***********************************************************************
**
**  This submodule searches the dictionary stack for a key object.
**
** TITLE:       where                       Date:   08/01/87
** CALL:        where(p_dict,p_key,p_flag)  UpDate: Jul/12/88
** INTERFACE:   op_store:   5.3.1.4.8
**              op_where:   5.3.1.4.12
** CALLS:       get_dict:   5.3.1.4.17
***********************************************************************/
static bool near
where(p_dict, p_key)
struct  object_def  FAR * FAR *p_dict, FAR *p_key ;
{
    fix     l_i ;
    struct  object_def  FAR *l_dvalue ;

    /* search the key in the dictionary stack */
    for(l_i=dictstktop - 1 ; l_i >= 0 ; l_i-- ) {
        *p_dict = &dictstack[l_i] ;
        /*
         * FOUND
         */
        if ( (get_dict(*p_dict, p_key, &l_dvalue)) ||
             (global_error_code != NOERROR) ) return(TRUE) ;
    }

    return(FALSE) ;
}   /* where */

/***********************************************************************
**
** This submodule defines a given key and value pair in the
** specified dictionary.
**
** TITLE:       put_dict1           Date:   08/01/87
** CALL:        put_dict1()         UpDate: Jul/12/88
** INTERFACE:
** CALLS:       equal_key:          5.3.1.4.30
**              save_obj:           5.3.1.10.4
**              sobj_to_nobj:       5.3.1.4.25
**              update_same_link:   5.3.1.10.7
***********************************************************************/
bool
put_dict1(p_dict, p_key, p_value, p_dstack)
struct object_def  FAR *p_dict, FAR *p_key, FAR *p_value ;
fix    p_dstack ;
{
    ufix16  l_j, l_maxlength, l_actlength ;
    fix     l_id ;
    struct object_def l_newkey, l_value ;
    struct object_def huge *l_newp = &l_newkey ;
    struct dict_head_def   FAR *l_dhead ;
    struct dict_content_def  huge *l_dcontain, huge *l_dtemp, huge *l_curptr,
                             huge *l_lastptr, huge *l_fstptr ;
    /*
     * set the save level of the object
     */
    COPY_OBJ( p_value, &l_value ) ;
    LEVEL_SET(&l_value, current_save_level) ;

    /* change string key to name key and create a new key object */
    if(! check_key_type(p_key, l_newp) ) return(FALSE) ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    l_actlength = l_dhead->actlength ;
    l_maxlength = LENGTH(p_dict) ;

    /* CHECK LENGTH */
    if( l_maxlength == 0 ) {
        ERROR(DICTFULL) ;
        return(FALSE) ;
    }

    LEVEL_SET(l_newp, current_save_level) ;

    l_dcontain = (struct dict_content_def huge *)
                 ( (ubyte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    /*
     *  key is NAMETYPE && dict is a RAM dictionary
     */
    if( (TYPE(l_newp) == NAMETYPE) && (!DROM(l_dhead))) {
        l_id = (fix)VALUE(l_newp) ;
#ifdef  DBG
        printf("put_dict1(RAM):<") ;
        GEIio_write(GEIio_stdout, name_table[l_id]->text, name_table[l_id]->name_len) ;
        printf(">(%lx)\n",VALUE(p_dict)) ;
#endif  /* DBG */
        l_curptr = name_table[l_id]->dict_ptr ;
        if((ULONG_PTR)l_curptr < SPECIAL_KEY_VALUE) {
            /*
             * EMPTY LIST: put the key-value pair to dict and
             *             become the first element of name list
             */
            if(l_actlength >= l_maxlength) {
                ERROR(DICTFULL) ;
                return(FALSE) ;
            }
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;

            l_dcontain += l_dhead->actlength ;
            l_dhead->level = current_save_level ;
            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;

            name_table[l_id]->dict_ptr = l_dcontain ;   /* maintain DICT_LIST */

            if(p_dstack) {                      /* set dict_found, dstkchg */
                name_table[l_id]->dict_found = TRUE ;
                name_table[l_id]->dstkchg = global_dictstkchg ;
            }

            l_dhead->actlength++ ;
            LENGTH(l_newp) = LENGTH(&(l_dcontain->k_obj)) ;
            VALUE(l_newp) = (ufix32)l_id ;                    /* hash id */
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;        /* new key */
        } else {
            l_fstptr = l_curptr ;
            l_lastptr = NIL ;
            while((ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE) {
                l_dtemp = DICT_NAME(l_curptr) ;
                if(l_dtemp == l_dcontain) {
                    /*
                     * FOUND: put value to dict and update name list
                     */
// DJC signed/unsigned mismatch warning
// DJC              if( LEVEL(&l_curptr->v_obj) != current_save_level )
                    if( (ufix16)(LEVEL(&l_curptr->v_obj)) != current_save_level )
                        if(! save_obj(&(l_curptr->v_obj)) ) return(FALSE) ;
                    if (p_dstack) {
                       if (l_curptr != l_fstptr) {
                          VALUE(&l_lastptr->k_obj) = VALUE(&l_curptr->k_obj) ;
                          VALUE(&l_curptr->k_obj) = (ULONG_PTR)l_fstptr ;
                          name_table[l_id]->dict_ptr = l_curptr ;
                       }
                       name_table[l_id]->dict_found = TRUE ;
                       name_table[l_id]->dstkchg = global_dictstkchg ;
                    }
                    l_dcontain = l_curptr ;
                    goto label_1 ;
                }
                l_lastptr = l_curptr ;
                l_curptr = (struct dict_content_def huge *)VALUE(&l_curptr->k_obj) ;
            }   /* while(l_curptr) */

            /*
             *  NOT FOUND: put the key-value pair to dict and
             *             update the name list
             */
            if(l_actlength >= l_maxlength) {
                ERROR(DICTFULL) ;
                return(FALSE) ;
            }
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;
            l_dcontain += l_dhead->actlength ;
            l_dhead-> level = current_save_level ;

            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;
            name_table[l_id]->dict_ptr = l_dcontain ;
            l_dhead->actlength++ ;

            if (p_dstack) {                     /* set dict_found, dstkchg */
                name_table[l_id]->dict_found = TRUE ;
                name_table[l_id]->dstkchg = global_dictstkchg ;
            } else                             /* reset dict_found */
               name_table[l_id]->dict_found = FALSE ;

            LENGTH(l_newp) = LENGTH(&(l_dcontain->k_obj)) ;
            VALUE(l_newp) = (ULONG_PTR)l_fstptr ;
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;      /* new key */
        }

label_1:
        COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
/* qqq, begin */
        if( ! cache_name_id.over )
            vm_cache_index(l_id);
/* qqq, end */
        return(TRUE) ;

    }   /*  NAMETYPE && RAM dictionary */
    /*
     *  OTHERS
     *
     *  linear search: first in first service
     */
    else {

#ifdef  DBG
        printf("put_dict1(others):<") ;
        /* 3/7/91
        print_string(name_table[VALUE(l_newp)]->text, name_table[VALUE(l_newp)]->name_len) ;
        */
        GEIio_write(GEIio_stdout, name_table[VALUE(l_newp)]->text, name_table[VALUE(l_newp)]->name_len) ;
        printf(">(%lx)\n",VALUE(p_dict)) ;
#endif  /* DBG */

        for(l_j=0 ; l_j < l_actlength ; l_j++, l_dcontain++) {
            /* find the SAME KEY */
            if( equal_key(&(l_dcontain->k_obj), l_newp) ) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(&l_dcontain->v_obj) != current_save_level ) {
                if( (ufix16)(LEVEL(&l_dcontain->v_obj)) != current_save_level ) {
                    if( ! save_obj(&(l_dcontain->v_obj)) )
                        return(FALSE) ;
                }
                COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
                return(TRUE) ;
            }
        }   /* for */

        if(l_dhead->actlength >= l_maxlength) {
            ERROR(DICTFULL) ;
            return(FALSE) ;
        } else {
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;
            l_dhead->level = current_save_level ;

            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;          /* new key */
            COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
            l_dhead->actlength++ ;              /* increase actual length */
            return(TRUE) ;
        }
    }   /* others */
}   /* put_dict1 */

/***********************************************************************
**
** This submodule loads the value of the given key from a dictionary stack.
**
** TITLE:       load_dict1          Date:   08/01/87
** CALL:        load_dict1()        UpDate: Jul/12/88
** INTERFACE:
** CALL:        get_dict:           5.3.1.4.17
**              check_key_type:     5.3.1.4.33
***********************************************************************/
static bool near
load_dict1(p_key, p_value, p_flag)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
bool    FAR *p_flag ;   /*@WIN*/
{
    fix     l_id, l_index ;
    struct  object_def      l_newkey, FAR *l_newp = &l_newkey ;
    struct  object_def  huge *l_dictobj, huge *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr,
                                huge *l_dold, huge *l_fstptr ;

    if( ! check_key_type(p_key, l_newp) )
        return(FALSE) ;

    if( TYPE(l_newp) == NAMETYPE ) {
        l_id = (fix)VALUE(l_newp) ;
        /*
         * if the name object is defined in a RAM dictionary,
         * it will be in the object lists in the name table.
         *
         * the dictionary cell is linked in the header entry
         */
        if( (name_table[l_id]->dstkchg == global_dictstkchg) &&
            (name_table[l_id]->dict_found) ) {

            /* get first element */
            *p_value = &(name_table[l_id]->dict_ptr->v_obj) ;
            return(TRUE) ;
        }
        /*
         *  RESCHEDULE NAME LIST
         */
        else {

            /*  link list */
            l_index = dictstktop -1 ;
            l_fstptr = name_table[l_id]->dict_ptr ;

            /*  get dictionary from dictionary stack */
            while( l_index >= 0 ) {
                l_dictobj = &dictstack[l_index] ;
                l_dhead = (struct dict_head_def huge *)VALUE(l_dictobj) ;

                if(DROM(l_dhead)) {
                    /*
                     *  ROM
                     */
                    if( get_dict(l_dictobj, l_newp,
                          (struct object_def FAR * FAR *)&l_vtemp) ) {
                        name_table[l_id]->dict_found = FALSE ;
                        if(DACCESS(l_dhead) == NOACCESS)
                            *p_flag = TRUE ;

                        *p_value = l_vtemp ;
                        return(TRUE) ;
                    }
                    /* else: to next dict */
                }   /* ROM */
                else {
                    /*
                     *  RAM
                     *
                     * search this RAM dictionary's address in link list
                     */
                    if((ULONG_PTR)l_fstptr < SPECIAL_KEY_VALUE) {
                        l_index-- ;
                        continue ;
                    }
                    l_dict = l_fstptr ;                     /* name list */
                    l_dold = NIL ;
                    l_dptr = (struct dict_content_def huge *)
                        ((byte FAR *)l_dhead + sizeof(struct dict_head_def));
                    for( ; ;) {
                        if( (ULONG_PTR)l_dict < SPECIAL_KEY_VALUE )  break ;

                        /*
                         * FOUND, this key in l_dictobj
                         */
                        if( DICT_NAME(l_dict) == l_dptr ) {
                            /* CHANGE THIS ELEMENT TO FRONT OF LIST */
                            if( l_dold != NIL ) {
                                VALUE(&l_dold->k_obj) = VALUE(&l_dict->k_obj) ;
                                VALUE(&l_dict->k_obj) = (ULONG_PTR)l_fstptr ;
                                name_table[l_id]->dict_ptr = l_dict ;
                            }
                            name_table[l_id]->dict_found = TRUE ;
                            name_table[l_id]->dstkchg = global_dictstkchg ;

                            if( DACCESS(l_dhead) == NOACCESS )
                                *p_flag = TRUE ;
                            *p_value = &(l_dict->v_obj) ;
                            return(TRUE) ;
                        } else {
                            /* to next element of name list */
                            l_dold = l_dict ;
                            l_dict = (struct dict_content_def huge *)
                                     VALUE(&l_dict->k_obj) ;
                        }
                    }   /* for */
                }   /* RAM */
                l_index-- ;
            }   /* while(l_index) */

            /* names in ROM dict are not chain to namelist */
            ERROR(UNDEFINED) ;
            return(FALSE) ;
        }   /* else */
    }   /* NAMETYPE */
    /*
     * if the key is NOT A NAME OBJECT,
     * search all dictionaries in the dictionary stack.
     * LINEAR SEARCH
     */
    l_index = dictstktop - 1 ;
    while( l_index >= 0 ) {
        if( get_dict(&dictstack[l_index], l_newp,
                    (struct object_def FAR * FAR *)&l_vtemp) ) {
            l_dhead = (struct dict_head_def FAR *)VALUE(&dictstack[l_index]) ;
            if( DACCESS(l_dhead) == NOACCESS)
                *p_flag = TRUE ;
            *p_value = l_vtemp ;
            return(TRUE) ;
        }
        l_index-- ;
    }   /* while(l_index) */

    ERROR(UNDEFINED) ;

    return(FALSE) ;
}   /* load_dict1 */

/***********************************************************************
**
** This function is used to change value field of a key object,
** (to get the name's id)
** if it is a nametype and belongs to RAM dictionary.
**
** TITLE:       change_namekey              Date:   08/01/87
** CALL:        change_namekey()            UpDate: Jul/12/88
** INTERFACE:
***********************************************************************/
static void near
change_namekey(p_oldkey, p_newkey)
struct  object_def  huge *p_oldkey ;
struct  object_def FAR *p_newkey ;
{
    struct  object_def  huge *l_curptr ;

    l_curptr = (struct object_def huge *)VALUE(p_oldkey) ;
    while( (ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE )
        l_curptr = (struct object_def huge *)VALUE(l_curptr) ;

    VALUE(p_newkey) = (ULONG_PTR)l_curptr ;

    return ;

}   /* change_namekey */

/***********************************************************************
**
** TITLE:       check_key_type              Date:   08/01/87
** CALL:        check_key_type()            UpDate: Jul/12/88
** INTERFACE:   get_dict:       5.3.1.4.17
**              load_dict1:     5.3.1.4.27
** CALLS:       sobj_to_nobj    5.3.1.4.25
***********************************************************************/
static bool near
check_key_type(p_key, p_newkey)
struct object_def  FAR *p_key, FAR *p_newkey ;
{
    COPY_OBJ(p_key, p_newkey) ;
    switch( TYPE(p_key) ) {
    case STRINGTYPE:
        if( ! sobj_to_nobj(p_key, p_newkey) )
            return(FALSE) ;             /* system error: name_to_id */
        break ;

    }   /* switch */

    return(TRUE) ;
}   /* check_key_type */

/***********************************************************************
**
** TITLE:       init_dict           Date:   08/01/87
** CALL:        init_dict()         UpDate: 08/27/87
** INTERFACE:   start:
***********************************************************************/
void
init_dict()
{
    dictstktop = 0 ;
    dictstkptr = dictstack;                     /* qqq */
    global_dictstkchg = 0 ;

    return ;
}   /* init_dict */

/***********************************************************************
**
** This submodule is actually to get the value object of a key object in a
** dictionary.
**
** TITLE:       get_dict                        Date:   08/01/87
** CALL:        get_dict()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
**              op_get:         5.3.1.4.9
**              op_known:       5.3.1.4.11
**              where:          5.3.1.4.21
** CALLS:       sobj_to_nobj:   5.3.1.4.25
**              equal_key:      5.3.1.4.30
**              get_pack_dict:
***********************************************************************/
bool
get_dict(p_dictobj, p_key, p_value)
struct object_def  FAR *p_dictobj, FAR *p_key, FAR * FAR *p_value ;
{
    bool    l_ram ;
    ufix16  l_index, l_actlength ;
    fix     l_id ;
    struct  object_def      l_newkey ;
    struct  object_def      huge *l_newp = &l_newkey ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr, huge *l_dtemp ;

    if(! check_key_type(p_key, l_newp) ) return(FALSE) ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dictobj) ;
    l_dptr = (struct dict_content_def huge *)
             ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    if( ! DROM(l_dhead) )
        l_ram = TRUE ;
    else  {
        l_ram = FALSE ;

        /* for get_pack_dict */
        if(DPACK(l_dhead)) {
            if( get_pack_dict(p_dictobj, p_key, p_value) )
                return(TRUE) ;
            else
                return(FALSE) ;
        }
    }   /* else */

    /*
     *  key is NAMETYPE && dict is a RAM dictionary
     */
    if( (TYPE(l_newp) == NAMETYPE) && l_ram ) {
        /*
         * search the name object list of name table
         * for the dictioanry's key-value pair
         */
        l_id = (fix)VALUE(l_newp) ;
        l_dict = name_table[l_id]->dict_ptr ;

        for( ; ;){
            /* LAST ENTRY is encountered: not found */
            if((ULONG_PTR)l_dict < SPECIAL_KEY_VALUE) return(FALSE) ;

            /* get the head address(content) of this dictionary structure */
            l_dtemp = DICT_NAME(l_dict) ;

            /* FOUND */
            if(l_dtemp == l_dptr) {
                *p_value = &(l_dict->v_obj) ;
                return(TRUE) ;
            }

            /* go to the next cell */
            l_dict = (struct dict_content_def huge *)VALUE(&l_dict->k_obj) ;

        }   /* end for */
    }   /* end if: NAMETYPE && RAM dictionary */

    /*
     *  OTHERS
     *
     *  find the key-value pair with LINEAR SEARCH
     */
    else {
        l_actlength = l_dhead->actlength ;

        /* LINEAR SEARCH */
        /* ?? get_virtual_data */
        for(l_index=0 ; l_index < l_actlength ; l_index++, l_dptr++) {
            switch( TYPE(&(l_dptr->k_obj)) ) {
                case NULLTYPE:              /* no element */
                    return(FALSE) ;

                case NAMETYPE:
                    if(l_ram) break ;       /* to next pair */

                default:
                    if( equal_key(&(l_dptr->k_obj), l_newp) ) {
                        *p_value = &(l_dptr->v_obj) ;
                        return(TRUE) ;
                    }
            }   /* switch */
        }   /* for */

        return(FALSE) ;
    }   /* else */
}   /* get_dict */

/***********************************************************************
**
** This submodule loads the value of the given key from a dictionary stack.
**
** TITLE:       load_dict                       Date:   08/01/87
** CALL:        load_dict()                     UpDate: Jul/12/88
** INTERFACE:   op_load:
** CALLS:       load_dict1      5.3.1.4.27
***********************************************************************/
bool
load_dict(p_key, p_value)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
{
    fix     l_flag = FALSE ;

    if( load_dict1(p_key, p_value, (fix FAR *)&l_flag) )
        return(TRUE) ;
    else
        return(FALSE) ;

}   /* load_dict */

/***********************************************************************
**
** This submodule defines a given key and value pair in the
** specified dictionary.
**
** TITLE:       put_dict            Date:   08/01/87
** CALL:        put_dict()          UpDate: Jul/12/88
** INTERFACE:
** CALLS:       put_dict1:      5.3.1.4.26
***********************************************************************/
bool
put_dict(p_dict, p_key, p_value)
struct  object_def  FAR *p_dict, FAR *p_key, FAR *p_value ;
{
    /* dict may be not in dictionary stack */
    if( put_dict1(p_dict, p_key, p_value, FALSE) )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* put_dict */

/***********************************************************************
**
** This submodule pushes various object onto the execution stack to
** establish the environment executing the dictionary forall.
**
** TITLE:       forall_dict         Date:   08/01/87
** CALL:        forall_dict()       UpDate: Jul/12/88
** INTERFACE:   op_forall:      5.3.1.4.13
***********************************************************************/
static bool near
forall_dict(p_dict, p_proc)
struct  object_def  FAR *p_dict, FAR *p_proc ;
{
    if( FREXECOUNT() < 4 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_dict) ;
    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0L) ;
    PUSH_EXEC_OP(AT_DICTFORALL) ;

    return(TRUE) ;
}   /* forall_dict */

/***********************************************************************
**
** This submodule copy the key-value pairs in a dictionary to
** another dictionary.
**
** TITLE:       copy_dict                       Date:   08/01/87
** CALL:        copy_dict()                     UpDate: Jul/12/88
** INTERFACE:   op_copy:            5.3.1.1.4
** CALLS:       get_dict:           5.3.1.4.17
**              change_namekey:     5.3.1.4.31
**              create_new_saveobj: 5.3.1.1.12
***********************************************************************/
bool
copy_dict(p_source, p_dest)
struct  object_def  FAR *p_source, FAR *p_dest ;
{
    ufix16  l_sactlength, l_index ;
    struct  object_def  l_otemp ;
    struct  dict_head_def   FAR *l_sdhead, FAR *l_ddhead ;
    struct  dict_content_def    huge *l_sdict ;

    /*
    ** check the second dictionary.
    ** It will not be defined with any key-value pairs
    */
    l_sdhead = (struct dict_head_def FAR *)VALUE(p_source) ;
    l_ddhead = (struct dict_head_def FAR *)VALUE(p_dest) ;

    /* check access right */
    if( (DACCESS(l_sdhead) == NOACCESS) ||
        (DACCESS(l_ddhead) != UNLIMITED) ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }
    if( (l_ddhead->actlength != 0) ||
        (l_sdhead->actlength > LENGTH(p_dest)) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    /*
     * copy the key-value pairs in the first dictionary
     * to the second dictionary
     */
    l_index = 0 ;
    l_sdict = (struct dict_content_def huge *)
              ( (byte FAR *)l_sdhead + sizeof(struct dict_head_def) ) ;

    l_sactlength = l_sdhead->actlength ;
    while( l_index++ < l_sactlength ) {

        COPY_OBJ( &(l_sdict->k_obj), &l_otemp ) ;
        /* get hash id of key object */
        if( (TYPE(&l_otemp) == NAMETYPE) && (! DROM(l_ddhead)) )
            change_namekey( &(l_sdict->k_obj), &l_otemp ) ;

        put_dict1(p_dest, &l_otemp, &(l_sdict->v_obj), FALSE) ;
        l_sdict++ ;
    }
    /* dict2's access right is same as the dict1 */
    DACCESS_SET(l_ddhead, DACCESS(l_sdhead)) ;

    return(TRUE) ;
}   /* copy_dict */

/***********************************************************************
**
** TITLE:       create_dict                     Date:   08/01/87
** CALL:        create_dict(obj, size)          UpDate: Jul/12/88
** INTERFACE:   op_dict:            5.3.1.4.1
** CALLS:       alloc_vm:           5.3.1.10.5
***********************************************************************/
bool
create_dict(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix    p_size ;
{
    ubyte    huge *l_dict ;
    ufix16  l_i ;
    struct  object_def  huge *l_otemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_contain ;

    l_dict = (ubyte huge *)
             extalloc_vm( (ufix32)p_size * sizeof(struct dict_content_def) +
                        sizeof(struct dict_head_def) ) ;


    if(l_dict != NIL) {
        l_dhead = (struct dict_head_def FAR *)l_dict ;
        DACCESS_SET(l_dhead, UNLIMITED) ;
        DPACK_SET(l_dhead, FALSE) ;
        DFONT_SET(l_dhead, FALSE) ;
        DROM_SET(l_dhead, FALSE) ;
        l_dhead->level = current_save_level ;
        l_dhead->actlength = 0 ;

        l_contain = (struct dict_content_def huge *)
                    ( l_dict + sizeof(struct dict_head_def) ) ;
        /*
         * INITIALIZE
         */
        for(l_i=0 ; l_i < p_size ; l_i++, l_contain++) {
            l_otemp = &(l_contain->k_obj) ;
            TYPE_SET(l_otemp, NULLTYPE) ;
            ATTRIBUTE_SET(l_otemp, LITERAL) ;
            ROM_RAM_SET(l_otemp, KEY_OBJECT) ;
            LEVEL_SET(l_otemp, current_save_level) ;

            LENGTH(l_otemp) = l_i ;
            VALUE(l_otemp) = NIL ;

            l_otemp = &(l_contain->v_obj) ;
            TYPE_SET(l_otemp, NULLTYPE) ;
            ATTRIBUTE_SET(l_otemp, LITERAL) ;
            ROM_RAM_SET(l_otemp, RAM) ;
            LEVEL_SET(l_otemp, current_save_level) ;

            LENGTH(l_otemp) = 0 ;
            VALUE(l_otemp) = NIL ;
        }   /* for */
    }  else
        return(FALSE) ;

    TYPE_SET(p_obj, DICTIONARYTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;

    LENGTH(p_obj) = (ufix16)p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_dict ;

    return(TRUE) ;
}   /* create_dict */

/***********************************************************************
**
** TITLE:       extract_dict                    Date:   08/01/87
** CALL:        extract_dict()                  UpDate: Jul/12/88
** INTERFACE:
** CALLS:       change_namekey:         5.3.1.4.31
**              extract_pack_dict:
***********************************************************************/
bool
extract_dict(p_dict, p_index, p_key, p_value)
struct  object_def  FAR *p_dict, FAR *p_key, FAR * FAR *p_value ;
ufix    p_index ;
{
    struct  object_def      FAR *l_key ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    if(p_index >= l_dhead->actlength) return(FALSE) ;
    l_dict = (struct dict_content_def huge *)
             ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    /* for extract_pack_dict */
    if( DROM(l_dhead) ) {
        if(DPACK(l_dhead)) {
            if( extract_pack_dict(p_dict, p_index, &l_key, p_value) ) {
            /*  @HC29 bug
                COPY_OBJ(l_key, p_key) ;
            */
                //DJC COPY_OBJ_1 causes data missaligne FAULT on MIPS
                //    because assumption was made about casting
                //    to double. Put back to COPY_OBJ and all seems
                //    fine.
                //DJC COPY_OBJ_1(l_key, p_key) ;       /* @HC29 */

                COPY_OBJ(l_key,p_key);
                return(TRUE) ;
            } else
                return(FALSE) ;
        }
    }

    l_dict += p_index ;
    COPY_OBJ( &(l_dict->k_obj), p_key ) ;

    if( (TYPE(p_key) == NAMETYPE) && (! DROM(l_dhead)) )
        change_namekey( p_key, p_key ) ;

    *p_value = &(l_dict->v_obj) ;

    return(TRUE) ;
}   /* extract_dict */

/***********************************************************************
**
** TITLE:       equal_key           Date:   08/01/87
** CALL:        equal_key()         UpDate: Jul/12/88
** INTERFACE:
** CALLS:       sobj_to_nobj:       5.3.1.4.25
***********************************************************************/
bool
equal_key(p_obj1, p_obj2)
struct  object_def  FAR *p_obj1, FAR *p_obj2 ;
{
    ufix16  l_type1, l_type2 ;
    ubyte   huge *l_str1, huge *l_str2 ;
    union   four_byte   l_num1, l_num2 ;
    struct  object_def  l_new1, l_new2 ;

    COPY_OBJ(p_obj1, &l_new1) ;
    COPY_OBJ(p_obj2, &l_new2) ;

    if( (TYPE(p_obj1) == STRINGTYPE) && (TYPE(p_obj2) == STRINGTYPE) )
        goto label_0 ;

    /*
     * STRINGTYPE ==> NAMETYPE
     */
    if( TYPE(p_obj1) == STRINGTYPE ) {
        if( ! sobj_to_nobj(p_obj1, &l_new1) )
            return(FALSE) ;     /* system error: name_to_id */
    } else {
        if( TYPE(p_obj2) == STRINGTYPE ) {
            if( ! sobj_to_nobj(p_obj2, &l_new2) )
                return(FALSE) ;             /* system error: name_to_id */
        }
    }

label_0:
    l_type1 = TYPE(&l_new1) ;
    l_type2 = TYPE(&l_new2) ;

    switch(l_type1) {
        case NAMETYPE:
        case BOOLEANTYPE:
        case OPERATORTYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) )
                return(TRUE) ;
            break ;

        case STRINGTYPE:    /* type1 = type2 */
            if( (l_type1 == l_type2) && (LENGTH(&l_new1) == LENGTH(&l_new2)) ) {
                if( (ACCESS(&l_new1) == NOACCESS) ||
                    (ACCESS(&l_new2) == NOACCESS) ) {
                    ERROR(INVALIDACCESS) ;
                    return(FALSE) ;
                }
                l_str1 = (ubyte huge *)VALUE(&l_new1) ;
                l_str2 = (ubyte huge *)VALUE(&l_new2) ;
                for( ; l_new1.length-- && (*l_str1++ == *l_str2++) ; ) ;
                if(LENGTH(&l_new1) == 0xFFFF)
                    return(TRUE) ;
            }
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case FILETYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) &&
                (LENGTH(&l_new1) == LENGTH(&l_new2)) )
                return(TRUE) ;
            break ;

        case DICTIONARYTYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) ) {
                /*
                l_dhead1 = (struct dict_head_def huge *)VALUE(&l_new1) ;
                l_dhead2 = (struct dict_head_def huge *)VALUE(&l_new2) ;
                */
                return(TRUE) ;
            }
            break ;
        /*
        **  if object1 is a number object: convert to FLOAT
        */
        case INTEGERTYPE:
            l_num1.ll = (fix32)VALUE(&l_new1) ;
            l_num1.ff = (real32)l_num1.ll ;
            goto label_1 ;
        case REALTYPE:
            l_num1.ll = (fix32)VALUE(&l_new1) ;
            goto label_1 ;

        case FONTIDTYPE:
        case SAVETYPE:
            break ;

        case MARKTYPE:
        case NULLTYPE:
            if( l_type1 == l_type2 )
                return(TRUE) ;
    }   /* switch */

    return(FALSE) ;

label_1:
    /*
    **  if object2 is a number object: convert to FLOAT
    */
    switch(l_type2) {
        case INTEGERTYPE:
            l_num2.ll = (fix32)VALUE(&l_new2) ;
            l_num2.ff = (real32)l_num2.ll ;
            goto label_2 ;
        case REALTYPE:
            l_num2.ll = (fix32)VALUE(&l_new2) ;
            goto label_2 ;

        default:
            return(FALSE) ;
    }   /* switch */

label_2:
    if( l_num1.ff == l_num2.ff )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* equal_key */

/***********************************************************************
**
** TITLE:       check_key_object            Date:   08/01/87
** CALL:        check_key_object()          UpDate: Jul/12/88
** INTERFACE:   op_restore:     5.3.1.10.2
***********************************************************************/
void
check_key_object(p_object)
struct  object_def  FAR *p_object ;
{
    struct  dict_head_def   FAR *l_dhead ;

    if( (TYPE(p_object) == NULLTYPE) &&
        (ROM_RAM(p_object) == KEY_OBJECT) ) {

        l_dhead = (struct dict_head_def FAR *)
                  ( (byte huge *)p_object -
                    LENGTH(p_object) * sizeof(struct dict_content_def) -
                    sizeof(struct dict_head_def) ) ;

        /* restore actual length of dictionary */
        l_dhead->actlength-- ;
    }
}   /* check_key_object */

/***********************************************************************
**
** TITLE:       change_dict_stack           Date:   08/01/87
** CALL:        change_dict_stack()         UpDate: Jul/12/88
** INTERFACE:   op_begin:   5.3.1.4.4
**              op_end:     5.3.1.4.5
***********************************************************************/
void
change_dict_stack()
{
    fix     l_index ;

    global_dictstkchg++ ;
    if(global_dictstkchg == 0) {            /* wrap around */
        global_dictstkchg++ ;

        /* change dict_found field of name_table ? */
        for(l_index=0 ; l_index < MAXHASHSZ ; l_index++)
            //DJC, added a check here for NULL dereference
            if (name_table[l_index] != (struct ntb_def *) NULL) {
               name_table[l_index]->dict_found = FALSE ;
            }else{
               printf("Warning....... Nane table[%d] is null",l_index); //TODO take out
            }
    }

    return ;
}   /* change_dict_stack */

/***********************************************************************
**
** TITLE:       sobj_to_nobj                Date:   08/01/87
** CALL:        sobj_to_nobj()              UpDate: Jul/12/88
** INTERFACE:
** CALLS:       name_to_id:
***********************************************************************/
bool
sobj_to_nobj(p_sobj, p_nobj)
struct  object_def  FAR *p_sobj, FAR *p_nobj ;
{
    fix16   l_id ;
    byte    FAR *l_str ;

    if( ACCESS(p_sobj) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    if( LENGTH(p_sobj) >= MAXNAMESZ ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    COPY_OBJ(p_sobj, p_nobj) ;
    if( LENGTH(p_sobj) == 0 )
        l_id = 0 ;
    else  {
        l_str = (byte FAR *)VALUE(p_sobj) ;
        if( ! name_to_id((byte FAR *)l_str,
                       (ufix16)LENGTH(p_sobj), &l_id, TRUE) )
            return(FALSE) ;
    }

    VALUE(p_nobj) = (ufix32)l_id ;
    TYPE_SET(p_nobj, NAMETYPE) ;

    return(TRUE) ;
}   /* sobj_to_nobj */

/***********************************************************************
**
** TITLE:       astore_stack                    Date:   12/03/87
** CALL:        astore_stack()                  UpDate: Jul/12/88
** INTERFACE:   op_dictstack
**              op_execstack
***********************************************************************/
bool
astore_stack(p_array, p_mode)
 struct  object_def  FAR *p_array ;
 fix     p_mode ;
{
    fix     l_index, l_i ;
    struct  object_def  FAR *l_obj ;

    /*
    ** copy the object in stack
    ** to the array in the operand stack
    */
    if(p_mode == DICTMODE) {
        l_obj = dictstack ;
        LENGTH(p_array) = dictstktop ;
    } else {
        l_obj = execstack ;
        LENGTH(p_array) = execstktop ;
    }
    l_i = (fix)LENGTH(p_array) ;
    for (l_index = 0 ; l_index < l_i ; l_index++, l_obj++)
        put_array(p_array, l_index, l_obj) ;

    return(TRUE) ;
}   /* astore_stack */

/***********************************************************************
**
** TITLE:       get_dict_valobj                 Date:   02/04/87
** CALL:        get_dict_valobj()               UpDate: Jul/12/88
** INTERFACE:
**
***********************************************************************/
bool
get_dict_valobj(p_value, p_dict, p_valobj)
ufix32  p_value ;
struct  object_def  FAR *p_dict, FAR * FAR *p_valobj ;
{
    ufix16  l_j, l_actlength ;
    struct  dict_content_def    huge *l_dcontain ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    l_actlength = l_dhead->actlength ;
    l_dcontain = (struct dict_content_def huge *)
                 ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    for(l_j=0 ; l_j < l_actlength ; l_j++, l_dcontain++) {
        if( p_value == VALUE(&l_dcontain->v_obj) ) {
            *p_valobj = &(l_dcontain->v_obj) ;
            return(TRUE) ;
        }
    }   /* for(l_j) */

    return(FALSE) ;
}   /* get_dict_valobj */

/* qqq, begin */
/*
************************************************************************
*
*   This submodule loads the value of the given key from a dictionary
*   stack.
*
*   Name:       load_name_obj
*
************************************************************************
*/
#ifdef  LINT_ARGS
bool    load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
#else
bool    load_name_obj();
#endif
bool
load_name_obj(p_key, p_value)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
{
    fix     l_id, l_index ;
    struct  object_def  huge *l_dictobj, huge *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr,
                                huge *l_dold, huge *l_fstptr ;

    l_id = (fix)VALUE(p_key) ;
    /*
     * if the name object is defined in a RAM dictionary,
     * it will be in the object lists in the name table.
     *
     * the dictionary cell is linked in the header entry
     */
    if( (name_table[l_id]->dstkchg == global_dictstkchg) &&
        (name_table[l_id]->dict_found) ) {
        /* get first element */
        *p_value = &(name_table[l_id]->dict_ptr->v_obj) ;
        return(TRUE) ;
    }
    /*
     *  RESCHEDULE NAME LIST
     */
    else {
        /*  link list */
        l_index = dictstktop -1 ;
        l_fstptr = name_table[l_id]->dict_ptr ;

        /*  get dictionary from dictionary stack */
        while( l_index >= 0 ) {
            l_dictobj = &dictstack[l_index] ;
            l_dhead = (struct dict_head_def huge *)VALUE(l_dictobj) ;

            if(DROM(l_dhead)) {
                /*
                 *  ROM
                 */
                if( get_dict(l_dictobj, p_key,
                            (struct object_def FAR * FAR*)&l_vtemp) ) {
                    name_table[l_id]->dict_found = FALSE ;
                    *p_value = l_vtemp ;
                    return(TRUE) ;
                }
                /* else: to next dict */
            }   /* ROM */
            else {
                /*
                 *  RAM
                 *
                 * search this RAM dictionary's address in link list
                 */
                if((ULONG_PTR)l_fstptr < SPECIAL_KEY_VALUE) {
                    l_index-- ;
                    continue ;
                }
                l_dict = l_fstptr ;                     /* name list */
                l_dold = NIL ;
                l_dptr = (struct dict_content_def huge *)
                         ((byte FAR *)l_dhead + sizeof(struct dict_head_def));
                for(;;) {
                    if( (ULONG_PTR)l_dict < SPECIAL_KEY_VALUE )  break ;
                    /*
                     * FOUND, this key in l_dictobj
                     */
                    if( DICT_NAME(l_dict) == l_dptr ) {
                        /* CHANGE THIS ELEMENT TO FRONT OF LIST */
                        if( l_dold != NIL ) {
                            VALUE(&l_dold->k_obj) = VALUE(&l_dict->k_obj) ;
                            VALUE(&l_dict->k_obj) = (ULONG_PTR)l_fstptr ;
                            name_table[l_id]->dict_ptr = l_dict ;
                        }
                        name_table[l_id]->dict_found = TRUE ;
                        name_table[l_id]->dstkchg = global_dictstkchg ;
                        *p_value = &(l_dict->v_obj) ;
                        return(TRUE) ;

                    } else {
                        /* to next element of name list */
                        l_dold = l_dict ;
                        l_dict = (struct dict_content_def huge *)
                                 VALUE(&l_dict->k_obj) ;
                    }
                }   /* for */
            }   /* RAM */
            l_index-- ;
        }   /* while(l_index) */

        /* names in ROM dict are not chain to namelist */
        ERROR(UNDEFINED) ;
        return(FALSE) ;
    }   /* else */
}   /* load_name_obj */
/* qqq, end */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\dict_tab.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * !!!IMPORTANT!!!
 *      1)please comment when you add or delete anything
 *      2)change exec.h
 *
 * revision history:
 *      7/13/90; ccteng; define #copies, manualfeedtimeout here
 *                      rename $printerdict to pagedict
 *      7/20/90; ccteng; 1)include language.h
 *                       2)redefine struct dicttab_def in global.ext
 *                       3)delete length element in every entries
 *                       4)clean out junks
 *                       5)delete internaldict, version, revision
 *                       6)add currentport, channelconfig, setchannelconfig
 *                         defaultchannelconfig, setdefaultchannelconfig
 *      7/21/90; ccteng; 1)move following stuff to PSPrep:
 *                         appletalktype, jobsource, jobname, manualfeed,
 *                         eerom
 *                       2)delete following for server change:
 *                         checkinputport, portarray, stdinname, PCbus,
 *                         Serial, Parallel, Network, Gio, execstdin,
 *                         enterserver, protectserver
 *      8/7/90; scchen;  1) added op_setfilecachelimit, op_filecachelimit
 *                       2) added st_selectsubstitutefont,
 *                                st_setsubstitutefonts,
 *                                st_substitutefonts
 *                       3) added op_readsfnt
 *      9/19/90; ccteng; add op_readhexsfnt
 */


// DJC added global include file
#include "psglobal.h"


#include "constant.h"
#include "global.ext"
#include "language.h"

/*
 *   1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 *   5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *  | ACCESS | LEVEL        | ROM | ATT | TYPE      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *
 * access: UNLIMITED ==> 0
 * level: 0 ==> 0
 * rom_ram: RAM ==> 0
 * att: LITERAL ==> 0
 */

#define     SYSOPREUBFD  (OPERATORTYPE | (EXECUTABLE << ATTRIBUTE_BIT))
#define     SYSPKAEUBFD  (PACKEDARRAYTYPE | (EXECUTABLE << ATTRIBUTE_BIT)
#define     SYSPKAERBFD  (PACKEDARRAYTYPE | (EXECUTABLE << ATTRIBUTE_BIT) | (READONLY << ACCESS_BIT))
#define     SYSDCTLUBFD  (DICTIONARYTYPE)
#define     SYSDCTLRBFD  (DICTIONARYTYPE | (READONLY << ACCESS_BIT))
#define     SYSDCTEUBFD  (DICTIONARYTYPE | (EXECUTABLE << ATTRIBUTE_BIT))
#define     SYSBOLLUBFD  (BOOLEANTYPE)
#define     SYSINTLUBFD  (INTEGERTYPE)
#define     SYSSTRLUBFD  (STRINGTYPE)
#define     SYSSTRLRBFD  (STRINGTYPE | (READONLY << ACCESS_BIT))
#define     SYSNULLUBFD  (NULLTYPE)
#define     SYSARYLRBFD  (ARRAYTYPE | (READONLY << ACCESS_BIT))

/* qqq, begin */
#define     INTOPREUBFD  ((OPERATORTYPE | P1_EXECUTABLE) | P1_ROM)
/* qqq, end */

// DJC DJC commented out
// #ifdef  _AM29K
// const
// #endif
struct dicttab_def far systemdict_table[] =
{
/* qqq, begin */
/* BEGIN @_operator */
{ TRUE , INTOPREUBFD, at_exec, "@exec" },
{ TRUE , INTOPREUBFD, at_ifor, "@ifor" },
{ TRUE , INTOPREUBFD, at_rfor, "@rfor" },
{ TRUE , INTOPREUBFD, at_loop, "@loop" },
{ TRUE , INTOPREUBFD, at_repeat, "@repeat" },
{ TRUE , INTOPREUBFD, at_stopped, "@stopped" },
{ TRUE , INTOPREUBFD, at_arrayforall, "@arrayforall" },
{ TRUE , INTOPREUBFD, at_dictforall, "@dictforall" },
{ TRUE , INTOPREUBFD, at_stringforall, "@stringforall" },
/* END   @operator */
/* qqq, end */

/* BEGIN systemdict */
{ FALSE, SYSOPREUBFD, two_equal, "==" },
{ FALSE, SYSOPREUBFD, op_pstack, "pstack" },
{ TRUE , SYSOPREUBFD, op_rcurveto, "rcurveto" },
{ TRUE , SYSOPREUBFD, op_floor, "floor" },
{ TRUE , SYSOPREUBFD, op_load, "load" },
{ TRUE , SYSOPREUBFD, op_counttomark, "counttomark" },
{ TRUE , SYSOPREUBFD, op_setlinejoin, "setlinejoin" },
{ TRUE , SYSOPREUBFD, op_write, "write" },
{ TRUE , SYSOPREUBFD, op_noaccess, "noaccess" },
{ TRUE , SYSOPREUBFD, op_scale, "scale" },
{ TRUE , SYSOPREUBFD, op_clippath, "clippath" },
{ TRUE , SYSOPREUBFD, op_setrgbcolor, "setrgbcolor" },
{ TRUE , SYSOPREUBFD, op_setscreen, "setscreen" },
{ TRUE , SYSOPREUBFD, op_exp, "exp" },
{ TRUE , SYSOPREUBFD, op_anchorsearch, "anchorsearch" },
{ TRUE , SYSOPREUBFD, op_end, "end" },
{ TRUE , SYSOPREUBFD, op_xor, "xor" },
{ TRUE , SYSOPREUBFD, op_bytesavailable, "bytesavailable" },
{ TRUE , SYSOPREUBFD, op_awidthshow, "awidthshow" },
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "true" },
{ TRUE , SYSOPREUBFD, op_dup, "dup" },
{ TRUE , SYSOPREUBFD, op_getinterval, "getinterval" },
{ TRUE , SYSOPREUBFD, op_currentdash, "currentdash" },
{ TRUE , SYSOPREUBFD, op_currentcacheparams, "currentcacheparams" },
{ TRUE , SYSOPREUBFD, op_moveto, "moveto" },
{ TRUE , SYSOPREUBFD, op_bind, "bind" },
{ TRUE , SYSOPREUBFD, op_pop, "pop" },
{ TRUE , SYSOPREUBFD, op_flattenpath, "flattenpath" },
{ TRUE , SYSOPREUBFD, op_gsave, "gsave" },
{ TRUE , SYSOPREUBFD, op_cachestatus, "cachestatus" },
{ TRUE , SYSOPREUBFD, op_definefont, "definefont" },
{ TRUE , SYSOPREUBFD, op_defaultmatrix, "defaultmatrix" },
{ TRUE , SYSOPREUBFD, op_kshow, "kshow" },
{ TRUE , SYSOPREUBFD, op_setcachedevice, "setcachedevice" },
{ TRUE , SYSOPREUBFD, op_countexecstack, "countexecstack" },
{ TRUE , SYSOPREUBFD, op_abs, "abs" },
{ TRUE , SYSOPREUBFD, op_strokepath, "strokepath" },
{ TRUE , SYSOPREUBFD, op_arcn, "arcn" },
{ TRUE , SYSOPREUBFD, op_currenttransfer, "currenttransfer" },
{ TRUE , SYSOPREUBFD, op_and, "and" },
{ TRUE , SYSOPREUBFD, op_repeat, "repeat" },
{ TRUE , SYSOPREUBFD, op_eexec, "eexec" },
{ TRUE , SYSOPREUBFD, op_xcheck, "xcheck" },
{ TRUE , SYSOPREUBFD, op_idtransform, "idtransform" },
{ TRUE , SYSOPREUBFD, op_restore, "restore" },
{ TRUE , SYSOPREUBFD, op_daytime, "daytime" },
{ FALSE, SYSDCTLUBFD, 0, "errordict" },
{ TRUE , SYSOPREUBFD, op_l_bracket, "[" },
{ TRUE , SYSOPREUBFD, op_setpacking, "setpacking" },
{ TRUE , SYSOPREUBFD, op_stop, "stop" },
{ TRUE , SYSOPREUBFD, op_file, "file" },
{ TRUE , SYSOPREUBFD, op_print, "print" },
{ TRUE , SYSOPREUBFD, op_loop, "loop" },
{ TRUE , SYSOPREUBFD, op_string, "string" },
{ TRUE , SYSOPREUBFD, op_cvx, "cvx" },
{ TRUE , SYSOPREUBFD, op_mul, "mul" },
{ FALSE, SYSNULLUBFD, 0, "null" },
{ TRUE , SYSOPREUBFD, op_roll, "roll" },
{ TRUE , SYSOPREUBFD, op_known, "known" },
{ TRUE , SYSOPREUBFD, op_idiv, "idiv" },
{ TRUE , SYSOPREUBFD, op_eq, "eq" },
{ TRUE , SYSOPREUBFD, op_sin, "sin" },
{ TRUE , SYSOPREUBFD, op_ln, "ln" },
{ TRUE , SYSOPREUBFD, op_transform, "transform" },
{ TRUE , SYSOPREUBFD, op_dtransform, "dtransform" },
{ TRUE , SYSOPREUBFD, op_currentmiterlimit,"currentmiterlimit" },
{ TRUE , SYSOPREUBFD, op_lineto, "lineto" },
{ TRUE , SYSOPREUBFD, op_neg, "neg" },
{ TRUE , SYSOPREUBFD, op_stopped, "stopped" },
{ TRUE , SYSOPREUBFD, op_r_bracket, "]" },
{ TRUE , SYSOPREUBFD, op_setlinewidth, "setlinewidth" },
{ TRUE , SYSOPREUBFD, op_rlineto, "rlineto" },
{ TRUE , SYSOPREUBFD, op_concat, "concat" },
{ TRUE , SYSOPREUBFD, op_dictstack, "dictstack" },
{ TRUE , SYSOPREUBFD, op_cos, "cos" },
{ TRUE , SYSOPREUBFD, op_clip, "clip" },
{ TRUE , SYSOPREUBFD, op_ge, "ge" },
{ TRUE , SYSOPREUBFD, op_eoclip, "eoclip" },
{ TRUE , SYSOPREUBFD, op_currentfont, "currentfont" },
{ TRUE , SYSOPREUBFD, op_sethsbcolor, "sethsbcolor" },
{ FALSE, SYSBOLLUBFD, FALSE, "false" },
{ TRUE , SYSOPREUBFD, op_currentlinewidth, "currentlinewidth" },
{ TRUE , SYSOPREUBFD, op_index, "index" },
{ TRUE , SYSOPREUBFD, op_settransfer, "settransfer" },
{ TRUE , SYSOPREUBFD, op_currentflat, "currentflat" },
{ TRUE , SYSOPREUBFD, op_currenthsbcolor, "currenthsbcolor" },
{ TRUE , SYSOPREUBFD, op_showpage, "showpage" },
{ TRUE , SYSOPREUBFD, op_makefont, "makefont" },
{ TRUE , SYSOPREUBFD, op_setcharwidth, "setcharwidth" },
{ TRUE , SYSOPREUBFD, op_setcachelimit, "setcachelimit" },
{ TRUE , SYSOPREUBFD, op_framedevice, "framedevice" },
{ FALSE, SYSOPREUBFD, op_stack, "stack" },
{ TRUE , SYSOPREUBFD, op_store, "store" },
{ FALSE, SYSOPREUBFD, one_equal, "=" },
{ TRUE , SYSOPREUBFD, op_ceiling, "ceiling" },
{ TRUE , SYSOPREUBFD, op_mark, "mark" },
{ TRUE , SYSOPREUBFD, op_setdash, "setdash" },
{ TRUE , SYSOPREUBFD, op_setlinecap, "setlinecap" },
{ TRUE , SYSOPREUBFD, op_grestoreall, "grestoreall" },
{ TRUE , SYSOPREUBFD, op_currentrgbcolor, "currentrgbcolor" },
{ TRUE , SYSOPREUBFD, op_def, "def" },
{ TRUE , SYSOPREUBFD, op_where, "where" },
{ TRUE , SYSOPREUBFD, op_clear, "clear" },
{ TRUE , SYSOPREUBFD, op_cleartomark, "cleartomark" },
{ TRUE , SYSOPREUBFD, op_truncate, "truncate" },
{ TRUE , SYSOPREUBFD, op_dict, "dict" },
{ TRUE , SYSOPREUBFD, op_gt, "gt" },
{ TRUE , SYSOPREUBFD, op_currentlinecap, "currentlinecap" },
{ TRUE , SYSOPREUBFD, op_setmiterlimit, "setmiterlimit" },
{ TRUE , SYSOPREUBFD, op_currentlinejoin, "currentlinejoin" },
{ TRUE , SYSOPREUBFD, op_maxlength, "maxlength" },
{ TRUE , SYSOPREUBFD, op_countdictstack, "countdictstack" },
{ TRUE , SYSOPREUBFD, op_ne, "ne" },
{ TRUE , SYSOPREUBFD, op_count, "count" },
{ TRUE , SYSOPREUBFD, op_lt, "lt" },
{ TRUE , SYSOPREUBFD, op_setfont, "setfont" },
{ TRUE , SYSOPREUBFD, op_setgray, "setgray" },
{ TRUE , SYSOPREUBFD, op_newpath, "newpath" },
{ TRUE , SYSDCTLUBFD, 0, "statusdict" },
{ TRUE , SYSOPREUBFD, op_exch, "exch" },
{ TRUE , SYSOPREUBFD, op_le, "le" },
{ TRUE , SYSOPREUBFD, op_vmstatus, "vmstatus" },
{ TRUE , SYSOPREUBFD, op_currentgray, "currentgray" },
{ TRUE , SYSOPREUBFD, op_setflat, "setflat"},
{ TRUE , SYSOPREUBFD, op_or, "or" },
{ TRUE , SYSOPREUBFD, op_run, "run" },
{ TRUE , SYSOPREUBFD, op_reversepath, "reversepath" },
{ TRUE , SYSOPREUBFD, op_widthshow, "widthshow" },
{ TRUE , SYSOPREUBFD, op_type, "type" },
{ TRUE , SYSOPREUBFD, op_put, "put" },
{ TRUE , SYSOPREUBFD, op_stroke, "stroke" },
{ TRUE , SYSOPREUBFD, op_execstack, "execstack" },
{ TRUE , SYSOPREUBFD, op_round, "round" },
{ TRUE , SYSOPREUBFD, op_image, "image" },
{ TRUE , SYSOPREUBFD, op_packedarray, "packedarray" },
{ TRUE , SYSOPREUBFD, op_translate, "translate" },
{ FALSE, SYSARYLRBFD, 0, "StandardEncoding" },
{ TRUE , SYSOPREUBFD, op_grestore, "grestore" },
{ TRUE , SYSOPREUBFD, op_begin, "begin" },
{ TRUE , SYSOPREUBFD, op_readline, "readline" },
{ TRUE , SYSOPREUBFD, op_findfont, "findfont" },
{ TRUE , SYSOPREUBFD, op_currentscreen, "currentscreen" },
{ TRUE , SYSOPREUBFD, op_setcacheparams, "setcacheparams" },
{ TRUE , SYSOPREUBFD, op_initclip, "initclip" },
{ TRUE , SYSOPREUBFD, op_token, "token" },
{ TRUE , SYSOPREUBFD, op_itransform, "itransform" },
{ TRUE , SYSOPREUBFD, op_currentdict, "currentdict" },
{ TRUE , SYSOPREUBFD, op_stringwidth, "stringwidth" },
{ TRUE , SYSOPREUBFD, op_currentpoint, "currentpoint" },
{ TRUE , SYSOPREUBFD, op_save, "save" },
{ TRUE , SYSOPREUBFD, op_exec, "exec" },
{ TRUE , SYSOPREUBFD, op_cvrs, "cvrs" },
{ TRUE , SYSOPREUBFD, op_rcheck, "rcheck" },
{ TRUE , SYSOPREUBFD, op_sub, "sub" },
{ TRUE , SYSOPREUBFD, op_atan, "atan" },
{ TRUE , SYSOPREUBFD, op_read, "read" },
{ TRUE , SYSOPREUBFD, op_cvs, "cvs" },
{ TRUE , SYSOPREUBFD, op_for, "for" },
{ TRUE , SYSOPREUBFD, op_search, "search" },
{ TRUE , SYSOPREUBFD, op_cvlit, "cvlit" },
{ TRUE , SYSOPREUBFD, op_currentpacking, "currentpacking" },
{ TRUE , SYSOPREUBFD, op_mod, "mod" },
{ TRUE , SYSOPREUBFD, op_log, "log" },
{ TRUE , SYSOPREUBFD, op_exit, "exit" },
{ FALSE, SYSDCTEUBFD, 0, "userdict" },
{ TRUE , SYSOPREUBFD, op_div, "div" },
{ TRUE , SYSOPREUBFD, op_length, "length" },
{ TRUE , SYSOPREUBFD, op_echo, "echo" },
{ TRUE , SYSOPREUBFD, op_cvn, "cvn" },
{ TRUE , SYSOPREUBFD, op_not, "not" },
{ TRUE , SYSOPREUBFD, op_rotate, "rotate" },
{ TRUE , SYSOPREUBFD, op_rmoveto, "rmoveto" },
{ FALSE, SYSDCTLRBFD, 0, "systemdict" },
{ TRUE , SYSOPREUBFD, op_curveto, "curveto" },
{ TRUE , SYSOPREUBFD, op_sqrt, "sqrt" },
{ TRUE , SYSOPREUBFD, op_usertime, "usertime" },
{ TRUE , SYSOPREUBFD, op_ifelse, "ifelse" },
{ TRUE , SYSOPREUBFD, op_wcheck, "wcheck" },
{ TRUE , SYSOPREUBFD, op_resetfile, "resetfile" },
{ TRUE , SYSOPREUBFD, op_add, "add" },
{ TRUE , SYSOPREUBFD, op_array, "array" },
{ TRUE , SYSOPREUBFD, op_srand, "srand" },
{ TRUE , SYSOPREUBFD, op_arc, "arc" },
{ TRUE , SYSOPREUBFD, op_arcto, "arcto" },
{ TRUE , SYSOPREUBFD, op_identmatrix, "identmatrix" },
{ TRUE , SYSOPREUBFD, op_writestring, "writestring" },
{ TRUE , SYSOPREUBFD, op_flushfile, "flushfile" },
{ TRUE , SYSOPREUBFD, op_if, "if" },
{ TRUE , SYSOPREUBFD, op_rrand, "rrand" },
{ TRUE , SYSOPREUBFD, op_readonly, "readonly" },
{ TRUE , SYSOPREUBFD, op_forall, "forall" },
{ TRUE , SYSOPREUBFD, op_closepath, "closepath" },
{ TRUE , SYSOPREUBFD, op_readhexstring, "readhexstring" },
{ TRUE , SYSOPREUBFD, op_currentmatrix, "currentmatrix" },
{ TRUE , SYSOPREUBFD, op_concatmatrix, "concatmatrix" },
{ TRUE , SYSOPREUBFD, op_setmatrix, "setmatrix" },
{ TRUE , SYSOPREUBFD, op_initmatrix, "initmatrix" },
{ TRUE , SYSOPREUBFD, op_initgraphics, "initgraphics" },
{ TRUE , SYSOPREUBFD, op_astore, "astore" },
{ TRUE , SYSOPREUBFD, op_currentfile, "currentfile" },
{ TRUE , SYSOPREUBFD, op_erasepage, "erasepage" },
{ TRUE , SYSOPREUBFD, op_copypage, "copypage" },
{ TRUE , SYSOPREUBFD, op_aload, "aload" },
{ TRUE , SYSOPREUBFD, op_writehexstring, "writehexstring" },
{ TRUE , SYSOPREUBFD, op_flush, "flush" },
{ TRUE , SYSOPREUBFD, op_readstring, "readstring" },
{ TRUE , SYSOPREUBFD, op_executeonly, "executeonly" },
{ TRUE , SYSOPREUBFD, op_get, "get" },
{ TRUE , SYSOPREUBFD, op_cvi, "cvi" },
{ TRUE , SYSOPREUBFD, op_putinterval, "putinterval" },
{ TRUE , SYSOPREUBFD, op_bitshift, "bitshift" },
{ TRUE , SYSOPREUBFD, op_rand, "rand" },
{ TRUE , SYSOPREUBFD, op_matrix, "matrix" },
{ TRUE , SYSOPREUBFD, op_invertmatrix, "invertmatrix" },
{ TRUE , SYSOPREUBFD, op_fill, "fill" },
{ TRUE , SYSOPREUBFD, op_pathforall, "pathforall" },
{ TRUE , SYSOPREUBFD, op_imagemask, "imagemask" },
{ TRUE , SYSOPREUBFD, op_quit, "quit" },
{ TRUE , SYSOPREUBFD, op_charpath, "charpath" },
{ TRUE , SYSOPREUBFD, op_pathbbox, "pathbbox" },
{ TRUE , SYSOPREUBFD, op_show, "show" },
{ TRUE , SYSOPREUBFD, op_ashow, "ashow" },
{ TRUE , SYSOPREUBFD, op_scalefont, "scalefont" },
{ FALSE, SYSDCTLRBFD, 0, "FontDirectory" },
{ FALSE, SYSDCTLUBFD, 0, "$error" },
{ TRUE , SYSOPREUBFD, op_nulldevice, "nulldevice" },
{ TRUE , SYSOPREUBFD, op_cvr, "cvr" },
{ TRUE , SYSOPREUBFD, op_status, "status" },
{ TRUE , SYSOPREUBFD, op_closefile, "closefile" },
{ TRUE , SYSOPREUBFD, op_copy, "copy" },
{ TRUE , SYSOPREUBFD, op_eofill, "eofill" },
{ FALSE, SYSOPREUBFD, op_handleerror, "handleerror" },
{ FALSE, SYSOPREUBFD, np_Run, "Run" },
{ FALSE, SYSOPREUBFD, one_equal_print, "=print" },
#ifdef KANJI
{ FALSE, SYSOPREUBFD, op_rootfont, "rootfont" },
/*{ FALSE, SYSOPREUBFD, op_cshow, "cshow" }, 5-9-1991 */
{ FALSE, SYSOPREUBFD, op_setcachedevice2, "setcachedevice2" },
{ FALSE, SYSOPREUBFD, op_findencoding, "findencoding" },
#endif  /* KANJI */
#ifdef SCSI
{ TRUE , SYSOPREUBFD, op_deletefile, "deletefile" },
{ TRUE , SYSOPREUBFD, op_devdismount, "devdismount" },
{ TRUE , SYSOPREUBFD, op_devmount, "devmount" },
{ TRUE , SYSOPREUBFD, op_devstatus, "devstatus" },
{ TRUE , SYSOPREUBFD, op_filenameforall, "filenameforall" },
{ TRUE , SYSOPREUBFD, op_renamefile, "renamefile" },
{ TRUE , SYSOPREUBFD, op_sync, "sync" },
{ TRUE , SYSOPREUBFD, op_setsysmode, "setsysmode" },
{ FALSE, SYSOPREUBFD, op_debugscsi, "debugscsi" },
{ TRUE , SYSOPREUBFD, op_setfilecachelimit, "setfilecachelimit" },
{ TRUE , SYSOPREUBFD, op_filecachelimit, "filecachelimit" },
#endif  /* SCSI */
{ FALSE, SYSOPREUBFD, op_readsfnt, "readsfnt" },
{ FALSE, SYSOPREUBFD, op_readhexsfnt, "readhexsfnt" },
/* OSS: Danny, 10/11/90 */
{ FALSE, SYSOPREUBFD, op_setsfntencoding, "setsfntencoding" },
/* OSS: end             */
#ifdef WIN
{ FALSE, SYSOPREUBFD, op_setpattern, "setpattern" },
{ FALSE, SYSOPREUBFD, op_patfill, "patfill" },
#ifdef WINF
{ FALSE, SYSOPREUBFD, op_strblt, "strblt" },
{ FALSE, SYSOPREUBFD, op_setjustify, "setjustify" },
#endif
#endif
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   systemdict */
/* BEGIN statusdict */
{ TRUE , SYSOPREUBFD, st_eescratch, "eescratch" },
{ TRUE , SYSOPREUBFD, st_printername, "printername" },
{ TRUE , SYSOPREUBFD, st_checkpassword, "checkpassword" },
{ TRUE , SYSOPREUBFD, st_defaulttimeouts, "defaulttimeouts" },
{ TRUE , SYSOPREUBFD, st_pagestackorder, "pagestackorder" },
{ FALSE, SYSINTLUBFD, (fix (*)())60, "manualfeedtimeout" },
{ TRUE , SYSOPREUBFD, st_setidlefonts, "setidlefonts" },
{ TRUE , SYSOPREUBFD, st_setdefaulttimeouts, "setdefaulttimeouts" },
{ TRUE , SYSOPREUBFD, st_sccbatch, "sccbatch" },
{ TRUE , SYSOPREUBFD, st_printererror, "printererror" },
{ TRUE , SYSOPREUBFD, st_setpassword, "setpassword" },
{ TRUE , SYSOPREUBFD, st_setsccbatch, "setsccbatch" },
{ TRUE , SYSOPREUBFD, st_setmargins, "setmargins" },
{ TRUE , SYSOPREUBFD, st_sccinteractive, "sccinteractive" },
{ TRUE , SYSOPREUBFD, st_idlefonts, "idlefonts" },
{ TRUE , SYSOPREUBFD, st_setjobtimeout, "setjobtimeout" },
{ TRUE , SYSOPREUBFD, st_setpagetype, "setpagetype" },
{ TRUE , SYSOPREUBFD, st_pagecount, "pagecount" },
{ TRUE , SYSOPREUBFD, st_dostartpage, "dostartpage" },
{ TRUE , SYSOPREUBFD, st_jobtimeout, "jobtimeout" },
{ TRUE , SYSOPREUBFD, st_setdostartpage, "setdostartpage" },
{ TRUE , SYSOPREUBFD, st_frametoprinter, "frametoprinter" },
{ FALSE, SYSINTLUBFD, 0, "waittimeout" },
{ TRUE , SYSOPREUBFD, st_setsccinteractive, "setsccinteractive" },
{ TRUE , SYSOPREUBFD, st_pagetype, "pagetype" },
{ TRUE , SYSOPREUBFD, st_margins, "margins" },
{ TRUE , SYSOPREUBFD, st_setprintername, "setprintername" },
{ TRUE , SYSOPREUBFD, st_seteescratch, "seteescratch" },
{ TRUE , SYSOPREUBFD, st_setstdio, "setstdio" },
{ TRUE , SYSOPREUBFD, st_softwareiomode   , "softwareiomode" },
{ TRUE , SYSOPREUBFD, st_setsoftwareiomode, "setsoftwareiomode" },
{ TRUE , SYSOPREUBFD, st_hardwareiomode   , "hardwareiomode" },
{ TRUE , SYSOPREUBFD, st_sethardwareiomode, "sethardwareiomode" },
{ FALSE, SYSOPREUBFD, st_countnode, "countnode" },
{ FALSE, SYSOPREUBFD, st_countedge, "countedge" },
{ FALSE, SYSOPREUBFD, st_dumpclip, "dumpclip" },
{ FALSE, SYSOPREUBFD, st_dumppath, "dumppath" },
#ifdef SCSI
{ TRUE , SYSOPREUBFD, st_cartstatus, "cartstatus" },
{ TRUE , SYSOPREUBFD, st_diskonline, "diskonline" },
{ TRUE , SYSOPREUBFD, st_diskstatus, "diskstatus" },
{ TRUE , SYSOPREUBFD, st_initializedisk, "initializedisk" },
{ TRUE , SYSOPREUBFD, st_setuserdiskpercent, "setuserdiskpercent" },
{ TRUE , SYSOPREUBFD, st_userdiskpercent, "userdiskpercent" },
{ TRUE , SYSOPREUBFD, st_dosysstart, "dosysstart" },
{ TRUE , SYSOPREUBFD, st_setsysstart, "setsysstart" },
{ TRUE , SYSOPREUBFD, st_flushcache, "flushcache" },
#endif  /* SCSI */
#ifdef SFNT
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "?_Royal" },
#endif /* SFNT */
#ifdef FIND_SUB
{ FALSE, SYSOPREUBFD, st_selectsubstitutefont, "selectsubstitutefont" },
{ FALSE, SYSOPREUBFD, st_setsubstitutefonts, "setsubstitutefonts" },
{ FALSE, SYSOPREUBFD, st_substitutefonts, "substitutefonts" },
#endif /* FIND_SUB */
{ FALSE, SYSOPREUBFD, st_checksum, "checksum" },
{ FALSE, SYSOPREUBFD, st_ramsize, "ramsize" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   statusdict */
/* BEGIN userdict */
{ FALSE, SYSINTLUBFD, (fix (*)())1, "#copies" },
{ FALSE, SYSOPREUBFD, us_cleardictstack, "cleardictstack" },
{ FALSE, SYSOPREUBFD, us_letter, "letter" },
{ FALSE, SYSOPREUBFD, us_lettersmall, "lettersmall" },
{ FALSE, SYSOPREUBFD, us_a4, "a4" },
{ FALSE, SYSOPREUBFD, us_a4small, "a4small" },
{ FALSE, SYSOPREUBFD, us_b5, "b5" },
{ FALSE, SYSOPREUBFD, us_note, "note" },
{ FALSE, SYSOPREUBFD, us_legal, "legal" },
{ FALSE, SYSOPREUBFD, us_prompt, "prompt" },
{ FALSE, SYSOPREUBFD, us_quit, "quit" },
{ FALSE, SYSOPREUBFD, us_executive, "executive" },
{ FALSE, SYSOPREUBFD, us_start, "start" },
{ FALSE, SYSDCTLUBFD, 0, "serverdict" },
{ FALSE, SYSDCTLUBFD, 0, "execdict" },
{ FALSE, SYSDCTLUBFD, 0, "printerdict" },
{ FALSE, SYSDCTLUBFD, 0, "$idleTimeDict" },

//DJC add support for dictionary to hold pstodib specific stuff
{ FALSE, SYSDCTLUBFD, 0, "psprivatedict" },

{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   userdict */
/* BEGIN errordict */
{ FALSE, SYSOPREUBFD, er_dictfull, "dictfull" },
{ FALSE, SYSOPREUBFD, er_dictstackoverflow, "dictstackoverflow" },
{ FALSE, SYSOPREUBFD, er_dictstackunderflow, "dictstackunderflow" },
{ FALSE, SYSOPREUBFD, er_execstackoverflow, "execstackoverflow" },
{ FALSE, SYSOPREUBFD, er_invalidaccess, "invalidaccess" },
{ FALSE, SYSOPREUBFD, er_invalidexit, "invalidexit" },
{ FALSE, SYSOPREUBFD, er_invalidfileaccess, "invalidfileaccess" },
{ FALSE, SYSOPREUBFD, er_invalidfont, "invalidfont" },
{ FALSE, SYSOPREUBFD, er_invalidrestore, "invalidrestore" },
{ FALSE, SYSOPREUBFD, er_ioerror, "ioerror" },
{ FALSE, SYSOPREUBFD, er_limitcheck, "limitcheck" },
{ FALSE, SYSOPREUBFD, er_nocurrentpoint, "nocurrentpoint" },
{ FALSE, SYSOPREUBFD, er_rangecheck, "rangecheck" },
{ FALSE, SYSOPREUBFD, er_stackoverflow, "stackoverflow" },
{ FALSE, SYSOPREUBFD, er_stackunderflow, "stackunderflow" },
{ FALSE, SYSOPREUBFD, er_syntaxerror, "syntaxerror" },
{ FALSE, SYSOPREUBFD, er_timeout, "timeout" },
{ FALSE, SYSOPREUBFD, er_typecheck, "typecheck" },
{ FALSE, SYSOPREUBFD, er_undefined, "undefined" },
{ FALSE, SYSOPREUBFD, er_undefinedfilename, "undefinedfilename" },
{ FALSE, SYSOPREUBFD, er_undefinedresult, "undefinedresult" },
{ FALSE, SYSOPREUBFD, er_unmatchedmark, "unmatchedmark" },
{ FALSE, SYSOPREUBFD, er_unregistered, "unregistered" },
{ FALSE, SYSOPREUBFD, er_VMerror, "VMerror" },
{ FALSE, SYSOPREUBFD, er_interrupt, "interrupt" },
{ FALSE, SYSOPREUBFD, er_handleerror, "handleerror" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   errordict */
/* BEGIN serverdict */
{ FALSE, SYSOPREUBFD, se_settimeouts, "settimeouts" },
{ FALSE, SYSOPREUBFD, se_exitserver, "exitserver" },
{ FALSE, SYSNULLUBFD, 0, "stdin" },
{ FALSE, SYSNULLUBFD, 0, "stdout" },
{ FALSE, SYSOPREUBFD, se_setrealdevice, "setrealdevice" }, /* 1/25/90 ccteng */
{ FALSE, SYSOPREUBFD, se_execjob, "execjob" }, /* 1/25/90 ccteng for LaserPrep */
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   serverdict */
/* BEGIN printerdict */
{ FALSE, SYSNULLUBFD, 0, "letter" },
{ FALSE, SYSNULLUBFD, 0, "lettersmall" },
{ FALSE, SYSNULLUBFD, 0, "a4" },
{ FALSE, SYSNULLUBFD, 0, "a4small" },
{ FALSE, SYSNULLUBFD, 0, "b5" },
{ FALSE, SYSNULLUBFD, 0, "note" },
{ FALSE, SYSNULLUBFD, 0, "legal" },
{ FALSE, SYSNULLUBFD, 0, "printerarray" },
{ FALSE, SYSNULLUBFD, 0, "defaultmtx" },
{ FALSE, SYSNULLUBFD, 0, "mtx" },
{ FALSE, SYSOPREUBFD, pr_proc, "proc" },
{ FALSE, SYSNULLUBFD, 0, "currentpagetype" },
{ FALSE, SYSINTLUBFD, 0, "width" },
{ FALSE, SYSINTLUBFD, 0, "height" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   printerdict */
/* BEGIN $idleTimeDict */
{ FALSE, SYSNULLUBFD, 0, "cachestring" },
{ FALSE, SYSNULLUBFD, 0, "stdfontname" },
{ FALSE, SYSNULLUBFD, 0, "cachearray" },
{ FALSE, SYSNULLUBFD, 0, "defaultarray" },
{ FALSE, SYSINTLUBFD, 0, "carrayindex" },
{ FALSE, SYSINTLUBFD, 0, "cstringindex" },
{ FALSE, SYSNULLUBFD, 0, "cstring" },
{ FALSE, SYSNULLUBFD, 0, "citem" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   $idleTimeDict */
/* BEGIN execdict */
{ FALSE, SYSINTLUBFD, 0, "execdepth" },
{ FALSE, SYSNULLUBFD, 0, "stmtfile" },                 /* SYSINTLUBFD -> SYSOPREUBFD */
{ FALSE, SYSOPREUBFD, ex_idleproc, "idleproc" },       /* 0 -> ex_execdepth */
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   execdict */
/* BEGIN $errordict */
{ FALSE, SYSBOLLUBFD, FALSE, "newerror" },
{ FALSE, SYSNULLUBFD, 0, "errorname" },
{ FALSE, SYSNULLUBFD, 0, "command" },
{ FALSE, SYSNULLUBFD, 0, "ostack" },
{ FALSE, SYSNULLUBFD, 0, "estack" },
{ FALSE, SYSNULLUBFD, 0, "dstack" },
{ FALSE, SYSNULLUBFD, 0, "opnstkary" },
{ FALSE, SYSNULLUBFD, 0, "dictstkary" },
{ FALSE, SYSNULLUBFD, 0, "execstkary" },
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "runbatch" },
{ FALSE, SYSBOLLUBFD, FALSE, "$debug" },
{ FALSE, SYSNULLUBFD, 0, "$cur_font" },
{ FALSE, SYSNULLUBFD, 0, "$cur_vm" },
{ FALSE, SYSNULLUBFD, 0, "$cur_screen" },
{ FALSE, SYSNULLUBFD, 0, "$cur_matrix" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   $errordict */
/* BEGIN psprivatedict */  //DJC added
//DJC added
{ FALSE, SYSINTLUBFD, 0, "psprivatepagetype" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL }
/* END   psprivatedict */
} ; /* systemdict_table[] */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\dumint.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DUMINT.C
 *
 * Revision History:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geierr.h"
#include    "language.h"
#include    "file.h"
#include    "user.h"
#include    "geiioctl.h"                /*@WIN*/
#include    "geipm.h"

extern  bool16  int_flag ;
bool16  eable_int ;
bool16  int_flag ;

#define _MAXEESCRATCHARRY       64

/***********************************************************************
** TITLE:       op_clearinterrupt               Dec-05-88
***********************************************************************/
fix
op_clearinterrupt()
{
    if(int_flag)
        int_flag = 0 ;

    eable_int = 1 ;

    return(0) ;
}   /* op_clearinterrupt */

/***********************************************************************
** TITLE:       op_enableinterrupt              Dec-05-88
***********************************************************************/
fix
op_enableinterrupt()
{
    eable_int = 1 ;

    return(0) ;
}   /* op_enableinterrupt */

/***********************************************************************
** TITLE:       op_disableinterrupt             Dec-05-88
***********************************************************************/
fix
op_disableinterrupt()
{
    eable_int = 0 ;

    return(0) ;
}   /* op_disableinterrupt */

/*
 *  This operator name is not matching its usage.
 *  used to select the input interface be serial or parallel.
 *  bool daytime -
 *  bool == TRUE, using Centronics interface ;
 *  bool == FALSE, get baud rate of serial interface.
 */
fix
op_daytime()
{
    if (COUNT() < 1)
       ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != BOOLEANTYPE)
       ERROR(TYPECHECK) ;
    else {
       POP(1) ;
    }

    return(0) ;
}   /* op_daytime() */

/***********************************************************************
** TITLE:       st_seteescratch            06-21-90
***********************************************************************/
fix
st_seteescratch()
{
    char  l_temp[64] ;

    if (current_save_level)
        ERROR(INVALIDACCESS) ;
    else if (COUNT() < 2)
        ERROR(STACKUNDERFLOW) ;
    else if ((TYPE_OP(0) != INTEGERTYPE) ||
            (TYPE_OP(1) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else if (((fix32)VALUE_OP(1) > 63) || ((fix32)VALUE_OP(1) < 0) ||
            ((fix32)VALUE_OP(0) > 255))
        ERROR(RANGECHECK) ;
    else {
        GEIpm_read(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        l_temp[(fix16)VALUE_OP(1)] = (char)VALUE_OP(0) ;   //@WIN
        GEIpm_write(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        POP(2) ;
    }

    return(0) ;
}   /* st_seteescratch */

/***********************************************************************
** TITLE:       st_eescratch            06-21-90
***********************************************************************/
fix
st_eescratch()
{
    fix16 l_index ;
    char  l_temp[64] ;

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if (((VALUE_OP(0)) > 63) || ((fix32)(VALUE_OP(0)) < 0))  //@WIN
        ERROR(RANGECHECK) ;
    else {
        l_index = (fix16)VALUE_OP(0) ;
        GEIpm_read(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0,
                   (ufix32)(0x000000ff)&l_temp[l_index]) ;
    }

    return(0) ;
}   /* st_eescratch */

/* statusdict stubs and will probably be removed */
fix
st_printererror()
{
    printer_error(0x10000000) ;

    return(0) ;
}   /* st_printererror */

fix
st_pagestackorder()
{
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;

    return(0) ;
}   /* st_pagestackorder */

fix
st_largelegal()
{
    /* this value is depend on system memory: Ref OPE */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    return(0) ;
}   /* st_largelegal */

/***********************************************************************
** TITLE:       op_checksum             01-11-91
***********************************************************************/
fix
st_checksum()
{
#ifdef  _AM29K
    ufix16  rom_checksum ;

    rom_checksum = GEIrom_checksum() ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, rom_checksum) ;
#else
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0) ;
#endif

    return(0) ;
}   /* op_checksum */

/***********************************************************************
** TITLE:       op_ramsize             01-11-91
***********************************************************************/
fix
st_ramsize()
{
#ifdef  _AM29K
    ufix32  ram_size ;

    ram_size = GEIram_size() ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, ram_size) ;
#else
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0) ;
#endif

    return(0) ;
}   /* op_checksum */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\dict.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DICT.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#define     DICT_NAME(contain)\
            (contain - (contain->k_obj.length))

#define     POP_KEY\
            {\
                free_new_name(GET_OPERAND(0)) ;\
                POP(1) ;\
            }

/* for the value field of composite object */
union   obj_value  {
    struct  object_def      huge *oo ;   /* for general object */
    struct  dict_head_def   far  *dd ;   /* for dictionary object */
    ubyte                   far  *ss ;   /* for string object */
} ;

#ifdef  LINT_ARGS
static bool near forall_dict(struct object_def FAR*, struct object_def FAR*),
            near where(struct object_def FAR* FAR*, struct object_def FAR*),
            near load_dict1(struct object_def FAR *,
                            struct object_def FAR * FAR*, bool FAR*), /*@WIN*/
            near check_key_type(struct object_def FAR *, struct object_def FAR *);
static void near
            change_namekey(struct object_def huge *, struct object_def FAR *) ;
#else
static bool near forall_dict(),
            near where(),
            near load_dict1(),
            near check_key_type() ;
static void near
            change_namekey() ;
#endif  /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\file.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        FILE.H
*  Author:      Ping-Jang Su
*  Date:        27-Jul-90
*
*  Update:
************************************************************************
*/
#define     FILE_MAXBUFFERSZ        24     /* 6K: block number of file spool */
#define     FILE_PERBUFFERSZ        256    /* cell size/per block */

/*
* standard file
*/
#define     F_MAXSTDSZ          3
#define     F_STDIN             0
#define     F_STDOUT            1
#define     F_STDERR            2

#define     SPECIALFILE_NO      (F_MAXSTDSZ+2)
#define     SPECIAL_STAT        3
#define     SPECIAL_LINE        4
/*
* file type
*/
#define     SEDIT_TYPE          3
#define     LEDIT_TYPE          4
#define     ORDFILE_TYPE        5
#define     FERR_TYPE           -1

#define     F_MAXNAMELEN        100

#define     F_READ              0x01
#define     F_WRITE             0x02
#define     F_RW                (F_READ | F_WRITE)

#define     READHEXSTRING       0
#define     READSTRING          1
#define     READLINE            2
#define     READ_BUF_LEN        128

#define     WRITEHEXSTRING      0
#define     WRITESTRING         1

#define     NEWLINE             '\n'
#define     TMOUT               "timeout"

#define     EVAL_ASCII(c)\
            {\
                if( c <= (ubyte)9 ) c += (ubyte)'0' ;\
                else c = c + (ubyte)'a' - (ubyte)10 ;\
            }                                   // @WIN

struct  file_buf_def {
    fix16   next ;              /* index of next file buffer */
    byte    data[FILE_PERBUFFERSZ] ;    /* data stream */
} ;

struct special_file_def {
    byte    FAR *name;              /* file name of special */
    fix16   ftype;              /* font type */
} ;

struct para_block {
    byte    FAR *fnameptr;          /* pointer of file name */
    fix     fnamelen;           /* length of file name */
    fix     ftype;              /* file type */
    fix     attr;               /* R/W attribute */
} ;

extern byte     g_mode[] ;
extern GEIFILE  FAR *g_editfile ;
extern struct para_block   fs_info ;
extern struct special_file_def  special_file_table[] ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\exec.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * 02/07/90 ccteng: modify for new 1pp modules; @1PP
 * 7/21/90; ccteng; 1)change opntype array for change of dict_tab.c
 *                  2)delete internaldict, version, revision
 * 7/25/90; ccteng; 1)add typecheck info for sccbatch, setsccbatch,
 *                    sccinteractive, setsccinteractive
 * 07/26/90 Jack Liaw: update for grayscale
 * 8/7/90; scchen;  1) added op_setfilecachelimit, op_filecachelimit
 *                  2) added st_selectsubstitutefont,
 *                                st_setsubstitutefonts,
 *                                st_substitutefonts
 *                  3) added op_readsfnt
 * 9/19/90; ccteng; add op_readhexsfnt
 * 3/22/91  Ada     add op_setpattern and op_patfill
 */
#include "global.ext"
#include <string.h>

/*
 * define error table to record each error name
 */
#ifdef  _AM29K
const
#endif
byte  FAR * far error_table[] =
{
        "",                     /* NOERROR                 0    */
        "dictfull",             /* DICTFULL                1    */
        "dictstackoverflow",    /* DICTSTACKOVERFLOW       2    */
        "dictstackunderflow",   /* DICTSTACKUNDERFLOW      3    */
        "execstackoverflow",    /* EXECSTACKOVERFLOW       4    */
        "handleerror",          /* HANDLEERROR             5    */
        "interrupt",            /* INTERRUPT               6    */
        "invalidaccess",        /* INVALIDACCESS           7    */
        "invalidexit",          /* INVALIDEXIT             8    */
        "invalidfileaccess",    /* INVALIDFILEACCESS       9    */
        "invalidfont",          /* INVALIDFONT             10   */
        "invalidrestore",       /* INVALIDRESTORE          11   */
        "ioerror",              /* IOERROR                 12   */
        "limitcheck",           /* LIMITCHECK              13   */
        "nocurrentpoint",       /* NOCURRENTPOINT          14   */
        "rangecheck",           /* RANGECHECK              15   */
        "stackoverflow",        /* STACKOVERFLOW           16   */
        "stackunderflow",       /* STACKUNDERFLOW          17   */
        "syntaxerror",          /* SYNTAXERROR             18   */
        "timeout",              /* TIMEOUT                 19   */
        "typecheck",            /* TYPECHECK               20   */
        "undefined",            /* UNDEFINED               21   */
        "undefinedfilename",    /* UNDEFINEDFILENAME       22   */
        "undefinedresult",      /* UNDEFINEDRESULT         23   */
        "unmatchedmark",        /* UNMATCHEDMARK           24   */
        "unregistered",         /* UNREGISTERED            25   */
        "VMerror"               /* VMERROR                 26   */
};

/* qqq, begin */
/*
 * Reference only
 *
 * #define  ANYTYPE             \144
 * #define  NUMTYPE             \145    ; INTEGER/REAL
 * #define  PROCTYPE            \146    ; ARRAY/PACKEDARRAY
 * #define  EXCLUDE_NULLTYPE    \147
 * #define  STREAMTYPE          \150    ; FILE/STRING
 * #define  COMPOSITE1          \151    ; ARRAY/PACKEDARRAY/STRING/DICT/FILE
 * #define  COMPOSITE2          \152    ; ARRAY/PACKEDARRAY/STRING/DICT
 * #define  COMPOSITE3          \153    ; ARRAY/PACKEDARRAY/STRING

 * #define  ARRAYTYPE           \001
 * #define  BOOLEANTYPE         \002
 * #define  DICTIONARYTYPE      \003
 * #define  FILETYPE            \004
 * #define  INTEGERTYPE         \006
 * #define  SAVETYPE            \014
 * #define  STRINGTYPE          \015
 * #define  PACKEDARRAYTYPE     \016
 */
/* qqq, end */

/*
 *  Encoding format:
 *  A type checking format is a sequence of chars surrounded by double quotes,
 *  as follows:
 *  "N(types) type1 type2 ... typeN M(types) type1 type2 ... typeM"
 *  each char is represented by the backslash \ and three octal digits
 */
#ifdef  _AM29K
const
#endif
static byte  * far opntype_array[] =
{
/* BEGIN @_operator */
/*  @exec                   */ "",
/*  @ifor                   */ "",
/*  @rfor                   */ "",
/*  @loop                   */ "",
/*  @repeat                 */ "",
/*  @stopped                */ "",
/*  @arrayforall            */ "",
/*  @dictforall             */ "",
/*  @stringforall           */ "",
/* END @_operator */

/* BEGIN systemdict */
/*  0  ==                   */ "\001\144",
/*  1  pstack               */ "",
/*  2  rcurveto             */ "\006\145\145\145\145\145\145",
/*  3  floor                */ "\001\145",
/*  4  load                 */ "\001\147",
/*  5  counttomark          */ "",
/*  6  setlinejoin          */ "\001\006",
/*  7  write                */ "\002\006\004",
/*  8  noaccess             */ "\001\151",
/*  9   scale               */ "\003\001\145\145\002\145\145",
/*  10  clippath            */ "",
/*  11  setrgbcolor         */ "\003\145\145\145",
/*  12  setscreen           */ "\003\146\145\145",
/*  13  exp                 */ "\002\145\145",
/*  14  anchorsearch        */ "\002\015\015",
/*  15  end                 */ "",
/*  16  xor                 */ "\002\002\002\002\006\006",
/*  17  bytesavailable      */ "\001\004",
/*  18  awidthshow          */ "\006\015\145\145\006\145\145",
/*  DON "true"              */ "",
/*  20  dup                 */ "\001\144",
/*  21  getinterval         */ "\003\006\006\153",
/*  22  currentdash         */ "",
/*  23  currentcacheparams  */ "",
/*  24  moveto              */ "\002\145\145",
/*  25  bind                */ /* "\001\146" PJ 5-9-1991 */ "",
/*  26  pop                 */ "\001\144",
/*  27  flattenpath         */ "",
/*  28  gsave               */ "",
/*  29  cachestatus         */ "",
/*  30  definefont          */ "\002\003\147",
/*  31  defaultmatrix       */ "\001\001",
/*  32  kshow               */ "\002\015\146",
/*  33  setcachedevice      */ "\006\145\145\145\145\145\145",
/*  34  countexecstack      */ "",
/*  35  abs                 */ "\001\145",
/*  36  strokepath          */ "",
/*  37  arcn                */ "\005\145\145\145\145\145",
/*  38  currenttransfer     */ "",
/*  39  and                 */ "\002\002\002\002\006\006",
/*  40  repeat              */ "\002\146\006",
/*  41  eexec               */ "\001\150",
/*  42  xcheck              */ "\001\144",
/*  43  idtransform         */ "\003\146\145\145\002\145\145",
/*  44  restore             */ "\001\014",
/*  45  daytime             */ "",
/*  DON "errordict"         */ "",
/*  47  [                   */ "",
/*  48  setpacking          */ "\001\002",
/*  49  stop                */ "",
/*  50  file                */ "\002\015\015",
/*  51  print               */ "\001\015",
/*  52  loop                */ "\001\146",
/*  53  string              */ "\001\006",
/*  54  cvx                 */ "\001\144",
/*  55  mul                 */ "\002\145\145",
/*  DON "null"              */ "",
/*  57  roll                */ "\002\006\006",
/*  58  known               */ "\002\147\003",
/*  59  idiv                */ "\002\145\145",
/*  60  eq                  */ "\002\144\144",
/*  61  sin                 */ "\001\145",
/*  62  ln                  */ "\001\145",
/*  63  transform           */ "\003\146\145\145\002\145\145",
/*  64  dtransform          */ "\003\146\145\145\002\145\145",
/*  65  currentmiterlimit   */ "",
/*  66  lineto              */ "\002\145\145",
/*  67  neg                 */ "\001\145",
/*  68  stopped             */ "\001\144",
/*  69  ]                   */ "",
/*  70  setlinewidth        */ "\001\145",
/*  71  rlineto             */ "\002\145\145",
/*  72  concat              */ "\001\146",
/*  73  dictstack           */ "\001\146",
/*  74  cos                 */ "\001\145",
/*  75  clip                */ "",
/*  76  ge                  */ "\002\145\145\002\015\015",
/*  77  eoclip              */ "",
/*  78  currentfont         */ "",
/*  79  sethsbcolor         */ "\003\145\145\145",
/*  DON "false"             */ "",
/*  81  currentlinewidth    */ "",
/*  82  index               */ "\001\006",
/*  83  settransfer         */ "\001\146",
/*  84  currentflat         */ "",
/*  85  currenthsbcolor     */ "",
/*  86  showpage            */ "",
/*  87  makefont            */ "\002\146\003",
/*  88  setcharwidth        */ "\002\145\145",
/*  89  setcachelimit       */ "\001\006",
/*  90  framedevice         */ "\004\146\006\006\146",
/*  91  stack               */ "",
/*  92  store               */ "\002\144\147",
/*  93  =                   */ "",
/*  94  ceiling             */ "\001\145",
/*  95  mark                */ "",
/*  96  setdash             */ "\002\145\146",
/*  97  setlinecap          */ "\001\006",
/*  98  grestoreall         */ "",
/*  99  currentrgbcolor     */ "",
/*  100  def                */ "\002\144\147",
/*  101  where              */ "\001\147",
/*  102  clear              */ "",
/*  103  cleartomark        */ "",
/*  104  truncate           */ "\001\145",
/*  105  dict               */ "\001\006",
/*  106  gt                 */ "\002\145\145\002\015\015",
/*  107  currentlinecap     */ "",
/*  108  setmiterlimit      */ "\001\145",
/*  109  currentlinejoin    */ "",
/*  110  maxlength          */ "\001\003",
/*  111  countdictstack     */ "",
/*  112  ne                 */ "\002\144\144",
/*  113  count              */ "",
/*  114  lt                 */ "\002\145\145\002\015\015",
/*  115  setfont            */ "\001\003",
/*  116  setgray            */ "\001\145",
/*  117  newpath            */ "",
/*  DON  "statusdict"       */ "",
/*  119  exch               */ "\002\144\144",
/*  120  le                 */ "\002\145\145\002\015\015",
/*  121  vmstatus           */ "",
/*  122  currentgray        */ "",
/*  123  setflat            */ "\001\145",
/*  124  or                 */ "\002\002\002\002\006\006",
/*  125  run                */ "\001\015",
/*  126  reversepath        */ "",
/*  127  widthshow          */ "\004\015\006\145\145",
/*  128  type               */ "\001\144",
/*  129  put                */ "\003\144\006\146\003\144\147\003\003\006\006\015",
/*  130  stroke             */ "",
/*  131  execstack          */ "\001\146",
/*  132  round              */ "\001\145",
/*  133  image              */ "\005\153\146\006\006\006",
/*  134  packedarray        */ "\001\006",
/*  135  translate          */ "\003\001\145\145\002\145\145",
/*  DON  "StandardEncoding" */ "",
/*  137  grestore           */ "",
/*  138  begin              */ "\001\003",
/*  139  readline           */ "\002\015\004",
/*  140  findfont           */ "\001\147",
/*  141  currentscreen      */ "",
/*  142  setcacheparams     */ "",
/*  143  initclip           */ "",
/*  144  token              */ "\001\150",
/*  145  itransform         */ "\003\146\145\145\002\145\145",
/*  146  currentdict        */ "",
/*  147  stringwidth        */ "\001\015",
/*  148  currentpoint       */ "",
/*  149  save               */ "",
/*  150  exec               */ "\001\144",
/*  151  cvrs               */ "\003\015\006\145",
/*  152  rcheck             */ "\001\151",
/*  153  sub                */ "\002\145\145",
/*  154  atan               */ "\002\145\145",
/*  155  read               */ "\001\004",
/*  156  cvs                */ "\002\015\144",
/*  157  for                */ "\004\146\145\145\145",
/*  158  search             */ "\002\015\015",
/*  159  cvlit              */ "\001\144",
/*  160  currentpacking     */ "",
/*  161  mod                */ "\002\006\006",
/*  162  log                */ "\001\145",
/*  163  exit               */ "",
/*  DON  "userdict"         */ "",
/*  165  div                */ "\002\145\145",
/*  166  length             */ "\001\152\001\010",  /* erik chen 5-20-1991 */
/*  167  echo               */ "\001\002",
/*  168  cvn                */ "\001\015",
/*  169  not                */ "\001\002\001\006",
/*  170  rotate             */ "\002\001\145\001\145",
/*  171  rmoveto            */ "\002\145\145",
/*  DON  "systemdict"       */ "",
/*  173  curveto            */ "\006\145\145\145\145\145\145",
/*  174  sqrt               */ "\001\145",
/*  175  usertime           */ "",
/*  176  ifelse             */ "\003\146\146\002",
/*  177  wcheck             */ "\001\151",
/*  178  resetfile          */ "\001\004",
/*  179  add                */ "\002\145\145",
/*  180  array              */ "\001\006",
/*  181  srand              */ "\001\006",
/*  182  arc                */ "\005\145\145\145\145\145",
/*  183  arcto              */ "\005\145\145\145\145\145",
/*  184  identmatrix        */ "\001\001",
/*  185  writestring        */ "\002\015\004",
/*  186  flushfile          */ "\001\004",
/*  187  if                 */ "\002\146\002",
/*  188  rrand              */ "",
/*  189  readonly           */ "\001\151",
/*  190  forall             */ "\002\146\152",
/*  191  closepath          */ "",
/*  192  readhexstring      */ "\002\015\004",
/*  193  currentmatrix      */ "\001\001",
/*  194  concatmatrix       */ "\003\001\146\146",
/*  195  setmatrix          */ "\001\146",
/*  196  initmatrix         */ "",
/*  197  initgraphics       */ "",
/*  198  astore             */ "\001\146",
/*  199  currentfile        */ "",
/*  200  erasepage          */ "",
/*  201  copypage           */ "",
/*  202  aload              */ "\001\146",
/*  203  writehexstring     */ "\002\015\004",
/*  204  flush              */ "",
/*  205  readstring         */ "\002\015\004",
/*  206  executeonly        */ "\001\153\001\004",
/*  207  get                */ "\002\006\153\002\147\003",
/*  208  cvi                */ "\001\145\001\015",
/*  209  putinterval        */ "\003\146\006\146\003\015\006\015",
/*  210  bitshift           */ "\002\006\006",
/*  211  rand               */ "",
/*  212  matrix             */ "",
/*  213  invertmatrix       */ "\002\001\146",
/*  214  fill               */ "",
/*  215  pathforall         */ "\004\144\144\144\144",
/*  216  imagemask          */ "\005\146\146\002\006\006\005\015\146\002\006\006",
/*  217  quit               */ "",
/*  218  charpath           */ "\002\002\015",
/*  219  pathbbox           */ "",
/*  220  show               */ "\001\015",
/*  221  ashow              */ "\003\015\145\145",
/*  222  scalefont          */ "\002\145\003",
/*  DON  "FontDirectory"    */ "",
/*  DON  "$error"           */ "",
/*  225  nulldevice         */ "",
/*  226  cvr                */ "\001\145\001\015",
/*  227  status             */ "\001\150",
/*  228  closefile          */ "\001\004",
/*  229  copy               */ "\001\006\002\146\146\002\003\003\002\015\015",
/*  230  eofill             */ "",
/*  231  handleerror        */ "",
/*  232  Run                */ "\001\015",
/*  234  =print             */ "\001\144",
#ifdef KANJI
/*  237  rootfont           */ "",
/*  238  cshow              *| "\002\015\146", 5-9-1991 */
/*  239  setcachedevice2    */ "\012\145\145\145\145\145\145\145\145\145\145",
/*  240  findencoding       */ "\001\147",
#endif  /* KANJI */
#ifdef SCSI
/*  241  deletefile         */ "",
/*  242  devdismount        */ "",
/*  243  devmount           */ "",
/*  244  devstatus          */ "",
/*  245  filenameforall     */ "",
/*  246  renamefile         */ "",
/*  247  sync               */ "",
/*  248  setsysmode         */ "",
/*  249  debugscsi          */ "",
/*  250  setfilecachelimit  */ "\001\006",
/*  251  filecachelimit     */ "",
#endif  /* SCSI */
/*  252  op_readsfnt        */ "\001\150",
/*  253  op_reahexdsfnt     */ "\001\004",
/* OSS: Danny, 10/11/90 */
/*  254 op_setsfntencoding  */ "\003\006\006\003",
/* OSS: ewd                 */
#ifdef WIN
/*  255  setpattern         */ "\001\015",
/*  256  patfill            */ "\007\006\145\145\145\145\145\145",
#ifdef WINF
/*  257    strblt           */ "\006\015\145\145\145\002\002",
/*  258    setjustify       */ "\003\006\145\006",
#endif
#endif
/*  DON  NULL               */ "",
/* END   systemdict */
/* BEGIN statusdict */
/*  FIRST_STAT,    eescratch             */ "",
/*  FIRST_STAT+1,  printername           */ "",
/*  FIRST_STAT+2,  checkpassword         */ "",
/*  FIRST_STAT+3,  defaulttimeouts       */ "",
/*  FIRST_STAT+4,  pagestackorder        */ "",
/*  DON,           "manualfeedtimeout"   */ "",
/*  FIRST_STAT+6,  setidlefonts          */ "",
/*  FIRST_STAT+7,  setdefaulttimeouts    */ "",
/*  FIRST_STAT+8,  sccbatch              */ "\001\006",
/*  FIRST_STAT+9,  printererror          */ "",
/*  FIRST_STAT+10, setpassword           */ "",
/*  FIRST_STAT+11, setsccbatch           */ "\003\006\006\006",
/*  FIRST_STAT+12, setmargins            */ "",
/*  FIRST_STAT+13, sccinteractive        */ "\001\006",
/*  FIRST_STAT+14, idlefonts             */ "",
/*  FIRST_STAT+15, setjobtimeout         */ "",
/*  FIRST_STAT+16, setpagetype           */ "",
/*  FIRST_STAT+17, pagecount             */ "",
/*  FIRST_STAT+18, dostartpage           */ "",
/*  FIRST_STAT+19, jobtimeout            */ "",
/*  FIRST_STAT+20, setdostartpage        */ "",
/*  FIRST_STAT+21, frametoprinter        */ "",
/*  DON,           "waittimeout"         */ "",
/*  FIRST_STAT+23, setsccinteractive     */ "\003\006\006\006",
/*  FIRST_STAT+24, pagetype              */ "",
/*  FIRST_STAT+25, margins               */ "",
/*  FIRST_STAT+26, setprintername        */ "",
/*  FIRST_STAT+27, seteescratch          */ "",
/*  FIRST_STAT+28, setstdio              */ "",
/*  FIRST_STAT+29, softwareiomode        */ "",
/*  FIRST_STAT+30, setsoftwareiomode     */ "",
/*  FIRST_STAT+31, hardwareiomode        */ "",
/*  FIRST_STAT+32, sethardwareiomode     */ "",
/*  FIRST_STAT+40, countnode             */ "",
/*  FIRST_STAT+41, countedge             */ "\002\006\006",
/*  FIRST_STAT+42, dumpclip              */ "",
/*  FIRST_STAT+43, dumppath              */ "",
#ifdef SCSI
/*  FIRST_STAT+44, cartstatus            */ "",
/*  FIRST_STAT+45, diskonline            */ "",
/*  FIRST_STAT+46, diskstatus            */ "",
/*  FIRST_STAT+47, initializedisk        */ "",
/*  FIRST_STAT+48, setuserdiskpercent    */ "",
/*  FIRST_STAT+49, userdiskpercent       */ "",
/*  FIRST_STAT+50, dosysstart            */ "",
/*  FIRST_STAT+51, setsysstart           */ "",
/*  FIRST_STAT+52, flushcache            */ "",
#endif  /* SCSI */
#ifdef SFNT
/*  DON            "?_Royal"             */ "",
#endif  /* SFNT */
#ifdef FIND_SUB
/*  FIRST_STAT+54, selectsubstitutefont */ "\001\010",
/*  FIRST_STAT+55, setsubstitutefonts   */ "\004\006\006\006\006",
/*  FIRST_STAT+56, substitutefonts      */ "",
#endif /* FIND_SUB */
/*  FIRST_STAT+57, checksum              */ "",
/*  FIRST_STAT+58, ramsize               */ "",
/*  DON            NULL                  */ "",
/* END   statusdict */
/* BEGIN userdict */
/*  DON,           "#copies"             */ "",
/*  FIRST_USER+1,  cleardictstack        */ "",
/*  FIRST_USER+2,  letter                */ "",
/*  FIRST_USER+3,  lettersmall           */ "",
/*  FIRST_USER+4,  a4                    */ "",
/*  FIRST_USER+5,  a4small               */ "",
/*  FIRST_USER+6,  b5                    */ "",
/*  FIRST_USER+7,  note                  */ "",
/*  FIRST_USER+8,  legal                 */ "",
/*  FIRST_USER+9,  prompt                */ "",
/*  FIRST_USER+10, quit                  */ "",
/*  FIRST_USER+11, executive             */ "",
/*  FIRST_USER+12, start                 */ "",
/*  DON,           "serverdict"          */ "",
/*  DON,           "execdict"            */ "",
/*  DON,           "printerdict"         */ "",
/*  DON,           "$idleTimeDict"       */ "",
/*  DON            NULL                  */ "",
/* END   userdict */
/* BEGIN errordict */
/*  FIRST_ERRO,    dictfull              */ "",
/*  FIRST_ERRO+1,  dictstackoverflow     */ "",
/*  FIRST_ERRO+2,  dictstackunderflow    */ "",
/*  FIRST_ERRO+3,  execstackoverflow     */ "",
/*  FIRST_ERRO+4,  invalidaccess         */ "",
/*  FIRST_ERRO+5,  invalidexit           */ "",
/*  FIRST_ERRO+6,  invalidfileaccess     */ "",
/*  FIRST_ERRO+7,  invalidfont           */ "",
/*  FIRST_ERRO+8,  invalidrestore        */ "",
/*  FIRST_ERRO+9,  ioerror               */ "",
/*  FIRST_ERRO+10, limitcheck            */ "",
/*  FIRST_ERRO+11, nocurrentpoint        */ "",
/*  FIRST_ERRO+12, rangecheck            */ "",
/*  FIRST_ERRO+13, stackoverflow         */ "",
/*  FIRST_ERRO+14, stackunderflow        */ "",
/*  FIRST_ERRO+15, syntaxerror           */ "",
/*  FIRST_ERRO+16, timeout               */ "",
/*  FIRST_ERRO+17, typecheck             */ "",
/*  FIRST_ERRO+18, undefined             */ "",
/*  FIRST_ERRO+19, undefinedfilename     */ "",
/*  FIRST_ERRO+20, undefinedresult       */ "",
/*  FIRST_ERRO+21, unmatchedmark         */ "",
/*  FIRST_ERRO+22, unregistered          */ "",
/*  FIRST_ERRO+23, VMerror               */ "",
/*  FIRST_ERRO+24, interrupt             */ "",
/*  FIRST_ERRO+25, handleerror           */ "",
/*  DON            NULL                  */ "",
/* END   errordict */
/* BEGIN serverdict */
/*  FIRST_SERV,    settimeouts           */ "",
/*  FIRST_SERV+1,  exitserver            */ "",
/*  DON            "stdin"               */ "",
/*  DON            "stdout"              */ "",
/*  FIRST_SERV+4,  setrealdevice         */ "",
/*  FIRST_SERV+5,  execjob               */ "",
/*  DON            NULL                  */ "",
/* END   serverdict */
/* BEGIN printerdict */
/*  DON            "letter"              */ "",
/*  DON            "lettersmall"         */ "",
/*  DON            "a4"                  */ "",
/*  DON            "a4small"             */ "",
/*  DON            "b5"                  */ "",
/*  DON            "note"                */ "",
/*  DON            "legal"               */ "",
/*  DON            "printerarray"        */ "",
/*  DON            "defaultmatrix"       */ "",
/*  DON            "matrix"              */ "",
/*  FIRST_PRIN+10, proc                  */ "",
/*  DON            "currentpagetype"     */ "",
/*  DON            "width"               */ "",
/*  DON            "height"              */ "",
/*  DON            NULL                  */ "",
/* END   printerdict */
/* BEGIN $idleTimeDict */
/*  DON            "cachestring"         */ "",
/*  DON            "stdfontname"         */ "",
/*  DON            "cachearray"          */ "",
/*  DON            "defaultarray"        */ "",
/*  DON            "carrayindex"         */ "",
/*  DON            "cstringindex"        */ "",
/*  DON            "cstring"             */ "",
/*  DON            "citem"               */ "",
/*  DON            NULL                  */ "",
/* END   $idleTimeDict */
/* BEGIN execdict */
/*  DON            "execdepth"           */ "",
/*  DON            "stmtfile"            */ "",
/*  DON            "idleproc"            */ "",
/*  DON            NULL                  */ "",
/* END   execdict */
/* BEGIN $errordict */
/*  DON            "newerror"            */ "",
/*  DON            "errorname"           */ "",
/*  DON            "command"             */ "",
/*  DON            "ostack"              */ "",
/*  DON            "estack"              */ "",
/*  DON            "dstack"              */ "",
/*  DON            "opnstkary"           */ "",
/*  DON            "dictstkary"          */ "",
/*  DON            "execstkary"          */ "",
/*  DON            "runbatch"            */ "",
/*  DON            "$debug"              */ "",
/*  DON            "$cur_font"           */ "",
/*  DON            "$cur_vm"             */ "",
/*  DON            "$cur_screen"         */ "",
/*  DON            "$cur_matrix"         */ "",
/*  DON            NULL                  */ ""
/* END   $errordict */
} ; /* opntype_array[] */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\exec.c ===
/*
* Copyright (c) 1989,90 Microsoft Corporation
*/
/*
************************************************************************
*      File name:              EXEC.C
*
*      revision history:
************************************************************************
*/
/*
*   Function:
*       interpreter
*       error_handler
*       get_dict_value
*       put_dict_value
*       waittimeout_task
*       init_interpreter
*       at_exec
*       at_ifor
*       at_rfor
*       at_loop
*       at_repeat
*       at_stopped
*       at_arrayforall
*       at_dictforall
*       at_stringforall
*       types_check
*
*/


// DJC added global include file
#include "psglobal.h"


#include    "exec.h"
#include    "user.h"
#include    "language.h"
#include    "geitmr.h"
#include    "geierr.h"
#include    <stdio.h>
#ifdef LINT_ARGS
/* qqq, begin */
/*
static  bool near  types_check(struct object_def FAR *, fix16 *);
*/
static  bool near  types_check(fix16 FAR *);
/* qqq, end */
#else
static  bool near  types_check() ;
#endif /* LINT_ARGS */

GEItmr_t      wait_tmr;
fix16         waittimeout_set=0;
int           waittimeout_task();
ufix8         l_wait=1;
extern byte   TI_state_flag;
/*
extern struct object_def  FAR *l_waittimeout ;
*/

/* @WIN; add prototype */
bool load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
static struct object_def    s_at_exec;          /* qqq */
static ubyte  FAR *s_tpstr;                         /* qqq */
#ifdef  DBG1
void type_obj();
#endif
extern fix16      timeout_flag; /* jonesw */
/*
************************************************************************
*
*   This submodue extract the topmost object of the execution stack, and
*   execute it.
*
*   Name:       interpreter
*   Input:
*       1. proc : input object to be executed
*
*   Data Items Accessed, Created, and/or Modified
*       1. execution stack - Modified
*       2. operand stack - Modified
*
************************************************************************
*/
fix
interpreter(proc)
struct object_def FAR *proc;
{
    struct object_def FAR *cur_obj, FAR *any_obj, FAR *ldval_obj;
    struct object_def token, val_obj;
    struct object_def temp_obj;
#ifdef _AM29K
    struct object_def  FAR *l_waittimeout ;
#endif

    fix  i, cur_type;
    fix  error, (*fun)(fix);          /* @WIN: add prototype */
    //DJC fix  error, (*fun)(void);    //DJC this should NOT pass a function
    fix16  opns;
    static fix  interpreter_depth = 0;


    if( interpreter_depth >= MAXINTERPRETSZ ) {
        ERROR(LIMITCHECK);
        return(1);       /* error */
    } else if( ! FR2EXESPACE() ) {
        ERROR(EXECSTACKOVERFLOW);
        return(1);       /* error */
    } else {
        if(P1_ATTRIBUTE(proc) != P1_EXECUTABLE) {
            if( FR1SPACE() ) {
                PUSH_ORIGLEVEL_OBJ(proc);
                return(0);
            } else {
                ERROR(STACKOVERFLOW);
                return(1);
            }
        }

        interpreter_depth++;
        PUSH_EXEC_OBJ(&s_at_exec);
        PUSH_EXEC_OBJ(proc);
    }

    /*
     * repeatly execute each object on the execution stack
     */
int_begin:
    cur_obj = GET_EXECTOP_OPERAND();
    cur_type = TYPE(cur_obj);
#ifdef  DBG2
    printf("\n<begin:%d, bf:%x, len:%x, vl:%lx> ", execstktop,
        cur_obj->bitfield, cur_obj->length, cur_obj->value);
#endif

int_array:
#ifdef  DBG
    printf("<array> ");
#endif
    /* ARRAY */
    if( cur_type == ARRAYTYPE ) {
        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }
        i = LENGTH(cur_obj);

        if (i) {
            any_obj = (struct object_def huge *)VALUE(cur_obj);

int_array1:
#ifdef  DBG
    printf("<array1> ");
#endif
            cur_type = TYPE(any_obj);
            if( (P1_ATTRIBUTE(any_obj) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(any_obj);
                    if( --i ) {
                        any_obj++;
                        goto int_array1;
                    } else {
                        POP_EXEC(1);
                        goto int_begin;
                    }
                } else {
                    ERROR(STACKOVERFLOW);
                    if( --i ) {
                        VALUE(cur_obj) = (ULONG_PTR)(any_obj+1);
                        LENGTH(cur_obj) = (ufix16)i;
                    } else {
                        POP_EXEC(1);
                    }
                    cur_obj = any_obj;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                if( --i ) {
                    VALUE(cur_obj) = (ULONG_PTR)(any_obj+1);
                    LENGTH(cur_obj) = (ufix16)i;
                } else {
                    POP_EXEC(1);
                    cur_obj--;
                }
                if( cur_type == OPERATORTYPE ) {
                    cur_obj = any_obj;
                    goto int_operator1;
                } else if( cur_type == NAMETYPE ) {
                    cur_obj = any_obj;
                    goto int_name1;
                }
                if( FR1EXESPACE() ) {
                    PUSH_EXEC_OBJ(any_obj);
                    cur_obj++;
                    goto int_stream;
                    /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    cur_obj = any_obj;
                    goto int_ckerror;
                }
            }
        } else
            POP_EXEC(1);
        goto int_begin;
    }   /* ARRAYTYPE */

#ifdef  DBG
    printf("<pkarray> ");
#endif
    /* PACKEDARRAY */
    if( cur_type == PACKEDARRAYTYPE ) {
        ubyte  FAR *tmp_ptr;

        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }

        i = LENGTH(cur_obj);

        if (i) {
            tmp_ptr = (ubyte FAR *)VALUE(cur_obj);
int_pkarray1:
#ifdef  DBG
    printf("<pkarray1> ");
#endif
            get_pk_object(get_pk_array(tmp_ptr, 0), &val_obj, LEVEL(cur_obj));
            cur_type = TYPE(&val_obj);

            if( (P1_ATTRIBUTE(&val_obj) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(&val_obj);
                    if( --i ) {
                        tmp_ptr = get_pk_array(tmp_ptr, 1);
                        /* qqq
                        LENGTH(cur_obj) = i;        |* ?? *|
                        */
                        goto int_pkarray1;
                    } else {
                        POP_EXEC(1);
                        goto int_begin;
                    }
                } else {
                    ERROR(STACKOVERFLOW);
                    if( --i ) {
                        VALUE(cur_obj) = (ULONG_PTR)get_pk_array(tmp_ptr, 1);
                        LENGTH(cur_obj) = (ufix16)i;
                    } else {
                        POP_EXEC(1);
                    }
                    cur_obj = &val_obj;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                if( --i ) {
                    VALUE(cur_obj) = (ULONG_PTR)get_pk_array(tmp_ptr, 1);
                    LENGTH(cur_obj) = (ufix16)i;
                } else {
                    POP_EXEC(1);
                    cur_obj--;
                }
                if( FR1EXESPACE() ) {
                    cur_type = TYPE(&val_obj);
                    if( cur_type == OPERATORTYPE ) {
                        cur_obj = &val_obj;
                        goto int_operator1;
                    } else if( cur_type == NAMETYPE ) {
                        cur_obj = &val_obj;
                        goto int_name1;
                    } else {
                        PUSH_EXEC_OBJ(&val_obj);
                        cur_obj++;
                        goto int_stream;
                        /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                    }
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    cur_obj = &val_obj;
                    goto int_ckerror;
                }
            }
        } else
            POP_EXEC(1);
        goto int_begin;
    }   /* PACKEDARRAY */

int_stream:
#ifdef  DBG
    printf("<stream> ");
#endif

/* qqq
    |* FILE *|
    if( cur_type == FILETYPE ) {
#ifdef  DBG2
    printf("<file> ");
#endif
        if( VALUE(cur_obj) != g_stream.currentID )
            stream_changed = TRUE;
        goto int_stream1;

    }

    |* STRING *|
    if( cur_type == STRINGTYPE ) {
        if( g_stream.currentID != MAX15 )
            stream_changed = TRUE;
*/
    if( (cur_type == FILETYPE) ||
        (cur_type == STRINGTYPE) ) {

//int_stream1:         @WIN
#ifdef  DBG2
    printf("<stream1> ");
#endif

#ifdef _AM29K
                 get_dict_value(STATUSDICT,"waittimeout",&l_waittimeout);
                  if (VALUE(l_waittimeout)>0)
                  {
                    wait_tmr.handler=waittimeout_task;
                    wait_tmr.interval=VALUE(l_waittimeout)*1000;
                    waittimeout_set=1;
                    /* ***** */
                    GEItmr_start(&wait_tmr);
                 /* */
                  }
#endif  /* _AM29K */

        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }

int_stream3:
#ifdef  DBG3
    printf("\n<stream3:%lx> ", g_stream.pointer);
#endif
        TI_state_flag = 0;
        if( get_token(&token, cur_obj) ) {
            TI_state_flag = 1;
#ifdef DBG1
            type_obj(&token);
            /*
            printf("tkntype:%d, attri:%d\n", TYPE(&token),
                    ATTRIBUTE(&token));
            */
            /*
            printf("|\n");
            */
#endif
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            if( check_interrupt() ) {       /* check ^C occurred? */
                POP_EXEC(1) ;               /* ?? */
                ERROR(INTERRUPT);
                goto int_ckerror;           /* ?? */
            }

            cur_type = TYPE(&token);
            if (( cur_type == EOFTYPE ) || (timeout_flag==1)){   /* jonesw */
#ifdef  DBG2
        printf("<EOF> ");
#endif
                if( TYPE(cur_obj) == FILETYPE ) {

                    close_file(cur_obj);
                }
/*
                else {
                    update_stream();
                    g_stream.currentID = -2;
                }
*/
                POP_EXEC(1);
                goto int_ckerror;
            }
            if( (P1_ATTRIBUTE(&token) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(&token);
                    goto int_stream3;
                } else {
                    ERROR(STACKOVERFLOW);
                    cur_obj = &token;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                cur_obj = &token;
                if( cur_type == OPERATORTYPE ) {
                    goto int_operator1;
                } else if( cur_type == NAMETYPE ) {
                    goto int_name1;
                }
                if( FR1EXESPACE() ) {
                    PUSH_EXEC_OBJ(&token);
                    goto int_stream;
                    /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    goto int_ckerror;
                }
            }
        }   /* if */
        goto int_ckinterrupt;
    }   /* FILE/STRING */

    /* OPERATOR */
    if( cur_type == OPERATORTYPE ) {
        POP_EXEC(1);

int_operator1:
    TI_state_flag = 1;

#ifdef  DBG2
    printf("<op1:%d, name:%s> ", opnstktop,
        systemdict_table[LENGTH(cur_obj)].key);
#endif
        if( *(s_tpstr=(ubyte FAR *)opntype_array[LENGTH(cur_obj)]) )
            if( ! types_check(&opns) )
                goto int_ckerror;
#ifdef  DBG
    printf("<op2> ");
#endif
        COPY_OBJ(cur_obj, &temp_obj);
        fun = (fix (*)(fix))VALUE(cur_obj);
        error = (*fun)(opns);  /* dispatch to each action routine */
        //DJC error = (*fun)();  //DJC should NOT pass arg
        cur_obj = &temp_obj;
        /*
         * only op_stop, op_exit will return error code,
         * and put error code (1) to caller while stop happened
         */

        if( ! error )               /* 0 -- normal action routine */
            goto int_ckinterrupt;
        else if( error == -1 ) {    /* op_stop, op_exit-1 for @exec */
            interpreter_depth--;
            return(1);              /* error */
        } else if( error == -2 ) {  /* @exec -- normal exit */
            interpreter_depth--;
#ifdef  DBG2
    printf("\n");
#endif
            return(0);              /* ok */
        } else if( error == -3 ) {  /* op_quit */
            interpreter_depth--;
            return(2);              /* ok */
        } else if( error == -4 ) {  /* op_exit-2 for @exec */
            cur_obj = GET_EXECTOP_OPERAND();
            goto int_ckerror;
        }
    }   /* OPERATORTYPE */


#ifdef  DBG2
    printf("<name> ");
#endif
    /* NAME */
    if( cur_type == NAMETYPE ) {
        POP_EXEC(1);
int_name1:
#ifdef  DBG2
    printf("<name1> ");
#endif
        if( load_name_obj(cur_obj, &ldval_obj) ) {
            if( P1_ATTRIBUTE(ldval_obj) != P1_EXECUTABLE ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(ldval_obj);
                } else {
                    ERROR(STACKOVERFLOW);
                    cur_obj = ldval_obj;
                }
            } else {                    /* other object */
                cur_type = TYPE(ldval_obj);
                if( cur_type == OPERATORTYPE ) {
                    cur_obj = ldval_obj;
                    goto int_operator1;
                } else {
                    //DJC fix for UPD043
                    if (!FR1EXESPACE()) {
                       ERROR(EXECSTACKOVERFLOW);
                       goto int_ckerror;
                    }
                    //DJC end for fix UPD043

                    cur_obj = execstkptr;
                    PUSH_EXEC_OBJ(ldval_obj);
                    goto int_array;
                }
            }
        } else {
            /* ?? object still in execution stack */
            if( FR1SPACE() ) {
                PUSH_OBJ(cur_obj);
                ERROR(UNDEFINED);
            } else {
                ERROR(STACKOVERFLOW);
            }
        }
        goto int_ckerror;
    }   /* NAMETYPE */

    /* NULL */
    if( cur_type == NULLTYPE ) {
#ifdef  DBG2
    printf("<null> ");
#endif
        POP_EXEC(1);
        goto int_ckerror;
    }   /* NULL */

    /*
     * data equivalence objects even it has executable attribute
     * ?? impossible type
     */
#ifdef  DBG2
    printf("<others> ");
#endif
    POP_EXEC(1);
    if( FR1SPACE() ) {
        PUSH_ORIGLEVEL_OBJ(cur_obj);
        goto int_begin;
    } else {
        ERROR(STACKOVERFLOW);
        goto int_ckerror;
    }

int_ckinterrupt:
#ifdef  DBG
    printf("<ckinterrupt> ");
#endif
    if( check_interrupt() )         /* check ^C occurred? */
        ERROR(INTERRUPT);

int_ckerror:
#ifdef  DBG
    printf("<ckerror> ");
#endif
    if( global_error_code )
        error_handler(cur_obj);
    goto int_begin;

}   /* interpreter */
/*
************************************************************************
*   Name:       error_handler
************************************************************************
*/
void
error_handler(cur_obj)
struct object_def FAR *cur_obj ;
{
    struct object_def FAR *any_obj ;
    struct object_def ary_obj ;

    // DJC added
    if (global_error_code) {
      PsReportError(global_error_code);
    }
    // DJC end


    /*
     * doing for the overflow checking of opnstack, dictstack, execstack.
     */
    /**** jonesw begin ****/
    if (timeout_flag == 1)
    {
      ERROR(TIMEOUT);
      if (get_dict_value("errordict", error_table[global_error_code], &any_obj))
          PUSH_ORIGLEVEL_OBJ(any_obj) ;        /* do error handler */
    }
    /**** jonesw end   ****/
    if( ! FR1EXESPACE() )            /* qqq */
       ERROR(EXECSTACKOVERFLOW) ;

    switch (global_error_code) {

    case DICTSTACKOVERFLOW:
            //UPD045

            if(create_array(&ary_obj, dictstktop)) {
               astore_stack(&ary_obj, DICTMODE) ;
               PUSH_OBJ(&ary_obj) ;         /* op_begin reserves one location */
            }
            dictstktop = 2 ;
            dictstkptr = &dictstack[dictstktop] ;   /* qqq */
            change_dict_stack() ;
            goto label_1 ;

        case EXECSTACKOVERFLOW:
            if( ! FR1SPACE() ) {         /* qqq */
                //UPD045
                if(create_array(&ary_obj, opnstktop)){
                  astore_array(&ary_obj) ;
                  PUSH_OBJ(&ary_obj) ;
                }
            }
            //DJC fix for UPD045
            if(create_array(&ary_obj, execstktop) ){
               astore_stack(&ary_obj, EXECMODE) ;
               PUSH_OBJ(&ary_obj) ;
            }
            POP_EXEC(1);

label_1:
            if( ! FR1SPACE() )           /* qqq */
                ERROR(STACKOVERFLOW) ;

        case STACKOVERFLOW:
            if (global_error_code == STACKOVERFLOW) {
                create_array(&ary_obj, opnstktop) ;
                astore_array(&ary_obj) ;
                PUSH_OBJ(&ary_obj) ;
            }
            break ;

    }   /* switch */

    if ((global_error_code != UNDEFINED) &&
        (global_error_code != TIMEOUT) &&
        (global_error_code != INTERRUPT))
        PUSH_ORIGLEVEL_OBJ(cur_obj) ;  /* push that object into the operand stack */

    if (get_dict_value("errordict", error_table[global_error_code], &any_obj))
        PUSH_EXEC_OBJ(any_obj) ;        /* do error handler */

    timeout_flag=0;    /* jonesw */
    global_error_code = 0 ;           /* reset error code */
}   /* error_handler */
/*
************************************************************************
*   get value object associated with the specific key in specific dict,
*   the key and dict are represented in string format it get the
*   value_obj in current active dict using the dictname as key, the
*   value_obj is a dict object, then get the value in this dict using the
*   keyname as key.
*
*   Name:       get_dict_value
************************************************************************
*/
bool
get_dict_value(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR * FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj ;

    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, dictname, lstrlen(dictname), TRUE) ;     /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get the specific dict_obj */
    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, keyname, lstrlen(keyname), TRUE) ;       /* @WIN */

    return(get_dict(dict_obj, &key_obj, value)) ;
}   /* get_dict_value */
/*
************************************************************************
*   put value object associated with the specific key in specific dict,
*   the key and dict are represented in string format
*   it get the value_obj in current active dict using the dictname as key,
*   the value_obj is a dict object, then put the value into this dict using
*   the keyname as key.
*
*   Name:       put_dict_value
************************************************************************
*/
bool
put_dict_value(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj=NULL ;

    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, dictname, lstrlen(dictname), TRUE) ;     /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get execdict obj */
    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, keyname, lstrlen(keyname), TRUE) ;       /* @WIN */

    return(put_dict(dict_obj, &key_obj, value)) ;
}   /* put_dict_value */

#ifdef _AM29K
/*
************************************************************************
*   waittimeout handler routine
*
*   Name:       waittimeout_task
************************************************************************
*/
int waittimeout_task()
{
    ERROR(TIMEOUT);
    GESseterror(ETIME);
    GEItmr_stop(wait_tmr.timer_id);
    waittimeout_set=0;
    timeout_flag =1; /* jonesw */
    return(1);
}
#endif
/*
************************************************************************
*   Name:       init_interpreter
************************************************************************
*/
void
init_interpreter()
{
    execstktop = 0 ;
    execstkptr = execstack;                     /* qqq */
    global_error_code = 0 ;

    /* qqq */
    TYPE_SET(&s_at_exec, OPERATORTYPE);
    P1_ACC_UNLIMITED_SET(&s_at_exec);
    P1_ATTRIBUTE_SET(&s_at_exec, P1_EXECUTABLE);
    P1_ROM_RAM_SET(&s_at_exec, P1_ROM);
    LENGTH(&s_at_exec) = AT_EXEC;
    VALUE(&s_at_exec) = (ULONG_PTR)(systemdict_table[AT_EXEC].value);
}   /* init_interpreter */
/*
************************************************************************
*   following functions are used to implement @_operator.
*   there are:
*       1. at_exec() - to implement @exec
*       2  at_ifor() - to implement @ifor
*       3. at_rfor() - to implement @rfor
*       4. at_loop() - to implement @loop
*       5. at_repeat() - to implement @repeat
*       6. at_stopped() - to implement @stopped
*       7. at_arrayforall() - to implement @arrayforall
*       8. at_dictforall() - to implement @dictorall
*       9. at_stringforall() - to implement @stringforall
************************************************************************
*/
/*
************************************************************************
*   Name:       at_exec
*
*   Modified by J. Lin at 11-26-87, also ref to control.c
************************************************************************
*/
fix
at_exec()
{
    if( P1_ACCESS(execstkptr) == P1_UNLIMITED)          /* qqq */
       return(-2) ;     /* normal exit */
    else                /* NOACCESS */
       return(-1) ;     /* @exec for op_exit-1 -- in invalidexit case */
}   /* at_exec */
/*
************************************************************************
*   Name:       at_ifor
************************************************************************
*/
fix
at_ifor()
{
    struct object_def FAR *temp_obj ;
    ULONG_PTR   count;
    ULONG_PTR   increment, limit ;

    temp_obj = GET_EXECTOP_OPERAND();
    count = VALUE(temp_obj) ;             /* get next count */
    increment = VALUE(temp_obj - 1) ;     /* get increment */
    limit = VALUE(temp_obj - 2) ;         /* get limit */

    if ((increment > 0 && count <= limit) ||
                         (increment <= 0 && count >= limit)) {
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW) ;
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW) ;
        else {
            /* push this control variable (count) on the operand stack,
            * increase this control variable, execute the proc
            */
            PUSH_ORIGLEVEL_OBJ(temp_obj);
            count += increment;
            VALUE(temp_obj) = count;
            INC_EXEC_IDX();

            PUSH_EXEC_OBJ(temp_obj - 3);
            return(0);
        }
    }
    POP_EXEC(4);
    return(0);
}   /* at_ifor */
/*
************************************************************************
*   Name:       at_rfor
************************************************************************
*/
fix
at_rfor()
{
    struct object_def FAR *temp_obj;
    union four_byte  count, increment, limit;

    temp_obj = GET_EXECTOP_OPERAND();
    count.ll = (fix32)VALUE(temp_obj);           /* get next count */
    increment.ll = (fix32)VALUE(temp_obj - 1);   /* get increment */
    limit.ll = (fix32)VALUE(temp_obj - 2);       /* get limit */
    if ((increment.ff > (real32)0.0 && count.ff <= limit.ff) ||
                   (increment.ff <= (real32)0.0 && count.ff >= limit.ff)) {
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            * push this control variable (count) on the operand stack,
            * increase this control variable, execute the proc
            */
            PUSH_ORIGLEVEL_OBJ(temp_obj);
            count.ff += increment.ff;
            VALUE(temp_obj) = count.ll;
            INC_EXEC_IDX();
            PUSH_EXEC_OBJ(temp_obj - 3);
            return(0);
        }
    }
    POP_EXEC(4);
    return(0);
}   /* at_rfor */
/*
************************************************************************
*   Name:       at_loop
************************************************************************
*/
fix
at_loop()
{
    struct object_def FAR *temp_obj ;

    temp_obj = GET_EXECTOP_OPERAND();
    if( ! FR2EXESPACE() ) {
        ERROR(EXECSTACKOVERFLOW) ;
        POP_EXEC(1) ;
    } else {
        INC_EXEC_IDX();
        PUSH_EXEC_OBJ(temp_obj) ;
    }
    return(0) ;
}   /* at_loop */
/*
************************************************************************
*   Name:       at_repeat
************************************************************************
*/
fix
at_repeat()
{
    struct object_def FAR *temp_obj ;
    ULONG_PTR  count ;

    temp_obj = GET_EXECTOP_OPERAND();
    count = VALUE(temp_obj);
    if (count) {
        count--;
        VALUE(temp_obj) = count;
        if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            INC_EXEC_IDX();
            PUSH_EXEC_OBJ(temp_obj - 1);
            return(0);
        }
    }
    POP_EXEC(2);
    return(0);
}   /* at_repeat */
/*
************************************************************************
*   the access field of @stopped object is used to record the result
*   of executing stopped context, if it runs to completion normally,
*   the access field is coded to UNLIMITED, and the stopped operator return
*   "false" on the operand stack, otherwise, the access field is coded to
*   NOACCESS, and the stopped operator return "true" on the operand stack.
*
*   Name:       at_stopped
************************************************************************
*/
fix
at_stopped()
{
    ufix  stopped ;

    if( ! FR2SPACE() ) {
        ERROR(STACKOVERFLOW);
        INC_EXEC_IDX();
    } else {
        if( P1_ACCESS(execstkptr) != P1_NOACCESS )
            stopped = FALSE;    /* false */
        else
            stopped = TRUE;     /* true */
        /* return bool onto operand stack */
        PUSH_SIMPLE_VALUE(BOOLEANTYPE, stopped);
    }
    return(0);
}   /* at_stopped */
/*
************************************************************************
*   Name:       at_arrayforall
************************************************************************
*/
fix
at_arrayforall()
{
    struct object_def FAR *cur_obj, val_obj;
    struct object_def huge *tmp_ptr1;
    ubyte  FAR *tmp_ptr2;
    ufix   i;

    cur_obj = GET_EXECTOP_OPERAND();        /* qqq */
    if (i = LENGTH(cur_obj)) {

        if (TYPE(cur_obj) == ARRAYTYPE) {
            tmp_ptr1 = (struct object_def huge *)VALUE(cur_obj);
            COPY_OBJ((struct object_def FAR *)tmp_ptr1, &val_obj);
        } else {
            tmp_ptr2 = (ubyte FAR *)VALUE(cur_obj);
            get_pk_object(get_pk_array(tmp_ptr2, 0), &val_obj, LEVEL(cur_obj));
        }

        if (--i) {
            if (TYPE(cur_obj) == ARRAYTYPE) {
                VALUE(cur_obj) = (ULONG_PTR)(++tmp_ptr1);
            } else {
                tmp_ptr2 = get_pk_array(tmp_ptr2, 1);
                VALUE(cur_obj) = (ULONG_PTR)tmp_ptr2;
            }
            LENGTH(cur_obj) = (ufix16)i;
        } else
            LENGTH(cur_obj) = 0;
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push array element on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(cur_obj - 1);
            return(0);
        }
    }   /* if */
    POP_EXEC(2);
    return(0);
}   /* at_arrayforall */
/*
************************************************************************
*   Name:       at_dictforall
************************************************************************
*/
fix
at_dictforall()
{
    struct object_def FAR *idx_obj, FAR *dict_obj, key_obj ;
    struct object_def FAR *val_obj ;
    ufix   i ;

    idx_obj = GET_EXECTOP_OPERAND();        /* qqq */
    dict_obj = idx_obj - 2;                 /* qqq */
    i = (fix)VALUE(idx_obj);

    if (extract_dict(dict_obj, i, &key_obj, &val_obj)) {
        VALUE(idx_obj)++;
        if( ! FR2SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push key_value pair on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&key_obj);
            PUSH_ORIGLEVEL_OBJ(val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(idx_obj - 1);
            return(0);
        }
    }   /* if */
    POP_EXEC(3);
    return(0);
}   /* at_dictforall */
/*
************************************************************************
*   Name:       at_stringforall
************************************************************************
*/
fix
at_stringforall()
{
    struct object_def FAR *cur_obj, val_obj;
    ufix   i;

    cur_obj = GET_EXECTOP_OPERAND();        /* qqq */
    if (i = LENGTH(cur_obj)) {
        get_string(cur_obj, 0, &val_obj);
        if (--i) {
            byte huge *tmp_ptr;

            tmp_ptr = (byte huge *)VALUE(cur_obj);
            VALUE(cur_obj) = (ULONG_PTR)(++tmp_ptr);
            LENGTH(cur_obj) = (ufix16)i;
        } else
            LENGTH(cur_obj) = 0;
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push string element on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(cur_obj - 1);
            return(0);
        }
    }
    POP_EXEC(2);
    return(0);
}   /* at_stringforall */
/*
************************************************************************
*   perform type checking for operands -
*   set TYPECHECK error code, if some operand's type is different from what
*   an operator expects, otherwise return the actual no# of operands.
*
*   Name:       types_check
************************************************************************
*/
static bool near
types_check(opns)
fix16  FAR *opns;
{
    ufix  no, np, nc, found, op_type, obj_type;
    ufix  error;

#ifdef  DBG
    printf("types_check<%d>\n", (fix)*s_tpstr);
#endif
    error = 0;
    while( *s_tpstr ) {
tc_next:
        found = 0; nc = COUNT();
        no = np = *s_tpstr++;
        while( no ) {
            if( ! nc ) {        /* operands in OPNSTK < required operands */
                if (error < 2) {    /* no error, or TYPECHECK error */
                    if (found == COUNT())
                        error = 2;      /* STACKUNDERFLOW error */
                    else
                        error = 1;      /* TYPECHECK error */
                }
                if( ! *(s_tpstr += no) ) {      /* in last check path */
                    if (error == 2)
                        ERROR(STACKUNDERFLOW);
                    else
                        ERROR(TYPECHECK);
                    return(FALSE);
                } else
                   break;
            } else {
                op_type = *s_tpstr++;
                obj_type = TYPE(GET_OPERAND(np - no));

                switch (op_type) {

                case '\144' :               /* ANYTYPE */
                    found++;
                    break;

                case '\145' :               /* NUMTYPE */
                    if( (obj_type == INTEGERTYPE) || (obj_type == REALTYPE) )
                        found++;
                    break;

                case '\146' :               /* PROCTYPE */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) )
                        found++;
                    break;

                case '\147' :               /* EXCLUDE_NULLTYPE */
                    if (obj_type != NULLTYPE)
                        found++;
                    break;

                case '\150' :               /* STREAMTYPE */
                    if( (obj_type == FILETYPE) || (obj_type == STRINGTYPE) )
                        found++;
                    break;

                case '\151' :               /* COMPOSITE1 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) || (obj_type == DICTIONARYTYPE) ||
                        (obj_type == FILETYPE) )
                        found++;
                    break;

                case '\152' :               /* COMPOSITE2 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) ||
                        (obj_type == DICTIONARYTYPE) )
                        found++;
                    break;

                case '\153' :               /* COMPOSITE3 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) )
                        found++;
                    break;

                default :                   /* other types */
                    if (obj_type == op_type)
                        found++;
                    else {
                        if (no <= 1) break;
                        error = 1;
                        s_tpstr += (no - 1);
                        goto tc_next;
                    }

                }   /* switch */
                no--; nc--;
            }   /* else */
        }   /* while */
        if( np == 0 )   break;
        if (found == np) {
            *opns = (fix16)np;                     /* pass type checking */
            return(TRUE);
        }
    }   /* while */
    ERROR(TYPECHECK);   /* operands in OPNSTK >= required operands */
    return(FALSE);
}   /* types_check */

#ifndef  DBG1
void
type_obj(p_obj)
struct object_def       FAR *p_obj;
{
    byte        FAR *l_str, l_str2[200], FAR *l_str3;
    fix         l_len;

    printf("<field: %x> ", p_obj->bitfield );
    switch(ACCESS(p_obj)) {
    case UNLIMITED:
        l_str = "unlimited";
        break;
    case READONLY:
        l_str = "readonly";
        break;
    case EXECUTEONLY:
        l_str = "executeonly";
        break;
    case NOACCESS:
        l_str = "noaccess";
        break;
    default:
        l_str = "ACCESS error";
    }
    printf("%s ", l_str);

    printf("lvl_%d ", LEVEL(p_obj));

    switch(ROM_RAM(p_obj)) {
    case ROM:
        l_str = "rom";
        break;
    case RAM:
        l_str = "ram";
        break;
    case KEY_OBJECT:
        l_str = "key_object";
        break;
    default:
        l_str = "ROM/RAM error";
    }
    printf("%s ", l_str);

    switch(ATTRIBUTE(p_obj)) {
    case LITERAL:
        l_str = "literal";
        break;
    case EXECUTABLE:
        l_str = "executable";
        break;
    case IMMEDIATE:
        l_str = "immediate";
        break;
    default:
        l_str = "ATTRIBUTE error";
    }
    printf("%s ", l_str);

    l_len = 0;
    switch(TYPE(p_obj)) {
    case EOFTYPE:
        l_str = "EOF";
        break;
    case ARRAYTYPE:
        l_str = "ARRAY";
        break;
    case BOOLEANTYPE:
        l_str = "BOOLEAN";
        break;
    case DICTIONARYTYPE:
        l_str = "DICT";
        break;
    case FILETYPE:
        l_str = "FILE";
        break;
    case FONTIDTYPE:
        l_str = "FONTID";
        break;
    case INTEGERTYPE:
        l_str = "INTEGER";
        break;
    case MARKTYPE:
        l_str = "MARK";
        break;
    case NAMETYPE:
        l_str = "NAME";
        l_str3 = name_table[(fix)VALUE(p_obj)]->text;
        l_len = name_table[(fix)VALUE(p_obj)]->name_len;
        lstrncpy(l_str2, l_str3, l_len);        /*@WIN*/
        l_str3 = l_str2;
        break;
    case NULLTYPE:
        l_str = "NULL";
        break;
    case OPERATORTYPE:
        l_str = "OPERATOR";
        l_str3 = systemdict_table[(fix)VALUE(p_obj)].key ;
        l_len = lstrlen(l_str3);        /* @WIN */
        break;
    case REALTYPE:
        l_str = "REAL";
        break;
    case SAVETYPE:
        l_str = "SAVE";
        break;
    case STRINGTYPE:
        l_str = "STRING";
        break;
    case PACKEDARRAYTYPE:
        l_str = "PACKEDARRAY";
        break;
    default:
        l_str = "TYPE error";
    }
    if(l_len) {
        printf("%s:", l_str);
        printf("%s", l_str3);
    } else
        printf("%s", l_str);

    printf(" len:%x, val:%lx\n", LENGTH(p_obj), VALUE(p_obj));
}   /* type_obj */
#endif  /* DBG1 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\file.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        FILE.C
*  By:          Ping-Jang Su
*  Date:        Jan-05-88
*  Owner:
*
*  History:
*   Jan-30-89 PJ: . op_token: skip one whitespace
*   06-23-90 ; Added unix support for op_run().
************************************************************************
*/
/*
*   Function:
*       op_file
*       op_closefile
*       op_read
*       op_write
*       op_readhexstring
*       op_writehexstring
*       op_readstring
*       op_writestring
*       op_readline
*       op_token
*       op_bytesavailable
*       op_flush
*       op_flushfile
*       op_resetfile
*       op_status
*       op_run
*       op_currentfile
*       op_print
*       op_echo
*       op_eexec
*       st_setstdio
*
*       init_file
*       open_file
*       open_edit
*       close_file
*       close_fd
*       read_file
*       read_fd
*       unread_file
*       write_fd
*       get_flbuffer
*       free_flbuffer
*       print_string
*       check_fname
*       wait_editin
*       read_routine
*       write_routine
*       vm_close_file
*
*       op_deletefile               ; not complete yet
*       op_renamefile               ; not complete yet
*       op_filenameforall           ; comment
*
*       port_out_string
*/


// DJC added global include file
#include "psglobal.h"


#include        <string.h>

#include        "stdio.h"
#include        "global.ext"
#include        "geiio.h"               /* @GEI */
#include        "geiioctl.h"            /* @GEI */
#include        "geierr.h"              /* @GEI */
#include        "gescfg.h"              /* @GEI */
#include        "geitmr.h"              /* @GEI */
#include        "language.h"
#include        "file.h"
#include        "user.h"

#ifdef  SCSI
#include        "scsi.h"
#include        "scsi.ext"
#endif  /* SCSI */

static  struct file_buf_def far * near   file_buffer ;
static  fix16   fspool_head ;    /* file-buffer-spool header */
static  bool8   echo_setting ;

byte    g_mode[4] ;
GEIFILE FAR *g_editfile ;
struct para_block   fs_info ;    /* parameter block used in open_file */

ufix16 eseed, old_eseed ;
//DJC fix bypass ;
fix32 bypass ; // DJC fix from SC
xbool itype ;
ybool estate = NON_EEXEC ;

struct special_file_def special_file_table[SPECIALFILE_NO] = {
    { "%stdin",          F_STDIN},
    { "%stdout",         F_STDOUT},
    { "%stderr",         F_STDERR},
    { "%statementedit",  SEDIT_TYPE},
    { "%lineedit",       LEDIT_TYPE},
} ;

static  bool    CRLF_flag = 0 ;

#ifdef  LINT_ARGS
static bool near    open_edit(struct object_def FAR *) ;
static bool near    write_fd(GEIFILE FAR *, byte) ;
static bool near    get_flbuffer(fix FAR *) ;
static bool near    free_flbuffer(fix, fix) ;
static bool near    wait_editin(fix FAR *, fix) ;
static void near    check_fname(void) ;
static void near    read_routine(fix) ;
static void near    write_routine(fix) ;
#else
static bool near    open_edit() ;
static bool near    write_fd() ;
static bool near    get_flbuffer() ;
static bool near    free_flbuffer() ;
static bool near    wait_editin() ;
static void near    check_fname() ;
static void near    read_routine() ;
static void near    write_routine() ;
#endif  /* LINT_ARGS */


#ifdef  LINT_ARGS
extern void     init_file(void) ;
extern bool     open_file(struct object_def FAR *) ;
extern bool     close_file(struct object_def FAR *) ;
extern bool     close_fd(GEIFILE FAR *) ;
extern bool     read_file(struct object_def FAR *, byte FAR *) ;
extern bool     read_fd(GEIFILE FAR *, byte FAR *) ;
extern bool     unread_file(byte, struct object_def FAR *) ;
// DJC declared in language.h
// extern void     vm_close_file(p_level) ;
#else
extern void     init_file() ;
extern bool     open_file() ;
extern bool     close_file() ;
extern bool     close_fd() ;
extern bool     read_file() ;
extern bool     read_fd() ;
extern bool     unread_file() ;
// DJC declared in language.h
// extern void     vm_close_file() ;
#endif  /* LINT_ARGS */
extern GEItmr_t      wait_tmr;   /* jonesw */
extern fix16         waittimeout_set; /*jonesw*/

//DJC UPD045
extern bool g_extallocfail;

/* @WIN; add prototype */
bool read_c_exec(byte FAR *, struct object_def FAR *) ;
bool read_c_norm(byte FAR *, struct object_def FAR *) ;
void unread_char(fix, struct object_def FAR *) ;

/*
**********************************************************************
*
*   This submodule implements the operator file.
*   Its operand and result objects on the operand stack are :
*       string1 string2 -file- file
*   This operator creates a file object for the file identifid by
*   string1, accessing it as specitied by string2. In this version,
*   only four kinds of file are implemted.
*
*   Name:       op_file
*   Called:     interpreter
*   Calling:    open_file
**********************************************************************
*/
fix
op_file()
{
    byte   FAR *l_tmptr, FAR *l_mode ;
    struct  object_def  l_fobj ;

    /*
    * check access right
    */
    if( (ACCESS_OP(0) >= EXECUTEONLY) ||
        (ACCESS_OP(1) >= EXECUTEONLY) ||
        (LENGTH_OP(0) > 3) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    l_tmptr = (byte FAR *)VALUE_OP(0) ;
    fs_info.attr = 0 ;
    l_mode = g_mode ;
    /*
    * ?? the second operand is not defined clearly
    * l_mode: a null terminate string for fopen()
    * fs_info.attr: attribute value to fill in file descriptor
    *       bit 0:  read
    *       bit 1:  write
    *       bit 2:  append
    *       bit 3:  statementedit/lineedit
    */
    if( LENGTH_OP(0) != 1 ) {
        ERROR(INVALIDACCESS) ;                   /* ?? */
        return(0) ;
    }

    switch(*l_tmptr++) {
    case 'r':
        fs_info.attr |= F_READ ;
        *l_mode++ = 'r' ;
        break ;

    case 'w':
        fs_info.attr |= F_WRITE ;
        *l_mode++ = 'w' ;
        break ;

    default:
        ERROR(INVALIDACCESS) ;                   /* ?? */
        return(0) ;
    }   /* switch */

    *l_mode = 0 ;
    fs_info.fnameptr = (byte FAR *)VALUE_OP(1) ;
    fs_info.fnamelen = LENGTH_OP(1) ;

    if ( open_file(&l_fobj) ) {
        if ( (fs_info.attr & F_RW) == F_READ ) {
            ACCESS_SET(&l_fobj, READONLY) ;
        }
        ATTRIBUTE_SET(&l_fobj, LITERAL) ;
        POP(2) ;
        PUSH_OBJ(&l_fobj) ;
    }
    return(0) ;
}   /* op_file */
/*
**********************************************************************
*
*   This submodule implements the operator closefile.
*   Its operand and result objects on the operand stack are :
*       file -closefile-
*   For an outfile, closefile first performs a flusfile.
*
*   Name:       op_closefile
*   Called:     interpreter
*   Calling:    close_file
**********************************************************************
*/
fix
op_closefile()
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if( (! GEIio_isopen(l_file)) || ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0)) ) { //@WIN
        POP(1) ;
        return(0) ;
    }

    if( close_fd(l_file) )
        POP(1) ;

    return(0) ;
}   /* op_closefile */
/*
**********************************************************************
*
*   This submodule implements the operator read.
*   Its operand and result objects on the operand stack are :
*       file -read- integer true
*                   false
*   It reads the next character from the input file, and pushes it on the
*   stack as an integer, and pushes a true object as an indication of
*   success. If an end-of-file is encountered before a character is read,
*   it closes the file and returns false on the operand stack.
*
*   Name:       op_read
*   Called:     interpreter
*   Calling:    read_char
*               close_fd
**********************************************************************
*/
fix
op_read()
{
    byte    l_c ;
    GEIFILE FAR *l_file ;

    if( (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( ! GEIio_isreadable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) { //@WIN
        if( estate == NON_EEXEC ) {
            if( read_fd(l_file, &l_c) ) {
                if (l_c == 10 && CRLF_flag) {
                    CRLF_flag = 0 ;
                    if (read_fd(l_file, &l_c)) {
                        if( l_c == 13 ) {
                            l_c = 10 ;
                            CRLF_flag = 1 ;
                        }
                    goto read_true ;
                    } else
                        goto read_false ;
                } else CRLF_flag = 0 ;

                if( l_c == 13 ) {
                    l_c = 10 ;
                    CRLF_flag = 1 ;
                }
                goto read_true ;
            } else
                goto read_false ;
        } else {
            if( read_c_exec(&l_c, GET_OPERAND(0)) )
                goto read_true ;
            else
                goto read_false ;
        }
    }

read_false:
    GEIio_clearerr(l_file) ;
    GEIclearerr() ;
    if( ! ANY_ERROR() ) {
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }
    return(0) ;

read_true:
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, ((ufix32)l_c & 0x000000FF)) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    return(0) ;

}   /* op_read */
/*
**********************************************************************
*
*   This submodule implements the operator write.
*   Its operand and result objects on the operand stack are :
*       file integer -write-
*   It appends a single character to the output file. The integer operand
*   must be in the range 0 to 255 representing a character code.
*
*   Name:       op_write
*   Called:     interpreter
*   Calling:    write_fd
**********************************************************************
*/
fix
op_write()
{
    ubyte   l_c ;
    GEIFILE FAR *l_file ;

    if( ACCESS_OP(1) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;

    if ( ! GEIio_iswriteable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if ( (! GEIio_isopen(l_file)) || ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) { //@WIN
        ERROR(IOERROR) ;
        return(0) ;
    }

    l_c = (ubyte)(VALUE_OP(0) % 256) ;

    if( write_fd(l_file, l_c) )
        POP(2) ;
    return(0) ;
}   /* op_write */
/*
**********************************************************************
*
*   This submodule implements the operator readhexstring.
*   Its operand and result objects on the operand stack are :
*       file string -readhexstring- substring boolean
*   It reads hexadecimal charaters from the input file to the string.
*
*   Name:       op_readhexstring
*   Called:     interpreter
*   Calling:    read_routine
**********************************************************************
*/
fix
op_readhexstring()
{
    read_routine(READHEXSTRING) ;
    return(0) ;
}   /* op_readhexstring */
/*
**********************************************************************
*
*   This submodule implements the operator writehexstring.
*   Its operand and result objects on the operand stack are :
*       file string -writehexstring-
*   It writes the characters in the string to the file as hexadecimal digits.
*
*   Name:       op_writehexstring
*   Called:     interpreter
*   Calling:    write_routine
**********************************************************************
*/
fix
op_writehexstring()
{
    write_routine(WRITEHEXSTRING) ;
    return(0) ;
}   /* op_writehexstring */
/*
**********************************************************************
*
*   This submodule implements the operator readstring.
*   Its operand and result objects on the operand stack are :
*       file string -readstring- substring boolean
*   It reads characters from the file and stores them into successive elements
*   of string until the entire string has been filled or an end-of-file
*   indication is encountered in file. It returns the substring of the string
*   that was actually filled and a boolean as a indication of the outcome.
*
*   Name:       op_readstring
*   Called:     interpreter
*   Calling     read_routine
**********************************************************************
*/
fix
op_readstring()
{
    read_routine(READSTRING) ;
    return(0) ;
}   /* op_readstring */
/*
**********************************************************************
*
*   This submodule implements the operator writestring.
*   Its operand and result objects on the operand stack are :
*       file string -writestring-
*   It writes the characters of the string to the output file.
*
*   Name:       op_writestring
*   Called:     interpreter
*   Calling:    write_routine
**********************************************************************
*/
fix
op_writestring()
{
    write_routine(WRITESTRING) ;
    return(0) ;
}   /* op_writestring */
/*
**********************************************************************
*
*   This submodule implements the operator readline.
*   Its operand and result objects on the operand stack are :
*       file string -readline-  substring bool
*   It reads a line of characters from the file and stores them
*   into successive elements of the string.
*
*   Name:       op_readline
*   Called:     interpreter
*   Calling:    read_routine
**********************************************************************
*/
fix
op_readline()
{
    read_routine(READLINE) ;
    return(0) ;
}   /* op_readline */
/*
**********************************************************************
*
*   This submodule implements the operator token.
*   Its operand and result objects on the operand stack are :
*       file   -token- any true
*                      false
*       string -token- post any true
*                      false
*   read characters from the file or the string, interpreting them according
*   to the PostScript syntax rules, until it has scanned and constructed an
*   entire object.
*
*   Name:       op_token
*   Called:     interpreter
*   Calling:    get_token
*               close_fd
**********************************************************************
*/
fix
op_token()
{
    bool    l_bool ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_token, l_obj ;

    if (ACCESS_OP(0) >= EXECUTEONLY) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (TYPE_OP(0) == FILETYPE)
        l_bool = TRUE ;
    else
        l_bool = FALSE ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if (l_bool && ((! GEIio_isopen(l_file)) ||
                     ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0))) ) {//@WIN
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        return(0) ;
    }

    /* call get token procedure to get a token */
    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    if (get_token(&l_token, &l_obj)) {
        if (TYPE(&l_token) != EOFTYPE) {
            LEVEL_SET(&l_token, LEVEL(&l_obj)); /* pjsu 3-17-1991 */
            POP(1) ;
            if (!l_bool) {
                /* ?? testing
                {
                    fix16   l_len ;
                    byte    FAR *l_ptr ;

                    switch (TYPE(&l_token)) {
                    case NAMETYPE:
                    case INTEGERTYPE:
                    case REALTYPE:
                        l_ptr = (byte FAR *)VALUE(&l_obj) ;
                        l_len = LENGTH(&l_obj) ;
                        if ((l_len-- >= 1) && (ISWHITESPACE(FAR *l_ptr))) {
                            l_ptr++ ;
                            VALUE(&l_obj) = (ufix32)l_ptr ;
                            LENGTH(&l_obj) = l_len ;
                        }
                    }
                }
                */

                PUSH_ORIGLEVEL_OBJ(&l_obj) ;
/*              PUSH_OBJ(&l_obj) ; pjsu 3-17-1991 */
                if (FRCOUNT() < 2)
                    ERROR(STACKOVERFLOW) ;
                else
                    PUSH_ORIGLEVEL_OBJ(&l_token) ;
            } else {
                PUSH_ORIGLEVEL_OBJ(&l_token) ;
                if (FRCOUNT() < 1)
                    ERROR(STACKOVERFLOW) ;
            }
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        } else {
            if (l_bool)
                close_fd(l_file) ;
            POP(1) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    } else if (ANY_ERROR() == SYNTAXERROR) {
        if (l_bool)
            close_fd(l_file) ;
        CLEAR_ERROR() ;
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0,LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_token */
/*
**********************************************************************
*
*   This submodule implements the operator file.
*   Its operand and result objects on the operand stack are :
*       file -bytesavailable integer
*   It returns the number of bytes that are immediately avaible for
*   reading from the file without waiting.
*
*   Name:       op_bytesavailable
*   Called:     interpreter
*   Calling:    ?? byteavailable
*               ioctl
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_bytesavailable()
{
    GEIFILE FAR *l_file ;
    fix32   l_i ;

    if( ACCESS_OP(0) == NOACCESS ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;
    l_i = -1 ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN

        if( GEIio_isreadable(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            if( GEIio_isedit(l_file) ) {
                l_fbuf = l_file->f_fbuf ;
                l_i = (fix32)(ufix32)l_fbuf->size + l_fbuf->incount ;
            } else
                GEIio_ioctl(l_file, _FIONREAD, (int FAR *)&l_i) ; /*@WIN add cast*/
        }
    }
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, l_i) ;

    return(0) ;
}   /* op_bytesavailable */
/*
**********************************************************************
*
*   This submodule implements the operator flush.
*   Its operand and result objects on the operand stack are :
*       -flush-
*   It causes any buffered characters for the stardard output file to be
*   delivered immediately.
*
*   Name:       op_flush
*   Called:     interpreter
*   Calling:    fflush
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_flush()
{
    GEIio_flush(GEIio_stdout) ;
    return(0) ;
}   /* op_flush */
/*
**********************************************************************
*
*   This submodule implements the operator flushfile
*   Its operand and result objects on the operand stack are :
*       file -flushfile-
*   If the file is an output file, it causes any buffered characters for
*   that file to be delivered immediately.
*   If the file is an input file, it reads and discards data from file
*   until the end-of-file indication is encountered.
*
*   Name:       op_flushfile
*   Called:     interpreter
*   Calling:    close_fd
*               wait_stdin
*               fflush
*               create_string
*               strncpy
*               clearerr
*               free_flbuffer
**********************************************************************
*/
fix
op_flushfile()
{
    GEIFILE FAR *l_file ;
    struct object_def l_obj ;
    int  iTmp;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN
        if( GEIio_isedit(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            /* RELEASE BUFFER */
            l_fbuf = l_file->f_fbuf ;
            l_fbuf->incount = 0 ;
            if( l_fbuf->size != 0 ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->size = 0 ;
            }
            l_fbuf->rw_buffer = MINUS_ONE ;
        } else
        if( GEIio_iswriteable(l_file) ) {
            GEIio_flush(l_file) ;
        } else {
            for ( ; ;) {
                //DJC if( (char)GEIio_getc(l_file) == EOF ) { //@WIN; cast to fix bug
                iTmp = (int)GEIio_getc(l_file);
                if (iTmp == EOF) {
                    if( GEIio_err(l_file) ) {
                        if( GEIerror() == ETIME ) {
                            if ( FRCOUNT() < 1 )
                                ERROR(STACKOVERFLOW) ;
                            else if (create_string(&l_obj, (ufix16)7)) {
                                lstrncpy((byte FAR *)l_obj.value, TMOUT, 7) ;/*@WIN*/
                                PUSH_OBJ(&l_obj) ;
                            }
                        } else
                            ERROR(IOERROR) ;
                        /* ?? need close file */
                    }
                    /* ?? leave for next time */
                    GEIio_clearerr(l_file) ;
                    GEIclearerr() ;
                    close_fd(l_file) ;
                    break ;
                } /* if */
            } /* for */
        }
    }

    if( ! ANY_ERROR() ) POP(1) ;
    //DJC UPD045
    g_extallocfail=FALSE;

    return(0) ;
}   /* op_flushfile */
/*
**********************************************************************
*
*   This submodule implements the operator resetfile.
*   Its operand and result objects on the operand stack are :
*       file -resetfile-
*   It discards buffered characters belonging to a file object.
*   For an input file, it discard all the characters that have been received
*   from the source but not yet consumed ; for an out file, it discards
*   any characters that have been written to the file but not yet deliverd
*   to their destination.
*
*   Name:       op_resetfile
*   Called:     interpreter:
*   Calling:    close_fd
*               free_flbuffer
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_resetfile()
{
    GEIFILE FAR *l_file ;
    fix     l_arg ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN
        if( GEIio_isedit(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            /* RELEASE BUFFER */
            l_fbuf = l_file->f_fbuf ;
            l_fbuf->incount = 0 ;
            if( l_fbuf->size != 0 ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->size = 0 ;
            }
            l_fbuf->rw_buffer = MINUS_ONE ;
        } else
            GEIio_ioctl(l_file, _FIONRESET, (int FAR *)&l_arg) ;  /*@WIN add cast*/
    }

    if( ! ANY_ERROR() ) POP(1) ;

    return(0) ;
}   /* op_resetfile */
/*
**********************************************************************
*
*   This submodule implements the operator status.
*   Its operand and result objects on the operand stack are :
*       *file -status- bool
*   It returns true if the file is still valid, false otherwise.
*
*   Name:       op_status
*   Called:     interpreter
*   Calling:    check_fname
*               ?? ps_status
*               ?? sf_diskonline
**********************************************************************
*/
fix
op_status()
{
    bool    l_bool ;
    GEIFILE FAR *l_file ;

    if (TYPE_OP(0) == STRINGTYPE) {
#ifdef  SCSI
        /* ?? noy complete yet */
        if(LENGTH_OP(0) > F_MAXNAMELEN) {
            ERROR(LIMITCHECK) ;
            return(0) ;
        }

        ps_status(l_buffer) ;
        } else
#endif  /* SCSI */
        {
            CLEAR_ERROR() ;
            POP(1) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    } else {
        l_file = (GEIFILE FAR *)VALUE_OP(0) ;
        l_bool = TRUE ;

        if ( (! GEIio_isopen(l_file)) ||
             ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0)) )  //@WIN
            l_bool = FALSE ;

        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* op_status */
/*
**********************************************************************
*
*   This submodule implements the operator run.
*   Its operand and result objects on the operand stack are :
*       string -run-
*   It executes the contents of the file identified by the string.
*
*   Name:       op_run
*   Called:     interpreter
*   Calling:    open_file
*               interpreter
**********************************************************************
*/
fix
op_run()
{
    struct  object_def  l_fobj ;

    byte        FAR *pp ;
    pp = (byte FAR *)VALUE_OP(0) ;
    if (!lstrcmp(pp, "%stdout") || !lstrcmp(pp, "%stderr")) {   /* @WIN */
        ERROR(INVALIDFILEACCESS);
        return(0) ;
    }

    g_mode[0] = 'r' ;
    g_mode[1] = 0 ;
    fs_info.attr = F_READ ;

    fs_info.fnameptr = (byte FAR *)VALUE_OP(0) ;
    fs_info.fnamelen = LENGTH_OP(0) ;

    if ( open_file(&l_fobj) ) {
        ACCESS_SET(&l_fobj, READONLY) ;
        ATTRIBUTE_SET(&l_fobj, EXECUTABLE) ;
        POP(1) ;
        interpreter(&l_fobj) ;
    }
    return(0) ;
}   /* op_run */
/*
**********************************************************************
*
*   This submodule implements the operator currentfile.
*   Its operand and result objects on the operand stack are :
*       -currentfile-  file
*   It return the topmost file object in the execution stack.
*
*   Name:       op_currentfile
*   Called:     interpreter
**********************************************************************
*/
fix
op_currentfile()
{
    fix     l_i ;

    if(FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    l_i = execstktop - 1 ;

    for(l_i = execstktop - 1 ; l_i >= 0 ; l_i--)
        if( TYPE(&execstack[l_i]) == FILETYPE ) {
            PUSH_ORIGLEVEL_OBJ(&execstack[l_i]) ;
            ATTRIBUTE_OP_SET(0, LITERAL) ;
            return(0) ;
        }
    PUSH_VALUE(FILETYPE, UNLIMITED, LITERAL, 0, NULL) ; /* ?? */
    return(0) ;
}   /* op_currentfile */
/*
**********************************************************************
*
*   This submodule implements the operator print.
*   Its operand and result objects on the operand stack are :
*       string -print-
*   It writes the characters of the string to the stardard output file.
*
*   Name:       op_print
*   Called:     interpreter
*   Calling:    port_out_string
**********************************************************************
*/
fix
op_print()
{
    if( ACCESS_OP(0) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    GEIio_write(GEIio_stdout, (byte FAR *)VALUE_OP(0), (fix)LENGTH_OP(0)) ;
    POP(1) ;

/*  if( GEIio_write(GEIio_stdout, (byte *)VALUE_OP(0), (fix)LENGTH_OP(0)) !=
                EOF )
        POP(1) ;
    else {
        GEIio_clearerr(GEIio_stdout) ;
        GEIclearerr() ;
    }
*/
    return(0) ;
}   /* op_print */
/*
**********************************************************************
*   Name:       op_echo
*   Called:     interpreter
**********************************************************************
*/
fix
op_echo()
{
    echo_setting = (bool8)VALUE_OP(0) ;
    POP(1) ;
    return(0) ;
}   /* op_echo */
/*
**********************************************************************
*
*   This submodule implements the operator eexec.
*   Its operand and result objects on the operand stack are :
*       string/file -eexec- any
*   This operator reads a block of code in eexec format from a string or
*   program input, decrypts the code to postscript then executes it.
*
*   Name:       op_eexec
*   Called:     interpreter
*   Calling:    interpreter
*               op_begin
*
*   ?? if reenter
**********************************************************************
*/
fix op_eexec()
{
    fix tmp ;
    GEIFILE FAR *l_file ;
    struct object_def s_obj ;
    struct object_def   dict_obj ;

    *(&dict_obj) = *(&dictstack[0]) ;
    PUSH_OBJ(&dict_obj) ;
    op_begin() ;
    if (ANY_ERROR())
        return(0) ;

    /*
    * initialization
    */
    eseed = 0xd971 ;
    old_eseed = eseed ;
    bypass = 4 ;
    itype = UNKNOWN ;

    COPY_OBJ(GET_OPERAND(0), &s_obj) ;
    if( TYPE_OP(0) == FILETYPE ) {
        if( (l_file=GEIio_dup((GEIFILE FAR *)VALUE_OP(0))) == NULL ) {

            /* ?? */
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIio_clearerr((GEIFILE FAR *)VALUE_OP(0)) ;
            GEIclearerr() ;
            return(0) ;
        } else {
            /* ?? file type */
            LENGTH(&s_obj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(&s_obj) = (ULONG_PTR)l_file ;
        }
    //}
    //DJC else is added from history.log UPD039
    } else {   /* Transfer string to file object; @WIN */
        struct object_def  FAR *cur_obj = GET_OPERAND(0);

        if((l_file=GEIio_sopen((char FAR *)cur_obj->value,
                               cur_obj->length, _O_RDONLY)) == NULL) {
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;
            GEIclearerr() ;
            return(0) ;
        } else {
            TYPE_SET(&s_obj, FILETYPE) ;
            ACCESS_SET(&s_obj, READONLY) ;
            ATTRIBUTE_SET(&s_obj, EXECUTABLE) ;
            LENGTH(&s_obj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(&s_obj) = (ULONG_PTR)l_file ;
        }
    }
    //DJC end fix from UPD039



    POP(1) ;
    ATTRIBUTE_SET(&s_obj, EXECUTABLE) ;
    estate = EEXEC ;

    tmp = interpreter(&s_obj) ;
    /* reset */
    estate = NON_EEXEC ;

    if( dictstack[dictstktop-1].value == dictstack[0].value )
        POP_DICT(1) ;
    return(0) ;
}   /* op_eexec */

/*
**********************************************************************
*
*   Name:       st_setstdio
*   Called:     interpreter
*   Calling:
*
*   ?? close original files
**********************************************************************
*/
fix
st_setstdio()
{
    return(0) ;
}   /* st_setstdio */
/*
**********************************************************************
*
*   This module is to initialize free link list of file buffer and
*   setup file descriptor table of upper level.
*
*   Name:       init_file
*   Called:     start
*   Calling     fardata
**********************************************************************
*/
void
init_file()
{
    fix     l_i, l_j;

    file_buffer = (struct file_buf_def far * )
        fardata( (ufix32)FILE_MAXBUFFERSZ * sizeof(struct file_buf_def) ) ;

    /*
    * initialize file spool
    */
    l_j = FILE_MAXBUFFERSZ - 1 ;
    fspool_head = 0 ;

    for(l_i=0 ; l_i < l_j ; l_i++)
        file_buffer[l_i].next = l_i + 1 ;

    file_buffer[l_j].next = MINUS_ONE ;         /* nil */
    echo_setting = TRUE ;
}   /* init_file */
/*
**********************************************************************
*   Name:       open_file
*   Called:     op_file
*               op_run
*   Calling:    check_fname
*               open_edit
*
*   Input:      struct object_def FAR *
*   Output:     bool
*
*   pass block: fs_info (know: attr, usrptr, usrlen)
**********************************************************************
*/
bool
open_file(p_fileobj)
struct object_def   FAR *p_fileobj ;
{
    fix     l_j ;
    bool    l_flag ;
    GEIFILE FAR *l_file = 0;

    check_fname() ;

    l_flag = TRUE ;
    l_j = fs_info.attr & F_WRITE ;           /* ?? RW */
    switch(fs_info.ftype) {
    case F_STDIN:
        if ( ! l_j )
            l_file = GEIio_stdin ;
        else
            l_j = -1 ;
        break ;

    case F_STDOUT:
        if ( l_j )
            l_file = GEIio_stdout ;
        else
            l_j = -1 ;
        break ;

    case F_STDERR:
        if ( l_j )
            l_file = GEIio_stderr ;
        else
            l_j = -1 ;
        break ;

    case FERR_TYPE:
        l_j = -1 ;
        break ;

    default:
        l_flag = FALSE ;

    }   /* switch */

    if(l_j == -1) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    TYPE_SET(p_fileobj, FILETYPE) ;
    ACCESS_SET(p_fileobj, UNLIMITED) ;
    LEVEL_SET(p_fileobj, current_save_level) ;  /* ?? std file need */

    if(l_flag) {
        /* ?? set savelevel */
/*
printf("open_file<%d>:lstdin<%lx>, stdin<%lx>\n", fs_info.ftype, l_file,
        GEIio_stdin) ;
*/
        LENGTH(p_fileobj) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(p_fileobj) = (ULONG_PTR)l_file ;
        return(TRUE) ;
    }

    switch(fs_info.ftype) {
    case SEDIT_TYPE:
    case LEDIT_TYPE:
        if( (g_editfile=GEIio_dup(GEIio_stdin)) == NULL ) {

            /* ?? */
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIclearerr() ;
            return(FALSE) ;
        }

        GEIio_setedit(g_editfile) ;
        GEIio_setsavelevel(g_editfile, current_save_level) ;
        LENGTH(p_fileobj) = ++GEIio_opentag(g_editfile) ;
        VALUE(p_fileobj) = (ULONG_PTR)g_editfile ;

        if( ! (l_flag=open_edit(p_fileobj)) ) {
            GEIio_close(g_editfile) ;
        }

        break ;

    case ORDFILE_TYPE:
        if( fs_info.attr & F_READ )
            l_flag = _O_RDONLY ;
        else
            l_flag = _O_WRONLY ;
        if( (l_file=GEIio_open(fs_info.fnameptr, fs_info.fnamelen, l_flag)) ==
            NULL ) {

            /* ?? */
            if( GEIerror() == EZERO )
                ERROR(UNDEFINEDFILENAME) ;
            else if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIclearerr() ;
            return(FALSE) ;
        } else {
            /* ?? file type */
            LENGTH(p_fileobj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(p_fileobj) = (ULONG_PTR)l_file ;
            l_flag = TRUE ;
        }
        break ;

    default:
        /* ??
        ERROR(UNDEFINEDFILENAME) ;
        */
        return(FALSE) ;
    }
    return(l_flag) ;
}   /* open_file */
/*
**********************************************************************
*   Name:       open_edit
*   Called:     open_file
*   Calling:    set_echo
*               wait_editin
*               statementgetc
*               linegetc
*
*   Input:      struct object_def FAR *
*   Output:     bool
*
*   Note:   ^D: UNDEFINEDFILENAME immediately
*
**********************************************************************
*/
static bool near
open_edit(p_fileobj)
struct object_def   FAR *p_fileobj ;
{
    fix l_i, l_j, l_nbyte, l_first ;
    byte l_chr ;
    fix16  (FAR *fun)(void) ;           /* @WIN; add prototype */
    bool l_flag = FALSE;

    if (echo_setting)
        set_echo(1) ;                        /* set echo mode */

    /*
    * wait first line or statement
    */
    if (!wait_editin(&l_nbyte, fs_info.ftype)) {  /* ERROR */
        set_echo(0) ;
        /* ??
        if ( ! ANY_ERROR() )
            ERROR(UNDEFINEDFILENAME) ;
        */
        return(FALSE) ;
    } else if(l_nbyte == 0) {       /* ^D */
        set_echo(0) ;
        GEIio_clearerr(GEIio_stdin) ;
        GEIclearerr() ;
        ERROR(UNDEFINEDFILENAME) ;
        return(FALSE) ;
    }
    if (fs_info.ftype == SEDIT_TYPE)
        fun = statementgetc ;
    else
        fun = linegetc ;

    /* check interrupt ^C */
    /* ?? skip the input chars */
    if (check_Control_C()) {
        for (l_i = 0 ; l_i < l_nbyte ; l_i++)
            (*fun)() ;
        POP(2) ;
        set_echo(0) ;
        return(TRUE) ;
    }

    if( get_flbuffer(&l_j) ) {
        GEIfbuf_t       FAR *l_fbuf ;

        l_first = l_j ;              /* first block no */
        l_fbuf = g_editfile->f_fbuf ;
        l_fbuf->rw_buffer = (short)l_j ;
        l_fbuf->rw_offset = 0 ;
        l_fbuf->size = 0 ;
        l_flag = TRUE ;
        if (l_nbyte < 0)
            l_nbyte = -l_nbyte ;     /* ?? eof but must leave flag to next in */

        /* copy from cook buffer to file */
        for (l_j = 0 ; l_j < l_nbyte ; l_j++) {
            l_chr = (byte)((*fun)() & 0x0FF) ;
            if( ! write_fd(g_editfile, l_chr) ) {
                for (++l_j ; l_j < l_nbyte ; l_j++)
                    (*fun)() ;                   /* ?? timeout */
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                GEIio_setsavelevel(g_editfile, 0) ;
                ERROR(LIMITCHECK) ;
                l_flag = FALSE ;
                break ;              /* ?? */
            }
        }   /* for */

        if(l_flag) {
            l_fbuf->rw_buffer = (short)l_first ;
            l_fbuf->rw_offset = MINUS_ONE ;
        }
    } else {       /* No free file descriptor */
        /* skip the input chars */
        if (l_nbyte < 0)
            l_nbyte = -l_nbyte ;
        for (l_j = 0 ; l_j < l_nbyte ; l_j++)
            (*fun)() ;
        ERROR(LIMITCHECK) ;
    }
    set_echo(0) ;
    return(l_flag) ;
}   /* open_edit */
/*
**********************************************************************
*
*   This submodule is to close a openning file.
*
*   Name:       close_file
*   Called:     op_closefile
*   Calling:    close_fd
**********************************************************************
*/
bool
close_file(p_fobj)
struct  object_def  FAR *p_fobj ;
{
    if( close_fd((GEIFILE FAR *)VALUE(p_fobj)) )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* close_file */

/*
**********************************************************************
*
*   This submodule is to close a openning file.
*
*   Name:       close_fd
*   Called:
*   Calling:    close
*               ?? sf_isdiskonline
*
*   Input:      fix
*   Output:     bool
**********************************************************************
*/
bool
close_fd(p_file)
GEIFILE FAR *p_file ;
{
    fix16     l_bitmap ;

    if( GEIio_isedit(p_file) ) {
        GEIfbuf_t       FAR *l_fbuf ;

        /* RELEASE BUFFER */
        l_fbuf = p_file->f_fbuf ;
        if( (l_fbuf->size != 0 ) ||
            (l_fbuf->rw_buffer != MINUS_ONE) ) {
            free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
            l_fbuf->size = 0 ;
            l_fbuf->rw_buffer = MINUS_ONE ;
        }
        l_fbuf->incount = 0 ;
    }
    GEIio_setsavelevel(p_file, 0) ;
    GEIio_close(p_file) ;

    l_bitmap = 0 ;
    if( p_file == GEIio_stdin )
        l_bitmap = _FORCESTDIN ;
    else if( p_file == GEIio_stdout )
        l_bitmap = _FORCESTDOUT ;
    else if( p_file == GEIio_stderr )
        l_bitmap = _FORCESTDERR ;

    if( l_bitmap ) {
        GEIio_forceopenstdios(l_bitmap) ;
    }

    return(TRUE) ;
}   /* close_fd */
/*
**********************************************************************
*
*   Name:       read_file
*   Called:
*   Calling:    read_fd
*
*   Input:      struct object_def FAR *
*               byte *
*   Output:     bool
**********************************************************************
*/
bool
read_file(p_fobj, p_chr)
struct object_def  FAR *p_fobj ;
byte   FAR *p_chr ;
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE(p_fobj) ;
    if( read_fd(l_file, p_chr) )
       return(TRUE) ;
    else
       return(FALSE) ;
}   /* read_file */
/*
**********************************************************************
*
*   Name:       read_fd
*   Called:     read_file
*   Calling:    free_flbuffer
*               close_fd
*               create_string
*               strncpy
*               clearerr
*               fread
*               ?? sf_isdiskonline
*
*   Input:      GEIFILE *
*               byte *
*   Output:     bool
**********************************************************************
*/
bool
read_fd(p_file, p_chr)
GEIFILE     FAR *p_file ;
byte        FAR *p_chr ;
{
    struct object_def l_obj ;

    fix  l_block ;
    GEIfbuf_t FAR *l_fbuf ;

    if( GEIio_isedit(p_file) ) {
        l_fbuf = p_file->f_fbuf ;
/*
printf("read_fd:edit, inc<%d>, siz<%d>, off<%d>, buf<%d>\n",
        l_fbuf->incount, l_fbuf->size, l_fbuf->rw_offset,
        l_fbuf->rw_buffer) ;
*/
/*      if ( l_block=l_fbuf->incount ) { erik chen */
        if ((l_block=l_fbuf->incount) > 0) {
            l_fbuf->incount = --l_block ;
            *p_chr = l_fbuf->inchar[l_block] ;
            return(TRUE) ;
        }
        /*
        * in case of EOF
        */
        if (! l_fbuf->size) {
            if( l_fbuf->rw_buffer != MINUS_ONE ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->rw_buffer = MINUS_ONE ;
            }
            l_fbuf->incount = 0 ;
            *p_chr = EOF ;
            return(FALSE) ;
        }
        /*
        * if end of this block, release this block and go to next one
        */
        if (l_fbuf->rw_offset >= (FILE_PERBUFFERSZ - 1)) {
           l_block = l_fbuf->rw_buffer ;
           l_fbuf->rw_buffer = file_buffer[l_block].next ;
           l_fbuf->rw_offset = MINUS_ONE ;
           free_flbuffer(1, l_block) ;
        }
        *p_chr = file_buffer[l_fbuf->rw_buffer].data[++(l_fbuf->rw_offset)] ;
        l_fbuf->size-- ;
        return(TRUE) ;
    } else
    {

//printf("before getc, file=%lx\n", p_file) ;

        *p_chr = GEIio_getc(p_file) ;

//printf("a:getc, ch<%d>eof<%d>err<%d>\n", *p_chr, GEIio_eof(p_file), GEIio_err(p_file)) ;
        //DJC UPD054
        // if( *p_chr == 0x03 || check_Control_C() ) {
        if( check_Control_C() ) {
            return(FALSE) ;
        }

        if( GEIio_eof(p_file) )
            return(FALSE) ;

        if( GEIio_err(p_file) ) {
            if( GEIerror() == ETIME ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if ( create_string(&l_obj, (ufix16)7) ) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            } else
                ERROR(IOERROR) ;

            return(FALSE) ;
        } else
            return(TRUE) ;
    }
}   /* read_fd */
/*
**********************************************************************
*
*   Name:       unread_file
*   Called:
*   Calling:    fseek
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      struct object_def FAR *
*   Output:     bool
**********************************************************************
*/
bool
unread_file(p_ch, p_fobj)
byte    p_ch ;
struct  object_def  FAR *p_fobj ;
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE(p_fobj) ;

    if( GEIio_isedit(l_file) ) {
        switch(l_file->f_fbuf->incount++) {
        case 0:
            l_file->f_fbuf->inchar[0] = p_ch ;
            break ;

        case 1:
            if( estate == EEXEC ) {
                l_file->f_fbuf->inchar[1] = p_ch ;
                break ;
            }

        /* FATAL ERROR */
        default:
            l_file->f_fbuf->incount = 0 ;
            return(FALSE) ;

        }   /* switch */
    } else
        GEIio_ungetc(p_ch, l_file) ;

    return(TRUE) ;
}   /* unread_file */
/*
**********************************************************************
*
*   Name:       write_fd
*   Called:     get_statement
*               get_lineedit
*   Calling:    get_flbuffer
*               write
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      fix
*               byte
*   Output:     bool
**********************************************************************
*/
static bool near
write_fd(p_file, p_chr)
GEIFILE FAR *p_file ;
byte    p_chr ;
{
    fix   l_block ;

    if( GEIio_isedit(p_file) ) {
        GEIfbuf_t       FAR *l_fbuf ;
        /*
        * if the current block is full, allocate a new one.
        */
        l_fbuf = p_file->f_fbuf ;
        if( l_fbuf->rw_offset >= FILE_PERBUFFERSZ ) {
            if( ! get_flbuffer(&l_block) )
                return(FALSE) ;
            file_buffer[l_fbuf->rw_buffer].next = (fix16)l_block ;
            l_fbuf->rw_offset = 0 ;
            l_fbuf->rw_buffer = (short)l_block ;
        }
        /*
        * put this character to buffer
        */
        file_buffer[p_file->f_fbuf->rw_buffer].data[p_file->f_fbuf->rw_offset] = p_chr ;
        p_file->f_fbuf->rw_offset++ ;
        p_file->f_fbuf->size++ ;
    } else
    {
        if( GEIio_putc(p_file, p_chr) == EOF ) {
            GEIio_clearerr(p_file) ;     /* ?? */
            GEIclearerr() ;              /* ?? */
            ERROR(IOERROR) ;
            return(FALSE) ;
        }
    }
    return(TRUE) ;
}   /* write_fd */
/*
**********************************************************************
*
*   This module is to get a file buffer, the buffer label
*   is stored in index.
*
*   Name:       get_flbuffer
*   Called:
*   Calling:    -
*
*   Input:      fix *
*   Output      bool
**********************************************************************
*/
static bool near
get_flbuffer(p_index)
fix   FAR *p_index ;
{
    fix   l_temp ;

    /* no available buffer */
    if( fspool_head == MINUS_ONE ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    l_temp = file_buffer[fspool_head].next ;
    file_buffer[fspool_head].next = MINUS_ONE ;
    *p_index = fspool_head ;
    fspool_head = (fix16)l_temp ;
    return(TRUE) ;
}   /* get_flbuffer */
/*
**********************************************************************
*
*   This module is to get a file buffer, the buffer label
*   is stored in index.
*
*   Name:       free_flbuffer
*   Called:     open_file
*               close_fd
*               read_fd
*   Calling:    -
*
*   Iutput:     fix
*               fix
*   Output:     bool
**********************************************************************
*/
static bool near
free_flbuffer(p_flag, p_begin)
fix   p_flag, p_begin ;
{
    fix     l_temp, l_end, l_current ;

    if( (p_begin < 0) || (p_begin >= FILE_MAXBUFFERSZ)  )
        return(FALSE) ;                 /* invalid index */

    l_temp = fspool_head ;
    fspool_head = (fix16)p_begin ;
    l_end = p_begin ;

    if(p_flag != 1) {                   /* release multi-block list */
        l_current = p_begin ;
        while( (l_current=file_buffer[l_current].next) != MINUS_ONE )
            l_end = l_current ;
    }
    file_buffer[l_end].next = (fix16)l_temp ;
    return(TRUE) ;
}   /* free_flbuffer */
/*
**********************************************************************
*
*   Name:       print_string
*   Called:     op_print
*   Calling:    port_out_string
*
*   Input:      byte *
*               ufix16
*   Output:     bool
**********************************************************************
*/
/*
bool
print_string(p_string, p_length)
byte   FAR *p_string ;
ufix16  p_length ;
{
    if( port_out_string(GEIio_stdout, p_string, p_length) ) {
        return(TRUE) ;
    } else {
        return(FALSE) ;
    }

}*/ /* print_string */
/*
**********************************************************************
*   Name:       check_fname
*   Called:
*   Calling:    strncmp
*               strlen
*               ?? sf_isdiskonline
*
*   Input:      byte *
*   Output:     bool
**********************************************************************
*/
static void near
check_fname()
{
    fix l_i, l_j ;
    byte FAR *l_tmptr ;

    fs_info.ftype = -1 ;

    if(*fs_info.fnameptr == '%') {
        /*
        * search special file table
        */
        for(l_i=0 ; l_i < SPECIALFILE_NO ; l_i++) {
            l_tmptr = special_file_table[l_i].name ;
            l_j = lstrlen(l_tmptr) ;    /* @WIN */
            if( (! lstrncmp(l_tmptr, fs_info.fnameptr, l_j)) &&
                (l_j == fs_info.fnamelen) ) {
                fs_info.ftype = special_file_table[l_i].ftype ;
                return ;
            }
        }
    }

    fs_info.ftype = ORDFILE_TYPE ;

    return ;
}   /* check_fname */
/*
**********************************************************************
*
*   Name:       wait_editin
*   Called:     open_file
*               get_statement
*   Calling:    getline
*               getstatement
*
*   Input:      fix16 *
*               fix16
*   Output:     bool
**********************************************************************
*/
static bool near
wait_editin(p_num, p_mode)
fix  FAR *p_num, p_mode ;
{
    bool   l_bool = FALSE ;

        switch(p_mode) {                        /* ?? need forever loop */
        case SEDIT_TYPE:
            l_bool = getstatement(p_num) ;
            break ;

        case LEDIT_TYPE:
            l_bool = getline(p_num) ;

        }   /* switch */
        /* check ^C postponed by caller */
        if (! l_bool || ANY_ERROR() )
            return(FALSE) ;
        else
            return(TRUE) ;
}   /* wait_editin */
/*
**********************************************************************
*
*   Name:       read_routine
*   Called:     op_readhexstring
*               op_readstring
*               op_readline
*   Calling:    read_char
*               close_fd
*               unread_file
*               fread
*               ?? sf_isdiskonline
*
*   Input:      fix
*
*   . ?? this routine's performace is not good because it read char
*        byte by byte
**********************************************************************
*/
static void near
read_routine(p_mode)
fix     p_mode ;
{
    bool    l_bool, l_pair ;
    byte    l_c1;
    byte    FAR *l_stream ;
    ufix16  l_i, l_strlen ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_strobj ;
    byte    l_c2 = 0;

    if( (ACCESS_OP(0) != UNLIMITED) ||
        (ACCESS_OP(1) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

    if(! LENGTH_OP(0)) {
        ERROR(RANGECHECK) ;
        return ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;       /* index of file descriptor */

    if ( ! GEIio_isreadable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
    COPY_OBJ( GET_OPERAND(0), &l_strobj ) ;
    l_strlen = LENGTH(&l_strobj)  ;             /* ?? less than 64K - 16B */
    l_stream = (byte FAR *)VALUE(&l_strobj) ;
    l_bool = TRUE ;

    if( (! GEIio_isopen(l_file)) ||
        ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) { //@WIN
        l_bool = FALSE ;
        LENGTH(&l_strobj) = 0 ;
    } else {
        switch(p_mode) {
        case READHEXSTRING:
            l_pair = FALSE ;
            /*
            * reads characters in hexadecimal form until end of file or
            * the string is full.
            */
            if( (estate != EEXEC) && (!GEIio_isedit(l_file)) ) {
                byte    l_buf[READ_BUF_LEN] ;
                //DJC fix     l_total, l_nbyte, l_hexno ;
                fix     l_total, l_hexno ;       //DJC fix from SC
                fix32   l_nbyte;   //DJC fix from SC

                l_total = 0 ;
                for( ; ;) {
                    //DJC l_nbyte = l_strlen << 1 ;
                    l_nbyte = (fix32) l_strlen << 1 ; //DJC fix from SC
                    if( l_pair )
                        l_nbyte-- ;
                    l_nbyte = MIN(l_nbyte, READ_BUF_LEN) ;
                    //DJC l_nbyte = GEIio_read(l_file, l_buf, l_nbyte) ;
                    l_nbyte = GEIio_read(l_file, l_buf, (fix)l_nbyte) ; // DJC fix from SC
                    l_hexno = 0 ;
                    //DJC for(l_i=0 ; l_i < (ufix16)l_nbyte ; l_i++) { //@WIN
                    for(l_i=0 ;  (fix32) l_i < l_nbyte ; l_i++) { //@WIN
                        l_c1 = l_buf[l_i] ;
                        if( ISHEXDIGIT(l_c1) ) {
                            if( l_pair ) {
                                l_c1 = (byte)EVAL_HEXDIGIT(l_c1) + l_c2 ;//@WIN
                                *l_stream++ = l_c1 ;
                                l_hexno++ ;
                                l_pair = FALSE ;        /* even */
                            } else {
                                l_c2 = (byte)(EVAL_HEXDIGIT(l_c1) << 4);//@WIN
                                l_pair = TRUE ;         /* odd */
                            }
                        }
                    }   /* for */
                    l_total += l_hexno ;
                    if( l_nbyte == EOF ) {
                        /* ?? if pair is true */
                        LENGTH(&l_strobj) = (ufix16)l_total ;
                        close_fd(l_file) ;           /* ?? clear any error */
                        l_bool = FALSE ;
                        break ;
                    } else {
                        l_strlen -= (ufix16)l_hexno ;
                        if( l_strlen )
                            continue ;
                        else
                            break ;
                    }
                }   /* for( ; ;) */
            } else {
                for(l_i=0 ; l_i < l_strlen ; ) {
                    if( READ_CHAR(&l_c1, GET_OPERAND(1)) ) {
                        if( ISHEXDIGIT(l_c1) ) {
                            if( l_pair ) {
                                l_c1 = (byte)EVAL_HEXDIGIT(l_c1) + l_c2 ;//@WIN
                                *l_stream++ = l_c1 ;
                                l_i++ ;
                                l_pair = FALSE ;        /* even */
                            } else {
                                l_c2 = (byte)(EVAL_HEXDIGIT(l_c1) << 4);//@WIN
                                l_pair = TRUE ;         /* odd */
                            }
                        } else
                            continue ;
                    } else {
                        /* ?? if pair is true */
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;           /* ?? clear any error */
                        l_bool = FALSE ;
                        break ;
                    }
                }   /* for */
            }
            break ;

        case READSTRING:
            /*
            READ_CHAR(&l_c1, GET_OPERAND(1)) ;  |* skip one char *|
            */
            if( estate == EEXEC ) {
                for(l_i=0 ; l_i < l_strlen ; l_i++) {
                    if( read_c_exec(&l_c1, GET_OPERAND(1)) ) {
                        *l_stream++ = l_c1 ;
                    } else {
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;
                        l_bool = FALSE ;
                        break ;
                    }
                }   /* for */
            }
            else if( GEIio_isedit(l_file) ) {
                for(l_i=0 ; l_i < l_strlen ; l_i++) {
                    if( read_fd(l_file, &l_c1) ) {
                        *l_stream++ = l_c1 ;
                    } else {
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;
                        l_bool = FALSE ;
                        break ;
                    }   /* for */
                }
            }
            else {
                int  cnt ;

                //DJCcnt = GEIio_read(l_file, l_stream, l_strlen) ;
                if ((cnt = GEIio_read(l_file, l_stream, l_strlen)) == EOF ) { //DJC fix from SC
                   cnt = 0;
                }
                if(cnt < (int)l_strlen) {       //@WIN
                    LENGTH(&l_strobj) = (fix16)cnt ;
                    close_fd(l_file) ;
                    GEIio_clearerr(l_file) ;
                    GEIclearerr() ;
                    l_bool = FALSE ;
                }
            }
            break ;

        case READLINE:
            l_c2 = TRUE ;
            for(l_i=0 ; l_i <= l_strlen ; l_i++) {
/*              if( READ_CHAR(&l_c1, GET_OPERAND(1)) ) { erik chen 3-26-1991 */
                if (((l_c1 = GEIio_getc(l_file)) != EOF) &&
                    (!GEIio_eof(l_file))) {
                    /*
                    * NL
                    */
/*                  if( l_c1 == NEWLINE ) { erik chen 5-2-1991 */
                    if( (l_c1 == 0x0a) || (l_c1 == 0x0d) ) {
                        if (l_c1 == 0x0d)
                            if (((l_c1 = GEIio_getc(l_file)) != EOF) &&
                                (!GEIio_eof(l_file)))
                                if (l_c1 != NEWLINE)
                                    unread_char(l_c1, GET_OPERAND(1)) ;
                        LENGTH(&l_strobj) = l_i ;
                        l_c2 = FALSE ;
                        break ;
                    }

                    if(l_i == l_strlen) {
                        unread_char(l_c1, GET_OPERAND(1)) ;
                        break ;
                    }
                    *l_stream++ = l_c1 ;
                } else {
                    /*
                    * EOF
                    */
                    LENGTH(&l_strobj) = l_i ;
                    close_fd(l_file) ;
                    GEIio_ioctl(l_file, _FIONRESET, (int FAR *)&l_i) ; /*@WIN add cast*/
                    l_bool = FALSE ;
                    l_c2 = FALSE ;
                    break ;
                }
            }   /* for */

            /* range check */
            if( l_c2 ) {
                ERROR(RANGECHECK) ;
                return ;
            }

        }   /* switch */
    }   /* else */

    POP(2) ;
    PUSH_ORIGLEVEL_OBJ(&l_strobj) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    return ;
}   /* read_routine */
/*
**********************************************************************
*
*   Name:       write_routine
*   Called:     op_writehexstring
*   Calling:    port_out_string
*               write_fd
*               fwrite
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      fix
**********************************************************************
*/
static void near
write_routine(p_mode)
fix     p_mode ;
{
    ubyte   l_c1, l_c2 ;
    byte    FAR *l_stream ;
    ufix16  l_i, l_strlen ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_strobj ;

    if( (ACCESS_OP(0) >= EXECUTEONLY) ||
        (ACCESS_OP(1) != UNLIMITED) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;       /* index of file descriptor */

    if ( (! GEIio_iswriteable(l_file)) ||
         (! GEIio_isopen(l_file)) ||
         ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) {    //@WIN
        ERROR(INVALIDACCESS) ;
        return ;
    }

    COPY_OBJ( GET_OPERAND(0), &l_strobj ) ;
    l_strlen = LENGTH(&l_strobj) ;          /* ?? less than 64K - 16B */
    if(l_strlen == 0)
        goto wr_1 ;

    l_stream = (byte FAR *)VALUE(&l_strobj) ;

    switch(p_mode) {

    case WRITEHEXSTRING:
        for(l_i=0 ; l_i < l_strlen ; l_i++) {
            l_c1 = *l_stream++ ;
            l_c2 = (l_c1 & (ubyte)0x0f) ;       //@WIN
            EVAL_ASCII(l_c2) ;
            l_c1 >>= 4 ;
            EVAL_ASCII(l_c1) ;
            if( (! write_fd(l_file, l_c1)) || (! write_fd(l_file, l_c2)) )
                return ;
        }   /* for */
        break ;

    case WRITESTRING:
        GEIio_write(l_file, l_stream, l_strlen) ;
/*      if( GEIio_write(l_file, l_stream, l_strlen) == EOF ) {
            GEIio_clearerr(l_file) ;
            GEIclearerr() ;
            ERROR(IOERROR) ;
            return ;
        } */
    }   /* switch */

wr_1:
    POP(2) ;
    return ;
}   /* write_routine */
/*
**********************************************************************
*   Name:       vm_close_file
*   Called:
*   Calling:    close_fd
*
*   Input:      fix16
**********************************************************************
*/
void
vm_close_file(p_level)
fix16   p_level ;
{
/*  GEIFILE *l_file ;

    l_file = GEIio_firstopen() ;

    while( l_file != NULL ) {
        if( GEIio_savelevel(l_file) >= p_level )
            close_fd(l_file) ;
        l_file = GEIio_nextopen() ;
    } */
}   /* vm_close_file */
#ifdef  SCSI
/*
**********************************************************************
*   Name:       op_deletefile
*   Called:     interpreter
*   Calling:    check_fname
*               remove
**********************************************************************
*/
fix
op_deletefile()
{
    if(LENGTH_OP(0) > F_MAXNAMELEN) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    if ( ! remove((byte *)VALUE_OP(0), (fix)LENGTH_OP(0)) )
        POP(1) ;
                                        /* ?? NULL means still open */
        return(0) ;
    }
    ERROR(UNDEFINEDFILENAME) ;           /* ?? ioerror */
    return(0) ;
}   /* op_deletefile */
/*
**********************************************************************
*   Name:       op_renamefile
*   Called:     interpreter
*   Calling:    check_fname
*               rename
**********************************************************************
*/
fix
op_renamefile()
{
    byte    l_old[F_MAXNAMELEN+1], l_new[F_MAXNAMELEN+1] ;


    if(LENGTH_OP(0) > F_MAXNAMELEN) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    /* new filename length > 0? */
    if(LENGTH_OP(0) <= 0) {
        ERROR(UNDEFINEDFILENAME) ;
        return(0) ;
    }

    if ( ! rename((byte FAR *)VALUE_OP(1), (fix)LENGTH_OP(1),
                  (byte FAR *)VALUE_OP(0), (fix)LENGTH_OP(0)) ) {
        POP(2) ;
        return(0) ;
    }
    ERROR(UNDEFINEDFILENAME) ;           /* ?? ioerror */
    return(0) ;
}   /* op_renamefile */
/*
**********************************************************************
*   Name:       op_filenameforall
*   Called:     interpreter
*   Calling:    check_fname
**********************************************************************
*|
fix
op_filenameforall()
{
    byte    l_buf[F_MAXNAMELEN+1] ;
    fix     l_len ;

    if( check_name(l_buf, (byte FAR *)VALUE_OP(2), (fix16)LENGTH_OP(2)) ) {
        if (*(byte FAR *)VALUE_OP(2) == '%') {
            l_len = file_table[F_DEF_KIND].chr_num ;
        } else {
            l_len = 0 ;
        }
        ps_filenameforall(file_table[F_DEF_KIND].fname, l_len, l_buf) ;
    }
    return(0) ;

}   |* op_filenameforall *|
*/
#endif  /* SCSI */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\error.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              ERROR.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *
 * revision history:
 *      7/13/90 ; ccteng ; add reporterror
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "user.h"
#include    <string.h>

#ifdef LINT_ARGS
static bool near    error_proc(ufix16) ;
#else
static bool near    error_proc() ;
#endif /* LINT_ARGS */

/************************************
 *  DICT: systemdict
 *  NAME: handleerror
 *  FUNCTION:
 *  11/29/89 Teng add to replace old 1pp /handleerror procedure
 ************************************/
fix
op_handleerror()
{
    struct  object_def  FAR *l_tmpobj ;

    /* call "er_doerror" in errordict */
    get_dict_value(ERRORDICT, "handleerror", &l_tmpobj) ;
    interpreter(l_tmpobj) ;

    return(0) ;
}   /* op_handleerror */

/************************************
 *  DICT: systemdict
 *  NAME: errorproc
 *  FUNCTION: ? could be an internal function
 *  11/29/89 Teng add to replace old 1pp /errorproc procedure
 ************************************/
fix
op_errorproc()
{
    struct  object_def  l_newobj, l_newobj1, l_null ;
    struct  object_def  FAR *l_tmpobj = &l_newobj, FAR *l_VMerror = &l_newobj1 ;
    struct  object_def  l_newerror = {0, 0, 0}, l_errorname, l_command, FAR *l_debug ;
    struct  object_def  l_dictstkary, l_opnstkary, l_execstkary ;
    struct  object_def  l_dstack, l_ostack, l_estack ;
    struct  object_def  FAR *l_vm, FAR *l_stopobj ;
    ufix16  l_i, l_j ;

#ifdef  DBG_1pp
    printf("errorproc()...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif  /* DBG_1pp */

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* set $error dict parameters */
    SET_TRUE_OBJ(&l_newerror) ;
    put_dict_value1(DERROR, "newerror", &l_newerror) ;
    COPY_OBJ(GET_OPERAND(0), &l_errorname) ;
    put_dict_value1(DERROR, "errorname", &l_errorname) ;
    COPY_OBJ(GET_OPERAND(1), &l_command) ;
    put_dict_value1(DERROR, "command", &l_command) ;
    POP(2) ;

#ifdef  DBG_1pp
    printf("errorname = ") ;
    PUSH_OBJ(&l_errorname) ;
    two_equal() ;
    printf("hash_id = %d\n", VALUE(&l_errorname)) ;
    printf("command = ") ;
    PUSH_OBJ(&l_command) ;
    two_equal() ;
#endif  /* DBG_1pp */

    /* update "$cur_vm" */
    get_dict_value(DERROR, "$debug", &l_debug) ;
    get_name1(l_VMerror, "VMerror", 7, TRUE) ;
    if ( VALUE(l_debug) )
        /* if "$debug" push vmstatus */
        op_vmstatus() ;
    else
        /* if not "$debug" push 3 NULLs */
        for (l_i = 0 ; l_i < 3 ; l_i++)
            PUSH_VALUE(NULLTYPE,UNLIMITED,LITERAL,0, 0) ;
    get_dict_value(DERROR, "$cur_vm", &l_vm) ;
    astore_array(l_vm) ;

    /* first error? */
    get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
    if ( ( TYPE(l_tmpobj) == NULLTYPE ) &&
         ( VALUE(&l_errorname) != VALUE(l_VMerror) ) ) {
        /* and if "errorname" != /VMerror */
        if ( ( !create_array(&l_execstkary, 250) ) ||
             ( !create_array(&l_opnstkary, 500) ) ||
             ( !create_array(&l_dictstkary, 20) ) ) {
            ERROR(VMERROR) ;
            return(0) ;
        } else {
            put_dict_value1(DERROR, "execstkary", &l_execstkary) ;
            put_dict_value1(DERROR, "opnstkary", &l_opnstkary) ;
            put_dict_value1(DERROR, "dictstkary", &l_dictstkary) ;
        } /* if-else */
    } /* if */

    get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
    if ( TYPE(l_tmpobj) != NULLTYPE ) {
        /* if "dictstkary" != NULL, update stacks */
        /* update "dstack" */
        get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_dstack) ;
        astore_stack(&l_dstack, DICTMODE) ;
        put_dict_value1(DERROR, "dstack", &l_dstack) ;

        /* update "estack" */
        get_dict_value(DERROR, "execstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_estack) ;
        astore_stack(&l_estack, EXECMODE) ;
     /* 2/16/90 ccteng, don't need it
      * LENGTH(&l_estack) -= 2 ;
      */
        put_dict_value1(DERROR, "estack", &l_estack) ;

        /* update "ostack" */
        l_j = COUNT() ;
        get_dict_value(DERROR, "opnstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_ostack) ;
        LENGTH(&l_ostack) = l_j ;
        for (l_i = 0 ; l_i < COUNT() ; l_i++)
              put_array(&l_ostack, l_i, GET_OPERAND(--l_j)) ;
        put_dict_value1(DERROR, "ostack", &l_ostack) ;

        /*
         * if "$debug": update $cur_font, $cur_screeen, $cur_matrix.
         */
        if ( VALUE(l_debug) ) {
            struct  object_def  l_screen, l_matrix, l_font ;

            /* update "$cur_font" */
            op_currentfont() ;       /* or use GSptr with include files */
            COPY_OBJ(GET_OPERAND(0), &l_font) ;
            put_dict_value1(DERROR, "$cur_font", &l_font) ;
            POP(1) ;

#ifdef  DBG_1pp
    printf("$cur_font = ") ;
    PUSH_OBJ(&l_font) ;
    two_equal() ;
#endif  /* DBG_1pp */

            /* update "$cur_screen" */
            op_currentscreen() ;     /* or use GSptr with include files */
            l_j = 3 ;                /* 3 array */
            create_array(&l_screen, l_j) ;
            for (l_i = 0 ; l_i < l_j ; l_i++)
                  put_array(&l_screen, l_i, GET_OPERAND(--l_j)) ;
            put_dict_value1(DERROR, "$cur_screen", &l_screen) ;
            POP(3) ;

#ifdef  DBG_1pp
    printf("$cur_screen = ") ;
    PUSH_OBJ(&l_screen) ;
    two_equal() ;
#endif  /* DBG_1pp */

            /* update "$cur_matrix" */
            create_array(&l_matrix, 6) ;
            PUSH_ORIGLEVEL_OBJ(&l_matrix) ;
            op_currentmatrix() ;
            put_dict_value1(DERROR, "$cur_matrix", &l_matrix) ;
            POP(1) ;

#ifdef  DBG_1pp
    printf("$cur_matrix = ") ;
    PUSH_OBJ(&l_matrix) ;
    two_equal() ;
#endif  /* DBG_1pp */

        } else {
            SET_NULL_OBJ(&l_null) ;
            put_dict_value1(DERROR, "$cur_font", &l_null) ;
            put_dict_value1(DERROR, "$cur_screen", &l_null) ;
            put_dict_value1(DERROR, "$cur_matrix", &l_null) ;
        } /* if */

    } /* if */

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}   /* op_errorproc */

/*
 * put value object associated with the specific key in specific dict,
 * the key and dict are represented in string format
 * it get the value_obj in current active dict using the dictname as key,
 * the value_obj is a dict object, then put the value into this dict using
 * the keyname as key.
 *
 * 12/20/89 ccteng, modify from put_dict_value (EXEC.C)
 */
bool
put_dict_value1(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj ;

    get_name1(&key_obj, dictname, lstrlen(dictname), TRUE) ;    /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get execdict obj */
    get_name1(&key_obj, keyname, lstrlen(keyname), TRUE) ;      /* @WIN */

    return(put_dict1(dict_obj, &key_obj, value, TRUE)) ;
}   /* put_dict_value1 */

/************************************
 *  DICT: errordict
 *  NAME: dictfull
 *  FUNCTION:
 *  INTERFACE:
 ************************************/
fix
er_dictfull()
{
#ifdef  DBG_1pp
    printf("dictfull()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTFULL) ;

    return(0) ;
}   /* er_dictfull */

/************************************
 *  DICT: errordict
 *  NAME: dictstackoverflow
 *  FUNCTION:
 *  INTERFACE:
 ************************************/
fix
er_dictstackoverflow()
{
#ifdef  DBG_1pp
    printf("dictstackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTSTACKOVERFLOW) ;

    return(0) ;
}   /* er_dictstackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: dictstackunderflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_dictstackunderflow()
{
#ifdef  DBG_1pp
    printf("dictstackunderflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTSTACKUNDERFLOW) ;

    return(0) ;
}   /* er_dictstackunderflow */

/************************************
 *  DICT: errordict
 *  NAME: execstackoverflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_execstackoverflow()
{
#ifdef  DBG_1pp
    printf("execstackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(EXECSTACKOVERFLOW) ;

    return(0) ;
}   /* er_execstackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: invalidaccess
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidaccess()
{
#ifdef  DBG_1pp
    printf("invalidaccess()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDACCESS) ;

    return(0) ;
}   /* er_invalidaccess */

/************************************
 *  DICT: errordict
 *  NAME: invalidexit
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidexit()
{
#ifdef  DBG_1pp
    printf("invalidexit()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDEXIT) ;

    return(0) ;
}   /* er_invalidexit */

/************************************
 *  DICT: errordict
 *  NAME: invalidfileaccess
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidfileaccess()
{
#ifdef  DBG_1pp
    printf("invalidfileaccess()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDFILEACCESS) ;

    return(0) ;
}   /* er_invalidfileaccess */

/************************************
 *  DICT: errordict
 *  NAME: invalidfont
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidfont()
{
#ifdef  DBG_1pp
    printf("invalidfont()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDFONT) ;

    return(0) ;
}   /* er_invalidfont */

/************************************
 *  DICT: errordict
 *  NAME: invalidrestore
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidrestore()
{
#ifdef  DBG_1pp
    printf("invalidrestore()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDRESTORE) ;

    return(0) ;
}   /* er_invalidrestore */

/************************************
 *  DICT: errordict
 *  NAME: ioerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_ioerror()
{
#ifdef  DBG_1pp
    printf("ioerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(IOERROR) ;

    return(0) ;
}   /* er_ioerror */

/************************************
 *  DICT: errordict
 *  NAME: limitcheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_limitcheck()
{
#ifdef  DBG_1pp
    printf("limitcheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(LIMITCHECK) ;

    return(0) ;
}   /* er_limitcheck */

/************************************
 *  DICT: errordict
 *  NAME: nocurrentpoint
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_nocurrentpoint()
{
#ifdef  DBG_1pp
    printf("nocurrentpoint()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(NOCURRENTPOINT) ;

    return(0) ;
}   /* er_nocurrentpoint */

/************************************
 *  DICT: errordict
 *  NAME: rangecheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_rangecheck()
{
#ifdef  DBG_1pp
    printf("rangecheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(RANGECHECK) ;

    return(0) ;
}   /* er_rangecheck */

/************************************
 *  DICT: errordict
 *  NAME: stackoverflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_stackoverflow()
{
#ifdef  DBG_1pp
    printf("stackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(STACKOVERFLOW) ;

    return(0) ;
}   /* er_stackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: stackunderflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_stackunderflow()
{
#ifdef  DBG_1pp
    printf("stackunderflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(STACKUNDERFLOW) ;

    return(0) ;
}   /* er_stackunderflow */

/************************************
 *  DICT: errordict
 *  NAME: syntaxerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_syntaxerror()
{
#ifdef  DBG_1pp
    printf("syntaxerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(SYNTAXERROR) ;

    return(0) ;
}   /* er_syntaxerror */

/************************************
 *  DICT: errordict
 *  NAME: timeout
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_timeout()
{
#ifdef  DBG_1pp
    printf("timeout()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(TIMEOUT) ;

    return(0) ;
}   /* er_timeout */

/************************************
 *  DICT: errordict
 *  NAME: typecheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_typecheck()
{
#ifdef  DBG_1pp
    printf("typecheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(TYPECHECK) ;

    return(0) ;
}   /* er_typecheck */

/************************************
 *  DICT: errordict
 *  NAME: undefined
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefined()
{
#ifdef  DBG_1pp
    printf("undefined()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINED) ;

    return(0) ;
}   /* er_undefined */

/************************************
 *  DICT: errordict
 *  NAME: undefinedfilename
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefinedfilename()
{
#ifdef  DBG_1pp
    printf("undefinedfilename()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINEDFILENAME) ;

    return(0) ;
}   /* er_undefinedfilename */

/************************************
 *  DICT: errordict
 *  NAME: undefinedresult
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefinedresult()
{
#ifdef  DBG_1pp
    printf("undefinedresult()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINEDRESULT) ;

    return(0) ;
}   /* er_undefinedresult */

/************************************
 *  DICT: errordict
 *  NAME: unmatchedmark
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_unmatchedmark()
{
#ifdef  DBG_1pp
    printf("unmatchedmark()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNMATCHEDMARK) ;

    return(0) ;
}   /* er_unmatchedmark */

/************************************
 *  DICT: errordict
 *  NAME: unregistered
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_unregistered()
{
#ifdef  DBG_1pp
    printf("unregistered()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNREGISTERED) ;

    return(0) ;
}   /* er_unregistered */

/************************************
 *  DICT: errordict
 *  NAME: VMerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_VMerror()
{
#ifdef  DBG_1pp
    printf("VMerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(VMERROR) ;

    return(0) ;
}   /* er_VMerror */

/************************************
 *  DICT: errordict
 *  NAME: interrupt
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_interrupt()
{
    struct  object_def  FAR *l_stopobj ;
#ifdef  DBG_1pp
    printf("interrupt()...\n") ;
#endif  /* DBG_1pp */

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}   /* er_interrupt */

/************************************
 *  DICT: errordict
 *  NAME: handleerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_handleerror()
{
    struct  object_def  FAR *l_errorname, FAR *l_newerror, FAR *l_command ;

#ifdef  DBG_1pp
    printf("er_handleerror()...\n") ;
#endif  /* DBG_1pp */

    /* 7/27/90 ccteng change FRCOUNT from 1 to 3 for messagedict reporterror */
    if (FRCOUNT() < 3) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* if "newerror", print the error message on screen */
    get_dict_value(DERROR, "newerror", &l_newerror) ;
    if ( VALUE(l_newerror) ) {

        //DJC here we must call a PSTODIB function to let the psttodib
        //DJC code know that the internal error handler was used and
        //DJC this data needs to be passed on to the caller of our DLL
        //
        PsInternalErrorCalled();   //DJC



        VALUE(l_newerror) = FALSE ;
        get_dict_value(DERROR, "command", &l_command) ;
        PUSH_ORIGLEVEL_OBJ(l_command) ;
        get_dict_value(DERROR, "errorname", &l_errorname) ;
        PUSH_ORIGLEVEL_OBJ(l_errorname) ;
        get_dict_value(MESSAGEDICT, "reporterror", &l_newerror) ;
        interpreter(l_newerror) ;
        op_flush() ;
    }

    return(0) ;
}   /* er_handleerror */

/************************************
 *  DICT: ..internal..
 *  NAME: errpr_proc
 *  FUNCTION:
 *  INTERFACE: above....
 ************************************/
static bool near
error_proc(errorname)
ufix16  errorname ;
{
    extern  byte   FAR * FAR error_table[] ;
    struct  object_def  l_errorobj ;
    byte    FAR *l_errorstring ;

#ifdef  DBG_1pp
    printf("error_proc()...\n") ;
#endif  /* DBG_1pp */

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(FALSE) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(FALSE) ;
    }

    /* push errorname */
    l_errorstring = (byte FAR *) error_table[errorname] ;
    get_name1(&l_errorobj, l_errorstring, lstrlen(l_errorstring), TRUE);/* @WIN */
    PUSH_ORIGLEVEL_OBJ(&l_errorobj) ;

#ifdef  DBG_1pp
    op_pstack() ;
    printf("end pstack...\n") ;
#endif  /* DBG_1pp */

    /* call systemdict "errorproc" */
    op_errorproc() ;

    return(TRUE) ;
}   /* error_proc */

/*
** Submodule get_name1
**
** Function Description
**
**      call get_name
*/
bool
get_name1(token, string, len, isvm)
struct  object_def FAR *token ;
byte    FAR *string ;
ufix    len ;
bool8   isvm ;
{
    /* set attribute and save_level */
    ATTRIBUTE_SET(token, LITERAL) ;
    LEVEL_SET(token, current_save_level) ;

    /* call get_name */
    if ( get_name(token, string, len, isvm) )
        return(TRUE) ;
    else
        return(FALSE) ;
} /* get_name1() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\ic_cfg.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ******************************************************************************
 *
 * FILE: ic_cfg.h
 *
 * HISTORY:
 ******************************************************************************
 */
/*
 *      Platform Configuration Structure
 */
struct ps_config
{
    unsigned int    FAR *PsMemoryPtr ;
    long int        PsMemorySize ;                      /* @WIN */
    int             PsDPIx ;
    int             PsDPIy ;
} ;

/*
 *      Imaging Component Error Return Codes
 */
#define PS_CONFIG_MALLOC        -1
#define PS_CONFIG_MPLANES       -2
#define PS_CONFIG_MWPP          -3
#define PS_CONFIG_DPI           -4
#define PS_FATAL_UNKNOWN        -11

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\fpexpt.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * FILE: setsp.c -- revised from setsp.asm
 * Pseudo file to provide functions:
 *      bauer_fpsignal
 *      _clear87
 *      _control87
 *      _status87
 *      set_sp
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"

void setargv()          //@WIN
{
}

void setenvp()          //@WIN
{
}

void init_fpsignal()    //@WIN
{
#ifdef  DBG
    printf("Init_fpsignal()\n");
#endif
}

void bauer_fpsignal()   //@WIN
{
#ifdef  DBG
    printf("Bauer_fpsignal()\n");
#endif
}

unsigned int _clear87()
{
    return(0);
}

unsigned int _control87(ufix arg1, ufix arg2)   /*@WIN; add prototype */
{
    return(0);
}

unsigned int _status87()
{
    return(0);
}

void setup_env() {}

void set_sp()
{
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\matherr.h ===
/* Copyright 1989 Interleaf, Inc.       */
/*
 * matherr.h
 */
/*
 * matherr_handler() actions
 */
#define MEH_CLEAR   0
#define MEH_STATUS  -1

/*
 * arithmetic error conditions
 */
#define MEH_ZERODIVIDE  0x0001
#define MEH_INFINITY    0x0002
#define MEH_UNDERFLOW   0x0004
#define MEH_DOMAIN      0x0008
#define MEH_SING        0x0010
#define MEH_OVERFLOW    0x0020
#define MEH_TLOSS       0x0040
#define MEH_PLOSS       0x0080

extern fix sigFPE() ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\init1pp.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              INIT1PP.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/30/89
 *      Owner:                  Microsoft Co.
 *      Description: this file contains all the initialization functionc
 *                   for statusdict and 1pp dicts.
 *
 * revision history:
 *
 *      06-18-90 ; Added string allocation for "jobsource"
 *              dictionary string entry.
 *      7/13/90 ; ccteng ; modify init_release(), add InitVersionDict, InitMsgDict
 *                      PSPrep, and delete some others
 *      7/13/90 ; ccteng ; comment init_psf_font, init_psg_font for rtfpp
 *      7/16/90 ; ccteng ; change printerdict arrays to be literal
 *      7/20/90 ; ccteng ; 1)delete PRODUCT in init_release
 *                       2)change init_userdict, init_errordict, init_serverdict,
 *                         init_printerdict, init_idletimedict, init_execdict,
 *                         init_Derror for change of dict_tab.c structure
 *      7/21/90 ; ccteng ; change init_release, move jobstate, jobsource to PSPrep
 *      7/23/90 ; ccteng ; include "startpage.h" and add StartPage initialization
 *      8/29/90 ; ccteng ; change <stdio.h> to "stdio.h"
 *      9/14/90 ; remove ALL_VM flag
 *     11/28/90  Danny   Precache Mech. Added(ref PCH:)
 *     11/30/90  Danny   Add for idle fonts setup at initial time(ref IDLI:)
 *     11/30/90  Danny  Add id_stdfont entries for 35 fonts (ref F35:)
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>                   /* move up @WIN */
#include    <string.h>                  /* move up @WIN */
#include    "global.ext"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geierr.h"
#include    "init1pp.h"
#include    "user.h"
#include    "release.h"
#include    "startpg.h"

#ifdef LINT_ARGS
static  void  near  init_userdict(void) ;
static  void  near  init_errordict(void) ;
static  void  near  init_serverdict(void) ;
static  void  near  init_printerdict(void) ;
static  void  near  init_idletimedict(void) ;
static  void  near  init_execdict(void) ;
static  void  near  init_Derrordict(void) ;
static  void  near  init_release(void) ;
static  void  near  init_printerdictarray(void) ;
static  void  near  init_idletimedictarray(void) ;
static  void  near  pre_cache(void) ;
//DJC
static  void  near  init_psprivatedict(void);  //DJC
#else
static  void  near  init_userdict() ;
static  void  near  init_errordict() ;
static  void  near  init_serverdict() ;
static  void  near  init_printerdict() ;
static  void  near  init_idletimedict() ;
static  void  near  init_execdict() ;
static  void  near  init_Derrordict() ;
static  void  near  init_release() ;
static  void  near  init_printerdictarray() ;
static  void  near  init_idletimedictarray() ;
static  void  near  pre_cache() ;
static  void  near  init_psprivatedict(); //DJC
#endif /* LINT_ARGS */

/* @WIN; add prototype */
fix us_readidlecachefont(void);

#ifdef KANJI
extern struct dict_head_def FAR *init_encoding_directory() ;
#endif  /* KANJI */

int     ES_flag = PDL;  /* added for Emulation Switch Aug-08,91 YM */

/*
 * init_1pp(): calling interface from main()
 *             to initialize each dictionaries
 */
void
init_1pp()
{
    struct  object_def  FAR *l_systemdict ;
    struct  dict_head_def   FAR *l_dict ;

    init_userdict() ;            /* init userdict */
#ifdef  DBG_1pp
    printf("init_userdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_errordict() ;           /* init errordict */
#ifdef  DBG_1pp
    printf("init_errordict() OK !\n") ;
#endif  /* DBG_1pp */

    init_serverdict() ;          /* init serverdict */
#ifdef  DBG_1pp
    printf("init_serverdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_printerdict() ;         /* init printerdict */
#ifdef  DBG_1pp
    printf("init_printerdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_idletimedict() ;        /* init idletimedict */
#ifdef  DBG_1pp
    printf("init_idletimedict() OK !\n") ;
#endif  /* DBG_1pp */

    init_execdict() ;            /* init execdict */
#ifdef  DBG_1pp
    printf("init_execdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_Derrordict() ;          /* init Derrordict */
#ifdef  DBG_1pp
    printf("init_Derrordict() OK !\n") ;
#endif  /* DBG_1pp */

    //DJC begin new init_psprivatedict
    init_psprivatedict() ;      /*  init psprivatedict */

#ifdef  DBG_1pp
    printf("init_psprivatedict() OK !\n") ;
#endif  /* DBG_1pp */

    //DJC end new init_psprivatedict

    init_release() ;              /* init release control data */
#ifdef  DBG_1pp
    printf("init_release() OK !\n") ;
#endif  /* DBG_1pp */

/*
 * optional functions for BS fonts in file INITBSF.C
 * to re-initialize the PSF font entries in /FontDirectory
 */
/*  init_psf_fonts() ; */          /* init FontDirectory */
#ifdef  DBG_1pp
    printf("init_psf_fonts() OK !\n") ;
#endif /* DBG_1pp */

    /*
     * re-set access of systemdict to be READONLY
     */
    get_dict_value("systemdict", "systemdict", &l_systemdict) ;
    l_dict = (struct dict_head_def FAR *) VALUE(l_systemdict) ;
    DACCESS_SET(l_dict, READONLY) ;

/*
 * optional functions for BS fonts in file INITBSF.C
 */
/*    init_psg_fonts() ;  */         /* init BS PSG fonts 03/28/90 kung */
#ifdef  DBG_1pp
    printf("init_psg_fonts() OK !\n") ;
    op_pstack() ;
#endif  /* DBG_1pp */

/*
 * build pre_cache data
 */
#ifdef PCH_S
    pre_cache() ;
#endif

#ifdef  DBG_1pp1
    printf("pre_cache() OK !\n") ;
#endif  /* DBG_1pp */

    st_idlefonts() ;
    op_counttomark() ;
    us_readidlecachefont() ;
    if (ANY_ERROR()) {
        op_cleartomark() ;
        CLEAR_ERROR() ;
    }
#ifdef DBG_1pp1
  printf("idle font setup OK !\n") ;
#endif

    return ;
}   /* init_1pp */

/*
 *  init_userdict()
 *     initialize userdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_userdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;
#ifdef  KANJI
    ufix32 max_length ;
    struct dict_head_def FAR *encod_dir ;
#endif  /* KANJI */

#ifdef  DBG_1pp1
    printf("init_userdict()...\n") ;
#endif  /* DBG_1pp1 */

    get_dict_value(SYSTEMDICT, USERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, MAXUSERDICTSZ) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

#ifdef  DBG_1pp1
    printf("for loop OK !\n") ;
#endif  /* DBG_1pp1 */

#ifdef  KANJI
    encod_dir = init_encoding_directory(&max_length) ;
    get_name(&key_obj, "EncodingDirectory",
                lstrlen("EncodingDirectory"), TRUE) ;   /* @WIN */
    TYPE_SET(&value_obj, DICTIONARYTYPE) ;
    VALUE(   &value_obj) = (ufix32)encod_dir ;
    LENGTH(  &value_obj) =  max_length ;
    put_dict(dict_obj, &key_obj, &value_obj) ;
#endif  /* KANJI */

#ifdef  DBG_1pp1
    printf("KANJI OK !\n") ;
#endif  /* DBG_1pp1 */

    /*
     * push userdict on dictstack
     */
    if (FRDICTCOUNT() < 1)
       ERROR(DICTSTACKOVERFLOW) ;
    else
       PUSH_DICT_OBJ(dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;
    ES_flag = PDL ;     /* Aug-08,91 YM */
#ifdef  DBG_1pp1
    printf("exit init_userdict()\n") ;
#endif  /* DBG_1pp1 */

    return ;
}   /* init_userdict */

/*
 *  init_errordict()
 *     initialize errordict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_errordict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(SYSTEMDICT, ERRORDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_errordict */


//DJC begin , new function init_psprivatedict
//
/*
 *  init_psprivatedict()
 *     initialize psprivatedict from the data in systemdict_table[]
 *     and save it in VM. This is used to initialize any postscript
 *     level objects required for PSTODIB that were not available
 *     in the original true image code. Currently we have only
 *     one new integer defined which tracks the current page type number
 *     so we can pass on the page size associated with the frame buffer
 *
 */
static  void  near
init_psprivatedict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, PSPRIVATEDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_errordict */



/*
 *  init_serverdict()
 *     initialize serverdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_serverdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, SERVERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 20) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_serverdict */

/*
 *  init_printerdict()
 *     initialize $printerdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_printerdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    struct object_def  FAR *l_proc ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;


    get_dict_value(USERDICT, PRINTERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;

        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * re_define "proc" to be a procedure (packedarray)
     */


    get_dict_value(PRINTERDICT, "proc", &l_proc) ;
    PUSH_ORIGLEVEL_OBJ(l_proc) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,1) ;

    op_array() ;
    op_astore() ;

    op_cvx() ;
    op_executeonly() ;
    put_dict_value(PRINTERDICT, "proc", GET_OPERAND(0)) ;
    POP(1) ;




    /*
     * re_initial $printerdict arrays
     */
    init_printerdictarray() ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_printerdict */

/*
 *  init_idletimedict()
 *     initialize $idleTimeDict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_idletimedict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, IDLETIMEDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;

    for ( ; j < (fix)(dict_count-1) ; j++) {            //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * re_initial $idleTimeDict arrays
     */
    init_idletimedictarray() ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_idletimedict */

/*
 *  init_execdict()
 *     initialize execdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_execdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, EXECDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_execdict */

/*
 *  init_Derrordict()
 *     initialize $errordict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_Derrordict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    struct object_def  FAR *l_curvm ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(SYSTEMDICT, DERROR, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /* initialize "/$cur_vm" array */
    for ( j = 0 ; j < 3 ; j++ )
        PUSH_VALUE(NULLTYPE,UNLIMITED,LITERAL,0, 0) ;

    /* create an array and load the initial values */
    get_dict_value(DERROR, "$cur_vm", &l_curvm) ;
    create_array(l_curvm, j) ;
    astore_array(l_curvm) ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_Derrordict */

/*
 *  init_printerdictarray()
 *     initialize following arrays in $printerdict:
 *     /printerarray, /letter, /lettersmall, /a4, /a4small,
 *     /b5, /legal, /note, /defaultmatrix, /matrix.
 */
static  void  near
init_printerdictarray()
{
    ufix16  l_i, l_j ;
    byte    FAR *l_name ;
    struct  object_def  l_paper ;
    struct  object_def  FAR *l_array, FAR *l_matrix, FAR *l_defmtx, FAR *l_prarray ;
    extern fix    near  resolution ;

    /* initialize "/printerarray" */
    for ( l_i = 0 ; l_i < PAPER_N ; l_i++ ) {
        l_name = (byte FAR *) pr_paper[l_i] ;
        ATTRIBUTE_SET(&l_paper, LITERAL) ;
        get_name(&l_paper, l_name, lstrlen(l_name), TRUE) ; /*@WIN*/
        PUSH_ORIGLEVEL_OBJ(&l_paper) ;

        /* initialize array for this paper size */
        for ( l_j = 0 ; l_j < 6 ; l_j++ )
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_arrays[l_i][l_j]) ;
        /* create an array and load the initial values */
        get_dict_value(PRINTERDICT, l_name, &l_array) ;
        create_array(l_array, l_j) ;
        astore_array(l_array) ;
    }

    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "printerarray", &l_prarray) ;
    create_array(l_prarray, l_i) ;
    astore_array(l_prarray) ;

    /* initialize "/matrix" array */
    for ( l_j = 0 ; l_j < 6 ; l_j++ )
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_mtx[l_j]) ;
    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;
    create_array(l_matrix, l_j) ;
    astore_array(l_matrix) ;

    /* initialize "/defaultmatrix array */
    l_j = 0 ;
    for (l_i = 0 ; l_i < 2 ; l_i++ ) {
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
        op_div() ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
    }

    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;
    create_array(l_defmtx, l_j) ;
    astore_array(l_defmtx) ;

    return ;
}   /* init_printerdictarray */

/*
 *  init_idletimedictarray()
 *     initialize following arrays in $idleTimeDict:
 *     /stdfontname, /cachearray, /defaultarray.
 */
static  void  near
init_idletimedictarray()
{
    ufix16  l_i, l_j ;
    byte    FAR *l_name ;
    struct  object_def  l_fontname ;
    struct  object_def  FAR *l_stdfontname, FAR *l_cstring, FAR *l_defarray, FAR *l_carray ;

    /* initialize "cachestring" */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cstring) ;
    create_string(l_cstring, (ufix16) lstrlen(CACHESTRING) ) ;  /*@WIN*/
    lstrcpy( (byte FAR *) VALUE(l_cstring), (char FAR *)CACHESTRING ) ; /*@WIN*/

    /* initialize "/stdfontname" */
    //DJC for ( l_i = 0; l_i < STD_FONT_N; l_i++ ) {
    //DJC for ( l_i = 0; l_i < MAX_INTERNAL_FONTS; l_i++ ) {
    for ( l_i = 0; l_i < sizeof(id_stdfont) / sizeof(id_stdfont[1]); l_i++ ) {
        l_name = (byte FAR *) id_stdfont[l_i] ;
        ATTRIBUTE_SET(&l_fontname, LITERAL) ;
        get_name(&l_fontname, l_name, lstrlen(l_name), TRUE) ;  /*@WIN*/
        PUSH_ORIGLEVEL_OBJ(&l_fontname) ;
    }

    /* create a packed array and load the initial values */
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfontname) ;
    create_array(l_stdfontname, l_i) ;
    astore_array(l_stdfontname) ;

    ATTRIBUTE_SET(l_stdfontname, EXECUTABLE) ;
    ACCESS_SET(l_stdfontname, READONLY) ;

    /* initialize "cachearray" & "defaultarray" */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cstring) ;
    for ( l_i = 0; l_i < IDL_FONT_N; l_i++ ) {
        /* push font#, scales, rotate */
        for ( l_j = 0 ; l_j < 4 ; l_j++ )
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,id_cachearray[l_i][l_j]) ;
        /* push cachestring */
        PUSH_ORIGLEVEL_OBJ(l_cstring) ;
        VALUE(GET_OPERAND(0)) = (ULONG_PTR)( (byte huge *)VALUE(l_cstring) +
                                          id_cachearray[l_i][l_j++] ) ;
        LENGTH(GET_OPERAND(0)) = id_cachearray[l_i][l_j] ;
    }

    /* create an array and load the initial values */
    get_dict_value(IDLETIMEDICT, "defaultarray", &l_defarray) ;
    get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
    create_array(l_defarray, (l_i * l_j)) ;
    astore_array(l_defarray) ;
    ACCESS_SET(l_defarray, READONLY) ;
    COPY_OBJ(l_defarray, l_carray) ;

    return ;
}   /* init_idletimedictarray */

/*
 * define some constants & strings in systemdict, userdict
 * and statusdict for release control
 */
static  void  near
init_release()
{
    struct  object_def      FAR *l_startpage;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(InitVersionDict),
        InitVersionDict) ;     /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during InitVersionDict initialization") ;
    POP(1) ;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(InitMsgDict),
        InitMsgDict) ;          /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during InitMsgDict initialization") ;
    POP(1) ;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(PSPrep),
        PSPrep) ;               /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during PSPrep initialization") ;
    POP(1) ;

    get_dict_value(USERDICT, "startpage", &l_startpage);

    // DJC change name of StartPage to avoid collision with Win API
    // VALUE(l_startpage) = (ufix32)StartPage;
    // LENGTH(l_startpage) = lstrlen(StartPage);   /*@WIN*/
    VALUE(l_startpage) = (ULONG_PTR)PSStartPage;
    LENGTH(l_startpage) = (ufix16)lstrlen(PSStartPage);   /*@WIN*/

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_release */

/*
 * pre_cache():
 */
static  void  near
pre_cache()
{
    struct  object_def  l_save, l_tmpobj ;
    struct  object_def  FAR *l_stdfont, FAR *l_cachestr, FAR *l_defmtx ;
    ufix16  l_i, l_j, l_k ;

    /* initialize object pointers */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cachestr) ;
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;

    /* create VM snapshot */
    op_save() ;
    COPY_OBJ(GET_OPERAND(0), &l_save) ;
    POP(1) ;

    /* set default matrix */
    PUSH_ORIGLEVEL_OBJ(l_defmtx) ;
    op_setmatrix() ;

    /* build pre-cache */
    op_gsave() ;
    l_j = 0 ;
    GEIio_write(GEIio_stdout, "\n", 1) ;
    for ( l_i = 0 ; l_i < PRE_CACHE_N ; l_i++ ) {
        op_grestore() ;
        op_gsave() ;

        /* set font */
        get_array(l_stdfont, pre_array[l_j++], &l_tmpobj) ;
        PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;

        GEIio_write(GEIio_stdout, "PreCache: ", 10) ;
        op_dup() ;
        one_equal_print() ;

        op_findfont() ;
        op_setfont() ;
        for (l_k=0 ; l_k<3 ; l_k++) {
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, pre_array[l_j++]) ;
        } /* for */

        GEIio_write(GEIio_stdout, ", Rotate= ", 10) ;
        op_dup() ;
        one_equal_print() ;

        op_rotate(1) ;

        GEIio_write(GEIio_stdout, ", Scale= ", 9) ;
        op_dup() ;
        one_equal_print() ;

        op_scale(2) ;

        GEIio_write(GEIio_stdout, ", Characters= ", 14) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, pre_array[l_j]) ;
        one_equal() ;
        op_flush() ;

        /* call op_stringwidth */
        getinterval_string(l_cachestr, 0, pre_array[l_j++], &l_tmpobj) ;
        PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
        op_stringwidth() ;
        POP(2) ;
    } /* for */

    GEIio_write(GEIio_stdout, "\n", 1) ;
    op_grestore() ;

#ifdef  DBG
    /* print out cachestatus */
    printf("\nCache Status = ") ;
    op_l_bracket() ;
    op_cachestatus() ;
    op_r_bracket() ;
    two_equal() ;
#endif  /* DBG */

    PUSH_ORIGLEVEL_OBJ(&l_save) ;
    op_restore() ;

#ifdef  DBG
    /* print out vmstatus */
    printf("\nVM Status = ") ;
    op_l_bracket() ;
    op_vmstatus() ;
    op_r_bracket() ;
    two_equal() ;
#endif  /* DBG */

#ifdef PCH_S
{
    bool        pack_cached_data();

    if (!pack_cached_data())
        printf("$$ PreCache ERROR!!!!!!\n");

    printf("TI pending!!!!!!\n");
    while(1);  /* forever */
}
#endif

    return ;
}   /* pre_cache */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\language.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              LANGUAGE.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#ifndef NULL
#define     NULL            0
#endif

#define     NULL_OBJ        0L
#define     MINUS_ONE       -1

#define     MARK            0
#define     LEFTMARK        MARK

/******************
 |  TIMER SET     |
 ******************/
#define     JOB_INDEX       0
#define     WAIT_INDEX      1
#define     MANU_INDEX      2
#define     JOB_MODE        0x01
#define     WAIT_MODE       0x02
#define     MANU_MODE       0x04
#define     ALL_MODE        0x07
#define     START_MODE      0x08

/**********************
 |  MACRO DEFINITION  |
 **********************/
#define     SPECIAL_KEY_VALUE\
            (MAXHASHSZ)

/* qqq, begin */
/*
#define     TYPE_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & TYPE_OFF) |\
              (var & TYPE_ON) )
#define     ATTRIBUTE_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ATTRIBUTE_OFF) |\
              ((ufix16)((var & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) )
#define     ROM_RAM_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ROM_RAM_OFF) |\
              ((var & ROM_RAM_ON) << ROM_RAM_BIT) )
#define     LEVEL_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & LEVEL_OFF) |\
              ((var & LEVEL_ON) << LEVEL_BIT) )
#define     ACCESS_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ACCESS_OFF) |\
              ((var & ACCESS_ON) << ACCESS_BIT) )

#define     TYPE_OP(idx)\
            ( opnstack[opnstktop - (idx+1)].bitfield & TYPE_ON )
#define     ATTRIBUTE_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ATTRIBUTE_BIT) & ATTRIBUTE_ON )
#define     ROM_RAM_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ROM_RAM_BIT) & ROM_RAM_ON )
#define     LEVEL_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> LEVEL_BIT) & LEVEL_ON )
#define     ACCESS_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ACCESS_BIT) & ACCESS_ON )

#define     VALUE_OP(n)\
            ( opnstack[opnstktop - (n + 1)].value )
#define     LENGTH_OP(n)\
            ( opnstack[opnstktop - (n + 1)].length )

#define     PUSH_NOLEVEL_OBJ(obj)\
            {\
              opnstack[opnstktop] = *(obj) ;\
              opnstktop++ ;\
            }
*/
#define     TYPE_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              (opnstkptr - (idx+1))->bitfield & TYPE_OFF) |\
              (var & TYPE_ON) )
#define     ATTRIBUTE_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ATTRIBUTE_OFF) |\
              ((ufix16)((var & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) )
#define     ROM_RAM_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ROM_RAM_OFF) |\
              ((var & ROM_RAM_ON) << ROM_RAM_BIT) )
#define     LEVEL_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & LEVEL_OFF) |\
              ((var & LEVEL_ON) << LEVEL_BIT) )
#define     ACCESS_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ACCESS_OFF) |\
              ((var & ACCESS_ON) << ACCESS_BIT) )

#define     TYPE_OP(idx)\
            ( (opnstkptr - (idx+1))->bitfield & TYPE_ON )
#define     ATTRIBUTE_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ATTRIBUTE_BIT) & ATTRIBUTE_ON )
#define     ROM_RAM_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ROM_RAM_BIT) & ROM_RAM_ON )
#define     LEVEL_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> LEVEL_BIT) & LEVEL_ON )
#define     ACCESS_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ACCESS_BIT) & ACCESS_ON )

#define     VALUE_OP(idx)\
            ( (opnstkptr - (idx+1))->value )
#define     LENGTH_OP(idx)\
            ( (opnstkptr - (idx+1))->length )

#define     PUSH_NOLEVEL_OBJ(obj)\
            {\
              COPY_OBJ(obj,opnstkptr);\
              INC_OPN_IDX();\
            }

#define     P1_TYPE_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & TYPE_OFF) | (con) )
#define     P1_ATTRIBUTE_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ATTRIBUTE_OFF) | (con) )
#define     P1_ROM_RAM_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ROM_RAM_OFF) | (con) )
#define     P1_LEVEL_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & LEVEL_OFF) | (con) )
#define     P1_ACCESS_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ACCESS_OFF) | (con) )

#define     P1_TYPE_OP(idx)\
            ( (opnstkptr - (idx+1))->bitfield & P1_TYPE_ON )
#define     P1_ATTRIBUTE_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ATTRIBUTE_ON )
#define     P1_ROM_RAM_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ROM_RAM_ON )
#define     P1_LEVEL_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_LEVEL_ON )
#define     P1_ACCESS_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ACCESS_ON )
/* qqq, end */

/************************
 |  PACKED_OBJECT SIZE  |
 ************************/
#define     PK_A_SIZE               1           /* 1-byte */
#define     PK_B_SIZE               2           /* 2-byte */
#define     PK_C_SIZE               5           /* 5-byte */
#define     PK_D_SIZE               9           /* 9-byte */
#define     _5BYTESPACKHDR          0xA0        /* 5 bytes objects */

#define     SYSOPERATOR             OPERATORPACKHDR             /* systemdict */

/******************************************
 |  PUBLIC FUNCTION DEFINITION: language  |
 ******************************************/
#ifdef LINT_ARGS
 /* OPERAND */
bool    create_new_saveobj(struct object_def FAR*) ;

 /* ARRAY */
bool    forall_array(struct object_def FAR*, struct object_def FAR*) ;

/* STRING */
bool    putinterval_string(struct object_def FAR*, ufix16, struct object_def FAR*) ;
bool    forall_string(struct object_def FAR*, struct object_def FAR*) ;

/* VM */
bool    save_obj(struct object_def FAR*) ;
void    update_same_link(fix16) ;

/* DICT */
bool    equal_key(struct object_def FAR *, struct object_def FAR *) ;
void    check_key_object(struct object_def FAR*) ;
void    change_dict_stack(void) ;

/* @WIN; move to global.ext and add FAR */
//char *ltoa(long,char *,int) ;
//char *gcvt(double,int,char *) ;

/* FILE */
void    vm_close_file(fix16) ;
#else
 /* OPERAND */
bool    create_new_saveobj() ;

 /* ARRAY */
bool    forall_array() ;

/* STRING */
bool    putinterval_string() ;
bool    forall_string() ;

/* VM */
bool    save_obj() ;
void    update_same_link() ;

/* DICT */
bool    equal_key() ;
void    check_key_object() ;
void    change_dict_stack() ;

char *ltoa() ;
char *gcvt() ;

/* FILE */
void    vm_close_file() ;
#endif /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\matherr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"
#include "matherr.h"
#include "stdio.h"      /* to define printf() @WIN */

/*
 * Floating point exception conditions and arithmetic error conditions.
 * This flag represents the most recent condtions. Caller must clear
 * this flag by calling matherr_handler(MEH_CLEAR) before executing the
 * arithmetic operation. Then check for status via matherr_handler(MEH_STATUS).
 */
static fix matherr_cond ;

/*
 * Process the matherr_cond flag.
 */
fix
matherr_handler(action)
char action ;
{
    switch (action) {
    case MEH_CLEAR:
        matherr_cond = 0 ;
        break ;

    case MEH_STATUS:
        return(0); /* Until we get this figured out */

    default:
        printf("Error: matherr_handler() unkown action %d.\n", action) ;
        printf("PDL interpreter error... exiting\n") ;
        while(1) ;
    }

    return(0);

}   /* matherr_handler */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\macprint\pstodib\ti\src\lang\init1pp.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              INIT1PP.H
 *      Author:                 CC Teng
 *      Date:                   11/21/89
 *      Owner:                  Microsoft Co.
 *      Description: this file was part of the old "global.def",
 *                   and it is only for statusdict and 1pp dicts
 *                   initialization in "user.c"
 * revision history: 2/12/90 ccteng move combine systemdict_table and
 *                      statusdict_table, then move them to dict_tab.c
 *      7/13/90 ; ccteng ; add PSPrep, delete some constant definitions
 *      7/21/90 ; ccteng ; 1)keep adding stuff in PSPrep which was in
 *                         dict_tab.c and init1pp.c
 *                       2)delete following serverdict stuff for server
 *                         change: se_stdin, STDIN_N, STDINNAME
 *      7/25/90 ; ccteng ; add startpage in serverdict (PSPrep)
 *      9/14/90 ; ccteng ; remove ALL_VM flag
 *      11/30/90  Danny  Add id_stdfont entries for 35 fonts (ref F35:)
 *      12/06/90  Danny  Change the precache & idle font array for lack
 *                       of font data -- Helvetica, Helvetica-Bold,
 *                       Times-Roman, Times-Bold.  (ref. FT19)
 *      12/17/90  Danny  CacheString is error by inserting a space (No this
 *                       error before the  12/06/90 release)
 *      03/27/91  Kason  Delete FT19 flag
 *      5/8/91    scchen Adjust page size(pr_arrays[])
 *      5/21/91   Kason  Add the option that can accept "TrueType PostScript
 *                       font Format" [ open (define) DLF42 flag ]
 ************************************************************************
 */
#define DLF42    /* feature for TrueType PostScript Font Format */
/*
 *  PSPrep
 */
#ifdef  _AM29K
const
#endif

#ifndef DLF42
byte FAR PSPrep[] = "\
systemdict begin\
/version{statusdict/versiondict get/Core get}bind def\
/=string 128 string def\
 end\
 statusdict begin\
/revision{statusdict/versiondict get/r_Core get}bind def\
/jobsource 64 string def\
/jobstate 64 string def\
/jobname 64 string def\
/manualfeed false def\
/eerom false def\
/printerstatus 8 def\
/lettertray{userdict/letter get exec}def\
/legaltray{userdict/legal get exec}def\
/a4tray{userdict/a4 get exec}def\
/b5tray{userdict/b5 get exec}def\
 end\
 userdict begin\
/startpage 0 string readonly def\
 end\
 printerdict begin\
/defspotfunc{abs exch abs 2 copy add 1 gt{1 sub dup mul exch 1 sub dup mul add\
 1 sub}{dup mul exch dup mul add 1 exch sub}ifelse}readonly def\
 end\
 serverdict begin\
/startpage{userdict/startpage get cvx exec showpage}readonly def\
 end" ;

#else /* set /type42known true in userdict */

byte FAR PSPrep[] = "\
systemdict begin\
/version{statusdict/versiondict get/Core get}bind def\
/=string 128 string def\
 end\
 statusdict begin\
/revision{statusdict/versiondict get/r_Core get}bind def\
/jobsource 64 string def\
/jobstate 64 string def\
/jobname 64 string def\
/manualfeed false def\
/eerom false def\
/printerstatus 8 def\
/lettertray{userdict/letter get exec}def\
/legaltray{userdict/legal get exec}def\
/a4tray{userdict/a4 get exec}def\
/b5tray{userdict/b5 get exec}def\
 end\
 userdict begin\
/startpage 0 string readonly def\
/type42known false def\
 end\
 printerdict begin\
/defspotfunc{abs exch abs 2 copy add 1 gt{1 sub dup mul exch 1 sub dup mul add\
 1 sub}{dup mul exch dup mul add 1 exch sub}ifelse}readonly def\
 end\
 serverdict begin\
/startpage{userdict/startpage get cvx exec showpage}readonly def\
 end" ;

#endif /*DLF42*/

/*
 ***********************************************************
