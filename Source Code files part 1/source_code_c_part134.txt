he DoS for another queue
                    SRV_DOS_COMPLETE_TEARDOWN();
                }

                RELEASE_DPC_SPIN_LOCK( &SrvDosSpinLock );
                RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
            }
            else
            {
                SRV_DOS_COMPLETE_TEARDOWN();
            }

            // Log the event if necessary
            if( LogEvent )
            {
                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_OUT_OF_WORK_ITEM_DOS,
                    STATUS_ACCESS_DENIED,
                    NULL,
                    0,
                    NULL,
                    0
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\info.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    info.c

Abstract:

    This module contains various routines for obtaining information such as
    times, dates, etc. that is to be returned by SMBs and for converting
    information that is given by request SMBs.

Author:

    David Treadwell (davidtr) 30-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "info.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_INFO

NTSTATUS
BruteForceRewind(
    IN HANDLE DirectoryHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileName,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PFILE_DIRECTORY_INFORMATION *CurrentEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCloseQueryDirectory )
#pragma alloc_text( PAGE, SrvQueryInformationFile )
#pragma alloc_text( PAGE, SrvQueryInformationFileAbbreviated )
#pragma alloc_text( PAGE, SrvQueryNtInformationFile )
#pragma alloc_text( PAGE, SrvQueryDirectoryFile )
#pragma alloc_text( PAGE, BruteForceRewind )
#pragma alloc_text( PAGE, SrvQueryEaFile )
#pragma alloc_text( PAGE, SrvTimeToDosTime )
#pragma alloc_text( PAGE, SrvDosTimeToTime )
#pragma alloc_text( PAGE, SrvGetOs2TimeZone )
#pragma alloc_text( PAGE, SrvQueryBasicAndStandardInformation )
#pragma alloc_text( PAGE, SrvQueryNetworkOpenInformation )
#pragma alloc_text( PAGE, SrvDownlevelTWarpQueryDirectoryFile )
#endif


VOID
SrvCloseQueryDirectory (
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation
    )

/*++

Routine Description:

    This routine cleans up after a directory search was aborted before
    SrvQueryDirectoryFile is done.  It closes the directory handle.

Arguments:

    DirectoryInformation - pointer to the buffer that is being used for
        SrvQueryDirectoryFile.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Close the directory handle.
    //

    if ( DirectoryInformation->DirectoryHandle != NULL &&
         !DirectoryInformation->DownlevelTimewarp ) {
        SRVDBG_RELEASE_HANDLE( DirectoryInformation->DirectoryHandle, "DID", 8, DirectoryInformation );
        SrvNtClose( DirectoryInformation->DirectoryHandle, TRUE );
    }

    DirectoryInformation->DirectoryHandle = NULL;

} // SrvCloseQueryDirectory



NTSTATUS
SrvQueryInformationFile (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    OUT PSRV_FILE_INFORMATION SrvFileInformation,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN QueryEaSize
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

    ShareType - The file type.  It will be disk, comm, print, pipe
                or (-1) for don't care.

    QueryEaSize - Try if EA size info is requested.

Return Value:

    A status indicating success or failure of the operation.

--*/

{
    SRV_NETWORK_OPEN_INFORMATION srvNetworkOpenInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Most query operations will fail on comm devices and print shares.
    // If this is a disk file, etc.  do the queries.  If it is a comm
    // device, fake it with defaults.
    //

    if ( ShareType != ShareTypePrint )
    {

        status = SrvQueryNetworkOpenInformation( FileHandle,
                                                 FileObject,
                                                 &srvNetworkOpenInformation,
                                                 QueryEaSize
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

    } else {
        //
        // Use defaults for comm and print shares.
        //

        RtlZeroMemory( &srvNetworkOpenInformation, sizeof( srvNetworkOpenInformation ) );
    }

    if ( ShareType == ShareTypePipe ) {

        FILE_PIPE_INFORMATION pipeInformation;
        IO_STATUS_BLOCK ioStatusBlock;
        USHORT pipeHandleState;

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;
    } else {

        SrvFileInformation->HandleState = 0;

    }


    //
    // Set up creation time fields.
    //

    {
        LARGE_INTEGER newTime;

        ExSystemTimeToLocalTime(
                        &srvNetworkOpenInformation.LastWriteTime,
                        &newTime
                        );


        //
        // Make sure we round up to two seconds.
        //

        newTime.QuadPart += AlmostTwoSeconds;

        if ( !RtlTimeToSecondsSince1970(
                &newTime,
                &SrvFileInformation->LastWriteTimeInSeconds
                ) ) {

            SrvFileInformation->LastWriteTimeInSeconds = 0;

        } else {

            //
            // Mask off the low bit so we can be consistent with LastWriteTime.
            // (We need to round up to 2 seconds)
            //

            SrvFileInformation->LastWriteTimeInSeconds &= ~1;
        }

    }

    SrvTimeToDosTime(
        &srvNetworkOpenInformation.LastWriteTime,
        &SrvFileInformation->LastWriteDate,
        &SrvFileInformation->LastWriteTime
        );

    if( srvNetworkOpenInformation.CreationTime.QuadPart == srvNetworkOpenInformation.LastWriteTime.QuadPart ) {
        SrvFileInformation->CreationDate = SrvFileInformation->LastWriteDate;
        SrvFileInformation->CreationTime = SrvFileInformation->LastWriteTime;
    } else {
        SrvTimeToDosTime(
            &srvNetworkOpenInformation.CreationTime,
            &SrvFileInformation->CreationDate,
            &SrvFileInformation->CreationTime
            );
    }

    if( srvNetworkOpenInformation.LastAccessTime.QuadPart == srvNetworkOpenInformation.LastWriteTime.QuadPart ) {
        SrvFileInformation->LastAccessDate = SrvFileInformation->LastWriteDate;
        SrvFileInformation->LastAccessTime = SrvFileInformation->LastWriteTime;

    } else {

        SrvTimeToDosTime(
            &srvNetworkOpenInformation.LastAccessTime,
            &SrvFileInformation->LastAccessDate,
            &SrvFileInformation->LastAccessTime
            );
    }

    //
    // Set File Attributes field of structure.
    //

    SRV_NT_ATTRIBUTES_TO_SMB(
        srvNetworkOpenInformation.FileAttributes,
        srvNetworkOpenInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
        &SrvFileInformation->Attributes
        );

    //
    // Set up allocation and data sizes.
    //
    // *** Note the assumption that the high part of the 64-bit
    //     allocation and EOF size is zero.  If it's not (i.e., the file
    //     is bigger than 4GB), then we're out of luck, because the SMB
    //     protocol can't express that.
    //

    SrvFileInformation->AllocationSize.QuadPart =
                            srvNetworkOpenInformation.AllocationSize.QuadPart;

    SrvFileInformation->DataSize.QuadPart =
                            srvNetworkOpenInformation.EndOfFile.QuadPart;


    //
    // Set the file device type.
    //

    switch( ShareType ) {

    case ShareTypeDisk:

        SrvFileInformation->Type = FileTypeDisk;
        break;

    case ShareTypePipe:

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    case ShareTypePrint:

        SrvFileInformation->Type = FileTypePrinter;
        break;

    default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    //
    // If the caller wants to know the length of the file's extended
    // attributes, obtain them now.
    //

    if ( QueryEaSize ) {

        //
        // If the file has no EAs, return an FEA size = 4 (that's what OS/2
        // does--it accounts for the size of the cbList field of an
        // FEALIST).
        //

        if ( srvNetworkOpenInformation.EaSize == 0 ) {
            SrvFileInformation->EaSize = 4;
        } else {
            SrvFileInformation->EaSize = srvNetworkOpenInformation.EaSize;
        }

    }

    return STATUS_SUCCESS;

} // SrvQueryInformationFile

NTSTATUS
SrvQueryInformationFileAbbreviated(
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    OUT PSRV_FILE_INFORMATION_ABBREVIATED SrvFileInformation,
    IN BOOLEAN AdditionalInfo,
    IN SHARE_TYPE ShareType
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

    ShareType - The file type.  It will be disk, comm, print, pipe
                or (-1) for don't care.

    QueryEaSize - Try if EA size info is requested.

Return Value:

    A status indicating success or failure of the operation.

--*/

{

    IO_STATUS_BLOCK ioStatusBlock;
    SRV_NETWORK_OPEN_INFORMATION srvNetworkOpenInformation;
    NTSTATUS status;
    LARGE_INTEGER newTime;

    PAGED_CODE( );

    //
    // Most query operations will fail on comm devices and print shares.
    // If this is a disk file, etc.  do the queries.  If it is a comm
    // device, fake it with defaults.
    //

    if ( ShareType != ShareTypePrint ) {

        status = SrvQueryNetworkOpenInformation(
                                                FileHandle,
                                                FileObject,
                                                &srvNetworkOpenInformation,
                                                FALSE
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

    } else {

        //
        // Use defaults for comm and print shares.
        //

        RtlZeroMemory( &srvNetworkOpenInformation, sizeof( srvNetworkOpenInformation ) );
    }

    //
    // Set up creation time fields.
    //
    ExSystemTimeToLocalTime(
                    &srvNetworkOpenInformation.LastWriteTime,
                    &newTime
                    );

    //
    // Make sure we round up to two seconds.
    //

    newTime.QuadPart += AlmostTwoSeconds;

    if ( !RtlTimeToSecondsSince1970(
            &newTime,
            &SrvFileInformation->LastWriteTimeInSeconds
            ) ) {

        SrvFileInformation->LastWriteTimeInSeconds = 0;

    } else {

        //
        // Mask off the low bit so we can be consistent with LastWriteTime.
        // (We need to round up to 2 seconds)
            //

            SrvFileInformation->LastWriteTimeInSeconds &= ~1;
        }

        //
        // Set File Attributes field of structure.
        //

        SRV_NT_ATTRIBUTES_TO_SMB(
            srvNetworkOpenInformation.FileAttributes,
            srvNetworkOpenInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &SrvFileInformation->Attributes
            );

        SrvFileInformation->DataSize.QuadPart =
                            srvNetworkOpenInformation.EndOfFile.QuadPart;

        //
        // Set the file device type.
        //

        switch( ShareType ) {

        case ShareTypeDisk: {

            SrvFileInformation->Type = FileTypeDisk;
            SrvFileInformation->HandleState = 0;

            if( AdditionalInfo ) {

                union {
                    FILE_EA_INFORMATION eaInformation;
                    FILE_STREAM_INFORMATION streamInformation;
                    FILE_ATTRIBUTE_TAG_INFORMATION tagInformation;
                    ULONG buffer[ (sizeof( FILE_STREAM_INFORMATION ) + 14) / sizeof(ULONG) ];
                } u;

                //
                // Find out if this file has EAs
                //
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.eaInformation,
                            sizeof( u.eaInformation ),
                            FileEaInformation
                         );

                if( !NT_SUCCESS( status ) || u.eaInformation.EaSize == 0 ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_EAS;
                }

                //
                // Find out if this file has substreams.
                //
                RtlZeroMemory( &u, sizeof(u) );
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.streamInformation,
                            sizeof( u.streamInformation ),
                            FileStreamInformation
                        );


                //
                // If the filesystem does not support this call, then there are no substreams.  Or
                //  If the filesystem supports the call but returned exactly no name or returned "::$DATA"
                //  then there are no substreams.
                //
                if( status == STATUS_INVALID_PARAMETER ||
                    status == STATUS_NOT_IMPLEMENTED ||

                    (status == STATUS_SUCCESS &&
                      (u.streamInformation.StreamNameLength == 0 ||
                      (u.streamInformation.StreamNameLength == 14 ))
                    )

                  ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_SUBSTREAMS;
                }

                //
                // Find out if this file is a reparse point
                //
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.tagInformation,
                            sizeof( u.tagInformation ),
                            FileAttributeTagInformation
                        );

                if( !NT_SUCCESS( status ) ||
                    u.tagInformation.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_REPARSETAG;
                }
            }
            break;

        } case ShareTypePipe: {

            FILE_PIPE_INFORMATION pipeInformation;
            FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
        USHORT pipeHandleState;

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    } case ShareTypePrint: {

        SrvFileInformation->Type = FileTypePrinter;
        break;

    } default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    return STATUS_SUCCESS;

} // SrvQueryInformationFileAbbreviated

NTSTATUS
SrvQueryNtInformationFile (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN AdditionalInfo,
    IN OUT PSRV_NT_FILE_INFORMATION SrvFileInformation
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

Return Value:

    A status indicating success or failure of the operation.

--*/

{

    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    USHORT pipeHandleState;
    NTSTATUS status;

    PAGED_CODE( );

    status = SrvQueryNetworkOpenInformation( FileHandle,
                                             FileObject,
                                             &SrvFileInformation->NwOpenInfo,
                                             FALSE
                                             );

    if ( !NT_SUCCESS(status) ) {
        if ( ShareType != ShareTypePipe ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryNtInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        }
        return status;
    }

    if ( ShareType == ShareTypePipe ) {

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvNtQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvNtQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;
    } else {

        SrvFileInformation->HandleState = 0;
        if( AdditionalInfo ) {

            //
            // the buffer is added to the end to ensure that we have enough space on the
            // stack to return a FILE_STREAM_INFORMATION buffer having the ::$DATA substream
            union {
                FILE_EA_INFORMATION eaInformation;
                FILE_STREAM_INFORMATION streamInformation;
                FILE_ATTRIBUTE_TAG_INFORMATION tagInformation;
                ULONG buffer[ (sizeof( FILE_STREAM_INFORMATION ) + 14) / sizeof(ULONG) ];
            } u;

            //
            // Find out if this file has EAs
            //
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.eaInformation,
                        sizeof( u.eaInformation ),
                        FileEaInformation
                     );
            if( !NT_SUCCESS( status ) || u.eaInformation.EaSize == 0 ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_EAS;
            }

            //
            // Find out if this file has substreams.
            //
            RtlZeroMemory( &u, sizeof(u) );
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.streamInformation,
                        sizeof( u ),
                        FileStreamInformation
                    );

            //
            // If the filesystem does not support this call, then there are no substreams.  Or
            //  If the filesystem supports the call but returned exactly no name or returned "::$DATA"
            //  then there are no substreams.
            //
            if( status == STATUS_INVALID_PARAMETER ||
                status == STATUS_NOT_IMPLEMENTED ||

                (status == STATUS_SUCCESS &&
                  (u.streamInformation.StreamNameLength == 0 ||
                  (u.streamInformation.StreamNameLength == 14 ))
                )

              ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_SUBSTREAMS;
            }

            //
            // Find out if this file is a reparse point
            //
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.tagInformation,
                        sizeof( u.tagInformation ),
                        FileAttributeTagInformation
                    );

            if( !NT_SUCCESS( status ) ||
                u.tagInformation.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_REPARSETAG;
            }
        }

    }

    //
    // Set the file device type.
    //

    switch( ShareType ) {

    case ShareTypeDisk:

        SrvFileInformation->Type = FileTypeDisk;
        break;

    case ShareTypePipe:

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    case ShareTypePrint:

        SrvFileInformation->Type = FileTypePrinter;
        break;

    default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    return STATUS_SUCCESS;

} // SrvQueryNtInformationFile


NTSTATUS
SrvQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    )

/*++

Routine Description:

    This routine acts as a wrapper for NT LanMan server access to
    NtQueryDirectoryFile.  It allows server routines to obtain information
    about the files in a directory using the kind of information
    passed in an SMB.  This localizes the code for this operation and
    simplifies the writing of SMB processing routines that use wildcards.

    The calling routine is responsible for setting up a quadword-aligned
    buffer in nonpaged pool that may be used by this routine.  A pointer
    to the buffer and the buffer length are passed in as parameters.
    The buffer must be allocated from nonpaged pool because one of
    the things it is used for is as a buffer for NtQueryDirectoryFile,
    a buffered-IO request.  The buffer is also used to hold information
    needed by this routine, such as a handle to the directory in which
    the search is being performed, a pointer to the
    FILE_DIRECTORY_INFORMATION structure that was last returned, and the
    basename (with wildcards) that we're using as a search key.  Since
    all this information must remain valid across calls to this routine,
    the calling routine must ensure that the buffer remains intact until
    this routine returns an unsuccessful status or STATUS_NO_MORE_FILES,
    or SrvCloseQueryDirectory is called.

    SMB processing routines which do not need to make use of the Buffer
    field of the outgoing SMB may use this as a buffer for this routine,
    remembering to leave any pathname information in the buffer field of the
    incoming SMB intact by starting the buffer after the pathname.  SMB
    processing routines that write into the Buffer field of the outgoing SMB,
    such as Search and Find, must allocate space for the buffer from nonpaged
    pool.  The size of the buffer should be approximately 4k.  Smaller
    buffers will work, but more slowly due to the need for more calls
    to NtQueryDirectoryFile.  The minimum buffer size is equal to:

        sizeof(SRV_DIRECTORY_INFORMATION) +
        sizeof(SRV_QUERY_DIRECTORY_INFORMATION) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR) +
        sizeof(UNICODE_STRING) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)

    This ensures that NtQueryDirectoryFile will be able to put at least
    one entry in the buffer.

    On the first call to this routine, it fills up its buffer with
    information from NtQueryDirectoryFile and passes back the name of
    a single file that conforms to the specified name and search
    attributes.  On subsequent calls, the names stored in the buffer are
    used until there are no more files in the directory or another
    call to NtQueryDirectoryFile is needed to again fill the buffer.

    Whenever the caller is done with the search, it must call
    SrvCloseQueryDirectory.  This is required even if this routine
    returns an error.

Arguments:

    WorkContext - pointer to a work context block for the operation.  The
        TreeConnect, Session, and RequestHeader fields are used, and the
        pointer is passed to the SMB error handling function if necessary.

    IsFirstCall - a boolean indicating whether this is the first time
        the calling routine is calling this function.  If it is, then
        the directory for the search is opened and other setup
        operations take place.

    FilterLongNames - a boolean that is TRUE when non-FAT names should be
        filtered out (not returned).  If FALSE, return all filenames,
        regardless of whether or not they could be FAT 8.3 names.

    FindWithBackupIntent - Whether the directory was opened by the use
        for backup intent.

    FileInformationClass - the type of file structures to return.  This
        field can be one of FileDirectoryInformation,
        FileFullDirectoryInformation, FileOleDirectoryInformation, or
        FileBothDirectoryInformation.

    FilePathName - a pointer to a string describing the file path name
        to do directory searches on.  This path is relative to the
        PathName specified in the share block.  This parameter is only
        used on the first call to this routine; subsequent calls ignore it.

    ResumeFileIndex - an optional pointer to a file index which determines
        the file with which to restart the search.  NULL if the search
        should be restarted from the last file returned.

    SmbSearchAttributes - the atttibutes, in SMB format, that files must
        have in order to be found.  The search is inclusive, meaning that
        if several attributes are specified, files having those attributes
        will be found, in addition to normal files.

    DirectoryInformation - a pointer to the buffer to be used by this
        routine to do its work.  This buffer must be quadword-aligned.

    BufferLength - the length of the buffer passed to this routine.

Return Value:

    A status indicating success or failure of the operation, or
    STATUS_NO_MORE_FILES if the files in the directory that match the
    specified parameters have been exausted.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_DIRECTORY_INFORMATION *currentEntry;
    ULONG inclusiveSearchAttributes;
    ULONG exclusiveSearchAttributes;
    ULONG currentAttributes;
    BOOLEAN returnDirectories;
    BOOLEAN returnDirectoriesOnly;
    BOOLEAN calledQueryDirectory = FALSE;

    OBJECT_ATTRIBUTES objectAttributes;
    PUNICODE_STRING filePathName;
    BOOLEAN FreePathName = FALSE;
    UNICODE_STRING objectNameString;
    UNICODE_STRING baseFileName;
    PSHARE fileShare = NULL;

    PUNICODE_STRING resumeName = NULL;
    BOOLEAN resumeSearch;

    CLONG fileNameOffset;
    ULONG createOptions;

    PAGED_CODE( );

    ASSERT( ( FileInformationClass == FileDirectoryInformation ) ||
            ( FileInformationClass == FileFullDirectoryInformation ) ||
            ( FileInformationClass == FileBothDirectoryInformation ) ||
            ( FileInformationClass == FileIdFullDirectoryInformation ) ||
            ( FileInformationClass == FileIdBothDirectoryInformation ) );

    //
    // Set up the offsets to the fields in FILE_FULL_DIR_INFORMATION in
    // a different place than corresponding fields in
    // FILE_DIRECTORY_INFORMATION.  These allow this routine to
    // efficiently use either structure.
    //

    {
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileNameLength ) );
    }

    if ( FileInformationClass == FileFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileIdBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileIdFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, FileName[0] );
    } else {
        fileNameOffset =
            FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName[0] );
    }

    //
    // This macro is used to actually get at the FileName field.  Note
    // that it depends on a local variable.
    //

#define FILE_NAME(a) (PWCH)( (PCHAR)(a) + fileNameOffset )

    //
    // If this is the first call to this routine, we must open the
    // correct directory, thereby obtaining a handle to it to pass to
    // NtQueryDirectoryFile.  The calling routine stores the handle
    // to prevent problems if SrvQueryDirectoryFile is called more
    // than once simultaneously.
    //

    if ( IsFirstCall ) {

        BOOLEAN endsInDot;
        ULONG attributes;

        DirectoryInformation->DirectoryHandle = 0L;
        DirectoryInformation->DownlevelTimewarp = FALSE;
        DirectoryInformation->ErrorOnFileOpen = FALSE;
        DirectoryInformation->OnlySingleEntries = FALSE;

        //
        // We must get the appropriate directory name in which to perform the
        // search.  First, find the basename of the file from the FilePathName.
        //
        // Find out whether there are wildcards in the file name we are
        // searching for.  This information will be used later to
        // know whether we should try to get more files if the buffer
        // is empty--if there were no wildcards and we have emptied the
        // buffer, then we know that we have already returned the one and
        // only file that could be found, so return STATUS_NO_MORE_FILES.
        //

        SrvGetBaseFileName( FilePathName, &baseFileName );
        DirectoryInformation->Wildcards =
                        FsRtlDoesNameContainWildCards( &baseFileName );

        if ( DirectoryInformation->Wildcards &&
             (!IS_NT_DIALECT(WorkContext->Connection->SmbDialect) ) ) {

            //
            // Bogus code to workaround ~* problem
            //

            if ( baseFileName.Buffer[(baseFileName.Length>>1)-1] == (WCHAR)'.' ) {
                endsInDot = TRUE;
                baseFileName.Length -= sizeof( WCHAR );
            } else {
                endsInDot = FALSE;
            }

            //
            // Convert the file name to the new form expected by the file
            // systems.  Special case *.* to * since it is so common.  Otherwise
            // transmogrify the input name according to the following rules:
            //
            // - Change all ? to DOS_QM
            // - Change all . followed by ? or * to DOS_DOT
            // - Change all * followed by a . into DOS_STAR
            //
            // These transmogrifications are all done in place.
            //

            if ( (baseFileName.Length == 6) &&
                 (RtlEqualMemory(baseFileName.Buffer, StrStarDotStar, 6) ) ) {

                baseFileName.Length = 2;

            } else {

                ULONG index;
                WCHAR *nameChar;

                for ( index = 0, nameChar = baseFileName.Buffer;
                      index < baseFileName.Length/sizeof(WCHAR);
                      index += 1, nameChar += 1) {

                    if (index && (*nameChar == L'.') && (*(nameChar - 1) == L'*')) {

                        *(nameChar - 1) = DOS_STAR;
                    }

                    if ((*nameChar == L'?') || (*nameChar == L'*')) {

                        if (*nameChar == L'?') {
                            *nameChar = DOS_QM;
                        }

                        if (index && *(nameChar-1) == L'.') {
                            *(nameChar-1) = DOS_DOT;
                        }
                    }
                }

                if ( endsInDot && *(nameChar - 1) == L'*' ) {
                    *(nameChar-1) = DOS_STAR;
                }
            }
        }

        //
        // Set up the object attributes structure for SrvIoCreateFile.
        //

        objectNameString.Buffer = FilePathName->Buffer;
        objectNameString.Length = SrvGetSubdirectoryLength( FilePathName );
        objectNameString.MaximumLength = objectNameString.Length;

        //
        // !!! If the object system supported relative opens with name
        //     length = 0, this wouldn't be necessary.  Take it out when
        //     the object system is done.
        //


        if ( objectNameString.Length == 0 ) {

            //
            // Since we are opening the root directory, set the attribute
            // to case insensitive since this is how we opened the share
            // point when it was added.
            //

            PSHARE share = WorkContext->TreeConnect->Share;

            status = SrvSnapGetNameString( WorkContext, &filePathName, &FreePathName );
            if( !NT_SUCCESS(status) )
            {
                return status;
            }
            objectNameString = *filePathName;

            DirectoryInformation->Wildcards = TRUE;
            attributes = OBJ_CASE_INSENSITIVE;

        } else {

            fileShare = WorkContext->TreeConnect->Share;
            attributes =
                (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                WorkContext->Session->UsingUppercasePaths) ?
                OBJ_CASE_INSENSITIVE : 0L;

        }

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &objectNameString,
            attributes,
            NULL,
            NULL
            );

        IF_DEBUG(SEARCH) {
            SrvPrint1( "Opening directory name: %wZ\n", &objectNameString );
        }

        //
        // Attempt to open the directory, using the client's security
        // profile to check access.  (We call SrvIoCreateFile, rather than
        // NtOpenFile, in order to get user-mode access checking.)
        //
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );
        //
        // There's no need to specify FILE_DIRECTORY_FILE; the file systems
        // will open whatever is there and reject later QueryDirectoryFile
        // when the object opened does not support enumeration.
        //

        createOptions = 0;
        if (FindWithBackupIntent) {
            createOptions = FILE_OPEN_FOR_BACKUP_INTENT;
        }

        status = SrvIoCreateFile(
                     WorkContext,
                     &DirectoryInformation->DirectoryHandle,
                     FILE_LIST_DIRECTORY,                   // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,                             // Disposition
                     createOptions,                         // CreateOptions
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     fileShare
                     );

        //
        // If the user didn't have this permission, update the statistics
        // database.
        //

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        // Free the path since we won't use it anymore
        if( FreePathName )
        {
            FREE_HEAP( filePathName );
            filePathName = NULL;
        }

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint2( "SrvQueryDirectoryFile: SrvIoCreateFile for dir %wZ "
                          "failed: %X\n",
                              &objectNameString, status );
            }
            DirectoryInformation->DirectoryHandle = NULL;
            return status;
        }

        SRVDBG_CLAIM_HANDLE( DirectoryInformation->DirectoryHandle, "DID", 3, DirectoryInformation );
        SrvStatistics.TotalFilesOpened++;

        IF_DEBUG(SEARCH) {
            SrvPrint1( "SrvIoCreateFile succeeded, handle = %p\n",
                          DirectoryInformation->DirectoryHandle );
        }

        //
        // Set up the currentEntry pointer.  This is a pointer to the
        // location where the FILE_DIRECTORY_INFORMATION pointer is
        // stored.  It is not really necessary--
        // DirectoryInformation->CurrentEntry could be substituted for
        // every occurrance of *currentEntry.  Using currentEntry makes
        // the code more compact and simpler.
        //

        currentEntry = &(DirectoryInformation->CurrentEntry);
        *currentEntry = NULL;

        //
        // Store the length of buffer space remaining--this is where IO
        // request information will be stored.
        //

        DirectoryInformation->BufferLength = BufferLength -
                                            sizeof(SRV_DIRECTORY_INFORMATION);

        IF_DEBUG(SEARCH) {
            SrvPrint3( "In BufferLength: %ld, sizeof(): %ld, ->BufferLength: "
                          "%ld\n", BufferLength,
                          sizeof(SRV_DIRECTORY_INFORMATION),
                          DirectoryInformation->BufferLength );
        }

    } else {

        //
        // This is not the first call to this routine, so just set up
        // the currentEntry pointer and have it point to the next entry
        // in the buffer.  If there are no more entries in the buffer at
        // this time (NextEntryOffset == 0), set the currentEntry
        // pointer to NULL so that we will know to get more later.
        //

        currentEntry = &DirectoryInformation->CurrentEntry;

        if ( *currentEntry != NULL ) {

            if ( (*currentEntry)->NextEntryOffset == 0 ) {

                *currentEntry = NULL;

            } else {

                *currentEntry = (PFILE_DIRECTORY_INFORMATION)
                   ( (PCHAR)*currentEntry + (*currentEntry)->NextEntryOffset );
            }
        }
    }

    //
    // The lower byte of SmbSearchAttributes defines "inclusive"
    // search attribute bits, meaning that if the bit is on on the
    // file but not set in the request, the file should be skipped.
    // For example, if HIDDEN is not specified in the request, then
    // files with the HIDDEN bit turned on are not returned.
    //
    // The upper byte of SmbSearchAttributes, as an LM2.1 extension,
    // defines "exclusive" search attributes, which means that a
    // file must have the specified bits set in order to be returned.
    // For example, if the READONLY bit is set in the request, only
    // files with the READONLY bit turned on will be returned to the
    // client.
    //
    // Convert the inclusive and exclusive search bits to NT format.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        (USHORT)(SmbSearchAttributes & 0xFF),
        &returnDirectories,
        &inclusiveSearchAttributes
        );

    SRV_SMB_ATTRIBUTES_TO_NT(
        (USHORT)(SmbSearchAttributes >> 8),
        &returnDirectoriesOnly,
        &exclusiveSearchAttributes
        );

    //
    // For the inclusive bits, files with the NORMAL, ARCHIVE, or READONLY
    // bits set should be returned regardless of whether these bits
    // were set in SmbSearchAttributes.
    //

    inclusiveSearchAttributes |= FILE_ATTRIBUTE_NORMAL |
                                     FILE_ATTRIBUTE_ARCHIVE |
                                     FILE_ATTRIBUTE_READONLY;

    //
    // For exclusive bits, the VOLUME bit is meaningless.  It is also not
    // necessary for a file to have the NORMAL bit on, since the NORMAL
    // bit is not defined for the SMB protocol.
    //

    exclusiveSearchAttributes &=
        ~(SMB_FILE_ATTRIBUTE_VOLUME | FILE_ATTRIBUTE_NORMAL);

    //
    // If a resume file index was passed in, this search is a resumption
    // from that file and the name specified in FilePathName.
    //

    if ( ARGUMENT_PRESENT( ResumeFileIndex ) ) {

        resumeSearch = TRUE;
        resumeName = FilePathName;

        IF_DEBUG(SEARCH) {
            SrvPrint3( "Resuming search at file %wZ, length %ld, index %lx\n",
                          resumeName, resumeName->Length,
                          *ResumeFileIndex );
        }

    } else {

        resumeSearch = FALSE;
    }

    //
    // Now we need to find a file to return.  We keep going until we find
    // a file that meets all of our criteria, pointing to the next file
    // if a file fails.  We continue the loop under the following conditions:
    //
    // 1) If *currentEntry == NULL, then we haven't yet filled our buffer
    //    with entries, so get some entries.
    //
    // 2) If there are bits set in the FileAttributes field of the
    //    FILE_DIRECTORY_INFORMATION field that are not set in the
    //    searchAttributes variable, then the file does not meet the
    //    search requirements, and we need to continue looking.
    //
    // 3) If we are not searching for directories and the file is actually
    //    a directory, skip over it.
    //
    // 4) If we are filtering long (non-FAT) filenames AND this file name
    //    is not a legal FAT name AND we have no short name for this file,
    //    skip it.
    //
    // 5) If the file doesn't have attribute bits specified as exclusive
    //    bits, skip it.
    //
    // 6) If the file is not a directory and we're only supposed to return
    //    directories, skip it.
    //
    // When this loop is complete, *currentEntry will point to the
    // FILE_DIRECTORY_INFORMATION structure corresponding to the file we
    // will return.  If no qualifying files are found, return
    // STATUS_NO_MORE_FILES and close the directory.
    //

    if( *currentEntry != NULL ) {
        SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
    }

    while ( ( *currentEntry == NULL )                                   // 1

            ||

            ( (currentAttributes | inclusiveSearchAttributes) !=        // 2
                inclusiveSearchAttributes )

            ||

            ( !returnDirectories &&                                     // 3
              (currentAttributes & FILE_ATTRIBUTE_DIRECTORY))

            ||
                                                                        // 4
            ( FilterLongNames &&
              !SrvIsLegalFatName( FILE_NAME( *currentEntry ),
                                  (*currentEntry)->FileNameLength) &&
              !( FileInformationClass == FileBothDirectoryInformation &&
                 ((PFILE_BOTH_DIR_INFORMATION)*currentEntry)->
                                                        ShortNameLength != 0) )


            ||
                                                                        // 5
            ( (currentAttributes | exclusiveSearchAttributes) !=
                currentAttributes )

            ||

            ( returnDirectoriesOnly &&                                  // 6
              !(currentAttributes & FILE_ATTRIBUTE_DIRECTORY) )

          ) {

        IF_DEBUG(SEARCH) {
            if ( *currentEntry != NULL) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint4( "Skipped %wZ, FileAttr: %lx, ISA: %lx ESA: %lx ",
                            &name, (*currentEntry)->FileAttributes,
                            inclusiveSearchAttributes,
                            exclusiveSearchAttributes );
                SrvPrint4( "NL=%ld D=%ld RD=%ld RDO=%ld ",
                            (*currentEntry)->FileNameLength,
                            (((*currentEntry)->FileAttributes &
                            FILE_ATTRIBUTE_DIRECTORY) != 0), returnDirectories,
                            returnDirectoriesOnly );
                SrvPrint1( "FLN=%ld\n", FilterLongNames );
            }
        }

        //
        // We need to look for more files under the following conditions:
        //
        //    o we have yet to fill the buffer with entries;
        //
        //    o the NextEntryOffset is zero, indicating that the files in
        //      the buffer have been exausted.
        //

        if ( *currentEntry == NULL ||
             (*currentEntry)->NextEntryOffset == 0 ) {

            PUNICODE_STRING actualString;
            BOOLEAN bruteForceRewind = FALSE;

            //
            // The buffer has no more valid entries in it.  If no
            // wildcards were specified in the file name to search on,
            // then we have already returned the single file and we
            // should just stop now.  Otherwise, we go get more entries.
            //

            if ( !DirectoryInformation->Wildcards &&
                 ( !IsFirstCall || calledQueryDirectory ) ) {

                if ( calledQueryDirectory ) {
                    return STATUS_NO_SUCH_FILE;
                } else {
                    return STATUS_NO_MORE_FILES;
                }
            }

            //
            // Set up the file name that will be passed to
            // SrvIssueQueryDirectoryRequest.  If this is the first
            // call, then pass the file spec given by the user.  If this
            // is a resume search and we haven't yet done a directory
            // query, then use the resume file name and index.
            // Otherwise, pass NULL for these and the file system will
            // continue from where it left off after the last directory
            // query.
            //

            if ( IsFirstCall &&
                 !calledQueryDirectory &&
                 baseFileName.Length != 0 ) {

                actualString = &baseFileName;

            } else if ( resumeSearch && !calledQueryDirectory ) {

                actualString = resumeName;

            } else {

                actualString = NULL;
                ResumeFileIndex = NULL;

            }

            IF_DEBUG(SEARCH) {

                if ( actualString == NULL ) {
                    SrvPrint0( "**** CALLING NTQUERYDIRECTORYFILE, file = NULL, length: 0\n" );
                } else {
                    SrvPrint2( "**** CALLING NTQUERYDIRECTORYFILE, file = %wZ, length: %ld\n",
                                actualString, actualString->Length );
                }

                SrvPrint0( "Reason:  \n" );

                if ( *currentEntry == NULL ) {
                    SrvPrint0( "*currentEntry == NULL\n" );
                } else {
                    SrvPrint1( "(*currentEntry)->NextEntryOffset == %ld\n",
                               (*currentEntry)->NextEntryOffset );
                }
            }

            //
            // Do the directory query operation using a directly-built
            // IRP.  Doing this rather than calling NtQueryDirectoryFile
            // eliminates a buffered I/O copy of the directory
            // information and allows use of a kernel event object.  If
            // this is the first call to NtQueryDirectoryFile, pass it
            // the search file name.  If this is a rewind or resume of a
            // prior search, pass the resume file name and index.
            //
            // The query is performed synchronously, which may be a
            // detriment to performance.  However, it may be the case
            // that routines calling SrvQueryDirectoryFile want to
            // exploit the asynchronous capabilities of the IO system,
            // so keeping this routine synchronous significantly
            // simplifies their job.
            //

            status = SrvIssueQueryDirectoryRequest(
                         DirectoryInformation->DirectoryHandle,
                         (PCHAR)DirectoryInformation->Buffer,
                         DirectoryInformation->BufferLength,
                         FileInformationClass,
                         actualString,
                         ResumeFileIndex,
                         FALSE,
                         DirectoryInformation->OnlySingleEntries
                         );

            calledQueryDirectory = TRUE;

            //
            // If the file system cannot support the rewind request,
            // do a brute force rewind (restart search at beginning
            // of directory).
            //
            // This check is before the check for STATUS_NO_MORE_FILES
            // in case there are no files after the resume file.
            //

            if ( status == STATUS_NOT_IMPLEMENTED ) {

                IF_DEBUG(SEARCH) {
                    SrvPrint0( "Doing brute force rewind!!\n" );
                }

                bruteForceRewind = TRUE;
                DirectoryInformation->OnlySingleEntries = TRUE;

                status = BruteForceRewind(
                             DirectoryInformation->DirectoryHandle,
                             (PCHAR)DirectoryInformation->Buffer,
                             DirectoryInformation->BufferLength,
                             actualString,
                             FileInformationClass,
                             currentEntry
                             );

                //
                //  If BruteForceRewind fails with STATUS_NOT_IMPLEMENTED, it
                //  means that the client requested a rewind from a
                //  non-existant file.   The only time this happens in when
                //  an OS/2 is deleting many files in a directory.  To cope
                //  simple rewind the search to the beginning of the
                //  directory.
                //

                if ( status == STATUS_NOT_IMPLEMENTED ) {

                    bruteForceRewind = FALSE;
                    DirectoryInformation->OnlySingleEntries = FALSE;

                    status = SrvIssueQueryDirectoryRequest(
                                 DirectoryInformation->DirectoryHandle,
                                 (PCHAR)DirectoryInformation->Buffer,
                                 DirectoryInformation->BufferLength,
                                 FileInformationClass,
                                 actualString,
                                 ResumeFileIndex,
                                 TRUE,
                                 FALSE
                                 );
                }
            }

            //
            // If there are no more files to be gotten, then stop.
            //

            if ( status == STATUS_NO_MORE_FILES ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint0( "SrvQueryDirectoryFile: No more files.\n" );
                }
                return status;
            }

            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint1( "SrvQueryDirectoryFile: NtQueryDirectoryFile "
                                 "failed: %X.\n", status );
                }
                return status;
            }

            IF_DEBUG(SEARCH) {
                SrvPrint1( "NtQueryDirectoryFile succeeded: %X\n", status );
            }

            //
            // If there wasn't a brute force rewind, which would have
            // set up the CurrentEntry pointer, Set up CurrentEntry
            // pointer to point to the first entry in the buffer.
            //

            if ( !bruteForceRewind ) {
                *currentEntry =
                    (PFILE_DIRECTORY_INFORMATION)DirectoryInformation->Buffer;
            } else {
                bruteForceRewind = FALSE;
            }

            IF_DEBUG(SEARCH) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint2( "First file name is %wZ, length = %ld\n",
                            &name, (*currentEntry)->FileNameLength );
            }

        } else {

            //
            // The file described by the FILE_DIRECTORY_INFORMATION pointed
            // to by *currentEntry does not meet our requirements, so
            // point to the next file in the buffer.
            //

            *currentEntry = (PFILE_DIRECTORY_INFORMATION)( (PCHAR)*currentEntry
                            + (*currentEntry)->NextEntryOffset );
        }

        if( *currentEntry != NULL ) {
            SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
        }
    }

    return STATUS_SUCCESS;

} // SrvQueryDirectoryFile


STATIC
NTSTATUS
BruteForceRewind(
    IN HANDLE DirectoryHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileName,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PFILE_DIRECTORY_INFORMATION *CurrentEntry
    )

/*++

Routine Description:

    This routine manually does a rewind rather than use the file system
    to do it.  It gets starts at the first entry in the directory
    specified by DirectoryHandle and continues until it reaches the end
    of the directory or a match.  If a file is deleted between the
    original search and the rewind, then this mechanism will fail.

    This routine is intended to work in conjunction with
    SrvQueryDirectoryFile.


Arguments:

    DirectoryHandle - handle of directory to search.

    Buffer - Space to hold results.

    BufferLength - length of Buffer.

    FileName - the rewind file name.  The file *after* this one is returned.

    FileInformationClass - one of FileDirectoryInformation,
        FileBothDirInformation, or FileFullDirectoryInformation.
        (The latter of the four if EA sizes are being requested.)

    CurrentEntry - a pointer to receive a pointer to the file after
        FileName in the directory.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING checkFileName;
    BOOLEAN matchFound = FALSE;
    BOOLEAN restartScan = TRUE;

    ULONG fileNameOffset;

    PAGED_CODE( );

    checkFileName.Length = 0;
    *CurrentEntry = NULL;

    if ( FileInformationClass == FileFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
    } else {
        fileNameOffset =
            FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName[0] );
    }

    while ( TRUE ) {

        if ( *CurrentEntry == NULL ) {

            //
            // Restart the directory search and get a buffer of files.
            //

            status = SrvIssueQueryDirectoryRequest(
                         DirectoryHandle,
                         Buffer,
                         BufferLength,
                         FileInformationClass,
                         NULL,
                         NULL,
                         restartScan,
                         TRUE
                         );

            restartScan = FALSE;

            if ( status == STATUS_NO_MORE_FILES ) {

                if ( matchFound ) {

                    //
                    // The file matched the last one in the directory;
                    // there is no following file.  Return
                    // STATUS_NO_MORE_FILES.
                    //

                    return status;

                } else {

                    //
                    // The file was deleted between when the original search
                    // was done and this rewind.  Return an error.
                    //

                    return STATUS_NOT_IMPLEMENTED;
                }
            }

            if ( !NT_SUCCESS(status) ) {
                return status;
            }

            //
            // Set up the current entry pointer.
            //

            *CurrentEntry = Buffer;
        }

        //
        // If the last file we looked at was the correct resume file,
        // then we want to return this file.
        //

        if ( matchFound ) {
            return STATUS_SUCCESS;
        }

        //
        // Check to see if this file is the resume file.
        //

        checkFileName.Length = (SHORT)(*CurrentEntry)->FileNameLength;
        checkFileName.Buffer = FILE_NAME( *CurrentEntry );
        checkFileName.MaximumLength = checkFileName.Length;

        if ( RtlCompareUnicodeString(
                FileName,
                &checkFileName,
                TRUE
                ) == 0 ) {
            matchFound = TRUE;

        } else if ( FileInformationClass == FileBothDirectoryInformation ) {

            //
            // Compare the short name.
            //

            checkFileName.Length = (SHORT)
                ((PFILE_BOTH_DIR_INFORMATION)*CurrentEntry)->ShortNameLength;
            checkFileName.Buffer =
                ((PFILE_BOTH_DIR_INFORMATION)*CurrentEntry)->ShortName;
            checkFileName.MaximumLength = checkFileName.Length;

            if ( RtlCompareUnicodeString(
                    FileName,
                    &checkFileName,
                    TRUE
                    ) == 0 ) {
                matchFound = TRUE;
            }
        }

        IF_DEBUG(SEARCH) {
            if ( matchFound ) {
                SrvPrint2( "Matched: %wZ and %wZ\n", FileName, &checkFileName );
            } else {
                SrvPrint2( "No match: %wZ and %wZ\n", FileName, &checkFileName );
            }
        }

        //
        // Set up the current entry pointer for the next iteration.
        //

        if ( (*CurrentEntry)->NextEntryOffset == 0 ) {
            *CurrentEntry = NULL;
        } else {
            *CurrentEntry =
                (PFILE_DIRECTORY_INFORMATION)( (PCHAR)(*CurrentEntry) +
                    (*CurrentEntry)->NextEntryOffset );
        }
    }

} // BruteForceRewind



NTSTATUS
SrvQueryEaFile (
    IN BOOLEAN IsFirstCall,
    IN HANDLE FileHandle,
    IN PFILE_GET_EA_INFORMATION EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PSRV_EA_INFORMATION EaInformation,
    IN CLONG BufferLength,
    OUT PULONG EaErrorOffset
    )

/*++

Routine Description:

    This routine acts as a wrapper for NT LanMan server access to
    NtQueryEaFile.  It has basically the same interface as
    SrvQueryDirectoryFile, allowing a routine to be written to deal
    with a single EA at a time while also maintaining performance
    by requesting a large number of EAs from the IO system at a
    time.

    The calling routine is responsible for setting up a quadword-aligned
    buffer in nonpaged pool that may be used by this routine.  A pointer
    to the buffer and the buffer length are passed in as parameters.
    The buffer must be allocated from nonpaged pool because one of
    the things it is used for is as a buffer for NtQueryEaFile,
    a buffered-IO request.  The buffer is also used to hold information
    needed by this routine, such as a pointer to the FILE_EA_INFORMATION
    structure that was last returned.  Since all this information must
    remain valid across calls to this routine, the calling routine
    must ensure that the buffer remains intact until this routine
    returns an unsuccessful status or STATUS_NO_MORE_EAS.

    Routines that make use of this routine should set up a buffer
    large enough to hold at least a single EA.  Since this can be
    over 64k, it is a good idea to call NtQueryInformationFile to
    get the EA size, then allocate a buffer of this size, unless
    it is greater than the maximum size of an EA.  In this case,
    the maximum size of an EA should be allocated as the buffer.

    On the first call to this routine, it fills up its buffer with
    information from NtQueryEaFile and passes back a single EA.  On
    subsequent calls, the names stored in the buffer are used until
    there are no more files in the directory or another call to
    NtQueryEaFile is needed to again fill the buffer.

Arguments:

    IsFirstCall - a boolean indicating whether this is the first time
        the calling routine is calling this function.  If it is, then
        setup operations take place.

    FileHandle - a handle to a file open with FILE_READ_EA.

    EaList - an optional pointer to an NT-style get EA list.  Only those
        EAs listed in this structure are returned.

    EaListLength - length in bytes of ths get EA list.

    EaInformation - a pointer to the buffer to be used by this routine
        to do its work.  This buffer must be quadword-aligned.

    BufferLength - the length of the buffer passed to this routine.

    EaErrorOffset - the offset into EaList of an invalid EA, if any.

Return Value:

    A status indicating success or failure of the operation, or
    STATUS_NO_MORE_EAS if all the EAs have been returned.

--*/

{
    NTSTATUS status;
    PFILE_GET_EA_INFORMATION useEaList = NULL;
    PFILE_FULL_EA_INFORMATION *currentEntry;

    PAGED_CODE( );

    //
    // If this is the first call, do the necessary setup.
    //

    if ( IsFirstCall ) {

        //
        // Set up the currentEntry pointer.  This is a pointer to the
        // location where the FILE_EA_INFORMATION pointer is stored.
        // It is not really necessary--EaInformation->CurrentEntry
        // could be substituted for every occurrance of *currentEntry.
        // Using currentEntry makes the code more compact and simpler.
        //

        currentEntry = &(EaInformation->CurrentEntry);
        *currentEntry = NULL;

        //
        // Store the length of buffer space remaining--this is where IO
        // request information will be stored.
        //

        EaInformation->BufferLength = BufferLength - sizeof(SRV_EA_INFORMATION);
        EaInformation->GetEaListOffset = 0;

        IF_DEBUG(SEARCH) {
            SrvPrint3( "In BufferLength: %ld, sizeof(): %ld, ->BufferLength: "
                          "%ld\n", BufferLength, sizeof(SRV_EA_INFORMATION),
                          EaInformation->BufferLength );
        }

    } else {

        //
        // This is not the first call to this routine, so just set up
        // the currentEntry pointer and have it point to the next entry
        // in the buffer.  If there are no more entries in the buffer at
        // this time (NextEntryOffset == 0), set the currentEntry
        // pointer to NULL so that we will know to get more later.
        //

        currentEntry = &EaInformation->CurrentEntry;

        if ( *currentEntry != NULL ) {

            if ( (*currentEntry)->NextEntryOffset == 0 ) {

                *currentEntry = NULL;

            } else {

                *currentEntry = (PFILE_FULL_EA_INFORMATION)
                   ( (PCHAR)*currentEntry + (*currentEntry)->NextEntryOffset );
            }
        }
    }

    //
    // If the buffer has no valid entries in it, get some.
    //

    if ( *currentEntry == NULL ) {

        //
        // If all the EAs in a get EA list were returned last time,
        // return now.
        //

        if ( ARGUMENT_PRESENT(EaList) &&
                 EaInformation->GetEaListOffset == 0xFFFFFFFF ) {

            return STATUS_NO_MORE_EAS;
        }

        //
        // The buffer has no more valid entries in it, so get more.
        //

        IF_DEBUG(SEARCH) SrvPrint0( "**** CALLING NTQUERYEAFILE\n" );

        //
        // Set up the proper get EA list if one was specified on input.
        //

        if ( ARGUMENT_PRESENT(EaList) ) {
            useEaList = (PFILE_GET_EA_INFORMATION)( (PCHAR)EaList +
                            EaInformation->GetEaListOffset );
            EaListLength -= EaInformation->GetEaListOffset;
        }

        //
        // Do the EA query operation using a directly-build IRP.  Doing
        // this rather than calling NtQueryEaFile eliminates a buffered I/O
        // copy of the EAs and allows use of a kernel event object.
        //
        // The query is performed synchronously, which may be a
        // detriment to performance.  However, it may be the case that
        // routines calling SrvQueryEaFile want to exploit the
        // asynchronous capabilities of the IO system, so keeping this
        // routine synchronous significantly simplifies their job.
        //

        status = SrvIssueQueryEaRequest(
                    FileHandle,
                    (PCHAR)EaInformation->Buffer,
                    EaInformation->BufferLength,
                    useEaList,
                    EaListLength,
                    IsFirstCall,
                    EaErrorOffset
                    );

        //
        // If there are no more EAs to be gotten, then stop.
        //

        if ( status == STATUS_NO_MORE_EAS ||
             status == STATUS_NONEXISTENT_EA_ENTRY ||
             status == STATUS_NO_EAS_ON_FILE ) {

            IF_DEBUG(SEARCH) {
                SrvPrint0( "SrvQueryEaFile: No more EAs (or file has no EAs).\n" );
            }

            return STATUS_NO_MORE_EAS;
        }

        if ( !NT_SUCCESS(status) ) {
            return status;
        }

        IF_DEBUG(SEARCH) {
            SrvPrint1( "NtQueryEaFile succeeded: %X\n", status );
        }

        //
        // Set up the offset into the get EA list by counting how many
        // full EAs were returned, then walking that far into the get
        // EA list.
        //
        // If all the requested EAs were returned, set the offset to
        // 0xFFFFFFFF so that we know to return STATUS_NO_MORE_EAS.
        //

        if ( ARGUMENT_PRESENT(EaList) ) {

            CLONG numberOfGetEas;
            CLONG numberOfFullEas;

            numberOfGetEas = SrvGetNumberOfEasInList( useEaList );
            numberOfFullEas = SrvGetNumberOfEasInList( EaInformation->Buffer );

            ASSERT( numberOfGetEas >= numberOfFullEas );

            if ( numberOfGetEas == numberOfFullEas ) {

                EaInformation->GetEaListOffset = 0xFFFFFFFF;

            } else {

                CLONG i;

                //
                // Walk the get EA list until we have passed the number
                // of EAs that were returned.  This assumes that we got
                // back at least one EA--if not even one EA would fit in
                // the buffer, SrvIssueQueryEaRequest should have
                // returned STATUS_BUFFER_OVERFLOW.
                //

                for ( i = 0; i < numberOfFullEas; i++ ) {
                    useEaList = (PFILE_GET_EA_INFORMATION)(
                                    (PCHAR)useEaList +
                                    useEaList->NextEntryOffset );
                }

                EaInformation->GetEaListOffset = (ULONG)((PCHAR)useEaList -
                                                         (PCHAR)EaList);
            }
        }

        //
        // Set up CurrentEntry pointer to point to the first entry in the
        // buffer.
        //

        *currentEntry = (PFILE_FULL_EA_INFORMATION)EaInformation->Buffer;

        IF_DEBUG(SEARCH) {
            ANSI_STRING name;
            name.Length = (*currentEntry)->EaNameLength;
            name.Buffer = (*currentEntry)->EaName;
            SrvPrint2( "First EA name is %z, length = %ld\n",
                        (PCSTRING)&name, (*currentEntry)->EaNameLength );
        }
    }

    return STATUS_SUCCESS;

} // SrvQueryEaFile



VOID
SrvTimeToDosTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PSMB_DATE DosDate,
    OUT PSMB_TIME DosTime
    )

/*++

Routine Description:

    This function converts a time in NT format to the format used by
    MS-DOS.

Arguments:

    SystemTime - a pointer to an NT time to convert.

    DosDate - a pointer to a location in which to store the date in DOS format.

    DosTime - a pointer to a location in which to store the time in DOS format.

Return Value:

    None.

--*/

{
    TIME_FIELDS timeFields;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    if ( SystemTime->QuadPart == 0 ) {
        goto zerotime;
    }

    //
    // Add almost two seconds to round up to the nearest double second.
    // We need to do this to be compatible with the NT rdr and NT FAT
    // filesystem.
    //

    SystemTime->QuadPart += AlmostTwoSeconds;

    //
    // Convert System time (UTC) to local NT time
    //

    ExSystemTimeToLocalTime( SystemTime, &localTime );

    RtlTimeToTimeFields(
        &localTime,
        &timeFields
        );

    DosDate->Struct.Day = timeFields.Day;
    DosDate->Struct.Month = timeFields.Month;
    DosDate->Struct.Year = (SHORT)(timeFields.Year - 1980);

    DosTime->Struct.TwoSeconds = (SHORT)(timeFields.Second / 2);
    DosTime->Struct.Minutes = timeFields.Minute;
    DosTime->Struct.Hours = timeFields.Hour;

    return;

zerotime:

    DosDate->Struct.Day = 0;
    DosDate->Struct.Month = 0;
    DosDate->Struct.Year = 0;

    DosTime->Struct.TwoSeconds = 0;
    DosTime->Struct.Minutes = 0;
    DosTime->Struct.Hours = 0;

    return;
} // SrvTimeToDosTime


VOID
SrvDosTimeToTime (
    OUT PLARGE_INTEGER SystemTime,
    IN SMB_DATE DosDate,
    IN SMB_TIME DosTime
    )

/*++

Routine Description:

    This function converts a time in NT format to the format used by
    MS-DOS.

Arguments:

    Time - a pointer to a location in which to store the NT time.

    DosDate - a pointer the date in DOS format.

    DosDate - a pointer the date in DOS format.

Return Value:

    None.

--*/

{

    TIME_FIELDS timeFields;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    timeFields.Day = DosDate.Struct.Day;
    timeFields.Month = DosDate.Struct.Month;
    timeFields.Year = (SHORT)(DosDate.Struct.Year + 1980);

    timeFields.Milliseconds = 0;
    timeFields.Second = (SHORT)(DosTime.Struct.TwoSeconds * 2);
    timeFields.Minute = DosTime.Struct.Minutes;
    timeFields.Hour = DosTime.Struct.Hours;

    if ( !RtlTimeFieldsToTime( &timeFields, &localTime ) ) {
        goto zerotime;
    }

    ExLocalTimeToSystemTime( &localTime, SystemTime );
    return;

zerotime:

    SystemTime->QuadPart = 0;
    return;

} // SrvDosTimeToTime


USHORT
SrvGetOs2TimeZone(
    IN PLARGE_INTEGER SystemTime
    )

/*++

Routine Description:

    This function gets the timezone bias.

Arguments:

    SystemTime - The current UTC time expressed.

Return Value:

    The time zone bias in minutes from GMT.

--*/

{
    LARGE_INTEGER zeroTime;
    LARGE_INTEGER timeZoneBias;

    PAGED_CODE( );

    zeroTime.QuadPart = 0;

    //
    // Specifying a zero local time will give you the time zone bias.
    //

    ExLocalTimeToSystemTime( &zeroTime, &timeZoneBias );

    //
    // Convert the bias unit from 100ns to minutes.  The maximum value
    // for the bias is 720 minutes so a USHORT is big enough to contain
    // it.
    //

    return (SHORT)(timeZoneBias.QuadPart / (10*1000*1000*60));

} // SrvGetOs2TimeZone

NTSTATUS
SrvQueryBasicAndStandardInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject OPTIONAL,
    PFILE_BASIC_INFORMATION FileBasicInfo,
    PFILE_STANDARD_INFORMATION FileStandardInfo OPTIONAL
    )
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFAST_IO_QUERY_BASIC_INFO fastQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO fastQueryStandardInfo;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE( );

    ASSERT( FileBasicInfo != NULL );

    //
    // Get a pointer to the file object, so that we can directly
    // access the fast IO routines, if they exists.
    //

    if ( !ARGUMENT_PRESENT( FileObject ) ) {

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            return(status);

        }

    } else {
        fileObject = FileObject;
    }

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    if ( fastIoDispatch ) {
        fastQueryBasicInfo = fastIoDispatch->FastIoQueryBasicInfo;
        fastQueryStandardInfo = fastIoDispatch->FastIoQueryStandardInfo;
    } else {
        fastQueryBasicInfo = NULL;
        fastQueryStandardInfo = NULL;
    }

    if ( fastQueryBasicInfo &&
         fastQueryBasicInfo(
                         fileObject,
                         TRUE,
                         FileBasicInfo,
                         &ioStatus,
                         deviceObject
                         ) ) {

        status = ioStatus.Status;

    } else {

        status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)FileBasicInfo,
                         sizeof(FILE_BASIC_INFORMATION),
                         FileBasicInformation
                         );
    }

    //
    // If we're done if there was a failure, return
    //

    if ( ARGUMENT_PRESENT( FileStandardInfo ) && NT_SUCCESS(status) ) {

        //
        // Get the standard info
        //

        if ( fastQueryStandardInfo &&
             fastQueryStandardInfo(
                             fileObject,
                             TRUE,
                             FileStandardInfo,
                             &ioStatus,
                             deviceObject
                             ) ) {

            status = ioStatus.Status;

        } else {

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)FileStandardInfo,
                         sizeof(FILE_STANDARD_INFORMATION),
                         FileStandardInformation
                         );
        }
    }

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }
    return(status);

} // SrvQueryBasicAndStandardInformation

NTSTATUS
SrvQueryNetworkOpenInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject OPTIONAL,
    PSRV_NETWORK_OPEN_INFORMATION SrvNetworkOpenInformation,
    BOOLEAN QueryEaSize
    )
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO fastQueryNetworkOpenInfo;
    FILE_BASIC_INFORMATION FileBasicInfo;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE( );

    //
    // Get a pointer to the file object, so that we can directly
    // access the fast IO routines, if they exist.
    //
    if ( !ARGUMENT_PRESENT( FileObject ) ) {

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            return(status);

        }

    } else {
        fileObject = FileObject;
    }

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    if(  !QueryEaSize &&
         fastIoDispatch &&
         fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH,FastIoQueryNetworkOpenInfo)) {

        fastQueryNetworkOpenInfo = fastIoDispatch->FastIoQueryNetworkOpenInfo;

        if( fastQueryNetworkOpenInfo &&

            fastQueryNetworkOpenInfo(
                fileObject,
                TRUE,
                (PFILE_NETWORK_OPEN_INFORMATION)SrvNetworkOpenInformation,
                &ioStatus,
                deviceObject ) ) {

            status = ioStatus.Status;

            if ( !ARGUMENT_PRESENT( FileObject ) ) {
                ObDereferenceObject( fileObject );
            }

            return status;
        }
    }

    //
    // The fast path didn't work.  Do it the slow way
    //
    status = SrvQueryBasicAndStandardInformation(
                FileHandle,
                fileObject,
                &FileBasicInfo,
                &FileStandardInfo
             );

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    SrvNetworkOpenInformation->CreationTime   = FileBasicInfo.CreationTime;
    SrvNetworkOpenInformation->LastAccessTime = FileBasicInfo.LastAccessTime;
    SrvNetworkOpenInformation->LastWriteTime  = FileBasicInfo.LastWriteTime;
    SrvNetworkOpenInformation->ChangeTime     = FileBasicInfo.ChangeTime;
    SrvNetworkOpenInformation->AllocationSize = FileStandardInfo.AllocationSize;
    SrvNetworkOpenInformation->EndOfFile      = FileStandardInfo.EndOfFile;
    SrvNetworkOpenInformation->FileAttributes = FileBasicInfo.FileAttributes;

    if ( QueryEaSize ) {

            FILE_EA_INFORMATION fileEaInformation;

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)&fileEaInformation,
                         sizeof(FILE_EA_INFORMATION),
                         FileEaInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvQueryInformationFile: NtQueryInformationFile "
                        "(EA information) failed: %X",
                     status,
                     NULL
                     );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            SrvNetworkOpenInformation->EaSize = fileEaInformation.EaSize;
    }

    return(status);

} // SrvQueryNetworkOpenInformation

NTSTATUS
SrvDownlevelTWarpQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    )

/*++

Routine Description:

    This routine acts as a wrapper for NT LanMan server access to
    NtQueryDirectoryFile.  It allows server routines to obtain information
    about the files in a directory using the kind of information
    passed in an SMB.  This localizes the code for this operation and
    simplifies the writing of SMB processing routines that use wildcards.

    The calling routine is responsible for setting up a quadword-aligned
    buffer in nonpaged pool that may be used by this routine.  A pointer
    to the buffer and the buffer length are passed in as parameters.
    The buffer must be allocated from nonpaged pool because one of
    the things it is used for is as a buffer for NtQueryDirectoryFile,
    a buffered-IO request.  The buffer is also used to hold information
    needed by this routine, such as a handle to the directory in which
    the search is being performed, a pointer to the
    FILE_DIRECTORY_INFORMATION structure that was last returned, and the
    basename (with wildcards) that we're using as a search key.  Since
    all this information must remain valid across calls to this routine,
    the calling routine must ensure that the buffer remains intact until
    this routine returns an unsuccessful status or STATUS_NO_MORE_FILES,
    or SrvCloseQueryDirectory is called.

    SMB processing routines which do not need to make use of the Buffer
    field of the outgoing SMB may use this as a buffer for this routine,
    remembering to leave any pathname information in the buffer field of the
    incoming SMB intact by starting the buffer after the pathname.  SMB
    processing routines that write into the Buffer field of the outgoing SMB,
    such as Search and Find, must allocate space for the buffer from nonpaged
    pool.  The size of the buffer should be approximately 4k.  Smaller
    buffers will work, but more slowly due to the need for more calls
    to NtQueryDirectoryFile.  The minimum buffer size is equal to:

        sizeof(SRV_DIRECTORY_INFORMATION) +
        sizeof(SRV_QUERY_DIRECTORY_INFORMATION) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR) +
        sizeof(UNICODE_STRING) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)

    This ensures that NtQueryDirectoryFile will be able to put at least
    one entry in the buffer.

    On the first call to this routine, it fills up its buffer with
    information from NtQueryDirectoryFile and passes back the name of
    a single file that conforms to the specified name and search
    attributes.  On subsequent calls, the names stored in the buffer are
    used until there are no more files in the directory or another
    call to NtQueryDirectoryFile is needed to again fill the buffer.

    Whenever the caller is done with the search, it must call
    SrvCloseQueryDirectory.  This is required even if this routine
    returns an error.

Arguments:

    WorkContext - pointer to a work context block for the operation.  The
        TreeConnect, Session, and RequestHeader fields are used, and the
        pointer is passed to the SMB error handling function if necessary.

    IsFirstCall - a boolean indicating whether this is the first time
        the calling routine is calling this function.  If it is, then
        the directory for the search is opened and other setup
        operations take place.

    FilterLongNames - a boolean that is TRUE when non-FAT names should be
        filtered out (not returned).  If FALSE, return all filenames,
        regardless of whether or not they could be FAT 8.3 names.

    FindWithBackupIntent - Whether the directory was opened by the use
        for backup intent.

    FileInformationClass - the type of file structures to return.  This
        field can be one of FileDirectoryInformation,
        FileFullDirectoryInformation, FileOleDirectoryInformation, or
        FileBothDirectoryInformation.

    FilePathName - a pointer to a string describing the file path name
        to do directory searches on.  This path is relative to the
        PathName specified in the share block.  This parameter is only
        used on the first call to this routine; subsequent calls ignore it.

    ResumeFileIndex - an optional pointer to a file index which determines
        the file with which to restart the search.  NULL if the search
        should be restarted from the last file returned.

    SmbSearchAttributes - the atttibutes, in SMB format, that files must
        have in order to be found.  The search is inclusive, meaning that
        if several attributes are specified, files having those attributes
        will be found, in addition to normal files.

    DirectoryInformation - a pointer to the buffer to be used by this
        routine to do its work.  This buffer must be quadword-aligned.

    BufferLength - the length of the buffer passed to this routine.

Return Value:

    A status indicating success or failure of the operation, or
    STATUS_NO_MORE_FILES if the files in the directory that match the
    specified parameters have been exausted.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_DIRECTORY_INFORMATION *currentEntry;
    ULONG currentAttributes;
    BOOLEAN returnDirectories;
    BOOLEAN returnDirectoriesOnly;
    BOOLEAN calledQueryDirectory = FALSE;

    OBJECT_ATTRIBUTES objectAttributes;
    PUNICODE_STRING filePathName;
    BOOLEAN FreePathName = FALSE;
    UNICODE_STRING objectNameString;
    UNICODE_STRING baseFileName;
    PSHARE fileShare = NULL;

    PUNICODE_STRING resumeName = NULL;
    BOOLEAN resumeSearch;

    CLONG fileNameOffset;
    ULONG createOptions;

    PAGED_CODE( );

    if ( FileInformationClass == FileBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
    }
    else
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // This macro is used to actually get at the FileName field.  Note
    // that it depends on a local variable.
    //

#define FILE_NAME(a) (PWCH)( (PCHAR)(a) + fileNameOffset )

    //
    // If this is the first call to this routine, we must open the
    // correct directory, thereby obtaining a handle to it to pass to
    // NtQueryDirectoryFile.  The calling routine stores the handle
    // to prevent problems if SrvQueryDirectoryFile is called more
    // than once simultaneously.
    //

    if ( IsFirstCall ) {

        BOOLEAN endsInDot;
        ULONG attributes;

        DirectoryInformation->DirectoryHandle = 0L;
        DirectoryInformation->ErrorOnFileOpen = FALSE;
        DirectoryInformation->OnlySingleEntries = FALSE;

        DirectoryInformation->Wildcards = TRUE;

        //
        // Set up the currentEntry pointer.  This is a pointer to the
        // location where the FILE_DIRECTORY_INFORMATION pointer is
        // stored.  It is not really necessary--
        // DirectoryInformation->CurrentEntry could be substituted for
        // every occurrance of *currentEntry.  Using currentEntry makes
        // the code more compact and simpler.
        //

        currentEntry = &(DirectoryInformation->CurrentEntry);
        *currentEntry = NULL;

        //
        // Store the length of buffer space remaining--this is where IO
        // request information will be stored.
        //

        DirectoryInformation->BufferLength = BufferLength -
                                            sizeof(SRV_DIRECTORY_INFORMATION);

        IF_DEBUG(SEARCH) {
            SrvPrint3( "In BufferLength: %ld, sizeof(): %ld, ->BufferLength: "
                          "%ld\n", BufferLength,
                          sizeof(SRV_DIRECTORY_INFORMATION),
                          DirectoryInformation->BufferLength );
        }

    } else {

        //
        // This is not the first call to this routine, so just set up
        // the currentEntry pointer and have it point to the next entry
        // in the buffer.  If there are no more entries in the buffer at
        // this time (NextEntryOffset == 0), set the currentEntry
        // pointer to NULL so that we will know to get more later.
        //

        currentEntry = &DirectoryInformation->CurrentEntry;

        if ( *currentEntry != NULL ) {

            if ( (*currentEntry)->NextEntryOffset == 0 ) {

                *currentEntry = NULL;

            } else {

                *currentEntry = (PFILE_DIRECTORY_INFORMATION)
                   ( (PCHAR)*currentEntry + (*currentEntry)->NextEntryOffset );
            }
        }
    }

    //
    // If a resume file index was passed in, this search is a resumption
    // from that file and the name specified in FilePathName.
    //

    if ( ARGUMENT_PRESENT( ResumeFileIndex ) ) {

        resumeSearch = TRUE;
        resumeName = FilePathName;

        IF_DEBUG(SEARCH) {
            SrvPrint3( "Resuming search at file %wZ, length %ld, index %lx\n",
                          resumeName, resumeName->Length,
                          *ResumeFileIndex );
        }

    } else {

        resumeSearch = FALSE;
    }

    //
    // Now we need to find a file to return.  We keep going until we find
    // a file that meets all of our criteria, pointing to the next file
    // if a file fails.  We continue the loop under the following conditions:
    //
    // 1) If *currentEntry == NULL, then we haven't yet filled our buffer
    //    with entries, so get some entries.
    //
    // 2) If there are bits set in the FileAttributes field of the
    //    FILE_DIRECTORY_INFORMATION field that are not set in the
    //    searchAttributes variable, then the file does not meet the
    //    search requirements, and we need to continue looking.
    //
    // 3) If we are not searching for directories and the file is actually
    //    a directory, skip over it.
    //
    // 4) If we are filtering long (non-FAT) filenames AND this file name
    //    is not a legal FAT name AND we have no short name for this file,
    //    skip it.
    //
    // 5) If the file doesn't have attribute bits specified as exclusive
    //    bits, skip it.
    //
    // 6) If the file is not a directory and we're only supposed to return
    //    directories, skip it.
    //
    // When this loop is complete, *currentEntry will point to the
    // FILE_DIRECTORY_INFORMATION structure corresponding to the file we
    // will return.  If no qualifying files are found, return
    // STATUS_NO_MORE_FILES and close the directory.
    //

    if( *currentEntry != NULL ) {
        SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
    }

    while ( ( *currentEntry == NULL ) ) {

        IF_DEBUG(SEARCH) {
            if ( *currentEntry != NULL) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint4( "NL=%ld D=%ld RD=%ld RDO=%ld ",
                            (*currentEntry)->FileNameLength,
                            (((*currentEntry)->FileAttributes &
                            FILE_ATTRIBUTE_DIRECTORY) != 0), returnDirectories,
                            returnDirectoriesOnly );
                SrvPrint1( "FLN=%ld\n", FilterLongNames );
            }
        }

        //
        // We need to look for more files under the following conditions:
        //
        //    o we have yet to fill the buffer with entries;
        //
        //    o the NextEntryOffset is zero, indicating that the files in
        //      the buffer have been exausted.
        //

        if ( *currentEntry == NULL ||
             (*currentEntry)->NextEntryOffset == 0 ) {

            PUNICODE_STRING actualString;
            BOOLEAN bruteForceRewind = FALSE;

            //
            // The buffer has no more valid entries in it.  If no
            // wildcards were specified in the file name to search on,
            // then we have already returned the single file and we
            // should just stop now.  Otherwise, we go get more entries.
            //

            if ( !DirectoryInformation->Wildcards &&
                 ( !IsFirstCall || calledQueryDirectory ) ) {

                if ( calledQueryDirectory ) {
                    return STATUS_NO_SUCH_FILE;
                } else {
                    return STATUS_NO_MORE_FILES;
                }
            }

            //
            // Set up the file name that will be passed to
            // SrvIssueQueryDirectoryRequest.  If this is the first
            // call, then pass the file spec given by the user.  If this
            // is a resume search and we haven't yet done a directory
            // query, then use the resume file name and index.
            // Otherwise, pass NULL for these and the file system will
            // continue from where it left off after the last directory
            // query.
            //

            if ( IsFirstCall &&
                 !calledQueryDirectory /*&&
                 baseFileName.Length != 0 */ ) {

                //actualString = &baseFileName;
                actualString = NULL;

            } else if ( resumeSearch && !calledQueryDirectory ) {

                actualString = resumeName;

            } else {

                actualString = NULL;
                ResumeFileIndex = NULL;

            }

            IF_DEBUG(SEARCH) {

                if ( actualString == NULL ) {
                    SrvPrint0( "**** CALLING NTQUERYDIRECTORYFILE, file = NULL, length: 0\n" );
                } else {
                    SrvPrint2( "**** CALLING NTQUERYDIRECTORYFILE, file = %wZ, length: %ld\n",
                                actualString, actualString->Length );
                }

                SrvPrint0( "Reason:  \n" );

                if ( *currentEntry == NULL ) {
                    SrvPrint0( "*currentEntry == NULL\n" );
                } else {
                    SrvPrint1( "(*currentEntry)->NextEntryOffset == %ld\n",
                               (*currentEntry)->NextEntryOffset );
                }
            }

            //
            // Do the directory query operation using a directly-built
            // IRP.  Doing this rather than calling NtQueryDirectoryFile
            // eliminates a buffered I/O copy of the directory
            // information and allows use of a kernel event object.  If
            // this is the first call to NtQueryDirectoryFile, pass it
            // the search file name.  If this is a rewind or resume of a
            // prior search, pass the resume file name and index.
            //
            // The query is performed synchronously, which may be a
            // detriment to performance.  However, it may be the case
            // that routines calling SrvQueryDirectoryFile want to
            // exploit the asynchronous capabilities of the IO system,
            // so keeping this routine synchronous significantly
            // simplifies their job.
            //

            status = SrvSnapEnumerateSnapShotsAsDirInfo(
                         WorkContext,
                         DirectoryInformation->Buffer,
                         DirectoryInformation->BufferLength,
                         actualString,
                         DirectoryInformation->OnlySingleEntries,
                         DirectoryInformation
                         );

            calledQueryDirectory = TRUE;

            //
            // If there are no more files to be gotten, then stop.
            //

            if ( status == STATUS_NO_MORE_FILES ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint0( "SrvQueryDirectoryFile: No more files.\n" );
                }
                return status;
            }

            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint1( "SrvQueryDirectoryFile: NtQueryDirectoryFile "
                                 "failed: %X.\n", status );
                }
                return status;
            }

            IF_DEBUG(SEARCH) {
                SrvPrint1( "NtQueryDirectoryFile succeeded: %X\n", status );
            }

            //
            // If there wasn't a brute force rewind, which would have
            // set up the CurrentEntry pointer, Set up CurrentEntry
            // pointer to point to the first entry in the buffer.
            //

            if ( !bruteForceRewind ) {
                *currentEntry =
                    (PFILE_DIRECTORY_INFORMATION)DirectoryInformation->Buffer;
            } else {
                bruteForceRewind = FALSE;
            }

            IF_DEBUG(SEARCH) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint2( "First file name is %wZ, length = %ld\n",
                            &name, (*currentEntry)->FileNameLength );
            }

        } else {

            //
            // The file described by the FILE_DIRECTORY_INFORMATION pointed
            // to by *currentEntry does not meet our requirements, so
            // point to the next file in the buffer.
            //

            *currentEntry = (PFILE_DIRECTORY_INFORMATION)( (PCHAR)*currentEntry
                            + (*currentEntry)->NextEntryOffset );
        }

        if( *currentEntry != NULL ) {
            SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
        }
    }

    return STATUS_SUCCESS;

} // SrvDownlevelTWarpQueryDirectoryFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\fspinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fspinit.c

Abstract:

    This module implements the initialization phase of the LAN Manager
    server File System Process.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "fspinit.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSPINIT

//
// Forward declarations.
//

PIRP
DequeueConfigurationIrp (
    VOID
    );

STATIC
NTSTATUS
InitializeServer (
    VOID
    );

STATIC
NTSTATUS
TerminateServer (
    VOID
    );

VOID
SrvFreeRegTables (
    VOID
    );

VOID
SrvGetRegTables (
    VOID
    );

#if SRVNTVERCHK
VOID
SrvGetRegClientNumber (
    VOID
    );
#endif

VOID
StartQueueDepthComputations(
    PWORK_QUEUE queue
    );

VOID
StopQueueDepthComputations(
    PWORK_QUEUE queue
    );

VOID
ComputeAvgQueueDepth (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
GenerateCrcTable();

BOOLEAN
CleanupCrcTable();

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvConfigurationThread )
#pragma alloc_text( PAGE, InitializeServer )
#pragma alloc_text( PAGE, TerminateServer )
#pragma alloc_text( PAGE, SrvFreeRegTables )
#pragma alloc_text( PAGE, SrvGetRegTables )
#if SRVNTVERCHK
#pragma alloc_text( PAGE, SrvGetRegClientNumber )
#endif
#pragma alloc_text( PAGE, DequeueConfigurationIrp )
#pragma alloc_text( PAGE, StartQueueDepthComputations )
#endif

extern ULONG SrvWmiInitialized;


VOID
SrvConfigurationThread (
    IN PDEVICE_OBJECT pDevice,
    IN PIO_WORKITEM pWorkItem
    )

/*++

Routine Description:

    This routine processes configuration IRPs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG code;

    PAGED_CODE( );

    IF_DEBUG(FSP1) KdPrint(( "SrvConfigurationThread entered\n" ));

    //
    // Loop processing requests.
    //

    while ( TRUE ) {

        irp = DequeueConfigurationIrp( );

        if ( irp == NULL ) break;

        ASSERT( (LONG)SrvConfigurationIrpsInProgress >= 1 );

        //
        // Get the IRP stack pointer.
        //

        irpSp = IoGetCurrentIrpStackLocation( irp );

        if( irpSp->MajorFunction == IRP_MJ_CLOSE ) {

            //
            // If the dispatcher routed this irp here, it means
            //  that we unexpectededly got the last handle close without
            //  having gotten cleanly terminated first. Ok, so we should
            //  shut ourselves down, since we can't sensibly run without
            //  our usermode counterpart.
            //

            ACQUIRE_LOCK( &SrvStartupShutdownLock );
            status = TerminateServer();
            RELEASE_LOCK( &SrvStartupShutdownLock );

        } else {

            ASSERT( irpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

            try {

                //
                // Dispatch on the FsControlCode.
                //

                code = irpSp->Parameters.FileSystemControl.FsControlCode;

                switch ( code ) {

                case FSCTL_SRV_STARTUP:
                    ACQUIRE_LOCK( &SrvStartupShutdownLock );

                    status = InitializeServer();

                    if ( !NT_SUCCESS(status) ) {

                        //
                        // Terminate the server FSP.
                        //
                        (void)TerminateServer();

                    }

                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    break;

                case FSCTL_SRV_SHUTDOWN:

                    ACQUIRE_LOCK( &SrvStartupShutdownLock );
                    status = TerminateServer();
                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    //
                    // If there is more than one handle open to the server
                    // device (i.e., any handles other than the server service's
                    // handle), return a special status code to the caller (who
                    // should be the server service).  This tells the caller to
                    // NOT unload the driver, in order prevent weird situations
                    // where the driver is sort of unloaded, so it can't be used
                    // but also can't be reloaded, thus preventing the server
                    // from being restarted.
                    //

                    if( NT_SUCCESS( status ) && SrvOpenCount != 1 ) {
                        status = STATUS_SERVER_HAS_OPEN_HANDLES;
                    }

                    break;

                case FSCTL_SRV_REGISTRY_CHANGE:
                    //
                    // The Parameters section of the server service registry has changed.
                    // That's likely due to somebody changing the Null Session pipe or
                    //  share lists.  Pick up the new settings.
                    //
                    ACQUIRE_LOCK( &SrvConfigurationLock );

                    SrvFreeRegTables();
                    SrvGetRegTables();
    #if SRVNTVERCHK
                    SrvGetRegClientNumber();
    #endif

                    RELEASE_LOCK( &SrvConfigurationLock );

                    status = STATUS_SUCCESS;

                    break;

                case FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS:
                    //
                    // If somebody tries to shut down the server while
                    //  we are registering our handlers, block them until
                    //  we are finished.
                    //
                    ACQUIRE_LOCK( &SrvStartupShutdownLock );

                    {
                        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

                        RtlZeroMemory(&ClientInterfaceInfo, sizeof(TDI_CLIENT_INTERFACE_INFO));

                        ClientInterfaceInfo.MajorTdiVersion = 2;
                        ClientInterfaceInfo.MinorTdiVersion = 0;
                        ClientInterfaceInfo.ClientName = &StrRegSrvPnpClientName;
                        ClientInterfaceInfo.BindingHandler = SrvPnpBindingHandler;
                        ClientInterfaceInfo.PnPPowerHandler = SrvPnpPowerHandler;


                        status = TdiRegisterPnPHandlers(
                                                        &ClientInterfaceInfo,
                                                        sizeof( ClientInterfaceInfo ),
                                                        &SrvTdiNotificationHandle
                                                        );

                        if (status != STATUS_SUCCESS) {
                            SrvTdiNotificationHandle = NULL;
                        }
                    }

                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    if( !NT_SUCCESS( status ) ) {

                            IF_DEBUG( PNP ) {
                                KdPrint(("TdiRegisterNotificationHandler: status %X\n", status ));
                            }

                            SrvLogServiceFailure( SRV_SVC_PNP_TDI_NOTIFICATION, status );
                    }

                    //
                    // Allow the transports to begin receiving connections
                    //
                    SrvCompletedPNPRegistration = TRUE;

                    break;

                case FSCTL_SRV_XACTSRV_CONNECT:
                {
                    ANSI_STRING ansiPortName;
                    UNICODE_STRING portName;

                    IF_DEBUG(XACTSRV) {
                        KdPrint(( "SrvFspConfigurationThread: XACTSRV FSCTL "
                                  "received.\n" ));
                    }

                    ansiPortName.Buffer = irp->AssociatedIrp.SystemBuffer;
                    ansiPortName.Length =
                        (USHORT)irpSp->Parameters.FileSystemControl.InputBufferLength;

                    status = RtlAnsiStringToUnicodeString(
                                 &portName,
                                 &ansiPortName,
                                 TRUE
                                 );
                    if ( NT_SUCCESS(status) ) {
                        status = SrvXsConnect( &portName );
                        RtlFreeUnicodeString( &portName );
                    }

                    break;
                }

                case FSCTL_SRV_XACTSRV_DISCONNECT:
                {
                    //
                    // This is now obsolete
                    //
                    status = STATUS_SUCCESS;

                    break;
                }

                case FSCTL_SRV_SEND_DATAGRAM:
                {
                    ANSI_STRING domain;
                    ULONG buffer1Length;
                    PVOID buffer2;
                    PSERVER_REQUEST_PACKET srp;

                    buffer1Length = ALIGN_UP(
                        irpSp->Parameters.FileSystemControl.InputBufferLength,
                        PVOID );

                    buffer2 = (PCHAR)irp->AssociatedIrp.SystemBuffer + buffer1Length;

                    srp = irp->AssociatedIrp.SystemBuffer;

                    //
                    // Send the second-class mailslot in Buffer2 to the domain
                    // specified in srp->Name1 on transport specified by srp->Name2.
                    //

                    domain = *((PANSI_STRING) &srp->Name1);

                    status = SrvSendDatagram(
                                 &domain,
                                 ( srp->Name2.Length != 0 ? &srp->Name2 : NULL ),
                                 buffer2,
                                 irpSp->Parameters.FileSystemControl.OutputBufferLength
                                 );

                    ExFreePool( irp->AssociatedIrp.SystemBuffer );
                    DEBUG irp->AssociatedIrp.SystemBuffer = NULL;

                    break;
                }

                case FSCTL_SRV_NET_FILE_CLOSE:
                case FSCTL_SRV_NET_SERVER_XPORT_ADD:
                case FSCTL_SRV_NET_SERVER_XPORT_DEL:
                case FSCTL_SRV_NET_SESSION_DEL:
                case FSCTL_SRV_NET_SHARE_ADD:
                case FSCTL_SRV_NET_SHARE_DEL:
                {
                    PSERVER_REQUEST_PACKET srp;
                    PVOID buffer2;
                    ULONG buffer1Length;
                    ULONG buffer2Length;

                    //
                    // These APIs are handled in the server FSP because they
                    // open or close FSP handles.
                    //

                    ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );
                    if( SrvFspTransitioning == TRUE && SrvFspActive == TRUE ) {
                        //
                        // The server is coming down.  Do not allow these
                        //  irps to continue.
                        //
                        RELEASE_LOCK( &SrvConfigurationLock );
                        status = STATUS_SERVER_NOT_STARTED;
                        break;
                    }
                    RELEASE_LOCK( &SrvConfigurationLock );

                    //
                    // Get the server request packet and secondary input buffer
                    // pointers.
                    //

                    buffer1Length = ALIGN_UP(
                        irpSp->Parameters.FileSystemControl.InputBufferLength,
                        PVOID );

                    buffer2Length =
                        irpSp->Parameters.FileSystemControl.OutputBufferLength;

                    srp = irp->AssociatedIrp.SystemBuffer;

                    buffer2 = (PCHAR)srp + buffer1Length;

                    //
                    // Dispatch the API request to the appripriate API processing
                    // routine.
                    //

                    status = SrvApiDispatchTable[ SRV_API_INDEX(code) ](
                                 srp,
                                 buffer2,
                                 buffer2Length
                                 );

                    break;
                }

                default:
                    IF_DEBUG(ERRORS) {
                        KdPrint((
                            "SrvFspConfigurationThread: Invalid control code %lx\n",
                            irpSp->Parameters.FileSystemControl.FsControlCode ));
                    }

                    status = STATUS_INVALID_PARAMETER;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }

        //
        // Make sure we're still at PASSIVE_LEVEL
        //
        if( KeGetCurrentIrql() > PASSIVE_LEVEL )
        {
            goto bad_irql_failure;
        }

        //
        // Complete the IO request.
        //

        irp->IoStatus.Status = status;
        IoCompleteRequest( irp, 2 );

        //
        // Make sure we're still at PASSIVE_LEVEL
        //
        if( KeGetCurrentIrql() > PASSIVE_LEVEL )
        {
            goto bad_irql_failure;
        }

        ASSERT( (LONG)SrvConfigurationIrpsInProgress >= 0 );

        // Make sure we don't continue if there are no IRP's left
        if( InterlockedDecrement( (PLONG)&SrvConfigurationIrpsInProgress ) == 0 )
        {
            break;
        }
    }

    IoFreeWorkItem( pWorkItem );

    return;

bad_irql_failure:

#if DBG
    DbgPrint( "ERROR: SrvConfigurationThread returning at >PASSIVE level\n" );
    DbgBreakPoint();
#endif

    IoFreeWorkItem( pWorkItem );

    return;

} // SrvConfigurationThread


PIRP
DequeueConfigurationIrp (
    VOID
    )

/*++

Routine Description:

    This routine retrieves an IRP from the configuration work queue.

Arguments:

    None.

Return Value:

    PIRP - Pointer to configuration IRP, or NULL.

--*/

{
    PLIST_ENTRY listEntry;
    PIRP irp;

    PAGED_CODE( );

    //
    // Take an IRP off the configuration queue.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    listEntry = RemoveHeadList( &SrvConfigurationWorkQueue );

    if ( listEntry == &SrvConfigurationWorkQueue ) {

        //
        // The queue is empty.
        //

        irp = NULL;

    } else {

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

    }

    RELEASE_LOCK( &SrvConfigurationLock );

    return irp;

} // DequeueConfigurationIrp


STATIC
NTSTATUS
InitializeServer (
    VOID
    )

/*++

Routine Description:

    This routine initializes the server.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    CLONG i;
    PWORK_CONTEXT workContext;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PSID AdminSid;
    PSID AnonymousSid;
    PACL Acl;
    ULONG length;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    PWORK_QUEUE queue;
    HANDLE handle;
    UNICODE_STRING string;

    PAGED_CODE();

    //
    // If running as an Advanced Server, lock all pageable server code.
    //

    if ( SrvProductTypeServer ) {
        for ( i = 0; i < SRV_CODE_SECTION_MAX; i++ ) {
            SrvReferenceUnlockableCodeSection( i );
        }
    }

    //
    // Initialize the server start time
    //

    KeQuerySystemTime( &SrvStatistics.StatisticsStartTime );

    //
    // Get actual alert service name using the display name found in the
    // registry.
    //

    SrvGetAlertServiceName( );

    //
    // Get the Os versions strings.
    //

    SrvGetOsVersionString( );

    //
    // Get the list of null session pipes and shares
    //
    SrvGetRegTables( );

#if SRVNTVERCHK
    SrvGetRegClientNumber();
#endif

#if MULTIPROCESSOR
    //
    // Allocate and init the nonblocking work queues, paying attention to cache lines
    //
    i = SrvNumberOfProcessors * sizeof( *SrvWorkQueues );
    i += CACHE_LINE_SIZE;
    SrvWorkQueuesBase = ALLOCATE_NONPAGED_POOL( i, BlockTypeWorkQueue );

    if( SrvWorkQueuesBase == NULL ) {
         return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Round up the start of the work queue data structure to
    // the next cache line boundry
    //
    SrvWorkQueues = (PWORK_QUEUE)(((ULONG_PTR)SrvWorkQueuesBase + CACHE_LINE_SIZE-1) &
                    ~(CACHE_LINE_SIZE-1));
#endif


    eSrvWorkQueues = SrvWorkQueues + SrvNumberOfProcessors;

    RtlZeroMemory( SrvWorkQueues, (char *)eSrvWorkQueues - (char *)SrvWorkQueues );

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        KeInitializeQueue( &queue->Queue, 1 );
        queue->WaitMode         = SrvProductTypeServer ? KernelMode : UserMode;
        queue->MaxThreads       = SrvMaxThreadsPerQueue;
        queue->MaximumWorkItems = SrvMaxReceiveWorkItemCount / SrvNumberOfProcessors;
        queue->MinFreeWorkItems = SrvMinReceiveQueueLength / SrvNumberOfProcessors;
        queue->MaxFreeRfcbs     = SrvMaxFreeRfcbs;
        queue->MaxFreeMfcbs     = SrvMaxFreeMfcbs;
        ExInitializeSListHead(&queue->InitialWorkItemList);
        ExInitializeSListHead(&queue->NormalWorkItemList);
        ExInitializeSListHead(&queue->RawModeWorkItemList);
        ExInitializeSListHead(&queue->RfcbFreeList);
        ExInitializeSListHead(&queue->MfcbFreeList);
        queue->PagedPoolLookAsideList.MaxSize  = SrvMaxPagedPoolChunkSize;
        queue->NonPagedPoolLookAsideList.MaxSize  = SrvMaxNonPagedPoolChunkSize;
        queue->CreateMoreWorkItems.CurrentWorkQueue = queue;
        queue->CreateMoreWorkItems.BlockHeader.ReferenceCount = 1;
        queue->IdleTimeOut.QuadPart = SrvIdleThreadTimeOut;

        INITIALIZE_SPIN_LOCK( &queue->SpinLock );
        SET_SERVER_TIME( queue );

#if MULTIPROCESSOR
        StartQueueDepthComputations( queue );
#endif
    }

    RtlZeroMemory( &SrvDoSWorkItem, sizeof(SPECIAL_WORK_ITEM) );
    SrvDoSWorkItem.BlockHeader.ReferenceCount = 1;
    SrvDoSWorkItemTearDown = SRV_DOS_TEARDOWN_MIN;
    KeInitializeSpinLock( &SrvDosSpinLock );

    //
    // Init the Blocking work queue
    //


#if MULTIPROCESSOR

    if( SrvNumberOfProcessors < 4 )
    {
        i = 1 * sizeof( *SrvWorkQueues );
        i += CACHE_LINE_SIZE;
    }

    //
    // Allocate and init the nonblocking work queues, paying attention to cache lines
    //
    SrvBlockingWorkQueuesBase = ALLOCATE_NONPAGED_POOL( i, BlockTypeWorkQueue );

    if( SrvBlockingWorkQueuesBase == NULL ) {
         return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Round up the start of the work queue data structure to
    // the next cache line boundry
    //
    SrvBlockingWorkQueues = (PWORK_QUEUE)(((ULONG_PTR)SrvBlockingWorkQueuesBase + CACHE_LINE_SIZE-1) &
                    ~(CACHE_LINE_SIZE-1));
#endif


    eSrvBlockingWorkQueues = SrvBlockingWorkQueues + ( (SrvNumberOfProcessors<4) ? 1 : SrvNumberOfProcessors);

    RtlZeroMemory( SrvBlockingWorkQueues, (char *)eSrvBlockingWorkQueues - (char *)SrvBlockingWorkQueues );

    for( queue = SrvBlockingWorkQueues; queue < eSrvBlockingWorkQueues; queue++ ) {
        KeInitializeQueue( &queue->Queue, 1 );
        queue->WaitMode         = SrvProductTypeServer ? KernelMode : UserMode;
        queue->MaxThreads       = SrvMaxThreadsPerQueue*2;
        queue->IdleTimeOut.QuadPart = SrvIdleThreadTimeOut;

        INITIALIZE_SPIN_LOCK( &queue->SpinLock );
        SET_SERVER_TIME( queue );
    }

    //
    //  Initialize the LPC upcall work queue
    //
    RtlZeroMemory( &SrvLpcWorkQueue, sizeof(WORK_QUEUE) );
    KeInitializeQueue( &SrvLpcWorkQueue.Queue, 1 );
    SrvLpcWorkQueue.WaitMode = SrvProductTypeServer ? KernelMode : UserMode;
    SrvLpcWorkQueue.MaxThreads = SrvMaxThreadsPerQueue;
    SrvLpcWorkQueue.IdleTimeOut.QuadPart = SrvIdleThreadTimeOut;
    INITIALIZE_SPIN_LOCK( &SrvLpcWorkQueue.SpinLock );
    SET_SERVER_TIME( &SrvLpcWorkQueue );

    //
    // Build the receive work item list.
    //

    status = SrvAllocateInitialWorkItems( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Build the raw mode work item list, and spread it around
    //  the processors
    //

    queue = SrvWorkQueues;
    for ( i = 0; i < SrvInitialRawModeWorkItemCount; i++ ) {

        SrvAllocateRawModeWorkItem( &workContext, queue );

        if ( workContext == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        GET_SERVER_TIME( queue, &workContext->Timestamp );

        SrvRequeueRawModeWorkItem( workContext );

        if( ++queue == eSrvWorkQueues )
            queue = SrvWorkQueues;
    }

    //
    // Create worker threads.
    //

    status = SrvCreateWorkerThreads( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Initialize the scavenger.
    //

    status = SrvInitializeScavenger( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Initialize the global ordered lists.
    //
    // *** WARNING:  Be careful when changing the locks associated with
    //     these ordered lists.  Certain places in the code depend on
    //     the level of the lock associated with a list.  Examples
    //     include (but are NOT limited to) SrvSmbSessionSetupAndX,
    //     SrvSmbTreeConnect, SrvSmbTreeConnectAndX, and CompleteOpen.
    //

    SrvInitializeOrderedList(
        &SrvEndpointList,
        FIELD_OFFSET( ENDPOINT, GlobalEndpointListEntry ),
        SrvCheckAndReferenceEndpoint,
        SrvDereferenceEndpoint,
        &SrvEndpointLock
        );

    SrvInitializeOrderedList(
        &SrvRfcbList,
        FIELD_OFFSET( RFCB, GlobalRfcbListEntry ),
        SrvCheckAndReferenceRfcb,
        SrvDereferenceRfcb,
        &SrvOrderedListLock
        );

    SrvInitializeOrderedList(
        &SrvSessionList,
        FIELD_OFFSET( SESSION, GlobalSessionListEntry ),
        SrvCheckAndReferenceSession,
        SrvDereferenceSession,
        &SrvOrderedListLock
        );

    SrvInitializeOrderedList(
        &SrvTreeConnectList,
        FIELD_OFFSET( TREE_CONNECT, GlobalTreeConnectListEntry ),
        SrvCheckAndReferenceTreeConnect,
        SrvDereferenceTreeConnect,
        &SrvShareLock
        );

    //
    // Open handle to NPFS.  Do not return an error if we fail so that
    // the server can still run without NPFS in the system.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &SrvNamedPipeRootDirectory,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                &SrvNamedPipeHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeNone,     // File type
                NULL,                   // ExtraCreateParameters
                IO_FORCE_ACCESS_CHECK   // Options
                );

    if (!NT_SUCCESS(status)) {

        INTERNAL_ERROR (
            ERROR_LEVEL_EXPECTED,
            "InitializeServer: Failed to open NPFS, err=%X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_IO_CREATE_FILE_NPFS, status );
        SrvNamedPipeHandle = NULL;
        return status;

    } else {

        //
        // Get a pointer to the NPFS device object
        //

        status = SrvVerifyDeviceStackSize(
                                SrvNamedPipeHandle,
                                TRUE,
                                &SrvNamedPipeFileObject,
                                &SrvNamedPipeDeviceObject,
                                &handleInformation
                                );

        if ( !NT_SUCCESS( status )) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "InitializeServer: Verify Device Stack Size failed: %X\n",
                status,
                NULL
                );

            SrvNtClose( SrvNamedPipeHandle, FALSE );
            SrvNamedPipeHandle = NULL;
            return status;
        }
    }

    //
    // Initialize Dfs operations
    //
    SrvInitializeDfs();

    //
    // Intialize SrvAdminSecurityDescriptor, which allows Administrators READ access.
    //   This descriptor is used by the server to check if a user is an administrator
    //   in SrvIsAdmin().

    status = RtlCreateSecurityDescriptor( &SrvAdminSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Create an admin SID
    //
    AdminSid  = ALLOCATE_HEAP_COLD( RtlLengthRequiredSid( 2 ), BlockTypeAdminCheck );
    if( AdminSid == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeSid( AdminSid, &BuiltinAuthority, (UCHAR)2 );
    *(RtlSubAuthoritySid( AdminSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    length = sizeof(ACL) + sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( AdminSid );
    Acl = ALLOCATE_HEAP_COLD( length, BlockTypeAdminCheck );
    if( Acl == NULL ) {
        FREE_HEAP( AdminSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( Acl, length, ACL_REVISION2 );

    if( NT_SUCCESS( status ) ) {
        status = RtlAddAccessAllowedAce( Acl, ACL_REVISION2, FILE_GENERIC_READ, AdminSid );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetDaclSecurityDescriptor( &SrvAdminSecurityDescriptor, TRUE, Acl, FALSE );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetOwnerSecurityDescriptor( &SrvAdminSecurityDescriptor, AdminSid, FALSE );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Intialize SrvNullSessionSecurityDescriptor, which allows anonymous
    // logons READ access. This descriptor is used by the server to check
    // if a user is an null session in SrvIsNullSession().
    //

    status = RtlCreateSecurityDescriptor( &SrvNullSessionSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Create an anonymous SID
    //
    AnonymousSid  = ALLOCATE_HEAP_COLD( RtlLengthRequiredSid( 1 ), BlockTypeAdminCheck );
    if( AnonymousSid == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeSid( AnonymousSid, &BuiltinAuthority, (UCHAR)1 );
    *(RtlSubAuthoritySid( AnonymousSid, 0 )) = SECURITY_ANONYMOUS_LOGON_RID;

    length = sizeof(ACL) + sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( AnonymousSid );
    Acl = ALLOCATE_HEAP_COLD( length, BlockTypeAdminCheck );
    if( Acl == NULL ) {
        FREE_HEAP( AnonymousSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( Acl, length, ACL_REVISION2 );

    if( NT_SUCCESS( status ) ) {
        status = RtlAddAccessAllowedAce( Acl, ACL_REVISION2, FILE_GENERIC_READ, AnonymousSid );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetDaclSecurityDescriptor( &SrvNullSessionSecurityDescriptor, TRUE, Acl, FALSE );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetOwnerSecurityDescriptor( &SrvNullSessionSecurityDescriptor, AnonymousSid, FALSE );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    (VOID) InitSecurityInterface();

    status = SrvValidateUser(
                &SrvNullSessionToken,
                NULL,
                NULL,
                NULL,
                StrNullAnsi,
                1,
                NULL,
                0,
                FALSE,
                NULL
                );

    if ( !NT_SUCCESS(status) ) {

        //
        // LSA doesn't want to let the null session in.  He's the boss!
        //
        INVALIDATE_SECURITY_HANDLE( SrvNullSessionToken );
    }

    //
    // See if the filesystems are allowing extended characters in 8.3 names.  If
    //  so, we need to filter them out ourself.
    //
    RtlInitUnicodeString( &string, StrRegExtendedCharsInPath );
    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    status = ZwOpenKey( &handle, KEY_READ, &objectAttributes );

    if( NT_SUCCESS( status ) ) {
        ULONG resultLength;
        union {
            KEY_VALUE_FULL_INFORMATION;
            UCHAR   buffer[ sizeof( KEY_VALUE_FULL_INFORMATION ) + 100 ];
        } keyValueInformation;

        RtlInitUnicodeString( &string, StrRegExtendedCharsInPathValue );
        status = ZwQueryValueKey( handle,
                                  &string,
                                  KeyValueFullInformation,
                                  &keyValueInformation,
                                  sizeof( keyValueInformation ),
                                  &resultLength
                                );

        if( NT_SUCCESS( status ) &&
            keyValueInformation.Type == REG_DWORD &&
            keyValueInformation.DataLength != 0 ) {

            SrvFilterExtendedCharsInPath =
                *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset) ?
                TRUE : FALSE;
        }

        ZwClose( handle );
    }

    //
    // Get a handle to use in PoRegisterSystemState() calls
    //
    SrvPoRegistrationState = PoRegisterSystemState( NULL, 0 );

    //
    // Indicate that the server is active.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    SrvFspTransitioning = FALSE;
    SrvFspActive = TRUE;

    RELEASE_LOCK( &SrvConfigurationLock );

    return STATUS_SUCCESS;

} // InitializeServer


STATIC
NTSTATUS
TerminateServer ( VOID )

/*++

Routine Description:

    This routine terminates the server.  The following steps are performed:

        - Walk through SrvEndpointList and close all open endpoints.

        - Walk through the work context blocks in the work queues
            getting rid of them as appropiate

        - Close all shares open in the server

        - Deallocate the search table

Arguments:

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PSLIST_ENTRY singleListEntry;
    PENDPOINT endpoint;
    ULONG numberOfThreads;
    PWORK_CONTEXT workContext;
    PSHARE share;
    ULONG i;
    SPECIAL_WORK_ITEM WorkItem;
    PSRV_TIMER timer;
    PSID adminsid;
    PSID anonymoussid;
    PACL acl;
    BOOLEAN defaulted;
    BOOLEAN daclpresent;
    NTSTATUS status;
    PWORK_QUEUE queue;
    PIRP irp;
    PLIST_ENTRY listEntryRoot;

    PAGED_CODE( );

    IF_DEBUG(FSP1) KdPrint(( "LAN Manager server FSP terminating.\n" ));

    //
    // Do not receive PNP notifications anymore
    //
    if( SrvTdiNotificationHandle != NULL ) {

        status = TdiDeregisterPnPHandlers( SrvTdiNotificationHandle );

        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "TdiDeregisterPnPHandlers status %X\n", status ));
            SrvLogServiceFailure( SRV_SVC_PNP_TDI_NOTIFICATION, status );
            return status;
        }

        SrvTdiNotificationHandle = NULL;
    }

    //
    // Make sure we are not processing any other configuration IRPs.  We know
    //  that no new configuration IRPs can enter the queue because SrvFspTransitioning
    //  has been set.
    //
    // First drain the configuration queue
    //
    while( 1 ) {

        ACQUIRE_LOCK( &SrvConfigurationLock );

        irp = DequeueConfigurationIrp( );

        RELEASE_LOCK( &SrvConfigurationLock );

        if( irp == NULL ) {
            break;
        }

        irp->IoStatus.Status = STATUS_SERVER_NOT_STARTED;
        IoCompleteRequest( irp, 2 );
        InterlockedDecrement( (PLONG)&SrvConfigurationIrpsInProgress );
    }

    //
    // Now wait until any already dequeued configuration IRPs have been completed.  We
    //  check for >1 because we need to account for our own IRP
    //
    while( SrvConfigurationIrpsInProgress > 1 ) {

        LARGE_INTEGER interval;

        interval.QuadPart = -1*10*1000*10; // .01 second

        ASSERT( (LONG)SrvConfigurationIrpsInProgress > 0 );

        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    //
    // If there are outstanding API requests in the server FSD,
    // wait for them to complete.  The last one to complete will
    // set SrvApiCompletionEvent.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    if( SrvLWIOContext )
    {
        FREE_HEAP( SrvLWIOContext );
        SrvLWIOContext = NULL;
    }

    if ( SrvApiRequestCount != 0 ) {

        //
        // We must release the lock before waiting so that the FSD
        // threads can get it to decrement SrvApiRequestCount.
        //

        RELEASE_LOCK( &SrvConfigurationLock );


        for (;;) {
            NTSTATUS WaitStatus;

            //
            // Wait until the last API has completed.  Since
            // SrvFspTransitioning was set to TRUE earlier, we know that the
            // API that makes SrvApiRequestCount go to zero will set the
            // event.
            //
            // This wait allows us to make the assumption later on that no
            // other thread is operating on server data structures.
            //

            WaitStatus = KeWaitForSingleObject(
                             &SrvApiCompletionEvent,
                             UserRequest,
                             UserMode,   // let kernel stack be paged
                             FALSE,
                             NULL
                         );

            if (WaitStatus != STATUS_USER_APC) {
                break;
            }
        }

    } else {

        RELEASE_LOCK( &SrvConfigurationLock );
    }


    //
    // Close all the endpoints opened by the server.  This also results
    // in the connections, sessions, tree connects, and files opened
    // by the server being closed.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    if ( SrvEndpointCount != 0 ) {

        listEntry = SrvEndpointList.ListHead.Flink;

        while ( listEntry != &SrvEndpointList.ListHead ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
                listEntry = listEntry->Flink;
                continue;
            }

            //
            // We don't want to hold the endpoint lock while we close
            // the endpoint (this causes lock level problems), so we have
            // to play some games.
            //
            // Reference the endpoint to ensure that it doesn't go away.
            // (We'll need its Flink later.)  Close the endpoint.  This
            // releases the endpoint lock.  Reacquire the endpoint lock.
            // Capture the address of the next endpoint.  Dereference the
            // current endpoint.
            //

            SrvReferenceEndpoint( endpoint );
            SrvCloseEndpoint( endpoint );

            ACQUIRE_LOCK( &SrvEndpointLock );

            listEntry = listEntry->Flink;
            SrvDereferenceEndpoint( endpoint );

        }

        RELEASE_LOCK( &SrvEndpointLock );

        for (;;) {
            NTSTATUS WaitStatus;

            //
            // Wait until all the endpoints have actually closed.
            //

            WaitStatus = KeWaitForSingleObject(
                            &SrvEndpointEvent,
                            UserRequest,
                            UserMode,   // let kernel stack be paged
                            FALSE,
                            NULL
                            );

            if (WaitStatus != STATUS_USER_APC) {
                break;
            }
        }

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    KeClearEvent( &SrvEndpointEvent );

    //
    // All the endpoints are closed, so it's impossible for there to
    // be any outstanding requests to xactsrv.  So shut it down.
    //
    SrvXsDisconnect();

    //
    // Queue a special work item to each of the work queues.  This
    // work item, when received by a worker thread. causes the thread
    // to requeue the work item and terminate itself.  In this way,
    // each of the worker threads receives the work item and kills
    // itself.
    //

    WorkItem.FspRestartRoutine = SrvTerminateWorkerThread;
    SET_BLOCK_TYPE( &WorkItem, BlockTypeWorkContextSpecial );

    //
    // Kill the threads on the nonblocking work queues
    //

    if ( SrvWorkQueues != NULL ) {

        for( queue=SrvWorkQueues; queue && queue < eSrvWorkQueues; queue++ ) {

            WorkItem.CurrentWorkQueue = queue;

            SrvInsertWorkQueueTail(
                queue,
                (PQUEUEABLE_BLOCK_HEADER)&WorkItem
                );

            //
            // Wait for the threads to all die
            //
            while( queue->Threads != 0 ) {

                LARGE_INTEGER interval;

                interval.QuadPart = -1*10*1000*10; // .01 second

                KeDelayExecutionThread( KernelMode, FALSE, &interval );
            }

            KeRundownQueue( &queue->Queue );
        }
    }

    //
    // Kill the threads on the blocking work queues
    //

    if( SrvBlockingWorkQueues != NULL )
    {
        for( queue=SrvBlockingWorkQueues; queue && queue < eSrvBlockingWorkQueues; queue++ ) {

            WorkItem.CurrentWorkQueue = queue;

            SrvInsertWorkQueueTail(
                queue,
                (PQUEUEABLE_BLOCK_HEADER)&WorkItem
                );

            //
            // Wait for the threads to all die
            //
            while( queue->Threads != 0 ) {

                LARGE_INTEGER interval;

                interval.QuadPart = -1*10*1000*10; // .01 second

                KeDelayExecutionThread( KernelMode, FALSE, &interval );
            }

            KeRundownQueue( &queue->Queue );
        }

        //
        // Kill all the threads in the LPC work queue
        // Note that if the Blocking Work Queues were successfully allocated, we're
        // guaranteed that the LPC queue was successfully initialized.
        //
        WorkItem.CurrentWorkQueue = &SrvLpcWorkQueue;

        SrvInsertWorkQueueTail(
            &SrvLpcWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)&WorkItem
            );

        //
        // Wait for the threads to all die
        //
        while( SrvLpcWorkQueue.Threads != 0 )
        {
            LARGE_INTEGER interval;

            interval.QuadPart = -1*10*1000*10; // .01 second

            KeDelayExecutionThread( KernelMode, FALSE, &interval );
        }

        KeRundownQueue( &SrvLpcWorkQueue.Queue );

    }

    //
    // Free any space allocated for the Null Session pipe and share lists
    //
    SrvFreeRegTables();

    //
    // If we allocated memory for the os version strings, free it now.
    //

    if ( SrvNativeOS.Buffer != NULL &&
         SrvNativeOS.Buffer != StrDefaultNativeOs ) {

        FREE_HEAP( SrvNativeOS.Buffer );
        SrvNativeOS.Buffer = NULL;

        RtlFreeOemString( &SrvOemNativeOS );
        SrvOemNativeOS.Buffer = NULL;

        FREE_HEAP( SrvNativeLanMan.Buffer );
        SrvNativeLanMan.Buffer = NULL;

        RtlFreeOemString( &SrvOemNativeLanMan );
        SrvOemNativeLanMan.Buffer = NULL;
    }

    //
    // If allocated memory for the display name, free it now.
    //

    if ( SrvAlertServiceName != NULL &&
         SrvAlertServiceName != StrDefaultSrvDisplayName ) {

        FREE_HEAP( SrvAlertServiceName );
        SrvAlertServiceName = NULL;
    }

    //
    // Make sure the scavenger is not running.
    //

    SrvTerminateScavenger( );

#if MULTIPROCESSOR
    if( SrvWorkQueues ) {
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
            StopQueueDepthComputations( queue );
        }
    }
#endif


    //
    // Free the work items in the work queues and the receive work item
    // list.  This also deallocates the SMB buffers.  Note that work
    // items allocated dynamically may be deallocated singly, while work
    // items allocated at server startup are part of one large block,
    // and may not be deallocated singly.
    //
    // !!! Does this properly clean up buffers allocated during SMB
    //     processing?  Probably not.  Should probably allow the worker
    //     threads to run the work queue normally before they stop.
    //

    if( SrvWorkQueues ) {

        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

            //
            // Clean out the single FreeContext spot
            //
            workContext = NULL;
            workContext = (PWORK_CONTEXT)InterlockedExchangePointer(
                                            &queue->FreeContext, workContext );

            if( workContext != NULL && workContext->PartOfInitialAllocation == FALSE ) {
                SrvFreeNormalWorkItem( workContext );
            }

            //
            // Clean out the normal work item list
            //
            while( 1 ) {
                singleListEntry = ExInterlockedPopEntrySList(
                                            &queue->NormalWorkItemList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }
                workContext =
                    CONTAINING_RECORD( singleListEntry, WORK_CONTEXT, SingleListEntry );

                SrvFreeNormalWorkItem( workContext );
                queue->FreeWorkItems--;
            }

            //
            // Clean out the raw mode work item list
            //
            while( 1 ) {
                singleListEntry = ExInterlockedPopEntrySList(
                                            &queue->RawModeWorkItemList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                workContext =
                    CONTAINING_RECORD( singleListEntry, WORK_CONTEXT, SingleListEntry );

                SrvFreeRawModeWorkItem( workContext );
            }

            //
            // Free up any saved rfcbs
            //
            if( queue->CachedFreeRfcb != NULL ) {
                FREE_HEAP( queue->CachedFreeRfcb->PagedRfcb );
                DEALLOCATE_NONPAGED_POOL( queue->CachedFreeRfcb );
                queue->CachedFreeRfcb = NULL;
            }

            while( 1 ) {
                PRFCB Rfcb;

                singleListEntry = ExInterlockedPopEntrySList( &queue->RfcbFreeList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                Rfcb =
                    CONTAINING_RECORD( singleListEntry, RFCB, SingleListEntry );
                FREE_HEAP( Rfcb->PagedRfcb );
                DEALLOCATE_NONPAGED_POOL( Rfcb );
            }

            //
            // Free up any saved mfcbs
            //
            if( queue->CachedFreeMfcb != NULL ) {
                DEALLOCATE_NONPAGED_POOL( queue->CachedFreeMfcb );
                queue->CachedFreeMfcb = NULL;
            }

            while( 1 ) {
                PNONPAGED_MFCB nonpagedMfcb;

                singleListEntry = ExInterlockedPopEntrySList( &queue->MfcbFreeList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                nonpagedMfcb =
                    CONTAINING_RECORD( singleListEntry, NONPAGED_MFCB, SingleListEntry );

                DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
            }
        }

    } // SrvWorkQueues

    //
    // All dynamic work items have been freed, and the work item queues
    // have been emptied.  Release the initial work item allocation.
    //
    SrvFreeInitialWorkItems( );

    //
    // Walk through the global share list, closing them all.
    //

    for( listEntryRoot = SrvShareHashTable;
         listEntryRoot < &SrvShareHashTable[ NSHARE_HASH_TABLE ];
         listEntryRoot++ ) {

        while( listEntryRoot->Flink != listEntryRoot ) {

            share = CONTAINING_RECORD( listEntryRoot->Flink, SHARE, GlobalShareList );

            SrvCloseShare( share );
        }
    }

    //
    // If we opened the NPFS during initialization, close the handle now
    // and dereference the NPFS file object.
    //

    if ( SrvNamedPipeHandle != NULL) {

        SrvNtClose( SrvNamedPipeHandle, FALSE );
        ObDereferenceObject( SrvNamedPipeFileObject );

        SrvNamedPipeHandle = NULL;

    }

    //
    // Disconnect from the Dfs driver
    //
    SrvTerminateDfs();

    //
    // Clean up the Dns Domain Name if necessary
    //
    if( SrvDnsDomainName )
    {
        DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
        SrvDnsDomainName = NULL;
    }

    //
    // Clean up the admin security descriptor
    //


    status = RtlGetDaclSecurityDescriptor( &SrvAdminSecurityDescriptor,
                                           &daclpresent,
                                           &acl,
                                           &defaulted );
    if( !NT_SUCCESS( status ) || !daclpresent ) {
        acl = NULL;
    }

    status = RtlGetOwnerSecurityDescriptor( &SrvAdminSecurityDescriptor,
                                            &adminsid,
                                            &defaulted );

    if( NT_SUCCESS( status ) && adminsid != NULL ) {
        FREE_HEAP( adminsid );
    }

    if( acl != NULL ) {
        FREE_HEAP( acl );
    }

    //
    // Clean up the null session security descriptor
    //

    status = RtlGetDaclSecurityDescriptor( &SrvNullSessionSecurityDescriptor,
                                           &daclpresent,
                                           &acl,
                                           &defaulted );
    if( !NT_SUCCESS( status ) || !daclpresent ) {
        acl = NULL;
    }

    status = RtlGetOwnerSecurityDescriptor( &SrvNullSessionSecurityDescriptor,
                                            &anonymoussid,
                                            &defaulted );

    if( NT_SUCCESS( status ) && anonymoussid != NULL ) {
        FREE_HEAP( anonymoussid );
    }

    if( acl != NULL ) {
        FREE_HEAP( acl );
    }


    if (!CONTEXT_NULL(SrvNullSessionToken)) {
        DeleteSecurityContext(&SrvNullSessionToken);
        INVALIDATE_SECURITY_HANDLE( SrvNullSessionToken );
    }

    //
    // Delete the global ordered lists.
    //

    SrvDeleteOrderedList( &SrvEndpointList );
    SrvDeleteOrderedList( &SrvRfcbList );
    SrvDeleteOrderedList( &SrvSessionList );
    SrvDeleteOrderedList( &SrvTreeConnectList );

    //
    // Clear out the timer pool.
    //

    while ( (singleListEntry = ExInterlockedPopEntrySList(
                                    &SrvTimerList,
                                    &GLOBAL_SPIN_LOCK(Timer) )) != NULL ) {
        timer = CONTAINING_RECORD( singleListEntry, SRV_TIMER, Next );
        DEALLOCATE_NONPAGED_POOL( timer );
    }

    if( SrvWorkQueues ) {

        //
        // Clear out the saved pool chunks
        //
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
            //
            // Free up any paged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->PagedPoolLookAsideList, SrvFreePagedPool );

            //
            // Free up any nonpaged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
        }

#if MULTIPROCESSOR
        DEALLOCATE_NONPAGED_POOL( SrvWorkQueuesBase );
        SrvWorkQueuesBase = NULL;
        SrvWorkQueues = NULL;
#endif
    }

    if( SrvBlockingWorkQueues ) {
        //
        // Clear out the saved pool chunks
        //
        for( queue = SrvBlockingWorkQueues; queue < eSrvBlockingWorkQueues; queue++ ) {
            //
            // Free up any paged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->PagedPoolLookAsideList, SrvFreePagedPool );

            //
            // Free up any nonpaged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
        }

#if MULTIPROCESSOR
        DEALLOCATE_NONPAGED_POOL( SrvBlockingWorkQueuesBase );
        SrvBlockingWorkQueuesBase = NULL;
        SrvBlockingWorkQueues = NULL;
#endif

        SrvClearLookAsideList( &SrvLpcWorkQueue.PagedPoolLookAsideList, SrvFreePagedPool );
        SrvClearLookAsideList( &SrvLpcWorkQueue.NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
    }

    //
    // Unlock pageable sections.
    //

    for ( i = 0; i < SRV_CODE_SECTION_MAX; i++ ) {
        if ( SrvSectionInfo[i].Handle != NULL ) {
            ASSERT( SrvSectionInfo[i].ReferenceCount != 0 );
            MmUnlockPagableImageSection( SrvSectionInfo[i].Handle );
            SrvSectionInfo[i].Handle = 0;
            SrvSectionInfo[i].ReferenceCount = 0;
        }
    }

    //
    // Zero out the statistics database.
    //

    RtlZeroMemory( &SrvStatistics, sizeof(SrvStatistics) );
#if SRVDBG_STATS || SRVDBG_STATS2
    RtlZeroMemory( &SrvDbgStatistics, sizeof(SrvDbgStatistics) );
#endif

    //
    // Free the handle used in PoRegisterSystemState
    //
    if( SrvPoRegistrationState != NULL ) {
        PoUnregisterSystemState( SrvPoRegistrationState );
        SrvPoRegistrationState = NULL;
    }

    //
    // Uninitialize WMI if we registered
    //
    if (SrvWmiInitialized) {
        // Deregister WMI
        //
        SrvWmiInitialized = FALSE;
        IoWMIRegistrationControl(SrvDeviceObject, WMIREG_ACTION_DEREGISTER);
    }

    //
    // Indicate that the server is no longer active.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    SrvFspTransitioning = FALSE;
    SrvFspActive = FALSE;
    SrvSvcProcess = NULL;

    RELEASE_LOCK( &SrvConfigurationLock );

    IF_DEBUG(FSP1) KdPrint(( "LAN Manager server FSP termination complete.\n" ));

    return STATUS_SUCCESS;

} // TerminateServer

VOID
SrvFreeRegTables (
    VOID
    )
/*++

Routine Description:

    This routine frees space allocated for the list of legal Null session shares
     and pipes.  The SrvConfigurationLock must be held when this routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    //
    // If we allocated a buffer for the list of null session pipes,
    // free it now.
    //

    if ( SrvNullSessionPipes != NULL &&
         SrvNullSessionPipes != StrDefaultNullSessionPipes ) {

        FREE_HEAP( SrvNullSessionPipes );
    }
    SrvNullSessionPipes = NULL;

    if( SrvNoRemapPipeNames != NULL &&
        SrvNoRemapPipeNames != StrDefaultNoRemapPipeNames ) {

        FREE_HEAP( SrvNoRemapPipeNames );
    }
    SrvNoRemapPipeNames = NULL;


    if ( SrvPipesNeedLicense != NULL &&
         SrvPipesNeedLicense != StrDefaultPipesNeedLicense ) {

        FREE_HEAP( SrvPipesNeedLicense );
    }
    SrvPipesNeedLicense = NULL;

    if ( SrvNullSessionShares != NULL &&
         SrvNullSessionShares != StrDefaultNullSessionShares ) {

        FREE_HEAP( SrvNullSessionShares );
    }
    SrvNullSessionShares = NULL;

#if SRVNTVERCHK
    if( SrvInvalidDomainNames != NULL ) {
        FREE_HEAP( SrvInvalidDomainNames );
    }
    SrvInvalidDomainNames = NULL;
#endif

#if SRVCATCH
    if( SrvCatchBuf != NULL ) {
        FREE_HEAP( SrvCatchBuf );
        SrvCatchBuf = NULL;
    }
    if( SrvCatchExtBuf != NULL ) {
        FREE_HEAP( SrvCatchExtBuf );
        SrvCatchExtBuf = NULL;
    }
    if( SrvCatchShareNames != NULL ) {
        FREE_HEAP( SrvCatchShareNames );
        SrvCatchShareNames = NULL;
        SrvCatchShares = 0;
        CleanupCrcTable();
    }
#endif
}

VOID
SrvGetRegTables (
    VOID
    )
/*++

Routine Description:

    This routine loads the lists of valid shares and pipes for null sessions.
      The SrvConfigurationLock must be held when this routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PWSTR *strErrorLogIgnore;
    DWORD dwSetting;

    PAGED_CODE( );

    //
    // Get the list of null session pipes.
    //
    ASSERT( SrvNullSessionPipes == NULL );
    SrvGetMultiSZList(
            &SrvNullSessionPipes,
            StrRegSrvParameterPath,
            StrRegNullSessionPipes,
            StrDefaultNullSessionPipes
            );

    //
    // Get the list of non-remappable pipe names
    //
    ASSERT( SrvNoRemapPipeNames == NULL );
    SrvGetMultiSZList(
            &SrvNoRemapPipeNames,
            StrRegSrvParameterPath,
            StrRegNoRemapPipes,
            StrDefaultNoRemapPipeNames
            );

    //
    // Get the list of pipes requiring licenses
    //
    ASSERT( SrvPipesNeedLicense == NULL );
    SrvGetMultiSZList(
            &SrvPipesNeedLicense,
            StrRegSrvParameterPath,
            StrRegPipesNeedLicense,
            StrDefaultPipesNeedLicense
            );

    //
    // Get the list of null session pipes.
    //
    ASSERT( SrvNullSessionShares == NULL );
    SrvGetMultiSZList(
            &SrvNullSessionShares,
            StrRegSrvParameterPath,
            StrRegNullSessionShares,
            StrDefaultNullSessionShares
            );

    //
    // These are the security signature settings
    //
    SrvSmbSecuritySignaturesRequired = FALSE;
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegRequireSecuritySignatures, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvSmbSecuritySignaturesRequired = TRUE;
        }
    }

    SrvSmbSecuritySignaturesEnabled = FALSE;
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegEnableSecuritySignatures, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvSmbSecuritySignaturesEnabled = TRUE;
        }
    }

    SrvEnableExtendedSignatures = SrvSmbSecuritySignaturesEnabled;
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegEnableExtendedSignatures, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvEnableExtendedSignatures = TRUE;
        }
        else
        {
            SrvEnableExtendedSignatures = FALSE;
        }
    }

    SrvRequireExtendedSignatures = FALSE;
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegRequireExtendedSignatures, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvRequireExtendedSignatures = TRUE;
        }
    }

    // Precedence settings
    // RequireExtended implies RequireSignatures and EnableExtended
    if( SrvRequireExtendedSignatures )
    {
        SrvSmbSecuritySignaturesRequired = TRUE;
        SrvEnableExtendedSignatures = TRUE;
    }

    // EnableExtended implies EnableSignatures
    if( SrvEnableExtendedSignatures ) {
        SrvSmbSecuritySignaturesEnabled = TRUE;
    }

    // RequireSignature implies EnableSignature
    if( SrvSmbSecuritySignaturesRequired )
    {
        SrvSmbSecuritySignaturesEnabled = TRUE;
    }

    //
    // Should we disable large read/write ops?
    //
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegDisableLargeRead, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvDisableLargeRead = TRUE;
        }
        else
        {
            SrvDisableLargeRead = FALSE;
        }
    }
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegDisableLargeWrite, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvDisableLargeWrite = TRUE;
        }
        else
        {
            SrvDisableLargeWrite = FALSE;
        }
    }
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegMapNoIntermediateBuffering, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvMapNoIntermediateBuffering = TRUE;
        }
        else
        {
            SrvMapNoIntermediateBuffering = FALSE;
        }
    }
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegNoAliasingOnFilesystem, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvNoAliasingOnFilesystem = TRUE;
        }
        else
        {
            SrvNoAliasingOnFilesystem = FALSE;
        }
    }

    SrvDisableDownlevelTimewarp = TRUE;
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegDisableDownlevelTimewarp, &dwSetting ) ) )
    {
        if( dwSetting == 0 )
        {
            SrvDisableDownlevelTimewarp = FALSE;
        }
    }

    //
    // Should we log invalid SMB commands?
    //
#if DBG
    SrvEnableInvalidSmbLogging = TRUE;
#else
    SrvEnableInvalidSmbLogging = FALSE;
#endif
    if( NT_SUCCESS( SrvGetDWord( StrRegSrvParameterPath, StrRegEnableInvalidSmbLogging, &dwSetting ) ) )
    {
        if( dwSetting != 0 )
        {
            SrvEnableInvalidSmbLogging = TRUE;
        }
        else
        {
            SrvEnableInvalidSmbLogging = FALSE;
        }
    }

#if SRVCATCH
    {
    USHORT i;

    SrvCatch.Length = 0;
    SrvCatch.Buffer = 0;
    if( SrvCatchBuf != NULL ) {
        FREE_HEAP( SrvCatchBuf );
        SrvCatchBuf = NULL;
    }

    SrvGetMultiSZList(
                &SrvCatchBuf,
                StrRegSrvParameterPath,
                L"CheckFile",
                0
                );

    if( SrvCatchBuf != NULL ) {
        SrvCatch.Buffer = SrvCatchBuf[0];
        for( i = 0; SrvCatch.Buffer[i]; i++ )
            ;
        SrvCatch.Length = i * sizeof( SrvCatch.Buffer[0] );
    }

    SrvCatchExt.Length = 0;
    SrvCatchExt.Buffer = 0;
    if( SrvCatchExtBuf != NULL )
    {
        FREE_HEAP( SrvCatchExtBuf );
        SrvCatchExtBuf = NULL;
    }
    SrvGetMultiSZList(
                &SrvCatchExtBuf,
                StrRegSrvParameterPath,
                L"CheckExtension",
                0
                );

    if( SrvCatchExtBuf != NULL ) {
        SrvCatchExt.Buffer = SrvCatchExtBuf[0];
        for( i = 0; SrvCatchExt.Buffer[i]; i++ )
            ;
        SrvCatchExt.Length = i * sizeof( SrvCatchExt.Buffer[0] );
    }
    if( SrvCatchShareNames != NULL )
    {
        FREE_HEAP( SrvCatchShareNames );
        SrvCatchShareNames = NULL;
    }
    SrvGetMultiSZList(
        &SrvCatchShareNames,
        StrRegSrvParameterPath,
        L"CheckShares",
        0
        );
    if( SrvCatchShareNames != NULL )
    {
        for( i=0; SrvCatchShareNames[i]; i++ ) ;
        SrvCatchShares = i;
    }

    if( SrvCatchShares > 0 )
    {
        if( !GenerateCrcTable() )
        {
            FREE_HEAP( SrvCatchShareNames );
            SrvCatchShareNames = NULL;
            SrvCatchShares = 0;
        }
    }
    }
#endif

    //
    // Get the list of error codes that we don't log
    //

    SrvGetMultiSZList(
            &strErrorLogIgnore,
            StrRegSrvParameterPath,
            StrRegErrorLogIgnore,
            StrDefaultErrorLogIgnore
            );

    if( strErrorLogIgnore != NULL ) {
        DWORD i;

        //
        // They came in as strings, convert to NTSTATUS codes
        //
        for( i=0; i < SRVMAXERRLOGIGNORE; i++ ) {
            NTSTATUS Status;
            PWSTR p;

            if( (p = strErrorLogIgnore[i]) == NULL )
                break;

            for( Status = 0; *p; p++ ) {
                if( *p >= L'A' && *p <= L'F' ) {
                    Status <<= 4;
                    Status += 10 + (*p - L'A');
                } else if( *p >= '0' && *p <= '9' ) {
                    Status <<= 4;
                    Status += *p - L'0';
                }
            }

            SrvErrorLogIgnore[i] = Status;

            IF_DEBUG(FSP1) KdPrint(( "LAN Manager server:  %X errs not logged\n", Status ));
        }
        SrvErrorLogIgnore[i] = 0;

        if( strErrorLogIgnore != StrDefaultErrorLogIgnore ) {
            FREE_HEAP( strErrorLogIgnore );
        }
    }

#if SRVNTVERCHK
    //
    // Get the list of Domains that we disallow if the client
    //  is running NT5
    //
    ASSERT( SrvInvalidDomainNames == NULL );
    SrvGetMultiSZList(
            &SrvInvalidDomainNames,
            StrRegSrvParameterPath,
            StrRegInvalidDomainNames,
            NULL
            );

    if( SrvInvalidDomainNames != NULL ) {

        int i;

        KdPrint(( "SRV disallows NT5 clients from the following domains:\n" ));
        for( i = 0; SrvInvalidDomainNames[i]; i++ ) {
            KdPrint(( " %ws\n", SrvInvalidDomainNames[i] ));
        }
    }

    //
    // Get the list of IP addresses of clients that we will allow to connect
    //  regardless of build number
    //
    {
    PWSTR *strAllowedIPAddresses;
    int i;

    //
    // Wipe out the current list
    //
    RtlZeroMemory( SrvAllowIPAddress, sizeof( SrvAllowIPAddress ) );

    SrvGetMultiSZList(
        &strAllowedIPAddresses,
        StrRegSrvParameterPath,
        StrRegAllowedIPAddresses,
        NULL
        );

    if( strAllowedIPAddresses != NULL ) {

        KdPrint(( "SRV ignores NT build version of clients at following IP addrs:\n" ));
        //
        // Fill it with the new ones
        //
        for(i = 0;
            strAllowedIPAddresses[i] &&
             i < (sizeof(SrvAllowIPAddress)/sizeof(SrvAllowIPAddress[0]))-1;
            i++ ) {

            LPWSTR p;
            DWORD addr = 0;
            char *s = (char *)&addr;

            //
            // Convert the IP address to a DWORD and store it
            //
            for( p = strAllowedIPAddresses[i]; *p && s < ((char *)&addr)+sizeof(addr); p++ ) {
                if( *p == L'.' ) {
                    s++;
                } else if( *p >= '0' && *p <= '9' ) {
                    *s = (*s * 10) + (*p - L'0');
                }
            }

            SrvAllowIPAddress[i] = addr;

            KdPrint(( "    %ws\n", strAllowedIPAddresses[i] ));

        }
        FREE_HEAP( strAllowedIPAddresses );
    }

    }
#endif
}

#if SRVNTVERCHK
VOID
SrvGetRegClientNumber (
    VOID
    )
/*++

Routine Description:

    This routine reads MinNt5Client REG_DWORD from the registry and sets
    the global SrvMinNT5Client to the retrieved value.  Later, if a client
    running >= NT5 with a build number less than SrvMinNT5Client tries to
    connect to a disk share, we reject the connection.  This mechanism
    is used on our SLM servers to ensure that people are upgrading to
    current builds.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG lengthNeeded;
    NTSTATUS status;

    PAGED_CODE( );

    SrvMinNT5Client = 0;
    SrvMinNT5ClientIPCToo = FALSE;

    RtlInitUnicodeString( &unicodeParamPath, StrRegSrvParameterPath );
    RtlInitUnicodeString( &unicodeKeyName, L"MinNT5Client" );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );


    if ( NT_SUCCESS(status) ) {

        status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValuePartialInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

        if( status != STATUS_BUFFER_TOO_SMALL ) {

            RtlInitUnicodeString( &unicodeKeyName, L"MinNT5ClientIPC" );

            status = ZwQueryValueKey(
                            keyHandle,
                            &unicodeKeyName,
                            KeyValuePartialInformation,
                            NULL,
                            0,
                            &lengthNeeded
                            );

            SrvMinNT5ClientIPCToo = TRUE;
        }

        if( status == STATUS_BUFFER_TOO_SMALL ) {

            infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

            if( infoBuffer ) {

                status = ZwQueryValueKey(
                            keyHandle,
                            &unicodeKeyName,
                            KeyValuePartialInformation,
                            infoBuffer,
                            lengthNeeded,
                            &lengthNeeded
                            );

                if( NT_SUCCESS( status ) &&
                    infoBuffer->Type == REG_DWORD &&
                    infoBuffer->DataLength == sizeof( DWORD )  ) {

                    SrvMinNT5Client = *(DWORD *)(&infoBuffer->Data[0]);

                    KdPrint(( "SRV: Restrict NT5 clients to builds >= %u\n",
                        SrvMinNT5Client ));

                    if( SrvMinNT5ClientIPCToo ) {
                        KdPrint(( "    Restrict IPC clients\n" ));
                    }
                }

                FREE_HEAP( infoBuffer );
            }
        }

        NtClose( keyHandle );
    }
}
#endif

#if MULTIPROCESSOR
VOID
StartQueueDepthComputations(
    PWORK_QUEUE queue
    )
{
    LARGE_INTEGER currentTime;

    PAGED_CODE();

    if( SrvNumberOfProcessors == 1 )
        return;

    //
    // We're going to schedule a dpc to call the 'ComputeAvgQueueDepth' routine
    //   Initialize the dpc
    //
    KeInitializeDpc( &queue->QueueAvgDpc, ComputeAvgQueueDepth, queue );

    //
    // We want to make sure the dpc runs on the same processor handling the
    //   queue -- to avoid thrashing the cache
    //
    KeSetTargetProcessorDpc( &queue->QueueAvgDpc, (CCHAR)(queue - SrvWorkQueues));

    //
    // Initialize a timer object to schedule our dpc later
    //
    KeInitializeTimer( &queue->QueueAvgTimer );
    KeQuerySystemTime( &currentTime );
    queue->NextAvgUpdateTime.QuadPart = currentTime.QuadPart + SrvQueueCalc.QuadPart;

    //
    // Initialize the sample vector
    //
    queue->NextSample = queue->DepthSamples;
    RtlZeroMemory( queue->DepthSamples, sizeof( queue->DepthSamples ) );

    //
    // And start it going!
    //
    KeSetTimer( &queue->QueueAvgTimer, queue->NextAvgUpdateTime, &queue->QueueAvgDpc );
}

VOID
StopQueueDepthComputations(
    PWORK_QUEUE queue
    )
{
    KIRQL oldIrql;

    if( SrvNumberOfProcessors == 1 )
        return;

    KeInitializeEvent( &queue->AvgQueueDepthTerminationEvent,
                       NotificationEvent,
                       FALSE
                     );


    ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );

    queue->NextSample = NULL;

    RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );

    //
    // Cancel the computation timer.  If this works, then we know that
    //  the DPC code is not running.  Otherwise, it is running or queued
    //  to run and we need to wait until it completes.
    //
    if( !KeCancelTimer( &queue->QueueAvgTimer ) ) {
        KeWaitForSingleObject(
            &queue->AvgQueueDepthTerminationEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }
}

VOID
ComputeAvgQueueDepth (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    LARGE_INTEGER currentTime;
    PWORK_QUEUE queue = (PWORK_QUEUE)DeferredContext;

    ACQUIRE_DPC_SPIN_LOCK( &queue->SpinLock );

    if( queue->NextSample == NULL ) {

        KeSetEvent( &queue->AvgQueueDepthTerminationEvent, 0, FALSE );

    } else {

        //
        // Compute the sliding window average by taking a queue depth
        // sample, removing the old sample value from the running sum
        // and adding in the new value
        //

        currentTime.LowPart= PtrToUlong(SystemArgument1);
        currentTime.HighPart = PtrToUlong(SystemArgument2);

        queue->AvgQueueDepthSum -= *queue->NextSample;
        *(queue->NextSample) = KeReadStateQueue( &queue->Queue );
        queue->AvgQueueDepthSum += *queue->NextSample;

        if( ++(queue->NextSample) == &queue->DepthSamples[ QUEUE_SAMPLES ] )
            queue->NextSample = queue->DepthSamples;

        queue->NextAvgUpdateTime.QuadPart =
               currentTime.QuadPart + SrvQueueCalc.QuadPart;

        KeSetTimer( &queue->QueueAvgTimer,
                    queue->NextAvgUpdateTime,
                    &queue->QueueAvgDpc );
    }

    RELEASE_DPC_SPIN_LOCK( &queue->SpinLock );
}
#endif  // MULTIPROCESSOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\io.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.c

Abstract:

    !!! Need to handle inability to allocate IRP.

    !!! Need to modify to accept file object pointer, not file handle,
        to avoid unnecessary translations.

Author:

    Chuck Lenzmeier (chuckl)    28-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "io.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_IO

//
// Forward declarations
//

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BuildCoreOfSyncIoRequest )
#pragma alloc_text( PAGE, StartIoAndWait )
#pragma alloc_text( PAGE, SrvBuildFlushRequest )
#pragma alloc_text( PAGE, SrvBuildLockRequest )
#pragma alloc_text( PAGE, SrvBuildMailslotWriteRequest )
#pragma alloc_text( PAGE, SrvBuildReadOrWriteRequest )
#pragma alloc_text( PAGE, SrvBuildNotifyChangeRequest )
#pragma alloc_text( PAGE, SrvIssueAssociateRequest )
#pragma alloc_text( PAGE, SrvIssueDisconnectRequest )
#pragma alloc_text( PAGE, SrvIssueTdiAction )
#pragma alloc_text( PAGE, SrvIssueTdiQuery )
#pragma alloc_text( PAGE, SrvIssueQueryDirectoryRequest )
#pragma alloc_text( PAGE, SrvIssueQueryEaRequest )
#pragma alloc_text( PAGE, SrvIssueSendDatagramRequest )
#pragma alloc_text( PAGE, SrvIssueSetClientProcessRequest )
#pragma alloc_text( PAGE, SrvIssueSetEaRequest )
#pragma alloc_text( PAGE, SrvIssueSetEventHandlerRequest )
#pragma alloc_text( PAGE, SrvIssueUnlockRequest )
#pragma alloc_text( PAGE, SrvIssueUnlockSingleRequest )
#pragma alloc_text( PAGE, SrvIssueWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvQuerySendEntryPoint )
#endif
#if 0
NOT PAGEABLE -- SrvBuildIoControlRequest
#endif


STATIC
PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This (local) function builds the request-independent portion of
    an I/O request packet for an I/O operation that will be performed
    synchronously.  It initializes a kernel event object, references
    the target file object, and allocates and initializes an IRP.

Arguments:

    FileHandle - Supplies a handle to the target file object.

    FileObject - Optionall supplies a pointer to the target file object.

    Event - Supplies a pointer to a kernel event object.  This routine
        initializes the event.

    IoStatusBlock - Supplies a pointer to an I/O status block.  This
        pointer is placed in the IRP.

    DeviceObject - Supplies or receives the address of the device object
        associated with the target file object.  This address is
        subsequently used by StartIoAndWait.  *DeviceObject must be
        valid or NULL on entry if FileObject != NULL.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( Event, SynchronizationEvent, FALSE );

    //
    // Get the file object corresponding to the directory's handle.
    // Referencing the file object every time is necessary because the
    // IO completion routine dereferneces it.
    //

    if ( ARGUMENT_PRESENT(FileObject) ) {

        ObReferenceObject(FileObject);

    } else {

        *DeviceObject = NULL;

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0L,                         // DesiredAccess
                    NULL,                       // ObjectType
                    KernelMode,
                    (PVOID *)&FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            return NULL;
        }
    }

    //
    // Set the file object event to a non-signaled state.
    //

    KeClearEvent( &FileObject->Event );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //

    if ( *DeviceObject == NULL ) {
        *DeviceObject = IoGetRelatedDeviceObject( FileObject );
    }

    irp = IoAllocateIrp( (*DeviceObject)->StackSize, TRUE );

    if ( irp == NULL ) {

        ULONG packetSize = sizeof(IRP) +
                ((*DeviceObject)->StackSize * sizeof(IO_STACK_LOCATION));

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "BuildCoreOfSyncIoRequest: Failed to allocate IRP",
             NULL,
             NULL
             );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_NONPAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &packetSize,
            sizeof(ULONG),
            NULL,
            0
            );

        return NULL;
    }

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->MdlAddress = NULL;

    irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = *DeviceObject;

    return irp;

} // BuildCoreOfSyncIoRequest


STATIC
NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This (local) function passes a fully built I/O request packet to the
    target driver, then waits for the driver to complete the request.

Arguments:

    Irp - Supplies a pointer to the I/O request packet.

    DeviceObject - Supplies a pointer to the target device object.

    Event - Supplies a pointer to a kernel event object.  This routine
        waits for the I/O to complete using this event.

    IoStatusBlock - Supplies a pointer to an I/O status block.  The
        Status field of this structure becomes the return status of
        this function.

Return Value:

    NTSTATUS - Either an error status returned by the driver from
        IoCallDriver, indicating that the driver rejected the request,
        or the I/O status placed in the I/O status block by the driver
        at I/O completion.

--*/

{
    NTSTATUS status;
    KIRQL oldIrql;

    PAGED_CODE();

    //
    // Queue the IRP to the thread and pass it to the driver.
    //

    IoQueueThreadIrp( Irp );

    status = IoCallDriver( DeviceObject, Irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            Event,
            UserRequest,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = IoStatusBlock->Status;
    }

    return status;

} // StartIoAndWait


PIRP
SrvBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN OUT PMDL Mdl OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a device or
    file system I/O control request.

    *** This routine sure takes a lot of arguments!

Arguments:

    Irp - Supplies a pointer to an IRP.  If NULL, this routine allocates
        an IRP and returns its address.  Otherwise, it supplies the
        address of an IRP allocated by the caller.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

        If this parameter is omitted, it is the responsiblity of the
        calling program to load the file object address before starting
        the I/O.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - The major function that we are calling.  Currently
        this most be one of IRP_MJ_FILE_SYSTEM_CONTROL or
        IRP_MJ_DEVICE_IO_CONTROL.

    IoControlCode - Supplies the control code for the operation.

    MainBuffer - Supplies the address of the main buffer.  This must
        be a system virtual address, and the buffer must be locked in
        memory.  If ControlCode specifies a method 0 request, the actual
        length of the buffer must be the greater of InputBufferLength
        and OutputBufferLength.

    InputBufferLength - Supplies the length of the input buffer.

    AuxiliaryBuffer - Supplies the address of the auxiliary buffer.  If the
        control code method is 0, this is a buffered I/O buffer, but the
        data returned by the called driver in the system buffer is not
        automatically copied into the auxiliary buffer.  Instead, the
        auxiliary data ends up in MainBuffer.  If the caller wishes the
        data to be in AuxiliaryBuffer, it must copy the data at some point
        after the completion routine runs.

        If the control code method is 1 or 2, this parameter is ignored;
        instead, the Mdl parameter is used to obtain the starting
        virtual address of the buffer.

    OutputBufferLength - Supplies the length of the output buffer.  Note
        that this parameter must be specified even when the Mdl
        parameter is specified.

    Mdl - If the control code method is 1 or 2, indicating direct I/O on
        the "output" buffer, this parameter is used to supply a pointer
        to an MDL describing a buffer.  Mdl must not be NULL, and the
        AuxiliaryBuffer parameter is ignored.  The buffer must reside in
        the system virtual address space (for the benefit of the
        transport provider).  If the buffer is not already locked, this
        routine locks it.  It is the calling program's responsibility to
        unlock the buffer and (potentially) deallocate the MDL after the
        I/O is complete.

        This parameter is ignored if the control method is not 1 or 2.

    CompletionRoutine - An optional IO completion routine.  If none
        is specified, SrvFsdIoCompletionRoutine is used.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    ASSERT( MajorFunction == IRP_MJ_DEVICE_CONTROL ||
            MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ||
            MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

    //
    // Get the method with which the buffers are being passed.
    //

    if ((MajorFunction == IRP_MJ_DEVICE_CONTROL)  ||
        (MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)) {
        method = IoControlCode & 3;
    } else {
        method = 4;
    }

    if ( ARGUMENT_PRESENT(Irp) ) {
        if( Irp->AssociatedIrp.SystemBuffer &&
            (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
            Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
        }

        IoReuseIrp( Irp, STATUS_SUCCESS );
    }

    //
    // If the FileObject parameter was specified, obtain the address of
    // the device object and allocate the IRP based on the stack size
    // for that device.  Otherwise, allocate the IRP based on the
    // server's receive IRP stack size.
    //

    if ( ARGUMENT_PRESENT(FileObject) ) {

        //
        // Allocate an IRP, if necessary.  The stack size is one higher
        // than that of the target device, to allow for the caller's
        // completion routine.
        //

        deviceObject = IoGetRelatedDeviceObject( FileObject );

        if ( ARGUMENT_PRESENT(Irp) ) {

            ASSERT( Irp->StackCount >= deviceObject->StackSize );

        } else {

            //
            // Get the address of the target device object.
            //

            Irp = IoAllocateIrp( SrvReceiveIrpStackSize, FALSE );
            if ( Irp == NULL ) {

                //
                // Unable to allocate an IRP.  Inform the caller.
                //

                return NULL;
            }

        }

    } else {

        deviceObject = NULL;

        if ( !ARGUMENT_PRESENT(Irp) ) {
            Irp = IoAllocateIrp( SrvReceiveIrpStackSize, FALSE );
            if ( Irp == NULL ) {
                return NULL;
            }
        }

    }

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        (ARGUMENT_PRESENT( CompletionRoutine ) ?
            CompletionRoutine : SrvFsdIoCompletionRoutine),
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    if ( MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ) {
        irpSp->MinorFunction = (UCHAR)IoControlCode;
    }
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    if ( MajorFunction == IRP_MJ_DEVICE_CONTROL ) {
        irpSp->Parameters.DeviceIoControl.OutputBufferLength =
            OutputBufferLength;
        irpSp->Parameters.DeviceIoControl.InputBufferLength =
            InputBufferLength;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    } else if ( MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ) {
        if ( IoControlCode == TDI_RECEIVE ) {
            PTDI_REQUEST_KERNEL_RECEIVE parameters =
                        (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
            parameters->ReceiveLength = OutputBufferLength;
            parameters->ReceiveFlags = 0;
            method = 1;
        } else if ( IoControlCode == TDI_ACCEPT ) {
            PTDI_REQUEST_KERNEL_ACCEPT parameters =
                        (PTDI_REQUEST_KERNEL_ACCEPT)&irpSp->Parameters;
            parameters->RequestConnectionInformation = NULL;
            parameters->ReturnConnectionInformation = NULL;
            method = 0;
        } else {
            ASSERTMSG( "Invalid TDI request type", 0 );
        }
    } else {
        irpSp->Parameters.FileSystemControl.OutputBufferLength =
            OutputBufferLength;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
            InputBufferLength;
        irpSp->Parameters.FileSystemControl.FsControlCode = IoControlCode;
    }

    //
    // Based on the method by which the buffers are being passed,
    // describe a system buffer and optionally build an MDL.
    //

    switch ( method ) {

    case 0:

        //
        // For this case, InputBuffer must be large enough to contain
        // both the input and the output buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->UserBuffer = AuxiliaryBuffer;

        //
        // !!! Does Irp->Flags need to be set?  Isn't this only looked
        //     at by I/O competion, which we bypass?
        //

        Irp->Flags = (ULONG)IRP_BUFFERED_IO;
        if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
            Irp->Flags |= IRP_INPUT_OPERATION;
        }

        break;

    case 1:
    case 2:

        //
        // For these two cases, InputBuffer is the buffered I/O "system
        // buffer".  Build an MDL for either read or write access,
        // depending on the method, for the output buffer.
        //

        Irp->MdlAddress = Mdl;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        // !!! Ditto above about setting Flags.
        Irp->Flags = (ULONG)IRP_BUFFERED_IO;

        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = AuxiliaryBuffer;
        Irp->Flags = 0;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = MainBuffer;
        break;

    case 4:

        //
        // This is the case for file system io request.  Both MainBuffer
        // and AuxiliaryBuffer are locked system buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->Flags = 0;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = AuxiliaryBuffer;
        break;

    }

    return Irp;

} // SrvBuildIoControlRequest


VOID
SrvBuildFlushRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a flush request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;

    return;

} // SrvBuildFlushRequest


VOID
SrvBuildLockRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    )

/*++

Routine Description:

    This function builds an I/O request packet for a lock request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    StartingBlock - the block number of the beginning of the locked
        range.

    ByteOffset - the offset within block of the beginning of the locked
        range.

    Length - the length of the locked range.

    Key - the key value to be associated with the lock.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_LOCK;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;
    if ( FailImmediately ) {
        irpSp->Flags = SL_FAIL_IMMEDIATELY;
    }
    if ( ExclusiveLock ) {
        irpSp->Flags |= SL_EXCLUSIVE_LOCK;
    }

    ((PWORK_CONTEXT)Context)->Parameters2.LockLength = Length;
    irpSp->Parameters.LockControl.Length = &((PWORK_CONTEXT)Context)->Parameters2.LockLength;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    return;

} // SrvBuildLockRequest

NTSTATUS
SrvIssueMdlCompleteRequest (
    IN PWORK_CONTEXT WorkContext OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PMDL Mdl,
    IN UCHAR Function,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG Length
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject = FileObject ? FileObject : WorkContext->Rfcb->Lfcb->FileObject;
    PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject( fileObject );
    KEVENT userEvent;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    if(  (irp = IoAllocateIrp( deviceObject->StackSize, TRUE )) == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Reference the file object
    ObReferenceObject( fileObject );

    KeInitializeEvent( &userEvent, SynchronizationEvent, FALSE );
    KeClearEvent( &userEvent );

    irp->MdlAddress = Mdl;
    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->UserEvent = &userEvent;
    irp->UserIosb = &ioStatusBlock;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;
    irpSp->Flags = 0;
    irpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
    irpSp->MajorFunction = Function;

    if( Function == IRP_MJ_WRITE ) {
        irpSp->Parameters.Write.ByteOffset = *ByteOffset;
        irpSp->Parameters.Write.Length = Length;
    } else {
        irpSp->Parameters.Read.ByteOffset = *ByteOffset;
        irpSp->Parameters.Read.Length = Length;
    }

    status = IoCallDriver( deviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &userEvent,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );

        status = ioStatusBlock.Status;
    }

    ASSERT( status == STATUS_SUCCESS );

    return status;
}


VOID
SrvBuildMailslotWriteRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This function builds an I/O request packet for a mailslot write
    request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    Buffer - Supplies the system virtual address of the write
        buffer.

    Length - Supplies the length of the write.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Set the write buffer.
    //

    //Irp->AssociatedIrp.SystemBuffer = Buffer;
    Irp->UserBuffer = Buffer;
    Irp->Flags = IRP_BUFFERED_IO;

    //
    // Set the write parameters.
    //

    irpSp->Parameters.Write.Length = Length;

    return;

} // SrvBuildMailslotWriteRequest


VOID
SrvBuildReadOrWriteRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    IN OUT PMDL Mdl OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN ULONG Key OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a read or write
    request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - Indicates the function to be performed.  Must be
        either IRP_MJ_READ or IRP_MJ_WRITE.

    MinorFunction - Qualifies the function to be performed.  (For
        example, issued at DPC level, MDL read, etc.)

    Buffer - Supplies the system virtual address of the read or write
        buffer.  This parameter is ignored when MinorFunction is
        IRP_MN_*_MDL_*.  Otherwise, the buffer must be mapped in the
        system virtual address space in order to support buffered I/O
        devices and other device drivers that need to look at the user
        data.  This routine always treats the buffer as a direct I/O
        buffer, locking it for I/O with an MDL.  It does, however, set
        up the IRP appropriately for the device type.

        If the Mdl parameter is NULL, this routine locks the buffer in
        memory for the I/O.  It is then the responsibility of the
        calling program to unlock the buffer and deallocate the MDL
        after the I/O is complete.

    Length - Supplies the length of the read or write.

    Mdl - This parameter is used to supply a pointer to an MDL
        describing a buffer.  It is ignored when MinorFunction is
        IRP_MN_MDL_*.  Otherwise, Mdl must not be NULL.  The buffer must
        reside in the system virtual address space (for the benefit of
        buffered I/O devices/drivers).  If the buffer is not already
        locked, this routine locks it.  It is the calling program's
        responsibility to unlock the buffer and (potentially) deallocate
        the MDL after the I/O is complete.

    ByteOffset - the offset within the file of the beginning of the read
        or write.

    Key - the key value to be associated with the read or write.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    if( Irp->AssociatedIrp.SystemBuffer &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Obtain the address of the device object and allocate the IRP
    // based on the stack size for that device.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = MinorFunction;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // This routine used to handle MDL read/write completion, but it
    // doesn't now.
    //

    ASSERT( IRP_MN_DPC == 1 );
    ASSERT( IRP_MN_MDL == 2 );
    ASSERT( IRP_MN_MDL_DPC == 3 );
    ASSERT( IRP_MN_COMPLETE_MDL == 6 );
    ASSERT( IRP_MN_COMPLETE_MDL_DPC == 7 );

    ASSERT( (MinorFunction & 4) == 0 );

    //
    // Set the parameters according to whether this is a read or a write
    // operation.  Notice that these parameters must be set even if the
    // driver has not specified buffered or direct I/O.
    //

    if ( MajorFunction == IRP_MJ_WRITE ) {

        irpSp->Parameters.Write.ByteOffset = ByteOffset;
        irpSp->Parameters.Write.Length = Length;
        irpSp->Parameters.Write.Key = Key;

    } else {

        irpSp->Parameters.Read.ByteOffset = ByteOffset;
        irpSp->Parameters.Read.Length = Length;
        irpSp->Parameters.Read.Key = Key;

    }

    //
    // Indicate to the file system that this operation can be handled
    // synchronously.  Basically, this means that the file system can
    // use the server's thread to fault pages in, etc.  This avoids
    // having to context switch to a file system thread.
    //

    Irp->Flags = IRP_SYNCHRONOUS_API;

    //
    // If this is the start of an MDL-based read or write, we simply
    // need to put the supplied MDL address in the IRP.  This optional
    // MDL address can provide a partial chain for a read or write that
    // was partially satisfied using the fast I/O path.
    //

    if ( (MinorFunction & IRP_MN_MDL) != 0 ) {

        Irp->MdlAddress = Mdl;

        DEBUG Irp->UserBuffer = NULL;
        DEBUG Irp->AssociatedIrp.SystemBuffer = NULL;

        return;

    }

    //
    // Normal ("copy") read or write.
    //

    ASSERT( Buffer != NULL );
    ASSERT( Mdl != NULL );

    //
    // If the target device does buffered I/O, load the address of the
    // caller's buffer as the "system buffered I/O buffer".  If the
    // target device does direct I/O, load the MDL address.  If it does
    // neither, load both the user buffer address and the MDL address.
    // (This is necessary to support file systems, such as HPFS, that
    // sometimes treat the I/O as buffered and sometimes treat it as
    // direct.)
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        Irp->AssociatedIrp.SystemBuffer = Buffer;
        if ( MajorFunction == IRP_MJ_WRITE ) {
            Irp->Flags |= IRP_BUFFERED_IO;
        } else {
            Irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        }

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        Irp->MdlAddress = Mdl;

    } else {

        Irp->UserBuffer = Buffer;
        Irp->MdlAddress = Mdl;
    }

    return;

} // SrvBuildReadOrWriteRequest


PIRP
SrvBuildNotifyChangeRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN ULONG CompletionFilter,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WatchTree
    )

/*++

Routine Description:

    This function builds an I/O request packet for a notify change request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    CompletionFilter - Specifies which directory changes will cause the
        File sytsem to complete the IRP.

    Buffer - The buffer to receive the directory change data.

    BufferLength - The size, in bytes, of the buffer.

    WatchTree - If TRUE, recursively watch all subdirectories for changes.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;

    PAGED_CODE( );

    if( Irp->AssociatedIrp.SystemBuffer &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Obtain the address of the device object and initialize the IRP.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    Irp->RequestorMode = KernelMode;
    Irp->MdlAddress = NULL;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;
    if (WatchTree) {
        irpSp->Flags = SL_WATCH_TREE;
    }

    irpSp->Parameters.NotifyDirectory.Length = BufferLength;
    irpSp->Parameters.NotifyDirectory.CompletionFilter = CompletionFilter;

    if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        mdl = IoAllocateMdl(
                Buffer,
                BufferLength,
                FALSE,
                FALSE,
                Irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            return NULL;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeMdl( mdl );
            return NULL;
        }

        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = NULL;

    } else {

        Irp->AssociatedIrp.SystemBuffer = Buffer;
        Irp->UserBuffer = NULL;
    }

    //
    // Return a pointer to the IRP.
    //

    return Irp;

} // SrvBuildNotifyChangeRequest


NTSTATUS
SrvIssueAssociateRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN HANDLE AddressFileHandle
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiAssociateAddress
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    AddressFileHandle - handle to an address endpoint.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_ASSOCIATE parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_ASSOCIATE_ADDRESS;

    parameters->AddressHandle = AddressFileHandle;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueAssociateRequest


NTSTATUS
SrvIssueDisconnectRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiDisconnect
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    Flags -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_DISCONNECT;

    parameters->RequestFlags = Flags;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueDisconnectRequest


NTSTATUS
SrvIssueTdiAction (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiQueryInformation
    (Query Adapter Status) request.  It builds an I/O request packet,
    passes the IRP to the driver (using IoCallDriver), and waits for the
    I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Buffer, BufferLength, FALSE, FALSE, NULL );
    if ( mdl == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    TdiBuildAction(
        irp,
        *DeviceObject,
        FileObject,
        NULL,
        NULL,
        mdl
        );

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueTdiAction


NTSTATUS
SrvIssueTdiQuery (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN ULONG QueryType
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiQueryInformation
    (Query Adapter Status) request.  It builds an I/O request packet,
    passes the IRP to the driver (using IoCallDriver), and waits for the
    I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Buffer, BufferLength, FALSE, FALSE, NULL );
    if ( mdl == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    TdiBuildQueryInformation(
        irp,
        *DeviceObject,
        FileObject,
        NULL,
        NULL,
        QueryType,
        mdl
        );

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueTdiQuery


NTSTATUS
SrvIssueQueryDirectoryRequest (
    IN HANDLE FileHandle,
    IN PCHAR Buffer,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN PULONG FileIndex OPTIONAL,
    IN BOOLEAN RestartScan,
    IN BOOLEAN SingleEntriesOnly
    )

/*++

Routine Description:

    This function issues an I/O request packet for a query directory
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a directory open with FILE_LIST_DIRECTORY
        access.

    Buffer - supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - supplies the length of the buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory.

    FileName - an optional pointer to a file name.  If FileIndex is NULL,
        then this is the search specification, i.e. the template that
        files must match in order to be returned.  If FileIndex is
        non-NULL, then this is the name of a file after which to resume
        a search.

    FileIndex - if specified, the index of a file after which to resume
        the search (first file returned is the one after the one
        corresponding to the index).

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.

    SingleEntriesOnly - Supplies a BOOLEAN value that, if TRUE, indicates that
        the scan should ask only for one entry at a time.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    ULONG actualBufferLength;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PUNICODE_STRING fileNameString;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Reject rewind requests if debugging for it.  If a file index is
    // specified, this must be a rewind request, so reject the request.
    //

    IF_DEBUG(BRUTE_FORCE_REWIND) {
        if ( ARGUMENT_PRESENT( FileIndex ) ) {
            return STATUS_NOT_IMPLEMENTED;
        }
    }

    //
    // Copy the file name into the end of the specified buffer, setting
    // the actualBufferLength accordingly.
    //

    if ( !ARGUMENT_PRESENT(FileName) || FileName->Length == 0 ) {

        actualBufferLength = Length;
        fileNameString = NULL;

    } else {

        //
        // *** Remember that the string must be longword-aligned!
        //

        actualBufferLength = (Length - FileName->Length -
                                        sizeof(UNICODE_STRING)) & ~(sizeof(PVOID)-1);
        fileNameString = (PUNICODE_STRING)( Buffer + actualBufferLength );

        RtlCopyMemory(
            fileNameString + 1,
            FileName->Buffer,
            FileName->Length
            );

        fileNameString->Length = FileName->Length;
        fileNameString->MaximumLength = FileName->Length;
        fileNameString->Buffer = (PWCH)(fileNameString + 1);

    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;

    irpSp->Parameters.QueryDirectory.FileName = fileNameString;

    irpSp->Parameters.QueryDirectory.FileIndex =
                    (ULONG)( ARGUMENT_PRESENT( FileIndex ) ? *FileIndex : 0 );

    irpSp->Parameters.QueryDirectory.Length = actualBufferLength;
    irpSp->Parameters.QueryDirectory.FileInformationClass =
                                                    FileInformationClass;

    //
    // Set the flags in the stack location.
    //

    irpSp->Flags = 0;

    if ( ARGUMENT_PRESENT( FileIndex ) ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_INDEX_SPECIFIED\n" ));
        }
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    if ( RestartScan ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_RESTART_SCAN\n" ));
        }
        irpSp->Flags |= SL_RESTART_SCAN;
    }

    if( SingleEntriesOnly ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_RETURN_SINGLE_ENTRY\n" ));
        }
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }

    //
    // The file system has been updated.  Determine whether the driver wants
    // buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                actualBufferLength,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            MmUnlockPages( mdl );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since our buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, deviceObject, &event, &iosb );

} // SrvIssueQueryDirectoryRequest


NTSTATUS
SrvIssueQueryEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN BOOLEAN RestartScan,
    OUT PULONG EaErrorOffset OPTIONAL
    )

/*++

Routine Description:

    This function issues an I/O request packet for an EA query request.
    It builds an I/O request packet, passes the IRP to the driver (using
    IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a file open with FILE_READ_EA access.

    Buffer - supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - supplies the length of the buffer.

    EaList - supplies a pointer to a list of EAs to query.  If omitted,
        all EAs are returned.

    EaListLength - supplies the length of EaList.

    RestartScan - if TRUE, then the query of EAs is to start from the
        beginning.  Otherwise, continue from where we left off.

    EaErrorOffset - if not NULL, returns the offset into EaList of an
        invalid EA, if any.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaList = EaList;
    irpSp->Parameters.QueryEa.EaListLength = EaListLength;
    irpSp->Parameters.QueryEa.EaIndex = 0L;

    irpSp->Flags = (UCHAR)( RestartScan ? SL_RESTART_SCAN : 0 );

    //
    // The file system has been updated.  Determine whether the
    // driver wants buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                Length,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since out buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    status = StartIoAndWait( irp, deviceObject, &event, &iosb );

    if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
        *EaErrorOffset = (ULONG)iosb.Information;
    }

    return status;

} // SrvIssueQueryEaRequest


NTSTATUS
SrvIssueSendDatagramRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PTDI_CONNECTION_INFORMATION SendDatagramInformation,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TDI Send Datagram
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for an endpoint.

    DeviceObject - pointer to pointer to device object for an endpoint.

    SendDatagramInformation - pointer to a buffer describing the
        target of the datagram.

    Buffer - Supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - Supplies the length of the buffer.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_SEND_DATAGRAM;

    parameters->SendLength = Length;
    parameters->SendDatagramInformation = SendDatagramInformation;

    //
    // The file system wants direct I/O.  Allocate an MDL and lock the
    // buffer into memory.
    //

    mdl = IoAllocateMdl(
            Buffer,
            Length,
            FALSE,
            FALSE,
            irp     // stores MDL address in irp->MdlAddress
            );

    if ( mdl == NULL ) {

        //
        // Unable to allocate an MDL.  Fail the I/O.
        //

        IoFreeIrp( irp );

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeIrp( irp );
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSendDatagramRequest


NTSTATUS
SrvIssueSetClientProcessRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCONNECTION Connection,
    IN PVOID ClientSession,
    IN PVOID ClientProcess
    )

/*++

Routine Description:

    This function issues an I/O request packet for a named pipe Set
    Client Process file system control function.  It builds an I/O
    request packet, passes the IRP to the driver (using IoCallDriver),
    and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a pipe.

    DeviceObject - pointer to pointer to device object for a pipe.

    ClientSession - A unique identifier for the client's session with
        the server.  Assigned by the server.

    ClientProcess - A unique identifier for the client process.
        Assigned by the redirector.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX clientIdBuffer;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Set the client ID in the FSCTL buffer.
    //

    clientIdBuffer.ClientSession = ClientSession;
    clientIdBuffer.ClientProcess = ClientProcess;

    // Set ClientComputerName in the buffer
    // The Rtl function terminates the string, so leave enough room

    unicodeString.Buffer = clientIdBuffer.ClientComputerBuffer;
    unicodeString.MaximumLength =
        (USHORT) ((FILE_PIPE_COMPUTER_NAME_LENGTH+1) * sizeof(WCHAR));

    status = RtlOemStringToUnicodeString( &unicodeString,
                                 &Connection->OemClientMachineNameString,
                                 FALSE );
    if (!NT_SUCCESS(status)) {
        // Set length to zero in case conversion fails
        unicodeString.Length = 0;
    }
    clientIdBuffer.ClientComputerNameLength = unicodeString.Length;

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = IRP_MN_KERNEL_CALL;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength =
                                            sizeof( clientIdBuffer );
    irpSp->Parameters.FileSystemControl.FsControlCode =
                                            FSCTL_PIPE_SET_CLIENT_PROCESS;

    irp->MdlAddress = NULL;
    irp->AssociatedIrp.SystemBuffer = &clientIdBuffer;
    irp->Flags |= IRP_BUFFERED_IO;
    irp->UserBuffer = NULL;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSetClientProcessRequest


NTSTATUS
SrvIssueSetEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EaErrorOffset OPTIONAL
    )

/*++

Routine Description:

    This function issues an I/O request packet for an EA set request.
    It builds an I/O request packet, passes the IRP to the driver (using
    IoCallDriver), and waits for the I/O to complete.

    WARNING!  The server must walk the list of EAs to set if it
    comes directly from a client.  This is because the file system
    trusts that this list is legitimate and could run into problems
    if the list has an error.

Arguments:

    FileHandle - handle to a file open with FILE_WRITE_EA access.

    Buffer - Supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - Supplies the length of the buffer.

    EaErrorOffset - if not NULL, returns the offset into EaList of an
        invalid EA, if any.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_EA;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.SetEa.Length = Length;

    irpSp->Flags = 0;

    //
    // The file system has been updated.  Determine whether the driver
    // wants buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                Length,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since our buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    status = StartIoAndWait( irp, deviceObject, &event, &iosb );

    if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
        *EaErrorOffset = (ULONG)iosb.Information;
    }

    return status;

} // SrvIssueSetEaRequest


NTSTATUS
SrvIssueSetEventHandlerRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiSetEventHandler
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    EventType -

    EventHandler -

    EventContext -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SET_EVENT parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject = NULL;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_SET_EVENT_HANDLER;

    parameters->EventType = EventType;
    parameters->EventHandler = EventHandler;
    parameters->EventContext = EventContext;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSetEventHandlerRequest


NTSTATUS
SrvIssueUnlockRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN UCHAR UnlockOperation,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This function issues an I/O request packet for an unlock request.
    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - Pointer to the file object.

    DeviceObject - Pointer to pointer to the related device object.

    UnlockOperation - the minor function code describing the unlock
        operation -- IRP_MN_UNLOCK_SINGLE or IRP_MN_UNLOCK_ALL_BY_KEY.

    StartingBlock - the block number of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    ByteOffset - the offset within block of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    Length - the length of the locked range.  Ignored if UnlockOperation
        is IRP_MN_UNLOCK_ALL_BY_KEY.

    Key - the key value used to obtain the lock.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE( );

    //
    // Try the turbo unlock path first.
    //

    fastIoDispatch = (*DeviceObject)->DriverObject->FastIoDispatch;

    if ( fastIoDispatch != NULL ) {

        if ( (UnlockOperation == IRP_MN_UNLOCK_SINGLE) &&
             (fastIoDispatch->FastIoUnlockSingle != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
            if ( fastIoDispatch->FastIoUnlockSingle(
                                    FileObject,
                                    &ByteOffset,
                                    &Length,
                                    IoGetCurrentProcess(),
                                    Key,
                                    &iosb,
                                    *DeviceObject
                                    ) ) {
                return iosb.Status;
            }
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );

        } else if ( (UnlockOperation == IRP_MN_UNLOCK_ALL_BY_KEY) &&
                    (fastIoDispatch->FastIoUnlockAllByKey != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
            if ( fastIoDispatch->FastIoUnlockAllByKey(
                                    FileObject,
                                    IoGetCurrentProcess(),
                                    Key,
                                    &iosb,
                                    *DeviceObject
                                    ) ) {

                return iosb.Status;

            }
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );

        }

    }

    //
    // The turbo path failed or was unavailable.  Allocate an IRP and
    // fill in the service-independent parameters for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = UnlockOperation;

    irpSp->Parameters.LockControl.Length = &Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueUnlockRequest

NTSTATUS
SrvIssueUnlockSingleRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This function issues an I/O request packet for an unlock single request.
    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - Pointer to the file object.

    DeviceObject - Pointer to pointer to the related device object.

    StartingBlock - the block number of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    ByteOffset - the offset within block of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    Length - the length of the locked range.  Ignored if UnlockOperation
        is IRP_MN_UNLOCK_ALL_BY_KEY.

    Key - the key value used to obtain the lock.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent
    // parameters for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_UNLOCK_SINGLE;

    irpSp->Parameters.LockControl.Length = &Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueUnlockSingleRequest


NTSTATUS
SrvIssueWaitForOplockBreak (
    IN HANDLE FileHandle,
    PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This function issues an I/O request packet for a wait for oplock
    break request.

    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a file.

    WaitForOplockBreak - Context information for this wait for oplock break.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    KIRQL oldIrql;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if (irp == NULL) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode =
                                          FSCTL_OPLOCK_BREAK_NOTIFY;

    //
    // Queue the WaitForOplockBreak block on the global list.
    //
    // We must hold the lock that protects wait for oplock breaks
    // from the time we queue this wait for oplock break on the global
    // list, to the time the IRP has actually been submitted.  Otherwise
    // the scavenger might wake up and attempt to cancel an IRP that
    // has not yet been submitted.
    //

    WaitForOplockBreak->Irp = irp;

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    SrvInsertTailList(
        &SrvWaitForOplockBreakList,
        &WaitForOplockBreak->ListEntry
        );

    //
    // The following code is a duplicate of the code from StartIoAndWait().
    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    //
    // Queue the IRP to the thread and pass it to the driver.
    //

    IoQueueThreadIrp( irp );

    status = IoCallDriver( deviceObject, irp );

    RELEASE_LOCK( &SrvOplockBreakListLock );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            &event,
            UserRequest,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
       status = iosb.Status;
    }

    return status;

} // SrvIssueWaitForOplockBreak

VOID
SrvQuerySendEntryPoint(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID *EntryPoint
    )

/*++

Routine Description:

    This function queries the transport for its send entry point.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    EntryPoint -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        *EntryPoint = NULL;
        return;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = EntryPoint;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    status = StartIoAndWait( irp, *DeviceObject, &event, &iosb );

    if ( !NT_SUCCESS(status) ) {
        *EntryPoint = NULL;
    }

    return;

} // SrvQuerySendEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\fsdsmb.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fsdsmb.c

Abstract:

    This module implements SMB processing routines and their support
    routines for the File System Driver of the LAN Manager server.

    *** This module must be nonpageable.

Author:

    Chuck Lenzmeier (chuckl) 19-Mar-1990

Revision History:

--*/

//
//  This module is laid out as follows:
//      Includes
//      Local #defines
//      Local type definitions
//      Forward declarations of local functions
//      SMB processing routines
//      Restart routines and other support routines
//

#include "precomp.h"
#include "fsdsmb.tmh"
#pragma hdrstop

VOID SRVFASTCALL
SrvFspRestartLargeReadAndXComplete(
    IN OUT PWORK_CONTEXT WorkContext
    );

#if SRVCATCH
VOID
SrvUpdateCatchBuffer (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PBYTE Buffer,
    IN DWORD BufferLength
    );
#endif


#ifdef ALLOC_PRAGMA
//#pragma alloc_text( PAGE8FIL, SrvFsdRestartRead )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartReadAndX )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartWrite )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartWriteAndX )
#pragma alloc_text( PAGE, SrvFspRestartLargeReadAndXComplete )

#if SRVCATCH
#pragma alloc_text( PAGE, SrvUpdateCatchBuffer )
#endif

#endif


VOID SRVFASTCALL
SrvFsdRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a Read SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    SHARE_TYPE shareType;
    KIRQL oldIrql;
    USHORT readLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartRead\n" );

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    shareType = rfcb->ShareType;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = WorkContext->Irp->IoStatus.Status;
    readLength = (USHORT)WorkContext->Irp->IoStatus.Information;

    if ( status == STATUS_BUFFER_OVERFLOW && shareType == ShareTypePipe ) {

        //
        // If this is an named pipe and the error is
        // STATUS_BUFFER_OVERFLOW, set the error in the smb header, but
        // return all the data to the client.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        if ( status != STATUS_END_OF_FILE ) {

            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
                WorkContext->FspRestartRoutine = SrvFsdRestartRead;
                QUEUE_WORK_TO_FSP( WorkContext );
            } else {
                SrvSetSmbError( WorkContext, status );
                SrvFsdSendResponse( WorkContext );
            }
            IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartRead complete\n" );

            goto Cleanup;

        } else {
            readLength = 0;
        }
    }

    //
    // The read completed successfully.  If this is a disk file, update
    // the file position.
    //

    if (shareType == ShareTypeDisk) {

#if SRVCATCH
        if( KeGetCurrentIrql() == 0 &&
            (rfcb->SrvCatch > 0 ) &&
            SmbGetUlong( &request->Offset ) == 0 ) {

            SrvUpdateCatchBuffer( WorkContext, (PCHAR)response->Buffer, readLength );
        }
#endif
        rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + readLength;

    }

    //
    // Save the count of bytes read, to be used to update the server
    // statistics database.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Build the response message.
    //

    response->WordCount = 5;
    SmbPutUshort( &response->Count, readLength );
    RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(readLength + FIELD_OFFSET(RESP_READ,Buffer[0]) -
                                FIELD_OFFSET(RESP_READ,BufferFormat))
        );
    response->BufferFormat = SMB_FORMAT_DATA;
    SmbPutUshort( &response->DataLength, readLength );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ,
                                        readLength
                                        );

    //
    // Processing of the SMB is complete.  Send the response.
    //

    SrvFsdSendResponse( WorkContext );

Cleanup:
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartRead complete\n" );
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }

    return;

} // SrvFsdRestartRead

VOID SRVFASTCALL
SrvFsdRestartReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a ReadAndX SMB.

    This routine may be called in the FSD or the FSP.  If the chained
    command is Close, it will be called in the FSP.

    *** This routine cannot look at the original ReadAndX request!
        This is because the read data may have overlaid the request.
        All necessary information from the request must be stored
        in WorkContext->Parameters.ReadAndX.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_ANDX response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    SHARE_TYPE shareType;
    KIRQL oldIrql;
    PCHAR readAddress;
    CLONG bufferOffset;
    ULONG readLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartReadAndX\n" );

    //
    // Get the response parameter pointer.
    //

    response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    shareType = rfcb->ShareType;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = WorkContext->Irp->IoStatus.Status;
    readLength = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( status == STATUS_BUFFER_OVERFLOW && shareType == ShareTypePipe ) {

        //
        // If this is an named pipe and the error is
        // STATUS_BUFFER_OVERFLOW, set the error in the smb header, but
        // return all the data to the client.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        if ( status != STATUS_END_OF_FILE ) {

            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
                QUEUE_WORK_TO_FSP( WorkContext );
            } else {
                SrvSetSmbError( WorkContext, status );
                SrvFsdSendResponse( WorkContext );
            }
            IF_DEBUG(FSD2) SrvPrint0("SrvFsdRestartReadAndX complete\n");
            goto Cleanup;
        } else {
            readLength = 0;
        }
    }

    //
    // The read completed successfully.  Generate information about the
    // destination of the read data.  Find out how much was actually
    // read.  If none was read, we don't have to worry about the offset.
    //

    if ( readLength != 0 ) {

        readAddress = WorkContext->Parameters.ReadAndX.ReadAddress;
        bufferOffset = (ULONG)(readAddress - (PCHAR)WorkContext->ResponseHeader);

        //
        // Save the count of bytes read, to be used to update the server
        // statistics database.
        //

        UPDATE_READ_STATS( WorkContext, readLength );

    } else {

        readAddress = (PCHAR)response->Buffer;
        bufferOffset = 0;

    }

    if (shareType == ShareTypePipe) {

        //
        // If this is NPFS then, Irp->Overlay.AllocationSize actually
        // contains the number bytes left to read on this side of the named
        // pipe.  Return this information to the client.
        //

        if (WorkContext->Irp->Overlay.AllocationSize.LowPart != 0) {
            SmbPutUshort(
                &response->Remaining,
                (USHORT)(WorkContext->Irp->Overlay.AllocationSize.LowPart - readLength)
                );
        } else {
            SmbPutUshort(
                &response->Remaining,
                0
                );
        }

    } else {

        if ( shareType == ShareTypeDisk ) {

#if SRVCATCH
            if( KeGetCurrentIrql() == 0 &&
                (rfcb->SrvCatch > 0) &&
                WorkContext->Parameters.ReadAndX.ReadOffset.QuadPart == 0 ) {

                SrvUpdateCatchBuffer( WorkContext, readAddress, readLength );
            }
#endif
            //
            // If this is a disk file, then update the file position.
            //

            rfcb->CurrentPosition =
                WorkContext->Parameters.ReadAndX.ReadOffset.LowPart +
                readLength;
        }

        SmbPutUshort( &response->Remaining, (USHORT)-1 );
    }

    //
    // Build the response message.  (Note that if no data was read, we
    // return a byte count of 0 -- we don't add padding.)
    //
    // *** Note that even though there may have been a chained command,
    //     we make this the last response in the chain.  This is what
    //     the OS/2 server does.  (Sort of -- it doesn't bother to
    //     update the AndX fields of the response.) Since the only legal
    //     chained commands are Close and CloseAndTreeDisc, this seems
    //     like a reasonable thing to do.  It does make life easier --
    //     we don't have to find the end of the read data and write
    //     another response there.  Besides, the read data might have
    //     completely filled the SMB buffer.
    //

    response->WordCount = 12;
    response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, 0 );
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->DataLength, (USHORT)readLength );
    SmbPutUshort( &response->DataOffset, (USHORT)bufferOffset );
    SmbPutUshort( &response->DataLengthHigh, (USHORT)(readLength >> 16) );
    RtlZeroMemory( (PVOID)&response->Reserved3[0], sizeof(response->Reserved3) );
    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(readLength + (readAddress - response->Buffer))
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ_ANDX,
                                        readLength +
                                            (readAddress - response->Buffer)
                                        );

    //
    // Processing of the SMB is complete, except that the file may still
    // need to be closed.  If not, just send the response.  If this is a
    // ReadAndX and Close, we need to close the file first.
    //
    // *** Note that other chained commands are illegal, but are ignored
    //     -- no error is returned.
    //

    if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {

        //
        // Not a chained Close.  Just send the response.
        //

        SrvFsdSendResponse( WorkContext );

    } else {

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        //
        // Remember the file last write time, to correctly set this on
        // close.
        //

        WorkContext->Parameters.LastWriteTime =
                WorkContext->Parameters.ReadAndX.LastWriteTimeInSeconds;

        //
        // This is a ReadAndX and Close.  Call SrvRestartChainedClose to
        // do the close and send the response.
        //

        SrvRestartChainedClose( WorkContext );

    }
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartReadAndX complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartReadAndX

/*
 * This routine is called at final send completion
 */
VOID SRVFASTCALL
SrvFspRestartLargeReadAndXComplete(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    NTSTATUS status;

    PAGED_CODE();

    if( WorkContext->Parameters.ReadAndX.SavedMdl != NULL ) {

        WorkContext->ResponseBuffer->Mdl = WorkContext->Parameters.ReadAndX.SavedMdl;

        MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );
        WorkContext->ResponseBuffer->PartialMdl->Next = NULL;

    }

    if ( WorkContext->Parameters.ReadAndX.MdlRead == TRUE ) {

        //
        // Call the Cache Manager to release the MDL chain.
        //
        if( WorkContext->Parameters.ReadAndX.CacheMdl ) {
            //
            // Try the fast path first..
            //
            if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

                WorkContext->Rfcb->Lfcb->MdlReadComplete(
                    WorkContext->Rfcb->Lfcb->FileObject,
                    WorkContext->Parameters.ReadAndX.CacheMdl,
                    WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

                //
                // Fast path didn't work, try an IRP...
                //
                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                            WorkContext->Parameters.ReadAndX.CacheMdl,
                                            IRP_MJ_READ,
                                            &WorkContext->Parameters.ReadAndX.ReadOffset,
                                            WorkContext->Parameters.ReadAndX.ReadLength
                        );

                if( !NT_SUCCESS( status ) ) {
                    //
                    // At this point, all we can do is complain!
                    //
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }
        }

    } else {

        PMDL mdl = (PMDL)(((ULONG_PTR)(WorkContext->Parameters.ReadAndX.ReadAddress) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));

        //
        // We shortened the byte count if the read returned less data than we asked for
        //
        mdl->ByteCount = WorkContext->Parameters.ReadAndX.ReadLength;

        MmUnlockPages( mdl );
        MmPrepareMdlForReuse( mdl );

        FREE_HEAP( WorkContext->Parameters.ReadAndX.Buffer );
    }

    SrvDereferenceWorkItem( WorkContext );
    return;
}

/*
 * This routine is called when the read completes
 */
VOID SRVFASTCALL
SrvFsdRestartLargeReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a ReadAndX SMB which
     is larger than the negotiated buffer size, and is from
     a disk file.

    There is no follow on command.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_ANDX response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    USHORT readLength;
    NTSTATUS status = WorkContext->Irp->IoStatus.Status;
    PRFCB rfcb = WorkContext->Rfcb;
    PIRP irp = WorkContext->Irp;
    BOOLEAN mdlRead = WorkContext->Parameters.ReadAndX.MdlRead;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

#ifdef SRVCATCH
    // For the Catch case, make sure we're PASSIVE
    if( (KeGetCurrentIrql() != PASSIVE_LEVEL) && (WorkContext->Rfcb->SrvCatch > 0) ) {
        //
        // Requeue this routine to come back around at passive level.
        //   (inefficient, but should be very rare)
        //
        WorkContext->FspRestartRoutine = SrvFsdRestartLargeReadAndX;
        SrvQueueWorkToFspAtDpcLevel( WorkContext );
        goto Cleanup;
    }
#endif

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    // Copy the MDL pointer back out of the IRP.  This is because if the read
    // failed, CC will free the MDL and NULL the pointer.  Not retrieving it in the
    // non-fast-io path will result in us holding (and possibly freeing) a dangling pointer
    if( mdlRead )
    {
        WorkContext->Parameters.ReadAndX.CacheMdl = WorkContext->Irp->MdlAddress;
    }

    if ( !NT_SUCCESS(status) ) {

        if( status != STATUS_END_OF_FILE ) {
            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            //
            // We cannot call SrvSetSmbError() at elevated IRQL.
            //
            if( KeGetCurrentIrql() != 0 ) {
                //
                // Requeue this routine to come back around at passive level.
                //   (inefficient, but should be very rare)
                //
                WorkContext->FspRestartRoutine = SrvFsdRestartLargeReadAndX;
                SrvQueueWorkToFspAtDpcLevel( WorkContext );
                goto Cleanup;
            }
            SrvSetSmbError( WorkContext, status );
        }

        readLength = 0;

    } else if( mdlRead ) {
        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple steps, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was satisfied
        // using an IRP
        //

        PMDL mdl = WorkContext->Irp->MdlAddress;
        readLength = 0;

        while( mdl != NULL ) {
            readLength += (USHORT)MmGetMdlByteCount( mdl );
            mdl = mdl->Next;
        }
    } else {
        //
        // This was a copy read.  The I/O status block has the length.
        //
        readLength = (USHORT)WorkContext->Irp->IoStatus.Information;
    }

    //
    // Build the response message.  (Note that if no data was read, we
    // return a byte count of 0 -- we don't add padding.)
    //
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    response->WordCount = 12;
    response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, 0 );
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->Reserved2, 0 );
    RtlZeroMemory( (PVOID)&response->Reserved3[0], sizeof(response->Reserved3) );
    SmbPutUshort( &response->DataLength, readLength );


    if( readLength == 0 ) {

        SmbPutUshort( &response->DataOffset, 0 );
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->Parameters.ReadAndX.PadCount = 0;

    } else {

        //
        // Update the file position.
        //
        rfcb->CurrentPosition =
                WorkContext->Parameters.ReadAndX.ReadOffset.LowPart +
                readLength;

        //
        // Update statistics
        //
        UPDATE_READ_STATS( WorkContext, readLength );

        SmbPutUshort( &response->DataOffset,
                      (USHORT)(READX_BUFFER_OFFSET + WorkContext->Parameters.ReadAndX.PadCount) );

        SmbPutUshort( &response->ByteCount,
                      (USHORT)( readLength + WorkContext->Parameters.ReadAndX.PadCount ) );

    }

    //
    // We will use two MDLs to describe the packet we're sending -- one
    // for the header and parameters, the other for the data.
    //
    // Handling of the second MDL varies depending on whether we did a copy
    // read or an MDL read.
    //

    //
    // Set the first MDL for just the header + pad
    //
    IoBuildPartialMdl(
        WorkContext->ResponseBuffer->Mdl,
        WorkContext->ResponseBuffer->PartialMdl,
        WorkContext->ResponseBuffer->Buffer,
        READX_BUFFER_OFFSET + WorkContext->Parameters.ReadAndX.PadCount
        );

    WorkContext->ResponseBuffer->PartialMdl->MdlFlags |=
        (WorkContext->ResponseBuffer->Mdl->MdlFlags & MDL_NETWORK_HEADER); // prop flag

    //
    // Set the overall data length to the header + pad + data
    //
    WorkContext->ResponseBuffer->DataLength = READX_BUFFER_OFFSET +
                                              WorkContext->Parameters.ReadAndX.PadCount +
                                              readLength;

    irp->Cancel = FALSE;

    //
    // The second MDL depends on the kind of read which we did
    //
    if( readLength != 0 ) {

        if( mdlRead ) {

            WorkContext->ResponseBuffer->PartialMdl->Next =
                    WorkContext->Irp->MdlAddress;

        } else {

            //
            // This was a copy read.  The MDL describing the data buffer is in the SMB buffer
            //

            PMDL mdl = (PMDL)(((ULONG_PTR)(WorkContext->Parameters.ReadAndX.ReadAddress) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));

            WorkContext->ResponseBuffer->PartialMdl->Next = mdl;
            mdl->ByteCount = readLength;

        }

#ifdef SRVCATCH
        if( (rfcb->SrvCatch > 0) && WorkContext->ResponseBuffer->PartialMdl->Next && (WorkContext->Parameters.ReadAndX.ReadOffset.QuadPart == 0) )
        {
            PVOID Buffer;

            Buffer = MmGetSystemAddressForMdlSafe( WorkContext->ResponseBuffer->PartialMdl->Next, LowPagePriority );
            if( Buffer )
            {
                SrvUpdateCatchBuffer( WorkContext, Buffer, WorkContext->ResponseBuffer->PartialMdl->Next->ByteCount );
            }
        }
#endif

    }

    //
    // SrvStartSend2 wants to use WorkContext->ResponseBuffer->Mdl, but
    //  we want it to use WorkContext->ResponseBuffer->PartialMdl.  So switch
    //  it!
    //
    WorkContext->Parameters.ReadAndX.SavedMdl = WorkContext->ResponseBuffer->Mdl;
    WorkContext->ResponseBuffer->Mdl = WorkContext->ResponseBuffer->PartialMdl;

    //
    // Send the response!
    //
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
    WorkContext->FspRestartRoutine = SrvFspRestartLargeReadAndXComplete;
    SrvStartSend2( WorkContext, SrvQueueWorkToFspAtSendCompletion );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;
}


VOID SRVFASTCALL
SrvFsdRestartWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for a Write SMB.

    This routine is called in the FSP for a write and close SMB so that
    it can free the pageable MFCB and for a write and unlock SMB so that
    it can do the unlock; for other SMBs, it is called in the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT writeLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartWrite\n" );

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the write failed, set an error status in the response header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Write failed: %X\n", status );
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = SrvFsdRestartWrite;
            QUEUE_WORK_TO_FSP( WorkContext );
            goto Cleanup;
        }

        SrvSetSmbError( WorkContext, status );

    } else {

        //
        // The write succeeded.
        //

        writeLength = (USHORT)WorkContext->Irp->IoStatus.Information;

        //
        // Save the count of bytes written, to be used to update the
        // server statistics database.
        //

        UPDATE_WRITE_STATS( WorkContext, writeLength );

        if ( rfcb->ShareType == ShareTypeDisk ) {

            //
            // Update the file position.
            //

            rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + writeLength;

            if ( WorkContext->NextCommand == SMB_COM_WRITE ) {
                response->WordCount = 1;
                SmbPutUshort( &response->Count, writeLength );
                SmbPutUshort( &response->ByteCount, 0 );

                WorkContext->ResponseParameters =
                                         NEXT_LOCATION( response, RESP_WRITE, 0 );

                //
                // Processing of the SMB is complete.  Send the response.
                //

                SrvFsdSendResponse( WorkContext );
                IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartWrite complete\n" );
                goto Cleanup;
            }

        } else if ( rfcb->ShareType == ShareTypePrint ) {

            //
            // Update the file position.
            //

            if ( WorkContext->NextCommand == SMB_COM_WRITE_PRINT_FILE ) {
                rfcb->CurrentPosition += writeLength;
            } else {
                rfcb->CurrentPosition =
                            SmbGetUlong( &request->Offset ) + writeLength;
            }
        }

        //
        // If this was a Write and Unlock request, do the unlock.  This
        // is safe because we are restarted in the FSP in this case.
        //
        // Note that if the write failed, the range remains locked.
        //

        if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_UNLOCK ) {

            IF_SMB_DEBUG(READ_WRITE1) {
                SrvPrint0( "SrvFsdRestartWrite: unlock requested -- passing request to FSP\n" );
            }

            SrvRestartWriteAndUnlock( WorkContext );
            goto Cleanup;

        } else if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ) {

            WorkContext->Parameters.LastWriteTime = SmbGetUlong(
                &((PREQ_WRITE_AND_CLOSE)request)->LastWriteTimeInSeconds );

        }

        //
        // If everything worked, build a response message.  (If something
        // failed, an error indication has already been placed in the SMB.)
        //

        if ( WorkContext->NextCommand == SMB_COM_WRITE_PRINT_FILE ) {

            //
            // ByteCount has a different offset for WRITE_PRINT_FILE
            //

            PRESP_WRITE_PRINT_FILE response2;

            response2 = (PRESP_WRITE_PRINT_FILE)WorkContext->ResponseParameters;
            response2->WordCount = 0;
            SmbPutUshort( &response2->ByteCount, 0 );

            WorkContext->ResponseParameters =
                          NEXT_LOCATION( response2, RESP_WRITE_PRINT_FILE, 0 );
        } else {

            response->WordCount = 1;
            SmbPutUshort( &response->Count, writeLength );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                                     NEXT_LOCATION( response, RESP_WRITE, 0 );
        }
    }

    //
    // If this was a Write and Close request, close the file.  It is
    // safe to close the RFCB here because if this is a Write and Close,
    // we're actually in the FSP, not in the FSD.
    //

    if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ) {

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        SrvRestartChainedClose( WorkContext );
        goto Cleanup;
    }

    //
    // Processing of the SMB is complete.  Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartWrite complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartWrite

VOID SRVFASTCALL
SrvFsdRestartPrepareMdlWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the MDL preparation completion for the large WriteAndX SMB.

    This routine initiates the receipt of transport data into the file's MDL,
    and then control resumes at SrvFsdRestartWriteAndX when the transfer of data
    from the transport is complete.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/
{
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    //
    // Make sure we call SrvFsdRestartWriteAndX at passive level when
    //  the TDI receive completes.
    //
    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;

    //
    // Make sure that we record the MDL address we're using
    //
    ASSERT( WorkContext->Parameters.WriteAndX.MdlAddress == NULL );
    WorkContext->Parameters.WriteAndX.MdlAddress = irp->MdlAddress;

    if( !NT_SUCCESS( irp->IoStatus.Status ) ) {

        //
        // Something went wrong.  Early-out to SrvFsdRestartWriteAndX.
        //
        if( KeGetCurrentIrql() < DISPATCH_LEVEL ) {
            SrvFsdRestartWriteAndX( WorkContext );
        } else {
            QUEUE_WORK_TO_FSP( WorkContext );
        }

        return;
    }

    ASSERT( irp->MdlAddress != NULL );

    //
    // Fill in the IRP for the TDI receive.  We want to receive the data into
    //  the buffer described by the MDL we've just gotten
    //

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    SET_OPERATION_START_TIME( &WorkContext );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
    irpSp->FileObject = WorkContext->Connection->FileObject;
    irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
    irpSp->Flags = 0;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;
    parameters->ReceiveFlags = 0;

    //
    // Account for the amount we are taking in
    //
    WorkContext->Parameters.WriteAndX.RemainingWriteLength -=
        WorkContext->Parameters.WriteAndX.CurrentWriteLength;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->Flags = (ULONG)IRP_BUFFERED_IO;
    irp->IoStatus.Status = 0;

    ASSERT( irp->MdlAddress != NULL );

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // Processing resumes at SrvFsdRestartWriteAndX() when we've received
    //  the data from the transport.  We will be at passive level.
    //
}

VOID SRVFASTCALL
RestartLargeWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This is the restart routine that's invoked when we have received more data from
    the transport, and we are not using MDLs to transfer the data into the file.

    This routine initiates the write to the file, and then control resumes at
    SrvFsdRestartWriteAndX when the write to the file is complete.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/
{
    PIRP irp = WorkContext->Irp;
    ULONG length;
    PRFCB rfcb = WorkContext->Rfcb;
    PLFCB lfcb = rfcb->Lfcb;

    //
    // Check if we successfully received more data from the transport
    //

    if( irp->Cancel ||
        (!NT_SUCCESS( irp->IoStatus.Status )
        && irp->IoStatus.Status != STATUS_BUFFER_OVERFLOW) ){

        SrvSetSmbError( WorkContext, irp->IoStatus.Status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    //
    // We got more data from the transport.  We need to write it out to the file if we
    //   haven't encountered any errors yet.  The irp at this point holds the results of
    //   reading more data from the transport.
    //
    length = (ULONG)irp->IoStatus.Information;

    //
    // Adjust the parameters in the WorkContext
    //
    WorkContext->Parameters.WriteAndX.RemainingWriteLength -= length;
    WorkContext->Parameters.WriteAndX.CurrentWriteLength = length;

    //
    // If we have picked up an error, we just want to keep reading from
    //  the transport and not write to the file.
    //
    if( WorkContext->Parameters.WriteAndX.FinalStatus ) {

        //
        // Indicate that we didn't write any more data to the file
        //
        WorkContext->Irp->IoStatus.Information = 0;
        WorkContext->Irp->IoStatus.Status = WorkContext->Parameters.WriteAndX.FinalStatus;

        SrvFsdRestartWriteAndX( WorkContext );

        return;
    }

    //
    // Write the data to the file
    //
    if( lfcb->FastIoWrite != NULL ) {

        try {
            if( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &WorkContext->Parameters.WriteAndX.Offset,
                    WorkContext->Parameters.WriteAndX.CurrentWriteLength,
                    TRUE,
                    WorkContext->Parameters.WriteAndX.Key,
                    WorkContext->Parameters.WriteAndX.WriteAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                //  to do postprocessing
                //
                SrvFsdRestartWriteAndX( WorkContext );


                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }
    }

    //
    // The fast path failed, use the IRP to write the data to the file
    //

    IoBuildPartialMdl(
        WorkContext->RequestBuffer->Mdl,
        WorkContext->RequestBuffer->PartialMdl,
        WorkContext->Parameters.WriteAndX.WriteAddress,
        WorkContext->Parameters.WriteAndX.CurrentWriteLength
        );

    //
    // Build the IRP.
    //
    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_WRITE,                   // major function code
            0,                              // minor function code
            WorkContext->Parameters.WriteAndX.WriteAddress,
            WorkContext->Parameters.WriteAndX.CurrentWriteLength,
            WorkContext->RequestBuffer->PartialMdl,
            WorkContext->Parameters.WriteAndX.Offset,
            WorkContext->Parameters.WriteAndX.Key
    );

    //
    // Ensure that processing resumes in SrvFsdRestartWriteAndX when the
    //  write has completed.  If this is the first part of a large write,
    //  we want to ensure that SrvFsdRestartWriteAndX is called at passive
    //  level because it might decide to use the cache manager to handle the
    //  rest of the write.
    //
    if ( WorkContext->Parameters.WriteAndX.InitialComplete ) {
        WorkContext->FsdRestartRoutine = SrvFsdRestartWriteAndX;
    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // Processing resumes at SrvFsdRestartWriteAndX() when the file write
    //  is complete.
    //
}


VOID SRVFASTCALL
SrvFsdRestartWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine may be called in the FSD or the FSP.  If the chained
    command is Close, it will be called in the FSP.

    If WorkContext->LargeIndication is set, this means we are processing
    the flavor of WriteAndX that exceeds our negotiated buffer size.  There may
    be more data that we need to fetch from the transport.  We may or may not be
    doing MDL writes to the file.

    If there is no more data to be gotten from the transport, we send the response
    to the client.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/

{
    PREQ_WRITE_ANDX request;
    PREQ_NT_WRITE_ANDX ntRequest;
    PRESP_WRITE_ANDX response;

    PRFCB rfcb =        WorkContext->Rfcb;
    PIRP irp =          WorkContext->Irp;
    NTSTATUS status =   irp->IoStatus.Status;
    ULONG writeLength = (ULONG)irp->IoStatus.Information;

    ULONG requestedWriteLength;
    UCHAR nextCommand;
    USHORT nextOffset;
    USHORT reqAndXOffset;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    PREQ_CLOSE closeRequest;

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_AND_X;
        //SrvReferenceWorkItem(WorkContext);
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartWriteAndX\n" );

    //
    // Get the request and response parameter pointers.
    //
    request = (PREQ_WRITE_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If we are using MDL transfers and we have more data to get from the client
    //  then STATUS_BUFFER_OVERFLOW is simply an indication from the transport that
    //  it has more data to give to us.  We consider that a success case for the
    //  purposes of this routine.
    //
    if( status == STATUS_BUFFER_OVERFLOW &&
        WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.MdlAddress &&
        WorkContext->Parameters.WriteAndX.RemainingWriteLength ) {

        status = STATUS_SUCCESS;
    }

    //
    // Remember where the follow-on request begins, and what the next
    // command is, as we are about to overwrite this information.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    nextCommand = request->AndXCommand;
    WorkContext->NextCommand = nextCommand;
    nextOffset = SmbGetUshort( &request->AndXOffset );

    //
    // If the write failed, set an error status in the response header.
    // We still return a valid parameter block, in case some bytes were
    // written before the error occurred.  Note that we do _not_ process
    // the next command if the write failed.
    //
    // *** OS/2 server behavior.  Note that this is _not_ done for core
    //     Write.
    //

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Write failed: %X\n", status );
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
            QUEUE_WORK_TO_FSP( WorkContext );
            goto Cleanup;
        }

        if( WorkContext->LargeIndication ) {
            //
            // Once this error code is set, we cease writing to the file.  But
            //  we still need to consume the rest of the data that was sent to us
            //  by the client.
            //
            WorkContext->Parameters.WriteAndX.FinalStatus = status;
        }

        SrvSetSmbError( WorkContext, status );
        nextCommand = SMB_COM_NO_ANDX_COMMAND;


        IF_SYSCACHE_RFCB( rfcb ) {
            KdPrint(( "SrvFsdRestartWriteAndX rfcb %p Status %x\n", rfcb, status ));
        }
    }
    else
    {
        IF_SYSCACHE_RFCB( rfcb ) {
            KdPrint(( "SrvFsdRestartWriteAndX  write success rfcb %p Offset %x Length %x\n", rfcb,
                      WorkContext->Parameters.WriteAndX.Offset.LowPart, WorkContext->Parameters.WriteAndX.CurrentWriteLength ));
        }
    }

    //
    // Update the file position.
    //

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // We will ignore the distinction between clients that supply 32-bit
        // and 64-bit file offsets. The reason for doing this is because
        // the only clients that will use CurrentPosition is a 32-bit file
        // offset client. Therefore, the upper 32-bits will never be used
        // anyway.  In addition, the RFCB is per client, so there is no
        // possibility of clients mixing 32-bit and 64-bit file offsets.
        // Therefore, for the 64-bit client, we will only read 32-bits of file
        // offset.
        //

        if ( request->ByteCount == 12 ) {

            //
            // The client supplied a 32-bit file offset.
            //

            rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + writeLength;

        } else {

            //
            // The client supplied a 64-bit file offset. Only use 32-bits of
            // file offset.
            //

            rfcb->CurrentPosition = SmbGetUlong( &ntRequest->Offset ) + writeLength;

        }
    }

    //
    // Save the count of bytes written, to be used to update the server
    // statistics database.
    //

    UPDATE_WRITE_STATS( WorkContext, writeLength );

    IF_SMB_DEBUG(READ_WRITE1) {
        SrvPrint2( "SrvFsdRestartWriteAndX:  Fid 0x%lx, wrote %ld bytes\n",
                  rfcb->Fid, writeLength );
    }

    //
    // If we are doing large transfers, and there is still more to go, then we
    //  need to keep the cycle going.
    //
    if( WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.RemainingWriteLength ) {

        PIO_STACK_LOCATION irpSp;
        PTDI_REQUEST_KERNEL_RECEIVE parameters;
        LARGE_INTEGER      PreviousWriteOffset;
        BOOLEAN fAppending = TRUE;

        PreviousWriteOffset = WorkContext->Parameters.WriteAndX.Offset;

        //
        // If we are only appending, do not change the offset
        //
        if( PreviousWriteOffset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {

            WorkContext->Parameters.WriteAndX.Offset.QuadPart += writeLength;
            fAppending = FALSE;
        }

        //
        // If we haven't tried an MDL write yet, or if we are already using
        //   MDLs, then we want to keep using MDLs
        //
        if( NT_SUCCESS( status ) && fAppending == FALSE &&
            ( WorkContext->Parameters.WriteAndX.InitialComplete == FALSE ||
              ( WorkContext->Parameters.WriteAndX.MdlAddress &&
                WorkContext->Parameters.WriteAndX.RemainingWriteLength != 0 )
            ) ) {

            PLFCB lfcb = rfcb->Lfcb;
            NTSTATUS mdlStatus;

            ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

            WorkContext->Parameters.WriteAndX.InitialComplete = TRUE;

            //
            // If we already have an MDL, complete it now since we've already asked
            //  TDI to fill the buffer.
            //
            if( WorkContext->Parameters.WriteAndX.MdlAddress ) {

                irp->MdlAddress = WorkContext->Parameters.WriteAndX.MdlAddress;
                irp->IoStatus.Information = writeLength;

                if( lfcb->MdlWriteComplete == NULL ||

                    lfcb->MdlWriteComplete( lfcb->FileObject,
                                            &PreviousWriteOffset,
                                            WorkContext->Parameters.WriteAndX.MdlAddress,
                                            lfcb->DeviceObject
                                          ) == FALSE ) {

                        mdlStatus = SrvIssueMdlCompleteRequest( WorkContext,
                                             NULL,
                                             WorkContext->Parameters.WriteAndX.MdlAddress,
                                             IRP_MJ_WRITE,
                                             &PreviousWriteOffset,
                                             writeLength
                                            );

                    if( !NT_SUCCESS( mdlStatus ) ) {
                        SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, mdlStatus );
                        if( NT_SUCCESS( status ) ) {
                            WorkContext->Parameters.WriteAndX.FinalStatus = status = mdlStatus;
                        }

                        IF_SYSCACHE_RFCB( rfcb ) {
                            KdPrint(( "FastIoWrite MdlComplete failed Rfcb %p Status %x\n", rfcb, mdlStatus ));
                        }
                    }
                    else
                    {
                        IF_SYSCACHE_RFCB( rfcb ) {
                            KdPrint(( "FastIoWrite MdlComplete succeeded Rfcb %p Offset %x Length %x\n", rfcb,
                                      WorkContext->Parameters.WriteAndX.Offset.LowPart, WorkContext->Parameters.WriteAndX.CurrentWriteLength ));
                        }
                    }
                }

                //
                // We have disposed of this MDL, get it out of our structures!
                //
                WorkContext->Parameters.WriteAndX.MdlAddress = NULL;
                irp->MdlAddress = NULL;
            }

            //
            // If we have more than 1 buffer's worth remaing, and if the filesystem
            // supports MDL writes, then let's do MDL writes
            //
            if( NT_SUCCESS( status ) &&
                (WorkContext->Parameters.WriteAndX.RemainingWriteLength >
                WorkContext->Parameters.WriteAndX.BufferLength)  &&
                (lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

                LARGE_INTEGER offset;
                ULONG remainingLength;

                irp->IoStatus.Information = 0;
                irp->UserBuffer = NULL;
                irp->MdlAddress = NULL;

                //
                // Figure out how big we want this MDL attempt to be.  We could
                //  map the whole thing in, but we don't want any single client request
                //  to lock down too much of the cache.
                //
                WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN (
                           WorkContext->Parameters.WriteAndX.RemainingWriteLength,
                           SrvMaxWriteChunk
                           );

                if( lfcb->PrepareMdlWrite &&
                    lfcb->PrepareMdlWrite(
                        lfcb->FileObject,
                        &WorkContext->Parameters.WriteAndX.Offset,
                        WorkContext->Parameters.WriteAndX.CurrentWriteLength,
                        WorkContext->Parameters.WriteAndX.Key,
                        &irp->MdlAddress,
                        &irp->IoStatus,
                        lfcb->DeviceObject
                        ) && irp->MdlAddress != NULL ) {

                    //
                    // The fast path worked!
                    //
                    SrvFsdRestartPrepareMdlWriteAndX( WorkContext );
                    goto Cleanup;
                }

                //
                // The fast path failed, build the write request.  The fast path
                //  may have partially succeeded, returning a partial MDL chain.
                //  We need to adjust our write request to account for that.
                //
                offset.QuadPart = WorkContext->Parameters.WriteAndX.Offset.QuadPart;

                //
                // If we are not just appending, adjust the offset
                //
                if( offset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {
                    offset.QuadPart += irp->IoStatus.Information;
                }

                remainingLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength -
                                  (ULONG)irp->IoStatus.Information;

                SrvBuildReadOrWriteRequest(
                        irp,                                // input IRP address
                        lfcb->FileObject,                   // target file object address
                        WorkContext,                        // context
                        IRP_MJ_WRITE,                       // major function code
                        IRP_MN_MDL,                         // minor function code
                        NULL,                               // buffer address (ignored)
                        remainingLength,
                        irp->MdlAddress,
                        offset,
                        WorkContext->Parameters.WriteAndX.Key
                        );

                WorkContext->bAlreadyTrace = TRUE;
                WorkContext->FsdRestartRoutine = SrvFsdRestartPrepareMdlWriteAndX;

                (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );
                goto Cleanup;
            }
        }

        //
        // We aren't doing MDL operations, so read the data from the transport into
        //  the SMB buffer.
        //
        WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN(
            WorkContext->Parameters.WriteAndX.RemainingWriteLength,
            WorkContext->Parameters.WriteAndX.BufferLength
            );

        //
        // Fill in the IRP for the receive
        //
        irp->Tail.Overlay.OriginalFileObject = NULL;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //
        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine
        //
        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        SET_OPERATION_START_TIME( &WorkContext );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLargeWriteAndX;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
        irpSp->FileObject = WorkContext->Connection->FileObject;
        irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
        irpSp->Flags = 0;

        parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
        parameters->ReceiveLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;
        parameters->ReceiveFlags = 0;

        //
        // Set the buffer's partial mdl to point just after the header for this
        // WriteAndX SMB.  We need to preserve the header to make it easier to send
        // back the response.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            WorkContext->Parameters.WriteAndX.WriteAddress,
            WorkContext->Parameters.WriteAndX.CurrentWriteLength
        );

        irp->MdlAddress = WorkContext->RequestBuffer->PartialMdl;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;        // ???

        (VOID)IoCallDriver( irpSp->DeviceObject, irp );

        goto Cleanup;
    }

    //
    // We have no more data to write to the file.  Clean up
    //  and send a response to the client
    //

    //
    // If we are working on a large write using MDLs,
    //  then we need to clean up the MDL
    //
    if( WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.MdlAddress ) {

        PLFCB lfcb = rfcb->Lfcb;
        NTSTATUS mdlStatus;

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        irp->MdlAddress = WorkContext->Parameters.WriteAndX.MdlAddress;
        irp->IoStatus.Information = writeLength;

        //
        // Tell the filesystem that we're done with it
        //
        if( lfcb->MdlWriteComplete == NULL ||

            lfcb->MdlWriteComplete( lfcb->FileObject,
                                    &WorkContext->Parameters.WriteAndX.Offset,
                                    WorkContext->Parameters.WriteAndX.MdlAddress,
                                    lfcb->DeviceObject
                                  ) == FALSE ) {

                mdlStatus = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 WorkContext->Parameters.WriteAndX.MdlAddress,
                                                 IRP_MJ_WRITE,
                                                 &WorkContext->Parameters.WriteAndX.Offset,
                                                 writeLength
                    );

            if( !NT_SUCCESS( mdlStatus ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, mdlStatus );
                if( NT_SUCCESS( status ) ) {
                    status = mdlStatus;
                }


                IF_SYSCACHE_RFCB( rfcb ) {
                    KdPrint(( "MDL complete failed - Rfcb %p Status %x", rfcb, mdlStatus ));
                }
            }
            else
            {
                IF_SYSCACHE_RFCB( rfcb ) {
                    KdPrint(( "FastIoWrite MdlComplete succeeded Rfcb %p Offset %x Length %x\n", rfcb,
                              WorkContext->Parameters.WriteAndX.Offset.LowPart, WorkContext->Parameters.WriteAndX.CurrentWriteLength ));
                }
            }
        }
        else {
            IF_SYSCACHE_RFCB( rfcb ) {
                KdPrint(( "FastIoWrite MdlComplete succeeded Rfcb %p Offset %x Length %x\n", rfcb,
                          WorkContext->Parameters.WriteAndX.Offset.LowPart, WorkContext->Parameters.WriteAndX.CurrentWriteLength ));
            }
        }

        irp->MdlAddress = NULL;
    }

    //
    // Build the response message.
    //
    requestedWriteLength = SmbGetUshort( &request->DataLength );

    if( WorkContext->LargeIndication ) {

        requestedWriteLength |= (SmbGetUshort( &ntRequest->DataLengthHigh ) << 16);

        writeLength = requestedWriteLength -
                      WorkContext->Parameters.WriteAndX.RemainingWriteLength;
    }

    SmbPutUlong( &response->Reserved, 0 );
    SmbPutUshort( &response->CountHigh, (USHORT)(writeLength >> 16) );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_WRITE_ANDX,
            0
            )
        );

    response->WordCount = 6;

    if ( rfcb->ShareType == ShareTypeDisk ||
        WorkContext->Parameters.Transaction == NULL ) {

        SmbPutUshort( &response->Count, (USHORT)writeLength );

    } else {

        SmbPutUshort( &response->Count, (USHORT)requestedWriteLength );
    }

    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    WorkContext->RequestParameters = (PUCHAR)WorkContext->RequestHeader + reqAndXOffset;

    IF_STRESS() {
        // If this was a paging write that failed, log an error
        PNT_SMB_HEADER pHeader = (PNT_SMB_HEADER)WorkContext->RequestHeader;
        if( !NT_SUCCESS(pHeader->Status.NtStatus) && (pHeader->Flags2 & SMB_FLAGS2_PAGING_IO) )
        {
            KdPrint(("Paging Write failure from %z (%x)\n", (PCSTRING)&WorkContext->Connection->OemClientMachineNameString, pHeader->Status.NtStatus ));
        }
    }

    //
    // If this was a raw mode write, queue the work to the FSP for
    // completion.  The FSP routine will handling dispatching of the
    // AndX command.
    //

    if ( rfcb->ShareType != ShareTypeDisk &&
        WorkContext->Parameters.Transaction != NULL ) {

        WorkContext->FspRestartRoutine = SrvRestartWriteAndXRaw;
        SrvQueueWorkToFsp( WorkContext );
        goto Cleanup;
    }

    if( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {
        //
        // No more commands.  Send the response.
        //

        SrvFsdSendResponse( WorkContext );
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvFsdRestartWriteAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Status = STATUS_INVALID_SMB;
            WorkContext->FspRestartRoutine = SrvBuildAndSendErrorResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            SrvFsdSendResponse( WorkContext );
        }
        goto Cleanup;
    }

    //
    // Test for a legal followon command, and dispatch as appropriate.
    // Close is handled specially.
    //

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_LOCK_AND_READ:
    case SMB_COM_WRITE_ANDX:

        //
        // Queue the work item back to the FSP for further processing.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToFsp( WorkContext );

        break;

    case SMB_COM_CLOSE:

        //
        // Save the last write time, to correctly set it.  Call
        // SrvRestartChainedClose to close the file and send the response.
        //

        closeRequest = (PREQ_CLOSE)
            ((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        //
        // Make sure we stay within the received SMB
        //
        if( (PCHAR)closeRequest + FIELD_OFFSET( REQ_CLOSE, ByteCount)
            <= END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime =
                closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );
            break;
        }

        /* Falls Through! */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvFsdRestartWriteAndX: Illegal followon "
                        "command: 0x%lx\n", nextCommand );
        }

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Status = STATUS_INVALID_SMB;
            WorkContext->FspRestartRoutine = SrvBuildAndSendErrorResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            SrvFsdSendResponse( WorkContext );
        }

    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartWriteAndX complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
        // SrvFsdDereferenceWorkItem(WorkContext);
    }
    return;

} // SrvFsdRestartWriteAndX

#if SRVCATCH
BYTE CatchPrototype[] = ";UUIDREF=";
VOID
SrvUpdateCatchBuffer (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PBYTE Buffer,
    IN DWORD BufferLength
    )
{
    BYTE idBuffer[ 100 ];
    PBYTE p, ep = idBuffer;
    USHORT bytesRemaining = sizeof( idBuffer );
    UNICODE_STRING userName, domainName;
    OEM_STRING oemString;
    ULONG requiredLength;

    if( BufferLength <= sizeof( CatchPrototype ) ) {
        return;
    }

    if( WorkContext->Session == 0 ) {
        SrvVerifyUid( WorkContext, SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
    }

    if( WorkContext->Session &&
        NT_SUCCESS( SrvGetUserAndDomainName( WorkContext->Session, &userName, &domainName ) ) ) {

        if( userName.Length && NT_SUCCESS( RtlUnicodeStringToOemString( &oemString, &userName, TRUE ) ) ) {
            if( bytesRemaining >= oemString.Length + 1 ) {
                RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
                ep += oemString.Length;
                *ep++ = '\\';
                bytesRemaining -= (oemString.Length + 1);
                RtlFreeOemString( &oemString );
            }
        }

        if( domainName.Length && NT_SUCCESS( RtlUnicodeStringToOemString( &oemString, &domainName, TRUE ) ) ) {
            if( bytesRemaining >= oemString.Length ) {
                RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
                ep += oemString.Length;
                bytesRemaining -= oemString.Length;
                RtlFreeOemString( &oemString );
            }
        }

        SrvReleaseUserAndDomainName( WorkContext->Session, &userName, &domainName );
    }

    if( WorkContext->Connection && bytesRemaining ) {

        oemString = WorkContext->Connection->OemClientMachineNameString;

        if( oemString.Length && oemString.Length < bytesRemaining + 1 ) {
            *ep++ = ' ';
            RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
            ep += oemString.Length;
            bytesRemaining -= oemString.Length;
        }
    }

    //
    // Insert the CatchPrototype into the output buffer
    //
    if( WorkContext->Rfcb->SrvCatch == 1 )
    {
        RtlCopyMemory( Buffer, CatchPrototype, sizeof( CatchPrototype )-1 );
        Buffer += sizeof( CatchPrototype )-1;
        BufferLength -= (sizeof( CatchPrototype ) - 1);

        //
        // Encode the information
        //
        for( p = idBuffer; BufferLength >= 3 && p < ep; p++, BufferLength =- 2 ) {
            *Buffer++ = SrvHexChars[ ((*p) >> 4) & 0xf ];
            *Buffer++ = SrvHexChars[ (*p) & 0xf ];
        }

        if( BufferLength >= 3 ) {
            *Buffer++ = '\r';
            *Buffer++ = '\n';
            *Buffer++ = ';';
        }
    }
    else if( WorkContext->Rfcb->SrvCatch == 2 )
    {
        PBYTE InnerBuffer;
        ULONG Offset;

        Offset = SrvFindCatchOffset( Buffer, BufferLength );
        if( Offset )
        {
            InnerBuffer = Buffer + Offset;
            BufferLength = 1020;

            RtlCopyMemory( InnerBuffer, CatchPrototype, sizeof( CatchPrototype )-1 );
            InnerBuffer += sizeof( CatchPrototype )-1;
            BufferLength -= (sizeof( CatchPrototype ) - 1);

            //
            // Encode the information
            //
            for( p = idBuffer; BufferLength >= 3 && p < ep; p++, BufferLength =- 2 ) {
                *InnerBuffer++ = SrvHexChars[ ((*p) >> 4) & 0xf ];
                *InnerBuffer++ = SrvHexChars[ (*p) & 0xf ];
            }

            if( BufferLength >= 3 ) {
                *InnerBuffer++ = '\r';
                *InnerBuffer++ = '\n';
                *InnerBuffer++ = ';';
            }

            SrvCorrectCatchBuffer( Buffer, Offset );
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\heapmgr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapmgr.c

Abstract:

    This module contains initialization and termination routines for
    server FSP heap, as well as debug routines for memory tracking.

--*/

#include "precomp.h"
#include "heapmgr.tmh"
#pragma hdrstop

// Make the retry time 15 milli-seconds
#define SRV_LOW_PRIORITY_RETRY_TIME -1*1000*10*15

#ifdef POOL_TAGGING
//
// Array correlating BlockType numbers to pool tags.
//
// *** This array must be maintained in concert with the BlockType
//     definitions in srvblock.h!
//

ULONG SrvPoolTags[BlockTypeMax-1] = {
        'fbSL',     // BlockTypeBuffer
        'ncSL',     // BlockTypeConnection
        'peSL',     // BlockTypeEndpoint
        'flSL',     // BlockTypeLfcb
        'fmSL',     // BlockTypeMfcb
        'frSL',     // BlockTypeRfcb
        'rsSL',     // BlockTypeSearch
        'csSL',     // BlockTypeSearchCore
        'lbSL',     // BlockTypeByteRangeLock       for persistent handles
        'ssSL',     // BlockTypeSession
        'hsSL',     // BlockTypeShare
        'rtSL',     // BlockTypeTransaction
        'ctSL',     // BlockTypeTreeConnect
        'poSL',     // BlockTypeOplockBreak
        'dcSL',     // BlockTypeCommDevice
        'iwSL',     // BlockTypeWorkContextInitial
        'nwSL',     // BlockTypeWorkContextNormal
        'rwSL',     // BlockTypeWorkContextRaw
        'swSL',     // BlockTypeWorkContextSpecial
        'dcSL',     // BlockTypeCachedDirectory
        'bdSL',     // BlockTypeDataBuffer
        'btSL',     // BlockTypeTable
        'hnSL',     // BlockTypeNonpagedHeader
        'cpSL',     // BlockTypePagedConnection
        'rpSL',     // BlockTypePagedRfcb
        'mpSL',     // BlockTypePagedMfcb
        'itSL',     // BlockTypeTimer
        'caSL',     // BlockTypeAdminCheck
        'qwSL',     // BlockTypeWorkQueue
        'fsSL',     // BlockTypeDfs
        'rlSL',     // BlockTypeLargeReadX
        'saSL',     // BlockTypeAdapterStatus
        'rsSL',     // BlockTypeShareRemark
        'dsSL',     // BlockTypeShareSecurityDescriptor
        'ivSL',     // BlockTypeVolumeInformation
        'nfSL',     // BlockTypeFSName
        'inSL',     // BlockTypeNameInfo
        'idSL',     // BlockTypeDirectoryInfo
        'cdSL',     // BlockTypeDirCache
        'imSL',     // BlockTypeMisc
        'nsSL',     // BlockTypeSnapShot
        'esSL',     // BlockTypeSecurityContext
        };

#endif // def POOL_TAGGING

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocatePagedPool )
#pragma alloc_text( PAGE, SrvFreePagedPool )
#pragma alloc_text( PAGE, SrvClearLookAsideList )
#endif
#if 0
NOT PAGEABLE -- SrvAllocateNonPagedPool
NOT PAGEABLE -- SrvFreeNonPagedPool
#endif

extern LONG SrvMemoryAllocationRetries;
extern LONG SrvMemoryAllocationRetriesSuccessful;


PVOID SRVFASTCALL
SrvInterlockedAllocate( PLOOK_ASIDE_LIST l, ULONG NumberOfBytes, PLONG statistics )
{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *pentry = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                            l->LargeFreeList : l->SmallFreeList;

    PPOOL_HEADER *pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        //
        // Exchange with the lookaside spot and see if we get anything
        //

        newPool = NULL;
        newPool = (PPOOL_HEADER)InterlockedExchangePointer( pentry, newPool );

        if( newPool == NULL ) {
            continue;
        }

        if( newPool->RequestedSize >= NumberOfBytes ) {
            //
            // The one we got is big enough!  Return it.
            //
            ++(l->AllocHit);
            return newPool + 1;
        }

        //
        // It wasn't big enough, so put it back.
        //
        newPool = (PPOOL_HEADER)InterlockedExchangePointer( pentry, newPool );
        if( newPool == NULL ) {
            continue;
        }

        //
        // Oops, somebody else freed some memory to this spot.  Can we use it?
        //
        if( newPool->RequestedSize >= NumberOfBytes ) {
            //
            // We can use it!
            //
            ++(l->AllocHit);
            return newPool + 1;
        }

        //
        // Can't use the memory -- so really free it and keep looking
        //
        if( statistics ) {
            InterlockedExchangeAdd(
                statistics,
                -(LONG)newPool->RequestedSize
                );
        }

        ExFreePool( newPool );

    } while( ++pentry < pend );

    ++(l->AllocMiss);
    return NULL;
}

PPOOL_HEADER SRVFASTCALL
SrvInterlockedFree( PPOOL_HEADER block )
{
    PPOOL_HEADER *pentry = block->FreeList;
    PPOOL_HEADER *pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {

        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

    } while( block != NULL && ++pentry < pend );

    return block;
}

VOID SRVFASTCALL
SrvClearLookAsideList( PLOOK_ASIDE_LIST l, VOID (SRVFASTCALL *FreeRoutine )( PVOID ) )
{
    PPOOL_HEADER *pentry, *pend, block;

    PAGED_CODE();

    //
    // Clear out the list of large chunks
    //
    pentry = l->LargeFreeList;
    pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        block = NULL;
        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

        if( block != NULL ) {
            block->FreeList = NULL;
            FreeRoutine( block + 1 );
        }

    } while( ++pentry < pend );

    //
    // Clear out the list of small chunks
    //
    pentry = l->SmallFreeList;
    pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        block = NULL;
        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

        if( block != NULL ) {
            block->FreeList = NULL;
            FreeRoutine( block + 1 );
        }

    } while( ++pentry < pend );
}


PVOID SRVFASTCALL
SrvAllocateNonPagedPool (
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    , IN CLONG BlockType
#endif
    )

/*++

Routine Description:

    This routine allocates nonpaged pool in the server.  A check is
    made to ensure that the server's total nonpaged pool usage is below
    the configurable limit.

Arguments:

    NumberOfBytes - the number of bytes to allocate.

    BlockType - the type of block (used to pass pool tag to allocator)

Return Value:

    PVOID - a pointer to the allocated memory or NULL if the memory could
       not be allocated.

--*/

{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *FreeList = NULL;
    ULONG newUsage;
    BOOLEAN IsLowPriority = FALSE;
    LARGE_INTEGER interval;

#ifdef POOL_TAGGING
    ASSERT( BlockType > 0 && BlockType < BlockTypeMax );
#endif

    //
    // Pull this allocation off the per-processor free list if we can
    //
    if( SrvWorkQueues ) {

        PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

        if( NumberOfBytes <= queue->NonPagedPoolLookAsideList.MaxSize ) {

            newPool = SrvInterlockedAllocate(
                                &queue->NonPagedPoolLookAsideList,
                                NumberOfBytes,
                                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage
                                );

            if( newPool != NULL ) {
                return newPool;
            }

            FreeList = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                    queue->NonPagedPoolLookAsideList.LargeFreeList :
                                    queue->NonPagedPoolLookAsideList.SmallFreeList ;
        }
    }

    //
    // Account for this allocation in the statistics database and make
    // sure that this allocation will not put us over the limit of
    // nonpaged pool that we can allocate.
    //

    newUsage = InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                       (LONG)NumberOfBytes );
    newUsage += NumberOfBytes;

    if ( newUsage > SrvMaxNonPagedPoolUsage ) {

        //
        // Count the failure, but do NOT log an event.  The scavenger
        // will log an event when it next wakes up.  This keeps us from
        // flooding the event log.
        //

        SrvNonPagedPoolLimitHitCount++;
        SrvStatistics.NonPagedPoolFailures++;

        InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                -(LONG)NumberOfBytes );

        return NULL;

    }

    if (SrvStatistics.CurrentNonPagedPoolUsage > SrvStatistics.PeakNonPagedPoolUsage) {
        SrvStatistics.PeakNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
    }

    //
    // Do the actual memory allocation.  Allocate extra space so that we
    // can store the size of the allocation for the free routine.
    //
    if( NumberOfBytes > 2*4096 )
    {
        IsLowPriority = TRUE;
    }

    newPool = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                IsLowPriority ? LowPoolPriority : NormalPoolPriority
                );

    if( (newPool == NULL) && IsLowPriority && (KeGetCurrentIrql() <= APC_LEVEL) )
    {
        interval.QuadPart = SRV_LOW_PRIORITY_RETRY_TIME;
        InterlockedIncrement( &SrvMemoryAllocationRetries );

        // Wait and try again
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        newPool = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                LowPoolPriority
                );

        if( newPool )
        {
            InterlockedIncrement( &SrvMemoryAllocationRetriesSuccessful );
        }
    }


    //
    // If the system couldn't satisfy the request, return NULL.
    //

    if ( newPool != NULL ) {
        //
        // Save the size of this block in the extra space we allocated.
        //

        newPool->RequestedSize = NumberOfBytes;
        newPool->FreeList = FreeList;

        //
        // Return a pointer to the memory after the size longword.
        //

        return (PVOID)( newPool + 1 );
    }

    //
    // Count the failure, but do NOT log an event.  The scavenger
    // will log an event when it next wakes up.  This keeps us from
    // flooding the event log.
    //

    SrvStatistics.NonPagedPoolFailures++;


    InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                -(LONG)NumberOfBytes );

    return NULL;

} // SrvAllocateNonPagedPool

VOID SRVFASTCALL
SrvFreeNonPagedPool (
    IN PVOID Address
    )

/*++

Routine Description:

    Frees the memory allocated by a call to SrvAllocateNonPagedPool.
    The statistics database is updated to reflect the current nonpaged
    pool usage.

Arguments:

    Address - the address of allocated memory returned by
        SrvAllocateNonPagedPool.

Return Value:

    None.

--*/

{
    PPOOL_HEADER actualBlock = (PPOOL_HEADER)Address - 1;

    //
    // See if we can stash this bit of memory away in the NonPagedPoolFreeList
    //
    if( actualBlock->FreeList ) {

        actualBlock = SrvInterlockedFree( actualBlock );
    }

    if( actualBlock != NULL ) {

        //
        // Update the nonpaged pool usage statistic.
        //
        InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                -(LONG)actualBlock->RequestedSize
                );

        //
        // Free the pool and return.
        //

        ExFreePool( actualBlock );
    }

} // SrvFreeNonPagedPool


PVOID SRVFASTCALL
SrvAllocatePagedPool (
    IN POOL_TYPE PoolType,
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    , IN CLONG BlockType
#endif
    )

/*++

Routine Description:

    This routine allocates Paged pool in the server.  A check is
    made to ensure that the server's total Paged pool usage is below
    the configurable limit.

Arguments:

    NumberOfBytes - the number of bytes to allocate.

    BlockType - the type of block (used to pass pool tag to allocator)

Return Value:

    PVOID - a pointer to the allocated memory or NULL if the memory could
       not be allocated.

--*/

{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *FreeList = NULL;
    ULONG newUsage;
    BOOLEAN IsLowPriority = FALSE;
    LARGE_INTEGER interval;

    PAGED_CODE();

#ifdef POOL_TAGGING
    ASSERT( BlockType > 0 && BlockType < BlockTypeMax );
#endif

    //
    // Pull this allocation off the per-processor free list if we can
    //
    if( SrvWorkQueues ) {

        PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

        if( NumberOfBytes <= queue->PagedPoolLookAsideList.MaxSize ) {

            newPool = SrvInterlockedAllocate(
                                &queue->PagedPoolLookAsideList,
                                NumberOfBytes,
                                (PLONG)&SrvStatistics.CurrentPagedPoolUsage
                              );

            if( newPool != NULL ) {
                return newPool;
            }

            FreeList = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                    queue->PagedPoolLookAsideList.LargeFreeList :
                                    queue->PagedPoolLookAsideList.SmallFreeList ;
        }
    }

    //
    // Account for this allocation in the statistics database and make
    // sure that this allocation will not put us over the limit of
    // nonpaged pool that we can allocate.
    //


    newUsage = InterlockedExchangeAdd(  (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                                        (LONG)NumberOfBytes );
    newUsage += NumberOfBytes;

    if ( newUsage > SrvMaxPagedPoolUsage ) {

        //
        // Count the failure, but do NOT log an event.  The scavenger
        // will log an event when it next wakes up.  This keeps us from
        // flooding the event log.
        //

        SrvPagedPoolLimitHitCount++;
        SrvStatistics.PagedPoolFailures++;

        InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                                -(LONG)NumberOfBytes );

        return NULL;
    }

    if (SrvStatistics.CurrentPagedPoolUsage > SrvStatistics.PeakPagedPoolUsage ) {
        SrvStatistics.PeakPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
    }

    //
    // Do the actual memory allocation.  Allocate extra space so that we
    // can store the size of the allocation for the free routine.
    //
    if( NumberOfBytes > 2*4096 )
    {
        IsLowPriority = TRUE;
    }

    newPool = ExAllocatePoolWithTagPriority(
                PoolType,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                IsLowPriority ? LowPoolPriority : NormalPoolPriority
                );

    if( (newPool == NULL) && IsLowPriority && (KeGetCurrentIrql() <= APC_LEVEL) )
    {
        interval.QuadPart = SRV_LOW_PRIORITY_RETRY_TIME;
        InterlockedIncrement( &SrvMemoryAllocationRetries );

        // Wait and try again
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        newPool = ExAllocatePoolWithTagPriority(
                PoolType,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                LowPoolPriority
                );

        if( newPool )
        {
            InterlockedIncrement( &SrvMemoryAllocationRetriesSuccessful );
        }
    }

    if( newPool != NULL ) {

        newPool->FreeList = FreeList;
        newPool->RequestedSize = NumberOfBytes;

        //
        // Return a pointer to the memory after the POOL_HEADER
        //

        return newPool + 1;
    }

    //
    // If the system couldn't satisfy the request, return NULL.
    //
    // Count the failure, but do NOT log an event.  The scavenger
    // will log an event when it next wakes up.  This keeps us from
    // flooding the event log.
    //

    SrvStatistics.PagedPoolFailures++;

    InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                            -(LONG)NumberOfBytes );


    return NULL;


} // SrvAllocatePagedPool

VOID SRVFASTCALL
SrvFreePagedPool (
    IN PVOID Address
    )

/*++

Routine Description:

    Frees the memory allocated by a call to SrvAllocatePagedPool.
    The statistics database is updated to reflect the current Paged
    pool usage.  If this routine is change, look at scavengr.c

Arguments:

    Address - the address of allocated memory returned by
        SrvAllocatePagedPool.

Return Value:

    None.

--*/

{
    PPOOL_HEADER actualBlock = (PPOOL_HEADER)Address - 1;

    PAGED_CODE();

    ASSERT( actualBlock != NULL );

    //
    // See if we can stash this bit of memory away in the PagedPoolFreeList
    //
    if( actualBlock->FreeList ) {

        actualBlock = SrvInterlockedFree( actualBlock );
    }

    if( actualBlock != NULL ) {

        //
        // Update the Paged pool usage statistic.
        //

        ASSERT( SrvStatistics.CurrentPagedPoolUsage >= actualBlock->RequestedSize );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
            -(LONG)actualBlock->RequestedSize
            );

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );

        //
        // Free the pool and return.
        //

        ExFreePool( actualBlock );
    }

} // SrvFreePagedPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\ipx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ipx.c

Abstract:

    This module implements IPX transport handling for the server.

Author:

    Chuck Lenzmeier (chuckl)    28-Oct-1993

Revision History:

--*/

#include "precomp.h"
#include "ipx.tmh"
#pragma hdrstop

#if SRVDBG_PERF
BOOLEAN Trap512s = FALSE;
BOOLEAN Break512s = FALSE;
ULONG Trapped512s = 0;
BOOLEAN UnlocksGoFast = TRUE;
BOOLEAN OpensGoSlow = TRUE;
BOOLEAN GlommingAllowed = TRUE;
#endif

#define NAME_CLAIM_ATTEMPTS 5
#define NAME_CLAIM_INTERVAL 500 // milliseconds

#define MPX_HEADER_SIZE (sizeof(SMB_HEADER) + sizeof(REQ_WRITE_MPX))

PCONNECTION
GetIpxConnection (
    IN PWORK_CONTEXT WorkContext,
    IN PENDPOINT Endpoint,
    IN PTDI_ADDRESS_IPX ClientAddress,
    IN PUCHAR ClientName
    );

VOID
PurgeIpxConnections (
    IN PENDPOINT Endpoint
    );

NTSTATUS
SendNameClaim (
    IN PENDPOINT Endpoint,
    IN PVOID ServerNetbiosName,
    IN PVOID DestinationNetbiosName,
    IN PTA_IPX_ADDRESS DestinationAddress,
    IN UCHAR NameClaimPacketType,
    IN USHORT ClientMessageId,
    IN UCHAR IpxPacketType,
    IN PIPX_DATAGRAM_OPTIONS DatagramOptions
    );

VOID SRVFASTCALL
IpxRestartNegotiate(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
IpxRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvFreeIpxConnectionInIndication(
    IN PWORK_CONTEXT WorkContext
    );

VOID
StartSendNoConnection (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN UseNameSocket,
    IN BOOLEAN LocalTargetValid
    );

VOID SRVFASTCALL
SrvIpxFastRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
SetupIpxFastCoreRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvIpxClaimServerName )
#pragma alloc_text( PAGE, IpxRestartReceive )
#pragma alloc_text( PAGE, SrvIpxFastRestartRead )
#endif
#if 0
NOT PAGEABLE -- GetWorkItem
NOT PAGEABLE -- SendNameClaim
NOT PAGEABLE -- SrvIpxServerDatagramHandler
NOT PAGEABLE -- SrvIpxNameDatagramHandler
NOT PAGEABLE -- SrvIpxStartSend
NOT PAGEABLE -- StartSendNoConnection
NOT PAGEABLE -- RequeueIpxWorkItemAtSendCompletion
NOT PAGEABLE -- PurgeIpxConnections
NOT PAGEABLE -- IpxRestartNegotiate
NOT PAGEABLE -- SetupIpxFastCoreRead
NOT PAGEABLE -- SrvFreeIpxConnectionInIndication
#endif


NTSTATUS
SendNameClaim (
    IN PENDPOINT Endpoint,
    IN PVOID ServerNetbiosName,
    IN PVOID DestinationNetbiosName,
    IN PTA_IPX_ADDRESS DestinationAddress,
    IN UCHAR NameClaimPacketType,
    IN USHORT MessageId,
    IN UCHAR IpxPacketType,
    IN PIPX_DATAGRAM_OPTIONS DatagramOptions
    )
{
    PWORK_CONTEXT workContext;
    PSMB_IPX_NAME_PACKET buffer;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Get a work item to use for the send.
    //

    ALLOCATE_WORK_CONTEXT( queue, &workContext );

    if ( workContext == NULL ) {
        //
        // We're out of WorkContext structures, and we aren't able to allocate
        // any more just now.  Let's at least cause a worker thread to allocate some more
        // by incrementing the NeedWorkItem counter.  This will cause the next
        // freed WorkContext structure to get dispatched to SrvServiceWorkItemShortage.
        // While SrvServiceWorkItemShortage probably won't find any work to do, it will
        // allocate more WorkContext structures if it can.  Maybe this will help next time.
        //
        InterlockedIncrement( &queue->NeedWorkItem );

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Format the name claim packet.
    //

    buffer = (PSMB_IPX_NAME_PACKET)workContext->ResponseBuffer->Buffer;
    RtlZeroMemory( buffer->Route, sizeof(buffer->Route) );
    buffer->Operation = NameClaimPacketType;
    buffer->NameType = SMB_IPX_NAME_TYPE_MACHINE;
    buffer->MessageId = MessageId;
    RtlCopyMemory( buffer->Name, ServerNetbiosName, SMB_IPX_NAME_LENGTH );
    RtlCopyMemory( buffer->SourceName, DestinationNetbiosName, SMB_IPX_NAME_LENGTH );

    workContext->ResponseBuffer->DataLength = sizeof(SMB_IPX_NAME_PACKET);
    workContext->ResponseBuffer->Mdl->ByteCount = sizeof(SMB_IPX_NAME_PACKET);

    //
    // Format the destination address and send the packet.
    //

    workContext->Endpoint = Endpoint;
    DEBUG workContext->FsdRestartRoutine = NULL;

    workContext->ClientAddress->IpxAddress = *DestinationAddress;

    if ( ARGUMENT_PRESENT(DatagramOptions) ) {

        workContext->ClientAddress->DatagramOptions = *DatagramOptions;
        workContext->ClientAddress->DatagramOptions.PacketType = IpxPacketType;

        StartSendNoConnection( workContext, TRUE, TRUE );

    } else {
        workContext->ClientAddress->DatagramOptions.PacketType = IpxPacketType;
        StartSendNoConnection( workContext, TRUE, FALSE );
    }

    return STATUS_SUCCESS;

} // SendNameClaim


NTSTATUS
SrvIpxClaimServerName (
    IN PENDPOINT Endpoint,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;
    LARGE_INTEGER interval;
    TA_IPX_ADDRESS broadcastAddress;

    PAGED_CODE( );

    //
    // The destination of the name claim packet is the broadcast address.
    //

    broadcastAddress.TAAddressCount = 1;
    broadcastAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    broadcastAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    broadcastAddress.Address[0].Address[0].NetworkAddress = 0;
    broadcastAddress.Address[0].Address[0].NodeAddress[0] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[1] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[2] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[3] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[4] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[5] = 0xff;
    broadcastAddress.Address[0].Address[0].Socket = SMB_IPX_NAME_SOCKET;

    //
    // Send the name claim packet 5 times, waiting 1/2 second after
    // each send.  If anyone else claims the name, fail.
    //

    interval.QuadPart = Int32x32To64( NAME_CLAIM_INTERVAL, -1*10*1000 );

    for ( i = 0; i < NAME_CLAIM_ATTEMPTS; i++ ) {

        //
        // Send the name claim.
        //

        status = SendNameClaim(
                    Endpoint,
                    NetbiosName,
                    NetbiosName,
                    &broadcastAddress,
                    SMB_IPX_NAME_CLAIM,
                    0,
                    0x14,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }

        //
        // Wait 1/2 second.  If a response arrives, the datagram
        // handler marks the endpoint, and we quit.
        //

        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if ( Endpoint->NameInConflict ) {
            return STATUS_DUPLICATE_NAME;
        }

    }

    //
    // We now own the name.
    //

    return STATUS_SUCCESS;

} // SrvIpxClaimServerName


NTSTATUS
SrvIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX NetBIOS name
    socket.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost.

--*/

{
    PENDPOINT endpoint = (PENDPOINT)TdiEventContext;
    PSMB_IPX_NAME_PACKET packet;

    //
    // We have received a name query or claim request.  Is it for us?
    //

    if( BytesIndicated < sizeof( SMB_IPX_NAME_PACKET ) ) {
        IF_DEBUG( IPXNAMECLAIM ) {
            KdPrint(("NameDatagramHandler: Short packet %u bytes\n", BytesIndicated ));
        }
        return( STATUS_SUCCESS );
    }

    packet = (PSMB_IPX_NAME_PACKET)Tsdu;

    IF_DEBUG(IPXNAMECLAIM) {
        STRING string, srcString;
        string.Buffer = (PSZ)packet->Name;
        string.Length = SMB_IPX_NAME_LENGTH;
        srcString.Buffer = (PSZ)packet->SourceName;
        srcString.Length = SMB_IPX_NAME_LENGTH;
        KdPrint(( "NameDatagramHandler: type: %x, name %z, from %z\n",
                    packet->Operation, (PCSTRING)&string, (PCSTRING)&srcString ));
    }

    if ( SourceAddressLength < sizeof(IPX_ADDRESS_EXTENDED_FLAGS) ) {

        IF_DEBUG(IPXNAMECLAIM) {
            KdPrint(( "SourceAddress too short.  Expecting %d got %d\n",
                sizeof(IPX_ADDRESS_EXTENDED_FLAGS), SourceAddressLength ));
        }
        return(STATUS_SUCCESS);
    }

    if ( !RtlEqualMemory(
            packet->Name,
            endpoint->TransportAddress.Buffer,
            SMB_IPX_NAME_LENGTH) ) {
        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  not for us\n" ));
        return STATUS_SUCCESS;
    }

    //
    // The packet is for our name.  If we sent it, ignore it.
    //

    if ( RtlEqualMemory(
            &endpoint->LocalAddress,
            &((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address[0],
            sizeof(TDI_ADDRESS_IPX) ) ) {
        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  we sent it!\n" ));
        return STATUS_SUCCESS;
    }

    //
    // If it's a query or a claim, send a response.  If it's a 'name
    // recognized' packet, then another server owns our name.
    //

    if ( packet->Operation == SMB_IPX_NAME_FOUND ) {

        //
        // Did we send this ?
        //

        if ( (((PIPX_ADDRESS_EXTENDED_FLAGS)SourceAddress)->Flags &
              IPX_EXTENDED_FLAG_LOCAL) == 0 ) {

            //
            // This came from another station.
            //

            IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  name in conflict!\n" ));
            endpoint->NameInConflict = TRUE;
        }

    } else {

        //
        // This is a name query.  If bit 0x8000 is set, this is from a
        // redir that supports named pipes correctly.
        //

        if ( !SrvEnableWfW311DirectIpx &&
             ((packet->MessageId & 0x8000) == 0)) {

            IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  msg ID high bit not set.\n" ));
            return STATUS_SUCCESS;
        }

        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  sending name recognized response!\n" ));
        SendNameClaim(
            endpoint,
            endpoint->TransportAddress.Buffer,
            packet->SourceName,
            (PTA_IPX_ADDRESS)SourceAddress,
            SMB_IPX_NAME_FOUND,
            packet->MessageId,
            0x04,
            (PIPX_DATAGRAM_OPTIONS)Options
            );
    }

    return STATUS_SUCCESS;

} // SrvIpxNameDatagramHandler


NTSTATUS
SrvIpxServerDatagramHandlerCommon (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket,
    IN PVOID TransportContext
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to buffer describing the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

    TransportContext - NULL is this is not a chained receive, otherwise this
        is the pointer to the TransportContext when returning the NDIS buffer.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost. If STATUS_PENDING, then TransportContext
        was not NULL and we decided that we are going to keep the NDIS
        buffer and return it later.

--*/

{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PENDPOINT endpoint;
    USHORT sid;
    USHORT idIndex;
    USHORT sequenceNumber;
    USHORT nextSequenceNumber;
    USHORT mid;
    PCONNECTION connection;
    PNT_SMB_HEADER header;
    PSMB_PARAMS params;
    ULONG length;
    PTABLE_HEADER tableHeader;
    BOOLEAN resend;
    BOOLEAN firstPacketOfGlom = FALSE;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    USHORT error;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;
    PBUFFER requestBuffer;
    PWORK_QUEUE workQueue;

    PREQ_WRITE_MPX request;

    USHORT fid;
    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    USHORT index;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_SUCCESS;

#if DBG
    workQueue = NULL;
    workContext = NULL;
    connection = NULL;

    if ( TransportContext ) {
        ASSERT( BytesAvailable == BytesIndicated );
    }
#endif

    //
    // Make sure we've received a complete SMB
    //
    if( BytesIndicated < sizeof( SMB_HEADER ) + sizeof( USHORT ) ) {
        //
        // Short SMB.  Eat it.
        //
        return STATUS_SUCCESS;
    }

    //
    // Pull out stuff we'll need later..
    //
    endpoint = (PENDPOINT)TdiEventContext;
    header = (PNT_SMB_HEADER)Tsdu;
    sid = SmbGetUshort( &header->Sid );
    sequenceNumber = SmbGetUshort( &header->SequenceNumber );

    ASSERT( *(PUCHAR)header == 0xff );  // Must be 0xff'SMB'
    ASSERT( endpoint != NULL );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    if ( sid == 0 ) {

        //
        // Must be a negotiate
        //
        if( header->Command != SMB_COM_NEGOTIATE ||
            GET_BLOCK_STATE( endpoint ) != BlockStateActive ) {

            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        //
        // Do not accept new clients until the server has completed
        //  registering for PNP notifications
        //
        if( SrvCompletedPNPRegistration == FALSE ) {
            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        //
        // Queue this to the fsp.
        //
        //
        // Save the sender's IPX address.
        //

        workQueue = PROCESSOR_TO_QUEUE();

        ALLOCATE_WORK_CONTEXT( workQueue, &workContext );

        if( workContext != NULL ) {
            workContext->ClientAddress->IpxAddress =
                                *(PTA_IPX_ADDRESS)SourceAddress;
            workContext->ClientAddress->DatagramOptions =
                                *(PIPX_DATAGRAM_OPTIONS)Options;

            irp = workContext->Irp;
            workContext->Endpoint = endpoint;
            workContext->QueueToHead = TRUE;
            workContext->FspRestartRoutine = IpxRestartNegotiate;

            if ( BytesAvailable == BytesIndicated ) {

                TdiCopyLookaheadData(
                    workContext->RequestBuffer->Buffer,
                    Tsdu,
                    BytesIndicated,
                    ReceiveDatagramFlags
                    );

                workContext->RequestBuffer->DataLength = BytesIndicated;

                *BytesTaken = BytesAvailable;
                goto queue_to_fsp;

            } else {

                workContext->FsdRestartRoutine = SrvQueueWorkToFsp;
                goto build_irp;

            }
        }

        //
        // Could not allocate a work context!
        //
        KeLowerIrql( oldIrql );

        InterlockedIncrement( &workQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }

    //
    // Not a Negotiate, and non-zero SID.
    // Check if the connection is cached.
    //

    idIndex = IPXSID_INDEX( sid );

    ACQUIRE_DPC_SPIN_LOCK(
        &ENDPOINT_SPIN_LOCK(idIndex & ENDPOINT_LOCK_MASK) );

    tableHeader = &endpoint->ConnectionTable;

    if ( (idIndex >= (USHORT)tableHeader->TableSize) ||
         ((connection = tableHeader->Table[idIndex].Owner) == NULL) ||
         (connection->Sid != sid) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(IPX2) {
            KdPrint(( "Bad Sid: " ));
            if ( idIndex >= (USHORT)tableHeader->TableSize ) {
                KdPrint(( "Index >= tableSize (index %d, size %d)\n",
                          idIndex, (USHORT)tableHeader->TableSize ));
            } else if( tableHeader->Table[ idIndex ].Owner == NULL ) {
                KdPrint(( "Owner == NULL\n" ));
            } else if( connection->Sid != sid ) {
                KdPrint(( "connection->Sid = %X, sid = %X\n", connection->Sid, sid ));
            } else {
                KdPrint(( "Connection blk state %X\n", GET_BLOCK_STATE( connection ) ));
            }
        }

        workQueue = PROCESSOR_TO_QUEUE();

        //
        // We have an invalid SID.  It would be nice to silently fail it,
        //  but that causes auto-reconnect on clients take an unnecessarily
        //  long time.
        //
        RELEASE_DPC_SPIN_LOCK( &
            ENDPOINT_SPIN_LOCK(idIndex & ENDPOINT_LOCK_MASK) );

        ALLOCATE_WORK_CONTEXT( workQueue, &workContext );

        if( workContext != NULL ) {
            error = SMB_ERR_BAD_SID;
            resend = FALSE;
            goto respond;
        }

        //
        // Unable to allocate workitem, give up
        //
        KeLowerIrql( oldIrql );

        InterlockedIncrement( &workQueue->NeedWorkItem );

        return STATUS_SUCCESS;

    }

#if MULTIPROCESSOR
    //
    // See if it's time to home this connection to another processor
    //
    if( --(connection->BalanceCount) == 0 ) {
        SrvBalanceLoad( connection );
    }

    workQueue = connection->CurrentWorkQueue;

#else

    workQueue = &SrvWorkQueues[0];

#endif

    //
    // The connection is active.  Record the time that this request
    // arrived.  If the sequence numbers match, handle this as a lost
    // response.
    //

    nextSequenceNumber = connection->SequenceNumber;
    GET_SERVER_TIME( workQueue, &connection->LastRequestTime );

    //
    // If this is a sequenced SMB, it has to have the right sequence
    // number: one greater than the current sequence number (but not 0).
    //

    if ( sequenceNumber != 0 ) {

        if ( nextSequenceNumber != 0 ) {

            ULONG tmpNext = nextSequenceNumber;

            if ( ++nextSequenceNumber == 0 ) nextSequenceNumber++;

            if ( sequenceNumber != nextSequenceNumber ) {

                if ( sequenceNumber == tmpNext ) {
                    goto duplicate_request;
                }

                //
                // Bad sequence number.  Ignore this message.
                //

                IF_DEBUG(IPX) KdPrint(( "SRVIPX: Bad sequence number; ignoring\n" ));

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

                KeLowerIrql( oldIrql );
                return STATUS_SUCCESS;
            }
        }

        //
        // The sequence number is correct. Update the connection's sequence number and
        // indicate that we're processing this message.  (We need to
        // allocate the work item first because we're modifying
        // connection state.)  Then go receive the message.
        //

        ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
        if( workContext != NULL ) {

            IF_DEBUG(IPX) KdPrint(( "SRVIPX: Receiving sequenced request %x\n", sequenceNumber ));

            connection->SequenceNumber = sequenceNumber;
            connection->LastResponseLength = (USHORT)-1;
            connection->IpxDuplicateCount = 0;

            if ( header->Command == SMB_COM_WRITE_MPX ) {
                goto process_writempx;
            } else {
                goto process_not_writempx;
            }
        }

        //
        // Unable to allocate workitem, give up
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );

        return STATUS_SUCCESS;
    }

    //
    // Unsequenced SMB.  Check to see if it's being processed or is in
    // the queue to be processed.  If it's not, then we can process this
    // message.
    //
    // *** We don't do this check for write MPX because the multiple SMBs
    //     in a write MPX all have the same MID.
    //

    if ( header->Command != SMB_COM_WRITE_MPX ) {

        mid = SmbGetUshort( &header->Mid ); // NOT Aligned

        //
        // We need to receive this message.  Get a work item.
        //

        IF_DEBUG(IPX) {
            KdPrint(( "SRVIPX: Receiving unsequenced request mid=%x\n",
                        SmbGetUshort(&header->Mid) )); // NOT Aligned
        }

        for ( listEntry = connection->InProgressWorkItemList.Flink;
              listEntry != &connection->InProgressWorkItemList;
              listEntry = listEntry->Flink ) {

            PWORK_CONTEXT tmpWorkContext;

            tmpWorkContext = CONTAINING_RECORD(
                                        listEntry,
                                        WORK_CONTEXT,
                                        InProgressListEntry );

            if ( SmbGetAlignedUshort(&tmpWorkContext->RequestHeader->Mid) == mid ) {

                IF_DEBUG(IPX) KdPrint(( "SRVIPX: Duplicate (queued) unsequenced request mid=%x\n", mid ));
                if( connection->IpxDuplicateCount++ < connection->IpxDropDuplicateCount ) {
                    //
                    // We drop every few duplicate requests from the client
                    //
                    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                    KeLowerIrql( oldIrql );
                    return STATUS_SUCCESS;
                }

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                error = SMB_ERR_WORKING;
                resend = FALSE;
                ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
                if( workContext != NULL ) {

                    connection->IpxDuplicateCount = 0;
                    goto respond;
                }

                //
                // Unable to allocate workitem, give up
                //

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                KeLowerIrql( oldIrql );
                InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
                return STATUS_SUCCESS;
            }
        }

        ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
        if( workContext != NULL ) {
            goto process_not_writempx;
        }

        //
        // Unable to allocate workitem, give up
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;

    }

    ASSERT( workContext == NULL );

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
    if( workContext == NULL ) {
        //
        // Unable to allocate workitem, give up
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }

    connection->IpxDuplicateCount = 0;

process_writempx:

    //
    // Have we received enough of the message to interpret the request?
    //
    if( BytesIndicated < sizeof( SMB_HEADER ) + FIELD_OFFSET( REQ_WRITE_MPX, Buffer ) ) {
        //
        // Drop this fellow on the floor
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        return STATUS_SUCCESS;
    }

    //
    // Reference the connection so we can release the lock.
    //

    ASSERT( connection != NULL );
    ASSERT( workContext != NULL );
    SrvReferenceConnectionLocked( connection );
    workContext->Connection = connection;

    workContext->Parameters.WriteMpx.TransportContext = NULL;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    //
    // The sequence number is correct.  Ensure that a work item is
    // available, then update the connection's sequence number and
    // indicate that we're processing this message.  (We need to
    // allocate the work item first because we're modifying
    // connection state.)  Then go receive the message.
    //

    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // This is a Write Mpx request, we need to save some state, in
    // order to prevent unnecessary out-of-order completion of the
    // sequenced part of a Write Mpx, which would lead to unnecessary
    // retransmissions.
    //

    //
    // Find the RFCB associated with this request.
    //
    // *** The following is adapted from SrvVerifyFid2.
    //

    request = (PREQ_WRITE_MPX)(header + 1);
    fid = SmbGetUshort( &request->Fid );

    //
    // See if this is the cached rfcb.
    //

    if ( connection->CachedFid == fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the
        // correct sequence number.
        //

        index = FID_INDEX( fid );
        tableHeader = &connection->FileTable;

        if ( (index >= (USHORT)tableHeader->TableSize) ||
             ((rfcb = tableHeader->Table[index].Owner) == NULL) ||
             (rfcb->Fid != fid) ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }

        //
        // Cache the FID.
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)fid;

        //
        // If there is a write behind error, return the error to the
        // client.
        //
        // !!! For now, we ignore write behind errors.  Need to
        //     figure out how to translate the saved NT status to a
        //     DOS status...
        //

#if 0
        if ( !NT_SUCCESS(rfcb->SavedError) ) {
            status = rfcb->SavedError;
            rfcb->SavedError = STATUS_SUCCESS;
            goto bad_fid;
        }
#endif

        //
        // The FID is valid within the context of this connection.
        // Verify that the owning tree connect's TID is correct.
        //

        if ( (rfcb->Tid != SmbGetUshort(&header->Tid)) ||
             (rfcb->Uid != SmbGetUshort(&header->Uid)) ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }
    }


    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    //
    // Since we don't support raw writes on IPX, there had
    // better not be one active.
    //

    ASSERT( rfcb->RawWriteCount == 0 );

    //
    // If the MID in the this packet is the same as the MID we're
    // currently working on, we can accept it.
    //

    writeMpx = &rfcb->WriteMpx;

    mid = SmbGetUshort( &header->Mid ); // NOT Aligned

    if ( mid == writeMpx->Mid ) {
        goto mpx_mid_ok;
    }

    //
    // If this a stale packet, ignore it.  Stale here means that the
    // MID of the packet is equal to the MID of the previous write
    // mux.  Such a packet can be received if a duplicate packet
    // from a previous write mux is delivered after a new write mux
    // starts.
    //
    // If this packet is for a new MID, but we're in the middle of
    // processing the current MID, then something is wrong -- the redir
    // should not send a new MID until we've replied to the old MID.
    // Ignore this packet.
    //

    if ( (mid == writeMpx->PreviousMid) || writeMpx->ReferenceCount ) {
        goto stale_mid;
    }

    //
    // It's not the MID we're currently working on, and it's not the
    // previous MID, and we're not glomming the current MID.  So we
    // have to assume it's a new MID.  If it's the first packet of a
    // write, we can prepare to glom.
    //
    // !!! This is a problem if we receive a delayed packet that is
    //     the first packet of a MID older than the last MID.  We
    //     will then put the file into glom mode for that old MID,
    //     will never be able to make progress on that file.
    //
    // !!! The mask == 1 test is not perfect.  It depends on the
    //     client using 1 in the first packet, which is not
    //     guaranteed by the protocol.
    //

    writeMpx->PreviousMid = writeMpx->Mid;
    writeMpx->Mid = mid;

#if SRVDBG_PERF
    if( GlommingAllowed )
#endif
    if ( (SmbGetUlong( &request->Mask ) == 1) && writeMpx->MpxGlommingAllowed ) {
        writeMpx->GlomPending = TRUE;
        firstPacketOfGlom = TRUE;
    }

mpx_mid_ok:

    //
    // Save the sender's IPX address.
    //

    workContext->Endpoint = endpoint;

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    //
    // Bump the Write Mpx reference count in the RFCB.
    //

    writeMpx->ReferenceCount++;

    //
    // See if we can do indication time write glomming.
    // We will try this if:
    //  we are in the middle of write glomming and
    //  smb is valid    and
    //  we receive all the data
    //
    if ( writeMpx->Glomming             &&
        ( BytesIndicated == BytesAvailable ) ) {

        UCHAR wordCount;
        USHORT byteCount;
        PSMB_USHORT byteCountPtr;
        ULONG availableSpaceForSmb;

        header = (PNT_SMB_HEADER) Tsdu;
        params = (PVOID)(header + 1);

        wordCount = *((PUCHAR)params);
        byteCountPtr = (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (12 * sizeof(USHORT)) );
        byteCount =
            SmbGetUshort( (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (12 * sizeof(USHORT))) );

        availableSpaceForSmb = BytesIndicated - sizeof(SMB_HEADER);

        //
        // Validate the WriteMpx smb.
        //

        if ( (SmbGetUlong((PULONG)header->Protocol) == SMB_HEADER_PROTOCOL)
                &&
             ((CHAR)wordCount == 12)
                &&
             ((PCHAR)byteCountPtr <= (PCHAR)header + BytesIndicated -
                sizeof(USHORT))
                &&
             ((12*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                byteCount) <= availableSpaceForSmb) ) {

            //
            // The connection SpinLock is released in this routine.
            //

            if ( AddPacketToGlomInIndication(
                                    workContext,
                                    rfcb,
                                    Tsdu,
                                    BytesAvailable,
                                    ReceiveDatagramFlags,
                                    SourceAddress,
                                    Options
                                    ) ) {

                //
                // We need to clean up the connection.
                //

                goto return_connection;
            }

            KeLowerIrql( oldIrql );
            return(STATUS_SUCCESS);
        }
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB.
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

    workContext->Parameters.WriteMpx.FirstPacketOfGlom = firstPacketOfGlom;

    //
    // Save the RFCB address in the work context block.
    //

    ASSERT( workContext->Rfcb == NULL );
    workContext->Rfcb = rfcb;

    //
    // Change the FSP restart routine for the work item to one
    // that's specific to Write Mpx.  This is necessary in order
    // to do proper cleanup if a receive error occurs.
    //

    workContext->FspRestartRoutine = SrvRestartReceiveWriteMpx;
    goto start_receive;

process_not_writempx:

    //
    // Reference the connection and save a pointer to it in the work
    // item.
    //

    ASSERT( connection != NULL );
    ASSERT( workContext != NULL );
    ASSERT( workContext->FsdRestartRoutine == SrvQueueWorkToFspAtDpcLevel );
    SrvReferenceConnectionLocked( connection );

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // Save the sender's IPX address.
    //

    workContext->Connection = connection;
    workContext->Endpoint = endpoint;

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    if ( header->Command == SMB_COM_LOCKING_ANDX ) {

        //
        // If this is a Locking&X SMB that includes at least one unlock
        // request, we want to process the request quickly.  So we put
        // it at the head of the work queue.
        //

        PREQ_LOCKING_ANDX lockRequest = (PREQ_LOCKING_ANDX)(header + 1);

#if SRVDBG_PERF
        if( UnlocksGoFast )
#endif
        if( (PCHAR)header + BytesIndicated >= (PCHAR)(&lockRequest->ByteCount) &&
            SmbGetUshort(&lockRequest->NumberOfUnlocks) != 0 ) {
            workContext->QueueToHead = TRUE;
        }

    } else if ( (header->Command == SMB_COM_READ) &&
                (BytesIndicated == BytesAvailable) ) {

        //
        // Copy the indicated data.
        //

        TdiCopyLookaheadData(
            workContext->RequestBuffer->Buffer,
            Tsdu,
            BytesIndicated,
            ReceiveDatagramFlags
            );

        workContext->RequestBuffer->DataLength = BytesIndicated;

        //
        // See if we are all set to do the fast path.
        //

        if ( SetupIpxFastCoreRead( workContext ) ) {

            workContext->FspRestartRoutine = SrvIpxFastRestartRead;
            workContext->ProcessingCount++;
            workQueue->stats.BytesReceived += BytesIndicated;

            //
            // Insert the work item at the tail of the nonblocking
            // work queue.
            //

            SrvInsertWorkQueueTail(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        irp = workContext->Irp;
        goto queue_to_fsp;

    } else if ( (header->Command == SMB_COM_OPEN_ANDX) ||
                (header->Command == SMB_COM_NT_CREATE_ANDX) ) {

        //
        // If this is an attempt to open a file, route the
        // request to a blocking worker thread.  This keeps opens
        // out of the way of handle-based operations.
        //

#if SRVDBG_PERF
        if( OpensGoSlow )
#endif
        {
            workContext->FsdRestartRoutine = SrvQueueWorkToBlockingThread;
            workQueue = GET_BLOCKING_WORK_QUEUE();
        }

    } else if ( (header->Command == SMB_COM_CLOSE) ||
                (header->Command == SMB_COM_FIND_CLOSE) ||
                (header->Command == SMB_COM_FIND_CLOSE2) ) {
        //
        // Closing things is an operation that (1) releases resources, (2) is usually
        // fast, and (3) can't be repeated indefinately by the client.  Give the client
        // a reward by putting it at the head of the queue.
        //
        workContext->QueueToHead = TRUE;
    }

start_receive:

    //
    // If the SMB is completely within the indicated data, copy it
    // directly into the buffer, avoiding the overhead of passing an IRP
    // down to the transport.
    //

    irp = workContext->Irp;

    if ( BytesIndicated == BytesAvailable ) {

        //
        // If this is a WRITE_MPX, and the buffer is big (how big is BIG?)
        // and there is a TransportContext (indicating that we can take the
        // NDIS buffer, then don't copy the data - just save the buffer
        // address, length and transport context.
        //

        if ( BytesIndicated > SrvMaxCopyLength &&
             header->Command == SMB_COM_WRITE_MPX &&
             TransportContext ) {

            workContext->Parameters.WriteMpx.Buffer = Tsdu;
            workContext->Parameters.WriteMpx.ReceiveDatagramFlags =
                            ReceiveDatagramFlags;
            workContext->Parameters.WriteMpx.TransportContext = TransportContext;

            DEBUG *BytesTaken = BytesIndicated;

            ASSERT( BytesIndicated >= MPX_HEADER_SIZE );

            TdiCopyLookaheadData(
                workContext->RequestBuffer->Buffer,
                Tsdu,
                MPX_HEADER_SIZE,
                ReceiveDatagramFlags
                );

            status = STATUS_PENDING;

        } else {

            TdiCopyLookaheadData(
                workContext->RequestBuffer->Buffer,
                Tsdu,
                BytesIndicated,
                ReceiveDatagramFlags
                );

            // NB: status is set to STATUS_SUCCESS above!
        }

#if SRVDBG_PERF
        if ( Trap512s ) {
            if ( header->Command == SMB_COM_READ ) {
                PREQ_READ request = (PREQ_READ)(header + 1);
                if ( (SmbGetUshort(&request->Count) == 512) &&
                     ((SmbGetUlong(&request->Offset) & 511) == 0) ) {
                    PRESP_READ response;
                    if (Break512s) DbgBreakPoint();
                    Trapped512s++;
                    response = (PRESP_READ)workContext->ResponseParameters;
                    response->WordCount = 5;
                    SmbPutUshort( &response->Count, 512 );
                    RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
                    SmbPutUshort(
                        &response->ByteCount,
                        (USHORT)(512 + FIELD_OFFSET(RESP_READ,Buffer[0]) -
                                                FIELD_OFFSET(RESP_READ,BufferFormat))
                        );
                    response->BufferFormat = SMB_FORMAT_DATA;
                    SmbPutUshort( &response->DataLength, 512 );
                    workContext->ResponseParameters = NEXT_LOCATION(
                                                        response,
                                                        RESP_READ,
                                                        512
                                                        );
                    SrvFsdSendResponse( workContext );
                    return STATUS_SUCCESS;
                }
            }
        }
#endif // SRVDBG_PERF

queue_to_fsp:

        //
        // Pretend the transport completed an IRP by doing what the
        // restart routine, which is known to be
        // SrvQueueWorkToFspAtDpcLevel, would do.
        //

        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = BytesIndicated;

        irp->Cancel = FALSE;

        //
        // *** THE FOLLOWING IS COPIED FROM SrvQueueWorkToFspAtDpcLevel.
        //
        // Increment the processing count.
        //

        workContext->ProcessingCount++;

        //
        // Insert the work item into the work queue
        //

        if( workContext->QueueToHead ) {

            SrvInsertWorkQueueHead(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

        } else {

            SrvInsertWorkQueueTail(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

        }

        KeLowerIrql( oldIrql );
        return status;

    }

build_irp:

    //
    // We can't copy the indicated data.  Set up the receive IRP.
    //

    ASSERT( workQueue != NULL );

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = workQueue->IrpThread;

    DEBUG irp->RequestorMode = KernelMode;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        workContext,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Make the next stack location current.  Normally IoCallDriver
    // would do this, but since we're bypassing that, we do it directly.
    // Load the target device object address into the stack location.
    // This especially important because the server likes to reuse IRPs.
    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    IoSetNextIrpStackLocation( irp );
    irpSp = IoGetCurrentIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE_DATAGRAM;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    requestBuffer = workContext->RequestBuffer;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = requestBuffer->BufferLength;
    parameters->ReceiveFlags = 0;

    irp->MdlAddress = requestBuffer->Mdl;
    irp->AssociatedIrp.SystemBuffer = NULL;

    irpSp->Flags = 0;
    irpSp->DeviceObject = endpoint->DeviceObject;
    irpSp->FileObject = endpoint->FileObject;

    ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that the transport
    // provider will use our IRP to service the receive.
    //

    *IoRequestPacket = irp;
    *BytesTaken = 0;

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

bad_fid:

    //
    // An invalid FID was specified on a Write Mpx request, or there was
    // a saved write behind error in the RFCB.  If this is an
    // unsequenced request, we drop it on the floor.  If it's a
    // sequenced request, we send an error response.
    //

    if ( sequenceNumber == 0 ) {

stale_mid:
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto return_connection;
    }

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

    ASSERT( workContext->Connection != NULL );
    SrvFreeIpxConnectionInIndication( workContext );

    resend = FALSE;
    goto respond;

duplicate_request:

    //
    // This is a duplicate request.  If it's still being processed,
    // indicate that to the client.
    //

    if ( connection->LastResponseLength == (USHORT)-1 ) {

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: request in progress\n" ));

        if( connection->IpxDuplicateCount++ < connection->IpxDropDuplicateCount ) {
            //
            // We drop every few duplicate request from the client
            //
            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        connection->IpxDuplicateCount = 0;
        error = SMB_ERR_WORKING;
        resend = FALSE;

    } else {

        //
        // The request has already been completed.  Resend the response.
        //

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: resending response\n" ));
        resend = TRUE;
    }

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
    if( workContext == NULL ) {

        if( resend == TRUE ) {
            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        }

        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }


respond:

    ASSERT( workContext != NULL );

    //
    // Copy the received SMB header into the response buffer.
    //

    RtlCopyMemory(
        workContext->ResponseBuffer->Buffer,
        header,
        sizeof(NT_SMB_HEADER)
        );

    header = (PNT_SMB_HEADER)workContext->ResponseBuffer->Buffer;
    params = (PSMB_PARAMS)(header + 1);

    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Format the parameters portion of the SMB, and set the status.
    //

    if ( !resend ) {

        SmbPutUshort( &header->Status.DosError.Error, error );
        header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
        header->Status.DosError.Reserved = 0;
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        length = sizeof(NT_SMB_HEADER) + sizeof(SMB_PARAMS);

    } else {

        //
        // Copy the saved response data into the response.
        //

        SmbPutUlong( &header->Status.NtStatus, connection->LastResponseStatus );

        SmbPutUshort( &header->Tid, connection->LastTid);
        SmbPutUshort( &header->Uid, connection->LastUid);

        RtlCopyMemory(
            (PVOID)params,
            connection->LastResponse,
            connection->LastResponseLength
            );
        length = sizeof(NT_SMB_HEADER) + connection->LastResponseLength;
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    workContext->ResponseBuffer->DataLength = length;
    workContext->ResponseBuffer->Mdl->ByteCount = length;

    //
    // Format the destination address.
    //

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    //
    // Send the packet.
    //

    workContext->Endpoint = endpoint;
    DEBUG workContext->FsdRestartRoutine = NULL;

    StartSendNoConnection( workContext, FALSE, TRUE );

    KeLowerIrql( oldIrql );
    return STATUS_SUCCESS;

return_connection:

    SrvFreeIpxConnectionInIndication( workContext );
    KeLowerIrql( oldIrql );

    workContext->BlockHeader.ReferenceCount = 0;
    RETURN_FREE_WORKITEM( workContext );

    return STATUS_SUCCESS;

} // SrvIpxServerDatagramHandlerCommon


NTSTATUS
SrvIpxServerDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to buffer describing the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost.

--*/

{
    NTSTATUS status;

    status = SrvIpxServerDatagramHandlerCommon(
                    TdiEventContext,
                    SourceAddressLength,
                    SourceAddress,
                    OptionsLength,
                    Options,
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket,
                    NULL
                    );

    ASSERT( status != STATUS_PENDING );
    return status;

} // SrvIpxServerDatagramHandler


NTSTATUS
SrvIpxServerChainedDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG ReceiveDatagramLength,
    IN ULONG StartingOffset,
    IN PMDL Tsdu,
    IN PVOID TransportContext
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    ReceiveDatagramLength - The length in byutes of the client data in the Tsdu

    StartingOffset - Offset, in bytes, from beginning of Tsdu to client's data

    Tsdu - Pointer to an MDL chain describing the received data

    TranportContext - Context to be passed to TdiReturnChainedReceives if
        buffer is taken


Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_PENDING, the receive buffer was
        taken and it will be returned via TdiReturnChainedReceives. If
        If STATUS_DATA_NOT_ACCEPTED, the message is lost.

--*/

{
    PVOID receiveBuffer;
    ULONG bytesTaken;
    NTSTATUS status;
    PIRP ioRequestPacket = NULL;

    ASSERT( StartingOffset < 512 );
    receiveBuffer = (PCHAR)MmGetSystemAddressForMdl( Tsdu ) + StartingOffset;

    status = SrvIpxServerDatagramHandlerCommon(
                    TdiEventContext,
                    SourceAddressLength,
                    SourceAddress,
                    OptionsLength,
                    Options,
                    ReceiveDatagramFlags,
                    ReceiveDatagramLength,
                    ReceiveDatagramLength,
                    &bytesTaken,
                    receiveBuffer,
                    &ioRequestPacket,
                    TransportContext
                    );

    ASSERT( ioRequestPacket == NULL );

    DEBUG if ( status == STATUS_PENDING ) {
        ASSERT( bytesTaken == ReceiveDatagramLength );
    }

    return status;

} // SrvIpxServerChainedDatagramHandler


VOID
SrvIpxStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    )

/*++

Routine Description:

    This function sends an SMB/IPX name claim request or response.  It
    is started as an asynchronous I/O request.  When the Send completes,
    the restart routine preloaded into the work context is called.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PCONNECTION connection;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PMDL mdl;
    ULONG sendLength;
    USHORT responseLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PTDI_CONNECTION_INFORMATION destination;
    PNT_SMB_HEADER header;

//    IF_DEBUG(IPX2) SrvPrint0( "SrvIpxStartSend entered\n" );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Count up the length of the data described by chained MDLs.
    //

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Get the MDL pointer.
    //

    mdl = WorkContext->ResponseBuffer->Mdl;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    irp = WorkContext->Irp;

    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    destination = &WorkContext->ClientAddress->Descriptor;

    destination->UserDataLength = 0;
    destination->OptionsLength = sizeof(IPX_DATAGRAM_OPTIONS);
    destination->Options = &WorkContext->ClientAddress->DatagramOptions;
    destination->RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
    destination->RemoteAddress = &WorkContext->ClientAddress->IpxAddress;

    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;
    parameters->SendLength = sendLength;
    parameters->SendDatagramInformation = destination;

    endpoint = WorkContext->Endpoint;

    ASSERT( endpoint->IsConnectionless );

    deviceObject = endpoint->DeviceObject;
    fileObject = endpoint->FileObject;

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->MdlAddress = mdl;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // If this is a sequenced message, save the response data.
    //

    header = (PNT_SMB_HEADER)WorkContext->ResponseHeader;
    ASSERT( header != NULL );
    connection = WorkContext->Connection;
    ASSERT( connection != NULL );

    if ( SmbGetAlignedUshort(&header->SequenceNumber) != 0 ) {

        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: Responding to sequenced request %x mid=%x, connection %p\n",
                        SmbGetAlignedUshort(&header->SequenceNumber),
                        SmbGetAlignedUshort(&header->Mid), connection ));
        }
        ASSERT( sendLength - sizeof(SMB_HEADER) < 0x10000 );
        responseLength = (USHORT)(sendLength - sizeof(SMB_HEADER));
        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: parameters length %x, max=%x\n",
                        responseLength, MAX_SAVED_RESPONSE_LENGTH ));
        }

        if ( responseLength > MAX_SAVED_RESPONSE_LENGTH ) {

            //
            // The response is too large to save.  The client shouldn't
            // be doing this, except on transactions, for which we save
            // a copy of the full response.
            //

            if ( (header->Command == SMB_COM_TRANSACTION) ||
                 (header->Command == SMB_COM_TRANSACTION_SECONDARY) ||
                 (header->Command == SMB_COM_TRANSACTION2) ||
                 (header->Command == SMB_COM_TRANSACTION2_SECONDARY) ) {

                //
                // We need a buffer to hold the response.  If a buffer
                // has already been allocated, and is large enough, use
                // it.  Otherwise, allocate one.
                //

                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: transaction; saving long response\n" ));
                }
                if ( (connection->LastResponse == connection->BuiltinSavedResponse) ||
                     (connection->LastResponseBufferLength < responseLength) ) {

                    PVOID resp = ALLOCATE_NONPAGED_POOL( responseLength, BlockTypeDataBuffer );

                    if( resp != NULL ) {
                        if ( connection->LastResponse != connection->BuiltinSavedResponse ) {
                            IF_DEBUG(IPX) {
                                KdPrint(("SRVIPX: deallocating old response buffer %p\n",
                                            connection->LastResponse ));
                            }
                            DEALLOCATE_NONPAGED_POOL( connection->LastResponse );
                        }

                        connection->LastResponse = resp;

                        IF_DEBUG(IPX) {
                            KdPrint(("SRVIPX: new response buffer %p\n",
                                        connection->LastResponse ));
                        }
                        connection->LastResponseBufferLength = responseLength;
                    }
                }

            } else {

                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: not a transaction; illegal long response\n" ));
                }
                SmbPutUshort( &header->Status.DosError.Error, SMB_ERR_ERROR );
                header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
                header->Status.DosError.Reserved = 0;
                *(PLONG)(header + 1) = 0; // set WCT and BCC to 0

                sendLength = sizeof(SMB_HEADER) + sizeof(SMB_PARAMS);
                responseLength = 3;

                mdl->ByteCount = sendLength;
                parameters->SendLength = sendLength;

                goto small_response;
            }

        } else {

small_response:
            //
            // The response fits in the built-in buffer.
            //

            IF_DEBUG(IPX) {
                KdPrint(("SRVIPX: response fits in builtin response buffer\n" ));
            }
            if ( connection->LastResponse != connection->BuiltinSavedResponse ) {
                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: deallocating old response buffer %p\n",
                                connection->LastResponse ));
                }
                DEALLOCATE_NONPAGED_POOL( connection->LastResponse );
                connection->LastResponse = connection->BuiltinSavedResponse;
                connection->LastResponseBufferLength = sizeof( connection->BuiltinSavedResponse );
            }

        }

        //
        // Save the response data in the connection.
        //

        connection->LastResponseStatus = SmbGetUlong( &header->Status.NtStatus );
        connection->LastUid = SmbGetUshort( &header->Uid );
        connection->LastTid = SmbGetUshort( &header->Tid );

        connection->LastResponseLength = MIN( responseLength, connection->LastResponseBufferLength );
        RtlCopyMemory( connection->LastResponse, (header + 1), connection->LastResponseLength );


    } else {

        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: Responding to unsequenced request mid=%x\n",
                        SmbGetAlignedUshort(&header->Mid) ));
        }
    }

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

    //
    // Pass the request to the transport provider.
    //

    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( endpoint->FastTdiSendDatagram ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        DEBUG irpSp->DeviceObject = deviceObject;
        irpSp->MinorFunction = TDI_DIRECT_SEND_DATAGRAM;
        IoSetNextIrpStackLocation( irp );
        irp->Cancel = FALSE;

        endpoint->FastTdiSendDatagram( deviceObject, irp );

    } else {

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;
        irp->Cancel = FALSE;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND_DATAGRAM;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    return;

} // SrvIpxStartSend


VOID
StartSendNoConnection (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN UseNameSocket,
    IN BOOLEAN LocalTargetValid
    )

/*++

Routine Description:

    This function sends an SMB/IPX name claim request or response.  It
    is started as an asynchronous I/O request.  When the Send completes,
    the restart routine preloaded into the work context is called.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block

    UseNameSocket - Indicates whether the name socket or the server
        socket is to be used.

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    ULONG sendLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PTDI_CONNECTION_INFORMATION destination;

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Count up the length of the data described by chained MDLs.
    //

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    irp = WorkContext->Irp;

    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        RequeueIpxWorkItemAtSendCompletion,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    destination = &WorkContext->ClientAddress->Descriptor;

    destination->UserDataLength = 0;
    destination->OptionsLength =
            LocalTargetValid ? sizeof(IPX_DATAGRAM_OPTIONS) : sizeof(UCHAR);
    ASSERT( FIELD_OFFSET( IPX_DATAGRAM_OPTIONS, PacketType ) == 0 );
    destination->Options = &WorkContext->ClientAddress->DatagramOptions;
    destination->RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
    destination->RemoteAddress = &WorkContext->ClientAddress->IpxAddress;

    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;
    parameters->SendLength = sendLength;
    parameters->SendDatagramInformation = destination;

    irp->MdlAddress = WorkContext->ResponseBuffer->Mdl;

    endpoint = WorkContext->Endpoint;

    ASSERT( endpoint->IsConnectionless );

    if ( !UseNameSocket ) {

        deviceObject = endpoint->DeviceObject;
        fileObject = endpoint->FileObject;

    } else {

        deviceObject = endpoint->NameSocketDeviceObject;
        fileObject = endpoint->NameSocketFileObject;

    }

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Pass the request to the transport provider.
    //

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    irp->Cancel = FALSE;

    if ( endpoint->FastTdiSendDatagram ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        DEBUG irpSp->DeviceObject = deviceObject;
        irpSp->MinorFunction = TDI_DIRECT_SEND_DATAGRAM;
        IoSetNextIrpStackLocation( irp );

        endpoint->FastTdiSendDatagram( deviceObject, irp );

    } else {

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND_DATAGRAM;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    return;

} // StartSendNoConnection


VOID SRVFASTCALL
IpxRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for IPX Receive completion.  It does
    some IPX-specific setup work, then calls SrvRestartReceive.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = (PSMB_HEADER)WorkContext->RequestBuffer->Buffer;

    PAGED_CODE( );

    ASSERT( header->Command == SMB_COM_NEGOTIATE );

    //
    // Get rid of stale connections.
    //

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: processing Negotiate\n" ));
    PurgeIpxConnections( WorkContext->Endpoint );

    //
    // Load the SID from the connection into the request.  Since this
    // is a Negotiate request, we need to return a SID to the client.
    // The easiest way to ensure that happens is to save the SID here.
    //

    SmbPutAlignedUshort( &header->Sid, WorkContext->Connection->Sid );

    //
    // Call the normal SMB processing routine.
    //

    SrvRestartReceive( WorkContext );

    return;

} // IpxRestartReceive


NTSTATUS
RequeueIpxWorkItemAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine requeues an IPX work item to the free queue.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS_CONNECTIONLESS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
    WorkContext->BlockHeader.ReferenceCount = 0;

    ASSERT( WorkContext->Share == NULL );
    ASSERT( WorkContext->Session == NULL );
    ASSERT( WorkContext->TreeConnect == NULL );
    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    //
    // Make sure the length specified in the MDL is correct -- it may
    // have changed while sending a response to the previous request.
    // Call an I/O subsystem routine to build the I/O request packet.
    //

    WorkContext->RequestBuffer->Mdl->ByteCount =
                            WorkContext->RequestBuffer->BufferLength;

    //
    // Requeue the work item.
    //

    RETURN_FREE_WORKITEM( WorkContext );

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RequeueIpxWorkItemAtSendCompletion


PCONNECTION
GetIpxConnection (
    IN PWORK_CONTEXT WorkContext,
    IN PENDPOINT Endpoint,
    IN PTDI_ADDRESS_IPX ClientAddress,
    IN PUCHAR ClientName
    )
{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    PCHAR clientMachineName;
    ULONG length;
    KIRQL oldIrql;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Take a connection off the endpoint's free connection list.
    //
    // *** Note that all of the modifications done to the connection
    //     block are done with the spin lock held.  This ensures that
    //     closing of the endpoint's connections will work properly if
    //     it happens simultaneously.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    listEntry = RemoveHeadList( &Endpoint->FreeConnectionList );

    if ( listEntry == &Endpoint->FreeConnectionList ) {

        //
        // Unable to get a free connection.
        //

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        IF_DEBUG(IPX) KdPrint(( "SRVIPX: no free connections\n" ));
        SrvOutOfFreeConnectionCount++;
        return NULL;
    }

    //
    // We have a connection and a table entry.
    //

    Endpoint->FreeConnectionCount--;

    //
    // Wake up the resource thread to create a new free connection
    // for the endpoint.
    //

    if ( (Endpoint->FreeConnectionCount < SrvFreeConnectionMinimum) &&
         (GET_BLOCK_STATE(Endpoint) == BlockStateActive) ) {
        SrvResourceAllocConnection = TRUE;
        SrvFsdQueueExWorkItem(
            &SrvResourceAllocThreadWorkItem,
            &SrvResourceAllocThreadRunning,
            CriticalWorkQueue
            );
    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // Reference the connection to account for its being "open" and
    // for the work item's pointer.
    //

    connection = CONTAINING_RECORD(
                    listEntry,
                    CONNECTION,
                    EndpointFreeListEntry
                    );


    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    SrvReferenceConnectionLocked( connection );
    SrvReferenceConnectionLocked( connection );

    //
    // Mark the connection active.
    //

    SET_BLOCK_STATE( connection, BlockStateActive );

    //
    // Initialize IPX protocol fields.
    //

    connection->DirectHostIpx = TRUE;
    connection->IpxAddress = *ClientAddress;
    connection->SequenceNumber = 0;
    connection->LastResponseLength = (USHORT)-1;

    //
    // Set the processor affinity
    //
    connection->PreferredWorkQueue = queue;
    connection->CurrentWorkQueue = queue;

    InterlockedIncrement( &queue->CurrentClients );

    //
    // Set the duplicate drop count.  Start off conservative until
    // we learn what kind of client we're dealing with
    //
    connection->IpxDropDuplicateCount = MIN_IPXDROPDUP;
    connection->IpxDuplicateCount = 0;

#if MULTIPROCESSOR
    //
    // Get this client onto the best possible processor
    //
    SrvBalanceLoad( connection );
#endif

    //
    // Set time stamps.  StartupTime is used by the server to determine
    // whether the connection is old enough to be considered stale and
    // should be closed when another negotiate comes in.  This is used
    // to fix a timing problem where identical negotiates may be
    // queued up the the worker thread and a session setup comes in which
    // gets partially processed in the indication routine.
    //

    SET_SERVER_TIME( connection->CurrentWorkQueue );

    GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->StartupTime );
    connection->LastRequestTime = connection->StartupTime;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    WorkContext->Connection = connection;

    //
    // Copy the oem name at this time.  We convert it to Unicode
    // when we get the Session Setup SMB.
    //

    clientMachineName = connection->OemClientMachineName;

    RtlCopyMemory( clientMachineName, ClientName,  SMB_IPX_NAME_LENGTH );

    clientMachineName[SMB_IPX_NAME_LENGTH] = '\0';

    //
    // Determine the number of characters that aren't blanks.  This
    // is used by the session APIs to simplify their processing.
    //

    for ( length = SMB_IPX_NAME_LENGTH;
          length > 0 &&
             (clientMachineName[length-1] == ' ' ||
              clientMachineName[length-1] == '\0');
          length-- ) ;

    connection->OemClientMachineNameString.Length = (USHORT)length;

    IF_DEBUG(IPX) {
        SrvPrint2( "IpxRestartReceive accepting connection from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection );
    }

    return connection;

} // GetIpxConnection


VOID
PurgeIpxConnections (
    IN PENDPOINT Endpoint
    )
{
    USHORT i,j;
    KIRQL oldIrql;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;

    IF_DEBUG(IPX2) KdPrint(( "SRVIPX: PurgeIpxConnections entered\n" ));

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( j = 1; j < ENDPOINT_LOCK_COUNT; j++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
    }

    tableHeader = &Endpoint->ConnectionTable;
    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( (connection == NULL) ||
             (connection->IpxAddress.Socket != 0) ||
             (GET_BLOCK_STATE(connection) != BlockStateActive) ) {
            IF_DEBUG(IPX2) {
                if ( connection == NULL ) {
                    KdPrint(( "        no connection at table index %x\n", i ));
                } else if ( connection->IpxAddress.Socket != 0 ) {
                    KdPrint(( "        connection %p has socket %x\n", connection, connection->IpxAddress.Socket ));
                } else {
                    KdPrint(( "        connection %p has state %x\n", connection, GET_BLOCK_STATE(connection) ));
                }
            }

            continue;
        }

        SrvReferenceConnectionLocked(connection);
        for ( j = ENDPOINT_LOCK_COUNT-1; j > 0; j-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: purging connection %p\n", connection ));
        connection->DisconnectReason = DisconnectStaleIPXConnection;
        SrvCloseConnection( connection, FALSE );
        SrvDereferenceConnection( connection );

        ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
        for ( j = 1; j < ENDPOINT_LOCK_COUNT; j++ ) {
            ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
        }
        tableHeader = &Endpoint->ConnectionTable;
    }

    for ( j = ENDPOINT_LOCK_COUNT-1; j > 0; j-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    IF_DEBUG(IPX2) KdPrint(( "SRVIPX: PurgeIpxConnections done\n" ));

    return;

} // PurgeIpxConnections

VOID SRVFASTCALL
IpxRestartNegotiate(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine handles the case where the transport did not
    indicate us all of the data in the negotiate smb.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

        The workcontext block:
        -   has a pointer to the endpoint
        -   has a ref count of 1


Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    USHORT sid;
    PCONNECTION connection;
    ULONG length;
    PUCHAR clientName;
    PTABLE_HEADER tableHeader;
    USHORT i;
    KIRQL oldIrql;
    BOOLEAN resend;
    USHORT error;
    PLIST_ENTRY listEntry;

    PTA_IPX_ADDRESS sourceAddress;
    PNT_SMB_HEADER header;
    PSMB_PARAMS params;

    ASSERT( WorkContext->Endpoint != NULL );

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: Negotiate received\n" ));

    //
    // If this endpoint is no longer around, ignore this request.
    //  This check covers the possibility that the endpoint has been
    //  removed between the time this request was queued to a worker
    //  thread and a worker thread actually picked up the request.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        if( endpoint == WorkContext->Endpoint &&
            GET_BLOCK_STATE( endpoint ) == BlockStateActive ) {

            //
            // We found the endpoint, and it's still active!  Reference
            //  it so the endpoint will not disappear out from under us.
            //
            endpoint->BlockHeader.ReferenceCount++;

            break;
        }

        listEntry = listEntry->Flink;
    }

    if( listEntry == &SrvEndpointList.ListHead ) {
        //
        // We ran the whole list and did not find the endpoint.  It
        //  must have gone away.  Ignore this WorkItem.
        //
        RELEASE_LOCK( &SrvEndpointLock );
        IF_DEBUG( IPX ) KdPrint(( "SRVIPX: Endpoint gone.  ignoring\n" ));
        goto return_workitem;
    }

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // The endpoint is still valid, and we have referenced it.  The local var
    //  'endpoint' points to it.
    //

    sourceAddress = &WorkContext->ClientAddress->IpxAddress;

    header = (PNT_SMB_HEADER) WorkContext->RequestHeader;
    sid = SmbGetUshort( &header->Sid ); // NOT Aligned
    ASSERT( sid == 0 );

    clientName = (PUCHAR)WorkContext->RequestParameters;
    clientName += 2 * (*clientName) + 1;
    clientName += (*clientName) + 2;

    //
    // Make sure he's really trying to connect to us, and the SMB is well formed
    //

    if ( clientName+16+SMB_IPX_NAME_LENGTH-1 > END_OF_REQUEST_SMB( WorkContext ) ||
         !RtlEqualMemory(
            endpoint->TransportAddress.Buffer,
            clientName + 16,
            SMB_IPX_NAME_LENGTH ) ) {

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: Negotiate sent to wrong name!\n" ));
        error = SMB_ERR_NOT_ME;
        resend = FALSE;
        goto respond;
    }

    //
    // Acquire the endpoint locks
    //

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &endpoint->ConnectionTable;
    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( connection == NULL ) {
            continue;
        }

        //
        // Make sure this connection references an endpoint having
        // the same netbios address that the new client is coming in on
        //
        // This is to allow a single server to be registered as more than
        //  one name on the network.
        //
        if( connection->Endpoint->TransportAddress.Length !=
            endpoint->TransportAddress.Length ||

            !RtlEqualMemory( connection->Endpoint->TransportAddress.Buffer,
                              endpoint->TransportAddress.Buffer,
                              endpoint->TransportAddress.Length ) ) {

            //
            // This connection is for an endpoint having a different network
            //  name than we have.  Ignore it.
            //
            continue;
        }

        //
        // Check the IPX address of the sender against this
        // connection.
        //

        if ( RtlEqualMemory(
                &connection->IpxAddress,
                &sourceAddress->Address[0].Address[0],
                sizeof(TDI_ADDRESS_IPX) ) ) {

            //
            // The IPX addresses match.  Check the machine name.
            //

            if ( !RtlEqualMemory(
                    connection->OemClientMachineName,
                    clientName,
                    SMB_IPX_NAME_LENGTH) ) {

                //
                // The connection is for a different machine name.
                // Mark it as no longer valid.  It will be killed
                // when the Negotiate SMB is processed.
                //
                IF_DEBUG(IPX)KdPrint(("SRVIPX: Found stale connection %p\n", connection ));
                connection->IpxAddress.Socket = 0;
                break;

            } else if ( connection->SequenceNumber != 0 ) {

                ULONG timeNow;

                SET_SERVER_TIME( connection->CurrentWorkQueue );
                GET_SERVER_TIME( connection->CurrentWorkQueue, &timeNow );

                //
                // If the connection was initialized less than 5 seconds ago,
                // then we must be processing a duplicate negotiate request.
                //

                timeNow -= connection->StartupTime;

                if ( timeNow > SrvFiveSecondTickCount ) {

                    //
                    // The connection has been active for more than 5 seconds.
                    // Mark it as no longer valid.  It will be killed when
                    // the Negotiate SMB is processed.
                    //
                    IF_DEBUG(IPX) KdPrint(( "SRVIPX: found stale connection %p\n", connection ));
                    connection->IpxAddress.Socket = 0;
                    break;

                } else {

                    //
                    // Don't bother replying to avoid confusing the client.
                    //

                    for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
                        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
                    }
                    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
                    SrvDereferenceEndpoint( endpoint );
                    goto return_workitem;
                }
            }

            //
            // The connection is still in the initializing state and
            // the names match, so handle this as a lost response.
            //

            IF_DEBUG(IPX) KdPrint(( "SRVIPX: Found initializing connection %p\n", connection ));
            SmbPutUshort( &header->Sid, connection->Sid ); // NOT Aligned
            goto duplicate_request;

        } else {
            IF_DEBUG(IPX) {
                KdPrint(( "        skipping index %x: different address\n", i ));
            }
        }
    }

    //
    // Release the endpoint locks
    //

    for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    //
    // Get a free connection.  If successful, the workcontext block will
    // reference the connection block.
    //

    connection = GetIpxConnection(
                    WorkContext,
                    endpoint,
                    &sourceAddress->Address[0].Address[0],
                    clientName
                    );

    //
    // Now that we've gotten a connection structure for this endpoint,
    //  we can drop the reference we obtained above.
    //
    SrvDereferenceEndpoint( endpoint );

    if ( connection == NULL ) {

        //
        // Unable to get a free connection.
        //
        goto return_workitem;
    }

    //
    // Modify the FSP restart routine so that we can clean up stale
    // connections.
    //

    IpxRestartReceive(WorkContext);
    return;

duplicate_request:

    //
    // This is a duplicate request.  If it's still being processed,
    // indicate that to the client.
    //

    if ( connection->LastResponseLength == (USHORT)-1 ) {
        IF_DEBUG(IPX) KdPrint(( "SRVIPX: request in progress\n" ));
        for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
        error = SMB_ERR_WORKING;
        resend = FALSE;
        goto respond;
    }

    //
    // The request has already been completed.  Resend the response.
    //

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: resending response\n" ));
    resend = TRUE;

respond:

    params = (PSMB_PARAMS)(header + 1);
    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Format the parameters portion of the SMB, and set the status.
    //

    if ( !resend ) {

        SmbPutUshort( &header->Status.DosError.Error, error );
        header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
        header->Status.DosError.Reserved = 0;
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        length = sizeof(NT_SMB_HEADER) + sizeof(SMB_PARAMS);

    } else {

        //
        // Copy the saved response data into the response.
        //

        SmbPutUlong( &header->Status.NtStatus, connection->LastResponseStatus );
        RtlCopyMemory(
            (PVOID)params,
            connection->LastResponse,
            connection->LastResponseLength
            );
        length = sizeof(NT_SMB_HEADER) + connection->LastResponseLength;
        for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
    }

    WorkContext->ResponseBuffer->DataLength = length;
    WorkContext->ResponseBuffer->Mdl->ByteCount = length;

    //
    // Give up the reference we earlier obtained
    //
    SrvDereferenceEndpoint( endpoint );

    //
    // Send the packet.
    //

    DEBUG WorkContext->FsdRestartRoutine = NULL;

    StartSendNoConnection( WorkContext, FALSE, TRUE );

    return;

return_workitem:

    //
    // Dereference the work item manually.
    //

    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
    WorkContext->BlockHeader.ReferenceCount = 0;

    WorkContext->Endpoint = NULL;
    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;
    WorkContext->Irp->Cancel = FALSE;
    WorkContext->ProcessingCount = 0;
    RETURN_FREE_WORKITEM( WorkContext );

    return;

} // IpxRestartNegotiate

VOID SRVFASTCALL
SrvIpxFastRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Implements core read over ipx.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    PSMB_HEADER header;

    PAGED_CODE( );

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;


    //
    // Update the server network error count.
    //

    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // We have received an SMB.
    //

    rfcb = WorkContext->Rfcb;

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    lfcb = rfcb->Lfcb;

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvIpxFastRestartRead: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvIpxFastRestartRead:  SmartCard Read returns TRUE\n" ));
            }

            return;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvIpxFastRestartRead:  SmartCard Read returns FALSE\n" ));
        }
    }

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            rfcb->Fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // Initialize the error class and code fields in the header to
    // indicate success.
    //

    header = WorkContext->ResponseHeader;

    SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

    //
    // Determine the maximum amount of data we can read.  This is the
    // minimum of the amount requested by the client and the amount of
    // room left in the response buffer.  (Note that even though we may
    // use an MDL read, the read length is still limited to the size of
    // an SMB buffer.)
    //

    readAddress = (PCHAR)response->Buffer;

    readLength = (ULONG)MIN(
                           (CLONG)SmbGetUshort( &request->Count ),
                           WorkContext->ResponseBuffer->BufferLength -
                           (readAddress - (PCHAR)header)
                           );

    //
    // Get the file offset.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //

                SrvFsdRestartRead( WorkContext );

                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvIpxFastRestartRead complete.\n" ));
                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }


        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the read request, reusing the
    // receive IRP.
    //

    //
    // Note that we never do MDL reads here.  The reasoning behind
    // this is that because the read is going into an SMB buffer, it
    // can't be all that large (by default, no more than 4K bytes),
    // so the difference in cost between copy and MDL is minimal; in
    // fact, copy read is probably faster than MDL read.
    //
    // Build an MDL describing the read buffer.  Note that if the
    // file system can complete the read immediately, the MDL isn't
    // really needed, but if the file system must send the request
    // to its FSP, the MDL _is_ needed.
    //
    // *** Note the assumption that the response buffer already has
    //     a valid full MDL from which a partial MDL can be built.
    //

    IoBuildPartialMdl(
        WorkContext->ResponseBuffer->Mdl,
        WorkContext->ResponseBuffer->PartialMdl,
        readAddress,
        readLength
        );

    //
    // Build the IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,           // input IRP address
            lfcb->FileObject,           // target file object address
            WorkContext,                // context
            IRP_MJ_READ,                // major function code
            0,                          // minor function code
            readAddress,                // buffer address
            readLength,                 // buffer length
            WorkContext->ResponseBuffer->PartialMdl, // MDL address
            offset,                     // byte offset
            key                         // lock key
            );

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvIpxFastRestartRead: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                    lfcb->FileObject, offset.LowPart, readLength,
                    readAddress ));
    }

    //
    // Load the restart routine address and pass the request to the file
    // system.
    //

    WorkContext->FsdRestartRoutine = SrvFsdRestartRead;
    DEBUG WorkContext->FspRestartRoutine = NULL;
    WorkContext->Irp->Cancel = FALSE;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //

    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvIpxFastRestartRead complete.\n" ));
    return;

} // SrvIpxFastRestartRead

BOOLEAN
SetupIpxFastCoreRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Prepares the workitem for the fast restart read by validating the
    smb and verifying the fid.

Arguments:

    WorkContext

Return Value:

    TRUE, if rfcb referenced.
    FALSE, otherwise.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS status;
    BOOLEAN validSmb;
    USHORT fid;
    PRFCB rfcb;

    UCHAR wordCount;
    USHORT byteCount;
    PSMB_USHORT byteCountPtr;
    ULONG availableSpaceForSmb;
    ULONG smbLength;
    PSMB_HEADER header;
    PSMB_PARAMS params;
    PCONNECTION connection;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            SmbGetUshort( &request->Fid ), SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // Validate this smb.
    //

    header = WorkContext->RequestHeader;
    params = (PVOID)(header + 1);
    smbLength = WorkContext->RequestBuffer->DataLength;

    wordCount = *((PUCHAR)params);
    byteCountPtr = (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (5 * sizeof(USHORT)) );
    byteCount = SmbGetUshort( (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (5 * sizeof(USHORT))) );

    availableSpaceForSmb = smbLength - sizeof(SMB_HEADER);

    //
    // Validate the Read smb.
    //

    validSmb = (SmbGetUlong((PULONG)header->Protocol) == SMB_HEADER_PROTOCOL)
                    &&
                ((CHAR)wordCount == 5)
                    &&
                ((PCHAR)byteCountPtr <= (PCHAR)header + smbLength -
                    sizeof(USHORT))
                    &&
                ((5*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                    byteCount) <= availableSpaceForSmb);

    if ( validSmb ) {

        PTABLE_HEADER tableHeader;
        USHORT index;
        USHORT sequence;

        //
        // Verify the FID.  If verified, the RFCB is referenced and
        // its address is stored in the WorkContext block, and the RFCB
        // address is returned.
        //

        fid = SmbGetUshort( &request->Fid );

        //
        // Initialize local variables:  obtain the connection block address
        // and crack the FID into its components.
        //

        connection = WorkContext->Connection;

        //
        // Acquire the spin lock that guards the connection's file table.
        //

        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

        //
        // See if this is the cached rfcb
        //

        if ( connection->CachedFid == (ULONG)fid ) {

            rfcb = connection->CachedRfcb;

        } else {

            //
            // Verify that the FID is in range, is in use, and has the correct
            // sequence number.

            index = FID_INDEX( fid );
            sequence = FID_SEQUENCE( fid );
            tableHeader = &connection->FileTable;

            if ( (index >= (USHORT)tableHeader->TableSize) ||
                 (tableHeader->Table[index].Owner == NULL) ||
                 (tableHeader->Table[index].SequenceNumber != sequence) ) {

                goto error_exit_locked;
            }

            rfcb = tableHeader->Table[index].Owner;

            if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

                goto error_exit_locked;
            }

            //
            // If the caller wants to fail when there is a write behind
            // error and the error exists, fill in NtStatus and do not
            // return the RFCB pointer.
            //
            //
            // !!! For now, we ignore write behind errors.  Need to
            //     figure out how to translate the saved NT status to a
            //     DOS status...
            //
#if 0
            if ( !NT_SUCCESS(rfcb->SavedError) ) {
                goto error_exit_locked;
            }
#endif
            //
            // Cache the fid.
            //

            connection->CachedRfcb = rfcb;
            connection->CachedFid = (ULONG)fid;

            //
            // The FID is valid within the context of this connection.  Verify
            // that the owning tree connect's TID is correct.
            //
            // Do not verify the UID for clients that do not understand it.
            //

            if ( (rfcb->Tid != SmbGetAlignedUshort(&header->Tid)) ||
                 (rfcb->Uid != SmbGetAlignedUshort(&header->Uid)) ) {

                goto error_exit_locked;
            }
        }

        //
        // The file is active and the TID is valid.  Reference the
        // RFCB.  Release the spin lock (we don't need it anymore).
        //

        rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

        //
        // Save the RFCB address in the work context block and
        // return the file address.
        //

        WorkContext->Rfcb = rfcb;

        ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

        //
        // Mark the rfcb as active
        //

        rfcb->IsActive = TRUE;

        //
        // Verify that the client has read access to the file via the
        // specified handle.
        //

        if ( rfcb->ReadAccessGranted ) {

            return(TRUE);

        } else {

            CHECK_PAGING_IO_ACCESS(
                            WorkContext,
                            rfcb->GrantedAccess,
                            &status );

            if ( NT_SUCCESS( status ) ) {
                return(TRUE);
            }
        }
    }

    return(FALSE);

error_exit_locked:

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    return(FALSE);

} // SetupIpxFastCoreRead

VOID
SrvFreeIpxConnectionInIndication(
    IN PWORK_CONTEXT WorkContext
    )
{
    PCONNECTION connection = WorkContext->Connection;

    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvRemoveEntryList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount--;


    if ( --connection->BlockHeader.ReferenceCount == 0 ) {

        connection->BlockHeader.ReferenceCount++;

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // Orphaned.  Send to Boys Town.
        //

        DispatchToOrphanage( (PVOID)connection );

    } else {

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    WorkContext->Connection = NULL;
    return;

} // SrvFreeIpxConnectionInIndication

VOID
SrvIpxSmartCardReadComplete(
    IN PVOID    Context,
    IN PFILE_OBJECT FileObject,
    IN PMDL Mdl OPTIONAL,
    IN ULONG Length
)
/*++

Routine Description:

    Completes the Read performed by an optional smart card that handles
    direct host IPX clients.

Arguments:

    Context - the WorkContext of the original request
    FileObject - the file being read from
    Mdl - the MDL chain obtained from the cache manager to satisfy the read
    Length - the length of the read

Return Value:

    None

--*/
{
    PWORK_CONTEXT workContext = Context;
    PRFCB rfcb = workContext->Rfcb;
    UCHAR command = workContext->NextCommand;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    NTSTATUS status;

    ASSERT( workContext != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( command == SMB_COM_READ || command == SMB_COM_READ_MPX );

    //
    // Figure out the file position
    //
    if( command == SMB_COM_READ ) {
        PREQ_READ readParms = (PREQ_READ)workContext->RequestParameters;
        position.QuadPart = SmbGetUlong( &readParms->Offset ) + Length;
    } else {
        PREQ_READ_MPX readMpxParms = (PREQ_READ_MPX)workContext->RequestParameters;
        position.QuadPart = SmbGetUlong( &readMpxParms->Offset ) + Length;
    }

    IF_DEBUG( SIPX ) {
        KdPrint(( "SrvIpxSmartCardReadComplete: %s %p Length %u, New Position %u\n",
                  command==SMB_COM_READ ? "SMB_COM_READ" : "SMB_COM_READ_MPX",
                  Context, Length, position.LowPart ));
    }

    //
    // Update the position info in the rfcb
    //
    rfcb->CurrentPosition = position.LowPart;

    UPDATE_READ_STATS( workContext, Length );
    UPDATE_STATISTICS( workContext, Length, command );

    if( ARGUMENT_PRESENT( Mdl ) ) {

        //
        // Give the MDL chain back to the cache manager
        //

        if( workContext->Parameters.SmartCardRead.MdlReadComplete == NULL ||
            workContext->Parameters.SmartCardRead.MdlReadComplete( FileObject,
                Mdl,
                workContext->Parameters.SmartCardRead.DeviceObject ) == FALSE ) {

            //
            // Fast path didn't work -- try the IRP way
            //
            position.QuadPart -= Length;

            status = SrvIssueMdlCompleteRequest( workContext, NULL,
                                                Mdl,
                                                IRP_MJ_READ,
                                                &position,
                                                Length
                                                );

            if( !NT_SUCCESS( status ) ) {
                //
                // This is very bad, what else can we do?
                //
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }
    }

    //
    // Finish the cleanup
    //
    if( command ==  SMB_COM_READ ) {
        workContext->Irp->IoStatus.Status = STATUS_SUCCESS;
        SrvFsdRestartSmbAtSendCompletion( NULL, workContext->Irp, workContext );

    } else {
        SrvFsdRestartSmbComplete( workContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\lock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module implements functions for the LAN Manager server FSP's
    lock package.  This package began as a modification and streamlining
    of the executive resource package -- it allowed recursive
    acquisition, but didn't provide shared locks.  Later, debugging
    support in the form of level checking was added.

    Coming full circle, the package now serves as a wrapper around the
    real resource package.  It simply provides debugging support.  The
    reasons for reverting to using resources include:

    1) The resource package now supports recursive acquisition.

    2) There are a couple of places in the server where shared access
       is desirable.

    3) The resource package has a "no-wait" option that disables waiting
       for a lock when someone else owns it.  This feature is useful to
       the server FSD.

Author:

    Chuck Lenzmeier (chuckl) 29-Nov-1989
        A modification of Gary Kimura's resource.c.  This version does
        not support shared ownership, only exclusive ownership.  Support
        for recursive ownership has been added.
    David Treadwell (davidtr)

    Chuck Lenzmeier (chuckl)  5-Apr-1991
        Revert to using resource package.

Environment:

    Kernel mode only, LAN Manager server FSP and FSD.

Revision History:

--*/

#include "precomp.h"
#include "lock.tmh"
#pragma hdrstop

#if SRVDBG_LOCK

#define BugCheckFileId SRV_FILE_LOCK

//
// *** This entire module is conditionalized away when SRVDBG_LOCK is off.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeLock )
#pragma alloc_text( PAGE, SrvDeleteLock )
#pragma alloc_text( PAGE, SrvReleaseLock )
#endif
#if 0
NOT PAGEABLE -- SrvAcquireLock
NOT PAGEABLE -- SrvCheckListIntegrity
NOT PAGEABLE -- SrvIsEntryInList
NOT PAGEABLE -- SrvIsEntryNotInList
#endif

//
// Lock Level Semantics:
//
// Lock levels are used for server lock debugging as an aid in
// preventing deadlocks.  A deadlock may occur if two (or more) threads
// attempt to acquire two (or more) locks in a different order.  For
// example, suppose that there are two threads, 0 and 1, and two locks,
// A and B.  Then suppose the following happens:
//
// - thread 0 acquires lock A
// - thread 1 acquires lock B
// - thread 0 attempts to acquire lock B, gets blocked
// - thread 1 attempts to acquire lock A, gets blocked.
//
// This results in deadlock, where all threads are blocked and cannot
// become unblocked.  To prevent it, all threads must acquire locks in
// the same order.  In the above example, if we had the rule that lock A
// must be acquired before lock B, then thread 1 would have blocked
// while attempting to acquire lock A, but thread 0 would have been able
// to acquire lock B and completed its work.
//
// This rule is implemented generally in the server by lock levels.  The
// lock levels are set up such that lower-level locks are acquired
// first, then higher level locks.  An attempt to acquire locks out of
// order will be caught during debugging.  The rules are as follows:
//
// - A lock's level is assigned during initialization.
//
// - A thread may acquire any lock with a level greater than the level
//   of the highest held exclusive lock, but an attempt to acquire a
//   lock with a level equal to less than the highest lock will fail.
//   Note that full level checking is _not_ done for shared locks,
//   because of the difficulty of trying to retain information about the
//   number of times multiple threads have obtained a given lock for
//   shared access.
//
// - Recursive acquisitions of locks are legal, even if there are
//   intervening lock acquisitions.  For example, this is legal:
//       thread acquires lock A
//       thread acquires lock B
//       thread recursively acquires lock A
//
// - Locks may be released in any order.
//
// Lock debugging is active only when debugging is turned on.
//

#define HAS_TEB(_teb) ((BOOLEAN)(((ULONG)(_teb) <= MM_HIGHEST_USER_ADDRESS) ? FALSE : MmIsNonPagedSystemAddressValid(_teb)))

#define SrvCurrentTeb( ) ((PTEB)(KeGetCurrentThread( )->Teb))

#define SrvTebLockList( ) \
    ((PLIST_ENTRY)&(SrvCurrentTeb( )->UserReserved[SRV_TEB_LOCK_LIST]))

#define SrvThreadLockAddress( )                                               \
    ( IsListEmpty( SrvTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 ) )

#define SrvThreadLockLevel( )                                                 \
    ( IsListEmpty( SrvTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockLevel )

#define SrvThreadLockName( )                                                  \
    ( IsListEmpty( SrvTebLockList( ) ) ? "none" : CONTAINING_RECORD(          \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockName )

KSPIN_LOCK LockSpinLock = {0};
BOOLEAN LockSpinLockInitialized = FALSE;

//
// Forward declarations.
//

#define MAX_LOCKS_HELD 15


VOID
SrvInitializeLock(
    IN PSRV_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    )

/*++

Routine Description:

    This routine initializes the input lock variable.

Arguments:

    Lock - Supplies the lock variable being initialized

    LockLevel - Supplies the level of the lock

    LockName - Supplies the name of the lock

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( !LockSpinLockInitialized ) {
        LockSpinLockInitialized = TRUE;
        INITIALIZE_SPIN_LOCK( LockSpinLock );
    }

    //
    // Initialize the executive resource.
    //

    ExInitializeResource( &Lock->Resource );

    //
    // Initialize the lock level.  This is used to determine whether a
    // thread may acquire the lock.  Save the lock name.
    //

    LOCK_LEVEL( Lock ) = LockLevel;

    LOCK_NAME( Lock ) = LockName;

    IF_DEBUG(LOCKS) {
        SrvPrint3( "Initialized %s(%lx, L%lx)\n",
                    LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ) );
    }

    return;

} // SrvInitializeLock


VOID
SrvDeleteLock (
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) a lock variable.

Arguments:

    Lock - Supplies the lock variable being deleted

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Make sure the lock is unowned.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) != 0 ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvDeleteLock: Thread %d\n", KeGetCurrentThread( ) );
        }

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvDeleteLock: Attempt to delete owned lock %s(%lx)",
            LOCK_NAME( Lock ),
            Lock
            );

    }

    //
    // Delete the resource.
    //

    ExDeleteResource( &Lock->Resource );

    return;

} // SrvDeleteLock


BOOLEAN
SrvAcquireLock(
    IN PSRV_LOCK Lock,
    IN BOOLEAN Wait,
    IN BOOLEAN Exclusive
    )

/*++

Routine Description:

    The routine acquires a lock.

Arguments:

    Lock - Supplies the lock to acquire

    Wait - Indicates whether the caller wants to wait for the resource
        if it is already owned

    Exclusive - Indicates whether exlusive or shared access is desired

Return Value:

    BOOLEAN - Indicates whether the lock was acquired.  This will always
        be TRUE if Wait is TRUE.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;
    ULONG threadLockLevel;
    BOOLEAN lockAcquired;
    KIRQL oldIrql;

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = SrvCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure that we are at an IRQL lower than DISPATCH_LEVEL, if
    // Wait is TRUE.  We cannot wait to acquire a lock at that IRQL or
    // above.
    //

    ASSERT( !Wait || (KeGetCurrentIrql( ) < DISPATCH_LEVEL) );

    //
    // If this thread does not have a nonpaged TEB, do not do lock-level
    // debugging.  (We might be at DPC level, so we can't take page
    // faults.)
    //

    if ( hasTeb ) {

        //
        // Make sure that this thread has been initialized for lock
        // debugging.  If not, initialize it.
        //

        ACQUIRE_SPIN_LOCK( LockSpinLock, &oldIrql );
        if ( (ULONG)currentTeb->UserReserved[SRV_TEB_LOCK_INIT] !=
                                                        0xbabababa ) {
            PLIST_ENTRY tebLockList = SrvTebLockList( );
            InitializeListHead( tebLockList );
            currentTeb->UserReserved[SRV_TEB_LOCK_INIT] = (PVOID)0xbabababa;
        }
        RELEASE_SPIN_LOCK( LockSpinLock, oldIrql );

        //
        // Make sure that the list of locks in the TEB is consistent.
        //

        SrvCheckListIntegrity( SrvTebLockList( ), MAX_LOCKS_HELD );

        //
        // The "lock level" of this thread is the highest level of the
        // locks currently held exclusively.  If this thread holds no
        // locks, the lock level of the thread is 0 and it can acquire
        // any lock.
        //

        threadLockLevel = SrvThreadLockLevel( );

        //
        // Make sure that the lock the thread is attempting to acquire
        // has a higher level than the last-acquired exclusive lock.
        // Note that a recursive exclusive acquisition of a lock should
        // succeed, even if a different, higher-level lock has been
        // acquired since the lock was originally acquired.  Shared
        // acquisition of a lock that is already held exclusively must
        // fail.
        //
        // *** We do NOT make this check if the caller isn't going to
        //     wait for the lock, because no-wait acquisitions cannot
        //     actually induce deadlock.  The server FSD does this at
        //     DPC level, potentially having interrupted a server FSP
        //     thread that holds a higher-level lock.
        //

        if ( Wait &&
             (LOCK_LEVEL( Lock ) <= threadLockLevel) &&
             (!Exclusive ||
              !ExIsResourceAcquiredExclusive( &Lock->Resource )) ) {

            SrvPrint4( "Thread %lx, last lock %s(%lx, L%lx) attempted to ",
                        currentThread,
                        SrvThreadLockName( ), SrvThreadLockAddress( ),
                        threadLockLevel );
            SrvPrint4( "acquire %s(%lx, L%lx) for %s access.\n",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        Exclusive ? "exclusive" : "shared" );
#if DBG
            DbgBreakPoint( );
#endif

        }

    }

    //
    // Acquire the lock.
    //

    if ( Exclusive ) {
        lockAcquired = ExAcquireResourceExclusive( &Lock->Resource, Wait );
    } else {
        lockAcquired = ExAcquireResourceShared( &Lock->Resource, Wait );
    }

    //
    // If the lock could not be acquired (Wait == FALSE), print a debug
    // message.
    //

    if ( !lockAcquired ) {

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) no-wait %s acquistion ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        Exclusive ? "exclusive" : "shared" );
            SrvPrint1( "by thread %lx failed\n", currentThread );
        }

    } else if ( !Exclusive ) {

        //
        // For shared locks, we don't retain any information about
        // the fact that they're owned by this thread.
        //

        IF_DEBUG(LOCKS) {
            PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
            PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
            ULONG level = hasTeb ? threadLockLevel : (ULONG)-1;
            SrvPrint4( "%s(%lx, L%lx) acquired shared by thread %lx, ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        currentThread );
            SrvPrint3( "last lock %s(%lx L%lx)\n", name, address, level );
        }

    } else {

        //
        // The thread acquired the lock for exclusive access.
        //

        if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 1 ) {

            //
            // This is the first time the thread acquired the lock for
            // exclusive access.  Update the thread's lock state.
            //

            IF_DEBUG(LOCKS) {
                PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
                PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
                ULONG level = hasTeb ? threadLockLevel : (ULONG)-1;
                SrvPrint4( "%s(%lx, L%lx) acquired exclusive by thread %lx, ",
                            LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                            currentThread );
                SrvPrint3( "last lock %s(%lx L%lx)\n", name, address, level );
            }

            if ( hasTeb ) {

                //
                // Insert the lock on the thread's list of locks.
                //

                ExInterlockedInsertHeadList(
                    SrvTebLockList( ),
                    LOCK_THREAD_LIST( Lock ),
                    &LockSpinLock
                    );

            }

        } else {

            //
            // This is a recursive acquisition of the lock.
            //

            IF_DEBUG(LOCKS) {
                SrvPrint4( "%s(%lx, L%lx) reacquired by thread %lx; ",
                            LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                            currentThread );
                SrvPrint1( "count %ld\n", LOCK_NUMBER_OF_ACTIVE( Lock ) );
            }

        }

    }

    return lockAcquired;

} // SrvAcquireLock


VOID
SrvReleaseLock(
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine releases a lock.

Arguments:

    Lock - Supplies the lock to release

Return Value:

    None.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;

    PAGED_CODE( );

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = SrvCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure the lock is really owned by the current thread.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 0 ) {

        // !!! Should crash server on internal error here.

        SrvPrint3( "Thread %lx releasing unowned lock %s(%lx)\n",
                    currentThread, LOCK_NAME( Lock ), Lock );
        DbgBreakPoint( );

    } else if ( (Lock->Resource.Flag & ResourceOwnedExclusive) &&
                !ExIsResourceAcquiredExclusive(&Lock->Resource) ) {

        // !!! Should crash server on internal error here.

        SrvPrint4( "Thread %lx releasing lock %s(%lx) owned by "
                    "thread %lx\n",
                    currentThread, LOCK_NAME( Lock ), Lock,
                    Lock->Resource.InitialOwnerThreads[0] );
        DbgBreakPoint( );

    } else if ( !(Lock->Resource.Flag & ResourceOwnedExclusive) ) {

        //
        // The thread is releasing shared access to the lock.
        //

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) released shared by thread %lx\n",
                          LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                          currentThread );
        }

    } else if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 1 ) {

        //
        // The thread is fully releasing exclusive access to the lock.
        //

        if ( hasTeb ) {

            //
            // Remove the lock from the list of locks held by this
            // thread.
            //

            ExInterlockedRemoveHeadList(
                LOCK_THREAD_LIST( Lock )->Blink,
                &LockSpinLock
                );
            LOCK_THREAD_LIST( Lock )->Flink = NULL;
            LOCK_THREAD_LIST( Lock )->Blink = NULL;

            //
            // Make sure that the list of locks in the TEB is consistent.
            //

            SrvCheckListIntegrity( SrvTebLockList( ), MAX_LOCKS_HELD );

        }

        IF_DEBUG(LOCKS) {
            PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
            PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
            ULONG level = hasTeb ? SrvThreadLockLevel( ) : (ULONG)-1;
            SrvPrint4( "%s(%lx, L%lx) released by thread %lx, ",
                          LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                          currentThread );
            SrvPrint3( "new last lock %s(%lx L%lx)\n", name, address, level );
        }

    } else {

        //
        // The thread is partially releasing exclusive access to the
        // lock.
        //

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) semireleased by thread %lx; ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        currentThread );
            SrvPrint1( "new count %ld\n", LOCK_NUMBER_OF_ACTIVE( Lock ) - 1 );
        }

    }

    //
    // Now actually do the release.
    //

    ExReleaseResource( &Lock->Resource );

    return;

} // SrvReleaseLock

#endif // SRVDBG_LIST


#if SRVDBG_LIST || SRVDBG_LOCK

ULONG
SrvCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This debug routine checks the integrity of a doubly-linked list by
    walking the list forward and backward.  If the number of elements is
    different in either direction, or there are too many entries in the
    list, execution is stopped.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    MaxEntries - if the number of entries in the list exceeds this
        number, breakpoint.

Return Value:

    ULONG - the number of entries in the list.

--*/

{
    PLIST_ENTRY current;
    ULONG entriesSoFar;
    ULONG flinkEntries;

    for ( current = ListHead->Flink, entriesSoFar = 0;
          current != ListHead;
          current = current->Flink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            SrvPrint2( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    flinkEntries = entriesSoFar;

    for ( current = ListHead->Blink, entriesSoFar = 0;
          current != ListHead;
          current = current->Blink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            SrvPrint2( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    if ( flinkEntries != entriesSoFar ) {
        SrvPrint3( "In list %lx, Flink entries: %ld, Blink entries: %lx\n",
                      ListHead, flinkEntries, entriesSoFar );
        DbgBreakPoint( );
    }

    return entriesSoFar;

} // SrvCheckListIntegrity

#endif // SRVDBG_LIST || SRVDBG_LOCK


#if SRVDBG_LIST

VOID
SrvIsEntryInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This debug routine determines whether the specified list entry is
    contained within the list.  If not, execution is stopped.  This is
    meant to be called before removing an entry from a list.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    ListEntry - a pointer to the entry to check.

Return Value:

    None.

--*/

{
    PLIST_ENTRY checkEntry;

    //
    // Walk the list.  If we find the entry we're looking for, quit.
    //

    for ( checkEntry = ListHead->Flink;
          checkEntry != ListHead;
          checkEntry = checkEntry->Flink ) {

        if ( checkEntry == ListEntry ) {
            return;
        }

        if ( checkEntry == ListEntry ) {
            SrvPrint2( "Entry at %lx supposedly in list at %lx but list is "
                      "circular.", ListEntry, ListHead );
        }
    }

    //
    // If we got here without returning, then the entry is not in the
    // list and something has gone wrong.
    //

    SrvPrint2( "SrvIsEntryInList: entry at %lx not found in list at %lx\n",
                  ListEntry, ListHead );
    DbgBreakPoint( );

    return;

} // SrvIsEntryInList


VOID
SrvIsEntryNotInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This debug routine determines whether the specified list entry is
    contained within the list.  If it is, execution is stopped.  This is
    meant to be called before inserting an entry in a list.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    ListEntry - a pointer to the entry to check.

Return Value:

    None.

--*/

{
    PLIST_ENTRY checkEntry;

    //
    // Walk the list.  If we find the entry we're looking for, break.
    //

    for ( checkEntry = ListHead->Flink;
          checkEntry != ListHead;
          checkEntry = checkEntry->Flink ) {

        if ( checkEntry == ListEntry ) {

            SrvPrint2( "SrvIsEntryNotInList: entry at %lx found in list "
                        "at %lx\n", ListEntry, ListHead );
            DbgBreakPoint( );

        }

    }

    //
    // If we got here without returning, then the entry is not in the
    // list, so we can return.
    //

    return;

} // SrvIsEntryNotInList

#endif // SRVDBG_LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\ipx.h ===
#define IPXSID_INDEX(id) (USHORT)( (id) & 0x0FFF )
#define IPXSID_SEQUENCE(id) (USHORT)( (id) >> 12 )
#define MAKE_IPXSID(index, sequence) (USHORT)( ((sequence) << 12) | (index) )
#define INCREMENT_IPXSID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0xF);

//
// Name claim routine
//

NTSTATUS
SrvIpxClaimServerName (
    IN PENDPOINT Endpoint,
    IN PVOID NetbiosName
    );

//
// Transport Receive Datagram indication handlers
//

NTSTATUS
SrvIpxServerDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
SrvIpxServerChainedDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG ReceiveDatagramLength,
    IN ULONG StartingOffset,
    IN PMDL Tsdu,
    IN PVOID TransportContext
    );

NTSTATUS
SrvIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

//
// Datagram send routine
//

VOID
SrvIpxStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    );

//
// Routine called by IPX smart accelerator card when a read is complete
//
VOID
SrvIpxSmartCardReadComplete(
    IN PVOID    Context,
    IN PFILE_OBJECT FileObject,
    IN PMDL Mdl OPTIONAL,
    IN ULONG Length
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\lockcode.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lockcode.c

Abstract:

Author:

    Chuck Lenzmeier (chuckl) 30-Jan-1994

Revision History:

--*/

#include "precomp.h"
#include "lockcode.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_LOCKCODE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvReferenceUnlockableCodeSection )
#pragma alloc_text( PAGE, SrvDereferenceUnlockableCodeSection )
#endif


VOID
SrvReferenceUnlockableCodeSection (
    IN ULONG CodeSection
    )
{
    PSECTION_DESCRIPTOR section = &SrvSectionInfo[CodeSection];
    ULONG oldCount;

    //
    // Lock the lockable code database.
    //

    ACQUIRE_LOCK( &SrvUnlockableCodeLock );

    //
    // Increment the reference count for the section.
    //

    oldCount = section->ReferenceCount++;

    if ( oldCount == 0 ) {

        //
        // This is the first reference to the section.  Lock it.
        //

        ASSERT( section->Handle == NULL );
        section->Handle = MmLockPagableCodeSection( section->Base );

    } else {

        //
        // This is not the first reference to the section.  The section
        // had better be locked!
        //

        ASSERT( section->Handle != NULL );

    }

    RELEASE_LOCK( &SrvUnlockableCodeLock );

    return;

} // SrvReferenceUnlockableCodeSection


VOID
SrvDereferenceUnlockableCodeSection (
    IN ULONG CodeSection
    )
{
    PSECTION_DESCRIPTOR section = &SrvSectionInfo[CodeSection];
    ULONG newCount;

    //
    // Lock the lockable code database.
    //

    ACQUIRE_LOCK( &SrvUnlockableCodeLock );

    ASSERT( section->Handle != NULL );

    //
    // Decrement the reference count for the section.
    //

    newCount = --section->ReferenceCount;

    if ( newCount == 0 ) {

        //
        // This is the last reference to the section.  Unlock it.
        //

        MmUnlockPagableImageSection( section->Handle );
        section->Handle = NULL;

    }

    RELEASE_LOCK( &SrvUnlockableCodeLock );

    return;

} // SrvDereferenceUnlockableCodeSection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\network.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains routines for interfacing the LAN Manager server
    to the network.

Author:

    Chuck Lenzmeier (chuckl)    7-Oct-1989

Environment:

    File System Process, kernel mode only

Revision History:

--*/

#include "precomp.h"
#include "network.tmh"
#pragma hdrstop

#include    <ntddip.h>
#include    <ntddtcp.h>
#include    <ipfltdrv.h>
#include    <tcpinfo.h>
#include    <tdiinfo.h>
#include    <nbtioctl.h>

// WinSock definitions

#define AF_INET 2

struct sockaddr_in {
        short   sin_family;
        USHORT sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define AF_INET6 23

/* IPv6 socket address structure, RFC 2553 */

struct sockaddr_in6 {
    short   sin6_family;        /* AF_INET6 */
    USHORT sin6_port;          /* Transport level port number */
    ULONG  sin6_flowinfo;      /* IPv6 flow information */
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } sin6_addr;
    ULONG sin6_scope_id;       /* set of interfaces for a scope */
};


#define BugCheckFileId SRV_FILE_NETWORK

//
// Local declarations
//

NTSTATUS
GetNetworkAddress (
    IN PENDPOINT Endpoint
    );

NTSTATUS
OpenEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG         TransportAddFlags,
    IN BOOLEAN       AlternateEndpoint
    );

NTSTATUS
OpenNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenNetbiosExAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenNonNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PVOID DeviceName,
    IN USHORT Socket
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAddServedNet )
#pragma alloc_text( PAGE, SrvDeleteServedNet )
#pragma alloc_text( PAGE, SrvDoDisconnect )
#pragma alloc_text( PAGE, GetNetworkAddress )
#pragma alloc_text( PAGE, OpenEndpoint )
#pragma alloc_text( PAGE, OpenNetbiosAddress )
#pragma alloc_text( PAGE, OpenNonNetbiosAddress )
#pragma alloc_text( PAGE, OpenIpxSocket )
#pragma alloc_text( PAGE, SrvRestartAccept )
#pragma alloc_text( PAGE, GetIpxMaxBufferSize )

#endif
#if 0
NOT PAGEABLE -- SrvOpenConnection
NOT PAGEABLE -- SrvPrepareReceiveWorkItem
NOT PAGEABLE -- SrvStartSend
NOT PAGEABLE -- SrvStartSend2
#endif


NTSTATUS
SrvAddServedNet(
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG         TransportAddFlags,
    IN DWORD            PasswordLength,
    IN PBYTE            Password
    )

/*++

Routine Description:

    This function initializes the server on a network.  This
    involves making the server known by creating a transport endpoint,
    posting a Listen request, and setting up event handlers.

Arguments:

    NetworkName - The administrative name of the network (e.g., NET1)

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The fully qualified address (or name ) of the
        server's endpoint.  This name is used exactly as specified.  For
        NETBIOS-compatible networks, the caller must upcase and
        blank-fill the name.  For example, "NTSERVERbbbbbbbb".

    DomainName - The name of the domain to service

    Password/PasswordLength - used for mutual authentication (optional)

Return Value:

    NTSTATUS - Indicates whether the network was successfully started.

--*/
{
    NTSTATUS status;
    PENDPOINT endpoint;

    PAGED_CODE( );

    IF_DEBUG(TRACE1) KdPrint(( "SrvAddServedNet entered\n" ));

    //
    // Call OpenEndpoint to open the transport provider, bind to the
    // server address, and register the FSD receive event handler.
    //

    status = OpenEndpoint(
                &endpoint,
                NetworkName,
                TransportName,
                TransportAddress,
                DomainName,
                TransportAddFlags,
                FALSE);              // primary endpoint

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvAddServedNet: unable to open endpoint %wZ for addr %z, status %X\n", TransportName, (PCSTRING)TransportAddress, status ));
        }

        return status;
    }

    //
    // Dereference the endpoint.  (When it was created, the reference
    // count was incremented to account for our pointer.)
    //
    SrvDereferenceEndpoint( endpoint );

    //
    // Call OpenEndpoint to open the transport provider, bind to the
    // server address, and register the FSD receive event handler. This is
    // the auxillary endpoint registration in the new TDI address format. Since
    // this is not supported by all the transports it cannot be deemed an error.
    //
    //
    status = OpenEndpoint(
                   &endpoint,
                   NetworkName,
                   TransportName,
                   TransportAddress,
                   DomainName,
                   TransportAddFlags,
                   TRUE);              // Alternate endpoint

    if ( NT_SUCCESS( status ) ) {
        SrvDereferenceEndpoint( endpoint );
    }

    if( PasswordLength ) {
        SrvAddSecurityCredentials( TransportAddress, DomainName, PasswordLength, Password );
    }

    return STATUS_SUCCESS;

} // SrvAddServedNet


NTSTATUS
SrvDeleteServedNet(
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress
    )

/*++

Routine Description:

    This function causes the server to stop listening to a network.

Arguments:

    TransportAddress - the transport address (e.g. \Device\Nbf\POPCORN
        of the endpoint to delete.

Return Value:

    NTSTATUS - Indicates whether the network was successfully stopped.

--*/

{
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;
    BOOLEAN match;
    NTSTATUS status = STATUS_NONEXISTENT_NET_NAME;

    PAGED_CODE( );
    IF_DEBUG(TRACE1) KdPrint(( "SrvDeleteServedNet entered\n" ));

    //
    // Find the endpoint block with the specified name.
    //

top:
    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        if( GET_BLOCK_STATE(endpoint) == BlockStateActive ) {

            //
            // We have a match if the transport name is correct and we either
            //  haven't specified a transport address, or if the transport
            //  address matches
            //
            match = (BOOLEAN)(
                        RtlEqualUnicodeString(
                            TransportName,
                            &endpoint->TransportName,
                            TRUE                    // case insensitive compare
                            )
                        &&
                        (
                        TransportAddress->Length == 0 ||

                        RtlEqualString(
                            (PSTRING)TransportAddress,
                            (PSTRING)&endpoint->TransportAddress,
                            TRUE                    // case insensitive compare
                            )
                        )

                        );

            if ( match ) {

                //
                // The specified network name (endpoint) exists.  Close the
                // endpoint.  This releases the endpoint lock.
                //

                SrvCloseEndpoint( endpoint );

                status = STATUS_SUCCESS;

                //
                // Restart this loop, since this endpoint may have vaporized and
                //  the list might have changed because we dropped SrvEndpointLock.
                //
                // SrvCloseEndpoint will have marked this endpoint as BlockStateClosing,
                //  so we will not be in an infinite loop!
                //
                goto top;

            }
        }

        //
        // Go to the next one.
        //

        listEntry = listEntry->Flink;

    }

    //
    // We are done.  If we successfully matched an endpoint, we return STATUS_SUCCESS
    //

    RELEASE_LOCK( &SrvEndpointLock );

    return status;

} // SrvDeleteServedNet


NTSTATUS
SrvDoDisconnect (
    IN OUT PCONNECTION Connection
    )

/*++

Routine Description:

    This function issues a Disconnect request on a network.  The request
    is performed synchronously -- control is not returned to the caller
    until the request completes.

Arguments:

    Connection - Supplies a pointer to an Connection Block

Return Value:

    NTSTATUS - Indicates whether the disconnect was successful.

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(TRACE2) KdPrint(( "SrvDoDisconnect entered\n" ));
#if SRVDBG29
    UpdateConnectionHistory( "SDSC", Connection->Endpoint, Connection );
#endif

    ASSERT( !Connection->Endpoint->IsConnectionless );

    //
    // Issue the disconnect request.
    //

    status = SrvIssueDisconnectRequest(
                Connection->FileObject,
                &Connection->DeviceObject,
                TDI_DISCONNECT_ABORT
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvDoDisconnect: NtDeviceIoControlFile failed: %X",
             status,
             NULL
             );

#if SRVDBG29
        if (status != STATUS_LINK_FAILED && status != STATUS_REMOTE_DISCONNECT) {
            KdPrint(( "SRV: SrvDoDisconnect: SrvIssueDisconnectRequest failed\n" ));
            DbgBreakPoint();
        }
#endif
        //
        // Mark the connection as not reusable, because the transport
        // probably still thinks it's active.
        //

        Connection->NotReusable = TRUE;

        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );

    }

    //
    // Return the status of the I/O operation.
    //

    return status;

} // SrvDoDisconnect


NTSTATUS
SrvOpenConnection (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function opens a connection for an endpoint and queues it to
    the endpoint's free connection list.

Arguments:

    Endpoint - Supplies a pointer to an Endpoint Block

Return Value:

    NTSTATUS - Indicates whether the connection was successfully opened.

--*/

{
    NTSTATUS status;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                  TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                  sizeof(CONNECTION_CONTEXT)];
    PFILE_FULL_EA_INFORMATION ea;
    CONNECTION_CONTEXT UNALIGNED *ctx;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    KIRQL oldIrql;
    PTABLE_HEADER tableHeader;
    SHORT sidIndex;
    USHORT i;
    PTABLE_ENTRY entry = NULL;
    TDI_PROVIDER_INFO providerInfo;

    //
    // Allocate a connection block.
    //

    SrvAllocateConnection( &connection );

    if ( connection == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    pagedConnection = connection->PagedConnection;

    //
    // Allocate an entry in the endpoint's connection table.
    //

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &Endpoint->ConnectionTable;

    if ( tableHeader->FirstFreeEntry == -1 &&
         SrvGrowTable(
            tableHeader,
            8,
            0x7fff,
            NULL ) == FALSE ) {

        for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto cleanup;
    }

    sidIndex = tableHeader->FirstFreeEntry;
    entry = &tableHeader->Table[sidIndex];
    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == sidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    if ( !Endpoint->IsConnectionless ) {

        //
        // Create the EA for the connection context.
        //

        ea = (PFILE_FULL_EA_INFORMATION)eaBuffer;
        ea->NextEntryOffset = 0;
        ea->Flags = 0;
        ea->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
        ea->EaValueLength = sizeof(CONNECTION_CONTEXT);

        RtlCopyMemory( ea->EaName, StrConnectionContext, ea->EaNameLength + 1 );

        ctx = (CONNECTION_CONTEXT UNALIGNED *)&ea->EaName[ea->EaNameLength + 1];
        *ctx = connection;

        //
        // Create the connection file object.
        //

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &Endpoint->TransportName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtCreateFile(
                    &pagedConnection->ConnectionHandle,
                    0,
                    &objectAttributes,
                    &iosb,
                    NULL,
                    0,
                    0,
                    0,
                    0,
                    eaBuffer,
                    FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                ea->EaNameLength + 1 + ea->EaValueLength
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvOpenConnection: NtCreateFile failed: %X\n", status ));
            }
            goto cleanup;
        }
        SRVDBG_CLAIM_HANDLE( pagedConnection->ConnectionHandle, "CON", 7, connection );

        //
        // Obtain a referenced pointer to the file object.
        //

        status = ObReferenceObjectByHandle(
                    pagedConnection->ConnectionHandle,
                    0,
                    (POBJECT_TYPE) NULL,
                    KernelMode,
                    (PVOID *)&connection->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "SrvOpenConnection: ObReferenceObjectByHandle failed: %X",
                status,
                NULL
                );

            goto cleanup;

        }

        //
        // Get the address of the device object for the endpoint.
        //

        connection->DeviceObject = IoGetRelatedDeviceObject(
                                        connection->FileObject
                                        );

        //
        // Associate the connection with the endpoint's address.
        //

        status = SrvIssueAssociateRequest(
                    connection->FileObject,
                    &connection->DeviceObject,
                    Endpoint->EndpointHandle
                    );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvOpenConnection: SrvIssueAssociateRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            goto cleanup;
        }

        IF_DEBUG(NET1) {
            KdPrint(( "SrvOpenConnection: Connection on %p %z opened; handle %p, pointer %p\n", Endpoint,
                        (PCSTRING)&Endpoint->TransportAddress,
                        connection->PagedConnection->ConnectionHandle,
                        connection->FileObject ));
        }

        //
        // Initialize the MaximumSendSize for the transport that we're using
        //

        status = SrvIssueTdiQuery(
                    connection->FileObject,
                    &connection->DeviceObject,
                    (PCHAR)&providerInfo,
                    sizeof(providerInfo),
                    TDI_QUERY_PROVIDER_INFO
                    );

        //
        // If we got the provider info, make sure the maximum send size is at
        // least 1K-1. If we have no provider info, then maximum send size is 64KB.
        //

        if ( NT_SUCCESS(status) ) {
            connection->MaximumSendSize = providerInfo.MaxSendSize;
            if ( connection->MaximumSendSize < MIN_SEND_SIZE ) {
                connection->MaximumSendSize = MIN_SEND_SIZE;
            }
        } else {
            connection->MaximumSendSize = MAX_PARTIAL_BUFFER_SIZE;
        }


    } else { // if ( Endpoint->IsConnectionless )
        if (sidIndex > 0xfff) {
            // The IPXSID index can only span 12 bits
            // Code needs to be added to ensure that we can try to locate
            // an index less than 0xfff
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto cleanup;
        }

        // Give this the default initialization
        connection->MaximumSendSize = MAX_PARTIAL_BUFFER_SIZE;
    }
    //
    // Set the reference count on the connection to zero, in order to
    // put it on the free list.  (SrvAllocateConnection initialized the
    // count to two.)
    //

    connection->BlockHeader.ReferenceCount = 0;

    UPDATE_REFERENCE_HISTORY( connection, TRUE );
    UPDATE_REFERENCE_HISTORY( connection, TRUE );

    //
    // Reference the endpoint and link the connection into the
    // endpoint's free connection list.
    //

    connection->Endpoint = Endpoint;
    connection->EndpointSpinLock =
        &ENDPOINT_SPIN_LOCK(sidIndex & ENDPOINT_LOCK_MASK);

    ACQUIRE_LOCK( &SrvEndpointLock );

    SrvReferenceEndpoint( Endpoint );

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
    INCREMENT_IPXSID_SEQUENCE( entry->SequenceNumber );
    if ( sidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_IPXSID_SEQUENCE( entry->SequenceNumber );
    }

    connection->Sid = MAKE_IPXSID( sidIndex, entry->SequenceNumber );
    connection->SidIndex = sidIndex;

    entry->Owner = connection;
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    SrvInsertTailList(
        &Endpoint->FreeConnectionList,
        &connection->EndpointFreeListEntry
        );
#if SRVDBG29
    UpdateConnectionHistory( "OPEN", Endpoint, connection );
#endif
    Endpoint->FreeConnectionCount++;
    Endpoint->TotalConnectionCount++;

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    IF_DEBUG(TDI) {
        KdPrint(( "SrvOpenConnection created connection %p for endpoint %p; free %ld, total %ld\n", connection, Endpoint,
                    Endpoint->FreeConnectionCount,
                    Endpoint->TotalConnectionCount ));
    }

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // The connection open was successful.
    //

    IF_DEBUG(TRACE1) {
        KdPrint(( "SrvOpenConnection complete: %X\n", STATUS_SUCCESS ));
    }

    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( !Endpoint->IsConnectionless ) {
        if ( connection->FileObject != NULL ) {
            ObDereferenceObject( connection->FileObject );
        }
        if ( pagedConnection->ConnectionHandle != NULL ) {
            SRVDBG_RELEASE_HANDLE( pagedConnection->ConnectionHandle, "CON", 12, connection );
            SrvNtClose( pagedConnection->ConnectionHandle, FALSE );
        }
    }

    if ( entry != NULL ) {
        SrvRemoveEntryTable( tableHeader, sidIndex );
    }

    SrvFreeConnection( connection );

    return status;

} // SrvOpenConnection


NTSTATUS
GetNetworkAddress (
    IN PENDPOINT Endpoint
    )

{
    NTSTATUS status;
    PCHAR adapterStatus;
    PCHAR adapterAddress;
    ANSI_STRING ansiString;
    CHAR addressData[12+1];
    ULONG i;

    struct {
        ULONG ActivityCount;
        TA_IPX_ADDRESS LocalAddress;
    } addressInfo;

    PAGED_CODE( );

    if ( !Endpoint->IsConnectionless ) {

        //
        // Allocate a buffer to receive adapter information.
        //
        // *** We want to get the ADAPTER_STATUS structure, but it is
        //     defined in the windows header file sdk\inc\nb30.h.
        //     Rather than including all the windows header files, just
        //     allocate about a page, which should always be enough for
        //     that structure.
        //

        adapterStatus = ALLOCATE_NONPAGED_POOL( 4080, BlockTypeAdapterStatus );
        if ( adapterStatus == NULL ) {
            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        status = SrvIssueTdiQuery(
                    Endpoint->FileObject,
                    &Endpoint->DeviceObject,
                    adapterStatus,
                    4080,
                    TDI_QUERY_ADAPTER_STATUS
                    );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "GetNetworkAddress: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            DEALLOCATE_NONPAGED_POOL( adapterStatus );
            return status;
        }

        adapterAddress = adapterStatus;

    } else {

        status = SrvIssueTdiQuery(
                    Endpoint->NameSocketFileObject,
                    &Endpoint->NameSocketDeviceObject,
                    (PCHAR)&addressInfo,
                    sizeof(addressInfo),
                    TDI_QUERY_ADDRESS_INFO
                    );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "GetNetworkAddress: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            return status;
        }

        Endpoint->LocalAddress = addressInfo.LocalAddress.Address[0].Address[0];

        adapterAddress = addressInfo.LocalAddress.Address[0].Address[0].NodeAddress;

    }

    //
    // Get an ANSI string that contains the adapter address.
    //

    ansiString.Buffer = addressData;
    ansiString.Length = 12;
    ansiString.MaximumLength = 13;

#define tohexdigit(a) ((CHAR)( (a) > 9 ? ((a) + 'a' - 0xA) : ((a) + '0') ))

    for ( i = 0; i < 6; i++ ) {
        addressData[2*i] = tohexdigit( (adapterAddress[i] >> 4) & 0x0F );
        addressData[2*i+1] = tohexdigit( adapterAddress[i] & 0x0F );
    }

    addressData[12] = '\0';

    //
    // Convert the address string to Unicode.
    //

    status = RtlAnsiStringToUnicodeString(
                &Endpoint->NetworkAddress,
                &ansiString,
                FALSE
                );
    ASSERT( NT_SUCCESS(status) );

    if ( !Endpoint->IsConnectionless ) {
        DEALLOCATE_NONPAGED_POOL( adapterStatus );
    }

    return STATUS_SUCCESS;

} // GetNetworkAddress


NTSTATUS
OpenEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN DWORD         TransportAddFlags,
    IN BOOLEAN       AlternateEndpoint
    )

/*++

Routine Description:

    This function opens a transport provider, simultaneously binding the
    server's address to the transport endpoint, and registers a Receive
    event handler for the endpoint.

Arguments:

    Endpoint - Returns a pointer to an Endpoint Block

    NetworkName - Supplies the administrative name of the network (e.g.,
        NET1).

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The exact name of the server to be used on the
        specified transport.  For NETBIOS-compatible networks, the
        caller must upcase and blank-fill the name.  For example,
        "NTSERVERbbbbbbbb".

    DomainName - name of domain to serve

Return Value:

    NTSTATUS - Indicates whether the network was successfully opened.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PENDPOINT endpoint = NULL;            // local copy of Endpoint

    PAGED_CODE( );

    IF_DEBUG(TRACE1) KdPrint(( "OpenEndpoint %wZ entered\n", TransportName ));

    //
    // Allocate an endpoint block.
    //

    SrvAllocateEndpoint(
        &endpoint,
        NetworkName,
        TransportName,
        TransportAddress,
        DomainName
        );

    if ( endpoint == NULL ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "OpenEndpoint complete: %X\n",
                        STATUS_INSUFF_SERVER_RESOURCES ));
        }
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    if( TransportAddFlags & SRP_XADD_PRIMARY_MACHINE ) {

        endpoint->IsPrimaryName = 1;

        if( SrvComputerName.Buffer == NULL ) {

            status = RtlAnsiStringToUnicodeString( &SrvComputerName, TransportAddress, TRUE );

            if( NT_SUCCESS( status ) ) {

                //
                // Trim off the trailing spaces
                //

                while( SrvComputerName.Buffer[(SrvComputerName.Length-sizeof(WCHAR))/sizeof(WCHAR)]
                    == L' ' ) {
                    SrvComputerName.Length -= sizeof(WCHAR);
                }
            }
        }
    }

    if( NT_SUCCESS( status ) ) {

       if( TransportAddFlags & SRP_XADD_REMAP_PIPE_NAMES ) {
           endpoint->RemapPipeNames = 1;
       }

       if (AlternateEndpoint) {

           status = OpenNetbiosExAddress(
                        endpoint,
                        TransportName,
                        TransportAddress->Buffer);

           endpoint->AlternateAddressFormat = TRUE;

       } else {

           endpoint->AlternateAddressFormat = FALSE;

          //
          // Assume that the transport is a NetBIOS provider, and try to
          // open the server's address using the NetBIOS name.
          //

          status = OpenNetbiosAddress(
                      endpoint,
                      TransportName,
                      TransportAddress->Buffer
                      );

          //
          // We could not open the transport as a NetBIOS provider.  We will now try
          //  to see if it is a direct host IPX provider. However, if we have been
          //  configured to use Security Signatures, do not attempt direct host IPX since
          //  security signatures are not supported for direct host IPX transports
          //
          if ( !NT_SUCCESS(status) && SrvSmbSecuritySignaturesRequired == FALSE ) {

              BOOLEAN isDuplicate = FALSE;
              PLIST_ENTRY listEntry;

              //
              // Apparently the transport is not a NetBIOS provider.  We can
              //  not open multiple connectionless providers through the same
              //  TransportName.
              //

              ACQUIRE_LOCK( &SrvEndpointLock );

              for( listEntry = SrvEndpointList.ListHead.Flink;
                   listEntry != &SrvEndpointList.ListHead;
                   listEntry = listEntry->Flink ) {

                  PENDPOINT tmpEndpoint;

                  tmpEndpoint = CONTAINING_RECORD( listEntry, ENDPOINT, GlobalEndpointListEntry );

                  if( GET_BLOCK_STATE( tmpEndpoint ) == BlockStateActive &&
                      tmpEndpoint->IsConnectionless &&
                      RtlCompareUnicodeString( &tmpEndpoint->TransportName, TransportName, TRUE ) == 0 ) {

                      IF_DEBUG(ERRORS) {
                          KdPrint(( "OpenEndpoint: Only one connectionless endpoint on %wZ allowed!\n",
                                    TransportName ));
                      }

                      isDuplicate = TRUE;
                      status = STATUS_TOO_MANY_NODES;
                      break;
                  }
              }

              RELEASE_LOCK( &SrvEndpointLock );

              //
              // Try to open it as a connectionless provider.
              //
              if( isDuplicate == FALSE ) {
                  NTSTATUS status2;

                  status2 = OpenNonNetbiosAddress(
                            endpoint,
                            TransportName,
                            TransportAddress->Buffer
                            );

                  if( NT_SUCCESS( status2 ) ) {
                    status = status2;
                  }
               }
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // We couldn't open the provider as either a NetBIOS provider
        // or as a connectionless provider.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "OpenEndpoint: OpenAddress failed: %X\n", status ));
        }

        //
        // Close all free connections.
        //

        EmptyFreeConnectionList( endpoint );

        SrvFreeEndpoint( endpoint );

        ACQUIRE_LOCK( &SrvEndpointLock );
        SrvEndpointCount--;

        if( SrvEndpointCount == 0 )
        {
            KeSetEvent( &SrvEndpointEvent, 0, FALSE );
        }

        RELEASE_LOCK( &SrvEndpointLock );

        return status;
    }

    //
    // Query the provider for the send entry point
    //

    SrvQuerySendEntryPoint(
                   endpoint->FileObject,
                   &endpoint->DeviceObject,
                   IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER,
                   (PVOID*)&endpoint->FastTdiSend
                   );

    //
    // Query the provider for the send entry point
    //

    SrvQuerySendEntryPoint(
                   endpoint->FileObject,
                   &endpoint->DeviceObject,
                   IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER,
                   (PVOID*)&endpoint->FastTdiSendDatagram
                   );

    //
    // The network open was successful.  Link the new endpoint into the
    // list of active endpoints.  Return with a success status.  (We
    // don't dereference the endpoint because we're returning a pointer
    // to the endpoint.)
    //

    SrvInsertEntryOrderedList( &SrvEndpointList, endpoint );

    *Endpoint = endpoint;

    IF_DEBUG(TRACE1) {
        KdPrint(( "OpenEndpoint complete: %wZ %X\n", TransportName, STATUS_SUCCESS ));
    }

    return STATUS_SUCCESS;

} // OpenEndpoint

NTSTATUS
SetupConnectionEndpointHandlers(
   IN OUT PENDPOINT Endpoint)
{
   NTSTATUS status;
   ULONG    i;

   Endpoint->IsConnectionless = FALSE;

   status = SrvVerifyDeviceStackSize(
                               Endpoint->EndpointHandle,
                               TRUE,
                               &Endpoint->FileObject,
                               &Endpoint->DeviceObject,
                               NULL
                               );

   if ( !NT_SUCCESS( status ) ) {

       INTERNAL_ERROR(
           ERROR_LEVEL_EXPECTED,
           "OpenNetbiosAddress: Verify Device Stack Size failed: %X\n",
           status,
           NULL
           );

       goto cleanup;
   }

   //
   // Find the network address of the adapter used by corresponding to
   // this endpoint.
   //

   GetNetworkAddress( Endpoint );

   //
   // Register the server's Receive event handler.
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_RECEIVE,
               (PVOID)SrvFsdTdiReceiveHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_EXPECTED,
           "OpenNetbiosAddress: set receive event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   //
   // Register the server's Disconnect event handler.
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_DISCONNECT,
               (PVOID)SrvFsdTdiDisconnectHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_UNEXPECTED,
           "OpenNetbiosAddress: set disconnect event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   //
   // Create a number of free connections for the endpoint.  These
   // connections will be used to service Connect events.
   //
   // *** If we fail in an attempt to create a connection, but we can
   //     successfully create at least one, we keep the endpoint.  The
   //     cleanup code below depends on this behavior.
   //

   for ( i = 0; i < SrvFreeConnectionMinimum; i++ ) {

       status = SrvOpenConnection( Endpoint );
       if ( !NT_SUCCESS(status) ) {
           INTERNAL_ERROR(
               ERROR_LEVEL_EXPECTED,
               "OpenNetbiosAddress: SrvOpenConnection failed: %X",
               status,
               NULL
               );
           if ( i == 0 ) {
               goto cleanup;
           } else {
               break;
           }
       }

   }

   //
   // Register the server's Connect event handler.
   //
   // *** Note that Connect events can be delivered IMMEDIATELY upon
   //     completion of this request!
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_CONNECT,
               (PVOID)SrvFsdTdiConnectHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_UNEXPECTED,
           "OpenNetbiosAddress: set connect event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   return STATUS_SUCCESS;

   //
   // Out-of-line error cleanup.
   //

cleanup:

   //
   // Something failed.  Clean up as appropriate.
   //

   if ( Endpoint->FileObject != NULL ) {
       ObDereferenceObject( Endpoint->FileObject );
       Endpoint->FileObject = NULL;
   }
   if ( Endpoint->EndpointHandle != NULL ) {
       SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 14, Endpoint );
       SrvNtClose( Endpoint->EndpointHandle, FALSE );
       Endpoint->EndpointHandle = NULL;
   }

   return status;
}


NTSTATUS
OpenNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;

    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_NETBIOS_ADDRESS)];

    PAGED_CODE( );

    status = TdiOpenNetbiosAddress(
                &Endpoint->EndpointHandle,
                eaBuffer,
                DeviceName,
                NetbiosName
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(( "TdiOpenNetbiosAddress( %wZ ) status %X\n", DeviceName, status ));
        }
        return status;
    }

    status = SetupConnectionEndpointHandlers(Endpoint);

    return status;
} // OpenNetbiosAddress

NTSTATUS
OpenNetbiosExAddress(
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
   NTSTATUS status;

   PFILE_FULL_EA_INFORMATION ea;
   OBJECT_ATTRIBUTES         objectAttributes;
   IO_STATUS_BLOCK           iosb;

   ULONG length;
   CHAR  buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                 TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                 sizeof(TA_NETBIOS_EX_ADDRESS)];

   TA_NETBIOS_EX_ADDRESS     NetbiosExAddress;
   PTDI_ADDRESS_NETBIOS_EX   pTdiNetbiosExAddress;
   PTDI_ADDRESS_NETBIOS      pNetbiosAddress;

   ULONG NetbiosExAddressLength;

   PAGED_CODE( );

   //
   // Build the NETBIOS Extended address.
   //

   NetbiosExAddress.TAAddressCount = 1;
   NetbiosExAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS_EX;
   NetbiosExAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;

   pTdiNetbiosExAddress = NetbiosExAddress.Address[0].Address;
   pNetbiosAddress = &pTdiNetbiosExAddress->NetbiosAddress;
   pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

   NetbiosExAddressLength =   FIELD_OFFSET(TRANSPORT_ADDRESS,Address)
                        + FIELD_OFFSET(TA_ADDRESS,Address)
                        + FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress)
                        + TDI_ADDRESS_LENGTH_NETBIOS;

   RtlCopyMemory(
         pNetbiosAddress->NetbiosName,
         NetbiosName,
         NETBIOS_NAME_LEN);

   // Copy the default endpoint name onto the NETBIOS Extended address.
   RtlCopyMemory(
         pTdiNetbiosExAddress->EndpointName,
         SMBSERVER_LOCAL_ENDPOINT_NAME,
         NETBIOS_NAME_LEN);

   length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                               TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                               NetbiosExAddressLength;
   ea = (PFILE_FULL_EA_INFORMATION)buffer;

   ea->NextEntryOffset = 0;
   ea->Flags = 0;
   ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
   ea->EaValueLength = (USHORT)NetbiosExAddressLength;

   RtlCopyMemory( ea->EaName, StrTransportAddress, ea->EaNameLength + 1 );

   RtlCopyMemory(
       &ea->EaName[ea->EaNameLength + 1],
       &NetbiosExAddress,
       NetbiosExAddressLength
       );

   InitializeObjectAttributes( &objectAttributes, DeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL );

   status = NtCreateFile (
                &Endpoint->EndpointHandle,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                &objectAttributes,     // object attributes
                &iosb,                 // returned status information
                NULL,                  // block size (unused)
                0,                     // file attributes
                FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                FILE_CREATE,           // create disposition
                0,                     // create options
                buffer,                // EA buffer
                length                 // EA length
                );

   if ( !NT_SUCCESS(status) ) {

      IF_DEBUG( ERRORS ) {
          KdPrint(("NtCreateFile %wZ NETBIOS_EX address status %X\n", DeviceName, status ));
       }

       return status;
   }

   Endpoint->IsNoNetBios = TRUE;
   status = SetupConnectionEndpointHandlers(Endpoint);

   IF_DEBUG( ERRORS ) {
     if( !NT_SUCCESS( status ) ) {
        KdPrint(("SetupConnectionEndpointHandlers failed, status %X\n", status ));
     }
   }

   return status;
}


NTSTATUS
OpenNonNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;
    ULONG numAdapters;
    PULONG maxPktArray = NULL;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1];
    PNWLINK_ACTION action;
    PIPX_ADDRESS_DATA ipxAddressData;

    PAGED_CODE( );

    //
    // Open the NetBIOS name socket.
    //

    status = OpenIpxSocket(
                &Endpoint->NameSocketHandle,
                &Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                DeviceName,
                SMB_IPX_NAME_SOCKET
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    Endpoint->IsConnectionless = TRUE;
    action = (PNWLINK_ACTION)buffer;

    //
    // Put the endpoint in broadcast reception mode.
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option);
    action->Option = MIPX_RCVBCAST;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION)
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Tell the transport to give you the extended receive info
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option);
    action->Option = MIPX_SETRCVFLAGS;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION)
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Get the max adapter number
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(ULONG);
    action->Option = MIPX_ADAPTERNUM2;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION) + sizeof(ULONG) - 1
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    numAdapters = *((PULONG)action->Data);

    //
    // Allocate an array to store the max pkt size for each adapter
    //

    maxPktArray = ALLOCATE_HEAP( numAdapters * sizeof(ULONG), BlockTypeBuffer );

    if ( maxPktArray == NULL ) {
        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto cleanup;
    }

    Endpoint->IpxMaxPacketSizeArray = maxPktArray;
    Endpoint->MaxAdapters = numAdapters;

    //
    // Query the max pkt size for each adapter
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(IPX_ADDRESS_DATA);
    action->Option = MIPX_GETCARDINFO2;
    ipxAddressData = (PIPX_ADDRESS_DATA)action->Data;

    for ( i = 0; i < numAdapters; i++ ) {

        ipxAddressData->adapternum = i;

        status = SrvIssueTdiAction(
                    Endpoint->NameSocketFileObject,
                    &Endpoint->NameSocketDeviceObject,
                    (PCHAR)action,
                    sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1
                    );

        if ( !NT_SUCCESS(status) ) {
            goto cleanup;
        }

        //
        // If this is a wan link, then we need to query the length each
        // time we get a connection.
        //

        if ( ipxAddressData->wan ) {
            maxPktArray[i] = 0;
        } else {
            maxPktArray[i] = ipxAddressData->maxpkt;
        }
    }

    //
    // Find the network address of the adapter used by corresponding to
    // this endpoint.
    //

    GetNetworkAddress( Endpoint );

    //
    // Register the name claim Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxNameDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    //
    // Claim the server name.
    //

    status = SrvIpxClaimServerName( Endpoint, NetbiosName );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Open the server socket.
    //

    status = OpenIpxSocket(
                &Endpoint->EndpointHandle,
                &Endpoint->FileObject,
                &Endpoint->DeviceObject,
                DeviceName,
                SMB_IPX_SERVER_SOCKET
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Create a number of free connections for the endpoint.  These
    // connections will be used to service Connect events.
    //
    // *** If we fail in an attempt to create a connection, but we can
    //     successfully create at least one, we keep the endpoint.  The
    //     cleanup code below depends on this behavior.
    //

    for ( i = 0; i < SrvFreeConnectionMinimum; i++ ) {

        status = SrvOpenConnection( Endpoint );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "OpenNonNetbiosAddress: SrvOpenConnection failed: %X",
                status,
                NULL
                );
            if ( i == 0 ) {
                goto cleanup;
            } else {
                break;
            }
        }

    }

    //
    // Register the server Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->FileObject,
                &Endpoint->DeviceObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxServerDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    //
    // Register the server Chained Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->FileObject,
                &Endpoint->DeviceObject,
                TDI_EVENT_CHAINED_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxServerChainedDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set chained receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( maxPktArray != NULL ) {
        Endpoint->IpxMaxPacketSizeArray = NULL;
        FREE_HEAP( maxPktArray );
    }
    if ( Endpoint->FileObject != NULL ) {
        ObDereferenceObject( Endpoint->FileObject );
        Endpoint->FileObject = NULL;
    }
    if ( Endpoint->EndpointHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 14, Endpoint );
        SrvNtClose( Endpoint->EndpointHandle, FALSE );
        Endpoint->FileObject = NULL;
    }

    if ( Endpoint->NameSocketFileObject != NULL ) {
        ObDereferenceObject( Endpoint->NameSocketFileObject );
        Endpoint->NameSocketFileObject = NULL;
    }
    if ( Endpoint->NameSocketHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( Endpoint->NameSocketHandle, "END", 14, Endpoint );
        SrvNtClose( Endpoint->NameSocketHandle, FALSE );
        Endpoint->NameSocketHandle = NULL;
    }

    return status;

} // OpenNonNetbiosAddress


NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PVOID DeviceName,
    IN USHORT Socket
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_FULL_EA_INFORMATION ea;
    TA_IPX_ADDRESS ipxAddress;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;

    CHAR buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_IPX_ADDRESS)];

    PAGED_CODE( );

    //
    // Build the IPX socket address.
    //

    length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                sizeof(TA_IPX_ADDRESS);
    ea = (PFILE_FULL_EA_INFORMATION)buffer;

    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = sizeof (TA_IPX_ADDRESS);

    RtlCopyMemory( ea->EaName, StrTransportAddress, ea->EaNameLength + 1 );

    //
    // Create a copy of the NETBIOS address descriptor in a local
    // first, in order to avoid alignment problems.
    //

    ipxAddress.TAAddressCount = 1;
    ipxAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    ipxAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_IPX);
    ipxAddress.Address[0].Address[0].Socket = Socket;

    RtlCopyMemory(
        &ea->EaName[ea->EaNameLength + 1],
        &ipxAddress,
        sizeof(TA_IPX_ADDRESS)
        );

    InitializeObjectAttributes( &objectAttributes, DeviceName, 0, NULL, NULL );

    status = NtCreateFile (
                 Handle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &objectAttributes,     // object attributes
                 &iosb,                 // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 buffer,                // EA buffer
                 length                 // EA length
                 );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    status = SrvVerifyDeviceStackSize(
                *Handle,
                TRUE,
                FileObject,
                DeviceObject,
                NULL
                );

    if ( !NT_SUCCESS( status ) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenIpxSocket: Verify Device Stack Size failed: %X\n",
            status,
            NULL
            );
        return status;
    }

    return STATUS_SUCCESS;

} // OpenIpxSocket


VOID
SrvPrepareReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN QueueItemToFreeList
    )

/*++

Routine Description:

    This routine initializes a Receive work item and optionally queues
    it to a list anchored in the server FSD device object.  The
    transport receive event handler in the FSD dequeues work items from
    this list and passes their associated IRPS to the transport
    provider.

Arguments:

    WorkContext - Supplies a pointer to the preallocated work context
        block that represents the work item.

    QueueItemToFreeList - If TRUE queue this work item on the receive
        free queue.

Return Value:

    None.

--*/

{
    PSMB_HEADER header;

    IF_DEBUG(TRACE2) KdPrint(( "SrvPrepareReceiveWorkItem entered\n" ));

    //
    // Set up pointers to the SMB header and parameters for the request
    // and the response.  Note that we currently write the response over
    // the request.  SMB processors must be able to handle this.  We
    // maintain separate request and response pointers so that we can
    // use a separate buffer if necessary.  Maintaining separate request
    // and response parameter pointers also allows us to process AndX
    // SMBs without having to pack the AndX commands as we go.
    //

    WorkContext->ResponseBuffer = WorkContext->RequestBuffer;

    header = (PSMB_HEADER)WorkContext->RequestBuffer->Buffer;

    WorkContext->RequestHeader = header;
    WorkContext->RequestParameters = (PVOID)(header + 1);

    WorkContext->ResponseHeader = header;
    WorkContext->ResponseParameters = (PVOID)(header + 1);

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    if ( QueueItemToFreeList ) {

        //
        // Queue the prepared receive work item to the FSD list.
        //

        GET_SERVER_TIME( WorkContext->CurrentWorkQueue, &WorkContext->Timestamp );
        RETURN_FREE_WORKITEM( WorkContext );

    } else {

        //
        // Make the work item look like it's in use by setting its
        // reference count to 1.
        //

        ASSERT( WorkContext->BlockHeader.ReferenceCount == 0 );
        WorkContext->BlockHeader.ReferenceCount = 1;

    }

    return;

} // SrvPrepareReceiveWorkItem


VOID SRVFASTCALL
SrvRestartAccept (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function is the worker thread restart routine for Accept
    requests.  If the endpoint on which the connection was established
    is no longer active, this routine disconnects the connection.  This
    is necessary because the connect indication handler cannot
    atomically verify that the endpoint is active and install the active
    connection.  (This is because the handler runs at DPC level.)

    This routine also checks the status of the TdiAccept.  In case of
    an error, it frees the connection.

    If all is well, but the endpoint is short of free connections, a new
    one is created.

Arguments:

    WorkContext - Supplies a pointer to the work context block describing
        server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PENDPOINT endpoint;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartAccept\n" ));

    connection = WorkContext->Connection;
    endpoint = WorkContext->Endpoint;
    irp = WorkContext->Irp;
    IF_DEBUG(TRACE2) {
        KdPrint(( "  connection %p, endpoint %p, IRP %p\n",
                    connection, endpoint, irp ));
    }

    //
    // If the I/O request failed or was canceled, or if the endpoint
    // block is closing, clean up.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    if ( irp->Cancel ||
         !NT_SUCCESS(irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(endpoint) != BlockStateActive) ) {

        RELEASE_LOCK( &SrvEndpointLock );

        DEBUG {
            KdPrint(( "SrvRestartAccept:  Accept failed!" ));
            if ( irp->Cancel ) {
                KdPrint(( "  I/O canceled\n" ));
            } else if ( !NT_SUCCESS(irp->IoStatus.Status) ) {
                KdPrint(( "  I/O failed: %X\n", irp->IoStatus.Status ));
            } else {
                KdPrint(( "  Endpoint no longer active\n" ));
            }
        }

        //
        // Close the connection.  If the Accept succeeded, we need to
        // issue a Disconnect.
        //

#if SRVDBG29
        if (irp->Cancel) {
            UpdateConnectionHistory( "ACC1", endpoint, connection );
        } else if (!NT_SUCCESS(irp->IoStatus.Status)) {
            UpdateConnectionHistory( "ACC2", endpoint, connection );
        } else {
            UpdateConnectionHistory( "ACC3", endpoint, connection );
        }
#endif

        connection->DisconnectReason = DisconnectAcceptFailedOrCancelled;
        SrvCloseConnection(
            connection,
            (BOOLEAN)(irp->Cancel || !NT_SUCCESS(irp->IoStatus.Status) ?
                        TRUE : FALSE)       // RemoteDisconnect
            );

    } else {

        PNBT_ADDRESS_PAIR_INFO AddressPairInfo;
        UNICODE_STRING clientMachineName;

        //
        // The Accept worked, and the endpoint is still active.  Create
        // a new free connection, if necessary.
        //

        if ( endpoint->FreeConnectionCount < SrvFreeConnectionMinimum ) {
            (VOID)SrvOpenConnection( endpoint );
            (VOID)SrvOpenConnection( endpoint );
        }

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // Get the IP address of the client (if it has one)
        //
        AddressPairInfo = WorkContext->RequestBuffer->Buffer;
        AddressPairInfo = (PNBT_ADDRESS_PAIR_INFO)(((ULONG_PTR)AddressPairInfo + 7) & ~7);

        //
        // Get the IP address of the client, if appropriate
        //
        status = SrvIssueTdiQuery(  connection->FileObject,
                                    &connection->DeviceObject,
                                    (PCHAR)AddressPairInfo, sizeof( *AddressPairInfo ),
                                    TDI_QUERY_ADDRESS_INFO
                                 );

        if( NT_SUCCESS( status ) &&
            AddressPairInfo->AddressPair.TAAddressCount == 2 ) {

            // Copy out the SockAddr info
            if( AddressPairInfo->AddressPair.AddressIP.AddressType == TDI_ADDRESS_TYPE_IP )
            {
                PTDI_ADDRESS_IP Address = &AddressPairInfo->AddressPair.AddressIP.Address;
                struct sockaddr_in* sockaddr = (struct sockaddr_in*)connection->SockAddr;

                sockaddr->sin_family = AF_INET;
                sockaddr->sin_port = Address->sin_port;
                sockaddr->sin_addr.S_un.S_addr = Address->in_addr;
            }
            else if( AddressPairInfo->AddressPair.AddressIP.AddressType == TDI_ADDRESS_TYPE_IP6 )
            {
                PTDI_ADDRESS_IP6 Address = &AddressPairInfo->AddressPair.AddressIP.AddressIp6;
                struct sockaddr_in6* sockaddr = (struct sockaddr_in6*)connection->SockAddr;

                ASSERT(sizeof(TDI_ADDRESS_IP6)==sizeof(struct sockaddr_in6)-sizeof(USHORT));
                sockaddr->sin6_family = AF_INET6;
                RtlCopyMemory( &sockaddr->sin6_port, Address, sizeof(TDI_ADDRESS_IP6) );
            }

            // Setup the ClientIPAddress and the Keep-alives
            if( AddressPairInfo->AddressPair.AddressIP.AddressType == TDI_ADDRESS_TYPE_IP )
            {
                PTCP_REQUEST_SET_INFORMATION_EX tcpSetInfo;
                struct TCPKeepalive *keepAlive;
                IO_STATUS_BLOCK iosb;

                connection->ClientIPAddress = AddressPairInfo->AddressPair.AddressIP.Address.in_addr;

                //
                // We have an IP client.  Set a reasonable keepalive interval.
                //
                tcpSetInfo = ALLOCATE_HEAP( sizeof(*tcpSetInfo) + sizeof( *keepAlive ), BlockTypeMisc );

                if( tcpSetInfo != NULL ) {

                    RtlZeroMemory( tcpSetInfo, sizeof( *tcpSetInfo ) + sizeof( *keepAlive ) );

                    tcpSetInfo->ID.toi_entity.tei_entity = CO_TL_ENTITY;
                    tcpSetInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
                    tcpSetInfo->ID.toi_type = INFO_TYPE_CONNECTION;
                    tcpSetInfo->ID.toi_id = TCP_SOCKET_KEEPALIVE_VALS;

                    tcpSetInfo->BufferSize = sizeof( *keepAlive );
                    keepAlive = (TCPKeepalive *)(&tcpSetInfo->Buffer[0]);

                    keepAlive->onoff = TRUE;     // turn on keepalives

                    //
                    // keepalive time is the time to first keepalive transmission, by default it
                    // is 2 hours (7,200,000 milliseconds) for TCP. If there is no data transfer between
                    // client and server for keepalive time, the server will send first keepalive
                    // probe. Successive probes are determined by keepalive interval. If there is any
                    // data transfer, timer is reset to keepalive time.
                    //
                    // keepalive interval is the interval in milliseconds between keepalive transmissions
                    // until a response is received, by default it is 1000.  Server sends a total of 10
                    // keepalive probes, keepalive interval apart, and if there is no response from the
                    // client, the connection is terminated.
                    //
                    keepAlive->keepalivetime =  2 * (60 * 1000);    // 2 minutes
                    keepAlive->keepaliveinterval = 2 * 1000;        // 2 seconds

                    //
                    // Set the keepalive values
                    //
                    (VOID)NtDeviceIoControlFile(
                                            connection->PagedConnection->ConnectionHandle,
                                            0,
                                            NULL,
                                            NULL,
                                            &iosb,
                                            IOCTL_NETBT_SET_TCP_CONNECTION_INFO,
                                            tcpSetInfo, sizeof( *tcpSetInfo ) + sizeof( *keepAlive ),
                                            NULL, 0
                                        );

                    FREE_HEAP( tcpSetInfo );
                }
            }

        } else {

            connection->ClientIPAddress = 0;
            RtlZeroMemory( connection->SockAddr, SRV_CONNECTION_SOCKADDR_SIZE );
        }

        //
        // Convert the client machine name to unicode
        //

        clientMachineName.Buffer = connection->ClientMachineName;
        clientMachineName.MaximumLength =
                        (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

        (VOID)RtlOemStringToUnicodeString(
                        &clientMachineName,
                        &connection->OemClientMachineNameString,
                        FALSE
                        );

        //
        // Add the double backslashes to the length
        //

        connection->ClientMachineNameString.Length =
                        (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

    }

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartAccept complete\n" ));
    return;

} // SrvRestartAccept


VOID
SrvStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine,
    IN PMDL Mdl OPTIONAL,
    IN ULONG SendOptions
    )

/*++

Routine Description:

    This function starts a Send request.  It is started as an
    asynchronous I/O request.  When the Send completes, it is delivered
    via the I/O completion routine to the server FSD, which routes it to
    the specified FsdRestartRoutine.  (This may be
    SrvQueueWorkToFspAtDpcLevel, which queues the work item to the FSP
    at the FspRestartRoutine.)

    Partial sends and chained sends are supported.  A partial send is one
    that is not the last segment of a "message" or "record".  A chained
    send is one made up of multiple virtually discontiguous buffers.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block.  The
        following fields of this structure must be valid:

            TdiRequest
            Irp (optional; actual address copied here)
            Endpoint
                Endpoint->FileObject
                Endpoint->DeviceObject
            Connection
                Connection->ConnectionId

    Mdl - Supplies a pointer to the first (or only) MDL describing the
        data that is to be sent.  To effect a chained send, the Next
        pointer of each MDL in the chain must point to the next MDL;
        the end of the chain is indicated by the NULL Next pointer.

        The total length of the send is calculated by summing the
        ByteCount fields of each MDL in the chain.

        This parameter is optional.  If it is omitted, a zero-length
        message is sent.

    SendOptions - Supplied TDI send options, which indicate whether this
        send is the last (or only) in a "chain" of partial sends.

Return Value:

    None.

--*/

{
    PTDI_REQUEST_KERNEL_SEND parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    ULONG sendLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend entered\n" ));

    ASSERT( !WorkContext->Endpoint->IsConnectionless );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Get the irp, device, and file objects
    //

    irp = WorkContext->Irp;
    deviceObject = WorkContext->Connection->DeviceObject;
    fileObject = WorkContext->Connection->FileObject;

    CHECKIRP( irp );

    if( irp->AssociatedIrp.SystemBuffer &&
        (irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( irp->AssociatedIrp.SystemBuffer );
        irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    irp->RequestorMode = KernelMode;
    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );


    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    parameters = (PTDI_REQUEST_KERNEL_SEND)&irpSp->Parameters;
    parameters->SendFlags = SendOptions;
    parameters->SendLength = sendLength;

    //
    // For these two cases, InputBuffer is the buffered I/O "system
    // buffer".  Build an MDL for either read or write access,
    // depending on the method, for the output buffer.
    //

    irp->MdlAddress = Mdl;

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

#if DBG
    if( sendLength >= sizeof( SMB_HEADER ) && sendLength <= 0xffff && Mdl ) {

        PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

        if ( SmbGetAlignedUlong( (PULONG)Smb->Protocol ) == SMB_HEADER_PROTOCOL ) {

            ULONG len;
            PMDL tmpMdl;

            //
            // For debugging purposes, put extra data in the response smb. This will help us figure
            // out what went wrong if the client detects an SMB format error
            //

            //
            // Put the send length in PidHigh
            //
            SmbPutUshort( &Smb->PidHigh, (USHORT)sendLength );

            //
            // Put the overall MDL length in Pid.  The transport is only supposed to transmit SendLength -- so
            //  this will help us figure out if the transport is sending too much data.
            //
            for( len = 0, tmpMdl = Mdl; tmpMdl != NULL; tmpMdl = tmpMdl->Next ) {
                len += MmGetMdlByteCount( tmpMdl );
            }

            SmbPutUshort( &Smb->Pid, (USHORT)len );
        }
    }
#endif

    //
    // If we are doing security signatures, we need to sign this packet
    //
    if( sendLength &&
        WorkContext->Connection &&
        WorkContext->Connection->SmbSecuritySignatureActive == TRUE &&
        WorkContext->NoResponseSmbSecuritySignature == FALSE ) {

        SrvAddSmbSecuritySignature( WorkContext, Mdl, sendLength );
    }

    //
    // Pass the request to the transport provider.
    //
    IF_DEBUG(TRACE2) {
        KdPrint(( "SrvStartSend posting Send IRP %p\n", irp ));
    }

    WorkContext->Irp->Cancel = FALSE;

    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( WorkContext->Endpoint->FastTdiSend ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        irpSp->MinorFunction = TDI_DIRECT_SEND;
        IoSetNextIrpStackLocation( irp );
        WorkContext->Endpoint->FastTdiSend( deviceObject, irp );

    } else {

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend complete\n" ));
    return;

} // SrvStartSend

VOID
SrvStartSend2 (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    )

/*++

Routine Description:

    This function starts a Send request.  It is started as an
    asynchronous I/O request.  When the Send completes, it is delivered
    via the I/O completion routine to the server FSD, which routes it to
    the specified FsdRestartRoutine.  (This may be
    SrvQueueWorkToFspAtDpcLevel, which queues the work item to the FSP
    at the FspRestartRoutine.)

    Partial sends and chained sends are supported.  A partial send is one
    that is not the last segment of a "message" or "record".  A chained
    send is one made up of multiple virtually discontiguous buffers.

    ** This is identical to SrvStartSend except that the parameter mdl
    is assumed to be ResponseBuffer->Mdl and sendOptions is assumed to be
    0 **

Arguments:

    WorkContext - Supplies a pointer to a Work Context block.  The
        following fields of this structure must be valid:

            TdiRequest
            Irp (optional; actual address copied here)
            Endpoint
                Endpoint->FileObject
                Endpoint->DeviceObject
            Connection
                Connection->ConnectionId

Return Value:

    None.

--*/

{
    PTDI_REQUEST_KERNEL_SEND parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;

    PMDL mdl = WorkContext->ResponseBuffer->Mdl;
    ULONG sendLength = WorkContext->ResponseBuffer->DataLength;

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend2 entered\n" ));

    ASSERT( !WorkContext->Endpoint->IsConnectionless );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Get the irp, device, and file objects
    //

    irp = WorkContext->Irp;
    deviceObject = WorkContext->Connection->DeviceObject;
    fileObject = WorkContext->Connection->FileObject;

    CHECKIRP( irp );

    if( irp->AssociatedIrp.SystemBuffer &&
        (irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( irp->AssociatedIrp.SystemBuffer );
        irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    parameters = (PTDI_REQUEST_KERNEL_SEND)&irpSp->Parameters;
    parameters->SendFlags = 0;
    parameters->SendLength = sendLength;

    //
    // For these two cases, InputBuffer is the buffered I/O "system
    // buffer".  Build an MDL for either read or write access,
    // depending on the method, for the output buffer.
    //

    irp->MdlAddress = mdl;

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

#if DBG
    if( sendLength >= sizeof( SMB_HEADER ) && sendLength <= 0xffff && mdl ) {

        PSMB_HEADER Smb = MmGetSystemAddressForMdl( mdl );

        if ( SmbGetAlignedUlong( (PULONG)Smb->Protocol ) == SMB_HEADER_PROTOCOL ) {

            ULONG len;
            PMDL tmpMdl;

            //
            // For debugging purposes, put extra data in the response smb. This
            // will help us figure out what went wrong if the client detects an
            // SMB format error
            //

            //
            // Put the send length in PidHigh
            //
            SmbPutUshort( &Smb->PidHigh, (USHORT)sendLength );

            //
            // Put the overall MDL length in Pid.  The transport is only supposed
            // to transmit SendLength -- so this will help us figure out if the
            // transport is sending too much data.
            //
            for( len = 0, tmpMdl = mdl; tmpMdl != NULL; tmpMdl = tmpMdl->Next ) {
                len += MmGetMdlByteCount( tmpMdl );
            }

            SmbPutUshort( &Smb->Pid, (USHORT)len );
        }
    }
#endif

    //
    // If we are doing security signatures, we need to sign this packet
    //
    if( sendLength &&
        WorkContext->Connection &&
        WorkContext->Connection->SmbSecuritySignatureActive == TRUE &&
        WorkContext->NoResponseSmbSecuritySignature == FALSE ) {

        SrvAddSmbSecuritySignature( WorkContext, mdl, sendLength );
    }

    //
    // Pass the request to the transport provider.
    //

    IF_DEBUG(TRACE2) {
        KdPrint(( "SrvStartSend2 posting Send IRP %p\n", irp ));
    }

    WorkContext->Irp->Cancel = FALSE;

    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( WorkContext->Endpoint->FastTdiSend ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        irpSp->MinorFunction = TDI_DIRECT_SEND;
        IoSetNextIrpStackLocation( irp );
        WorkContext->Endpoint->FastTdiSend( deviceObject, irp );

    } else {

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend2 complete\n" ));
    return;

} // SrvStartSend2

ULONG
GetIpxMaxBufferSize(
    PENDPOINT Endpoint,
    ULONG AdapterNumber,
    ULONG DefaultMaxBufferSize
    )

/*++

Routine Description:

    This routine computes the max buffer size the server negotiates
    with the client.  It takes the smaller of DefaultMaxBufferSize
    and the max packet length returned by the ipx transport.

Arguments:

    Endpoint - pointer to the endpoint corresponding to the ipx transport
    AdapterNumber - the adapter number for which the max buffer size is to
        be computed for.
    DefaultMaxBufferSize - the maximum size that can be returned by this
        routine.

Return Value:

    The max buffer size to be negotiated by the server.

--*/

{
    NTSTATUS status;
    ULONG maxBufferSize;
    PNWLINK_ACTION action;
    PIPX_ADDRESS_DATA ipxAddressData;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1];

    PAGED_CODE( );

    action = (PNWLINK_ACTION)buffer;

    //
    // Verify that the adapter number is within bounds
    //

    if ( AdapterNumber > Endpoint->MaxAdapters ) {
        return DefaultMaxBufferSize;
    }

    //
    // If value in array is non-zero, then this is not a wan link.
    // Use that value.
    //

    if ( Endpoint->IpxMaxPacketSizeArray[AdapterNumber-1] != 0 ) {

        maxBufferSize = MIN(
            Endpoint->IpxMaxPacketSizeArray[AdapterNumber-1],
            DefaultMaxBufferSize
            );

        return (maxBufferSize & ~3);
    }

    //
    // This is a wan link, query the max packet size.
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(IPX_ADDRESS_DATA);
    action->Option = MIPX_GETCARDINFO2;
    ipxAddressData = (PIPX_ADDRESS_DATA)action->Data;

    ipxAddressData->adapternum = AdapterNumber - 1;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1
                );

    if ( !NT_SUCCESS(status) ) {
        return DefaultMaxBufferSize;
    }

    ASSERT( ipxAddressData->wan );

    maxBufferSize = MIN(
        (ULONG)ipxAddressData->maxpkt,
        DefaultMaxBufferSize
        );

    return (maxBufferSize & ~3);

} // GetMaxIpxPacketSize


VOID
SrvpNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList)

/*++

Routine Description:

    This routine should not be part of srv. It has been introduced into this
    component to overcome current limitations in NetBt. The NetBt transport
    exposes two  kinds of devices -- the traditional NetBt device and the
    new non Netbios device which make use of the NetBt framing code without the
    name resolution aspects of it. The current implementation in NetBt exposes
    the former devices on a per adapter basis while the second category of device
    is exposed on a global basis ( one for all the adapters ). This poses
    problems in disabling/enabling srv on a given adapter.

    The correct solution is to expose the second category of devices on a per
    adapter basis. Till it is done this workaround is reqd. With this workaround
    whenever the server is notified of any changes to the binding string it turns
    around and notifies the NetBt transport about these changes.

    This routine is based upon the following assumptions ...

        1) The notification from TDI is not done at raised IRQL.

        2) The thread on which this notification occurs has enough access rights.

        3) The notification to NetBt is done asynchronously with srv's reaction
        to the change. The srv handles the PNP notification by passing it off to
        user mode and have it come through the server service.

Arguments:

    PNPOpcode - the PNP opcode

    DeviceName - the transport for which this opcode is intended

    MultiSZBindList - the binding list

Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE            NetbioslessSmbHandle;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    NetbioslessSmbName = {36,36, L"\\device\\NetbiosSmb"};

    InitializeObjectAttributes(
        &ObjectAttributes,
        &NetbioslessSmbName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = ZwCreateFile (
                 &NetbioslessSmbHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &ObjectAttributes,     // object attributes
                 &IoStatusBlock,        // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 NULL,                  // EA buffer
                 0                      // EA length
                 );

    if ( NT_SUCCESS(Status) ) {
        NETBT_SMB_BIND_REQUEST      NetBtNotificationParameters;

        NetBtNotificationParameters.RequestType = SMB_SERVER;
        NetBtNotificationParameters.PnPOpCode   = PnPOpcode;
        NetBtNotificationParameters.pDeviceName = DeviceName;
        NetBtNotificationParameters.MultiSZBindList = MultiSZBindList;

        Status = ZwDeviceIoControlFile(
                     NetbioslessSmbHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO,
                     &NetBtNotificationParameters,
                     sizeof(NetBtNotificationParameters),
                     NULL,
                     0);

        IF_DEBUG( ERRORS ) {
            KdPrint(("NtFsControlFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }

        Status = ZwClose(NetbioslessSmbHandle);

        IF_DEBUG( ERRORS ) {
            KdPrint(("NtCloseFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }
    } else {
        IF_DEBUG( ERRORS ) {
            KdPrint(("NtCreateFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\open.c ===
/*++

Copyright (c) 1989  Microsoft Corporation


Module Name:

    open.c

Abstract:

    This module contains the routine called by processing routines for
    the various flavors of Open SMBs (SrvCreateFile) and its
    subroutines.

    !!! Need to use SrvEnableFcbOpens to determine whether to fold FCB
        opens together.

Author:

    David Treadwell (davidtr) 23-Nov-1989
    Chuck Lenzmeier (chuckl)
    Manny Weiser (mannyw)

Revision History:

--*/

#include "precomp.h"
#include "open.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_OPEN

//
// Local functions
//

NTSTATUS
DoNormalOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    );

NTSTATUS
DoCompatibilityOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    );


NTSTATUS
DoFcbOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

NTSTATUS
DoCommDeviceOpen (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbOpenFunction,
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

PTABLE_ENTRY
FindAndClaimFileTableEntry (
    IN PCONNECTION Connection,
    OUT PSHORT FidIndex
    );

NTSTATUS
CompleteOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    IN PLFCB ExistingLfcb OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN PACCESS_MASK RemoteGrantedAccess OPTIONAL,
    IN ULONG ShareAccess,
    IN ULONG FileMode,
    IN BOOLEAN CompatibilityOpen,
    IN BOOLEAN FcbOpen,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

BOOLEAN SRVFASTCALL
MapCompatibilityOpen(
    IN PUNICODE_STRING FileName,
    IN OUT PUSHORT SmbDesiredAccess
    );

NTSTATUS SRVFASTCALL
MapDesiredAccess(
    IN USHORT SmbDesiredAccess,
    OUT PACCESS_MASK NtDesiredAccess
    );

NTSTATUS SRVFASTCALL
MapOpenFunction(
    IN USHORT SmbOpenFunction,
    OUT PULONG CreateDisposition
    );

NTSTATUS SRVFASTCALL
MapShareAccess(
    IN USHORT SmbDesiredAccess,
    OUT PULONG NtShareAccess
    );

NTSTATUS SRVFASTCALL
MapCacheHints(
    IN USHORT SmbDesiredAccess,
    IN OUT PULONG NtCreateFlags
    );

BOOLEAN
SetDefaultPipeMode (
    IN HANDLE FileHandle
    );

NTSTATUS
RemapPipeName(
    IN PANSI_STRING AnsiServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    IN OUT PUNICODE_STRING NewRelativeName,
    OUT PBOOLEAN Remapped
    );

BOOLEAN
SrvFailMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SrvFailPrepareMdlWriteDev(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, RemapPipeName )
#pragma alloc_text( PAGE, SrvCreateFile )
#pragma alloc_text( PAGE, DoNormalOpen )
#pragma alloc_text( PAGE, DoCompatibilityOpen )
#pragma alloc_text( PAGE, DoFcbOpen )
#pragma alloc_text( PAGE, CompleteOpen )
#pragma alloc_text( PAGE, MapCompatibilityOpen )
#pragma alloc_text( PAGE, MapDesiredAccess )
#pragma alloc_text( PAGE, MapOpenFunction )
#pragma alloc_text( PAGE, MapCacheHints )
#pragma alloc_text( PAGE, MapShareAccess )
#pragma alloc_text( PAGE, SrvNtCreateFile )
#pragma alloc_text( PAGE, SetDefaultPipeMode )
#pragma alloc_text( PAGE8FIL, FindAndClaimFileTableEntry )
#pragma alloc_text( PAGE, SrvFailMdlReadDev )
#pragma alloc_text( PAGE, SrvFailPrepareMdlWriteDev )
#endif


NTSTATUS
RemapPipeName(
    IN PANSI_STRING AnsiServerName,
    IN PUNICODE_STRING UnicodeName,
    IN OUT PUNICODE_STRING NewRelativeName,
    OUT PBOOLEAN Remapped
    )

/*++

Routine Description:

    Remaps a pipe name by prepending "$$\<AnsiServerName>\" to the
    relative pipe name (without the trailing spaces in AnsiServerName).

Arguments:

    AnsiServerName - NetBIOS server name, or
    UnicodeName - UNICODE server name

    NewRelativeName - pointer to pipe name; on successful return,
    points to newly allocated memory for remapped pipe name.
    This memory must be freed by the caller.

    Remapped - set to TRUE if the name was remapped

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    UNICODE_STRING OldRelativeName;
    UNICODE_STRING UnicodeServerName;
    ULONG nameLength;
    PWCH nextLocation;
    NTSTATUS status;
    int i;

    PAGED_CODE();

    *Remapped = FALSE;

    //
    // Do not remap  the pipe name if it is in our SrvNoRemapPipeNames list
    //
    ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

    for ( i = 0; SrvNoRemapPipeNames[i] != NULL ; i++ ) {

        UNICODE_STRING NoRemap;

        RtlInitUnicodeString( &NoRemap, SrvNoRemapPipeNames[i] );

        if( RtlCompareUnicodeString( &NoRemap, NewRelativeName, TRUE ) == 0 ) {

            //
            // This is a pipe name that we are not supposed to remap.  We
            //  return STATUS_SUCCESS, but indicate to our caller that we did
            //  not remap the pipe name
            //
            RELEASE_LOCK( &SrvConfigurationLock );
            return STATUS_SUCCESS;
        }
    }

    RELEASE_LOCK( &SrvConfigurationLock );

    //
    // Save RelativeName before changing it to point to new memory.
    //

    OldRelativeName = *NewRelativeName;

    //
    // Trim the trailing spaces from the server name.
    // We know that the last character is a space,
    // because server name is a netbios name.
    //

    if( !ARGUMENT_PRESENT( UnicodeName ) ) {

        USHORT SavedLength;

        ASSERT(AnsiServerName->Length == 16);
        ASSERT(AnsiServerName->Buffer[AnsiServerName->Length - 1] == ' ');

        SavedLength = AnsiServerName->Length;

        while (AnsiServerName->Length > 0 &&
           AnsiServerName->Buffer[AnsiServerName->Length - 1] == ' ') {

            AnsiServerName->Length--;
        }

        //
        // Convert the server name from ANSI to Unicode.
        //
        status = RtlAnsiStringToUnicodeString(
                        &UnicodeServerName,
                        AnsiServerName,
                        TRUE);

        AnsiServerName->Length = SavedLength;

        if (! NT_SUCCESS(status)) {
            return status;
        }

    } else {

        UnicodeServerName = *UnicodeName;

    }

    //
    // Allocate space for new relative name ("$$\server\oldrelative").
    // Start by calculating the string length, and then add one more WCHAR
    // for zero-termination.
    //

    nameLength =  (sizeof(L'$') +
                   sizeof(L'$') +
                   sizeof(L'\\') +
                   UnicodeServerName.Length +
                   sizeof(L'\\') +
                   OldRelativeName.Length);

    NewRelativeName->Length = (USHORT)nameLength;

    if( NewRelativeName->Length != nameLength ) {

        //
        // Oh no -- string length overflow!
        //

        if( !ARGUMENT_PRESENT( UnicodeName ) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
        }

        return STATUS_INVALID_PARAMETER;
    }

    NewRelativeName->MaximumLength =
    NewRelativeName->Length + sizeof(L'\0');

    NewRelativeName->Buffer =
        ALLOCATE_HEAP_COLD(NewRelativeName->MaximumLength, BlockTypeDataBuffer);

    if (NewRelativeName->Buffer == NULL) {

        if( !ARGUMENT_PRESENT( UnicodeName ) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
        }

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    RtlZeroMemory(NewRelativeName->Buffer, NewRelativeName->MaximumLength);

    nextLocation = NewRelativeName->Buffer;

    //
    // Copy strings and characters to new relative name.
    //
    *nextLocation++ = L'$';
    *nextLocation++ = L'$';
    *nextLocation++ = L'\\';

    RtlCopyMemory(
        nextLocation,
        UnicodeServerName.Buffer,
        UnicodeServerName.Length
        );

    nextLocation += (UnicodeServerName.Length / sizeof(WCHAR));

    *nextLocation++ = L'\\';

    RtlCopyMemory(
        nextLocation,
        OldRelativeName.Buffer,
        OldRelativeName.Length
        );

    if( !ARGUMENT_PRESENT( UnicodeName ) ) {
        //
        // Free UnicodeServerName.
        //
        RtlFreeUnicodeString(&UnicodeServerName);
    }

    *Remapped = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
SrvCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PCHAR SmbFileName,
    IN PCHAR EndOfSmbFileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    )

/*++

Routine Description:

    Does most of the operations necessary to open or create a file.
    First the UID and TID are verified and the corresponding session and
    tree connect blocks located.  The input file name name is
    canonicalized, and a fully qualified name is formed.  An appropriate
    subroutine is called to do the open, based on whether this is a
    normal, compatibility mode, or FCB open.

Arguments:

    WorkContext - Work context block for the operation.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    SmbFileName - A pointer to the zero-terminated file name in the
        request SMB.  NOTE:  This pointer should NOT point to the ASCII
        format indicator (\004) present in some SMBs!

    EndOfSmbFileName - a pointer to the last possible character that
        the file name can be in.  If the name extands beyond this location
        without a zero terminator, SrvCanonicalizePathName will fail.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;

    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PRFCB rfcb;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    UNICODE_STRING relativeName;
    UNICODE_STRING pipeRelativeName;
    BOOLEAN pipeRelativeNameAllocated = FALSE;
    UNICODE_STRING fullName;
    SHARE_TYPE shareType;

    ULONG error;
    ULONG jobId;

    ULONG hashValue;

    ULONG attributes;
    ULONG openRetries;
    BOOLEAN isUnicode;
    BOOLEAN caseInsensitive;

    PSRV_LOCK mfcbLock = NULL;

    //
    // NOTE ON MFCB REFERENCE COUNT HANDLING
    //
    // After finding or creating an MFCB for a file, we increment the
    // MFCB reference count an extra time to simplify our
    // synchronization logic. We hold the MfcbListLock lock while
    // finding/creating the MFCB, but release it after acquiring the the
    // per-MFCB lock.  We then call one of the DoXxxOpen routines, which
    // may need to queue an LFCB to the MFCB and thus need to increment
    // the count.  But they can't, because the MFCB list lock may not be
    // acquired while the per-MFCB lock is held because of deadlock
    // potential.  The boolean LfcbAddedToMfcbList returned from the
    // routines indicates whether they actually queued an LFCB to the
    // MFCB.  If they didn't, we need to release the extra reference.
    //
    // Note that it isn't often that we actually have to dereference the
    // MFCB.  This only occurs when 1) the open fails, or 2) a
    // compatibility mode or FCB open succeeds when the client already
    // has the file open.
    //

    BOOLEAN lfcbAddedToMfcbList;

    PAGED_CODE( );

    //
    // Assume we won't need a temporary open.
    //

    WorkContext->Parameters2.Open.TemporaryOpen = FALSE;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find the tree connect corresponding to the given TID if a tree
    // connect pointer has not already been put in the WorkContext block
    // by an AndX command or a previous call to SrvCreateFile.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvCreateFile: Invalid UID or TID\n" ));
        }
        return status;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        return SESSION_EXPIRED_STATUS_CODE;
    }

    //
    // Decide if we're case sensitive or not
    //
    caseInsensitive = (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
                          session->UsingUppercasePaths;

    //
    // Here we begin share type specific processing.
    //

    shareType = treeConnect->Share->ShareType;

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    // Note that a disk open will block if the file is currently oplocked.
    //

    if ( shareType == ShareTypeDisk && !WorkContext->BlockingOperation ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;
            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            return STATUS_INSUFF_SERVER_RESOURCES;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    isUnicode = SMB_IS_UNICODE( WorkContext );

    switch ( shareType ) {

    case ShareTypePrint:

        //
        // Allocate space to hold the file name we're going to open.
        //

        fullName.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
        fullName.Buffer = ALLOCATE_HEAP_COLD(
                                  fullName.MaximumLength,
                                  BlockTypeDataBuffer
                                  );
        if ( fullName.Buffer == NULL ) {
            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        //
        // Get a print file name to use for spooling the request.
        // We open this as a disk file, use normal writes to get the
        // data, then call ScheduleJob( ) in XACTSRV to start the
        // actual printing process.
        //

        status = SrvAddPrintJob(
                     WorkContext,
                     WorkContext->TreeConnect->Share->Type.hPrinter,
                     &fullName,
                     &jobId,
                     &error
                     );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvCreateFile: SrvAddPrintJob failed: %lx (%ld)\n",
                              status, error ));
            }
            FREE_HEAP( fullName.Buffer );
            if ( error != NO_ERROR ) {
                ASSERT( SrvErrorCode(error) == error );
                status = (NTSTATUS)(SRV_WIN32_STATUS | error);
            }
            return status;
        }

        //
        // Scan the Master File Table to see if the named file is already
        // open.
        //
        mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

        if ( mfcb == NULL ) {

            //
            // There is no MFCB for this file.  Create one.
            //

            mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

            if ( mfcb == NULL ) {

                //
                // Failure to add open file instance to MFT.
                //

                if( mfcbLock ) {
                    RELEASE_LOCK( mfcbLock );
                }

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvCreateFile: Unable to allocate MFCB\n" ));
                }

                FREE_HEAP( fullName.Buffer );

                //
                // Free up the Job ID.
                //

                SrvSchedulePrintJob(
                    WorkContext->TreeConnect->Share->Type.hPrinter,
                    jobId
                    );

                return STATUS_INSUFF_SERVER_RESOURCES;
            }

        }


        //
        // Increment the MFCB reference count. See the note at the beginning of this routine.
        //

        mfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

        //
        // Grab the MFCB-based lock to serialize opens of the same file
        // and release the MFCB list lock.
        //

        nonpagedMfcb = mfcb->NonpagedMfcb;

        if( mfcbLock ) {
            RELEASE_LOCK( mfcbLock );
        }

        ACQUIRE_LOCK( &nonpagedMfcb->Lock );

        //
        // Set up the share access and desired access in SMB terms.
        // We will only write to the file, so just request write
        // as the desired access.  As an optimization, the spooler
        // may read from the file before we finish writing to it,
        // so allow other readers.
        //

        SmbDesiredAccess = SMB_DA_ACCESS_WRITE | SMB_DA_SHARE_DENY_WRITE | SMB_LR_SEQUENTIAL;

        //
        // Set up the open function to create the file it it doesn't
        // exist and to truncate it if it does exist.  There shouldn't
        // be preexisting data in the file, hence the truncation.
        //
        // !!! The spooler may change to create the file for us, in which
        //     case this should change to only truncate.

        SmbOpenFunction = SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_TRUNCATE;

        //
        // This is a normal sharing mode open.  Do the actual open
        // of the disk file.
        //

        status = DoNormalOpen(
                    &rfcb,
                    mfcb,
                    WorkContext,
                    &WorkContext->Irp->IoStatus,
                    SmbDesiredAccess,
                    SmbFileAttributes,
                    SmbOpenFunction,
                    SmbAllocationSize,
                    &fullName,
                    NULL,
                    0,
                    0,
                    &lfcbAddedToMfcbList,
                    RequestedOplockType
                    );

        //
        // If the open worked, set up the Job ID in the LFCB.
        //

        if ( NT_SUCCESS(status) ) {

            rfcb->Lfcb->JobId = jobId;

        } else {

            //
            // Free up the Job ID if the open failed.
            //

            SrvSchedulePrintJob(
                WorkContext->TreeConnect->Share->Type.hPrinter,
                jobId
                );
        }

        //
        // Release the Open serialization lock and dereference the MFCB.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // If DoNormalOpen didn't queue an LFCB to the MFCB, release the
        // extra reference that we added.
        //

        if ( !lfcbAddedToMfcbList ) {
            SrvDereferenceMfcb( mfcb );
        }

        SrvDereferenceMfcb( mfcb );

        //
        // Deallocate the full path name buffer.
        //

        FREE_HEAP( fullName.Buffer );

        break;

    case ShareTypeDisk:
    case ShareTypePipe:

        //
        // Canonicalize the path name so that it conforms to NT
        // standards.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        status = SrvCanonicalizePathName(
                WorkContext,
                treeConnect->Share,
                NULL,
                SmbFileName,
                EndOfSmbFileName,
                TRUE,
                isUnicode,
                &relativeName
                );

        if( !NT_SUCCESS( status ) ) {

            //
            // The path tried to do ..\ to get beyond the share it has
            // accessed.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvCreateFile: Invalid pathname: %s\n",
                            SmbFileName ));
            }

            return status;

        }

        //
        // Form the fully qualified name of the file.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        if ( shareType == ShareTypeDisk ) {

            SrvAllocateAndBuildPathName(
                &treeConnect->Share->DosPathName,
                &relativeName,
                NULL,
                &fullName
                );

        } else {

            UNICODE_STRING pipePrefix;

            RtlInitUnicodeString( &pipePrefix, StrSlashPipeSlash );

            //
            // Check for PIPE pathname prefix.
            //

            if ( !RtlPrefixUnicodeString(
                    &SrvCanonicalNamedPipePrefix,
                    &relativeName,
                    TRUE
                    ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvCreateFile: Invalid pipe pathname: %s\n",
                        SmbFileName ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &relativeName );
                }

                return STATUS_OBJECT_PATH_SYNTAX_BAD;
            }

            //
            // Delete PIPE\ prefix from file path
            //

            pipeRelativeName.Buffer = (PWSTR)( (PCHAR)relativeName.Buffer +
                SrvCanonicalNamedPipePrefix.Length );
            pipeRelativeName.Length = relativeName.Length -
                SrvCanonicalNamedPipePrefix.Length;
            pipeRelativeName.MaximumLength = pipeRelativeName.Length;

            if( WorkContext->Endpoint->RemapPipeNames || treeConnect->RemapPipeNames ) {

                //
                // The RemapPipeNames flag is set, so remap the pipe name
                //  to "$$\<server>\<pipe name>".
                //
                // Note: this operation allocates space for pipeRelativeName.
                //
                status = RemapPipeName(
                            &WorkContext->Endpoint->TransportAddress,
                            treeConnect->RemapPipeNames ? &treeConnect->ServerName : NULL ,
                            &pipeRelativeName,
                            &pipeRelativeNameAllocated
                         );

                if( !NT_SUCCESS( status ) ) {
                    if ( !isUnicode ) {
                        RtlFreeUnicodeString( &relativeName );
                    }
                    return status;
                }
            }

            SrvAllocateAndBuildPathName(
                &pipePrefix,
                &pipeRelativeName,
                NULL,
                &fullName
                );

            //
            // If this is a compatibility mode or FCB mode open, map
            // it to a normal non-shared open.
            //

            if ( SmbDesiredAccess == SMB_DA_FCB_MASK  ||
                 (SmbDesiredAccess & SMB_DA_SHARE_MASK) ==
                                            SMB_DA_SHARE_COMPATIBILITY ) {

                SmbDesiredAccess = SMB_DA_ACCESS_READ_WRITE |
                                   SMB_DA_SHARE_EXCLUSIVE;
            }

        }

        if ( fullName.Buffer == NULL ) {

            //
            // Unable to allocate heap for the full name.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvCreateFile: Unable to allocate heap for "
                            "full path name\n" ));
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &relativeName );
            }

            if( pipeRelativeNameAllocated ) {
                FREE_HEAP( pipeRelativeName.Buffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        attributes = caseInsensitive ? OBJ_CASE_INSENSITIVE : 0;

        if ( WorkContext->ProcessingCount == 2) {

            HANDLE fileHandle;
            OBJECT_ATTRIBUTES objectAttributes;
            IO_STATUS_BLOCK ioStatusBlock;

            //
            // This is the second time through, so we must be in a blocking
            // thread.  Do a blocking open of the file to force an oplock
            // break.  Then close the handle and fall through to the normal
            // open path.
            //
            // We must do the blocking open without holding the MFCB
            // lock, because this lock can be acquired during oplock
            // break, resulting in deadlock.
            //

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &relativeName,
                attributes,
                NULL,
                NULL
                );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         GENERIC_READ,
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,
                         0,
                         FILE_SHARE_VALID_FLAGS,
                         FILE_OPEN,
                         0,
                         NULL,
                         0,
                         CreateFileTypeNone,
                         NULL,                    // ExtraCreateParameters
                         0,
                         WorkContext->TreeConnect->Share
                         );

            if ( NT_SUCCESS( status ) ) {
                SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 9, 0 );
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 16, 0 );
                SrvNtClose( fileHandle, TRUE );
            }

        }

        //
        // Scan the Master File Table to see if the named file is already
        // open.  We can do the scan with a shared lock, but we must have an
        // exclusive lock to modify the table.  Start out shared, assuming the
        // file is already open.
        //

        mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

        if ( mfcb == NULL ) {

            //
            // There is no MFCB for this file.  Create one.
            //

            mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

            if ( mfcb == NULL ) {

                //
                // Failure to add open file instance to MFT.
                //

                if( mfcbLock ) {
                    RELEASE_LOCK( mfcbLock );
                }

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvCreateFile: Unable to allocate MFCB\n" ));
                }

                FREE_HEAP( fullName.Buffer );

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &relativeName );
                }

                if( pipeRelativeNameAllocated ) {
                    FREE_HEAP( pipeRelativeName.Buffer );
                }

                return STATUS_INSUFF_SERVER_RESOURCES;
            }
        }

        //
        // Increment the MFCB reference count. See the note at the beginning of this routine.
        //
        mfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

        //
        // Grab the MFCB-based lock to serialize opens of the same file
        // and release the MFCB list lock.
        //
        nonpagedMfcb = mfcb->NonpagedMfcb;

        if( mfcbLock )
        {
            RELEASE_LOCK( mfcbLock );
        }

        ACQUIRE_LOCK( &nonpagedMfcb->Lock );

        //
        // Call an appropriate routine to actually do the open.
        //

        openRetries = SrvSharingViolationRetryCount;

start_retry:

        if ( SmbDesiredAccess == SMB_DA_FCB_MASK ) {

            //
            // This is an FCB open.
            //

            status = DoFcbOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList
                        );

        } else if ( (SmbDesiredAccess & SMB_DA_SHARE_MASK) ==
                                                SMB_DA_SHARE_COMPATIBILITY ) {

            //
            // This is a compatibility mode open.
            //

            status = DoCompatibilityOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbDesiredAccess,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList,
                        RequestedOplockType
                        );

        } else {

            //
            // This is a normal sharing mode open.
            //

            status = DoNormalOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbDesiredAccess,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        shareType == ShareTypePipe ?
                            &pipeRelativeName : &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList,
                        RequestedOplockType
                        );

        }

        //
        // Retry if sharing violation and we are in the blocking thread.
        //

        if ( (WorkContext->ProcessingCount == 2) &&
             (status == STATUS_SHARING_VIOLATION) &&
             (shareType == ShareTypeDisk) &&
             (openRetries-- > 0) ) {

            //
            // Release the mfcb lock so that a close might slip through.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            ACQUIRE_LOCK( &nonpagedMfcb->Lock );
            goto start_retry;
        }

        //
        // Release the Open serialization lock and dereference the MFCB.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // If DoXxxOpen didn't queue an LFCB to the MFCB, release the
        // extra reference that we added.
        //

        if ( !lfcbAddedToMfcbList ) {
            SrvDereferenceMfcb( mfcb );
        }

        SrvDereferenceMfcb( mfcb );

        //
        // Deallocate the full path name buffer.
        //

        FREE_HEAP( fullName.Buffer );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &relativeName );
        }

        break;

    //
    //  Default case, illegal device type.  This should never happen.
    //

    default:

        // !!! Is this an appropriate error return code?  Probably no.
        status = STATUS_INVALID_PARAMETER;
        rfcb = NULL;

    }

    //
    // Update the statistics database if the open was successful.
    //

    if ( NT_SUCCESS(status) ) {
        SrvStatistics.TotalFilesOpened++;
    }

    //
    // Make a pointer to the RFCB accessible to the caller.
    //

    WorkContext->Parameters2.Open.Rfcb = rfcb;

    //
    // If there is an oplock break in progress, wait for the oplock
    // break to complete.
    //

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        NTSTATUS startStatus;

        //
        // Save the Information from the open, so it doesn't
        //  get lost when we re-use the WorkContext->Irp for the
        //  oplock processing.
        //
        WorkContext->Parameters2.Open.IosbInformation = WorkContext->Irp->IoStatus.Information;

        startStatus = SrvStartWaitForOplockBreak(
                        WorkContext,
                        RestartRoutine,
                        0,
                        rfcb->Lfcb->FileObject
                        );

        if (!NT_SUCCESS( startStatus ) ) {

            //
            // The file is oplocked, and we cannot wait for the oplock
            // break to complete.  Just close the file, and return the
            // error.
            //

            SrvCloseRfcb( rfcb );
            status = startStatus;

        }

    }

    if( pipeRelativeNameAllocated ) {
        FREE_HEAP( pipeRelativeName.Buffer );
    }

    //
    // Return the open status.
    //

    return status;

} // SrvCreateFile


NTSTATUS
DoNormalOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    )

/*++

Routine Description:

    Processes a normal sharing mode open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.  FALSE, otherwise.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    HANDLE fileHandle;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG shareAccess;
    ULONG createDisposition;
    ULONG createOptions;
    ACCESS_MASK desiredAccess;
    PSHARE fileShare = NULL;

    UCHAR errorClass = SMB_ERR_CLASS_DOS;
    USHORT error = 0;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Map the desired access from SMB terms to NT terms.
    //

    status = MapDesiredAccess( SmbDesiredAccess, &desiredAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Map the share mode from SMB terms to NT terms.
    //

    status = MapShareAccess( SmbDesiredAccess, &shareAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    if ( WorkContext->TreeConnect->Share->ShareType == ShareTypePipe ) {
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeName,
            attributes,
            SrvNamedPipeHandle,
            NULL
            );
    } else {

        fileShare = WorkContext->TreeConnect->Share;

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeName,
            attributes,
            NULL,
            NULL
            );
    }

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    //
    // OS/2 expects that if it creates a file with an allocation size,
    // the end of file pointer will be the same as that allocation size.
    // Therefore, the server is expected to set EOF to the allocation
    // size on creating a file.  However, this requires write access,
    // so if the client is creating a file with an allocation size, give
    // him write access.  Only do this if creating a file; if this is
    // a "create or open" operation, don't do this, as it could cause
    // an extraneuos audit.
    //

    if ( SmbAllocationSize != 0 && createDisposition == FILE_CREATE ) {
        desiredAccess |= GENERIC_WRITE;
    }

    //
    // Set createOptions parameter.
    //

    if ( SmbDesiredAccess & SMB_DA_WRITE_THROUGH ) {
        createOptions = FILE_WRITE_THROUGH | FILE_NON_DIRECTORY_FILE;
    } else {
        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions |= FILE_NO_EA_KNOWLEDGE;
    }

    //
    // Set the caching hints flags.
    //

    status = MapCacheHints( SmbDesiredAccess, &createOptions );

    //
    // Check to see if there is a cached handle for the file.
    //

    if ( (createDisposition == FILE_OPEN) ||
         (createDisposition == FILE_CREATE) ||
         (createDisposition == FILE_OPEN_IF) ) {

        ASSERT( *LfcbAddedToMfcbList == FALSE );

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCreateFile: checking for cached rfcb for %wZ\n", RelativeName ));
        }
        if ( SrvFindCachedRfcb(
                WorkContext,
                Mfcb,
                desiredAccess,
                shareAccess,
                createDisposition,
                createOptions,
                RequestedOplockType,
                &status ) ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvCreateFile: FindCachedRfcb = TRUE, status = %x, rfcb = %p\n",
                            status, WorkContext->Rfcb ));
            }

            IoStatusBlock->Information = FILE_OPENED;

            return status;
        }

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCreateFile: FindCachedRfcb = FALSE; do it the slow way\n" ));
        }
    }

    //
    // Call SrvIoCreateFile to create or open the file.  (We call
    // SrvIoCreateFile, rather than NtOpenFile, in order to get user-mode
    // access checking.)
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoNormalOpen: Opening file %wZ\n", RelativeName ));
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        createOptions |= FILE_COMPLETE_IF_OPLOCKED;

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     shareAccess,
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     fileShare
                     );
    }

    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The open failed.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "DoNormalOpen: SrvIoCreateFile failed, file = %wZ, status = %X, Info = 0x%p\n",
                        objectAttributes.ObjectName,
                        status, (PVOID)IoStatusBlock->Information ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
            IoStatusBlock->Information = 0;
        }

        return status;

    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 10, 0 );

    //
    // The open was successful.  Attempt to allocate structures to
    // represent the open.  If any errors occur, CompleteOpen does full
    // cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoNormalOpen: Open of %wZ succeeded, file handle: 0x%p\n",
                    RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           shareAccess,
                           createOptions,
                           FALSE,
                           FALSE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoNormalOpen


NTSTATUS
DoCompatibilityOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    )

/*++

Routine Description:

    Processes a compatibility mode open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PLFCB lfcb;

    HANDLE fileHandle = NULL;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG createDisposition;
    ULONG createOptions;
    ACCESS_MASK desiredAccess;
    USHORT smbOpenMode;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Map the desired access from SMB terms to NT terms.
    //

    status = MapDesiredAccess( SmbDesiredAccess, &desiredAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createOptions parameter.
    //

    if ( SmbDesiredAccess & SMB_DA_WRITE_THROUGH ) {
        createOptions = FILE_WRITE_THROUGH | FILE_NON_DIRECTORY_FILE;
    } else {
        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions |= FILE_NO_EA_KNOWLEDGE;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        RelativeName,
        attributes,
        NULL,
        NULL
        );

    if ( Mfcb->ActiveRfcbCount > 0 ) {

        //
        // The named file is already opened by the server.  If the client
        // specified that it didn't want to open an existing file,
        // reject this open.
        //

        if ( createDisposition == FILE_CREATE ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; wants to create\n", RelativeName ));
            }

            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // If the existing open is not a compatibility mode open, then
        // we try to map the new open into a normal sharing mode.  If
        // that works, we attempt a normal open.  If it doesn't work, we
        // reject the new open.  If the existing open is a compatibility
        // mode open by this session, we just add a new RFCB.  If it's a
        // compatibility mode open by a different session, we reject
        // this open.
        //

        if ( !Mfcb->CompatibilityOpen ) {

            //
            // The named file is open, but not in compatibility mode.
            // Determine whether this should be mapped from a
            // compatibility mode open to a normal sharing mode open.
            //

            smbOpenMode = SmbDesiredAccess;

            if ( MapCompatibilityOpen( RelativeName, &smbOpenMode ) ) {

                //
                // The open has been mapped to a normal sharing mode.
                //

                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoCompatibilityOpen: Mapped compatibility open of %wZ to normal open\n", RelativeName ));
                }

                return DoNormalOpen(
                            Rfcb,
                            Mfcb,
                            WorkContext,
                            IoStatusBlock,
                            smbOpenMode,
                            SmbFileAttributes,
                            SmbOpenFunction,
                            SmbAllocationSize,
                            RelativeName,
                            EaBuffer,
                            EaLength,
                            EaErrorOffset,
                            LfcbAddedToMfcbList,
                            RequestedOplockType
                            );

            }

            //
            // The open was not mapped away from compatibility mode.
            // Because the file is already open for normal sharing, this
            // open request must be rejected.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; already open in normal mode\n",
                            RelativeName ));
            }

            status = STATUS_SHARING_VIOLATION;
            goto sharing_violation;

        } // if ( !Mfcb->CompatibilityOpen )

        //
        // The named file is open in compatibility mode.  Get a pointer
        // to the LFCB for the open.  Determine whether the requesting
        // session is the one that did the original open.
        //
        // Normally there will only be one LFCB linked to a
        // compatibility mode MFCB.  However, it is possible for there
        // to briefly be multiple LFCBs.  When an LFCB is in the process
        // of closing, the ActiveRfcbCount will be 0, so a new open will
        // be treated as the first open of the MFCB, and there will be
        // two LFCBs linked to the MFCB.  There can actually be more
        // than two LFCBs linked if the rundown of the closing LFCBs
        // takes some time.  So the find "the" LFCB for the open, we go
        // to the tail of the MFCB's list.
        //

        lfcb = CONTAINING_RECORD( Mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        if ( lfcb->Session != WorkContext->Session ) {

            //
            // A different session has the file open in compatibility
            // mode.  Reject this open request.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; already open in compatibility mode\n",
                            RelativeName ));
            }

            status = STATUS_SHARING_VIOLATION;
            goto sharing_violation;
        }

        //
        // If this request is asking for more access than could be
        // obtained when the file was originally opened, reject this
        // open.
        //

        if ( !NT_SUCCESS(IoCheckDesiredAccess(
                          &desiredAccess,
                          lfcb->GrantedAccess )) ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Duplicate compatibility open of %wZ rejected; access denied\n", RelativeName ));
            }

            return STATUS_ACCESS_DENIED;
        }

        //
        // The client has access.  Allocate a new RFCB and link it into
        // the existing LFCB.  If any errors occur, CompleteOpen does
        // full cleanup.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: Duplicate compatibility open of %wZ accepted", RelativeName ));
        }

        IoStatusBlock->Information = FILE_OPENED;

        status = CompleteOpen(
                    Rfcb,
                    Mfcb,
                    WorkContext,
                    lfcb,
                    NULL,
                    &desiredAccess,
                    0,                  // ShareAccess
                    createOptions,
                    TRUE,
                    FALSE,
                    LfcbAddedToMfcbList
                    );

        if( NT_SUCCESS( status ) &&
            ( createDisposition == FILE_OVERWRITE ||
              createDisposition == FILE_OVERWRITE_IF)
        ) {
            //
            // The file was successfully opened, and the client wants it
            //  truncated. We need to do it here by hand since we
            //  didn't actually call the filesystem to open the file and it
            //  therefore never had a chance to truncate the file if the
            //  open modes requested it.
            //
            LARGE_INTEGER zero;
            IO_STATUS_BLOCK ioStatusBlock;

            zero.QuadPart = 0;
            NtSetInformationFile( lfcb->FileHandle,
                                  &ioStatusBlock,
                                  &zero,
                                  sizeof( zero ),
                                  FileEndOfFileInformation
                                 );
        }

        return status;

    } // if ( mfcb->ActiveRfcbCount > 0 )

    //
    // The file is not already open (by the server, at least).
    // Determine whether this should be mapped from a compatibility mode
    // open to a normal sharing mode open.
    //

    smbOpenMode = SmbDesiredAccess;

    if ( MapCompatibilityOpen( RelativeName, &smbOpenMode ) ) {

        //
        // The open has been mapped to a normal sharing mode.
        //

        return DoNormalOpen(
                    Rfcb,
                    Mfcb,
                    WorkContext,
                    IoStatusBlock,
                    smbOpenMode,
                    SmbFileAttributes,
                    SmbOpenFunction,
                    SmbAllocationSize,
                    RelativeName,
                    EaBuffer,
                    EaLength,
                    EaErrorOffset,
                    LfcbAddedToMfcbList,
                    RequestedOplockType
                    );

    }

    //
    // The open was not mapped away from compatibility mode.  Attempt to
    // open the file for exclusive access.
    //
    // *** We try to open the file for the most access we'll ever need.
    //     This is because we fold multiple compatibility opens by the
    //     same client into a single local open.  The client may open
    //     the file first for readonly access, then for read/write
    //     access.  Because the local open is exclusive, we can't open
    //     again on the second remote open.  We try to get Delete
    //     access, in case the client tries to delete the file while
    //     it's open.
    //

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoCompatibilityOpen: Opening file %wZ\n", RelativeName ));
    }

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Try to open the file for Read/Write/Delete access.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        createOptions |= FILE_COMPLETE_IF_OPLOCKED;

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE | DELETE,      // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                         // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                       // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );
    }


    if ( status == STATUS_ACCESS_DENIED ) {

        //
        // The client doesn't have Read/Write/Delete access to the file.
        // Try for Read/Write access.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: r/w/d access denied.\n" ));
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE,           // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                     // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                   // ExtraPipeCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );


        if ( status == STATUS_ACCESS_DENIED ) {

            //
            // The client doesn't have Read/Write access to the file.
            // Try Read or Write access, as appropriate.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: r/w access denied.\n" ));
            }

            if ( (SmbDesiredAccess & SMB_DA_ACCESS_MASK) ==
                                                    SMB_DA_ACCESS_READ ) {

                //
                // !!! Should this be mapped to a normal sharing mode?
                //     Note that we already tried to map into normal
                //     mode once, but that failed.  (With the current
                //     mapping algorithm, we can't get here unless soft
                //     compatibility is disabled.)
                //

                INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

                status = SrvIoCreateFile(
                             WorkContext,
                             &fileHandle,
                             GENERIC_READ,                   // DesiredAccess
                             &objectAttributes,
                             IoStatusBlock,
                             &allocationSize,
                             fileAttributes,
                             0L,                             // ShareAccess
                             createDisposition,
                             createOptions,
                             EaBuffer,
                             EaLength,
                             CreateFileTypeNone,
                             NULL,                           // ExtraCreateParameters
                             IO_FORCE_ACCESS_CHECK,
                             WorkContext->TreeConnect->Share
                             );

            } else if ( (SmbDesiredAccess & SMB_DA_ACCESS_MASK) ==
                                                    SMB_DA_ACCESS_WRITE ) {

                INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

                status = SrvIoCreateFile(
                             WorkContext,
                             &fileHandle,
                             GENERIC_WRITE,                  // DesiredAccess
                             &objectAttributes,
                             IoStatusBlock,
                             &allocationSize,
                             fileAttributes,
                             0L,                             // ShareAccess
                             createDisposition,
                             createOptions,
                             EaBuffer,
                             EaLength,
                             CreateFileTypeNone,
                             NULL,                           // NamedPipeCreateParameters
                             IO_FORCE_ACCESS_CHECK,
                             WorkContext->TreeConnect->Share
                             );

            }

            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

        }

    }

    //
    // If we got sharing violation, just get a handle so that we can wait
    // for an oplock break.
    //

sharing_violation:
    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // All of the open attempts failed.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: all opens failed; status = %X\n",
                        status ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                         status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
            IoStatusBlock->Information = 0;
        }

        return status;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 11, 0 );

    //
    // The file has been successfully opened for exclusive access, with
    // at least as much desired access as requested by the client.
    // Attempt to allocate structures to represent the open.  If any
    // errors occur, CompleteOpen does full cleanup, including closing
    // the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoCompatibilityOpen: Open of %wZ succeeded, file handle: 0x%p\n", RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           &desiredAccess,
                           0,               // ShareAccess
                           createOptions,
                           TRUE,
                           FALSE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoCompatibilityOpen


NTSTATUS
DoFcbOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList
    )

/*++

Routine Description:

    Processes an FCB open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PLIST_ENTRY lfcbEntry;
    PLIST_ENTRY rfcbEntry;

    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;
    PLFCB lfcb;

    HANDLE fileHandle;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG createOptions;
    ULONG createDisposition;
    ULONG shareAccess;
    BOOLEAN compatibilityOpen;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createOptions parameter.
    //

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions = FILE_NON_DIRECTORY_FILE |
                        FILE_NO_EA_KNOWLEDGE;
    } else {

        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        RelativeName,
        attributes,
        NULL,
        NULL
        );

    createOptions |= FILE_COMPLETE_IF_OPLOCKED;

    if ( Mfcb->ActiveRfcbCount > 0 ) {

        //
        // The named file is already open by the server.  If the client
        // specified that it didn't want to open an existing file,
        // reject this open.
        //

        if ( createDisposition == FILE_CREATE ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: FCB open of %wZ rejected; wants to create\n", RelativeName ));
            }

            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // If the requesting session already has the file open in FCB
        // mode, fold this open into the existing open by returning a
        // pointer to the existing RFCB.
        //
        // *** Multiple FCB opens are folded together because the client
        //     may send only one close; that single close closes all FCB
        //     opens by the client.
        //

        for ( lfcbEntry = Mfcb->LfcbList.Flink;
              lfcbEntry != &Mfcb->LfcbList;
              lfcbEntry = lfcbEntry->Flink ) {

            lfcb = CONTAINING_RECORD( lfcbEntry, LFCB, MfcbListEntry );

            if ( lfcb->Session == WorkContext->Session ) {

                //
                // This LFCB is owned by the requesting session.  Check
                // for RFCBs opened in FCB mode.
                //

                for ( rfcbEntry = lfcb->RfcbList.Flink;
                      rfcbEntry != &lfcb->RfcbList;
                      rfcbEntry = rfcbEntry->Flink ) {

                    pagedRfcb = CONTAINING_RECORD(
                                            rfcbEntry,
                                            PAGED_RFCB,
                                            LfcbListEntry
                                            );

                    rfcb = pagedRfcb->PagedHeader.NonPagedBlock;
                    if ( (pagedRfcb->FcbOpenCount != 0) &&
                         (GET_BLOCK_STATE(rfcb) == BlockStateActive) ) {

                        //
                        // The requesting session already has the file
                        // open in FCB mode.  Rather than reopening the
                        // file, or even linking a new RFCB off the
                        // LFCB, we just return a pointer to the
                        // existing RFCB.
                        //

                        IF_SMB_DEBUG(OPEN_CLOSE2) {
                            KdPrint(( "DoFcbOpen: FCB open of %wZ accepted; duplicates FCB open\n", RelativeName ));
                        }

                        SrvReferenceRfcb( rfcb );

                        pagedRfcb->FcbOpenCount++;

                        IoStatusBlock->Information = FILE_OPENED;

                        WorkContext->Rfcb = rfcb;
                        *Rfcb = rfcb;

                        return STATUS_SUCCESS;

                    } // if ( rfcb->FcbOpenCount != 0 )

                } // for ( rfcbEntry = lfcb->RfcbList.Flink; ...

            } // if ( lfcb->Session == WorkContext->Session )

        } // for ( lfcbEntry = mfcb->LfcbList.Flink; ...

        //
        // The server has the file open, but the requesting session
        // doesn't already have an FCB open for the file.  If the
        // existing open is a compatibility mode open open by this
        // session, we just add a new RFCB.  If it's a compatibility
        // mode open by a different session, we reject this open.
        //

        if ( Mfcb->CompatibilityOpen ) {

            //
            // The named file is open in compatibility mode.  Get a
            // pointer to the LFCB for the open.  Determine whether the
            // requesting session is the one that did the original open.
            //
            // Normally there will only be one LFCB linked to a
            // compatibility mode MFCB.  However, it is possible for
            // there to briefly be multiple LFCBs.  When an LFCB is in
            // the process of closing, the ActiveRfcbCount will be 0, so
            // a new open will be treated as the first open of the MFCB,
            // and there will be two LFCBs linked to the MFCB.  There
            // can actually be more than two LFCBs linked if the rundown
            // of the closing LFCBs takes some time.  So the find "the"
            // LFCB for the open, we go to the tail of the MFCB's list.
            //

            lfcb = CONTAINING_RECORD( Mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

            if ( lfcb->Session != WorkContext->Session ) {

                //
                // A different session has the file open in
                // compatibility mode.  Reject this open request.
                //

                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoFcbOpen: FCB open of %wZ rejected; already open in compatibility mode\n",
                                RelativeName ));
                }

                return STATUS_SHARING_VIOLATION;
            }

            //
            // The same client has the file open in compatibility mode.
            // Allocate a new RFCB and link it into the existing LFCB.
            // If any errors occur, CompleteOpen does full cleanup.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: FCB open of %wZ accepted; duplicates compatibility open\n", RelativeName ));
            }

            IoStatusBlock->Information = FILE_OPENED;

            status = CompleteOpen(
                        Rfcb,
                        Mfcb,
                        WorkContext,
                        lfcb,
                        NULL,
                        NULL,
                        0,          // ShareAccess
                        0,
                        TRUE,
                        TRUE,
                        LfcbAddedToMfcbList
                        );

            return status;

        } // if ( mfcb->CompatibilityOpen )

    } // if ( mfcb->ActiveRfcbCount > 0 )

    //
    // Either the file is not already open by the server, or it's open
    // for normal sharing, and not in FCB mode by this session.  Because
    // we're supposed to give the client maximum access to the file, we
    // do the following:
    //
    // 1) Try to open the file for read/write/delete, exclusive access.
    //    Obviously this will fail if the file is already open.  But
    //    what we're really trying to find out is what access the client
    //    has to the file.  If this attempt fails with a sharing
    //    violation, then we know the client has write/delete access,
    //    but someone else has it open.  So we can't get compatibility
    //    mode.  Therefore, we reject the open.  On the other hand, if
    //    we get an access denied error, then we know the client can't
    //    write/delete the file, so we try again with write access.  Of
    //    course, this first open could succeed, in which case the
    //    client has the file open for read/write in compatibility mode.
    //
    // 2) Try to open the file for read/write, exclusive access.  As
    //    above, if it fails with a sharing violation, then we know the
    //    client has write access, but someone else has it open.  So we
    //    can't get compatibility mode, and we reject the open.  If we
    //    get an access denied error, then we know the client can't
    //    write the file, so we try again with readonly access.  If this
    //    open succeeds, the client has the file open for read/write in
    //    compatibility mode.
    //
    // 3) If we get here, we know the client can't write to the file,
    //    so we try to open the file for readonly, shared access.  This
    //    no longer a compatibility mode open.  If we get any kind of a
    //    failure here, we're just out of luck.
    //

    compatibilityOpen = TRUE;

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoFcbOpen: Opening file %wZ\n", RelativeName ));
    }

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Try to open the file for Read/Write/Delete access.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE | DELETE,      // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                         // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                       // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );
    }


    if ( status == STATUS_ACCESS_DENIED ) {

        //
        // The client doesn't have Read/Write/Delete access to the file.
        // Try for Read/Write access.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoFcbOpen: r/w/d access denied.\n" ));
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE,           // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                     // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                   // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );


        if ( status == STATUS_ACCESS_DENIED ) {

            //
            // The client doesn't have Read/Write access to the file.
            // Try Read access.  If soft compatibility mapping is
            // enabled, use SHARE=READ and don't call this a
            // compatibility mode open.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: r/w access denied.\n" ));
            }

            shareAccess = 0;
            if ( SrvEnableSoftCompatibility ) {
                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoFcbOpen: FCB open of %wZ mapped to normal open\n", RelativeName ));
                }
                shareAccess = FILE_SHARE_READ;
                compatibilityOpen = FALSE;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         GENERIC_READ,                       // DesiredAccess
                         &objectAttributes,
                         IoStatusBlock,
                         &allocationSize,
                         fileAttributes,
                         shareAccess,
                         createDisposition,
                         createOptions,
                         EaBuffer,
                         EaLength,
                         CreateFileTypeNone,
                         NULL,                               // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,
                         WorkContext->TreeConnect->Share
                         );


            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

        }

    }

    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // All of the open attempts failed.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoFcbOpen: all opens failed; status = %X\n",
                        status ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
        }

        return status;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 12, 0 );

    //
    // The file has been successfully opened.  Attempt to allocate
    // structures to represent the open.  If any errors occur,
    // CompleteOpen does full cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoFcbOpen: Open of %wZ succeeded, file handle: 0x%p\n", RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           0,           // ShareAccess
                           0,
                           compatibilityOpen,
                           TRUE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoFcbOpen


PTABLE_ENTRY
FindAndClaimFileTableEntry (
    IN PCONNECTION Connection,
    OUT PSHORT FidIndex
    )
{
    PTABLE_HEADER tableHeader;
    SHORT fidIndex;
    PTABLE_ENTRY entry;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    tableHeader = &Connection->FileTable;

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &oldIrql );

    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialFileTableSize,
             SrvMaxFileTableSize,
             NULL ) == FALSE
       ) {

        RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );

        return NULL;
    }

    //
    // Remove the FID slot from the free list, but don't set its owner
    // and sequence number yet.
    //

    fidIndex = tableHeader->FirstFreeEntry;

    entry = &tableHeader->Table[fidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == fidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );

    *FidIndex = fidIndex;
    return entry;

} // FindAndClaimFileTableEntry


NTSTATUS
CompleteOpen (
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    IN PLFCB ExistingLfcb OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN PACCESS_MASK RemoteGrantedAccess OPTIONAL,
    IN ULONG ShareAccess,
    IN ULONG FileMode,
    IN BOOLEAN CompatibilityOpen,
    IN BOOLEAN FcbOpen,
    OUT PBOOLEAN LfcbAddedToMfcbList
    )

/*++

Routine Description:

    Completes structure allocation, initialization, and linking after
    a successful open.  Updates Master File Table as appropriate.
    Adds entry to connection's file table.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    ExistingLfcb - Optional address of an existing Local File Control
        Block.  Specified when folding a duplicate compatibility mode
        open into a single local open.

    FileHandle - Optional file handle obtained from SrvIoCreateFile.
        Ignored when ExistingLfcb is specified.

    RemoteGrantedAccess - Optional granted access to be stored in new
        RFCB.  If not specified, granted access from LFCB (i.e., access
        obtained on local open) is used.

    FileMode - Same value specified as CreateOptions on SrvIoCreateFile
        call.  Indicates whether client wants writethrough mode.

    CompatibilityOpen - TRUE if this is a compatibility mode open.

    FcbOpen - TRUE if this is an FCB open.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;

    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;
    PLFCB newLfcb;
    PLFCB lfcb;
    BOOLEAN rfcbLinkedToLfcb;

    PFILE_OBJECT fileObject;

    OBJECT_HANDLE_INFORMATION handleInformation;

    PCONNECTION connection;
    PTABLE_ENTRY entry;
    SHORT fidIndex;

    ULONG pid;

    PAGED_CODE( );

    //
    // Initialize various fields for the error handler.
    //

    rfcb = NULL;
    newLfcb = NULL;
    rfcbLinkedToLfcb = FALSE;
    fileObject = NULL;
    *LfcbAddedToMfcbList = FALSE;

    //
    // Allocate an RFCB.
    //

    SrvAllocateRfcb( &rfcb, WorkContext );

    if ( rfcb == NULL ) {

        ULONG length = sizeof( RFCB );

        //
        // Unable to allocate RFCB.  Return an error to the client.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Unable to allocate RFCB\n" ));
        }

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto error_exit;

    }

    pagedRfcb = rfcb->PagedRfcb;
    KeQuerySystemTime( &pagedRfcb->OpenTime );

    //
    // If no existing LFCB address was passed in (i.e., if this is not a
    // duplicate compatibility mode open), allocate and initialize a new
    // LFCB.
    //

    if ( ARGUMENT_PRESENT( ExistingLfcb ) ) {

        ASSERT( CompatibilityOpen );
        ASSERT( ExistingLfcb->CompatibilityOpen );

        lfcb = ExistingLfcb;

    } else {

        PFAST_IO_DISPATCH fastIoDispatch;

        SrvAllocateLfcb( &newLfcb, WorkContext );

        if ( newLfcb == NULL ) {

            //
            // Unable to allocate LFCB.  Return an error to the client.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "CompleteOpen: Unable to allocate LFCB\n" ));
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;

        }

        lfcb = newLfcb;

        //
        // Get a pointer to the file object, so that we can directly
        // build IRPs for asynchronous operations (read and write).
        // Also, get the granted access mask, so that we can prevent the
        // client from doing things that it isn't allowed to do.
        //
        // *** Note that the granted access on the local open may allow
        //     more access than was requested on the remote open.
        //     That's why the RFCB has its own granted access field.
        //

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    &handleInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            goto error_exit;

        }

        //
        // Initialize the new LFCB.
        //

        lfcb->FileHandle = FileHandle;
        lfcb->FileObject = fileObject;

        lfcb->GrantedAccess = handleInformation.GrantedAccess;
        lfcb->DeviceObject = IoGetRelatedDeviceObject( fileObject );

        fastIoDispatch = lfcb->DeviceObject->DriverObject->FastIoDispatch;
        if ( fastIoDispatch != NULL ) {
            lfcb->FastIoRead = fastIoDispatch->FastIoRead;
            lfcb->FastIoWrite = fastIoDispatch->FastIoWrite;
            lfcb->FastIoLock = fastIoDispatch->FastIoLock;
            lfcb->FastIoUnlockSingle = fastIoDispatch->FastIoUnlockSingle;

            //
            //  Fill in Mdl calls.  If the file system's vector is large enough,
            //  we still need to check if one of the routines is specified.  But
            //  if one is specified they all must be.
            //
            if ((fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
                (fastIoDispatch->MdlRead != NULL)) {

                lfcb->MdlRead = fastIoDispatch->MdlRead;
                lfcb->MdlReadComplete = fastIoDispatch->MdlReadComplete;
                lfcb->PrepareMdlWrite = fastIoDispatch->PrepareMdlWrite;
                lfcb->MdlWriteComplete = fastIoDispatch->MdlWriteComplete;


            } else if( IoGetBaseFileSystemDeviceObject( fileObject ) == lfcb->DeviceObject ) {
                //
                //  Otherwise default to the original FsRtl routines if we are right atop
                //   a filesystem.
                //
                lfcb->MdlRead = FsRtlMdlReadDev;
                lfcb->MdlReadComplete = FsRtlMdlReadCompleteDev;
                lfcb->PrepareMdlWrite = FsRtlPrepareMdlWriteDev;
                lfcb->MdlWriteComplete = FsRtlMdlWriteCompleteDev;
            } else {
                //
                // Otherwise, make them fail!
                //
                lfcb->MdlRead = SrvFailMdlReadDev;
                lfcb->PrepareMdlWrite = SrvFailPrepareMdlWriteDev;
            }
        }

        lfcb->FileMode = FileMode & ~FILE_COMPLETE_IF_OPLOCKED;
        lfcb->CompatibilityOpen = CompatibilityOpen;
    }

    //
    // Initialize the RFCB.
    //

    if ( ARGUMENT_PRESENT( RemoteGrantedAccess ) ) {
        rfcb->GrantedAccess = *RemoteGrantedAccess;
        IoCheckDesiredAccess( &rfcb->GrantedAccess, lfcb->GrantedAccess );
    } else {
        rfcb->GrantedAccess = lfcb->GrantedAccess;
    }

    rfcb->ShareAccess = ShareAccess;
    rfcb->FileMode = lfcb->FileMode;
    rfcb->Mfcb = Mfcb;
#ifdef SRVCATCH
    rfcb->SrvCatch = Mfcb->SrvCatch;

    IF_SYSCACHE_RFCB( rfcb ) {
        KdPrint(("Syscache RFCB %p off MFCB %p\n", rfcb, Mfcb ));
    }
#endif

    //
    // If delete on close was specified, don't attempt to cache this rfcb.
    //

    if ( (FileMode & FILE_DELETE_ON_CLOSE) != 0 ) {
        rfcb->IsCacheable = FALSE;
    }

    //
    // Check for granted access
    //

    //
    // Locks
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_LOCK_CONTROL,
        IRP_MN_LOCK,
        0,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        rfcb->LockAccessGranted = TRUE;
        rfcb->ExclusiveLockGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Lock IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Unlocks
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_LOCK_CONTROL,
        IRP_MN_UNLOCK_SINGLE,
        0,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        rfcb->UnlockAccessGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Unlock IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Reads
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_READ,
        0, 0, &status );

    if ( NT_SUCCESS(status) ) {
        rfcb->ReadAccessGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Read IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Writes
    //

    if( rfcb->GrantedAccess & FILE_WRITE_DATA ) {
        rfcb->WriteAccessGranted = TRUE;
    }
    if( rfcb->GrantedAccess & FILE_APPEND_DATA ) {
        rfcb->AppendAccessGranted = TRUE;

        //
        // This hack is required for now.  The problem is that clients, given an
        //  oplock, will write whole pages to the server.  The offset of the page
        //  will likely cover the last part of the file, and the server will reject
        //  the write.  Code needs to be added to the server to ignore the
        //  first part of the page.  Or we could just not give the client an oplock
        //  if append access is granted.  For now, we revert to prior NT4 behavior.
        //
        rfcb->WriteAccessGranted = TRUE;
    }

    if( !(rfcb->WriteAccessGranted) && (WorkContext->TreeConnect->Share->ShareProperties & SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS) )
    {
        rfcb->ExclusiveLockGranted = FALSE;
    }

    //
    // Copy the TID from the tree connect into the RFCB.  We do this to
    // reduce the number of indirections we have to take.  Save the PID
    // of the remote process that's opening the file.  We'll need this
    // if we get a Process Exit SMB.
    //

    rfcb->Tid = WorkContext->TreeConnect->Tid;
    rfcb->Pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    pid = rfcb->Pid;
    rfcb->Uid = WorkContext->Session->Uid;

    if ( FcbOpen ) {
        pagedRfcb->FcbOpenCount = 1;
    }

    if ( WorkContext->Endpoint->IsConnectionless ) {
        rfcb->WriteMpx.FileObject = lfcb->FileObject;
        rfcb->WriteMpx.MpxGlommingAllowed =
            (BOOLEAN)((lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) != 0);
    }

    //
    // If this is a named pipe, fill in the named pipe specific
    // information.  The default mode on open is always byte mode,
    // blocking.
    //

    rfcb->ShareType = WorkContext->TreeConnect->Share->ShareType;

    if ( rfcb->ShareType == ShareTypePipe ) {
        rfcb->BlockingModePipe = TRUE;
        rfcb->ByteModePipe = TRUE;
    }

    //
    // Link the RFCB into the LFCB.
    //

    SrvInsertTailList( &lfcb->RfcbList, &pagedRfcb->LfcbListEntry );
    rfcb->Lfcb = lfcb;
    lfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( lfcb, FALSE );
    lfcb->HandleCount++;
    rfcbLinkedToLfcb = TRUE;

    //
    // Making a new RFCB visible is a multi-step operation.  It must be
    // inserted in the global ordered file list and the containing
    // connection's file table.  If the LFCB is not new, it must be
    // inserted in the MFCB's list of LFCBs, and the connection, the
    // session, and the tree connect must all be referenced.  We need to
    // make these operations appear atomic, so that the RFCB cannot be
    // accessed elsewhere before we're done setting it up.  In order to
    // do this, we hold all necessary locks the entire time we're doing
    // the operations.  The locks that are required are:
    //
    //  1) the MFCB lock (which protects the MFCB's LFCB list),
    //
    //  2) the global ordered list lock (which protects the ordered file
    //     list),
    //
    //  3) the connection lock (which prevents closing of the
    //     connection, the session, and the tree connect), and
    //
    // These locks are taken out in the order listed above, as dictated
    // by lock levels (see lock.h).  Note that the MFCB lock is already
    // held on entry to this routine.
    //

    connection = WorkContext->Connection;

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Mfcb->NonpagedMfcb->Lock)) );
    ASSERT( SrvRfcbList.Lock == &SrvOrderedListLock );
    ACQUIRE_LOCK( SrvRfcbList.Lock );
    ACQUIRE_LOCK( &connection->Lock );

    //
    // We first check all conditions to make sure that we can actually
    // insert this RFCB.
    //
    // Make sure that the tree connect isn't closing.
    //

    if ( GET_BLOCK_STATE(WorkContext->TreeConnect) != BlockStateActive ) {

        //
        // The tree connect is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Tree connect is closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Make sure that the session isn't closing.
    //

    if ( GET_BLOCK_STATE(WorkContext->Session) != BlockStateActive ) {

        //
        // The session is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Session is closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing.
    //

    connection = WorkContext->Connection;

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        //
        // The connection is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Connection closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;
    }

    //
    // Find and claim a FID that can be used for this file.
    //

    entry = FindAndClaimFileTableEntry( connection, &fidIndex );
    if ( entry == NULL ) {

        //
        // No free entries in the file table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: No more FIDs available.\n" ));
        }

        SrvLogTableFullError( SRV_TABLE_FILE );

        status = STATUS_OS2_TOO_MANY_OPEN_FILES;
        goto cant_insert;
    }

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the file visible.
    //
    // If this isn't a duplicate open, add this open file instance to
    // the Master File Table.
    //

    if ( !ARGUMENT_PRESENT( ExistingLfcb ) ) {

        //
        // Add the new LFCB to the master file's list of open instances.
        // We set LfcbAddedToMfcbList to tell the calling routine that
        // an LFCB has been queued to the MFCB and that the reference
        // count that was previously incremented should not be
        // decremented.
        //

        *LfcbAddedToMfcbList = TRUE;
        Mfcb->CompatibilityOpen = lfcb->CompatibilityOpen;
        SrvInsertTailList( &Mfcb->LfcbList, &lfcb->MfcbListEntry );
        lfcb->Mfcb = Mfcb;

        //
        // Point the LFCB to the connection, session, and tree connect,
        // referencing them to account for the open file and therefore
        // prevent deletion.
        //

        SrvReferenceConnection( connection );
        lfcb->Connection = connection;

        SrvReferenceSession( WorkContext->Session );
        lfcb->Session = WorkContext->Session;

        SrvReferenceTreeConnect( WorkContext->TreeConnect );
        lfcb->TreeConnect = WorkContext->TreeConnect;

        //
        // Increment the count of open files in the session and tree
        // connect.  These counts prevent autodisconnecting a session
        // that has open files and are used by server APIs.
        //

        WorkContext->Session->CurrentFileOpenCount++;
        WorkContext->TreeConnect->CurrentFileOpenCount++;

    }

    //
    // Capture the connection pointer in the nonpaged RFCB so that we
    // can find the connection at DPC level.
    //

    rfcb->Connection = lfcb->Connection;

    //
    // Insert the RFCB on the global ordered list.
    //

    SrvInsertEntryOrderedList( &SrvRfcbList, rfcb );

    //
    // Set the owner and sequence number of the file table slot.  Create
    // a FID for the file.
    //

    entry->Owner = rfcb;

    INCREMENT_FID_SEQUENCE( entry->SequenceNumber );
    if ( fidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_FID_SEQUENCE( entry->SequenceNumber );
    }

    rfcb->Fid = MAKE_FID( fidIndex, entry->SequenceNumber );
    rfcb->ShiftedFid = rfcb->Fid << 16;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "CompleteOpen: Found FID. Index = 0x%lx, sequence = 0x%lx\n",
                    FID_INDEX( rfcb->Fid ), FID_SEQUENCE( rfcb->Fid ) ));
    }

    //
    // Release the locks used to make this operation appear atomic.
    //
    // Note that our caller expects us to keep the MFCB lock held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( SrvRfcbList.Lock );

    //
    // File successfully opened.  Save in the WorkContext block for
    // the followon SMB, if any. Cache the Rfcb.
    //

    WorkContext->Rfcb = rfcb;
    *Rfcb = rfcb;

    //
    // Update the MFCB active count.
    //

    ++Mfcb->ActiveRfcbCount;

    //
    // If this is a pipe, set the client ID for the pipe.  If it is a
    // message type named pipe, set the read mode to message mode.
    //

    if ( rfcb->ShareType == ShareTypePipe ) {

        //
        // NT clients put the high part of the PID in a reserved
        // location in the SMB header.
        //

        if ( IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            pid = (SmbGetUshort( &WorkContext->RequestHeader->PidHigh )
                    << 16) | pid;
        }

        (VOID)SrvIssueSetClientProcessRequest(
                lfcb->FileObject,
                &lfcb->DeviceObject,
                connection,
                WorkContext->Session,
                LongToPtr( pid )
                );

        //
        // Set the read mode.
        //

        rfcb->ByteModePipe = !SetDefaultPipeMode( FileHandle );

    }

    return STATUS_SUCCESS;

cant_insert:

    //
    // Release the locks.
    //
    // Note that our caller expects us to keep the MFCB lock held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( SrvRfcbList.Lock );

error_exit:

    //
    // Error cleanup.  Put things back into their initial state.
    //
    // If the new RFCB was associated with an LFCB, unlink it now.
    //

    if ( rfcbLinkedToLfcb ) {
        SrvRemoveEntryList(
                &rfcb->Lfcb->RfcbList,
                &pagedRfcb->LfcbListEntry
                );

        lfcb->BlockHeader.ReferenceCount--;
        UPDATE_REFERENCE_HISTORY( lfcb, TRUE );
        lfcb->HandleCount--;
    }

    //
    // If the file object was referenced, dereference it.
    //

    if ( fileObject != NULL ) {
        ObDereferenceObject( fileObject );
    }

    //
    // If a new LFCB was allocated, free it.
    //

    if ( newLfcb != NULL ) {
        SrvFreeLfcb( newLfcb, WorkContext->CurrentWorkQueue );
    }

    //
    // If a new RFCB was allocated, free it.
    //

    if ( rfcb != NULL ) {
        SrvFreeRfcb( rfcb, WorkContext->CurrentWorkQueue );
    }

    //
    // If this not a folded compatibility mode open, close the file.
    //

    if ( !ARGUMENT_PRESENT( ExistingLfcb ) ) {
        SRVDBG_RELEASE_HANDLE( FileHandle, "FIL", 17, 0 );
        SrvNtClose( FileHandle, TRUE );
    }

    //
    // Indicate failure.
    //

    *Rfcb = NULL;

    return status;

} // CompleteOpen


BOOLEAN SRVFASTCALL
MapCompatibilityOpen(
    IN PUNICODE_STRING FileName,
    IN OUT PUSHORT SmbDesiredAccess
    )

/*++

Routine Description:

    Determines whether a compatibility mode open can be mapped into
    normal sharing mode.

Arguments:

    FileName - The name of the file being accessed

    SmbDesiredAccess - On input, the desired access specified in the
        received SMB.  On output, the share mode portion of this field
        is updated if the open is mapped to normal sharing.

Return Value:

    BOOLEAN - TRUE if the open has been mapped to normal sharing.

--*/

{
    PAGED_CODE( );

    //
    // If soft compatibility is not enabled then reject the mapping
    //
    if( !SrvEnableSoftCompatibility ) {

        IF_SMB_DEBUG( OPEN_CLOSE2 ) {
            KdPrint(( "MapCompatibilityOpen: "
                      "SrvEnableSoftCompatibility is FALSE\n" ));
        }

        return FALSE;
    }

    //
    // If the client is opening one of the following reserved suffixes, be lenient
    //
    if( FileName->Length > 4 * sizeof( WCHAR ) ) {

        LPWSTR periodp;

        periodp = FileName->Buffer + (FileName->Length / sizeof( WCHAR ) ) - 4;

        if( (*periodp++ == L'.') &&
            (_wcsicmp( periodp, L"EXE" ) == 0  ||
             _wcsicmp( periodp, L"DLL" ) == 0  ||
             _wcsicmp( periodp, L"SYM" ) == 0  ||
             _wcsicmp( periodp, L"COM" ) == 0 )  ) {

            //
            // This is a readonly open of one of the above file types.
            //  Map to DENY_NONE
            //

            IF_SMB_DEBUG( OPEN_CLOSE2 ) {
                KdPrint(( "MapCompatibilityOpen: %wZ mapped to DENY_NONE\n", FileName ));
            }

            *SmbDesiredAccess |= SMB_DA_SHARE_DENY_NONE;
            return TRUE;
        }
    }

    //
    // The filename does not end in one of the special suffixes -- map
    // it to DENY_WRITE if the client is asking for just read permissions.
    //
    if( (*SmbDesiredAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_READ) {
        IF_SMB_DEBUG( OPEN_CLOSE2 ) {
                KdPrint(( "MapCompatibilityOpen: %wZ mapped to DENY_WRITE\n", FileName ));
        }
        *SmbDesiredAccess |= SMB_DA_SHARE_DENY_WRITE;
        return TRUE;
    }

    IF_SMB_DEBUG( OPEN_CLOSE2 ) {
        KdPrint(( "MapCompatibilityOpen: %wZ not mapped, DesiredAccess %X\n", FileName, *SmbDesiredAccess ));
    }

    return FALSE;
} // MapCompatibilityOpen


NTSTATUS SRVFASTCALL
MapDesiredAccess(
    IN USHORT SmbDesiredAccess,
    OUT PACCESS_MASK NtDesiredAccess
    )

/*++

Routine Description:

    Maps a desired access specification from SMB form to NT form.

Arguments:

    SmbDesiredAccess - The desired access specified in the received SMB.
        (This includes desired access, share access, and other mode
        bits.)

    NtDesiredAccess - Returns the NT equivalent of the desired access
        part of SmbDesiredAccess.

Return Value:

    NTSTATUS - Indicates whether SmbDesiredAccess is valid.

--*/

{
    PAGED_CODE( );

    switch ( SmbDesiredAccess & SMB_DA_ACCESS_MASK ) {

    case SMB_DA_ACCESS_READ:

        *NtDesiredAccess = GENERIC_READ;
        break;

    case SMB_DA_ACCESS_WRITE:

        //
        // Having read attributes is implicit in having the file open in
        // the SMB protocol, so request FILE_READ_ATTRIBUTES in addition
        // to GENERIC_WRITE.
        //

        *NtDesiredAccess = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
        break;

    case SMB_DA_ACCESS_READ_WRITE:

        *NtDesiredAccess = GENERIC_READ | GENERIC_WRITE;
        break;

    case SMB_DA_ACCESS_EXECUTE:

        // !!! is this right?
        *NtDesiredAccess = GENERIC_READ | GENERIC_EXECUTE;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapDesiredAccess: Invalid desired access: 0x%lx\n",
                        SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapDesiredAccess


NTSTATUS SRVFASTCALL
MapOpenFunction(
    IN USHORT SmbOpenFunction,
    OUT PULONG NtCreateDisposition
    )

/*++

Routine Description:

    Maps an open function specification from SMB form to NT form.

Arguments:

    WorkContext - Work context block for the operation.

    SmbOpenFunction - The open function specified in the received SMB.

    NtDesiredAccess - Returns the NT equivalent of SmbOpenFunction.

Return Value:

    NTSTATUS - Indicates whether SmbOpenFunction is valid.

--*/

{
    PAGED_CODE( );

    // The OpenFunction bit mapping:
    //
    //     rrrr rrrr rrrC rrOO
    //
    //   where:
    //
    //     C - Create (action to be taken if the file does not exist)
    //       0 -- Fail
    //       1 -- Create file
    //
    //     O - Open (action to be taken if the file exists)
    //       0 - Fail
    //       1 - Open file
    //       2 - Truncate file
    //

    switch ( SmbOpenFunction & (SMB_OFUN_OPEN_MASK | SMB_OFUN_CREATE_MASK) ) {

    case SMB_OFUN_CREATE_FAIL | SMB_OFUN_OPEN_OPEN:

        *NtCreateDisposition = FILE_OPEN;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL:

        *NtCreateDisposition = FILE_CREATE;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_OPEN:

        *NtCreateDisposition = FILE_OPEN_IF;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_TRUNCATE:

        *NtCreateDisposition = FILE_OVERWRITE_IF;
        break;

    case SMB_OFUN_CREATE_FAIL | SMB_OFUN_OPEN_TRUNCATE:

        *NtCreateDisposition = FILE_OVERWRITE;
        break;

    //case 0x00:
    //case 0x03:
    //case 0x13:
    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapOpenFunction: Invalid open function: 0x%lx\n",
                        SmbOpenFunction ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapOpenFunction


NTSTATUS SRVFASTCALL
MapCacheHints(
    IN USHORT SmbDesiredAccess,
    IN OUT PULONG NtCreateFlags
    )

/*++

Routine Description:

    This function maps the SMB cache mode hints to the NT format.  The
    NtCreateFlags are updated.

Arguments:

    WorkContext - Work context block for the operation.

    SmbOpenFunction - The open function specified in the received SMB.

    NtCreateFlags - The NT file creation flags

Return Value:

    NTSTATUS - Indicates whether SmbOpenFunction is valid.

--*/

{
    PAGED_CODE( );

    // The DesiredAccess bit mapping:
    //
    //      xxxC xLLL xxxx xxxx
    //
    //   where:
    //
    //     C - Cache mode
    //       0 -- Normal file
    //       1 -- Do not cache the file
    //
    //     LLL - Locality of reference
    //       000 - Unknown
    //       001 - Mainly sequential access
    //       010 - Mainly random access
    //       011 - Random with some locality
    //       1xx - Undefined
    //

    //
    // If the client doesn't want us to use the cache, we can't give that, but we
    // can at least get the data written immediately.
    //

    if ( SmbDesiredAccess & SMB_DO_NOT_CACHE ) {
        *NtCreateFlags |= FILE_WRITE_THROUGH;
    }

    switch ( SmbDesiredAccess & SMB_LR_MASK ) {

    case SMB_LR_UNKNOWN:
        break;

    case SMB_LR_SEQUENTIAL:
        *NtCreateFlags |= FILE_SEQUENTIAL_ONLY;
        break;

    case SMB_LR_RANDOM:
    case SMB_LR_RANDOM_WITH_LOCALITY:
        *NtCreateFlags |= FILE_RANDOM_ACCESS;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapCacheHints: Invalid cache hint: 0x%lx\n",
                       SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapCacheHints


NTSTATUS SRVFASTCALL
MapShareAccess(
    IN USHORT SmbDesiredAccess,
    OUT PULONG NtShareAccess
    )

/*++

Routine Description:

    Maps a share access specification from SMB form to NT form.

Arguments:

    SmbDesiredAccess - The desired access specified in the received SMB.
        (This includes desired access, share access, and other mode
        bits.)

    NtShareAccess - Returns the NT equivalent of the share access part
        of SmbDesiredAccess.

Return Value:

    NTSTATUS - Indicates whether SmbDesiredAccess is valid.

--*/

{
    PAGED_CODE( );

    switch ( SmbDesiredAccess & SMB_DA_SHARE_MASK ) {

    case SMB_DA_SHARE_EXCLUSIVE:

        //
        // Deny read and write.
        //

        *NtShareAccess = 0L;
        break;

    case SMB_DA_SHARE_DENY_WRITE:

        //
        // Deny write but allow read.
        //

        *NtShareAccess = FILE_SHARE_READ;
        break;

    case SMB_DA_SHARE_DENY_READ:

        //
        // Deny read but allow write.
        //

        *NtShareAccess = FILE_SHARE_WRITE;
        break;

    case SMB_DA_SHARE_DENY_NONE:

        //
        // Deny none -- allow other processes to read or write the file.
        //

        *NtShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapShareAccess: Invalid share access: 0x%lx\n",
                        SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapShareAccess


NTSTATUS
SrvNtCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN ULONG RootDirectoryFid,
    IN ACCESS_MASK DesiredAccess,
    IN LARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptorBuffer OPTIONAL,
    IN PUNICODE_STRING FileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    IN ULONG OptionFlags,
    PSECURITY_QUALITY_OF_SERVICE QualityOfService,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    )

/*++

Routine Description:

    Does most of the operations necessary to open or create a file.
    First the UID and TID are verified and the corresponding session and
    tree connect blocks located.  The input file name name is
    canonicalized, and a fully qualified name is formed.  The file
    is opened and the appropriate data structures are created.

Arguments:

    WorkContext - Work context block for the operation.

    RootDirectoryFid - The FID of an open root directory.  The file is opened
       relative to this directory.

    DesiredAccess - The access type requested by the client.

    AllocationSize - The initialize allocation size of the file.  It is
       only used if the file is created, overwritten, or superseded.

    FileAttributes - Specified the file attributes.

    ShareAccess -  Specifies the type of share access requested by the
        client.

    CreateDisposition - Specifies the action to be taken if the file does
        or does not exist.

    CreateOptions - Specifies the options to use when creating the file.

    SecurityDescriptorBuffer - The SD to set on the file.

    FileName - The name of the file to open.

    EaBuffer - The EAs to set on the file.

    EaLength - Length, in bytes, of the EA buffer.

    EaErrorOffset - Returns the offset, in bytes, in the EA buffer of
       the EA error.

    OptionFlags - The option flags for creating the file

    QualityOfService - The security quality of service for the file

    RestartRoutine - The restart routine for the caller.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PRFCB rfcb;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    UNICODE_STRING relativeName;
    UNICODE_STRING fullName;
    BOOLEAN nameAllocated;
    BOOLEAN relativeNameAllocated = FALSE;
    SHARE_TYPE shareType;
    PRFCB rootDirRfcb = NULL;
    PLFCB rootDirLfcb;
    BOOLEAN success;
    ULONG attributes;
    ULONG openRetries;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG ioCreateFlags;
    PSHARE fileShare = NULL;
    BOOLEAN caseInsensitive;
    ULONG hashValue;

    PSRV_LOCK mfcbLock = NULL;

    //
    // NOTE ON MFCB REFERENCE COUNT HANDLING
    //
    // After finding or creating an MFCB for a file, we increment the
    // MFCB reference count an extra time to simplify our
    // synchronization logic.   We hold MfcbListLock lock while
    // finding/creating the MFCB, but release it after acquiring the the
    // per-MFCB lock.  After opening the file, we call CompleteOpen,
    // which may need to queue an LFCB to the MFCB and thus need to
    // increment the count.  But it can't, because the MFCB list lock may
    // not be acquired while the per-MFCB lock is held because of
    // deadlock potential.  The boolean LfcbAddedToMfcbList returned
    // from CompleteOpen indicates whether it actually queued an LFCB to
    // the MFCB.  If it didn't, we need to release the extra reference.
    //
    // Note that it isn't often that we actually have to dereference the
    // MFCB.  This only occurs when the open fails.
    //

    BOOLEAN lfcbAddedToMfcbList;

    PAGED_CODE( );

    //
    // Assume we won't need a temporary open.
    //

    WorkContext->Parameters2.Open.TemporaryOpen = FALSE;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find the tree connect corresponding to the given TID if a tree
    // connect pointer has not already been put in the WorkContext block
    // by an AndX command or a previous call to SrvCreateFile.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvNtCreateFile: Invalid UID or TID\n" ));
        }
        return status;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        return SESSION_EXPIRED_STATUS_CODE;
    }

    if ( RootDirectoryFid != 0 ) {

        rootDirRfcb = SrvVerifyFid(
                            WorkContext,
                            (USHORT)RootDirectoryFid,
                            FALSE,
                            NULL,  // don't serialize with raw write
                            &status
                            );

        if ( rootDirRfcb == SRV_INVALID_RFCB_POINTER ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Invalid Root Dir FID: 0x%lx\n",
                           RootDirectoryFid ));
            }

            return status;

        } else {

            //
            // Remove the redundant copy of the RFCB to prevent a redundant
            // dereference of this RFCB.
            //

            WorkContext->Rfcb = NULL;

        }

        rootDirLfcb = rootDirRfcb->Lfcb;

    }

    //
    // Here we begin share type specific processing.
    //

    shareType = treeConnect->Share->ShareType;

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    // Note that a disk open will block if the file is currently oplocked.
    //

    if ( shareType == ShareTypeDisk && !WorkContext->BlockingOperation ) {

        if ( SrvReceiveBufferShortage( ) ) {

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            SrvStatistics.BlockingSmbsRejected++;

            return STATUS_INSUFF_SERVER_RESOURCES;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Assume we won't need a temporary open.
    //

    switch ( shareType ) {

    case ShareTypeDisk:
    case ShareTypePipe:

        //
        // Canonicalize the path name so that it conforms to NT
        // standards.
        //
        // *** Note that this operation allocates space for the name.
        //

        status = SrvCanonicalizePathName(
                     WorkContext,
                     treeConnect->Share,
                     RootDirectoryFid != 0 ? &rootDirLfcb->Mfcb->FileName : NULL,
                     FileName->Buffer,
                     ((PCHAR)FileName->Buffer +
                        FileName->Length - sizeof(WCHAR)),
                     TRUE,              // Strip trailing "."s
                     TRUE,              // Name is always unicode
                     &relativeName
                     );

        if ( !NT_SUCCESS( status ) ) {

            //
            // The path tried to do ..\ to get beyond the share it has
            // accessed.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Invalid pathname: "
                           "%wZ\n", FileName ));
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }
            return status;

        }

        //
        // Form the fully qualified name of the file.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        if ( shareType == ShareTypeDisk ) {

            if ( RootDirectoryFid != 0 ) {
                SrvAllocateAndBuildPathName(
                    &rootDirLfcb->Mfcb->FileName,
                    &relativeName,
                    NULL,
                    &fullName
                    );
            } else {
                SrvAllocateAndBuildPathName(
                    &treeConnect->Share->DosPathName,
                    &relativeName,
                    NULL,
                    &fullName
                    );
            }

        } else {

            UNICODE_STRING pipePrefix;

            if( !WorkContext->Session->IsNullSession &&
                WorkContext->Session->IsLSNotified == FALSE ) {

                //
                // We have a pipe open request, not a NULL session, and
                //  we haven't gotten clearance from the license server yet.
                //  If this pipe requires clearance, get a license.
                //

                ULONG i;
                BOOLEAN matchFound = FALSE;

                ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

                for ( i = 0; SrvPipesNeedLicense[i] != NULL ; i++ ) {

                    if ( _wcsicmp(
                            SrvPipesNeedLicense[i],
                            relativeName.Buffer
                            ) == 0 ) {
                        matchFound = TRUE;
                        break;
                    }
                }

                RELEASE_LOCK( &SrvConfigurationLock );

                if( matchFound == TRUE ) {
                    status = SrvXsLSOperation( WorkContext->Session,
                                               XACTSRV_MESSAGE_LSREQUEST );

                    if( !NT_SUCCESS( status ) ) {
                        if( rootDirRfcb != NULL ) {
                            SrvDereferenceRfcb( rootDirRfcb );
                        }
                        return status;
                    }
                }
            }

            RtlInitUnicodeString( &pipePrefix, StrSlashPipeSlash );

            if( WorkContext->Endpoint->RemapPipeNames || treeConnect->RemapPipeNames ) {

                //
                // The RemapPipeNames flag is set, so remap the pipe name
                //  to "$$\<server>\<pipe name>".
                //
                // Note: this operation allocates space for pipeRelativeName.
                //

                status = RemapPipeName(
                            &WorkContext->Endpoint->TransportAddress,
                            treeConnect->RemapPipeNames ? &treeConnect->ServerName : NULL,
                            &relativeName,
                            &relativeNameAllocated
                         );

                if( !NT_SUCCESS( status ) ) {

                    if( rootDirRfcb != NULL ) {
                        SrvDereferenceRfcb( rootDirRfcb );
                    }

                    return status;
                }
            }
            SrvAllocateAndBuildPathName(
                &pipePrefix,
                &relativeName,
                NULL,
                &fullName
                );

        }

        if ( fullName.Buffer == NULL ) {

            //
            // Unable to allocate heap for the full name.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Unable to allocate heap for "
                            "full path name\n" ));
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        //
        // Indicate that we must free the file name buffers on exit.
        //

        nameAllocated = TRUE;

        break;

    //
    //  Default case, illegal device type.  This should never happen.
    //

    default:

        // !!! Is this an appropriate error return code?  Probably no.
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Determine whether or not the path name is case sensitive.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
          WorkContext->Session->UsingUppercasePaths )
    {

        attributes = OBJ_CASE_INSENSITIVE;
        caseInsensitive = TRUE;

    } else {
        attributes = 0L;
        caseInsensitive = FALSE;
    }

    if ( RootDirectoryFid != 0 ) {

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            rootDirLfcb->FileHandle,
            NULL
            );

    } else if ( WorkContext->TreeConnect->Share->ShareType == ShareTypePipe ) {
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            SrvNamedPipeHandle,
            NULL
            );
    } else {

        fileShare = treeConnect->Share;

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            NULL,
            NULL
            );
    }

    if ( SecurityDescriptorBuffer != NULL) {
        objectAttributes.SecurityDescriptor = SecurityDescriptorBuffer;
    }

    //
    // Always add read attributes since we need to query file info after
    // the open.
    //

    DesiredAccess |= FILE_READ_ATTRIBUTES;

    //
    // Interpret the io create flags
    //

    ioCreateFlags = IO_CHECK_CREATE_PARAMETERS | IO_FORCE_ACCESS_CHECK;

    if ( OptionFlags & NT_CREATE_OPEN_TARGET_DIR ) {
        ioCreateFlags |= IO_OPEN_TARGET_DIRECTORY;
    }

    //
    // Override the default server quality of service, with the QOS request
    // by the client.
    //

    objectAttributes.SecurityQualityOfService = QualityOfService;

    if ( WorkContext->ProcessingCount == 2 ) {

        HANDLE innerFileHandle;
        OBJECT_ATTRIBUTES innerObjectAttributes;
        IO_STATUS_BLOCK innerIoStatusBlock;

        //
        // This is the second time through, so we must be in a blocking
        // thread.  Do a blocking open of the file to force an oplock
        // break.  Then close the handle and fall through to the normal
        // open path.
        //
        // We must do the blocking open without holding the MFCB
        // lock, because this lock can be acquired during oplock
        // break, resulting in deadlock.
        //

        SrvInitializeObjectAttributes_U(
            &innerObjectAttributes,
            &relativeName,
            attributes,
            0,
            NULL
            );

        status = SrvIoCreateFile(
                     WorkContext,
                     &innerFileHandle,
                     GENERIC_READ,
                     &innerObjectAttributes,
                     &innerIoStatusBlock,
                     NULL,
                     0,
                     FILE_SHARE_VALID_FLAGS,
                     FILE_OPEN,
                     0,
                     NULL,
                     0,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     0,
                     WorkContext->TreeConnect->Share
                     );

        if ( NT_SUCCESS( status ) ) {
            SRVDBG_CLAIM_HANDLE( innerFileHandle, "FIL", 13, 0 );
            SRVDBG_RELEASE_HANDLE( innerFileHandle, "FIL", 18, 0 );
            SrvNtClose( innerFileHandle, TRUE );
        }
    }

    //
    // Scan the Master File Table to see if the named file is already
    // open.
    //

    mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

    if ( mfcb == NULL ) {
        //
        // There is no MFCB for this file.  Create one.
        //

        mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

        if ( mfcb == NULL ) {

            //
            // Failure to add open file instance to MFT.
            //

            if( mfcbLock ) {
                RELEASE_LOCK( mfcbLock );
            }

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Unable to allocate MFCB\n" ));
            }

            if ( nameAllocated ) {
                FREE_HEAP( fullName.Buffer );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }
    }


    //
    // Increment the MFCB reference count.  See the note at the beginning of this routine.
    //
    mfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

    //
    // Grab the MFCB-based lock to serialize opens of the same file
    // and release the MFCB list lock.
    //

    nonpagedMfcb = mfcb->NonpagedMfcb;

    if( mfcbLock )
    {
        RELEASE_LOCK( mfcbLock );
    }

    ACQUIRE_LOCK( &nonpagedMfcb->Lock );

    openRetries = SrvSharingViolationRetryCount;

start_retry:

    // We now have two behaviors.  By default, we ignore NO_INTERMEDIATE_BUFFERING because
    // we cannot support it over the network, and switching to WRITE_THROUGH as we used
    // to do is too slow.  However, if the user desires the old behavior, we provide a setting
    // to revert back to it.

    if( SrvMapNoIntermediateBuffering )
    {
        //
        // If the client asked for FILE_NO_INTERMEDIATE_BUFFERING, turn that
        // flag off and turn FILE_WRITE_THROUGH on instead.  We cannot give
        // the client the true meaning of NO_INTERMEDIATE_BUFFERING, but we
        // can at least get the data out to disk right away.
        //

        if ( (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) != 0 ) {
            CreateOptions |= FILE_WRITE_THROUGH;
            CreateOptions &= ~FILE_NO_INTERMEDIATE_BUFFERING;
        }
    }
    else
    {
        //
        // Ignore the NoIntermediateBuffering Flag
        //
        CreateOptions &= ~FILE_NO_INTERMEDIATE_BUFFERING;
    }


    //
    // Check to see if there is a cached handle for the file.
    //

    if ( (CreateDisposition == FILE_OPEN) ||
         (CreateDisposition == FILE_CREATE) ||
         (CreateDisposition == FILE_OPEN_IF) ) {

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvNtCreateFile: checking for cached rfcb for %wZ\n", &fullName ));
        }
        if ( SrvFindCachedRfcb(
                WorkContext,
                mfcb,
                DesiredAccess,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                RequestedOplockType,
                &status ) ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvNtCreateFile: FindCachedRfcb = TRUE, status = %x, rfcb = %p\n",
                            status, WorkContext->Rfcb ));
            }

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            //
            // We incremented the MFCB reference count in anticipation of
            // the possibility that an LFCB might be queued to the MFCB.
            // This path precludes that possibility.
            //

            SrvDereferenceMfcb( mfcb );

            //
            // This second dereference is for the reference done by
            // SrvFindMfcb/SrvCreateMfcb.
            //

            SrvDereferenceMfcb( mfcb );

            if ( nameAllocated ) {
                FREE_HEAP( fullName.Buffer );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            return status;
        }

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvNtCreateFile: FindCachedRfcb = FALSE; do it the slow way\n" ));
        }
    }

    //
    // Call SrvIoCreateFile to create or open the file.  (We call
    // SrvIoCreateFile, rather than NtOpenFile, in order to get user-mode
    // access checking.)
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "SrvCreateFile: Opening file %wZ\n", &fullName ));
    }

    CreateOptions |= FILE_COMPLETE_IF_OPLOCKED;

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     DesiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     &AllocationSize,
                     FileAttributes,
                     ShareAccess,
                     CreateDisposition,
                     CreateOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     ioCreateFlags,
                     fileShare
                     );
    }

    //
    // If we got sharing violation and this is a disk file.
    // If this is the first open attempt, setup for a blocking open attempt.
    //   If the file is batch oplocked, the non-blocking open would fail,
    //   and the oplock will not break.
    //
    // If this is the second open attempt, we can assume that we are in
    //   the blocking thread.  Retry the open.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        if ( WorkContext->ProcessingCount == 1 ) {

            WorkContext->Parameters2.Open.TemporaryOpen = TRUE;

        } else if ( (WorkContext->ProcessingCount == 2) &&
                    (openRetries-- > 0) ) {

            //
            // We are in the blocking thread.
            //

            //
            // Release the mfcb lock so that a close might slip through.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            ACQUIRE_LOCK( &nonpagedMfcb->Lock );
            goto start_retry;
        }
    }

    //
    // Save the open information where the SMB processor can find it.
    //

    WorkContext->Irp->IoStatus.Information = ioStatusBlock.Information;

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The open failed.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvNtCreateFile: SrvIoCreateFile failed, file = %wZ, "
                        "status = %X, Info = 0x%p\n",
                        objectAttributes.ObjectName,
                        status, (PVOID)ioStatusBlock.Information ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)ioStatusBlock.Information;
            ioStatusBlock.Information = 0;
        }

        //
        // Cleanup allocated memory and return with a failure status.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // We incremented the MFCB reference count in anticipation of
        // the possibility that an LFCB might be queued to the MFCB.
        // This error path precludes that possibility.
        //

        SrvDereferenceMfcb( mfcb );

        //
        // This second dereference is for the reference done by
        // SrvFindMfcb/SrvCreateMfcb.
        //

        SrvDereferenceMfcb( mfcb );

        if ( nameAllocated ) {
            FREE_HEAP( fullName.Buffer );
        }

        if( relativeNameAllocated ) {
            FREE_HEAP( relativeName.Buffer );
        }

        if ( rootDirRfcb != NULL ) {
            SrvDereferenceRfcb( rootDirRfcb );
        }
        return status;

    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 14, 0 );

    //
    // The open was successful.  Attempt to allocate structures to
    // represent the open.  If any errors occur, CompleteOpen does full
    // cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "SrvNtCreateFile: Open of %wZ succeeded, file handle: 0x%p\n", &fullName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           &rfcb,
                           mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           ShareAccess,
                           CreateOptions,
                           FALSE,
                           FALSE,
                           &lfcbAddedToMfcbList
                           );

    //
    // Remember the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        status = completionStatus;
    }

    //
    // Release the Open serialization lock and dereference the MFCB.
    //

    RELEASE_LOCK( &nonpagedMfcb->Lock );

    //
    // If CompleteOpen didn't queue an LFCB to the MFCB, release the
    // extra reference that we added.
    //

    if ( !lfcbAddedToMfcbList ) {
        SrvDereferenceMfcb( mfcb );
    }

    SrvDereferenceMfcb( mfcb );

    //
    // Deallocate the full path name buffer.
    //

    if ( nameAllocated ) {
        FREE_HEAP( fullName.Buffer );
    }

    //
    // Deallocate the relative path name buffer.
    //
    if( relativeNameAllocated ) {
        FREE_HEAP( relativeName.Buffer );
    }

    //
    // Release our reference to the root directory RFCB
    //

    if ( rootDirRfcb != NULL ) {
        SrvDereferenceRfcb( rootDirRfcb );
    }

    //
    // If this is a temporary file, don't attempt to cache it.
    //

    if ( rfcb != NULL && (FileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0 ) {

        rfcb->IsCacheable = FALSE;
    }

    //
    // Update the statistics database if the open was successful.
    //

    if ( NT_SUCCESS(status) ) {
        SrvStatistics.TotalFilesOpened++;
    }

    //
    // Make a pointer to the RFCB accessible to the caller.
    //

    WorkContext->Parameters2.Open.Rfcb = rfcb;

    //
    // If there is an oplock break in progress, wait for the oplock
    // break to complete.
    //

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        NTSTATUS startStatus;

        //
        // Save the Information from the open, so it doesn't
        //  get lost when we re-use the WorkContext->Irp for the
        //  oplock processing.
        //
        WorkContext->Parameters2.Open.IosbInformation = WorkContext->Irp->IoStatus.Information;

        startStatus = SrvStartWaitForOplockBreak(
                        WorkContext,
                        RestartRoutine,
                        0,
                        rfcb->Lfcb->FileObject
                        );

        if (!NT_SUCCESS( startStatus ) ) {

            //
            // The file is oplocked, and we cannot wait for the oplock
            // break to complete.  Just close the file, and return the
            // error.
            //

            SrvCloseRfcb( rfcb );
            status = startStatus;

        }

    }

    return status;

} // SrvNtCreateFile

BOOLEAN
SetDefaultPipeMode (
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    This function set the read mode of a newly opened named pipe.  If
    the pipe type is message mode, the read mode is set the message
    mode.

Arguments:

    FileHandle - The client side handle to the named pipe.

Return Value:

    FALSE - Pipe mode is byte mode.
    TRUE  - Pipe mode has been set to message mode.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;

    PAGED_CODE( );

    status = NtQueryInformationFile(
                 FileHandle,
                 &ioStatusBlock,
                 (PVOID)&pipeLocalInformation,
                 sizeof(pipeLocalInformation),
                 FilePipeLocalInformation
                 );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    if ( pipeLocalInformation.NamedPipeType != FILE_PIPE_MESSAGE_TYPE ) {
        return FALSE;
    }

    pipeInformation.ReadMode = FILE_PIPE_MESSAGE_MODE;
    pipeInformation.CompletionMode = FILE_PIPE_QUEUE_OPERATION;

    //
    // ???: is it ok to ignore the return status for this call?
    //

    NtSetInformationFile(
        FileHandle,
        &ioStatusBlock,
        (PVOID)&pipeInformation,
        sizeof(pipeInformation),
        FilePipeInformation
        );

    return TRUE;

}  // SetDefaultPipeMode

BOOLEAN
SrvFailMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return FALSE;
}

BOOLEAN
SrvFailPrepareMdlWriteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\pipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbpipe.c

Abstract:

    This module contains the code for handling named pipe based transact
    SMB's.

    Functions that are handled are:
        SrvCallNamedPipe
        SrvWaitNamedPipe
        SrvQueryInfoNamedPipe
        SrvQueryStateNamedPipe
        SrvSetStateNamedPipe
        SrvPeekNamedPipe
        SrvTransactNamedPipe

Author:

    Manny Weiser (9-18-90)

Revision History:

--*/

#include "precomp.h"
#include "pipe.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_PIPE

STATIC
VOID SRVFASTCALL
RestartCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartFastTransactNamedPipe (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartFastTransactNamedPipe2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCallNamedPipe )
#pragma alloc_text( PAGE, SrvWaitNamedPipe )
#pragma alloc_text( PAGE, SrvQueryStateNamedPipe )
#pragma alloc_text( PAGE, SrvQueryInformationNamedPipe )
#pragma alloc_text( PAGE, SrvSetStateNamedPipe )
#pragma alloc_text( PAGE, SrvPeekNamedPipe )
#pragma alloc_text( PAGE, SrvTransactNamedPipe )
#pragma alloc_text( PAGE, SrvFastTransactNamedPipe )
#pragma alloc_text( PAGE, SrvRawWriteNamedPipe )
#pragma alloc_text( PAGE, SrvReadNamedPipe )
#pragma alloc_text( PAGE, SrvWriteNamedPipe )
#pragma alloc_text( PAGE, RestartCallNamedPipe )
#pragma alloc_text( PAGE, RestartWaitNamedPipe )
#pragma alloc_text( PAGE, RestartPeekNamedPipe )
#pragma alloc_text( PAGE, RestartReadNamedPipe )
#pragma alloc_text( PAGE, RestartTransactNamedPipe )
#pragma alloc_text( PAGE, RestartRawWriteNamedPipe )
#pragma alloc_text( PAGE, RestartFastTransactNamedPipe2 )
#pragma alloc_text( PAGE, RestartWriteNamedPipe )
#pragma alloc_text( PAGE8FIL, RestartFastTransactNamedPipe )
#endif


SMB_TRANS_STATUS
SrvCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Call Named pipe request from a
    Transaction SMB.  This call is handled asynchronously and
    is completed in RestartCallNamedPipe.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PFILE_OBJECT fileObject;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PTRANSACTION transaction;
    NTSTATUS status;
    UNICODE_STRING pipePath;
    UNICODE_STRING fullName;
    FILE_PIPE_INFORMATION pipeInformation;
    PIRP                  irp = WorkContext->Irp;
    PIO_STACK_LOCATION    irpSp;

    PAGED_CODE( );

    //
    //  Strip "\PIPE\" prefix from the path string.
    //

    pipePath = WorkContext->Parameters.Transaction->TransactionName;

    if ( pipePath.Length <=
                (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    pipePath.Buffer +=
        (UNICODE_SMB_PIPE_PREFIX_LENGTH / sizeof(WCHAR)) + 1;
    pipePath.Length -= UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR);

    //
    // Attempt to open the named pipe.
    //

    SrvAllocateAndBuildPathName(
        &SrvNamedPipeRootDirectory,
        &pipePath,
        NULL,
        &fullName
        );

    if ( fullName.Buffer == NULL ) {

        //
        // Unable to allocate heap for the full name.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvCallNamedPipe: Unable to allocate heap for full path name\n" );
        }

        SrvSetSmbError (WorkContext, STATUS_INSUFF_SERVER_RESOURCES);
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &fullName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN,
                 0,                      // Create Options
                 NULL,                   // EA Buffer
                 0,                      // EA Length
                 CreateFileTypeNone,
                 (PVOID)NULL,            // Create parameters
                 IO_FORCE_ACCESS_CHECK,
                 NULL
                 );

    FREE_HEAP( fullName.Buffer );

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if (!NT_SUCCESS(status)) {

        //
        // The server could not open the requested name pipe,
        // return the error.
        //

        IF_SMB_DEBUG(OPEN_CLOSE1) {
            SrvPrint2( "SrvCallNamedPipe: Failed to open %ws, err=%x\n",
                WorkContext->Parameters.Transaction->TransactionName.Buffer, status );
        }
        SrvSetSmbError (WorkContext, status);
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 15, 0 );
    SrvStatistics.TotalFilesOpened++;

    //
    // Get a pointer to the file object, so that we can directly
    // build IRPs for asynchronous operations (read and write).
    // Also, get the granted access mask, so that we can prevent the
    // client from doing things that it isn't allowed to do.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvCallNamedPipe: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Save file handle for the completion routine.
    //

    transaction = WorkContext->Parameters.Transaction;
    transaction->FileHandle = fileHandle;
    transaction->FileObject = fileObject;

    //
    // Set the pipe to message mode, so that we can preform a transceive
    //

    pipeInformation.CompletionMode = FILE_PIPE_QUEUE_OPERATION;
    pipeInformation.ReadMode = FILE_PIPE_MESSAGE_MODE;

    status = NtSetInformationFile (
                fileHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCallNamedPipe: NtSetInformationFile (pipe information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartCallNamedPipe;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Build the IRP to start a pipe transceive.
    // Pass this request to NPFS.
    //

    //
    // Inline SrvBuildIoControlRequest
    //

    {

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = IoGetRelatedDeviceObject(fileObject);
        irpSp->FileObject = fileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = transaction->OutData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    transaction->InData;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength =
                                                    transaction->MaxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                                    transaction->DataCount;
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    (VOID)IoCallDriver(
                irpSp->DeviceObject,
                irp
                );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvCallNamedPipe


SMB_TRANS_STATUS
SrvWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Wait named pipe transaction SMB.
    It issues an asynchronous call to NPFS.  The function
    completetion is handled by RestartWaitNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PFILE_PIPE_WAIT_FOR_BUFFER pipeWaitBuffer;
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    UNICODE_STRING pipePath;
    CLONG nameLength;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Allocate and fill in FILE_PIPE_WAIT_FOR_BUFFER structure.
    //

    pipePath = transaction->TransactionName;

    if ( pipePath.Length <= (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        //
        // The transaction name does not include a pipe name.  It's
        // either \PIPE or \PIPE\, or it doesn't even have \PIPE.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    nameLength = pipePath.Length -
                    (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) +
                    sizeof(WCHAR);

    pipeWaitBuffer = ALLOCATE_NONPAGED_POOL(
                        sizeof(FILE_PIPE_WAIT_FOR_BUFFER) + nameLength,
                        BlockTypeDataBuffer
                        );

    if ( pipeWaitBuffer == NULL ) {

        //
        // We could not allocate space for the buffer to issue the
        // pipe wait.  Fail the request.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvWaitNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Copy the pipe name not including "\PIPE\" to the pipe wait for
    // buffer.
    //

    pipeWaitBuffer->NameLength = nameLength - sizeof(WCHAR);

    RtlCopyMemory(
        pipeWaitBuffer->Name,
        (PUCHAR)pipePath.Buffer + UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR),
        nameLength
        );

    //
    // Fill in the pipe timeout value if necessary.
    //

    if ( SmbGetUlong( &request->Timeout ) == 0 ) {
        pipeWaitBuffer->TimeoutSpecified = FALSE;
    } else {
        pipeWaitBuffer->TimeoutSpecified = TRUE;

        //
        // Convert timeout time from milliseconds to NT relative time.
        //

        pipeWaitBuffer->Timeout.QuadPart = -1 *
            UInt32x32To64( SmbGetUlong( &request->Timeout ), 10*1000 );
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartWaitNamedPipe;

    //
    // Build a Wait named pipe IRP and pass the request to NPFS.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        SrvNamedPipeFileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_WAIT,
        pipeWaitBuffer,
        sizeof(*pipeWaitBuffer) + nameLength,
        NULL,
        0,
        NULL,
        NULL
        );

    (VOID)IoCallDriver( SrvNamedPipeDeviceObject, WorkContext->Irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvWaitNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvWaitNamedPipe


SMB_TRANS_STATUS
SrvQueryStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Query Named pipe transaction SMB.
    Since this call cannot block it is handled synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    USHORT pipeHandleState;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvQueryStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    pipeHandle = rfcb->Lfcb->FileHandle;

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryStateNamedPipe:  NtQueryInformationFile (pipe "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeLocalInformation,
                sizeof(pipeLocalInformation),
                FilePipeLocalInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryStateNamedPipe:  NtQueryInformationFile (pipe local "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Query succeeded generate response
    //

    pipeHandleState = (USHORT)pipeInformation.CompletionMode
                        << PIPE_COMPLETION_MODE_BITS;
    pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                        << PIPE_PIPE_END_BITS;
    pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                        << PIPE_PIPE_TYPE_BITS;
    pipeHandleState |= (USHORT)pipeInformation.ReadMode
                        << PIPE_READ_MODE_BITS;
    pipeHandleState |= (USHORT)((pipeLocalInformation.MaximumInstances
                        << PIPE_MAXIMUM_INSTANCES_BITS)
                            & SMB_PIPE_UNLIMITED_INSTANCES);

    if( transaction->MaxParameterCount < sizeof(USHORT) )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    SmbPutUshort(
        (PSMB_USHORT)WorkContext->Parameters.Transaction->OutParameters,
        pipeHandleState
        );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(pipeHandleState);
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
    return SmbTransStatusSuccess;
} // SrvQueryStateNamedPipe


SMB_TRANS_STATUS
SrvQueryInformationNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function process a Query named pipe information transaction
    SMB.  This call is handled synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    PNAMED_PIPE_INFORMATION_1 namedPipeInfo;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    USHORT level;
    CLONG smbPathLength;
    PUNICODE_STRING pipeName;
    CLONG actualDataSize;
    BOOLEAN returnPipeName;
    BOOLEAN isUnicode;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvQueryStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    lfcb = rfcb->Lfcb;
    pipeHandle = lfcb->FileHandle;

    //
    // The information level is stored in paramter byte one.
    // Verify that is set correctly.
    //

    level = SmbGetUshort( (PSMB_USHORT)transaction->InParameters );

    if ( level != 1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Now check that the response will fit.  If everything expect for
    // the pipe name fits, return STATUS_BUFFER_OVERFLOW with the
    // fixed size portion of the data.
    //
    // *** Note that Unicode strings must be aligned in the SMB.
    //

    pipeName = &lfcb->Mfcb->FileName;

    actualDataSize = sizeof(NAMED_PIPE_INFORMATION_1) - sizeof(UCHAR);

    isUnicode = SMB_IS_UNICODE( WorkContext );
    if ( isUnicode ) {

        ASSERT( sizeof(WCHAR) == 2 );
        actualDataSize = (actualDataSize + 1) & ~1; // align to SHORT
        smbPathLength = (CLONG)(pipeName->Length) + sizeof(WCHAR);

    } else {

        smbPathLength = (CLONG)(RtlUnicodeStringToOemSize( pipeName ));

    }

    actualDataSize += smbPathLength;


    if ( transaction->MaxDataCount <
            FIELD_OFFSET(NAMED_PIPE_INFORMATION_1, PipeName ) ) {
        SrvSetSmbError( WorkContext, STATUS_BUFFER_TOO_SMALL );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    if ( (transaction->MaxDataCount < actualDataSize) ||
         (smbPathLength >= MAXIMUM_FILENAME_LENGTH) ) {

        //
        // Do not return the pipe name.  It won't fit in the return buffer.
        //

        returnPipeName = FALSE;
    } else {
        returnPipeName = TRUE;
    }


    //
    // Everything is correct, ask NPFS for the information.
    //

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeLocalInformation,
                sizeof(pipeLocalInformation),
                FilePipeLocalInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryInformationNamedPipe: NtQueryInformationFile (pipe "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Query succeeded format the response data into the buffer pointed
    // at by transaction->OutData
    //

    namedPipeInfo = (PNAMED_PIPE_INFORMATION_1)transaction->OutData;

    if ((pipeLocalInformation.OutboundQuota & 0xffff0000) != 0) {
        SmbPutAlignedUshort(
            &namedPipeInfo->OutputBufferSize,
            (USHORT)0xFFFF
            );
    } else {
        SmbPutAlignedUshort(
            &namedPipeInfo->OutputBufferSize,
            (USHORT)pipeLocalInformation.OutboundQuota
            );
    }

    if ((pipeLocalInformation.InboundQuota & 0xffff0000) != 0) {
        SmbPutAlignedUshort(
            &namedPipeInfo->InputBufferSize,
            (USHORT)0xFFFF
            );
    } else {
        SmbPutAlignedUshort(
            &namedPipeInfo->InputBufferSize,
            (USHORT)pipeLocalInformation.InboundQuota
            );
    }

    if ((pipeLocalInformation.MaximumInstances & 0xffffff00) != 0) {
        namedPipeInfo->MaximumInstances = (UCHAR)0xFF;
    } else {
        namedPipeInfo->MaximumInstances =
                            (UCHAR)pipeLocalInformation.MaximumInstances;
    }

    if ((pipeLocalInformation.CurrentInstances & 0xffffff00) != 0) {
        namedPipeInfo->CurrentInstances = (UCHAR)0xFF;
    } else {
        namedPipeInfo->CurrentInstances =
                            (UCHAR)pipeLocalInformation.CurrentInstances;
    }

    if ( returnPipeName ) {

        //
        // Copy full pipe path name to the output buffer, appending a NUL.
        //
        // *** Note that Unicode pipe names must be aligned in the SMB.
        //

        namedPipeInfo->PipeNameLength = (UCHAR)smbPathLength;

        if ( isUnicode ) {

            PVOID buffer = ALIGN_SMB_WSTR( namedPipeInfo->PipeName );

            RtlCopyMemory( buffer, pipeName->Buffer, smbPathLength );

        } else {

            UNICODE_STRING source;
            OEM_STRING destination;

            source.Buffer = pipeName->Buffer;
            source.Length = pipeName->Length;
            source.MaximumLength = source.Length;

            destination.Buffer = (PCHAR) namedPipeInfo->PipeName;
            destination.MaximumLength = (USHORT)smbPathLength;

            RtlUnicodeStringToOemString(
                &destination,
                &source,
                FALSE
                );

        }

        transaction->DataCount = actualDataSize;

    } else {

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );
        transaction->DataCount =
            FIELD_OFFSET( NAMED_PIPE_INFORMATION_1, PipeName );

    }

    //
    // Set up to send success response
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );

    if ( returnPipeName) {
        return SmbTransStatusSuccess;
    } else {
        return SmbTransStatusErrorWithData;
    }

} // SrvQueryInformationNamedPipe


SMB_TRANS_STATUS
SrvSetStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a set named pipe handle state transaction
    SMB.  The call is issued synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    USHORT pipeHandleState;
    FILE_PIPE_INFORMATION pipeInformation;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSetStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    pipeHandle = rfcb->Lfcb->FileHandle;

    //
    // The SMB contains 2 parameter bytes.  Translate these to
    // NT format, then attempt to set the named pipe handle state.
    //

    if( transaction->ParameterCount < sizeof(USHORT) )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    pipeHandleState = SmbGetUshort(
                         (PSMB_USHORT)
                           WorkContext->Parameters.Transaction->InParameters
                         );

    pipeInformation.CompletionMode =
        ((ULONG)pipeHandleState >> PIPE_COMPLETION_MODE_BITS) & 1;
    pipeInformation.ReadMode =
        ((ULONG)pipeHandleState >> PIPE_READ_MODE_BITS) & 1;


    status = NtSetInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if (NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSetStateNamedPipe: NetSetInformationFile (pipe information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Success.  Update our internal pipe handle state.
    //

    rfcb->BlockingModePipe =
        (BOOLEAN)(pipeInformation.CompletionMode ==
                                                FILE_PIPE_QUEUE_OPERATION);
    rfcb->ByteModePipe =
        (BOOLEAN)(pipeInformation.ReadMode == FILE_PIPE_BYTE_STREAM_MODE);

    //
    // Now set up for the success response.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
    return SmbTransStatusSuccess;

} // SrvSetStateNamedPipe


SMB_TRANS_STATUS
SrvPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles a peek named pipe transaction SMB.  The
    call is issued asynchrously and is completed by RestartPeekNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    status - The result of the operation.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //
    
    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvPeekNamedPipe: Invalid FID: 0x%lx\n", fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvPeekNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartPeekNamedPipe;

    //
    // Issue the request to NPFS.  We expect both parameters and
    // data to be returned.  The buffer which we offer is contiguous
    // and large enough to contain both.
    //

    transaction = WorkContext->Parameters.Transaction;
    lfcb = rfcb->Lfcb;

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_PEEK,
        transaction->OutParameters,
        0,
        NULL,
        transaction->MaxParameterCount + transaction->MaxDataCount,
        NULL,
        NULL
        );

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The peek was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvPeekNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvPeekNamedPipe


SMB_TRANS_STATUS
SrvTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the transact named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartTransactNamedPipe()

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PIRP irp = WorkContext->Irp;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvTransactStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartTransactNamedPipe;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Inline SrvBuildIoControlRequest
    //

    {

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = rfcb->Lfcb->DeviceObject;
        irpSp->FileObject = rfcb->Lfcb->FileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = transaction->OutData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    transaction->InData;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength =
                                                    transaction->MaxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                                    transaction->DataCount;
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvTransactNamedPipe

BOOLEAN
SrvFastTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT SMB_STATUS * SmbStatus
    )

/*++

Routine Description:

    This function handles the special case of a single buffer transact
    named pipe transaction SMB.  The call to NPFS is issued asynchronously
    and is completed by RestartFastTransactNamedPipe()

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.
    SmbStatus - Status of the transaction.

Return Value:

    TRUE, if fastpath succeeded,
    FALSE, otherwise.  Server must take long path.

--*/

{
    USHORT fid;
    PRFCB rfcb;
    PSESSION session;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PIRP irp = WorkContext->Irp;
    CLONG outputBufferSize;
    CLONG maxParameterCount;
    CLONG maxDataCount;

    PSMB_USHORT inSetup;
    PSMB_USHORT outSetup;
    PCHAR outParam;
    PCHAR outData;
    CLONG offset;
    CLONG setupOffset;

    PREQ_TRANSACTION request;
    PRESP_TRANSACTION response;
    PSMB_HEADER header;

    PAGED_CODE( );

    header = WorkContext->ResponseHeader;
    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    setupOffset = (CLONG)((CLONG_PTR)(request->Buffer) - (CLONG_PTR)header);
    inSetup = (PSMB_USHORT)( (PCHAR)header + setupOffset );

    fid = SmbGetUshort( &inSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvTransactStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
            *SmbStatus = SmbStatusSendResponse;
            return TRUE;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        *SmbStatus = SmbStatusInProgress;
        return TRUE;

    }

    //
    // See and see if all the data will fit into the response buffer.
    // Reject the long path if not the case.
    // The "+1" on the MaxSetupCount calculation below accounts for the
    // USHORT byte count in the buffer.
    //

    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    session = rfcb->Lfcb->Session;
    outputBufferSize = ((maxParameterCount * sizeof(CHAR) + 3) & ~3) +
                       ((maxDataCount * sizeof(CHAR) + 3) & ~3) +
                       (((request->MaxSetupCount + 1) * sizeof(USHORT) + 3) & ~3);

    if ( sizeof(SMB_HEADER) +
            sizeof (RESP_TRANSACTION) +
            outputBufferSize
                    > (ULONG)session->MaxBufferSize) {

        //
        // This won't fit.  Use the long path.
        //

        return(FALSE);
    }

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    //

    if ( SrvReceiveBufferShortage( ) ) {

        SrvStatistics.BlockingSmbsRejected++;

        SrvSetSmbError(
            WorkContext,
            STATUS_INSUFF_SERVER_RESOURCES
            );

        *SmbStatus = SmbStatusSendResponse;
        return TRUE;

    } else {

        //
        // SrvBlockingOpsInProgress has already been incremented.
        // Flag this work item as a blocking operation.
        //

        WorkContext->BlockingOperation = TRUE;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    DEBUG WorkContext->FsdRestartRoutine = NULL;

    //
    // Setup pointers and locals.
    //

    outSetup = (PSMB_USHORT)response->Buffer;

    //
    // The "+1" on the end of the following calculation is to account
    // for the USHORT byte count, which could overwrite data in certain
    // cases should the MaxSetupCount be 0.
    //

    outParam = (PCHAR)(outSetup + (request->MaxSetupCount + 1));
    offset = (CLONG)((outParam - (PCHAR)header + 3) & ~3);
    outParam = (PCHAR)header + offset;

    outData = outParam + maxParameterCount;
    offset = (CLONG)((outData - (PCHAR)header + 3) & ~3);
    outData = (PCHAR)header + offset;

    //
    // Fill in the work context parameters.
    //

    WorkContext->Parameters.FastTransactNamedPipe.OutSetup = outSetup;
    WorkContext->Parameters.FastTransactNamedPipe.OutParam = outParam;
    WorkContext->Parameters.FastTransactNamedPipe.OutData = outData;

    //
    // Inline SrvBuildIoControlRequest
    //

    {
        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            RestartFastTransactNamedPipe,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = rfcb->Lfcb->DeviceObject;
        irpSp->FileObject = rfcb->Lfcb->FileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = outData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                    (PCHAR)header + SmbGetUshort( &request->DataOffset );

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength = maxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                    SmbGetUshort( &request->DataCount );
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
    *SmbStatus = SmbStatusInProgress;
    return TRUE;

} // SrvFastTransactNamedPipe


SMB_TRANS_STATUS
SrvRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw write named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawWriteNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    NTSTATUS status;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvRawWriteStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvRawWriteNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // We only allow the special 0 bytes message mode write.  Otherwise
    // reject the request.
    //

    if ( transaction->DataCount != 2 ||
         transaction->InData[0] != 0 ||
         transaction->InData[1] != 0 ||
         rfcb->ByteModePipe ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartRawWriteNamedPipe;

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_WRITE,
        transaction->InData,
        0,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // Pass the request to NPFS.
    //

    IoCallDriver( rfcb->Lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvRawWriteNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvRawWriteNamedPipe


VOID SRVFASTCALL
RestartCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvCallNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;
    transaction = WorkContext->Parameters.Transaction;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "RestartCallNamedPipe:  Pipe transceive failed: %X\n",
                        status );
        }
        SrvSetSmbError( WorkContext, status );

    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction->SetupCount = 0;
        transaction->ParameterCount = 0;
        transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    }

    //
    // Close the open pipe handle.
    //

    SRVDBG_RELEASE_HANDLE( transaction->FileHandle, "FIL", 19, transaction );
    SrvNtClose( transaction->FileHandle, TRUE );
    ObDereferenceObject( transaction->FileObject );

    //
    // Respond to the client
    //

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else if ( status == STATUS_BUFFER_OVERFLOW ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    } else {
        IF_DEBUG(ERRORS) SrvPrint1( "Pipe call failed: %X\n", status );
        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCallNamedPipe complete\n" );
    return;

} // RestartCallNamedPipe


VOID SRVFASTCALL
RestartWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvWaitNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Deallocate the wait buffer.
    //

    DEALLOCATE_NONPAGED_POOL( WorkContext->Irp->AssociatedIrp.SystemBuffer );

    //
    // If the wait request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) SrvPrint1( "Pipe wait failed: %X\n", status );
        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartWaitNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Prepare to generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    //
    // Generate and send the response.
    //

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    IF_DEBUG(TRACE2) SrvPrint0( "RestartWaitNamedPipe complete\n" );
    return;

} // RestartWaitNamedPipe


VOID SRVFASTCALL
RestartPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for PeekNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;
    PRESP_PEEK_NMPIPE respPeekNmPipe;
    USHORT readDataAvailable, messageLength, namedPipeState;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the peek request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe peek failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartPeekNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //
    // The parameter bytes are currently in the format returned by NT.
    // we will reformat them, and leave the extra space between the
    // parameter and data bytes as extra pad.
    //

    //
    // Since the NT and SMB formats overlap
    //   First read all the parameters into locals...
    //

    transaction = WorkContext->Parameters.Transaction;
    pipePeekBuffer = (PFILE_PIPE_PEEK_BUFFER)transaction->OutParameters;

    readDataAvailable = (USHORT)pipePeekBuffer->ReadDataAvailable;
    messageLength = (USHORT)pipePeekBuffer->MessageLength;
    namedPipeState = (USHORT)pipePeekBuffer->NamedPipeState;

    //
    // ... then copy them back in the new format.
    //

    respPeekNmPipe = (PRESP_PEEK_NMPIPE)pipePeekBuffer;
    SmbPutAlignedUshort(
        &respPeekNmPipe->ReadDataAvailable,
        readDataAvailable
        );
    SmbPutAlignedUshort(
        &respPeekNmPipe->MessageLength,
        messageLength
        );
    SmbPutAlignedUshort(
        &respPeekNmPipe->NamedPipeState,
        namedPipeState
        );

    //
    // Send the response.  Set the output counts.
    //
    // NT return to us 4 ULONGS of parameter bytes, followed by data.
    // We return to the client 6 parameter bytes.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 6;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information -
                                        (4 * sizeof(ULONG));

    if (NT_SUCCESS(status)) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }
    IF_DEBUG(TRACE2) SrvPrint0( "RestartPeekNamedPipe complete\n" );
    return;

} // RestartPeekNamedPipe


VOID SRVFASTCALL
RestartTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvTransactNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

#if 0
        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }
#else

        //
        // os/2 returns ERROR_MORE_DATA in this case, why we convert
        // this to NO_ERROR is a mystery.
        //

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );
#endif

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        SrvSetSmbError(WorkContext, status);
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
    return;

} // RestartTransactNamedpipe


NTSTATUS
RestartFastTransactNamedPipe (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvFastTransactNamedPipe

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    NTSTATUS status;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramOffset;
    PCHAR dataPtr;
    CLONG dataOffset;
    CLONG dataLength;
    CLONG sendLength;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // os/2 returns ERROR_MORE_DATA in this case, why we convert
        // this to NO_ERROR is a mystery.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = RestartFastTransactNamedPipe2;
            QUEUE_WORK_TO_FSP( WorkContext );
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        RestartFastTransactNamedPipe2( WorkContext );
        goto error_no_data;
    }

    //
    // Success.  Generate and send the response.
    //

    dataLength = (CLONG)WorkContext->Irp->IoStatus.Information;

    header = WorkContext->ResponseHeader;

    //
    // Save a pointer to the byte count field.
    //
    // If the output data and parameters are not already in the SMB
    // buffer we must calculate how much of the parameters and data can
    // be sent in this response.  The maximum amount we can send is
    // minimum of the size of our buffer and the size of the client's
    // buffer.
    //
    // The parameter and data byte blocks are aligned on longword
    // boundaries in the message.
    //

    byteCountPtr = WorkContext->Parameters.FastTransactNamedPipe.OutSetup;

    //
    // The data and paramter are already in the SMB buffer.  The entire
    // response will fit in one response buffer and there is no copying
    // to do.
    //

    paramPtr = WorkContext->Parameters.FastTransactNamedPipe.OutParam;
    paramOffset = (CLONG)(paramPtr - (PCHAR)header);

    dataPtr = WorkContext->Parameters.FastTransactNamedPipe.OutData;
    dataOffset = (CLONG)(dataPtr - (PCHAR)header);

    //
    // The client wants a response.  Build the first (and possibly only)
    // response.  The last received SMB of the transaction request was
    // retained for this purpose.
    //

    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Build the parameters portion of the response.
    //

    response->WordCount = (UCHAR)10;
    SmbPutUshort( &response->TotalParameterCount,
                  (USHORT)0
                  );
    SmbPutUshort( &response->TotalDataCount,
                  (USHORT)dataLength
                  );
    SmbPutUshort( &response->Reserved, 0 );
    response->SetupCount = (UCHAR)0;
    response->Reserved2 = 0;

    //
    // We need to be sure we're not sending uninitialized kernel memory
    // back to the client with the response, so zero out the range between
    // byteCountPtr and dataPtr.
    //

    RtlZeroMemory(byteCountPtr,(ULONG)(dataPtr - (PCHAR)byteCountPtr));

    //
    // Finish filling in the response parameters.
    //

    SmbPutUshort( &response->ParameterCount, (USHORT)0 );
    SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
    SmbPutUshort( &response->ParameterDisplacement, 0 );

    SmbPutUshort( &response->DataCount, (USHORT)dataLength );
    SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
    SmbPutUshort( &response->DataDisplacement, 0 );

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the response.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );

error_no_data:

    //
    // The response send is in progress.  The caller will assume
    // the we will handle send completion.
    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartFastTransactNamedPipe


VOID SRVFASTCALL
RestartFastTransactNamedPipe2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvFastTransactNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // The transceive request failed.  Set an error status in the response
    // header.
    //

    SrvSetSmbError( WorkContext, WorkContext->Irp->IoStatus.Status );

    //
    // An error occurred, so no transaction-specific response data
    // will be returned.
    //
    // Calculate the length of the response message.
    //


    WorkContext->ResponseBuffer->DataLength =
                 (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                            (PCHAR)WorkContext->ResponseHeader );

    //
    // Send the response.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );

    return;

} // RestartFastTransactNamedPipe2


VOID SRVFASTCALL
RestartRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawWriteNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe raw write failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartRawWriteNamedPipe complete\n" );
        return;

    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    transaction->DataCount = 0;

    SmbPutUshort( (PSMB_USHORT)transaction->OutParameters, 2 );

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);

    IF_DEBUG(TRACE2) SrvPrint0( "RestartRawWriteNamedPipe complete\n" );
    return;

} // RestartRawWriteNamedpipe


SMB_TRANS_STATUS
SrvWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw write named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawWriteNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    LARGE_INTEGER offset;
    ULONG key = 0;
    PCHAR writeAddress;
    CLONG writeLength;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvWriteNamedPipe: fid = %x length = %d\n",
                fid, transaction->DataCount));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvWriteNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvWriteNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    lfcb = rfcb->Lfcb;
    writeLength = transaction->DataCount;
    writeAddress = transaction->InData;

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //

                RestartWriteNamedPipe( WorkContext );

                IF_DEBUG(IPX_PIPES) SrvPrint0( "SrvWriteNamedPipe complete.\n" );
                return SmbTransStatusInProgress;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvWriteNamedPipe: Using slow path.\n"));
    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // Build the PIPE_INTERNAL_WRITE IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_WRITE,
        writeAddress,
        writeLength,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartWriteNamedPipe;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // RestartWriteNamedPipe when the write completes.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvWriteNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvWriteNamedPipe

VOID SRVFASTCALL
RestartWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawWriteNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIO_STATUS_BLOCK iosb;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    iosb = &WorkContext->Irp->IoStatus;
    status = iosb->Status;

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("RestartWriteNamedPipe: Status = %x\n", status));
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( " pipe write failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartWriteNamedPipe complete\n" );
        return;

    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    transaction->DataCount = 0;

    SmbPutUshort( (PSMB_USHORT)transaction->OutParameters,
                    (USHORT)iosb->Information
                    );

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);

    IF_DEBUG(TRACE2) SrvPrint0( "RestartWriteNamedPipe complete\n" );
    return;

} // RestartWriteNamedPipe

SMB_TRANS_STATUS
SrvReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw Read named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawReadNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    LARGE_INTEGER offset;
    ULONG key = 0;
    PCHAR readAddress;
    CLONG readLength;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    if( transaction->SetupCount < sizeof(USHORT)*2 )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &transaction->InSetup[1] );

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvReadNamedPipe: fid = %x length = %d\n",
                fid, transaction->MaxDataCount));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw Read
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvReadNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvReadNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw Read is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    lfcb = rfcb->Lfcb;
    readLength = transaction->MaxDataCount;
    readAddress = transaction->OutData;

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //

                RestartReadNamedPipe( WorkContext );

                IF_SMB_DEBUG(READ_WRITE2) SrvPrint0( "SrvReadNamedPipe complete.\n" );
                return SmbTransStatusInProgress;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the Read request, reusing the
    // receive IRP.
    //
    // Build the PIPE_INTERNAL_READ IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_READ,
        readAddress,
        0,
        NULL,
        readLength,
        NULL,
        NULL
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartReadNamedPipe;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The Read has been started.  Control will return to
    // SrvFsdRestartRead when the Read completes.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvReadNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvReadNamedPipe


VOID SRVFASTCALL
RestartReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawReadNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        SrvSetSmbError(WorkContext, status);
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartReadNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartReadNamedPipe complete\n" );
    return;

} // RestartReadNamedPipe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\move.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    move.c

Abstract:

    This module contains the routine to rename or copy a file.  This
    routine is used by the routines SrvSmbRenameFile,
    SrvSmbRenameFileExtended, and SrvSmbCopyFile.

Author:

    David Treadwell (davidtr) 22-Jan-1990

Revision History:

--*/

#include "precomp.h"
#include "move.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_MOVE

NTSTATUS
DoCopy (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags
    );

NTSTATUS
DoRename (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvMoveFile )
#pragma alloc_text( PAGE, DoCopy )
#pragma alloc_text( PAGE, DoRename )
#endif


NTSTATUS
SrvMoveFile(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN OUT PUSHORT SmbFlags,
    IN USHORT SmbSearchAttributes,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount,
    IN PUNICODE_STRING Source,
    IN OUT PUNICODE_STRING Target
    )

/*++

Routine Description:

    This routine moves a file, which may be a copy or a rename.

Arguments:

    WorkContext - a pointer to the work context block for the operation.  The
        Session, TreeConnect, and RequestHeader fields are used.

    TargetShare - a pointer to the share on which the target should
        be.  The RootDirectoryHandle field is used to do relative opens.

    SmbOpenFunction - the "OpenFunction" field of the request SMB.  This
        parameter is used to determine what should be done if the target
        file does or does not exist.

    SmbFlags - a pointer to the "Flags" field of the request SMB.  This
        parameter is used to determine whether we know that the target
        is supposed to be a file or directory.  In addition, if this has
        no information about the target, it is set to reflect whether
        the target was a directory or file.  This is useful when doing
        multiple renames or copies as a result of wildcards--move a*.* b
        might call this routine many times, and if b is a directory,
        this routine will set this parameter appropiately such that if
        does not have to reopen the directory for each move.

    SmbSearchAttributes - the search attributes specified in the request
        SMB.  The attributes on the source file are checked against
        these to make sure that the move can be done.

    FailIfTargetIsDirectory - if TRUE and the target already exists as
        a directory, fail the operation.  Otherwise, rename the file
        into the directory.

    InformationLevel - Move/Rename/CopyOnWrite/Link/MoveCluster

    ClusterCount - MoveCluster count

    Source - a pointer to a string describing the name of the source file
        relative to the share directory in which it is located.

    Target - a pathname to the target file.  This may contain directory
        information--it should be the raw information from the SMB,
        unadulterated by the SMB processing routine except for
        canonicalization.  This name may end in a directory name, in
        which case the source name is used as the filename.

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    HANDLE sourceHandle;
    BOOLEAN isCompatibilityOpen;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PLFCB lfcb;

    OBJECT_ATTRIBUTES sourceObjectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG sourceAccess = 0;
    BOOLEAN isNtRename;
    ULONG hashValue;

    PSESSION session;
    PSHARE sourceShare;

    PSRV_LOCK mfcbLock;

    PAGED_CODE( );

    IF_SMB_DEBUG(FILE_CONTROL2) SrvPrint0( "SrvMoveFile entered.\n" );

    //
    // Set handles and pointers to NULL so we know how to clean up on
    // exit.
    //

    sourceHandle = NULL;
    isCompatibilityOpen = FALSE;
    lfcb = NULL;
    //mfcb = NULL;     // not really necessary--SrvFindMfcb sets it correctly

    //
    // Set up the block pointers that will be needed.
    //

    session = WorkContext->Session;
    sourceShare = WorkContext->TreeConnect->Share;

    isNtRename = (BOOLEAN)(WorkContext->RequestHeader->Command == SMB_COM_NT_RENAME);

    //
    // See if we already have this file open in compatibility mode.  If
    // we do, and this session owns it, then we must use that open
    // handle and, if this is a rename, close all the handles when we
    // are done.
    //
    // *** SrvFindMfcb references the MFCB--remember to dereference it.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
         WorkContext->Session->UsingUppercasePaths ) {
        mfcb = SrvFindMfcb( Source, TRUE, &mfcbLock, &hashValue, WorkContext );
    } else {
        mfcb = SrvFindMfcb( Source, FALSE, &mfcbLock, &hashValue, WorkContext );
    }

    if ( mfcb != NULL ) {
        nonpagedMfcb = mfcb->NonpagedMfcb;
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );
    }

    if( mfcbLock ) {
        RELEASE_LOCK( mfcbLock );
    }

    if ( mfcb == NULL || !mfcb->CompatibilityOpen ) {

        //
        // Either the file wasn't opened by the server or it was not
        // a compatibility/FCB open, so open it here.
        //
        // Release the open lock--we don't need it any more.
        //

        if ( mfcb != NULL ) {
            RELEASE_LOCK( &nonpagedMfcb->Lock );
        }

        //
        // Use DELETE access for a rename, and the appropriate copy access
        // for Copy/Link/Move/MoveCluster.
        //

        switch (InformationLevel) {
        case SMB_NT_RENAME_RENAME_FILE:
            sourceAccess = DELETE;
            break;

        case SMB_NT_RENAME_MOVE_CLUSTER_INFO:
            sourceAccess = SRV_COPY_TARGET_ACCESS & ~(WRITE_DAC | WRITE_OWNER);
            break;

        case SMB_NT_RENAME_SET_LINK_INFO:
        case SMB_NT_RENAME_MOVE_FILE:
            sourceAccess = SRV_COPY_SOURCE_ACCESS;
            break;

        default:
            ASSERT(FALSE);
        }

        SrvInitializeObjectAttributes_U(
            &sourceObjectAttributes,
            Source,
            (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "Opening source: %wZ\n",
                          sourceObjectAttributes.ObjectName );
        }

        //
        // Open the source file.  We allow read access for other processes.
        //

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &sourceHandle,
                     sourceAccess | SYNCHRONIZE,            // DesiredAccess
                     &sourceObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     FILE_OPEN,                             // Disposition
                     FILE_SYNCHRONOUS_IO_NONALERT           // CreateOptions
                        | FILE_OPEN_REPARSE_POINT
                        | FILE_OPEN_FOR_BACKUP_INTENT,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     WorkContext->TreeConnect->Share
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &sourceHandle,
                         sourceAccess | SYNCHRONIZE,            // DesiredAccess
                         &sourceObjectAttributes,
                         &ioStatusBlock,
                         NULL,                                  // AllocationSize
                         0,                                     // FileAttributes
                         FILE_SHARE_READ,                       // ShareAccess
                         FILE_OPEN,                             // Disposition
                         FILE_SYNCHRONOUS_IO_NONALERT
                            | FILE_OPEN_FOR_BACKUP_INTENT,      // CreateOptions
                         NULL,                                  // EaBuffer
                         0,                                     // EaLength
                         CreateFileTypeNone,                    // File type
                         NULL,                                  // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,                 // Options
                         WorkContext->TreeConnect->Share
                         );
        }

        if ( NT_SUCCESS(status) ) {

            SRVDBG_CLAIM_HANDLE( sourceHandle, "MOV", 4, 0 );

        } else if ( status == STATUS_ACCESS_DENIED ) {

            //
            // If the user didn't have this permission, update the statistics
            // database.
            //
            SrvStatistics.AccessPermissionErrors++;
        }

        ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvMoveFile: SrvIoCreateFile failed (source): %X\n",
                              status );
            }

            goto exit;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "SrvIoCreateFile succeeded (source), handle = 0x%p\n",
                          sourceHandle );
        }

        SrvStatistics.TotalFilesOpened++;

    } else {

        //
        // The file was opened by the server in compatibility mode or as
        // an FCB open.
        //

        lfcb = CONTAINING_RECORD( mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        //
        // Make sure that the session which sent this request is the
        // same as the one which has the file open.
        //

        if ( lfcb->Session != session ) {

            //
            // A different session has the file open in compatibility
            // mode, so reject the request.
            //

            status = STATUS_ACCESS_DENIED;
            RELEASE_LOCK( &nonpagedMfcb->Lock );

            goto exit;
        }

        //
        // Set isCompatibilityOpen so that we'll know on exit to close
        // all the open instances of this file.
        //

        isCompatibilityOpen = TRUE;

        sourceHandle = lfcb->FileHandle;
        sourceAccess = lfcb->GrantedAccess;

    }

    //
    // Make sure that the search attributes jive with the attributes
    // on the file.
    //

    status = SrvCheckSearchAttributesForHandle( sourceHandle, SmbSearchAttributes );

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // If the target has length 0, then it is the share root, which must
    // be a directory.  If the target is supposed to be a file, fail,
    // otherwise indicate that the target is a directory.
    //

    if ( Target->Length == 0 ) {

        if ( *SmbFlags & SMB_TARGET_IS_FILE ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;
    }

    //
    // We now have the source file open.  Call the appropriate routine
    // to rename or copy the file.
    //

    if (InformationLevel != SMB_NT_RENAME_MOVE_FILE) {

        status = DoRename(
                     WorkContext,
                     Source,
                     sourceHandle,
                     Target,
                     TargetShare,
                     SmbOpenFunction,
                     SmbFlags,
                     FailIfTargetIsDirectory,
                     InformationLevel,
                     ClusterCount
                     );

    } else {

        FILE_BASIC_INFORMATION fileBasicInformation;

        //
        // Check whether this is a tree copy request.  If so, allow it only if
        // this is a single file copy operation.
        //

        if ( (*SmbFlags & SMB_COPY_TREE) != 0 ) {

            //
            // Get the attributes on the file.
            //

            status = SrvQueryBasicAndStandardInformation(
                                                    sourceHandle,
                                                    NULL,
                                                    &fileBasicInformation,
                                                    NULL
                                                    );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvMoveFile: NtQueryInformationFile (basic "
                        "information) returned %X",
                    NULL,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                goto exit;
            }

            if ( ( fileBasicInformation.FileAttributes &
                   FILE_ATTRIBUTE_DIRECTORY ) != 0 ) {

                //
                // Fail this copy.
                //

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "Tree copy not implemented.",
                    NULL,
                    NULL
                    );
                status = STATUS_NOT_IMPLEMENTED;
                goto exit;
            }

        }

        status = DoCopy(
                     WorkContext,
                     Source,
                     sourceHandle,
                     Target,
                     TargetShare,
                     SmbOpenFunction,
                     SmbFlags
                     );
    }

exit:

    if ( sourceHandle != NULL && !isCompatibilityOpen ) {
        SRVDBG_RELEASE_HANDLE( sourceHandle, "MOV", 9, 0 );
        SrvNtClose( sourceHandle, TRUE );
    } else if (isCompatibilityOpen &&
               InformationLevel == SMB_NT_RENAME_RENAME_FILE) {
        SrvCloseRfcbsOnLfcb( lfcb );
    }

    //
    // If the file is open in compatibility mode, then we have held the
    // MFCB lock all along.  Release it now.
    //

    if ( isCompatibilityOpen ) {
        RELEASE_LOCK( &nonpagedMfcb->Lock );
    }

    if ( mfcb != NULL ) {
        SrvDereferenceMfcb( mfcb );
    }

    return status;

} // SrvMoveFile


NTSTATUS
DoCopy (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags
    )

/*++

Routine Description:

    This routine sets up for a call to SrvCopyFile.  It opens the target,
    determining, if necessary, whether the target is a file or directory.
    If this information is unknown, it writes it into the SmbFlags
    location.

Arguments:

    WorkContext - a pointer to the work context block for the operation.
        The session pointer is used, and the block itself is used for
        an impersonation.

    Source - the name of the source file relative to its share.

    SourceHandle - the handle to the source file.

    Target - the name of the target file relative to its share.

    TargetShare - the share of the target file.  The RootDirectoryHandle
        field is used for a relative rename.

    SmbOpenFunction - describes whether we are allowed to overwrite an
        existing file, or we should append to existing files.

    SmbFlags - can tell if the target is a file, directory, or unknown.
        This routine writes the true information into the location if
        it is unknown.

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG createDisposition;
    UNICODE_STRING sourceBaseName;
    BOOLEAN create;

    HANDLE targetHandle = NULL;
    OBJECT_ATTRIBUTES targetObjectAttributes;
    UNICODE_STRING targetName;

    PAGED_CODE( );

    //
    // Set the buffer field of targetName to NULL so that we'll know
    // if we have to deallocate it at the end.
    //

    targetName.Buffer = NULL;

    //
    // Open the target file.  If we know that it is a directory, generate
    // the full file name.  Otherwise, open the target as a file.
    //

    SrvInitializeObjectAttributes_U(
        &targetObjectAttributes,
        Target,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         WorkContext->Session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Determine the create disposition from the open function.
    //

    create = SmbOfunCreate( SmbOpenFunction );

    if ( SmbOfunTruncate( SmbOpenFunction ) ) {
        createDisposition = create ? FILE_OVERWRITE_IF : FILE_OVERWRITE;
    } else if ( SmbOfunAppend( SmbOpenFunction ) ) {
        createDisposition = create ? FILE_OPEN_IF : FILE_OPEN;
    } else {
        createDisposition = FILE_CREATE;
    }

    //
    // If we know that the target is a directory, generate the real target
    // name.
    //

    if ( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) {

        SrvGetBaseFileName( Source, &sourceBaseName );

        SrvAllocateAndBuildPathName(
            Target,
            &sourceBaseName,
            NULL,
            &targetName
            );

        if ( targetName.Buffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto copy_done;
        }

        targetObjectAttributes.ObjectName = &targetName;
    }

    IF_SMB_DEBUG(FILE_CONTROL2) {
        SrvPrint1( "Opening target: %wZ\n", targetObjectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // !!! Currently we can't specify complete if oplocked, because
    //     this won't break a batch oplock.  Unfortunately this also
    //     means that we can't timeout the open (if the oplock break
    //     takes too long) and fail this SMB gracefully.
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &targetHandle,
                 SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                 &targetObjectAttributes,
                 &ioStatusBlock,
                 NULL,                                  // AllocationSize
                 0,                                     // FileAttributes
                 FILE_SHARE_READ,                       // ShareAccess
                 createDisposition,
                 FILE_NON_DIRECTORY_FILE |              // CreateOptions
                    FILE_OPEN_REPARSE_POINT |
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    // | FILE_COMPLETE_IF_OPLOCKED,
                 NULL,                                  // EaBuffer
                 0,                                     // EaLength
                 CreateFileTypeNone,                    // File type
                 NULL,                                  // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                 // Options
                 TargetShare
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &targetHandle,
                     SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                     &targetObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     createDisposition,
                     FILE_NON_DIRECTORY_FILE |              // CreateOptions
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        // | FILE_COMPLETE_IF_OPLOCKED,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     TargetShare
                     );
    }


    //
    // If the open failed because the target is a directory, and we didn't
    // know that it was supposed to be a file, then concatenate the
    // source base name to the target and retry the open.
    //
    // !!! NOT THE CORRECT STATUS CODE.  It should be something like
    //     STATUS_FILE_IS_DIRECTORY.

    if ( status == STATUS_INVALID_PARAMETER &&
         !( *SmbFlags & SMB_TARGET_IS_FILE ) &&
         !( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) ) {

        //
        // Set the flags so that future calls to this routine will do
        // the right thing first time around.
        //

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;

        SrvGetBaseFileName( Source, &sourceBaseName );

        SrvAllocateAndBuildPathName(
            Target,
            &sourceBaseName,
            NULL,
            &targetName
            );

        if ( targetName.Buffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto copy_done;
        }

        targetObjectAttributes.ObjectName = &targetName;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "Opening target: %wZ\n", targetObjectAttributes.ObjectName );
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &targetHandle,
                     SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                     &targetObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     createDisposition,
                     FILE_NON_DIRECTORY_FILE |              // CreateOptions
                        FILE_OPEN_REPARSE_POINT |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File Type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     TargetShare
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &targetHandle,
                         SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                         &targetObjectAttributes,
                         &ioStatusBlock,
                         NULL,                                  // AllocationSize
                         0,                                     // FileAttributes
                         FILE_SHARE_READ,                       // ShareAccess
                         createDisposition,
                         FILE_NON_DIRECTORY_FILE |              // CreateOptions
                            FILE_SYNCHRONOUS_IO_NONALERT,
                         NULL,                                  // EaBuffer
                         0,                                     // EaLength
                         CreateFileTypeNone,                    // File Type
                         NULL,                                  // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,                 // Options
                         TargetShare
                         );
        }

    }

    if ( targetHandle != NULL ) {
        SRVDBG_CLAIM_HANDLE( targetHandle, "CPY", 5, 0 );
    }

    //
    // Is the target is a directory, and the copy move is append if exists,
    // create if the file does not exist, fail the request.  We must do
    // this, because we have no way of knowing whether the original request
    // expects us append to the file, or truncate it.
    //

    if ( (*SmbFlags & SMB_TARGET_IS_DIRECTORY) &&
         ((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_OPEN) &&
         ((SmbOpenFunction & SMB_OFUN_CREATE_MASK) == SMB_OFUN_CREATE_CREATE)) {

        status = STATUS_OS2_CANNOT_COPY;
        goto copy_done;

    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "Unable to open target: %X\n", status );
        }

        goto copy_done;
    }

    SrvStatistics.TotalFilesOpened++;

    //
    // Copy the source to the target handle just opened.
    //

    status = SrvCopyFile(
                 SourceHandle,
                 targetHandle,
                 SmbOpenFunction,
                 *SmbFlags,
                 (ULONG)ioStatusBlock.Information          // TargetOpenAction
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCopyFile failed, status = %X\n", status );
        }
    }

copy_done:

    if ( targetName.Buffer != NULL ) {
        FREE_HEAP( targetName.Buffer );
    }

    if ( targetHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( targetHandle, "CPY", 10, 0 );
        SrvNtClose( targetHandle, TRUE );
    }

    return status;

} // DoCopy


NTSTATUS
DoRename (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN OUT PUSHORT SmbFlags,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount
    )

/*++

Routine Description:

    This routine does the actual rename of an open file.  The target may
    be a file or directory, but is bound by the constraints of SmbFlags.
    If SmbFlags does not indicate what the target is, then it is first
    assumed to be a file; if this fails, then the rename if performed
    again with the target as the original target string plus the source
    base name.

    *** If the source and target are on different volumes, then this
        routine will fail.  We could make this work by doing a copy
        then delete, but this seems to be of limited usefulness and
        possibly incorrect due to the fact that a big file would take
        a long time, something the user would not expect.

Arguments:

    WorkContext - a pointer to the work context block for this operation
        used for an impersonation.

    Source - the name of the source file relative to its share.

    SourceHandle - the handle to the source file.

    Target - the name of the target file relative to its share.

    TargetShare - the share of the target file.  The RootDirectoryHandle
        field is used for a relative rename.

    SmbOpenFunction - describes whether we are allowed to overwrite an
        existing file.

    SmbFlags - can tell if the target is a file, directory, or unknown.
        This routine writes the true information into the location if
        it is unknown.

    FailIfTargetIsDirectory - if TRUE and the target already exists as
        a directory, fail the operation.  Otherwise, rename the file
        into the directory.

    InformationLevel - Rename/CopyOnWrite/Link/MoveCluster

    ClusterCount - MoveCluster count

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_RENAME_INFORMATION fileRenameInformation;
    ULONG renameBlockSize;
    USHORT NtInformationLevel;
    UNICODE_STRING sourceBaseName;
    UNICODE_STRING targetBaseName;
    PWCH s, es;

    PAGED_CODE( );

    //
    // Allocate enough heap to hold a FILE_RENAME_INFORMATION block and
    // the target file name.  Allocate enough extra to hold the source
    // name in case the target turns out to be a directory and we have
    // to concatenate the source and target.
    //

    renameBlockSize = sizeof(FILE_RENAME_INFORMATION) + Target->Length +
                          Source->Length;

    fileRenameInformation = ALLOCATE_HEAP_COLD(
                                renameBlockSize,
                                BlockTypeDataBuffer
                                );

    if ( fileRenameInformation == NULL ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvMoveFile: Unable to allocate heap.\n" );
        }

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Get the Share root handle.
    //

    status = SrvGetShareRootHandle( TargetShare );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "DoRename: SrvGetShareRootHandle failed. %X\n", status );
        }

        FREE_HEAP( fileRenameInformation );
        return(status);
    }

    //
    // Set up the rename block.
    //

    if (InformationLevel == SMB_NT_RENAME_MOVE_CLUSTER_INFO) {
        ((FILE_MOVE_CLUSTER_INFORMATION *)fileRenameInformation)->ClusterCount =
            ClusterCount;
    } else {
        fileRenameInformation->ReplaceIfExists =
            SmbOfunTruncate( SmbOpenFunction );
    }

    fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

    //
    // If the target file has wildcards, expand name.
    //

    if ( FsRtlDoesNameContainWildCards( Target ) ) {

        ULONG tempUlong;
        UNICODE_STRING newTargetBaseName;

        if (InformationLevel != SMB_NT_RENAME_RENAME_FILE) {
            FREE_HEAP( fileRenameInformation );
            return(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        //
        // Get source and target filenames.  The target filename is to be
        // used as a template for wildcard expansion.
        //

        SrvGetBaseFileName( Source, &sourceBaseName );
        SrvGetBaseFileName( Target, &targetBaseName );

        tempUlong = sourceBaseName.Length + targetBaseName.Length;
        newTargetBaseName.Length = (USHORT)tempUlong;
        newTargetBaseName.MaximumLength = (USHORT)tempUlong;
        newTargetBaseName.Buffer = ALLOCATE_NONPAGED_POOL(
                                            tempUlong,
                                            BlockTypeDataBuffer
                                            );

        if ( newTargetBaseName.Buffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "DoRename: Unable to allocate %d bytes from nonpaged pool.\n",
                tempUlong,
                NULL
                );

            //
            // Release the share root handle if device is removable
            //

            SrvReleaseShareRootHandle( TargetShare );

            FREE_HEAP( fileRenameInformation );
            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        //
        // Get expanded filename
        //

        status = SrvWildcardRename(
                    &targetBaseName,
                    &sourceBaseName,
                    &newTargetBaseName
                    );

        if ( !NT_SUCCESS( status ) ) {

            //
            // Release the share root handle if device is removable
            //

            SrvReleaseShareRootHandle( TargetShare );

            DEALLOCATE_NONPAGED_POOL( newTargetBaseName.Buffer );
            FREE_HEAP( fileRenameInformation );
            return STATUS_OBJECT_NAME_INVALID;

        }

        //
        // tempUlong is equal to the directory path without this filename
        // but including the last delimeter.
        //

        tempUlong = Target->Length - targetBaseName.Length;

        //
        // Copy the directory path (including the delimeter.
        //

        RtlCopyMemory(
            fileRenameInformation->FileName,
            Target->Buffer,
            tempUlong
            );

        s = (PWCH) ((PCHAR)fileRenameInformation->FileName + tempUlong);

        //
        // Copy the expanded file name
        //

        RtlCopyMemory(
            s,
            newTargetBaseName.Buffer,
            newTargetBaseName.Length
            );


        fileRenameInformation->FileNameLength = tempUlong +
                                                newTargetBaseName.Length;

        DEALLOCATE_NONPAGED_POOL( newTargetBaseName.Buffer );

    } else {

        fileRenameInformation->FileNameLength = Target->Length;

        RtlCopyMemory(
            fileRenameInformation->FileName,
            Target->Buffer,
            Target->Length
            );

        // Check if we can do a fast rename if they are in the same path (which is usually the case)
        SrvGetBaseFileName( Source, &sourceBaseName );
        SrvGetBaseFileName( Target, &targetBaseName );


       if ((Source->Length - sourceBaseName.Length) == (Target->Length - targetBaseName.Length)) {
          ULONG i;
          PWCH sptr,tptr;

          i = Source->Length - sourceBaseName.Length;
          i=i>>1;

          sptr = &Source->Buffer[i-1];
          tptr = &Target->Buffer[i-1];

          while ( i > 0) {
             if (*sptr-- != *tptr--) {
                goto no_match;
             }
             i--;
          }

          // If the names matched, we're set for a quick rename (where the directory is not needed,
          // since they are in the same path)
          fileRenameInformation->RootDirectory = NULL;

          fileRenameInformation->FileNameLength = targetBaseName.Length;

          RtlCopyMemory(
              fileRenameInformation->FileName,
              targetBaseName.Buffer,
              targetBaseName.Length
              );
       }
    }

no_match:

    //
    // If we know that the target is a directory, then concatenate the
    // source base name to the end of the target name.
    //

    if ( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) {

        SrvGetBaseFileName( Source, &sourceBaseName );

        s = (PWCH)((PCHAR)fileRenameInformation->FileName +
                                    fileRenameInformation->FileNameLength);

        //
        // Only add in a directory separator if the target had some path
        // information.  This avoids having a new name like "\NAME", which
        // is illegal with a relative rename (there should be no
        // leading backslash).
        //

        if ( Target->Length > 0 ) {
            *s++ = DIRECTORY_SEPARATOR_CHAR;
        }

        RtlCopyMemory( s, sourceBaseName.Buffer, sourceBaseName.Length );

        fileRenameInformation->FileNameLength +=
                                sizeof(WCHAR) + sourceBaseName.Length;
    }

    //
    // Call NtSetInformationFile to actually rename the file.
    //

    IF_SMB_DEBUG(FILE_CONTROL2) {
        UNICODE_STRING name;
        name.Length = (USHORT)fileRenameInformation->FileNameLength;
        name.Buffer = fileRenameInformation->FileName;
        SrvPrint2( "Renaming %wZ to %wZ\n", Source, &name );
    }
    switch (InformationLevel) {
    case SMB_NT_RENAME_RENAME_FILE:
        NtInformationLevel = FileRenameInformation;

        //
        // If we are renaming a substream, we do not supply
        //  fileRenameInformation->RootDirectory
        //
        es = fileRenameInformation->FileName +
                fileRenameInformation->FileNameLength / sizeof( WCHAR );

        for( s = fileRenameInformation->FileName; s < es; s++ ) {
            if( *s == L':' ) {
                fileRenameInformation->RootDirectory = 0;
                break;
            }
        }
        break;

    case SMB_NT_RENAME_MOVE_CLUSTER_INFO:
        NtInformationLevel = FileMoveClusterInformation;
        break;

    case SMB_NT_RENAME_SET_LINK_INFO:
        NtInformationLevel = FileLinkInformation;
        break;

    default:
        ASSERT(FALSE);
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {
        status = NtSetInformationFile(
                     SourceHandle,
                     &ioStatusBlock,
                     fileRenameInformation,
                     renameBlockSize,
                     NtInformationLevel
                     );

        //
        // If the media was changed and we can come up with a new share root handle,
        //  then we should retry the operation
        //
        if( SrvRetryDueToDismount( TargetShare, status ) ) {

            fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

            status = NtSetInformationFile(
                     SourceHandle,
                     &ioStatusBlock,
                     fileRenameInformation,
                     renameBlockSize,
                     NtInformationLevel
                     );
        }

        REVERT( );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
        SrvRemoveCachedDirectoryName( WorkContext, Source );
    }

    //
    // If the status was STATUS_OBJECT_NAME_COLLISION then the target
    // already existed as a directory.  Unless the target name was
    // supposed to indicate a file or we have already tried used the
    // source name, retry by concatenating the source base name to the
    // target.
    //

    if ( status == STATUS_OBJECT_NAME_COLLISION &&
         !FailIfTargetIsDirectory &&
         !( *SmbFlags & SMB_TARGET_IS_FILE ) &&
         !( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) ) {

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint0( "Retrying rename with source name.\n" );
        }

        //
        // Set the flags so that future calls to this routine will do
        // the right thing first time around.
        //

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;

        //
        // Generate the new target name.
        //

        SrvGetBaseFileName( Source, &sourceBaseName );

        s = (PWCH)((PCHAR)fileRenameInformation->FileName +
                                    fileRenameInformation->FileNameLength);

        *s++ = DIRECTORY_SEPARATOR_CHAR;

        RtlCopyMemory( s, sourceBaseName.Buffer, sourceBaseName.Length );

        fileRenameInformation->FileNameLength +=
                                sizeof(WCHAR) + sourceBaseName.Length;

        //
        // Do the rename again.  If it fails this time, too bad.
        //
        // *** Note that it may fail because the source and target
        //     exist on different volumes.  This could potentially
        //     cause confusion for DOS clients in the presence of
        //     links.

        IF_SMB_DEBUG(FILE_CONTROL2) {
            UNICODE_STRING name;
            name.Length = (USHORT)fileRenameInformation->FileNameLength;
            name.Buffer = fileRenameInformation->FileName;
            SrvPrint2( "Renaming %wZ to %wZ\n", Source, &name );
        }

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            status = NtSetInformationFile(
                         SourceHandle,
                         &ioStatusBlock,
                         fileRenameInformation,
                         renameBlockSize,
                         NtInformationLevel
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( TargetShare, status ) ) {

                fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

                status = NtSetInformationFile(
                             SourceHandle,
                             &ioStatusBlock,
                             fileRenameInformation,
                             renameBlockSize,
                             NtInformationLevel
                             );
            }

            REVERT( );
        }

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }
    }

    //
    // Release the share root handle if device is removable
    //

    SrvReleaseShareRootHandle( TargetShare );

    FREE_HEAP( fileRenameInformation );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "DoRename: NtSetInformationFile failed, status = %X\n",
                          status );
        }
    }

    return status;

} // DoRename
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\lock.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    This module defines types and functions for the LAN Manager server
    FSP's lock package.  This package began as a modification and
    streamlining of the executive resource package -- it allowed
    recursive acquisition, but didn't provide shared locks.  Later,
    debugging support in the form of level checking was added.

    Coming full circle, the package now serves as a wrapper around the
    real resource package.  It simply provides debugging support.  The
    reasons for reverting to using resources include:

    1) The resource package now supports recursive acquisition.

    2) There are a couple of places in the server where shared access
       is desirable.

    3) The resource package has a "no-wait" option that disables waiting
       for a lock when someone else owns it.  This feature is useful to
       the server FSD.

Author:

    Chuck Lenzmeier (chuckl) 29-Nov-1989
        A modification of Gary Kimura's resource package.  See lock.c.
    David Treadwell (davidtr)

    Chuck Lenzmeier (chuckl)  5-Apr-1991
        Revert to using resource package.

Environment:

    Kernel mode only, LAN Manager server FSP and FSD.

Revision History:

--*/

#ifndef _LOCK_
#define _LOCK_

//#include <ntos.h>

//
// Structure containing global spin locks.  Used to isolate each spin
// lock into its own cache line.
//

typedef struct _SRV_GLOBAL_SPIN_LOCKS {
    ULONG Reserved1[7];
    KSPIN_LOCK Fsd;
    ULONG Reserved2[7];
    struct {
        KSPIN_LOCK Lock;
        ULONG Reserved3[7];
    } Endpoint[ENDPOINT_LOCK_COUNT];
    KSPIN_LOCK Statistics;
    ULONG Reserved4[7];
    KSPIN_LOCK Timer;
    ULONG Reserved5[7];
#if SRVDBG || SRVDBG_HANDLES
    KSPIN_LOCK Debug;
    ULONG Reserved6[7];
#endif
} SRV_GLOBAL_SPIN_LOCKS, *PSRV_GLOBAL_SPIN_LOCKS;

//
// Macros for accessing spin locks.
//

#define ACQUIRE_SPIN_LOCK(lock,irql) {          \
    PAGED_CODE_CHECK();                         \
    ExAcquireSpinLock( (lock), (irql) );        \
    }
#define RELEASE_SPIN_LOCK(lock,irql) {          \
    PAGED_CODE_CHECK();                         \
    ExReleaseSpinLock( (lock), (irql) );        \
    }
#define ACQUIRE_DPC_SPIN_LOCK(lock) {           \
    PAGED_CODE_CHECK();                         \
    ExAcquireSpinLockAtDpcLevel( (lock) );      \
    }
#define RELEASE_DPC_SPIN_LOCK(lock) {           \
    PAGED_CODE_CHECK();                         \
    ExReleaseSpinLockFromDpcLevel( (lock) );    \
    }

#define INITIALIZE_SPIN_LOCK(lock) KeInitializeSpinLock( lock );

#define GLOBAL_SPIN_LOCK(lock) SrvGlobalSpinLocks.lock
#define ENDPOINT_SPIN_LOCK(index) SrvGlobalSpinLocks.Endpoint[index].Lock

#define INITIALIZE_GLOBAL_SPIN_LOCK(lock) INITIALIZE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )

#define ACQUIRE_GLOBAL_SPIN_LOCK(lock,irql) ACQUIRE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock), (irql) )
#define RELEASE_GLOBAL_SPIN_LOCK(lock,irql) RELEASE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock), (irql) )
#define ACQUIRE_DPC_GLOBAL_SPIN_LOCK(lock)  ACQUIRE_DPC_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )
#define RELEASE_DPC_GLOBAL_SPIN_LOCK(lock)  RELEASE_DPC_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )

//
// Macros for initializing, deleting, acquiring, and releasing locks.
//

#if !SRVDBG_LOCK

//
// When debugging is disabled, the lock macros simply equate to calls to
// the corresponding resource package functions.
//

#define INITIALIZE_LOCK( lock, level, name ) ExInitializeResourceLite( (lock) )
#define DELETE_LOCK( lock ) ExDeleteResourceLite( (lock) )

#define ACQUIRE_LOCK( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), TRUE )
#define ACQUIRE_LOCK_NO_WAIT( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), FALSE )

#define ACQUIRE_LOCK_SHARED( lock ) \
                    ExAcquireResourceSharedLite( (lock), TRUE )
#define ACQUIRE_LOCK_SHARED_NO_WAIT( lock ) \
                    ExAcquireResourceSharedLite( (lock), FALSE )

#define RELEASE_LOCK(lock) ExReleaseResourceLite( (lock) )

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->ActiveCount)

#else // !SRVDBG_LOCK

//
// When debugging is enabled, the lock macros equate to calls to
// functions in the server.  These functions are implemented in lock.c.
//

#define INITIALIZE_LOCK( lock, level, name ) \
                    SrvInitializeLock( (lock), (level), (name) )
#define DELETE_LOCK( lock ) SrvDeleteLock( (lock) )

#define ACQUIRE_LOCK( lock ) \
                    SrvAcquireLock( (lock), TRUE, TRUE )
#define ACQUIRE_LOCK_NO_WAIT( lock ) \
                    SrvAcquireLock( (lock), FALSE, TRUE )

#define ACQUIRE_LOCK_SHARED( lock ) \
                    SrvAcquireLock( (lock), TRUE, FALSE )
#define ACQUIRE_LOCK_SHARED_NO_WAIT( lock ) \
                    SrvAcquireLock( (lock), FALSE, FALSE )

#define RELEASE_LOCK( lock ) SrvReleaseLock( (lock) )

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->Resource.ActiveCount)

#define LOCK_NAME( lock ) ((lock)->Header.LockName)
#define LOCK_LEVEL( lock ) ((lock)->Header.LockLevel)
#define LOCK_THREAD_LIST( lock ) (&((lock)->Header.ThreadListEntry))

#endif // else !SRVDBG_LOCK


#if !SRVDBG_LOCK

//
// When debugging is disabled, a server lock is identical to an
// executive resource.
//

typedef ERESOURCE SRV_LOCK, *PSRV_LOCK;

#define RESOURCE_OF(_l_) (_l_)

#else // !SRVDBG_LOCK

//
// SRV_LOCK_HEADER is a structure that contains debugging information
// used by the server lock package.  Server locks contain a
// SRV_LOCK_HEADER.
//

typedef struct _SRV_LOCK_HEADER {

    //
    // To prevent deadlocks, locks are assigned level numbers.  If a
    // thread holds a lock with level N, it may only acquire new locks
    // with a level greater then N.  Level numbers are assigned during
    // lock initialization.
    //
    // *** Due to the problems involved in retaining the information
    //     necessary to do level checking for shared locks, the lock
    //     package only does level checking for exclusive locks.
    //

    ULONG LockLevel;

    //
    // A doubly-linked list of all the locks owned by a thread is stored
    // in a thread's TEB.  The list is in order of lock level (from
    // highest to lowest), which is also, by definition of lock levels,
    // the order in which the thread acquired the locks.  This allows
    // the thread to release the locks in any order while maintaining
    // easy access to the highest-level lock that the thread owns,
    // thereby providing a mechanism for ensuring that locks are
    // acquired in increasing order.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // The symbolic name of the lock is used in DbgPrint calls.
    //

    PSZ LockName;

} SRV_LOCK_HEADER, *PSRV_LOCK_HEADER;

//
// When debugging is enabled, a server lock is a wrapper around an
// executive resource.
//

typedef struct _SRV_LOCK {

    //
    // The SRV_LOCK_HEADER must appear first!
    //

    SRV_LOCK_HEADER Header;

    //
    // The actual "lock" is maintained by the resource package.
    //

    ERESOURCE Resource;

} SRV_LOCK, *PSRV_LOCK;

#define RESOURCE_OF(_sl_) (_sl_).Resource

//
// Lock functions used when debugging.
//

VOID
SrvInitializeLock(
    IN PSRV_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    );

VOID
SrvDeleteLock (
    IN PSRV_LOCK Lock
    );

BOOLEAN
SrvAcquireLock(
    IN PSRV_LOCK Lock,
    IN BOOLEAN Wait,
    IN BOOLEAN Exclusive
    );

VOID
SrvReleaseLock(
    IN PSRV_LOCK Lock
    );

//
// Macros that define locations in the UserReserved field of the TEB
// where lock level information is stored.
//

#define SRV_TEB_LOCK_LIST 0
#define SRV_TEB_LOCK_INIT 2
#define SRV_TEB_USER_SIZE (3 * sizeof(ULONG))

//
// Max value for lock levels is 0x7FFFFFFF.
//
// Levels for locks used in the server.  The following must be true:
//
// EndpointLock must be lower than ConnectionLock (really
// connection->Lock) because SrvCloseConnectionsFromClient holds
// EndpointLock when it acquires ConnectionLock to check a connection's
// client name, and because a number of callers hold EndpointLock when
// they call SrvCloseConnection, which acquires ConnectionLock.  Note
// also that SrvDeleteServedNet and TerminateServer hold EndpointLock
// when they call SrvCloseEndpoint; any attempt to change
// SrvCloseEndpoint must take this into account.
// ExamineAndProcessConnections also depends on this ordering.
//
// EndpointLock must be lower than MfcbListLock and MfcbLock because
// EndpointLock is held while stopping the server and closing
// connections, thereby closing files on the connections.
//
// ShareLock must be lower than ConnectionLock because
// SrvCloseTreeConnectsOnShare holds ShareLock when it calls
// SrvCloseTreeConnect.  Note that SrvSmbTreeConnect and
// SrvSmbTreeConnectAndX depend on this ordering, because they take out
// both locks concurrently.
//
// Similarly, ShareLock must be lower than MfcbListLock and MfcbLock
// because SrvCloseTreeConnectsOnShare holds ShareLock when it calls
// SrvCloseRfcbsOnTree.
//
// MfcbListLock must be lower than MfcbLock (really mfcb->Lock) because
// SrvMoveFile and DoDelete hold MfcbListLock to find an MFCB, then take
// MfcbLock before releasing MfcbListLock.
//
// MfcbLock must be lower than OrderedListLock and ConnectionLock
// because CompleteOpen acquires these locks while holding the MfcbLock.
//
// OrderedListLock must be lower than ConnectionLock because
// SrvFindEntryInOrderedList holds the ordered list lock when in calls
// the check-and-reference routine for sessions and tree connects.  For
// other ordered lists, this is not a problem, because the other lists
// are either protected the same locks that the check-and-reference
// routine uses (endpoints, connections, and shares), or the
// check-and-reference routine uses a spin lock (files).  Note also that
// OrderedListLock and ConnectionLock are acquired concurrently and in
// the proper order in SrvSmbSessionSetupAndX, SrvSmbTreeConnect, and
// CompleteOpen.
//
// *** WARNING:  If the ordered RFCB list (SrvRfcbList) or the ordered
//     session list (SrvSessionList) are changed to use a lock other
//     than SrvOrderedListLock, the above requirement may change, and
//     the routines listed above may need to change.  Changing other
//     ordered lists that currently use some other global lock also may
//     change the requirements.
//
// DebugLock must be higher than MfcbLock because CompleteOpen holds
// the MfcbLock when it allocates the LFCB and RFCB.  The DebugLock
// is held for all memory allocations.  Note that because of the
// way DebugLock is currently used, it is impossible to acquire other
// locks while holding DebugLock.
//
// ConnectionLock must be higher than SearchLock because the scavenger
// thread holds the search lock while walking the search list looking
// for search blocks to time out, and if a block to time out is found it
// closes the search which acquires the the connection lock in order to
// dereference the session in by the search block.
//
// EndpointLock must be higher than SearchLock because in the above
// scenario, SrvDereferenceSession may call SrvDereferenceConnection
// which acquires the endpoint lock.
//
// SearchLock must be at a higher level than ShareLock because
// SrvCloseShare gets the ShareLock, but SrvCloseSessionsOnTreeConnect
// aquires the SearchLock.
//
// CommDeviceLock must be higher than MfcbLock because DoCommDeviceOpen
// acquires the CommDeviceLock while holding MfcbLock.
//
// OplockListLock needs to be lower than ShareLock as the server may
// need to call SrvDereferenceRfcb while holding the OplockListLock.
// This routine may call SrvDereferenceLfcb which may call
// SrvDereferenceShare which acquires the ShareLock.
//
// This is a summary of the above (the top lock is acquired first and
// therefore must have a lower level):
//
//  endp  endp   endp  share  share  share  mfcbl  mfcb  mfcb  order  mfcb
//  conn  mfcbl  mfcb  conn   mfcbl  mfcb   mfcb   order conn  conn   debug
//
//  search  search  share    oplock  oplock
//  conn    endp    search   mfcb    share
//
// Merging this, we find the following "threads" of requirements:
//
//    share   mfcb   mfcb   oplock
//    search  debug  comm   share
//    endp
//    mfcbl
//    mfcb
//    order
//    conn
//
// The following locks are not affected by the above requirements:
//
//    configuration
//    smbbufferlist
//    Connection->LicenseLock
//
// The levels of all of these locks are made equal and high in an
// attempt to find level requirements not listed above.
//

#define OPLOCK_LIST_LOCK_LEVEL                  (ULONG)0x00000800
#define SHARE_LOCK_LEVEL                        (ULONG)0x00000900
#define SEARCH_LOCK_LEVEL                       (ULONG)0x00001000
#define ENDPOINT_LOCK_LEVEL                     (ULONG)0x00002000
#define MFCB_LIST_LOCK_LEVEL                    (ULONG)0x00003000
#define MFCB_LOCK_LEVEL                         (ULONG)0x00004000
#define COMM_DEVICE_LOCK_LEVEL                  (ULONG)0x00005000
#define ORDERED_LIST_LOCK_LEVEL                 (ULONG)0x00006000
#define CONNECTION_LOCK_LEVEL                   (ULONG)0x00007000
#define CONFIGURATION_LOCK_LEVEL                (ULONG)0x00010000
#define UNLOCKABLE_CODE_LOCK_LEVEL              (ULONG)0x00010000
#define STARTUPSHUTDOWN_LOCK_LEVEL              (ULONG)0x00020000
#define DEBUG_LOCK_LEVEL                        (ULONG)0x00050000
#define LICENSE_LOCK_LEVEL                      (ULONG)0x00100000
#define FCBLIST_LOCK_LEVEL                      (ULONG)0x00200000

#endif // else !SRVDBG_LOCK

#endif // ndef _LOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\precomp.h ===
#if defined(SRVKD)

#include <ntos.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntiolog.h>
#include <ntiologc.h>
#include <ntddnfs.h>
#include <ntddser.h>
#include <ntmsv1_0.h>
#include <nturtl.h>
#include <zwapi.h>
#include <fsrtl.h>

#else

#include <ntifs.h>
#include <ntddser.h>

#endif

// header file for WMI event tracing
//
#define _NTDDK_
#include "wmistr.h"
#include "evntrace.h"
#if !defined (SRVKD)
#include "stdarg.h"
#include "wmikm.h"
#endif //#if !defined (SRVKD)
#undef _NTDDK_

#include <windef.h>
#include <winerror.h>

#include <netevent.h>

#include <lm.h>

#include <xactsrv2.h>
#include <alertmsg.h>
#include <msgtext.h>

#include <tstr.h>
#include <stdlib.h>

#include <string.h>

#include <wsnwlink.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <isnkrnl.h>
#include <nbtioctl.h>

#include <protocol.h>

#include <lmcons.h>

#ifndef SECURITY_KERNEL
#define SECURITY_KERNEL
#endif // SECURITY_KERNEL

#ifndef SECURITY_NTLM
#define SECURITY_NTLM
#endif // SECURITY_NTLM

#ifndef SECURITY_KERBEROS
#define SECURITY_KERBEROS
#endif // SECURITY_KERBEROS
#include <security.h>
#include <secint.h>

// #define INCLUDE_SMB_CAIRO
#define INCLUDE_SMB_ALL

#include <smbtypes.h>
#include <smbmacro.h>
#include <smbgtpt.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbipx.h>

//
// Network include files.
//

#include <status.h>
#define INCLUDE_SRV_IPX_SMART_CARD_INTERFACE 1
#include <srvfsctl.h>

//
// Local, independent include files
//

//
// Determine if we are building for a multiprocessor target
//
#if !defined( NT_UP ) || NT_UP == 0
#define MULTIPROCESSOR 1
#else
#define MULTIPROCESSOR 0
#endif

#define DBG_STUCK 1

#include "srvdebug.h"

#if SRVDBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        DbgPrint( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() ); \
        ASSERT(FALSE); \
        DbgBreakPoint(); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
extern ULONG ThisCodeCantBePaged;
#else
#undef PAGED_CODE
#define PAGED_CODE()
#define PAGED_CODE_CHECK()
#endif


#include "srvconst.h"

#include "lock.h"

#include "srvstrng.h"

#include <md5.h>
#include <crypt.h>

//
// The following include files are dependent on each other; be careful
// when changing the order in which they appear.
//
#include "srvtypes.h"
#include "srvblock.h"

#if !defined( SRVKD )

#include "srvfsp.h"
#include "srvio.h"
#include "srvfsd.h"
#include "smbprocs.h"
#include "smbctrl.h"
#include "srvsvc.h"
#include "srvdata.h"
#include "srvnet.h"
#include "srvstamp.h"
#include "srvsupp.h"
#include "srvmacro.h"
#include "srvconfg.h"
#include "errorlog.h"
#include "rawmpx.h"
#include "ipx.h"
#include "srvsnap.h"

#if DBG
#undef ASSERT
#define ASSERT( x ) \
    if( !(x) ) { \
        DbgPrint( "SRV: Assertion Failed at line %u in %s\n", __LINE__, __FILE__ ); \
        DbgBreakPoint(); \
    }
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\oplock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    oplock.c

Abstract:

    This module contains the routines used to support oppurtunistic
    locking in the server.

Details:

    Oplock activity is controlled by information contained in the
    connection block.  In particular oplocks must be synchronized
    with the read block raw SMB, since the oplock request SMB is
    indistinguishable from raw data.

    RawReadsInProgress -
        Is incremented when a read raw request is accepted.  It is
        decremented after the raw data has been sent.  An oplock break
        request is never sent when RawReadsInProgress is nonzero.

    OplockBreaksInProgess -
        Is incremented when the server determines that it must send
        an oplock break SMB.  It is decremented when the oplock break
        response arrives.

    OplockBreakRequestsPending -
        Is the number of oplock break requests that could not be sent
        due the lack of a WCBs.  It is incremented when WCB allocation
        fails.  It is decremented when the WCB is successfully allocated
        and the oplock break request is sent.

    OplockWorkItemList -
        Is a list of oplock context blocks for oplock break that could
        not be sent due to (1) a read raw in progress or (2) a resource
        shortage.

    It is possible for an oplock break request from the server and a
    read raw request from the client to "cross on the wire".  In this
    case the client is expected to examine the raw data.  If the data
    may be an oplock break request, the client must break the oplock
    then reissue the read request.

    If the server receives the read raw request after having sent an
    oplock break request (but before the reply arrives), it must return
    zero bytes read, since the oplock break request may have completed
    the raw request, and the client is unprepared to receives a larger
    than negotiated size response.

Author:

    Manny Weiser (mannyw)  16-Apr-1991

Revision History:

--*/

#include "precomp.h"
#include "oplock.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_OPLOCK

//
// Local definitions
//

PWORK_CONTEXT
GenerateOplockBreakRequest(
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvFillOplockBreakRequest )
#pragma alloc_text( PAGE, SrvRestartOplockBreakSend )
#pragma alloc_text( PAGE, SrvAllocateWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvDereferenceWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvFreeWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvGetOplockBreakTimeout )
#pragma alloc_text( PAGE, SrvRequestOplock )
#pragma alloc_text( PAGE, SrvStartWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvCheckOplockWaitState )
#pragma alloc_text( PAGE8FIL, SrvOplockBreakNotification )
#pragma alloc_text( PAGE8FIL, GenerateOplockBreakRequest )
#pragma alloc_text( PAGE8FIL, SrvSendOplockRequest )
#pragma alloc_text( PAGE8FIL, SrvCheckDeferredOpenOplockBreak )
#endif
#if 0
#pragma alloc_text( PAGECONN, SrvSendDelayedOplockBreak )
#endif

#if    SRVDBG

//
// Unfortunately, when KdPrint is given a %wZ conversion, it calls a
//    pageable Rtl routine to convert.  This is bad if we're calling
//    KdPrint from DPC level, as we are below.  So we've introduced
//    SrvPrintwZ() here to get around the problem.  This is only for
//    debugging anyway....
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE8FIL, SrvCheckDeferredOpenOplockBreak )
#endif

#define SrvPrintwZ( x ) if( KeGetCurrentIrql() == 0 ){ DbgPrint( "%wZ", x ); } else { DbgPrint( "??" ); }

#else

#define    SrvPrintwZ( x )

#endif

VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );


VOID SRVFASTCALL
SrvOplockBreakNotification(
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function receives the oplock break notification from a file
    system.  It must send the oplock break SMB to the oplock owner.

Arguments:

    OplockContext - A pointer to the oplock context for this oplock break.
Return Value:

--*/

{
    ULONG information;
    NTSTATUS status;
    PCONNECTION connection;
    KIRQL oldIrql;
    PRFCB Rfcb = (PRFCB)WorkContext;
    PPAGED_RFCB pagedRfcb = Rfcb->PagedRfcb;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the oplock request.
    //

    UpdateRfcbHistory( Rfcb, 'tnpo' );

    status = Rfcb->Irp->IoStatus.Status;

    information = (ULONG)Rfcb->Irp->IoStatus.Information;
    connection = Rfcb->Connection;

    IF_DEBUG( OPLOCK ) {

        KdPrint(( "SrvOplockBreakNotification: Received notification for " ));
        SrvPrintwZ( &Rfcb->Mfcb->FileName );
        KdPrint(( "\n" ));
        KdPrint(( "  status 0x%x, information %X, connection %p\n",
                     status, information, connection ));
        KdPrint(( "  Rfcb->OplockState = %X\n", Rfcb->OplockState ));
    }

    //
    // Check the oplock break request.
    //
    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Mark this rfcb as not cacheable since the oplock has been broken.
    // This is to close a timing window where the client closes the file
    // just as we are preparing to send an oplock break.  We won't send the
    // break because the rfcb is closing and we will cache the file if
    // it was an opbatch.  This results in the oplock never being broken.
    //

    Rfcb->IsCacheable = FALSE;

    if ( !NT_SUCCESS(status) ||
         Rfcb->OplockState == OplockStateNone ||
         ((GET_BLOCK_STATE( Rfcb ) == BlockStateClosing) &&
          (Rfcb->OplockState != OplockStateOwnServerBatch)) ) {

        IF_DEBUG( SMB_ERRORS ) {
            if( status == STATUS_INVALID_OPLOCK_PROTOCOL ) {
                if ( GET_BLOCK_STATE( Rfcb ) != BlockStateClosing ) {
                    KdPrint(( "BUG: SrvOplockBreakNotification: " ));
                    SrvPrintwZ( &Rfcb->Mfcb->FileName );
                    KdPrint(( " is not closing.\n" ));
                }
            }
        }

        //
        // One of the following is true:
        //  (1) The oplock request failed.
        //  (2) Our oplock break to none has succeeded.
        //  (3) We are in the process of closing the file.
        //
        // Note that if a level I oplock request fails when a retry at
        // level II is desired, SrvFsdOplockCompletionRoutine handles
        // setting the retry event and we do not get here at all.
        //

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "SrvOplockBreakNotification: Breaking to none\n"));
        }

        UpdateRfcbHistory( Rfcb, 'nnso' );

        Rfcb->OplockState = OplockStateNone;

        if( Rfcb->CachedOpen ) {
            //
            // SrvCloseCachedRfcb releases the spinlock
            //
            SrvCloseCachedRfcb( Rfcb, oldIrql );

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }

        //
        // Free the IRP we used to the oplock request.
        //

        UpdateRfcbHistory( Rfcb, 'prif' );

        IoFreeIrp( Rfcb->Irp );
        Rfcb->Irp = NULL;

        //
        // Dereference the rfcb.
        //

        SrvDereferenceRfcb( Rfcb );

    } else if ( Rfcb->OplockState == OplockStateOwnServerBatch ) {

        //
        // We are losing a server-initiated batch oplock.  Don't send
        // anything to the client.  If the client still has the file
        // open, just release the oplock.  If the client has closed the
        // file, we have to close the file now.
        //

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvOplockBreakNotification: server oplock broken for %p, file %wZ\n", Rfcb, &Rfcb->Mfcb->FileName ));
        }

        if ( !Rfcb->CachedOpen ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvOplockBreakNotification: ack close pending for " ));
                SrvPrintwZ( &Rfcb->Mfcb->FileName );
                KdPrint(( "\n" ));
            }
            UpdateRfcbHistory( Rfcb, 'pcao' );

            Rfcb->OplockState = OplockStateNone;
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            Rfcb->RetryOplockRequest = NULL;
            SrvBuildIoControlRequest(
                Rfcb->Irp,
                Rfcb->Lfcb->FileObject,
                Rfcb,
                IRP_MJ_FILE_SYSTEM_CONTROL,
                FSCTL_OPLOCK_BREAK_ACK_NO_2,
                NULL,                        // Main buffer
                0,                           // Input buffer length
                NULL,                        // Auxiliary buffer
                0,                           // Output buffer length
                NULL,                        // MDL
                SrvFsdOplockCompletionRoutine
                );

            IoCallDriver( Rfcb->Lfcb->DeviceObject, Rfcb->Irp );

        } else {

            //
            // SrvCloseCachedRfcb releases the spin lock.
            //

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvOplockBreakNotification: closing cached rfcb for "));
                SrvPrintwZ( &Rfcb->Mfcb->FileName );
                KdPrint(( "\n" ));
            }
            UpdateRfcbHistory( Rfcb, '$bpo' );

            SrvCloseCachedRfcb( Rfcb, oldIrql );
            SrvDereferenceRfcb( Rfcb );

        }

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        //
        // We have an oplock to break.
        //

        IF_DEBUG( OPLOCK ) {
            if (information == FILE_OPLOCK_BROKEN_TO_LEVEL_2) {
                KdPrint(( "SrvOplockBreakNotification: Breaking to level 2\n"));
            } else if (information == FILE_OPLOCK_BROKEN_TO_NONE) {
                KdPrint(( "SrvOplockBreakNotification: Breaking to level none\n"));
            } else {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvOplockBreakNotification:  Unknown oplock type %d",
                    information,
                    NULL
                    );

            }
        }

        //
        // Save the new oplock level, in case this oplock break is deferrred.
        //

        if ( information == FILE_OPLOCK_BROKEN_TO_LEVEL_2 &&
                CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, Rfcb->Connection ) ) {

            Rfcb->NewOplockLevel = OPLOCK_BROKEN_TO_II;
        } else {

            Rfcb->NewOplockLevel = OPLOCK_BROKEN_TO_NONE;
        }

        //
        // Do not send the oplock break notification if a read raw is
        // in progress (and the client is expecting raw data on the VC).
        //
        // The oplock break notification will be sent after the raw
        // data.
        //

        ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

        //
        // Do not send the oplock break if we have not yet sent the
        // open response (i.e. the client does not yet know that it
        // owns the oplock).
        //

        if ( !Rfcb->OpenResponseSent ) {

            Rfcb->DeferredOplockBreak = TRUE;
            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        } else {

            //
            // EndpointSpinLock will be released in this routine.
            //

            SrvSendOplockRequest( connection, Rfcb, oldIrql );
        }
    }

    return;

} // SrvOplockBreakNotification


PWORK_CONTEXT
GenerateOplockBreakRequest(
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function creates an oplock break request SMB.

Arguments:

    Rfcb - A pointer to the RFCB.  Rfcb->NewOplockLevel contains
            the oplock level to break to.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT workContext;
    PCONNECTION connection = Rfcb->Connection;
    BOOLEAN success;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Attempt to allocate a work context block for the oplock break.
    //

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );

    if ( workContext == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "GenerateOplockBreakRequest: no receive work items available",
            NULL,
            NULL
            );

        //
        // If the rfcb is closing, forget about the oplock break.
        // Acquire the lock that guards the RFCB's state field.
        //

        if ( GET_BLOCK_STATE( Rfcb ) == BlockStateClosing ) {
            ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
            connection->OplockBreaksInProgress--;
            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
            SrvDereferenceRfcb( Rfcb );
            return NULL;
        }

        //
        // Mark this connection as waiting to send an oplock break.
        //

        success = SrvAddToNeedResourceQueue(
                    connection,
                    OplockSendPending,
                    Rfcb
                    );

        if ( !success ) {

            //
            // Failed to queue the RFCB, so the connection must be going
            // away.  Simply dereference the RFCB and forget about the
            // oplock break.
            //

            SrvDereferenceRfcb( Rfcb );

        }

        return NULL;

    }

    //
    // If the rfcb is closing, forget about the oplock break.
    // Acquire the lock that guards the RFCB's state field.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    if ( GET_BLOCK_STATE( Rfcb ) == BlockStateClosing ) {
        connection->OplockBreaksInProgress--;
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvDereferenceRfcb( Rfcb );
        workContext->BlockHeader.ReferenceCount = 0;
        RETURN_FREE_WORKITEM( workContext );
        return NULL;
    }

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    //
    // Return a pointer to the work context block to the caller.
    //

    return workContext;

} // GenerateOplockBreakRequest


VOID
SrvFillOplockBreakRequest (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function fills the request buffer of a work context block with
    an oplock break request for the file specified by the RFCB.

Arguments:

    WorkContext - The work context block to fill

    Rfcb - The file whose oplock is being broken. Rfcb->NewOplockLevel contains
           the level to break to.

Return Value:

    None.

--*/

{
    PNT_SMB_HEADER requestHeader;
    PREQ_LOCKING_ANDX requestParameters;
    ULONG sendLength;

    PAGED_CODE( );

    requestHeader = (PNT_SMB_HEADER)WorkContext->RequestBuffer->Buffer;
    requestParameters = (PREQ_LOCKING_ANDX)(requestHeader + 1);

    //
    // Fill in the SMB header.
    // Zero the unused part of the header for safety.
    //

    RtlZeroMemory(
        (PVOID)&requestHeader->Status,
        FIELD_OFFSET(SMB_HEADER, Mid) - FIELD_OFFSET(NT_SMB_HEADER, Status)
        );

    *(PULONG)requestHeader->Protocol = SMB_HEADER_PROTOCOL;
    requestHeader->Command = SMB_COM_LOCKING_ANDX;

    SmbPutAlignedUshort( &requestHeader->Tid, Rfcb->Tid );
    SmbPutAlignedUshort( &requestHeader->Mid, 0xFFFF );
    SmbPutAlignedUshort( &requestHeader->Pid, 0xFFFF );

    //
    // Fill in the SMB parameters.
    //

    requestParameters->WordCount = 8;
    requestParameters->AndXCommand = 0xFF;
    requestParameters->AndXReserved = 0;
    SmbPutUshort( &requestParameters->AndXOffset, 0 );
    SmbPutUshort( &requestParameters->Fid, Rfcb->Fid );
    requestParameters->LockType = LOCKING_ANDX_OPLOCK_RELEASE;
    requestParameters->OplockLevel = Rfcb->NewOplockLevel;
    SmbPutUlong ( &requestParameters->Timeout, 0 );
    SmbPutUshort( &requestParameters->NumberOfUnlocks, 0 );
    SmbPutUshort( &requestParameters->NumberOfLocks, 0 );
    SmbPutUshort( &requestParameters->ByteCount, 0 );

    sendLength = LOCK_BROKEN_SIZE;
    WorkContext->RequestBuffer->DataLength = sendLength;

    return;

} // SrvFillOplockBreakRequest

VOID SRVFASTCALL
SrvRestartOplockBreakSend(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine is used to send the break request smb during servicing
    of the need resource queue if SrvFsdServiceNeedResourceQueue is called
    at Dpc.

Arguments:

    WorkContext - A pointer to the work context block.

Return Value:

    None.

--*/

{

    //
    // The rfcb is being referenced by the work item.
    //

    PRFCB rfcb = WorkContext->Rfcb;
    PPAGED_RFCB pagedRfcb = rfcb->PagedRfcb;

    PAGED_CODE( );

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRestartOplockBreakSend entered.\n"));
    }

    pagedRfcb->OplockBreakTimeoutTime =
                    SrvGetOplockBreakTimeout( WorkContext );

    WorkContext->ResponseHeader =
                        WorkContext->ResponseBuffer->Buffer;

    //
    // Generate the oplock break request SMB.
    //

    SrvFillOplockBreakRequest( WorkContext, rfcb );

    //
    // If this is a break from level 2 to none, send the
    // oplock break but don't queue this.  No response from the
    // client is expected.
    //

    if ( rfcb->NewOplockLevel == OPLOCK_BROKEN_TO_NONE &&
         rfcb->OplockState == OplockStateOwnLevelII ) {

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRestartOplockBreakSend: Oplock break from "
                     " II to none sent.\n"));
        }

        rfcb->OplockState = OplockStateNone;

    } else {

        //
        // Reference the RFCB so it cannot be freed while it is on
        // the list.
        //

        SrvReferenceRfcb( rfcb );

        //
        // Insert the RFCB on the list of oplock breaks in progress.
        //

        ACQUIRE_LOCK( &SrvOplockBreakListLock );

        //
        // Check if the rfcb is closing.
        //

        if ( GET_BLOCK_STATE( rfcb ) == BlockStateClosing ) {

            //
            // The file is closing, forget about this break.
            // Cleanup and exit.
            //

            RELEASE_LOCK( &SrvOplockBreakListLock );

            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvRestartOplockBreakSend: Rfcb %p closing.\n",
                        rfcb));
            }

            ExInterlockedAddUlong(
                &WorkContext->Connection->OplockBreaksInProgress,
                (ULONG)-1,
                WorkContext->Connection->EndpointSpinLock
                );


            //
            // Remove the queue reference.
            //

            SrvDereferenceRfcb( rfcb );

            //
            // Remove the pointer reference here since we know we are
            // not in the fsd.  The rfcb may be cleaned up safely here.
            //

            SrvDereferenceRfcb( rfcb );
            WorkContext->Rfcb = NULL;

            SrvRestartFsdComplete( WorkContext );
            return;
        }

        SrvInsertTailList( &SrvOplockBreaksInProgressList, &rfcb->ListEntry );

        rfcb->OnOplockBreaksInProgressList = TRUE;
        RELEASE_LOCK( &SrvOplockBreakListLock );

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRestartOplockBreakSend: Oplock sent.\n"));
        }

    }

    //
    // Since this is an out-of-order transmission to the client, we do not
    //  stamp a security signatue on it.
    //
    WorkContext->NoResponseSmbSecuritySignature = TRUE;

    //
    // Update statistics for the broken oplock.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksBroken );

    SRV_START_SEND_2(
        WorkContext,
        (rfcb->OplockState == OplockStateNone) ?
                            SrvFsdRestartSendOplockIItoNone :
                            SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );


} // SrvRestartOplockBreakSend

VOID
SrvAllocateWaitForOplockBreak (
    OUT PWAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak
    )

/*++

Routine Description:

    This routine allocates an wait for oplock break item.  It also
    allocates extra space for a kernel timer and a kernel DPC object.

Arguments:

    WaitForOplockBreak - Returns a pointer to the wait for oplock break
        item, or NULL if no space was available.  The oplock context
        block has a pointer to the IRP.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Attempt to allocate the memory.
    //

    *WaitForOplockBreak = (PWAIT_FOR_OPLOCK_BREAK)ALLOCATE_NONPAGED_POOL(
                                sizeof(WAIT_FOR_OPLOCK_BREAK),
                                BlockTypeWaitForOplockBreak
                                );

    if ( *WaitForOplockBreak == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateWaitForOplockBreak: Unable to allocate %d bytes "
                "from paged pool.",
            sizeof(WAIT_FOR_OPLOCK_BREAK),
            NULL
            );

        *WaitForOplockBreak = NULL;
        return;

    }

    //
    // Zero the item.
    //

    RtlZeroMemory( (PVOID)*WaitForOplockBreak, sizeof(WAIT_FOR_OPLOCK_BREAK) );

    //
    // Initialize the header
    //

    SET_BLOCK_TYPE_STATE_SIZE( *WaitForOplockBreak,
                               BlockTypeWaitForOplockBreak,
                               BlockStateActive,
                               sizeof( WAIT_FOR_OPLOCK_BREAK ));

    //
    // Set the reference count to 2 to account for the workcontext
    // and the oplock wait for oplock break list reference to the structure.
    //

    (*WaitForOplockBreak)->BlockHeader.ReferenceCount = 2;

    INITIALIZE_REFERENCE_HISTORY( *WaitForOplockBreak );

    //
    // Return a pointer to the wait for oplock break item
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.WaitForOplockBreakInfo.Allocations );

    return;

} // SrvAllocateWaitForOplockBreak


VOID
SrvDereferenceWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This routine dereferences an wait for oplock break item.

Arguments:

    WaitForOplockBreak - A pointer to the item to dereference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    PAGED_CODE( );

    ASSERT( GET_BLOCK_TYPE( WaitForOplockBreak ) == BlockTypeWaitForOplockBreak );
    ASSERT( (LONG)WaitForOplockBreak->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( WaitForOplockBreak, TRUE );

    oldCount = ExInterlockedAddUlong(
                   &WaitForOplockBreak->BlockHeader.ReferenceCount,
                   (ULONG)-1,
                   &GLOBAL_SPIN_LOCK(Fsd)
                   );

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing WaitForOplockBreak %p; old refcnt %lx\n",
                  WaitForOplockBreak, oldCount ));
    }

    if ( oldCount == 1 ) {

        //
        // The new reference count is 0.  Delete the block.
        //

        SrvFreeWaitForOplockBreak( WaitForOplockBreak );
    }

    return;

} // SrvDereferenceWaitForOplockBreak


VOID
SrvFreeWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This routine deallocates an wait for oplock break item.

Arguments:

    WaitForOplockBreak - A pointer to the item to free.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    TERMINATE_REFERENCE_HISTORY( WaitForOplockBreak );

    DEALLOCATE_NONPAGED_POOL( WaitForOplockBreak );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.WaitForOplockBreakInfo.Frees );

    return;

} // SrvFreeWaitForOplockBreak


BOOLEAN
SrvRequestOplock (
    IN PWORK_CONTEXT WorkContext,
    IN POPLOCK_TYPE OplockType,
    IN BOOLEAN RequestIIOnFailure
    )

/*++

Routine Description:

    This function will attempt to request an oplock if the oplock was
    requested.

Arguments:

    WorkContext - Pointer to the workitem containing the rfcb.
    OplockType - Pointer to the oplock type being requested.  If the
        request was successful, this will contain the type of oplock
        that was obtained.
    RequestIIOfFailure - If TRUE, a level II oplock will be requested in
        case the original request was denied.

Return Value:

    TRUE - The oplock was obtained.
    FALSE - The oplock was not obtained.

--*/


{
    NTSTATUS status;
    ULONG ioControlCode;
    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    KEVENT oplockRetryEvent;
    UNICODE_STRING fileName;

    PAGED_CODE( );

    if ( !SrvEnableOplocks && (*OplockType != OplockTypeServerBatch) ) {
        return FALSE;
    }

    rfcb = WorkContext->Rfcb;
    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    //
    // If this is an FCB open, return TRUE if the RFCB already owns an
    // oplock, FALSE otherwise.  Since we're folding multiple FCB opens
    // into a single FID, they are logically one open.  Hence, the oplock
    // state of all open instances is identical.
    //

    if ( pagedRfcb->FcbOpenCount > 1 ) {
        return (BOOLEAN)(rfcb->OplockState != OplockStateNone);
    }

    //
    // If we already have an oplock, because this is a reclaiming of a
    // cached open, then we don't need to request one now.
    //

    if ( rfcb->OplockState != OplockStateNone ) {
        UpdateRfcbHistory( rfcb, 'poer' );
        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvRequestOplock: already own server oplock for "));
            SrvPrintwZ( &rfcb->Mfcb->FileName );
            KdPrint(( "\n" ));
        }
        ASSERT( ((rfcb->OplockState == OplockStateOwnBatch) &&
                 (*OplockType == OplockTypeBatch)) ||
                ((rfcb->OplockState == OplockStateOwnServerBatch) &&
                 (*OplockType == OplockTypeServerBatch)) );
        return (BOOLEAN)(*OplockType != OplockTypeServerBatch);
    }

    //
    // Check to see if connection is reliable. If not, reject oplock request.
    //

    SrvUpdateVcQualityOfService( WorkContext->Connection, NULL );

    if ( !WorkContext->Connection->EnableOplocks &&
         (*OplockType != OplockTypeServerBatch) ) {
        return FALSE;
    }

    //
    // Do not give oplocks to system files, otherwise deadlock can occur.  This
    //  can happen, for instance, if the LSA is needing to open a system file to handle
    //  an AcceptSecurityContext request.  If a client has this system file open, we may
    //  need to send a break to the client, which may require us to take a resource already
    //  held during this open operation.
    //
    // Another way to look at it is to assert that we can't allow operation of the local
    //  operating system to depend on timely interactions with clients on the network.
    //
    if( WorkContext->TreeConnect != NULL &&
        WorkContext->TreeConnect->Share->PotentialSystemFile == TRUE &&
        rfcb->Mfcb->FileName.Length > SrvSystemRoot.Length ) {

        UNICODE_STRING  tmpString;

        tmpString = rfcb->Mfcb->FileName;
        tmpString.Length = SrvSystemRoot.Length;

        if( RtlCompareUnicodeString( &SrvSystemRoot, &tmpString, TRUE ) == 0 &&
            tmpString.Buffer[ tmpString.Length / sizeof( WCHAR ) ] == OBJ_NAME_PATH_SEPARATOR ) {

            IF_DEBUG( OPLOCK ) {
                KdPrint(("Oplock request REJECTED for system file: <%wZ>!\n",
                        &rfcb->Mfcb->FileName ));
            }

            return FALSE;
        }
    }

    //
    // Do not give batch oplocks on substreams of files
    //
    if( *OplockType == OplockTypeBatch || *OplockType == OplockTypeServerBatch ) {
        PWCHAR s, es;

        SrvGetBaseFileName( &rfcb->Mfcb->FileName, &fileName );

        for( s = fileName.Buffer; fileName.Length; s++, fileName.Length -= sizeof(WCHAR) ) {
            if( *s == L':' ) {
                IF_DEBUG( OPLOCK ) {
                    KdPrint(("Oplock request REJECTED for substream: <%wZ>!\n",
                            &rfcb->Mfcb->FileName ));
                }
                return FALSE;
            }
        }
    }

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRequestOplock: Attempting to obtain oplock for RFCB %p ", rfcb ));
        SrvPrintwZ( &rfcb->Mfcb->FileName );
        KdPrint(( "\n" ));
    }

    //
    // Set the RFCB oplock to the type of oplock we are requesting.
    //

    if ( *OplockType == OplockTypeExclusive ) {

        rfcb->OplockState = OplockStateOwnExclusive;
        ioControlCode = FSCTL_REQUEST_OPLOCK_LEVEL_1;

    } else if ( *OplockType == OplockTypeBatch ) {

        rfcb->OplockState = OplockStateOwnBatch;
        ioControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    } else if ( *OplockType == OplockTypeServerBatch ) {

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvRequestOplock: requesting server oplock for " ));
            SrvPrintwZ( &rfcb->Mfcb->FileName );
            KdPrint(( "\n" ));
        }
        UpdateRfcbHistory( rfcb, 'osqr' );

        rfcb->OplockState = OplockStateOwnServerBatch;
        ioControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    } else {
        ASSERT(0);
        return(FALSE);
    }

    //
    // Generate and issue the oplock request IRP.
    //

    if (rfcb->Irp != NULL) {

        //DbgPrint( "ACK! Would have allocated second IRP for RFCB %x\n", rfcb );
        UpdateRfcbHistory( rfcb, '2pri' );

        //
        // This RFCB previously owned an oplock, and that oplock has been broken, but
        // the rundown of the oplock is not yet complete.  We can't start a new one,
        // because then there would be two oplock IRPs associated with the RFCB, and
        // the RFCB could be queued twice to the work queue.  (Even if it didn't get
        // queued twice, the completion of the first one would clear Rfcb->Irp.)
        //
        // We could come up with some delay scheme to wait for the previous oplock to
        // rundown, but since the oplock has been broken, it doesn't seem like we want
        // to try again anyway.
        //

        return FALSE;
    }

    UpdateRfcbHistory( rfcb, 'pria' );

    //
    // Reference the RFCB to account for the IRP we are about to submit.
    //

    SrvReferenceRfcb( rfcb );

    rfcb->Irp = SrvBuildIoControlRequest(
                    NULL,
                    lfcb->FileObject,
                    rfcb,
                    IRP_MJ_FILE_SYSTEM_CONTROL,
                    ioControlCode,
                    NULL,                        // Main buffer
                    0,                           // Input buffer length
                    NULL,                        // Auxiliary buffer
                    0,                           // Output buffer length
                    NULL,                        // MDL
                    SrvFsdOplockCompletionRoutine
                    );

    if ( rfcb->Irp == NULL ) {
        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: oplock attempt failed, could not allocate IRP" ));
        }
        rfcb->OplockState = OplockStateNone;

        SrvDereferenceRfcb( rfcb );

        return FALSE;
    }

    //
    // Clear this flag to indicate that this has not caused an oplock
    // break to occur.
    //

    rfcb->DeferredOplockBreak = FALSE;

    //
    // Initialize this event that we use to do an oplock request retry
    // in case the original request fails.  This will prevent the completion
    // routine from cleaning up the irp.
    //

    if ( RequestIIOnFailure ) {
        KeInitializeEvent( &oplockRetryEvent, SynchronizationEvent, FALSE );
        rfcb->RetryOplockRequest = &oplockRetryEvent;
    } else {
        rfcb->RetryOplockRequest = NULL;
    }

    //
    // Make the actual request.
    //

    status = IoCallDriver(
                 lfcb->DeviceObject,
                 rfcb->Irp
                 );

    //
    // If the driver returns STATUS_PENDING, the oplock was granted.
    // The IRP will complete when (1) The driver wants to break to
    // oplock or (2) The file is being closed.
    //

    if ( status == STATUS_PENDING ) {

        //
        // Remember that this work item caused us to generate an oplock
        // request.
        //

        WorkContext->OplockOpen = TRUE;

        IF_DEBUG(OPLOCK) {
            KdPrint(("RequestOplock: oplock attempt successful\n" ));
        }
        UpdateRfcbHistory( rfcb, 'rgpo' );

        return (BOOLEAN)(*OplockType != OplockTypeServerBatch);

    } else if ( RequestIIOnFailure ) {

        //
        // The caller wants us to attempt a level II oplock request.
        //

        ASSERT( *OplockType != OplockTypeServerBatch );

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: Oplock request failed. "
                      "OplockII being attempted.\n" ));
        }

        //
        // Wait for the completion routine to be run.  It will set
        // an event that will signal us to go on.
        //

        KeWaitForSingleObject(
            &oplockRetryEvent,
            WaitAny,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );

        //
        // The Oplock Retry event was signaled. Proceed with the retry.
        //

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: Oplock retry event signalled.\n"));
        }

        //
        // Generate and issue the wait for oplock IRP.  Clear the
        // Retry event pointer so that the completion routine can clean up
        // the irp in case of failure.
        //

        rfcb->RetryOplockRequest = NULL;

        (VOID) SrvBuildIoControlRequest(
                        rfcb->Irp,
                        lfcb->FileObject,
                        rfcb,
                        IRP_MJ_FILE_SYSTEM_CONTROL,
                        FSCTL_REQUEST_OPLOCK_LEVEL_2,
                        NULL,                        // Main buffer
                        0,                           // Input buffer length
                        NULL,                        // Auxiliary buffer
                        0,                           // Output buffer length
                        NULL,                        // MDL
                        SrvFsdOplockCompletionRoutine
                        );


        //
        // Set the RFCB oplock to the type of oplock we are requesting.
        //

        rfcb->OplockState = OplockStateOwnLevelII;

        status = IoCallDriver(
                     lfcb->DeviceObject,
                     rfcb->Irp
                     );

        //
        // If the driver returns STATUS_PENDING, the oplock was granted.
        // The IRP will complete when (1) The driver wants to break to
        // oplock or (2) The file is being closed.
        //

        if ( status == STATUS_PENDING ) {

            //
            // Remember that this work item caused us to generate an oplock
            // request.
            //

            WorkContext->OplockOpen = TRUE;

            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvRequestOplock: OplockII attempt successful\n" ));
            }

            *OplockType = OplockTypeShareRead;
            return TRUE;

        }

    } else {
        UpdateRfcbHistory( rfcb, 'gnpo' );
    }

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRequestOplock: oplock attempt unsuccessful\n" ));
    }

    //
    // Oplock was denied.
    //

    return FALSE;

} // SrvRequestOplock


NTSTATUS
SrvStartWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN PRESTART_ROUTINE RestartRoutine,
    IN HANDLE Handle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This function builds and issues an oplock break notify file system
    control IRP.

Arguments:

    WorkContext - A pointer to the work context block for this request.

    RestartRoutine - The restart routine for this IRP.

    Additional one of the following must be supplied:

    Handle - A handle to the oplocked file.
    FileObject - A pointer to the file object of the oplocked file.

Return Value:

    NTSTATUS.

--*/

{
    PFILE_OBJECT fileObject;
    NTSTATUS status;

    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Allocate memory, so that we can track this wait for oplock break.
    //

    SrvAllocateWaitForOplockBreak( &waitForOplockBreak );

    if (waitForOplockBreak == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }


    IF_DEBUG( OPLOCK ) {
        KdPrint(("Starting wait for oplock break.  Context = %p\n", waitForOplockBreak));
    }

    //
    // Get a pointer to the file object, so that we can directly
    // build a wait for oplock IRP for asynchronous operations.
    //

    if (ARGUMENT_PRESENT( FileObject ) ) {

        fileObject = FileObject;

    } else {

        status = ObReferenceObjectByHandle(
                    Handle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL                     // handle information
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "SrvStartWaitForOplock: unable to reference file handle 0x%lx",
                Handle,
                NULL
                );

            return STATUS_UNSUCCESSFUL;

        }

    }

    //
    // Set the restart routine.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartRoutine;

    //
    // Generate and send the wait for oplock break IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        fileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_OPLOCK_BREAK_NOTIFY,
        NULL,                       // Main buffer
        0,                          // Input buffer length
        NULL,                       // Auxiliary buffer
        0,                          // Output buffer length
        NULL,                       // MDL
        NULL
        );

    //
    // Set the timeout time for the oplock wait to complete.
    //

    WorkContext->WaitForOplockBreak = waitForOplockBreak;

    waitForOplockBreak->WaitState = WaitStateWaitForOplockBreak;
    waitForOplockBreak->Irp = WorkContext->Irp;

    KeQuerySystemTime( (PLARGE_INTEGER)&waitForOplockBreak->TimeoutTime );

    waitForOplockBreak->TimeoutTime.QuadPart += SrvWaitForOplockBreakTime.QuadPart;

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    SrvInsertTailList(
        &SrvWaitForOplockBreakList,
        &waitForOplockBreak->ListEntry
        );

    RELEASE_LOCK( &SrvOplockBreakListLock );

    //
    // Submit the IRP.
    //

    (VOID)IoCallDriver(
              IoGetRelatedDeviceObject( fileObject ),
              WorkContext->Irp
              );

    //
    // We no longer need a reference to the file object.  Dereference
    // it now.
    //

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }

    return STATUS_SUCCESS;

} // SrvStartWaitForOplockBreak


NTSTATUS
SrvWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    This function waits synchrounsly for an oplock to be broken.

    !!!  When cancel is available.  This function will also start timer.
         If the timer expires before the oplock is broken, the wait is
         cancelled.

Arguments:

    FileHandle - A handle to an oplocked file.

Return Value:

    NTSTATUS - The status of the wait for oplock break.

--*/

{
    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Allocate memory, so that we can track this wait for oplock break.
    //

    SrvAllocateWaitForOplockBreak( &waitForOplockBreak );

    if (waitForOplockBreak == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    IF_DEBUG( OPLOCK ) {
        KdPrint(("Starting wait for oplock break.  Context = %p\n", waitForOplockBreak));
    }

    //
    // Set the timeout time for the oplock wait to complete.
    //

    waitForOplockBreak->WaitState = WaitStateWaitForOplockBreak;
    waitForOplockBreak->Irp = NULL;

    KeQuerySystemTime( (PLARGE_INTEGER)&waitForOplockBreak->TimeoutTime );

    waitForOplockBreak->TimeoutTime.QuadPart += SrvWaitForOplockBreakTime.QuadPart;

    //
    // SrvIssueWaitForOplockBreakRequest will queue the waitForOplockBreak
    // structure on the global list of oplock breaks.
    //

    return SrvIssueWaitForOplockBreak(
               FileHandle,
               waitForOplockBreak
               );

} // SrvWaitForOplockBreak


VOID
SrvSendDelayedOplockBreak (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function sends outstanding oplock breaks on a connection that
    were held back because a read raw operation was in progress.

Arguments:

    Connection - A pointer to the connection block that has completed
                 a read raw operation.

Return Value:

    None

--*/

{
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PRFCB rfcb;
#if SRVDBG
    ULONG oplockBreaksSent = 0;
#endif

    //UNLOCKABLE_CODE( CONN );

    //
    // Acquire the lock that protects the connection's oplock list and
    // raw read status.
    //

    ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );

    //
    // Indicate that the read raw operation is complete.  If the count
    // goes to zero, oplock breaks can proceed.
    //

    Connection->RawReadsInProgress--;

    while ( (Connection->RawReadsInProgress == 0) &&
            !IsListEmpty( &Connection->OplockWorkList ) ) {

        //
        // There is an outstanding oplock break request.  Send
        // the request now.
        //

        listEntry = Connection->OplockWorkList.Flink;

        RemoveHeadList( &Connection->OplockWorkList );

        //
        // Note that releasing the spin lock here is safe.  If a new
        // raw read request comes in, it will be rejected, because the
        // OplockBreaksInProgress count is not zero.  Also, if the
        // oplock break count manages to go to zero, and a raw read
        // comes in, we'll catch this back at the top of the loop.
        //

        RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );

        rfcb = (PRFCB)CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif

        workContext = GenerateOplockBreakRequest( rfcb );

        if ( workContext != NULL ) {

            //
            // Copy the RFCB reference to the work context block.
            //

            workContext->Rfcb = rfcb;

            //
            // !!! Is the init of share, session, tree connect
            //     necessary?
            //

            workContext->Share = NULL;
            workContext->Session = NULL;
            workContext->TreeConnect = NULL;
            workContext->SecurityContext = NULL;

            workContext->Connection = rfcb->Connection;
            SrvReferenceConnection( workContext->Connection );

            workContext->Endpoint = workContext->Connection->Endpoint;

            SrvRestartOplockBreakSend( workContext );
#if SRVDBG
            oplockBreaksSent++;
#endif

        } else {

            //
            // We are out of resources.  GenerateOplockRequest, has
            // added this connection to the needs resource queue. The
            // scavenger will finish processing the remainder of the
            // oplock break requests when resources become available.
            //

#if SRVDBG
            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvSendDelayedOplockBreak: sent %d\n", oplockBreaksSent ));
            }
#endif
            return;

        }

        ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );

    }

    //
    // We have stopped trying to send oplock break requests. The
    // scavenger will attempt to send the rest.
    //

#if SRVDBG
    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvSendDelayedOplockBreak: sent %d\n", oplockBreaksSent ));
    }
#endif

    RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );

    return;

} // SrvSendDelayedOplockBreak


NTSTATUS
SrvCheckOplockWaitState (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This function checks the state of a wait for oplock break, and
    takes action.

Arguments:

    WaitForOplockBreak

Return Value:

    NTSTATUS -
        STATUS_SUCCESS - The oplock was successfully broken.
        STATUS_SHARING_VIOLATION - The oplock could not be broken.
--*/

{
    PAGED_CODE( );

    if ( WaitForOplockBreak == NULL ) {
        return STATUS_SUCCESS;
    }

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    if ( WaitForOplockBreak->WaitState == WaitStateOplockWaitTimedOut ) {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvCheckOplockWaitState: Oplock wait timed out\n"));
        }

        RELEASE_LOCK( &SrvOplockBreakListLock );
        return STATUS_SHARING_VIOLATION;

    } else {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvCheckOplockWaitState: Oplock wait succeeded\n"));
        }

        WaitForOplockBreak->WaitState = WaitStateOplockWaitSucceeded;

        SrvRemoveEntryList(
            &SrvWaitForOplockBreakList,
            &WaitForOplockBreak->ListEntry
            );

        RELEASE_LOCK( &SrvOplockBreakListLock );

        //
        // The WaitForOplockBreak has been taken off of the wait for oplock
        // break list.  Decrement the reference count.
        //

        SrvDereferenceWaitForOplockBreak( WaitForOplockBreak );

        return STATUS_SUCCESS;

    }

} // SrvCheckOplockWaitState

LARGE_INTEGER
SrvGetOplockBreakTimeout (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function computes the timeout to wait for an oplock break response
    from the client.  This is based on the formula:

        new timeout = current time + default timeout +
                      link delay + requestSize / throughput +
                      link delay + responseSize / thoughput

Arguments:

    WorkContext - Pointer to the work context block that points to the
        connection that owns this oplock.

Return Value:

    The timeout value.

--*/

{
    LARGE_INTEGER timeoutTime;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER throughput;
    LARGE_INTEGER additionalTimeoutTime;
    LARGE_INTEGER propagationDelay;
    PCONNECTION connection = WorkContext->Connection;

    PAGED_CODE( );

    //
    // Get current time.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Add default timeout
    //

    timeoutTime.QuadPart = currentTime.QuadPart +
                                SrvWaitForOplockBreakRequestTime.QuadPart;

    //
    // Update link QOS.
    //

    SrvUpdateVcQualityOfService(
        connection,
        &currentTime
        );

    //
    // Access connection QOS fields using a spin lock.
    //

    ACQUIRE_LOCK( &connection->Lock );
    throughput = connection->PagedConnection->Throughput;
    additionalTimeoutTime = connection->PagedConnection->Delay;
    RELEASE_LOCK( &connection->Lock );

    //
    // Calculate the actual timeout.
    //

    if ( throughput.QuadPart == 0 ) {
        throughput = SrvMinLinkThroughput;
    }

    //
    // Add link delay + link delay to account for round trip.
    //

    additionalTimeoutTime.QuadPart *= 2;

    if ( throughput.QuadPart != 0 ) {

        //
        // Compute the propagation delay.  Convert throughput from bytes/s
        // to bytes/100ns.
        //

        propagationDelay.QuadPart =
            Int32x32To64( SRV_PROPAGATION_DELAY_SIZE, 10*1000*1000 );

        propagationDelay.QuadPart /= throughput.QuadPart;

        additionalTimeoutTime.QuadPart += propagationDelay.QuadPart;

    }

    timeoutTime.QuadPart += additionalTimeoutTime.QuadPart;

    return timeoutTime;

} // SrvGetOplockBreakTimeout

VOID
SrvSendOplockRequest(
    IN PCONNECTION Connection,
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )
/*++

Routine Description:

    This function tries to send an oplock break request to the owner of
    an oplock.

    *** Must be called with the EndpointSpinLock held. Released on exit ***

Arguments:

    Connection - The connection on which to send the oplock break.

    Rfcb - The RFCB of the oplocked file.  Rfcb->NewOplockLevel contains the
           oplock level to break to.  The rfcb has an extra reference
           from the irp used to make the oplock request.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/
{
    PWORK_CONTEXT workContext;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Indicate that we are about to send an oplock break request
    // and queue this request to the oplocks in progress list.
    //

    Connection->OplockBreaksInProgress++;

    //
    // If there is a read raw in progress we will defer the oplock
    // break request and send it only after the read raw has
    // completed.
    //

    if ( Connection->RawReadsInProgress != 0 ) {

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "SrvOplockBreakNotification: Read raw in progress; "
                       "oplock break deferred\n"));
        }

        //
        // if the connection is closing, forget about this.
        //

        if ( GET_BLOCK_STATE(Connection) != BlockStateActive ) {

            Connection->OplockBreaksInProgress--;

            //
            // Dereference the rfcb.
            //

            RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );

            SrvDereferenceRfcb( Rfcb );

        } else {

            //
            // Save the RFCB on the list for this connection.  It will be
            // used when the read raw has completed.
            //

            InsertTailList( &Connection->OplockWorkList, &Rfcb->ListEntry );

            RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );
        }

        return;
    }

    RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );

    workContext = GenerateOplockBreakRequest( Rfcb );

    //
    // If we were able to generate the oplock break request SMB
    // prepare and send it.  Otherwise this connection has
    // been inserted in the need resource queue and the
    // scavenger will have to send the SMB.
    //

    if ( workContext != NULL ) {

        //
        // Copy the RFCB reference to the work context block.
        // Do not re-reference the RFCB.
        //

        workContext->Rfcb = Rfcb;

        //
        // !!! Is the init of share, session, tree connect
        //     necessary?
        //

        workContext->Share = NULL;
        workContext->Session = NULL;
        workContext->TreeConnect = NULL;
        workContext->SecurityContext = NULL;

        workContext->Connection = Connection;
        SrvReferenceConnection( Connection );

        workContext->Endpoint = Connection->Endpoint;

        SrvRestartOplockBreakSend( workContext );

    }

} // SrvSendOplockRequest

VOID SRVFASTCALL
SrvCheckDeferredOpenOplockBreak(
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine checks to see if there an oplock break was deferred
    pending the completion of the open request.  If there is, try to
    send it.

Arguments:

    WorkContext - Pointer to the work item that contains the rfcb
        and the connection block of the open request that just finished.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    PRFCB rfcb;
    PCONNECTION connection;

    UNLOCKABLE_CODE( 8FIL );

    //
    // This work item contained an open and oplock request.  Now that
    // the response has been sent, see if there is a deferred oplock
    // break request to send.
    //

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;

    ASSERT( rfcb != NULL );

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    rfcb->OpenResponseSent = TRUE;

    if ( rfcb->DeferredOplockBreak ) {

        //
        // EndpointSpinLock will be released in this routine.
        //

        SrvSendOplockRequest( connection, rfcb, oldIrql );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    }

    return;

} // SrvCheckDeferredOpenOplockBreak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\prnsupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    prnsupp.c

Abstract:

    This module contains routines for supporting printing in the NT
    server.  Many of these routines are wrappers that send the request
    off to XACTSRV through LPC in order to issue a user-mode API.

Author:

    David Treadwell (davidtr) 05-Nov-1991

Revision History:

--*/

#include "precomp.h"
#include "prnsupp.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvOpenPrinter )
#pragma alloc_text( PAGE, SrvAddPrintJob )
#pragma alloc_text( PAGE, SrvSchedulePrintJob )
#pragma alloc_text( PAGE, SrvClosePrinter )
#endif


NTSTATUS
SrvOpenPrinter(
    IN PWCH PrinterName,
    OUT PHANDLE phPrinter,
    OUT PULONG Error
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    OpenPrinter( ).  This packages up a call and sends it off to
    Xactsrv, which makes the actual API call.

Arguments:

    Printer - a pointer to a Unicode string of the printer to open

    Handle - receives a handle, valid only in XACTSRV, that corresponds to
        the Printer open.

    Error - a Win32 error if one occurred, or NO_ERROR if the operation
        was successful.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    PSZ printerName;
    ULONG printerNameLength;

    PAGED_CODE( );

    printerNameLength = wcslen( PrinterName ) * sizeof(WCHAR) + sizeof(WCHAR);

    printerName = SrvXsAllocateHeap( printerNameLength, &status );

    if ( printerName == NULL ) {
        *Error = RtlNtStatusToDosErrorNoTeb( status );
        return status;
    }

    //
    // SrvXsResource is held at this point
    //

    //
    // Copy over the printer name to the new memory.
    //

    RtlCopyMemory( printerName, PrinterName, printerNameLength );

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_OPEN_PRINTER;
    requestMessage.Message.OpenPrinter.PrinterName =
        (PCHAR)printerName + SrvXsPortMemoryDelta;

    //
    // Send the message to XACTSRV so it can call OpenPrinter( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint2( "SrvOpenPrinter: sending message at %p PrinterName %s\n",
                       &requestMessage,
                       (PCHAR)requestMessage.Message.OpenPrinter.PrinterName );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvOpenPrinter: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        *Error = ERROR_UNEXP_NET_ERR;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvOpenPrinter: received response at %p\n", &replyMessage );
    }

    *phPrinter = replyMessage.Message.OpenPrinter.hPrinter;
    *Error = replyMessage.Message.OpenPrinter.Error;

exit:

    SrvXsFreeHeap( printerName );

    return status;

} // SrvOpenPrinter


NTSTATUS
SrvAddPrintJob (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE Handle,
    IN OUT PUNICODE_STRING FileName,
    OUT PULONG JobId,
    OUT PULONG Error
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the user-mode API AddJob(  ).
    This API returns a filename to use as a disk spool file and a
    Job ID to identify the print job to the spooler subsystem.

Arguments:

    Handle - the Printer handle.

    FileName - filled in with the Unicode name of the file to open as
        a spool filed.  The MaximumLength and Buffer fields should
        be valid on input and are not changed.  Length is changed to
        indicate the length of the NT path name of the file.

    JobId - filled in with the Job ID of the print job.  This value
        is used to call ScheduleJob( ) when the writing of the spool
        file is complete and printing should begin.

    Error - if AddJob failed in XACTSRV, this is the error code.

Return Value:

    NTSTATUS - result of operation.  If AddJob( ) failed, NTSTATUS =
        STATUS_UNSUCCESSFUL and Error contains the real error code.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    ANSI_STRING fileName;
    PCONNECTION connection = WorkContext->Connection;
    PWCH destPtr, sourcePtr, sourceEndPtr;

    PAGED_CODE( );

    *Error = NO_ERROR;
    fileName.Buffer = NULL;

    //
    // Allocate space to hold the buffer for the file name that will be
    // returned.
    //

    fileName.Buffer = SrvXsAllocateHeap(
                           MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR),
                           &status
                           );

    if ( fileName.Buffer == NULL ) {
        *Error = RtlNtStatusToDosErrorNoTeb( status );
        return(status);
    }

    //
    // SrvXsResource is held at this point
    //

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_ADD_JOB_PRINTER;
    requestMessage.Message.AddPrintJob.hPrinter = Handle;
    requestMessage.Message.AddPrintJob.Buffer =
                          fileName.Buffer + SrvXsPortMemoryDelta;
    requestMessage.Message.AddPrintJob.BufferLength = MAXIMUM_FILENAME_LENGTH;

    // Add client machine name for notification
    //
    // Copy the client machine name for XACTSRV, skipping over the
    // initial "\\", and deleting trailing spaces.
    //

    destPtr = requestMessage.Message.AddPrintJob.ClientMachineName;
    sourcePtr =
        connection->ClientMachineNameString.Buffer + 2;
    sourceEndPtr = sourcePtr
        + min( connection->ClientMachineNameString.Length,
               sizeof(requestMessage.Message.AddPrintJob.ClientMachineName) /
               sizeof(WCHAR) - 1 );

    while ( sourcePtr < sourceEndPtr && *sourcePtr != UNICODE_NULL ) {
        *destPtr++ = *sourcePtr++;
    }

    *destPtr-- = UNICODE_NULL;

    while ( destPtr >= requestMessage.Message.AddPrintJob.ClientMachineName
            &&
            *destPtr == L' ' ) {
        *destPtr-- = UNICODE_NULL;
    }


    //
    // Send the message to XACTSRV so it can call AddJob( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvAddPrintJob: sending message at %p", &requestMessage );
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {
        status = NtRequestWaitReplyPort(
                     SrvXsPortHandle,
                     (PPORT_MESSAGE)&requestMessage,
                     (PPORT_MESSAGE)&replyMessage
                     );

        REVERT( );
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvAddPrintJob: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );

        *Error = ERROR_UNEXP_NET_ERR;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvAddPrintJob: received response at %p\n", &replyMessage );
    }

    if ( replyMessage.Message.AddPrintJob.Error != NO_ERROR ) {
        *Error = replyMessage.Message.AddPrintJob.Error;
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Set up return information.
    //

    *JobId = replyMessage.Message.AddPrintJob.JobId;
    FileName->Length = MIN(replyMessage.Message.AddPrintJob.BufferLength, FileName->MaximumLength );
    RtlCopyMemory( FileName->Buffer, fileName.Buffer, FileName->Length );

exit:

    SrvXsFreeHeap( fileName.Buffer );

    return status;

} // SrvAddPrintJob


NTSTATUS
SrvSchedulePrintJob (
    IN HANDLE PrinterHandle,
    IN ULONG JobId
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    ScheduleJob( ).

Arguments:

    PrinterHandle - a handle to a printer returned by OpenPrinter( ).

    JobId - the job ID returned to AddJob( ) that identifies this print
        job.

    Error - if ScheduleJob failed in XACTSRV, this is the error code.

Return Value:

    NTSTATUS - result of operation.  If ScheduleJob( ) failed, NTSTATUS =
        STATUS_UNSUCCESSFUL and Error contains the real error code.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;

    PAGED_CODE( );

    //
    // Grab the XsResource
    //

    (VOID) SrvXsAllocateHeap( 0, &status );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_SCHD_JOB_PRINTER;
    requestMessage.Message.SchedulePrintJob.hPrinter = PrinterHandle;
    requestMessage.Message.SchedulePrintJob.JobId = JobId;

    //
    // Send the message to XACTSRV so it can call ScheduleJob( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvSchedulePrintJob: sending message at %p", &requestMessage );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSchedulePrintJob: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvSchedulePrintJob: received response at %p\n",
                       &replyMessage );
    }

exit:

    //
    // release the lock
    //

    SrvXsFreeHeap( NULL );

    return status;

} // SrvSchedulePrintJob


NTSTATUS
SrvClosePrinter (
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    ClosePrinter( ).

Arguments:

    Handle - the Printer handle to close.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;

    PAGED_CODE( );

    //
    // Grab the XsResource
    //

    (VOID) SrvXsAllocateHeap( 0, &status );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // SrvXsResource is held at this point
    //


    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_CLOSE_PRINTER;
    requestMessage.Message.ClosePrinter.hPrinter = Handle;

    //
    // Send the message to XACTSRV so it can call ClosePrinter( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvClosePrinter: sending message at %p", &requestMessage );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvClosePrinter: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvClosePrinter: received response at %p\n", &replyMessage );
    }

exit:

    //
    // release the lock
    //

    SrvXsFreeHeap( NULL );

    return status;

} // SrvClosePrinter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\rawmpx.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rawmpx.h

Abstract:

    This module defines structures and routines common to raw and
    multiplexed mode processing.

Author:

    Chuck Lenzmeier (chuckl) 30-Sep-1990

Revision History:

--*/

#ifndef _RAWMPX_
#define _RAWMPX_

//#include <ntos.h>

//#include <smb.h>
//#include "smbtypes.h"
//#include "srvblock.h"

//
// Common (raw and mpx) routines, callable from both FSD and FSP.
// Implemented in fsdraw.c.
//
// SrvFsdBuildWriteCompleteResponse can be called from a DISPATCH_LEVEL
// only if Status == STATUS_SUCCESS.
//

VOID
SrvFsdBuildWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN ULONG BytesWritten
    );

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines callable from both FSD and FSP.  Implemented in
// fsdraw.c.
//

VOID SRVFASTCALL
SrvFsdRestartPrepareRawMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWriteRaw (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines called only in FSD, but referenced in FSP.
// Implemented in fsdraw.c.
//

VOID SRVFASTCALL
SrvFsdRestartReadRaw (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines called only in FSP, but referenced in FSD, or in
// modules other than smbraw.c.  Implemented in smbraw.c.
//

VOID SRVFASTCALL
SrvBuildAndSendWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvDecrementRawWriteCount (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvRestartRawReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartReadRawComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Special receive restart routine for Write Mpx.
//

VOID SRVFASTCALL
SrvRestartReceiveWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Write glomming during indication
//

BOOLEAN
AddPacketToGlomInIndication (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PRFCB Rfcb,
    IN PVOID Tsdu,
    IN ULONG BytesAvailable,
    IN ULONG ReceiveDatagamFlags,
    IN PVOID SourceAddress,
    IN PVOID Options
    );

#endif // def _RAWMPX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\scavengr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This module implements the LAN Manager server FSP resource and
    scavenger threads.

Author:

    Chuck Lenzmeier (chuckl) 30-Dec-1989
    David Treadwell (davidtr)

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#include <ntdddisk.h>
#include "scavengr.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SCAVENGR

//
// Local data
//

ULONG LastNonPagedPoolLimitHitCount = 0;
ULONG LastNonPagedPoolFailureCount = 0;
ULONG LastPagedPoolLimitHitCount = 0;
ULONG LastPagedPoolFailureCount = 0;

ULONG SrvScavengerCheckRfcbActive = 5;
LONG ScavengerUpdateQosCount = 0;
LONG ScavengerCheckRfcbActive = 0;
LONG FailedWorkItemAllocations = 0;

ULONG OutOfFreeConnectionConsecutiveCount = 0;

BOOLEAN EventSwitch = TRUE;

LARGE_INTEGER NextScavengeTime = {0};
LARGE_INTEGER NextAlertTime = {0};

//
// Fields used during shutdown to synchronize with EX worker threads.  We
// need to make sure that no worker thread is running server code before
// we can declare shutdown to be complete -- otherwise the code may be
// unloaded while it's running!
//

BOOLEAN ScavengerInitialized = FALSE;
PKEVENT ScavengerTimerTerminationEvent = NULL;
PKEVENT ScavengerThreadTerminationEvent = NULL;
PKEVENT ResourceThreadTerminationEvent = NULL;
PKEVENT ResourceAllocThreadTerminationEvent = NULL;

//
// Timer, DPC, and work item used to run the scavenger thread.
//

KTIMER ScavengerTimer = {0};
KDPC ScavengerDpc = {0};

PIO_WORKITEM ScavengerWorkItem = NULL;

BOOLEAN ScavengerRunning = FALSE;

KSPIN_LOCK ScavengerSpinLock = {0};

//
// Flags indicating which scavenger algorithms need to run.
//

BOOLEAN RunShortTermAlgorithm = FALSE;
BOOLEAN RunScavengerAlgorithm = FALSE;
BOOLEAN RunAlerterAlgorithm = FALSE;
BOOLEAN RunSuspectConnectionAlgorithm = FALSE;

//
// Base scavenger timeout.  A timer DPC runs each interval.  It
// schedules EX worker thread work when other longer intervals expire.
//

LARGE_INTEGER ScavengerBaseTimeout = { (ULONG)(-1*10*1000*1000*10), -1 };

#define SRV_MAX_DOS_ATTACK_EVENT_LOGS 10

//
//  Defined somewhere else.
//

LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

//
// Local declarations
//

VOID
ScavengerTimerRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SrvResourceThread (
    IN PVOID Parameter
    );

VOID
ScavengerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    );

VOID
ScavengerAlgorithm (
    VOID
    );

VOID
AlerterAlgorithm (
    VOID
    );

VOID
CloseIdleConnection (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER DisconnectTime,
    IN PLARGE_INTEGER PastExpirationTime,
    IN PLARGE_INTEGER TwoMinuteWarningTime,
    IN PLARGE_INTEGER FiveMinuteWarningTime
    );

VOID
CreateConnections (
    VOID
    );

VOID
GeneratePeriodicEvents (
    VOID
    );

VOID
ProcessConnectionDisconnects (
    VOID
    );

VOID
ProcessOrphanedBlocks (
    VOID
    );

VOID
TimeoutSessions (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
TimeoutWaitingOpens (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
TimeoutStuckOplockBreaks (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
UpdateConnectionQos (
    IN PLARGE_INTEGER currentTime
    );

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    );

VOID
LazyFreeQueueDataStructures (
    PWORK_QUEUE queue
    );

VOID
SrvUserAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING ComputerName
    );

VOID
SrvAdminAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING String3 OPTIONAL
    );

NTSTATUS
TimeToTimeString (
    IN PLARGE_INTEGER Time,
    OUT PUNICODE_STRING TimeString
    );

ULONG
CalculateErrorSlot (
    PSRV_ERROR_RECORD ErrorRecord
    );

VOID
CheckErrorCount (
    PSRV_ERROR_RECORD ErrorRecord,
    BOOLEAN UseRatio
    );

VOID
CheckDiskSpace (
    VOID
    );

NTSTATUS
OpenAlerter (
    OUT PHANDLE AlerterHandle
    );

VOID
RecalcCoreSearchTimeout(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeScavenger )
#pragma alloc_text( PAGE, ScavengerAlgorithm )
#pragma alloc_text( PAGE, AlerterAlgorithm )
#pragma alloc_text( PAGE, CloseIdleConnection )
#pragma alloc_text( PAGE, CreateConnections )
#pragma alloc_text( PAGE, GeneratePeriodicEvents )
#pragma alloc_text( PAGE, TimeoutSessions )
#pragma alloc_text( PAGE, TimeoutWaitingOpens )
#pragma alloc_text( PAGE, TimeoutStuckOplockBreaks )
#pragma alloc_text( PAGE, UpdateConnectionQos )
#pragma alloc_text( PAGE, UpdateSessionLastUseTime )
#pragma alloc_text( PAGE, SrvUserAlertRaise )
#pragma alloc_text( PAGE, SrvAdminAlertRaise )
#pragma alloc_text( PAGE, TimeToTimeString )
#pragma alloc_text( PAGE, CheckErrorCount )
#pragma alloc_text( PAGE, CheckDiskSpace )
#pragma alloc_text( PAGE, OpenAlerter )
#pragma alloc_text( PAGE, ProcessOrphanedBlocks )
#pragma alloc_text( PAGE, RecalcCoreSearchTimeout )
#endif
#if 0
NOT PAGEABLE -- SrvTerminateScavenger
NOT PAGEABLE -- ScavengerTimerRoutine
NOT PAGEABLE -- SrvResourceThread
NOT PAGEABLE -- ScavengerThread
NOT PAGEABLE -- ProcessConnectionDisconnects
NOT PAGEABLE -- SrvServiceWorkItemShortage
NOT PAGEABLE -- LazyFreeQueueDataStructures
NOT PAGEABLE -- SrvUpdateStatisticsFromQueues
#endif


NTSTATUS
SrvInitializeScavenger (
    VOID
    )

/*++

Routine Description:

    This function creates the scavenger thread for the LAN Manager
    server FSP.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of thread creation

--*/

{
    LARGE_INTEGER currentTime;

    PAGED_CODE( );

    //
    // Initialize the scavenger spin lock.
    //

    INITIALIZE_SPIN_LOCK( &ScavengerSpinLock );

    //
    // When this count is zero, we will update the QOS information for
    // each active connection.
    //

    ScavengerUpdateQosCount = SrvScavengerUpdateQosCount;

    //
    // When this count is zero, we will check the rfcb active status.
    //

    ScavengerCheckRfcbActive = SrvScavengerCheckRfcbActive;

    //
    // Get the current time and calculate the next time the scavenge and
    // alert algorithms need to run.
    //

    KeQuerySystemTime( &currentTime );
    NextScavengeTime.QuadPart = currentTime.QuadPart + SrvScavengerTimeout.QuadPart;
    NextAlertTime.QuadPart = currentTime.QuadPart + SrvAlertSchedule.QuadPart;

    ScavengerWorkItem = IoAllocateWorkItem( SrvDeviceObject );
    if( !ScavengerWorkItem )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the scavenger DPC, which will queue the work item.
    //

    KeInitializeDpc( &ScavengerDpc, ScavengerTimerRoutine, NULL );

    //
    // Start the scavenger timer.  When the timer expires, the DPC will
    // run and will queue the work item.
    //

    KeInitializeTimer( &ScavengerTimer );
    ScavengerInitialized = TRUE;
    KeSetTimer( &ScavengerTimer, ScavengerBaseTimeout, &ScavengerDpc );

    return STATUS_SUCCESS;

} // SrvInitializeScavenger


VOID
SrvTerminateScavenger (
    VOID
    )
{
    KEVENT scavengerTimerTerminationEvent;
    KEVENT scavengerThreadTerminationEvent;
    KEVENT resourceThreadTerminationEvent;
    KEVENT resourceAllocThreadTerminationEvent;
    BOOLEAN waitForResourceThread;
    BOOLEAN waitForResourceAllocThread;
    BOOLEAN waitForScavengerThread;
    KIRQL oldIrql;

    if ( ScavengerInitialized ) {

        //
        // Initialize shutdown events before marking the scavenger as
        // shutting down.
        //

        KeInitializeEvent(
            &scavengerTimerTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ScavengerTimerTerminationEvent = &scavengerTimerTerminationEvent;

        KeInitializeEvent(
            &scavengerThreadTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ScavengerThreadTerminationEvent = &scavengerThreadTerminationEvent;

        KeInitializeEvent(
            &resourceThreadTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ResourceThreadTerminationEvent = &resourceThreadTerminationEvent;

        KeInitializeEvent(
            &resourceAllocThreadTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ResourceAllocThreadTerminationEvent = &resourceAllocThreadTerminationEvent;

        //
        // Lock the scavenger, then indicate that we're shutting down.
        // Also, notice whether the resource and scavenger threads are
        // running.  Then release the lock.  We must notice whether the
        // threads are running while holding the lock so that we can
        // know whether to expect the threads to set their termination
        // events.  (We don't have to do this with the scavenger timer
        // because it's always running.)
        //

        ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

        waitForScavengerThread = ScavengerRunning;
        waitForResourceThread = SrvResourceThreadRunning;
        waitForResourceAllocThread = SrvResourceAllocThreadRunning;
        ScavengerInitialized = FALSE;

        RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

        //
        // Cancel the scavenger timer.  If this works, then we know that
        // the timer DPC code is not running.  Otherwise, it is running
        // or queued to run, and we need to wait it to finish.
        //

        if ( !KeCancelTimer( &ScavengerTimer ) ) {
            KeWaitForSingleObject(
                &scavengerTimerTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }

        //
        // If the scavenger thread was running when we marked the
        // shutdown, wait for it to finish.  (If it wasn't running
        // before, we know that it can't be running now, because timer
        // DPC wouldn't have started it once we marked the shutdown.)
        //

        if ( waitForScavengerThread ) {
            KeWaitForSingleObject(
                &scavengerThreadTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }
        else
        {
            IoFreeWorkItem( ScavengerWorkItem );
        }

        //
        // If the resource thread was running when we marked the
        // shutdown, wait for it to finish.  (We know that it can't be
        // started because no other part of the server is running.)
        //

        if ( waitForResourceThread ) {
            KeWaitForSingleObject(
                &resourceThreadTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }

        if ( waitForResourceAllocThread ) {
            KeWaitForSingleObject(
                &resourceAllocThreadTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }


    }

    //
    // At this point, no part of the scavenger is running.
    //

    return;

} // SrvTerminateScavenger


VOID
SrvResourceThread (
    IN PVOID Parameter
    )

/*++

Routine Description:

    Main routine for the resource thread.  Is called via an executive
    work item when resource work is needed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN runAgain = TRUE;
    PWORK_CONTEXT workContext;
    KIRQL oldIrql;

    do {

        //
        // The resource event was signaled.  This can indicate a number
        // of different things.  Currently, this event is signaled for
        // the following reasons:
        //
        // 1.  The TDI disconnect event handler was called.  The
        //     disconnected connection was marked.  It is up to the
        //     scavenger shutdown the connection.
        //
        // 2.  A connection has been accepted.
        //

        IF_DEBUG(SCAV1) {
            KdPrint(( "SrvResourceThread: Resource event signaled!\n" ));
        }

        //
        // Service pending disconnects.
        //

        if ( SrvResourceDisconnectPending ) {
            SrvResourceDisconnectPending = FALSE;
            ProcessConnectionDisconnects( );
        }

        //
        // Service orphaned connections.
        //

        if ( SrvResourceOrphanedBlocks ) {
            ProcessOrphanedBlocks( );
        }

        //
        // At the end of the loop, check to see whether we need to run
        // the loop again.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        if ( !SrvResourceDisconnectPending &&
             !SrvResourceOrphanedBlocks ) {

            //
            // No more work to do.  If the server is shutting down,
            // set the event that tells SrvTerminateScavenger that the
            // resource thread is done running.
            //

            SrvResourceThreadRunning = FALSE;
            runAgain = FALSE;

            if ( !ScavengerInitialized ) {
                KeSetEvent( ResourceThreadTerminationEvent, 0, FALSE );
            }

        }

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    } while ( runAgain );

    ObDereferenceObject( SrvDeviceObject );

    return;

} // SrvResourceThread


VOID
SrvResourceAllocThread (
    IN PVOID Parameter
    )

/*++

Routine Description:

    Main routine for the resource thread.  Is called via an executive
    work item when we need to allocate resources.  This was split from
    SrvResourceThread because that thread can block on the local FS,
    resulting in resource shortages.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN runAgain = TRUE;
    PWORK_CONTEXT workContext;
    KIRQL oldIrql;

    do {

        //
        // The resource event was signaled.  This can indicate a number
        // of different things.  Currently, this event is signaled for
        // the following reasons:
        //
        // 1.  The TDI disconnect event handler was called.  The
        //     disconnected connection was marked.  It is up to the
        //     scavenger shutdown the connection.
        //
        // 2.  A connection has been accepted.
        //

        IF_DEBUG(SCAV1) {
            KdPrint(( "SrvResourceThread: Resource event signaled!\n" ));
        }

        //
        // Service endpoints that need connections.
        //

        if ( SrvResourceAllocConnection ) {
            SrvResourceAllocConnection = FALSE;
            CreateConnections( );
        }

        //
        // At the end of the loop, check to see whether we need to run
        // the loop again.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        if ( !SrvResourceAllocConnection ) {

            //
            // No more work to do.  If the server is shutting down,
            // set the event that tells SrvTerminateScavenger that the
            // resource thread is done running.
            //

            SrvResourceAllocThreadRunning = FALSE;
            runAgain = FALSE;

            if ( !ScavengerInitialized ) {
                KeSetEvent( ResourceAllocThreadTerminationEvent, 0, FALSE );
            }

        }

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    } while ( runAgain );

    ObDereferenceObject( SrvDeviceObject );

    return;

} // SrvResourceAllocThread


VOID
ScavengerTimerRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    BOOLEAN runShortTerm;
    BOOLEAN runScavenger;
    BOOLEAN runAlerter;
    BOOLEAN start;

    LARGE_INTEGER currentTime;

    Dpc, DeferredContext;   // prevent compiler warnings

    //
    // Query the system time (in ticks).
    //

    SET_SERVER_TIME( SrvWorkQueues );

    //
    // Capture the current time (in 100ns units).
    //

    currentTime.LowPart = PtrToUlong(SystemArgument1);
    currentTime.HighPart = PtrToUlong(SystemArgument2);

    //
    // Determine which algorithms (if any) need to run.
    //

    start = FALSE;

    if ( !IsListEmpty( &SrvOplockBreaksInProgressList ) ) {
        runShortTerm = TRUE;
        start = TRUE;
    } else {
        runShortTerm = FALSE;
    }

    if ( currentTime.QuadPart >= NextScavengeTime.QuadPart ) {
        runScavenger = TRUE;
        start = TRUE;
    } else {
        runScavenger = FALSE;
    }

    if ( currentTime.QuadPart >= NextAlertTime.QuadPart ) {
        runAlerter = TRUE;
        start = TRUE;
    } else {
        runAlerter = FALSE;
    }

    //
    // If necessary, start the scavenger thread.  Don't do this if
    // the server is shutting down.
    //

    ACQUIRE_DPC_SPIN_LOCK( &ScavengerSpinLock );

    if ( !ScavengerInitialized ) {

        KeSetEvent( ScavengerTimerTerminationEvent, 0, FALSE );

    } else {

        if ( start ) {

            if ( runShortTerm ) {
                RunShortTermAlgorithm = TRUE;
            }

            if ( runScavenger ) {
                RunScavengerAlgorithm = TRUE;
                NextScavengeTime.QuadPart += SrvScavengerTimeout.QuadPart;
            }
            if ( runAlerter ) {
                RunAlerterAlgorithm = TRUE;
                NextAlertTime.QuadPart += SrvAlertSchedule.QuadPart;
            }

            if( !ScavengerRunning )
            {
                ScavengerRunning = TRUE;
                IoQueueWorkItem( ScavengerWorkItem, ScavengerThread, CriticalWorkQueue, NULL );
            }
        }

        //
        // Restart the timer.
        //

        KeSetTimer( &ScavengerTimer, ScavengerBaseTimeout, &ScavengerDpc );

    }

    RELEASE_DPC_SPIN_LOCK( &ScavengerSpinLock );

    return;

} // ScavengerTimerRoutine

#if DBG_STUCK

//
// This keeps a record of the operation which has taken the longest time
// in the server
//
struct {
    ULONG   Seconds;
    UCHAR   Command;
    UCHAR   ClientName[ 16 ];
} SrvMostStuck;

VOID
SrvLookForStuckOperations()
{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN printed = FALSE;
    ULONG stuckCount = 0;

    //
    // Look at all of the InProgress work items and chatter about any
    //  which look stuck
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TRUE ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // Now walk the InProgressWorkItemList to see if any work items
            //  look stuck
            //
            wlistHead = &connection->InProgressWorkItemList;
            wlistEntry = wlistHead;

            KeQuerySystemTime( &now );

            ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql )

            while ( wlistEntry->Flink != wlistHead ) {

                PWORK_CONTEXT workContext;
                PSMB_HEADER header;
                LARGE_INTEGER interval;

                wlistEntry = wlistEntry->Flink;

                workContext = CONTAINING_RECORD(
                                             wlistEntry,
                                             WORK_CONTEXT,
                                             InProgressListEntry
                                             );

                interval.QuadPart = now.QuadPart - workContext->OpStartTime.QuadPart;

                //
                // Any operation over 45 seconds is VERY stuck....
                //

                if( workContext->IsNotStuck || interval.LowPart < 45 * 10000000 ) {
                    continue;
                }

                header = workContext->RequestHeader;

                if ( (workContext->BlockHeader.ReferenceCount != 0) &&
                     (workContext->ProcessingCount != 0) &&
                     header != NULL ) {

                    //
                    // Convert to seconds
                    //
                    interval.LowPart /= 10000000;

                    if( !printed ) {
                        IF_STRESS() KdPrint(( "--- Potential stuck SRV.SYS Operations ---\n" ));
                        printed = TRUE;
                    }

                    if( interval.LowPart > SrvMostStuck.Seconds ) {
                        SrvMostStuck.Seconds = interval.LowPart;
                        RtlCopyMemory( SrvMostStuck.ClientName,
                                       connection->OemClientMachineNameString.Buffer,
                                       MIN( 16, connection->OemClientMachineNameString.Length )),
                        SrvMostStuck.ClientName[ MIN( 15, connection->OemClientMachineNameString.Length ) ] = 0;
                        SrvMostStuck.Command = header->Command;
                    }

                    if( stuckCount++ < 5 ) {
                        IF_STRESS() KdPrint(( "Client %s, %u secs, Context %p",
                                   connection->OemClientMachineNameString.Buffer,
                                   interval.LowPart, workContext ));

                        switch( header->Command ) {
                        case SMB_COM_NT_CREATE_ANDX:
                            IF_STRESS() KdPrint(( " NT_CREATE_ANDX\n" ));
                            break;
                        case SMB_COM_OPEN_PRINT_FILE:
                            IF_STRESS() KdPrint(( " OPEN_PRINT_FILE\n" ));
                            break;
                        case SMB_COM_CLOSE_PRINT_FILE:
                            IF_STRESS() KdPrint(( " CLOSE_PRINT_FILE\n" ));
                            break;
                        case SMB_COM_CLOSE:
                            IF_STRESS() KdPrint(( " CLOSE\n" ));
                            break;
                        case SMB_COM_SESSION_SETUP_ANDX:
                            IF_STRESS() KdPrint(( " SESSION_SETUP\n" ));
                            break;
                        case SMB_COM_OPEN_ANDX:
                            IF_STRESS() KdPrint(( " OPEN_ANDX\n" ));
                            break;
                        case SMB_COM_NT_TRANSACT:
                        case SMB_COM_NT_TRANSACT_SECONDARY:
                            IF_STRESS() KdPrint(( " NT_TRANSACT\n" ));
                            break;
                        case SMB_COM_TRANSACTION2:
                        case SMB_COM_TRANSACTION2_SECONDARY:
                            IF_STRESS() KdPrint(( " TRANSACTION2\n" ));
                            break;
                        case SMB_COM_TRANSACTION:
                        case SMB_COM_TRANSACTION_SECONDARY:
                            IF_STRESS() KdPrint(( " TRANSACTION\n" ));
                            break;
                        default:
                            IF_STRESS() KdPrint(( " Cmd %X\n", header->Command ));
                            break;
                        }
                    }
                }
            }

            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    if( printed && SrvMostStuck.Seconds ) {
        IF_STRESS() KdPrint(( "Longest so far: %s, %u secs, cmd %u\n", SrvMostStuck.ClientName, SrvMostStuck.Seconds, SrvMostStuck.Command ));
    }

    if( stuckCount ) {
        //DbgBreakPoint();
    }

    RELEASE_LOCK( &SrvEndpointLock );
}
#endif


VOID
ScavengerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    )

/*++

Routine Description:

    Main routine for the FSP scavenger thread.  Is called via an
    executive work item when scavenger work is needed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN runAgain = TRUE;
    BOOLEAN oldPopupStatus;
    BOOLEAN finalExecution = FALSE;
    KIRQL oldIrql;

    Parameter;  // prevent compiler warnings

    IF_DEBUG(SCAV1) KdPrint(( "ScavengerThread entered\n" ));

    //
    // Make sure that the thread does not generate pop-ups.  We need to do
    // this because the scavenger might be called by an Ex worker thread,
    // which unlike the srv worker threads, don't have popups disabled.
    //

    oldPopupStatus = IoSetThreadHardErrorMode( FALSE );

    //
    // Main loop, executed until no scavenger events are set.
    //

    do {

#if DBG_STUCK
        IF_STRESS() SrvLookForStuckOperations();
#endif

        //
        // If the short-term timer expired, run that algorithm now.
        //

        if ( RunShortTermAlgorithm ) {

            LARGE_INTEGER currentTime;

            RunShortTermAlgorithm = FALSE;

            KeQuerySystemTime( &currentTime );

            //
            // Time out oplock break requests.
            //

            TimeoutStuckOplockBreaks( &currentTime );
        }

        //
        // If the scavenger timer expired, run that algorithm now.
        //

        if ( RunScavengerAlgorithm ) {
            //KePrintSpinLockCounts( 0 );
            RunScavengerAlgorithm = FALSE;
            ScavengerAlgorithm( );
        }

        //
        // If the short-term timer expired, run that algorithm now.
        // Note that we check the short-term timer twice in the loop
        // in order to get more timely processing of the algorithm.
        //

        //if ( RunShortTermAlgorithm ) {
        //    RunShortTermAlgorithm = FALSE;
        //    ShortTermAlgorithm( );
        //}

        //
        // If the alerter timer expired, run that algorithm now.
        //

        if ( RunAlerterAlgorithm ) {
            RunAlerterAlgorithm = FALSE;
            AlerterAlgorithm( );
        }

        //
        // At the end of the loop, check to see whether we need to run
        // the loop again.
        //

        ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

        if ( !RunShortTermAlgorithm &&
             !RunScavengerAlgorithm &&
             !RunAlerterAlgorithm ) {

            //
            // No more work to do.  If the server is shutting down,
            // set the event that tells SrvTerminateScavenger that the
            // scavenger thread is done running.
            //

            ScavengerRunning = FALSE;
            runAgain = FALSE;

            if ( !ScavengerInitialized ) {
                // The server was stopped while the scavenger was queued,
                // so we need to delete the WorkItem ourselves.
                finalExecution = TRUE;
                KeSetEvent( ScavengerThreadTerminationEvent, 0, FALSE );
            }

        }

        RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

    } while ( runAgain );

    //
    // reset popup status.
    //

    IoSetThreadHardErrorMode( oldPopupStatus );

    if( finalExecution )
    {
        IoFreeWorkItem( ScavengerWorkItem );
        ScavengerWorkItem = NULL;
    }

    return;

} // ScavengerThread

VOID
DestroySuspectConnections(
    VOID
    )
{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    BOOLEAN printed = FALSE;
    ULONG stuckCount = 0;

    IF_DEBUG( SCAV1 ) {
        KdPrint(( "Looking for Suspect Connections.\n" ));
    }

    //
    // Look at all of the InProgress work items and chatter about any
    //  which look stuck
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TRUE ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            if( connection->IsConnectionSuspect )
            {
                // Prevent us from flooding the eventlog by only logging X DOS attacks every 24 hours.
                LARGE_INTEGER CurrentTime;
                KeQuerySystemTime( &CurrentTime );
                if( CurrentTime.QuadPart > SrvLastDosAttackTime.QuadPart + SRV_ONE_DAY )
                {
                    // reset the counter every 24 hours
                    SrvDOSAttacks = 0;
                    SrvLastDosAttackTime.QuadPart = CurrentTime.QuadPart;
                    SrvLogEventOnDOS = TRUE;
                }

                IF_DEBUG( ERRORS )
                {
                    KdPrint(( "Disconnected suspected DoS attack (%z)\n", (PCSTRING)&connection->OemClientMachineNameString ));
                }

                RELEASE_LOCK( &SrvEndpointLock );

                // Log an event if we need to
                if( SrvLogEventOnDOS )
                {
                    SrvLogError(
                        SrvDeviceObject,
                        EVENT_SRV_DOS_ATTACK_DETECTED,
                        STATUS_ACCESS_DENIED,
                        NULL,
                        0,
                        &connection->ClientMachineNameString,
                        1
                        );

                    SrvDOSAttacks++;
                    if( SrvDOSAttacks > SRV_MAX_DOS_ATTACK_EVENT_LOGS )
                    {
                        SrvLogEventOnDOS = FALSE;

                        SrvLogError(
                            SrvDeviceObject,
                            EVENT_SRV_TOO_MANY_DOS,
                            STATUS_ACCESS_DENIED,
                            NULL,
                            0,
                            NULL,
                            0
                            );
                    }
                }

                connection->DisconnectReason = DisconnectSuspectedDOSConnection;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

    RunSuspectConnectionAlgorithm = FALSE;
}


VOID
ScavengerAlgorithm (
    VOID
    )
{
    LARGE_INTEGER currentTime;
    ULONG currentTick;
    UNICODE_STRING insertionString[2];
    WCHAR secondsBuffer[20];
    WCHAR shortageBuffer[20];
    BOOLEAN logError = FALSE;
    PWORK_QUEUE queue;

    PAGED_CODE( );

    IF_DEBUG(SCAV1) KdPrint(( "ScavengerAlgorithm entered\n" ));

    KeQuerySystemTime( &currentTime );
    GET_SERVER_TIME( SrvWorkQueues, &currentTick );

    //
    // EventSwitch is used to schedule parts of the scavenger algorithm
    // to run every other iteration.
    //

    EventSwitch = !EventSwitch;

    //
    // Time out opens that are waiting too long for the other
    // opener to break the oplock.
    //

    TimeoutWaitingOpens( &currentTime );

    //
    // Time out oplock break requests.
    //

    TimeoutStuckOplockBreaks( &currentTime );

    //
    // Check for malicious attacks
    //
    if( RunSuspectConnectionAlgorithm )
    {
        DestroySuspectConnections( );
    }

    //
    // See if we can free some work items at this time.
    //

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        LazyFreeQueueDataStructures( queue );
    }

    //
    // See if we need to update QOS information.
    //

    if ( --ScavengerUpdateQosCount < 0 ) {
        UpdateConnectionQos( &currentTime );
        ScavengerUpdateQosCount = SrvScavengerUpdateQosCount;
    }

    //
    // See if we need to walk the rfcb list to update the session
    // last use time.
    //

    if ( --ScavengerCheckRfcbActive < 0 ) {
        UpdateSessionLastUseTime( &currentTime );
        ScavengerCheckRfcbActive = SrvScavengerCheckRfcbActive;
    }

    //
    // See if we need to log an error for resource shortages
    //

    if ( FailedWorkItemAllocations > 0      ||
         SrvOutOfFreeConnectionCount > 0    ||
         SrvOutOfRawWorkItemCount > 0       ||
         SrvFailedBlockingIoCount > 0 ) {

        //
        // Setup the strings for use in logging work item allocation failures.
        //

        insertionString[0].Buffer = shortageBuffer;
        insertionString[0].MaximumLength = sizeof(shortageBuffer);
        insertionString[1].Buffer = secondsBuffer;
        insertionString[1].MaximumLength = sizeof(secondsBuffer);

        (VOID) RtlIntegerToUnicodeString(
                        SrvScavengerTimeoutInSeconds * 2,
                        10,
                        &insertionString[1]
                        );

        logError = TRUE;
    }

    if ( EventSwitch ) {
        ULONG FailedCount;

        //
        // If we were unable to allocate any work items during
        // the last two scavenger intervals, log an error.
        //

        FailedCount = InterlockedExchange( &FailedWorkItemAllocations, 0 );

        if ( FailedCount != 0 ) {

            (VOID) RtlIntegerToUnicodeString(
                                FailedCount,
                                10,
                                &insertionString[0]
                                );

            SrvLogError(
                SrvDeviceObject,
                EVENT_SRV_NO_WORK_ITEM,
                STATUS_INSUFFICIENT_RESOURCES,
                NULL,
                0,
                insertionString,
                2
                );
        }

        //
        // Generate periodic events and alerts (for events that
        // could happen very quickly, so we don't flood the event
        // log).
        //

        GeneratePeriodicEvents( );

    } else {

        if ( logError ) {

            //
            // If we failed to find free connections during
            // the last two scavenger intervals, log an error.
            //

            // The out-of-connection logic is being changed because most DC's see these
            // occassionally (once a day) due to a short spike in CPU or network traffic.  This one
            // time spike is usually not indicative of an underlying problem, but the event log
            // causes much administrator worry.  Thus, we now increment the OutOfFreeConnection count
            // by the number of failed connections each time this algorithm is run.  If we encounter a
            // situation where we failed many times in a row, or if the number of failures was unusually
            // high, we will log an event.

            if ( ((SrvOutOfFreeConnectionCount > 0) &&
                  (OutOfFreeConnectionConsecutiveCount > 25)) ||
                 (SrvOutOfFreeConnectionCount > 100) ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvOutOfFreeConnectionCount+OutOfFreeConnectionConsecutiveCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_FREE_CONNECTIONS,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvOutOfFreeConnectionCount = 0;
                OutOfFreeConnectionConsecutiveCount = 0;
            }
            else if (SrvOutOfFreeConnectionCount > 0) {
                OutOfFreeConnectionConsecutiveCount+= SrvOutOfFreeConnectionCount;
                SrvOutOfFreeConnectionCount = 0;
            } else {
                OutOfFreeConnectionConsecutiveCount = 0;
            }

            //
            // If we failed to find free raw work items during
            // the last two scavenger intervals, log an error.
            //

            if ( SrvOutOfRawWorkItemCount > 0 ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvOutOfRawWorkItemCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_FREE_RAW_WORK_ITEM,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvOutOfRawWorkItemCount = 0;
            }

            //
            // If we failed a blocking io due to resource shortages during
            // the last two scavenger intervals, log an error.
            //

            if ( SrvFailedBlockingIoCount > 0 ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvFailedBlockingIoCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_BLOCKING_IO,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvFailedBlockingIoCount = 0;
            }

        } // if ( logError )
        else
        {
            // Reset the consecutive openconnection failure count, since we
            // only want to detect cases where connections are unavailible for an
            // extended period
            OutOfFreeConnectionConsecutiveCount = 0;
        }

        //
        // Recalculate the core search timeout time.
        //

        RecalcCoreSearchTimeout( );

        //
        // Time out users/connections that have been idle too long
        // (autodisconnect).
        //

        TimeoutSessions( &currentTime );

        //
        // Update the statistics from the the queues
        //

        SrvUpdateStatisticsFromQueues( NULL );

    }

    // Update the DoS variables as necessary for rundown.  This reduces the percentage
    // of work-items we free up whenever we detect a DoS by running out of work items
    if( SrvDoSRundownIncreased && !SrvDoSRundownDetector )
    {
        // We've increased the percentage at some time, but no DoS has been detected since
        // the last execution of the scavenger, so we can reduce our tear down amount
        SRV_DOS_DECREASE_TEARDOWN();
    }
    SrvDoSRundownDetector = FALSE;

    return;

} // ScavengerAlgorithm


VOID
AlerterAlgorithm (
    VOID
    )

/*++

Routine Description:

    The other scavenger thread.  This routine checks the server for
    alert conditions, and if necessary raises alerts.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(SCAV1) KdPrint(( "AlerterAlgorithm entered\n" ));

    CheckErrorCount( &SrvErrorRecord, FALSE );
    CheckErrorCount( &SrvNetworkErrorRecord, TRUE );
    CheckDiskSpace();

    return;

} // AlerterAlgorithm


VOID
CloseIdleConnection (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER DisconnectTime,
    IN PLARGE_INTEGER PastExpirationTime,
    IN PLARGE_INTEGER TwoMinuteWarningTime,
    IN PLARGE_INTEGER FiveMinuteWarningTime
    )

/*++

Routine Description:

    The routine checks to see if some sessions need to be closed becaused
    it has been idle too long or has exceeded its logon hours.

    Endpoint lock assumed held.

Arguments:

    Connection - The connection whose sessions we are currently looking at.
    CurrentTime - The currest system time.
    DisconnectTime - The time beyond which the session will be autodisconnected.
    PastExpirationTime - Time when the past expiration message will be sent.
    TwoMinuteWarningTime - Time when the 2 min warning will be sent.
    FiveMinuteWarningTime - Time when the 5 min warning will be sent.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    NTSTATUS status;
    BOOLEAN sessionClosed = FALSE;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    LONG i;
    ULONG AllSessionsIdle = TRUE;
    ULONG HasSessions = FALSE;

    PAGED_CODE( );

    //
    // Is this is a connectionless connection (IPX), check first to see
    // if it's been too long since we heard from the client.  The client
    // is supposed to send Echo SMBs every few minutes if nothing else
    // is going on.
    //

    if ( Connection->Endpoint->IsConnectionless ) {

        //
        // Calculate the number of clock ticks that have happened since
        // we last heard from the client.  If that's more than we allow,
        // kill the connection.
        //

        GET_SERVER_TIME( Connection->CurrentWorkQueue, (PULONG)&i );
        i -= Connection->LastRequestTime;
        if ( i > 0 && (ULONG)i > SrvIpxAutodisconnectTimeout ) {
            IF_DEBUG( IPX2 ) {
                KdPrint(("CloseIdleConnection: closing IPX conn %p, idle %u\n", Connection, i ));
            }
            Connection->DisconnectReason = DisconnectIdleConnection;
            SrvCloseConnection( Connection, FALSE );
            return;
        }
    }

    //
    // Walk the active connection list, looking for connections that
    // are idle.
    //

    tableHeader = &pagedConnection->SessionTable;

    ACQUIRE_LOCK( &Connection->Lock );

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PSESSION session = (PSESSION)tableHeader->Table[i].Owner;

        if( session == NULL ) {
            continue;
        }

        HasSessions = TRUE;

        if ( GET_BLOCK_STATE( session ) == BlockStateActive ) {

            SrvReferenceSession( session );
            RELEASE_LOCK( &Connection->Lock );

            //
            // Test whether the session has been idle too long, and whether
            // there are any files open on the session.  If there are open
            // files, we must not close the session, as this would seriously
            // confuse the client.  For purposes of autodisconnect, "open
            // files" referes to open searches and blocking comm device
            // requests as well as files actually opened.
            //

            if ( AllSessionsIdle == TRUE &&
                 (session->LastUseTime.QuadPart >= DisconnectTime->QuadPart ||
                  session->CurrentFileOpenCount != 0 ||
                  session->CurrentSearchOpenCount != 0 )
               ) {

                AllSessionsIdle = FALSE;
            }

            // Check if the session has expired
            if( session->LogOffTime.QuadPart < CurrentTime->QuadPart )
            {
                session->IsSessionExpired = TRUE;
                KdPrint(( "Marking session as expired (scavenger)\n" ));
            }

            // Look for forced log-offs
            if ( !SrvEnableForcedLogoff &&
                        !session->LogonSequenceInProgress &&
                        !session->LogoffAlertSent &&
                        PastExpirationTime->QuadPart <
                               session->LastExpirationMessage.QuadPart ) {

                //
                // Checks for forced logoff.  If the client is beyond his logon
                // hours, force him off.  If the end of logon hours is
                // approaching, send a warning message.  Forced logoff occurs
                // regardless of whether the client has open files or searches.
                //

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    //
                    // Only the scavenger thread sets this, so no mutual
                    // exclusion is necessary.
                    //

                    session->LastExpirationMessage = *CurrentTime;

                    SrvUserAlertRaise(
                        MTXT_Past_Expiration_Message,
                        2,
                        &session->Connection->Endpoint->DomainName,
                        &timeString,
                        &Connection->ClientMachineNameString
                        );

                    RtlFreeUnicodeString( &timeString );
                }

                // !!! need to raise an admin alert in this case?

            } else if ( !session->LogoffAlertSent &&
                        !session->LogonSequenceInProgress &&
                        session->KickOffTime.QuadPart < CurrentTime->QuadPart ) {

                session->LogoffAlertSent = TRUE;

                SrvUserAlertRaise(
                    MTXT_Expiration_Message,
                    1,
                    &session->Connection->Endpoint->DomainName,
                    NULL,
                    &Connection->ClientMachineNameString
                    );

                //
                // If real forced logoff is not enabled, all we do is send an
                // alert, don't actually close the session/connection.
                //

                if ( SrvEnableForcedLogoff ) {

                    //
                    // Increment the count of sessions that have been
                    // forced to logoff.
                    //

                    SrvStatistics.SessionsForcedLogOff++;

                    SrvCloseSession( session );
                    sessionClosed = TRUE;
                }

            } else if ( SrvEnableForcedLogoff &&
                        !session->LogonSequenceInProgress &&
                        !session->TwoMinuteWarningSent &&
                        session->KickOffTime.QuadPart <
                                        TwoMinuteWarningTime->QuadPart ) {

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    //
                    // We only send a two-minute warning if "real" forced logoff
                    // is enabled.  If it is not enabled, the client doesn't
                    // actually get kicked off, so the extra messages are not
                    // necessary.
                    //

                    session->TwoMinuteWarningSent = TRUE;

                    //
                    // Send a different alert message based on whether the client
                    // has open files and/or searches.
                    //

                    if ( session->CurrentFileOpenCount != 0 ||
                             session->CurrentSearchOpenCount != 0 ) {

                        SrvUserAlertRaise(
                            MTXT_Immediate_Kickoff_Warning,
                            1,
                            &timeString,
                            NULL,
                            &Connection->ClientMachineNameString
                            );

                    } else {

                        SrvUserAlertRaise(
                            MTXT_Kickoff_Warning,
                            1,
                            &session->Connection->Endpoint->DomainName,
                            NULL,
                            &Connection->ClientMachineNameString
                            );
                    }

                    RtlFreeUnicodeString( &timeString );
                }

            } else if ( !session->FiveMinuteWarningSent &&
                        !session->LogonSequenceInProgress &&
                        session->KickOffTime.QuadPart <
                                        FiveMinuteWarningTime->QuadPart ) {

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    session->FiveMinuteWarningSent = TRUE;

                    SrvUserAlertRaise(
                        MTXT_Expiration_Warning,
                        2,
                        &session->Connection->Endpoint->DomainName,
                        &timeString,
                        &Connection->ClientMachineNameString
                        );

                    RtlFreeUnicodeString( &timeString );
                }
            }

            SrvDereferenceSession( session );
            ACQUIRE_LOCK( &Connection->Lock );

        } // if GET_BLOCK_STATE(session) == BlockStateActive

    } // for

    //
    // Nuke the connection if no sessions are active, and we have not heard
    //  from the client for one minute, drop the connection
    //
    if( HasSessions == FALSE ) {
        RELEASE_LOCK( &Connection->Lock );

        GET_SERVER_TIME( Connection->CurrentWorkQueue, (PULONG)&i );
        i -= Connection->LastRequestTime;

        if ( i > 0 && (ULONG)i > SrvConnectionNoSessionsTimeout ) {
#if SRVDBG29
            UpdateConnectionHistory( "IDLE", Connection->Endpoint, Connection );
#endif

            Connection->DisconnectReason = DisconnectIdleConnection;
            SrvCloseConnection( Connection, FALSE );
        }

    } else if ( (sessionClosed && (Connection->CurrentNumberOfSessions == 0)) ||
         (HasSessions == TRUE && AllSessionsIdle == TRUE) ) {

        //
        // Update the statistics for the 'AllSessionsIdle' case
        //
        SrvStatistics.SessionsTimedOut += Connection->CurrentNumberOfSessions;

        RELEASE_LOCK( &Connection->Lock );
#if SRVDBG29
        UpdateConnectionHistory( "IDLE", Connection->Endpoint, Connection );
#endif
        Connection->DisconnectReason = DisconnectIdleConnection;
        SrvCloseConnection( Connection, FALSE );

    } else {

        //
        // If this connection has more than 20 core searches, we go in and
        // try to remove dups.  20 is an arbitrary number.
        //


        if ( (pagedConnection->CurrentNumberOfCoreSearches > 20) &&
             SrvRemoveDuplicateSearches ) {

            RemoveDuplicateCoreSearches( pagedConnection );
        }

        RELEASE_LOCK( &Connection->Lock );
    }

} // CloseIdleConnection


VOID
CreateConnections (
    VOID
    )

/*++

Routine Description:

    This function attempts to service all endpoints that do not have
    free connections available.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // Walk the endpoint list, looking for endpoints that need
    // connections.  Note that we hold the endpoint lock for the
    // duration of this routine.  This keeps the endpoint list from
    // changing.
    //
    // Note that we add connections based on level of need, so that
    // if we are unable to create as many as we'd like, we at least
    // take care of the most needy endpoints first.
    //

    for ( count = 0 ; count < SrvFreeConnectionMinimum; count++ ) {

        listEntry = SrvEndpointList.ListHead.Flink;

        while ( listEntry != &SrvEndpointList.ListHead ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            //
            // If the endpoint's free connection count is at or below
            // our current level, try to create a connection now.
            //

            if ( (endpoint->FreeConnectionCount <= count) &&
                 (GET_BLOCK_STATE(endpoint) == BlockStateActive) ) {

                //
                // Try to create a connection.  If this fails, leave.
                //

                if ( !NT_SUCCESS(SrvOpenConnection( endpoint )) ) {
                    RELEASE_LOCK( &SrvEndpointLock );
                    return;
                }

            }

            listEntry = listEntry->Flink;

        } // walk endpoint list

    } // 0 <= count < SrvFreeConnectionMinimum

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // CreateConnections


VOID
GeneratePeriodicEvents (
    VOID
    )

/*++

Routine Description:

    This function is called when the scavenger timeout occurs.  It
    generates events for things that have happened in the previous
    period for which we did not want to immediately generate an event,
    for fear of flooding the event log.  An example of such an event is
    being unable to allocate pool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG capturedNonPagedFailureCount;
    ULONG capturedPagedFailureCount;
    ULONG capturedNonPagedLimitHitCount;
    ULONG capturedPagedLimitHitCount;

    ULONG nonPagedFailureCount;
    ULONG pagedFailureCount;
    ULONG nonPagedLimitHitCount;
    ULONG pagedLimitHitCount;

    PAGED_CODE( );

    //
    // Capture pool allocation failure statistics.
    //

    capturedNonPagedLimitHitCount = SrvNonPagedPoolLimitHitCount;
    capturedNonPagedFailureCount = SrvStatistics.NonPagedPoolFailures;
    capturedPagedLimitHitCount = SrvPagedPoolLimitHitCount;
    capturedPagedFailureCount = SrvStatistics.PagedPoolFailures;

    //
    // Compute failure counts for the last period.  The FailureCount
    // fields in the statistics structure count both hitting the
    // server's configuration limit and hitting the system's limit.  The
    // local versions of FailureCount include only system failures.
    //

    nonPagedLimitHitCount =
        capturedNonPagedLimitHitCount - LastNonPagedPoolLimitHitCount;
    nonPagedFailureCount =
        capturedNonPagedFailureCount - LastNonPagedPoolFailureCount -
        nonPagedLimitHitCount;
    pagedLimitHitCount =
        capturedPagedLimitHitCount - LastPagedPoolLimitHitCount;
    pagedFailureCount =
        capturedPagedFailureCount - LastPagedPoolFailureCount -
        pagedLimitHitCount;

    //
    // Saved the current failure counts for next time.
    //

    LastNonPagedPoolLimitHitCount = capturedNonPagedLimitHitCount;
    LastNonPagedPoolFailureCount = capturedNonPagedFailureCount;
    LastPagedPoolLimitHitCount = capturedPagedLimitHitCount;
    LastPagedPoolFailureCount = capturedPagedFailureCount;

    //
    // If we hit the nonpaged pool limit at least once in the last
    // period, generate an event.
    //

    if ( nonPagedLimitHitCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NONPAGED_POOL_LIMIT,
            STATUS_INSUFFICIENT_RESOURCES,
            &nonPagedLimitHitCount,
            sizeof( nonPagedLimitHitCount ),
            NULL,
            0
            );
    }

    //
    // If we had any nonpaged pool allocations failures in the last
    // period, generate an event.
    //

    if ( nonPagedFailureCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_NONPAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &nonPagedFailureCount,
            sizeof( nonPagedFailureCount ),
            NULL,
            0
            );
    }

    //
    // If we hit the paged pool limit at least once in the last period,
    // generate an event.
    //

    if ( pagedLimitHitCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_PAGED_POOL_LIMIT,
            STATUS_INSUFFICIENT_RESOURCES,
            &pagedLimitHitCount,
            sizeof( pagedLimitHitCount ),
            NULL,
            0
            );
    }

    //
    // If we had any paged pool allocations failures in the last period,
    // generate an event.
    //

    if ( pagedFailureCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_PAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &pagedFailureCount,
            sizeof( pagedFailureCount ),
            NULL,
            0
            );
    }

    return;

} // GeneratePeriodicEvents


VOID
ProcessConnectionDisconnects (
    VOID
    )

/*++

Routine Description:

    This function processes connection disconnects.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    KIRQL oldIrql;

    //
    // Run through the list of connection with pending disconnects.
    // Do the work necessary to shut the disconnection connection
    // down.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    while ( !IsListEmpty( &SrvDisconnectQueue ) ) {

        //
        // This thread already owns the disconnect queue spin lock
        // and there is at least one entry on the queue.  Proceed.
        //

        listEntry = RemoveHeadList( &SrvDisconnectQueue );

        connection = CONTAINING_RECORD(
            listEntry,
            CONNECTION,
            ListEntry
            );

        ASSERT( connection->DisconnectPending );
        connection->DisconnectPending = FALSE;

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        IF_STRESS() {
            if( connection->InProgressWorkContextCount > 0 )
            {
                KdPrint(("Abortive Disconnect for %z while work-in-progress (reason %d)\n", (PCSTRING)&connection->OemClientMachineNameString, connection->DisconnectReason ));
            }
        }

        //
        // Do the disconnection processing.  Dereference the connection
        // an extra time to account for the reference made when it was
        // put on the disconnect queue.
        //

#if SRVDBG29
        UpdateConnectionHistory( "PDSC", connection->Endpoint, connection );
#endif
        SrvCloseConnection( connection, TRUE );
        SrvDereferenceConnection( connection );

        //
        // We are about to go through the loop again, reacquire
        // the disconnect queue spin lock first.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
    return;

} // ProcessConnectionDisconnects


VOID SRVFASTCALL
SrvServiceWorkItemShortage (
    IN PWORK_CONTEXT workContext
    )
{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN moreWork;
    PWORK_QUEUE queue;

    ASSERT( workContext );

    queue = workContext->CurrentWorkQueue;

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvServiceWorkItemShortage: Processor %p\n",
                 (PVOID)(queue - SrvWorkQueues) ));
    }

    workContext->FspRestartRoutine = SrvRestartReceive;

    ASSERT( queue >= SrvWorkQueues && queue < eSrvWorkQueues );

    //
    // If we got called, it's likely that we're running short of WorkItems.
    //  Allocate more if it makes sense.
    //

    do {
        PWORK_CONTEXT NewWorkContext;

        SrvAllocateNormalWorkItem( &NewWorkContext, queue );
        if ( NewWorkContext != NULL ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(( "SrvServiceWorkItemShortage:  Created new work context "
                        "block\n" ));
            }

            SrvPrepareReceiveWorkItem( NewWorkContext, TRUE );

        } else {
            InterlockedIncrement( &FailedWorkItemAllocations );
            break;
        }

    } while ( queue->FreeWorkItems < queue->MinFreeWorkItems );

    if( GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextSpecial ) {
        //
        // We've been called with a special workitem telling us to allocate
        // more standby WorkContext structures. Since our passed-in workContext
        // is not a "standard one", we can't use it for any further work
        // on starved connections.  Just release this workContext and return.
        //
        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
        SET_BLOCK_TYPE( workContext, BlockTypeGarbage );
        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
        return;
    }

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    //
    // Run through the list of queued connections and find one that
    // we can service with this workContext.  This will ignore processor
    // affinity, but we're in exceptional times.  The workContext will
    // be freed back to the correct queue when done.
    //

    while( !IsListEmpty( &SrvNeedResourceQueue ) ) {

        connection = CONTAINING_RECORD( SrvNeedResourceQueue.Flink, CONNECTION, ListEntry );

        IF_DEBUG( WORKITEMS ) {
             KdPrint(("SrvServiceWorkItemShortage: Processing connection %p.\n",
                       connection ));
        }

        ASSERT( connection->OnNeedResourceQueue );
        ASSERT( connection->BlockHeader.ReferenceCount > 0 );

        if( GET_BLOCK_STATE( connection ) != BlockStateActive ) {

                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvServiceWorkItemShortage: Connection %p closing.\n", connection ));
                }

                //
                // Take it off the queue
                //
                SrvRemoveEntryList(
                    &SrvNeedResourceQueue,
                    &connection->ListEntry
                );
                connection->OnNeedResourceQueue = FALSE;

                RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

                //
                // Remove the queue reference
                //
                SrvDereferenceConnection( connection );

                ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
                continue;
        }

        //
        // Reference this connection so no one can delete this from under us.
        //
        ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        SrvReferenceConnectionLocked( connection );

        //
        // Service the connection
        //
        do {

            if( IsListEmpty( &connection->OplockWorkList ) && !connection->ReceivePending )
                break;

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("Work to do on connection %p\n", connection ));
            }

            INITIALIZE_WORK_CONTEXT( queue, workContext );

            //
            // Reference connection here.
            //
            workContext->Connection = connection;
            SrvReferenceConnectionLocked( connection );
            workContext->Endpoint = connection->Endpoint;

            //
            // Service this connection.
            //
            SrvFsdServiceNeedResourceQueue( &workContext, &oldIrql );

            moreWork = (BOOLEAN) (    workContext != NULL &&
                                      (!IsListEmpty(&connection->OplockWorkList) ||
                                      connection->ReceivePending) &&
                                      connection->OnNeedResourceQueue);

        } while( moreWork );

        //
        // Is it now off the queue?
        //
        if ( !connection->OnNeedResourceQueue ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage: connection %p removed by another thread.\n", connection ));
            }

            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            //
            // Remove this routine's reference.
            //

            SrvDereferenceConnection( connection );

            if( workContext == NULL ) {
                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvServiceWorkItemShortage:  DONE at %d\n", __LINE__ ));
                }
                return;
            }

            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
            continue;
        }

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // The connection is still on the queue.  Keep it on the queue if there is more
        //  work to be done for it.
        //
        if( !IsListEmpty(&connection->OplockWorkList) || connection->ReceivePending ) {

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            if( workContext ) {
                RETURN_FREE_WORKITEM( workContext );
            }

            //
            // Remove this routine's reference.
            //
            SrvDereferenceConnection( connection );

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage:  More to do for %p.  LATER\n", connection ));
            }

            return;
        }

        //
        // All the work has been done for this connection.  Get it off the resource queue
        //
        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage:  Take %p off resource queue\n", connection ));
        }

        SrvRemoveEntryList(
            &SrvNeedResourceQueue,
            &connection->ListEntry
            );

        connection->OnNeedResourceQueue = FALSE;

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        //
        // Remove queue reference
        //
        SrvDereferenceConnection( connection );

        //
        // Remove this routine's reference.
        //

        SrvDereferenceConnection( connection );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage: Connection %p removed from queue.\n", connection ));
        }

        if( workContext == NULL ) {
            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage: DONE at %d\n", __LINE__ ));
            }
            return;
        }

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // See if we need to free the workContext
    //

    if ( workContext != NULL ) {

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage: Freeing WorkContext block %p\n",
                     workContext ));
        }
        workContext->BlockHeader.ReferenceCount = 0;
        RETURN_FREE_WORKITEM( workContext );
    }

    IF_DEBUG(WORKITEMS) KdPrint(( "SrvServiceWorkItemShortage DONE at %d\n", __LINE__ ));

} // SrvServiceWorkItemShortage

VOID SRVFASTCALL
SrvServiceDoSTearDown (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is called when we perceive a DoS attack against us.  It results
    in us tearing down connections randomly who have WorkItems trapped in the
    transports to help prevent the DoS.

Arguments:

    WorkContext - The special work item used to trigger this routine

Return Value:

    None

--*/

{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    BOOLEAN printed = FALSE;
    LONG TearDownAmount = SRV_DOS_GET_TEARDOWN();

    ASSERT( GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextSpecial );
    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    SRV_DOS_INCREASE_TEARDOWN();
    SrvDoSRundownDetector = TRUE;

    // Tear down some connections.  Look for ones with operations pending in the transport

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( (TearDownAmount > 0) && (listEntry != &SrvEndpointList.ListHead) ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TearDownAmount > 0 ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // To determine if we should tear this connection down, we require that there be work waiting on
            // the transport, since that is the way anonymous users can attack us.  If there is, we use a
            // random method based on the timestamp of the last time this was ran.  We cycle through the connections
            // and use the index to determine if a teardown is issued (for a psuedo-random result)
            //
            if( (GET_BLOCK_STATE(connection) == BlockStateActive) && (connection->OperationsPendingOnTransport > 0) )
            {
                RELEASE_LOCK( &SrvEndpointLock );

                KdPrint(( "Disconnected suspected DoS attacker by WorkItem shortage (%z)\n", (PCSTRING)&connection->OemClientMachineNameString ));
                TearDownAmount -= connection->InProgressWorkContextCount;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        index = (USHORT)-1;

        while ( TearDownAmount > 0 ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // To determine if we should tear this connection down, we require that there be work waiting on
            // the transport, since that is the way anonymous users can attack us.  If there is, we use a
            // random method based on the timestamp of the last time this was ran.  We cycle through the connections
            // and use the index to determine if a teardown is issued (for a psuedo-random result)
            //
            if( (GET_BLOCK_STATE(connection) == BlockStateActive) && (connection->InProgressWorkContextCount > 0) )
            {
                RELEASE_LOCK( &SrvEndpointLock );

                KdPrint(( "Disconnected suspected DoS attack triggered by WorkItem shortage\n" ));
                TearDownAmount -= connection->InProgressWorkContextCount;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );


    // This is the special work item for tearing down connections to free WORK_ITEMS.  We're done, so release it
    SET_BLOCK_TYPE( WorkContext, BlockTypeGarbage );
    SRV_DOS_COMPLETE_TEARDOWN();

    return;
}


VOID
TimeoutSessions (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This routine walks the ordered list of sessions and closes those
    that have been idle too long, sends warning messages to those
    that are about to be forced closed due to logon hours expiring,
    and closes those whose logon hours have expired.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None

--*/

{
    USHORT index;
    LARGE_INTEGER oldestTime;
    LARGE_INTEGER pastExpirationTime;
    LARGE_INTEGER twoMinuteWarningTime;
    LARGE_INTEGER fiveMinuteWarningTime;
    LARGE_INTEGER time;
    LARGE_INTEGER searchCutoffTime;
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvConfigurationLock );

    //
    // If autodisconnect is turned off (the timeout == 0) set the oldest
    // last use time to zero so that we and don't attempt to
    // autodisconnect sessions.
    //

    if ( SrvAutodisconnectTimeout.QuadPart == 0 ) {

        oldestTime.QuadPart = 0;

    } else {

        //
        // Determine the oldest last use time a session can have and not
        // be closed.
        //

        oldestTime.QuadPart = CurrentTime->QuadPart -
                                        SrvAutodisconnectTimeout.QuadPart;
    }

    searchCutoffTime.QuadPart = (*CurrentTime).QuadPart - SrvSearchMaxTimeout.QuadPart;

    RELEASE_LOCK( &SrvConfigurationLock );

    //
    // Set up the warning times.  If a client's kick-off time is sooner
    // than one of these times, an appropriate warning message is sent
    // to the client.
    //

    time.QuadPart = 10*1000*1000*60*2;               // two minutes
    twoMinuteWarningTime.QuadPart = CurrentTime->QuadPart + time.QuadPart;

    time.QuadPart = (ULONG)10*1000*1000*60*5;        // five minutes
    fiveMinuteWarningTime.QuadPart = CurrentTime->QuadPart + time.QuadPart;
    pastExpirationTime.QuadPart = CurrentTime->QuadPart - time.QuadPart;

    //
    // Walk each connection and determine if we should close it.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            CloseIdleConnection(
                            connection,
                            CurrentTime,
                            &oldestTime,
                            &pastExpirationTime,
                            &twoMinuteWarningTime,
                            &fiveMinuteWarningTime
                            );

            //
            // Time out old core search blocks.
            //

            if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {
                (VOID)SrvTimeoutSearches(
                          &searchCutoffTime,
                          connection,
                          FALSE
                          );
            }

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // TimeoutSessions


VOID
TimeoutWaitingOpens (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function times out opens that are waiting for another client
    or local process to release its oplock.  This opener's wait for
    oplock break IRP is cancelled, causing the opener to return the
    failure to the client.

Arguments:

    CurrentTime - pointer to the current system time.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Entries in wait for oplock break list are chronological, i.e. the
    // oldest entries are closest to the head of the list.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    while ( !IsListEmpty( &SrvWaitForOplockBreakList ) ) {

        listEntry = SrvWaitForOplockBreakList.Flink;
        waitForOplockBreak = CONTAINING_RECORD( listEntry,
                                                WAIT_FOR_OPLOCK_BREAK,
                                                ListEntry
                                              );

        if ( waitForOplockBreak->TimeoutTime.QuadPart > CurrentTime->QuadPart ) {

            //
            // No more wait for oplock breaks to timeout
            //

            break;

        }

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "srv!TimeoutWaitingOpens: Failing stuck open, "
                       "cancelling wait IRP %p\n", waitForOplockBreak->Irp ));
            KdPrint(( "Timeout time = %08lx.%08lx, current time = %08lx.%08lx\n",
                       waitForOplockBreak->TimeoutTime.HighPart,
                       waitForOplockBreak->TimeoutTime.LowPart,
                       CurrentTime->HighPart,
                       CurrentTime->LowPart ));

        }

        //
        // Timeout this wait for oplock break
        //

        RemoveHeadList( &SrvWaitForOplockBreakList );

        IoCancelIrp( waitForOplockBreak->Irp );
        waitForOplockBreak->WaitState = WaitStateOplockWaitTimedOut;

        SrvDereferenceWaitForOplockBreak( waitForOplockBreak );
    }

    RELEASE_LOCK( &SrvOplockBreakListLock );

} // TimeoutWaitingOpens


VOID
TimeoutStuckOplockBreaks (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function times out blocked oplock breaks.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;

    PAGED_CODE( );

    //
    // Entries in wait for oplock break list are chronological, i.e. the
    // oldest entries are closest to the head of the list.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    while ( !IsListEmpty( &SrvOplockBreaksInProgressList ) ) {

        listEntry = SrvOplockBreaksInProgressList.Flink;
        rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

        pagedRfcb = rfcb->PagedRfcb;
        if ( pagedRfcb->OplockBreakTimeoutTime.QuadPart > CurrentTime->QuadPart ) {

            //
            // No more wait for oplock break requests to timeout
            //

            break;

        }

        IF_DEBUG( ERRORS ) {
            KdPrint(( "srv!TimeoutStuckOplockBreaks: Failing stuck oplock, "
                       "break request.  Closing %wZ\n",
                       &rfcb->Mfcb->FileName ));
        }

        IF_DEBUG( STUCK_OPLOCK ) {
            KdPrint(( "srv!TimeoutStuckOplockBreaks: Failing stuck oplock, "
                       "break request.  Closing %wZ\n",
                       &rfcb->Mfcb->FileName ));

            KdPrint(( "Rfcb %p\n", rfcb ));

            KdPrint(( "Timeout time = %08lx.%08lx, current time = %08lx.%08lx\n",
                       pagedRfcb->OplockBreakTimeoutTime.HighPart,
                       pagedRfcb->OplockBreakTimeoutTime.LowPart,
                       CurrentTime->HighPart,
                       CurrentTime->LowPart ));

            DbgBreakPoint();
        }

        //
        // We have been waiting too long for an oplock break response.
        // Unilaterally acknowledge the oplock break, on the assumption
        // that the client is dead.
        //

        rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
        rfcb->OnOplockBreaksInProgressList = FALSE;

        //
        // Remove the RFCB from the Oplock breaks in progress list, and
        // release the RFCB reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &rfcb->ListEntry );
#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );

        SrvAcknowledgeOplockBreak( rfcb, 0 );

        ExInterlockedAddUlong(
            &rfcb->Connection->OplockBreaksInProgress,
            (ULONG)-1,
            rfcb->Connection->EndpointSpinLock
            );

        SrvDereferenceRfcb( rfcb );

        ACQUIRE_LOCK( &SrvOplockBreakListLock );
    }

    RELEASE_LOCK( &SrvOplockBreakListLock );

} // TimeoutStuckOplockBreaks


VOID
UpdateConnectionQos (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function updates the qos information for each connection.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION connection;

    PAGED_CODE( );

    //
    // Go through each connection of each endpoint and update the qos
    // information.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, or is a connectionless (IPX)
        // endpoint, skip to the next one.  Otherwise, reference the
        // endpoint so that it can't go away.
        //

        if ( (GET_BLOCK_STATE(endpoint) != BlockStateActive) ||
             endpoint->IsConnectionless ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            SrvUpdateVcQualityOfService( connection, CurrentTime );

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        }

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    }

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // UpdateConnectionQos

VOID
LazyFreeQueueDataStructures (
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function frees work context blocks and other per-queue data
    structures that are held on linked lists when otherwise free.  It
    only frees a few at a time, to allow a slow ramp-down.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY listEntry;
    KIRQL oldIrql;
    ULONG i,j;
    PWORK_CONTEXT workContext;

    //
    // Clean out the queue->FreeContext
    //
    workContext = NULL;
    workContext = (PWORK_CONTEXT)InterlockedExchangePointer( &queue->FreeContext, workContext );

    if( workContext != NULL ) {
        ExInterlockedPushEntrySList( workContext->FreeList,
                                     &workContext->SingleListEntry,
                                     &queue->SpinLock
                                   );
        InterlockedIncrement( &queue->FreeWorkItems );
    }

    //
    // Free up to 1/32 of the normal work items, if appropriate
    //
    i = MAX(1, queue->FreeWorkItems >> 5);
    for( j=0; j<i; j++ )
    {
        if( queue->FreeWorkItems > queue->MinFreeWorkItems ) {


            listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList,
                                                    &queue->SpinLock );

            if( listEntry != NULL ) {
                PWORK_CONTEXT innerWorkContext;

                InterlockedDecrement( &queue->FreeWorkItems );

                innerWorkContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );

                SrvFreeNormalWorkItem( innerWorkContext );
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    //
    // Free 1 raw mode work item, if appropriate
    //

    if( (ULONG)queue->AllocatedRawModeWorkItems > SrvMaxRawModeWorkItemCount / SrvNumberOfProcessors ) {

        PWORK_CONTEXT innerWorkContext;

        listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );

        if( listEntry != NULL ) {
            InterlockedDecrement( &queue->FreeRawModeWorkItems );
            ASSERT( queue->FreeRawModeWorkItems >= 0 );
            innerWorkContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
            SrvFreeRawModeWorkItem( innerWorkContext );
        }

    }

    //
    // Free 1 rfcb off the list
    //
    {
        PRFCB rfcb = NULL;

        rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb, rfcb );

        if( rfcb != NULL ) {
            ExInterlockedPushEntrySList( &queue->RfcbFreeList,
                                         &rfcb->SingleListEntry,
                                         &queue->SpinLock
                                       );
            InterlockedIncrement( &queue->FreeRfcbs );
        }

        listEntry = ExInterlockedPopEntrySList( &queue->RfcbFreeList,
                                                &queue->SpinLock );

        if( listEntry ) {
            InterlockedDecrement( &queue->FreeRfcbs );
            rfcb = CONTAINING_RECORD( listEntry, RFCB, SingleListEntry );
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Frees );
            FREE_HEAP( rfcb->PagedRfcb );
            DEALLOCATE_NONPAGED_POOL( rfcb );
        }
    }

    //
    // Free 1 Mfcb off the list
    //
    {

        PNONPAGED_MFCB nonpagedMfcb = NULL;

        nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(&queue->CachedFreeMfcb,
                                                                  nonpagedMfcb);

        if( nonpagedMfcb != NULL ) {
            ExInterlockedPushEntrySList( &queue->MfcbFreeList,
                                         &nonpagedMfcb->SingleListEntry,
                                         &queue->SpinLock
                                       );
            InterlockedIncrement( &queue->FreeMfcbs );
        }

        listEntry = ExInterlockedPopEntrySList( &queue->MfcbFreeList,
                                                &queue->SpinLock );
        if( listEntry ) {
            InterlockedDecrement( &queue->FreeMfcbs );
            nonpagedMfcb = CONTAINING_RECORD( listEntry, NONPAGED_MFCB, SingleListEntry );
            DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
        }
    }

    //
    // Free memory in the per-queue pool free lists
    //
    {
        //
        // Free the paged pool chunks
        //
        SrvClearLookAsideList( &queue->PagedPoolLookAsideList, SrvFreePagedPool );

        //
        // Free the non paged pool chunks
        //
        SrvClearLookAsideList( &queue->NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
    }

} // LazyFreeQueueDataStructures

VOID
SrvUserAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING ComputerName
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSTD_ALERT alert;
    PUSER_OTHER_INFO user;
    LARGE_INTEGER currentTime;
    ULONG mailslotLength;
    ULONG string1Length = 0;
    ULONG string2Length = 0;
    PCHAR variableInfo;
    UNICODE_STRING computerName;
    HANDLE alerterHandle;

    PAGED_CODE( );

    ASSERT( (NumberOfStrings == 2 && String1 != NULL && String2 != NULL) ||
            (NumberOfStrings == 1 && String1 != NULL) ||
            (NumberOfStrings == 0) );

    //
    // Open a handle to the alerter service's mailslot.
    //

    status = OpenAlerter( &alerterHandle );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Get rid of the leading backslashes from the computer name.
    //

    computerName.Buffer = ComputerName->Buffer + 2;
    computerName.Length = (USHORT)(ComputerName->Length - 2*sizeof(WCHAR));
    computerName.MaximumLength =
        (USHORT)(ComputerName->MaximumLength - 2*sizeof(WCHAR));

    //
    // Allocate a buffer to hold the mailslot we're going to send to the
    // alerter.
    //

    if ( String1 != NULL ) {
        string1Length = String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        string2Length = String2->Length + sizeof(WCHAR);
    }

    mailslotLength = sizeof(STD_ALERT) + sizeof(USER_OTHER_INFO) +
                         string1Length + string2Length +
                         sizeof(WCHAR) +
                         ComputerName->Length + sizeof(WCHAR);

    alert = ALLOCATE_HEAP_COLD( mailslotLength, BlockTypeDataBuffer );
    if ( alert == NULL ) {
        SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 20, 0 );
        SrvNtClose( alerterHandle, FALSE );
        return;
    }

    //
    // Set up the standard alert structure.
    //

    KeQuerySystemTime( &currentTime );
    RtlTimeToSecondsSince1970( &currentTime, &alert->alrt_timestamp );

    STRNCPY( alert->alrt_eventname, StrUserAlertEventName, EVLEN+1 );
    STRNCPY( alert->alrt_servicename, SrvAlertServiceName, SNLEN+1 );
    alert->alrt_eventname[EVLEN] = L'\0';
    alert->alrt_servicename[SNLEN] = L'\0';

    //
    // Set up the user info in the alert.
    //

    user = (PUSER_OTHER_INFO)ALERT_OTHER_INFO(alert);

    user->alrtus_errcode = Message;

    user->alrtus_numstrings = NumberOfStrings;

    //
    // Set up the variable portion of the message.
    //

    variableInfo = ALERT_VAR_DATA(user);

    if ( String1 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String1->Buffer,
            String1->Length
            );
        *(PWCH)(variableInfo + String1->Length) = UNICODE_NULL;
        variableInfo += String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String2->Buffer,
            String2->Length
            );
        *(PWCH)(variableInfo + String2->Length) = UNICODE_NULL;
        variableInfo += String2->Length + sizeof(WCHAR);
    }

    *(PWCH)variableInfo = UNICODE_NULL;
    variableInfo += sizeof(WCHAR);

    RtlCopyMemory(
        variableInfo,
        ComputerName->Buffer,
        ComputerName->Length
        );
    *(PWCH)(variableInfo + ComputerName->Length) = UNICODE_NULL;
    variableInfo += ComputerName->Length + sizeof(WCHAR);

    status = NtWriteFile(
                 alerterHandle,
                 NULL,                       // Event
                 NULL,                       // ApcRoutine
                 NULL,                       // ApcContext
                 &ioStatusBlock,
                 alert,
                 mailslotLength,
                 NULL,                       // ByteOffset
                 NULL                        // Key
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvUserAlertRaise: NtWriteFile failed: %X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );

    }

    FREE_HEAP( alert );
    SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 21, 0 );
    SrvNtClose( alerterHandle, FALSE );

    return;

} // SrvUserAlertRaise


VOID
SrvAdminAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING String3 OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSTD_ALERT alert;
    PADMIN_OTHER_INFO admin;
    LARGE_INTEGER currentTime;
    ULONG mailslotLength;
    ULONG string1Length = 0;
    ULONG string2Length = 0;
    ULONG string3Length = 0;
    PCHAR variableInfo;
    HANDLE alerterHandle;

    PAGED_CODE( );

    ASSERT( (NumberOfStrings == 3 && String1 != NULL && String2 != NULL && String3 != NULL ) ||
            (NumberOfStrings == 2 && String1 != NULL && String2 != NULL && String3 == NULL ) ||
            (NumberOfStrings == 1 && String1 != NULL && String2 == NULL && String3 == NULL ) ||
            (NumberOfStrings == 0 && String1 == NULL && String2 == NULL && String3 == NULL ) );

    //
    // Open a handle to the alerter service's mailslot.
    //

    status = OpenAlerter( &alerterHandle );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Allocate a buffer to hold the mailslot we're going to send to the
    // alerter.
    //

    if ( String1 != NULL ) {
        string1Length = String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        string2Length = String2->Length + sizeof(WCHAR);
    }

    if ( String3 != NULL ) {
        string3Length = String3->Length + sizeof(WCHAR);
    }

    mailslotLength = sizeof(STD_ALERT) + sizeof(ADMIN_OTHER_INFO) +
                         string1Length + string2Length + string3Length;

    alert = ALLOCATE_HEAP_COLD( mailslotLength, BlockTypeDataBuffer );
    if ( alert == NULL ) {
        SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 22, 0 );
        SrvNtClose( alerterHandle, FALSE );
        return;
    }

    //
    // Set up the standard alert structure.
    //

    KeQuerySystemTime( &currentTime );
    RtlTimeToSecondsSince1970( &currentTime, &alert->alrt_timestamp );

    STRCPY( alert->alrt_eventname, StrAdminAlertEventName );
    STRCPY( alert->alrt_servicename, SrvAlertServiceName );

    //
    // Set up the user info in the alert.
    //

    admin = (PADMIN_OTHER_INFO)ALERT_OTHER_INFO(alert);

    admin->alrtad_errcode = Message;
    admin->alrtad_numstrings = NumberOfStrings;

    //
    // Set up the variable portion of the message.
    //

    variableInfo = ALERT_VAR_DATA(admin);

    if ( String1 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String1->Buffer,
            String1->Length
            );
        *(PWCH)(variableInfo + String1->Length) = UNICODE_NULL;
        variableInfo += string1Length;
    }

    if ( String2 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String2->Buffer,
            String2->Length
            );
        *(PWCH)(variableInfo + String2->Length) = UNICODE_NULL;
        variableInfo += string2Length;
    }

    if ( String3 != NULL ){
        RtlCopyMemory(
            variableInfo,
            String3->Buffer,
            String3->Length
            );
        *(PWCH)(variableInfo + String3->Length) = UNICODE_NULL;
    }

    status = NtWriteFile(
                 alerterHandle,
                 NULL,                       // Event
                 NULL,                       // ApcRoutine
                 NULL,                       // ApcContext
                 &ioStatusBlock,
                 alert,
                 mailslotLength,
                 NULL,                       // ByteOffset
                 NULL                        // Key
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvAdminAlertRaise: NtWriteFile failed: %X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );
    }

    FREE_HEAP( alert );
    SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 23, 0 );
    SrvNtClose( alerterHandle, FALSE );

    return;

} // SrvAdminAlertRaise


NTSTATUS
TimeToTimeString (
    IN PLARGE_INTEGER Time,
    OUT PUNICODE_STRING TimeString
    )
{
    TIME_FIELDS timeFields;
    UCHAR buffer[6];
    ANSI_STRING ansiTimeString;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    // !!! need a better, internationalizable way to do this.

    //
    // Convert Time To Local Time
    //

    ExSystemTimeToLocalTime(
                        Time,
                        &localTime
                        );


    RtlTimeToTimeFields( &localTime, &timeFields );

    buffer[0] = (UCHAR)( (timeFields.Hour / 10) + '0' );
    buffer[1] = (UCHAR)( (timeFields.Hour % 10) + '0' );
    buffer[2] = ':';
    buffer[3] = (UCHAR)( (timeFields.Minute / 10) + '0' );
    buffer[4] = (UCHAR)( (timeFields.Minute % 10) + '0' );
    buffer[5] = '\0';

    RtlInitString( &ansiTimeString, buffer );

    return RtlAnsiStringToUnicodeString( TimeString, &ansiTimeString, TRUE );

} // TimeToTimeString


VOID
CheckErrorCount (
    PSRV_ERROR_RECORD ErrorRecord,
    BOOLEAN UseRatio
    )
/*++

Routine Description:

    This routine checks the record of server operations and adds up the
    count of successes to failures.

Arguments:

    ErrorRecord - Points to an SRV_ERROR_RECORD structure

    UseRatio - If TRUE, look at count of errors,
               If FALSE, look at ratio of error to total.

Return Value:

    None.

--*/
{
    ULONG totalOperations;
    ULONG failedOperations;

    UNICODE_STRING string1, string2;
    WCHAR buffer1[20], buffer2[20];
    NTSTATUS status;

    PAGED_CODE( );

    failedOperations = ErrorRecord->FailedOperations;
    totalOperations = failedOperations + ErrorRecord->SuccessfulOperations;

    //
    // Zero out the counters
    //

    ErrorRecord->SuccessfulOperations = 0;
    ErrorRecord->FailedOperations = 0;

    if ( (UseRatio &&
          ( totalOperations != 0 &&
           ((failedOperations * 100 / totalOperations) >
                         ErrorRecord->ErrorThreshold)))
               ||

         (!UseRatio &&
           failedOperations > ErrorRecord->ErrorThreshold) ) {

        //
        // Raise an alert
        //

        string1.Buffer = buffer1;
        string1.Length = string1.MaximumLength = sizeof(buffer1);

        string2.Buffer = buffer2;
        string2.Length = string2.MaximumLength = sizeof(buffer2);

        status = RtlIntegerToUnicodeString( failedOperations, 10, &string1 );
        ASSERT( NT_SUCCESS( status ) );

        status = RtlIntegerToUnicodeString( SrvAlertMinutes, 10, &string2 );
        ASSERT( NT_SUCCESS( status ) );

        if ( ErrorRecord->AlertNumber == ALERT_NetIO) {

            //
            // We need a third string for the network name.
            //
            // This allocation is unfortunate.  We need to maintain
            // per xport error count so we can print out the actual
            // xport name.
            //

            UNICODE_STRING string3;
            RtlInitUnicodeString(
                            &string3,
                            StrNoNameTransport
                            );


            //
            // We need a third string for the network name
            //

            SrvAdminAlertRaise(
                ErrorRecord->AlertNumber,
                3,
                &string1,
                &string2,
                &string3
                );

        } else {

            SrvAdminAlertRaise(
                ErrorRecord->AlertNumber,
                2,
                &string1,
                &string2,
                NULL
                );
        }

    }

    return;

} // CheckErrorCount


VOID
CheckDiskSpace (
    VOID
    )
/*++

Routine Description:

    This routine check disk space on local drives.  If a drive
    is low on space, an alert is raised.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG diskMask;
    UNICODE_STRING insert1, insert2;
    WCHAR buffer2[20];
    UNICODE_STRING pathName;
    WCHAR dosPathPrefix[] = L"\\DosDevices\\A:\\";
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    FILE_FS_SIZE_INFORMATION sizeInformation;
    FILE_FS_DEVICE_INFORMATION deviceInformation;
    HANDLE handle;
    ULONG percentFree;
    PWCH currentDrive;
    DWORD diskconfiguration;

    PAGED_CODE( );

    if( SrvFreeDiskSpaceThreshold == 0 ) {
        return;
    }

    diskMask = 0x80000000;  // Start at A:

    pathName.Buffer = dosPathPrefix;
    pathName.MaximumLength = 32;
    pathName.Length = 28;           // skip last backslash!

    currentDrive = &dosPathPrefix[12];
    insert1.Buffer = &dosPathPrefix[12];
    insert1.Length = 4;

    //
    // SrvDiskConfiguration is a bitmask of drives that are
    // administratively shared.  It is updated by NetShareAdd and
    // NetShareDel.
    //
    diskconfiguration = SrvDiskConfiguration;

    for ( ; diskMask >= 0x40; diskMask >>= 1, dosPathPrefix[12]++ ) {

        if ( !(diskconfiguration & diskMask) ) {
            continue;
        }

        //
        // Check disk space on this disk
        //

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &pathName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtOpenFile(
                    &handle,
                    FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_NON_DIRECTORY_FILE
                    );
        if ( !NT_SUCCESS( status) ) {
            continue;
        }
        SRVDBG_CLAIM_HANDLE( handle, "DSK", 16, 0 );

        status = NtQueryVolumeInformationFile(
                     handle,
                     &iosb,
                     &deviceInformation,
                     sizeof( FILE_FS_DEVICE_INFORMATION ),
                     FileFsDeviceInformation
                     );
        if ( NT_SUCCESS(status) ) {
            status = iosb.Status;
        }
        SRVDBG_RELEASE_HANDLE( handle, "DSK", 24, 0 );
        if ( !NT_SUCCESS( status ) ||
             (deviceInformation.Characteristics &
                (FILE_FLOPPY_DISKETTE | FILE_READ_ONLY_DEVICE | FILE_WRITE_ONCE_MEDIA)) ||
             !(deviceInformation.Characteristics &
                FILE_DEVICE_IS_MOUNTED) ) {
            SrvNtClose( handle, FALSE );
            continue;
        }

        // Validate its write-able
        if( deviceInformation.Characteristics & FILE_REMOVABLE_MEDIA )
        {
            PIRP Irp;
            PIO_STACK_LOCATION IrpSp;
            KEVENT CompletionEvent;
            PDEVICE_OBJECT DeviceObject;

            // Create the IRP
            KeInitializeEvent( &CompletionEvent, SynchronizationEvent, FALSE );
            Irp = BuildCoreOfSyncIoRequest(
                                handle,
                                NULL,
                                &CompletionEvent,
                                &iosb,
                                &DeviceObject );
            if( !Irp )
            {
                // If we are out of memory, don't log an entry
                goto skip_volume;
            }

            // Initialize the other IRP fields
            IrpSp = IoGetNextIrpStackLocation( Irp );
            IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            IrpSp->MinorFunction = 0;
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
            IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_IS_WRITABLE;
            IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            // Issue the IO
            status = StartIoAndWait( Irp, DeviceObject, &CompletionEvent, &iosb );

            if( !NT_SUCCESS(status) )
            {
skip_volume:
                SrvNtClose( handle, FALSE );
                continue;
            }
        }

        SrvNtClose( handle, FALSE );

        pathName.Length += 2;   // include last backslash
        status = NtOpenFile(
                    &handle,
                    FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );
        pathName.Length -= 2;   // skip last backslash
        if ( !NT_SUCCESS( status) ) {
            continue;
        }
        SRVDBG_CLAIM_HANDLE( handle, "DSK", 17, 0 );

        status = NtQueryVolumeInformationFile(
                     handle,
                     &iosb,
                     &sizeInformation,
                     sizeof( FILE_FS_SIZE_INFORMATION ),
                     FileFsSizeInformation
                     );
        if ( NT_SUCCESS(status) ) {
            status = iosb.Status;
        }
        SRVDBG_RELEASE_HANDLE( handle, "DSK", 25, 0 );
        SrvNtClose( handle, FALSE );
        if ( !NT_SUCCESS( status) ) {
            continue;
        }

        //
        // Calculate % space available = AvailableSpace * 100 / TotalSpace
        //

        if( sizeInformation.TotalAllocationUnits.QuadPart > 0 )
        {
            LARGE_INTEGER mbFree;
            LARGE_INTEGER mbTotal;


            percentFree = (ULONG)(sizeInformation.AvailableAllocationUnits.QuadPart
                        * 100 / sizeInformation.TotalAllocationUnits.QuadPart);

            mbFree.QuadPart = (ULONG)
                                (sizeInformation.AvailableAllocationUnits.QuadPart*
                                 sizeInformation.SectorsPerAllocationUnit*
                                 sizeInformation.BytesPerSector/
                                    (1024*1024));

            ASSERT( percentFree <= 100 );

            //
            // If space is low raise, and we have already raised an alert,
            // then raise the alert.
            //
            // If space is not low, then clear the alert flag so the we will
            // raise an alert if diskspace falls again.
            //

            if ( percentFree < SrvFreeDiskSpaceThreshold ) {
               // If a ceiling is specified, make sure we have exceeded it
               if( SrvFreeDiskSpaceCeiling &&
                   ((mbFree.LowPart > SrvFreeDiskSpaceCeiling) ||
                    (mbFree.HighPart != 0))
                 )
               {
                    goto abort_error;
               }

               if ( !SrvDiskAlertRaised[ *currentDrive - L'A' ] ) {

                    ULONGLONG FreeSpace;

                    SrvLogError(
                        SrvDeviceObject,
                        EVENT_SRV_DISK_FULL,
                        status,
                        NULL,
                        0,
                        &insert1,
                        1
                        );

                    //
                    //  Raise alert
                    //

                    insert2.Buffer = buffer2;
                    insert2.Length = insert2.MaximumLength = sizeof(buffer2);

                    FreeSpace = (ULONGLONG)(sizeInformation.AvailableAllocationUnits.QuadPart
                                          * sizeInformation.SectorsPerAllocationUnit
                                          * sizeInformation.BytesPerSector);


                    status = RtlInt64ToUnicodeString(
                                FreeSpace,
                                10,
                                &insert2
                                );

                    ASSERT( NT_SUCCESS( status ) );

                    SrvAdminAlertRaise(
                        ALERT_Disk_Full,
                        2,
                        &insert1,
                        &insert2,
                        NULL
                        );

                    SrvDiskAlertRaised[ *currentDrive - L'A' ] = TRUE;
                }

            } else { // if ( percentFree < SrvFreeDiskSpaceThreshold )

abort_error:
                SrvDiskAlertRaised[ *currentDrive - L'A' ] = FALSE;

            }
        }
    } // for ( ; diskMask >= 0x40; ... )

    return;

} // CheckDiskSpace


NTSTATUS
OpenAlerter (
    OUT PHANDLE AlerterHandle
    )

/*++

Routine Description:

    This routine opens the alerter server's mailslot.

Arguments:

    AlerterHandle - returns a handle to the mailslot.

Return Value:

    NTSTATUS - Indicates whether the mailslot was opened.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING alerterName;
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE( );

    //
    // Open a handle to the alerter service's mailslot.
    //
    // !!! use a #define for the name!
    //

    RtlInitUnicodeString( &alerterName, StrAlerterMailslot );

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &alerterName,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                AlerterHandle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &iosb,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,  // Create Options
                NULL,                          // EA Buffer
                0,                             // EA Length
                CreateFileTypeNone,            // File type
                NULL,                          // ExtraCreateParameters
                0                              // Options
                );

    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "OpenAlerter: failed to open alerter mailslot: %X, "
                   "an alert was lost.\n", status ));
    } else {
        SRVDBG_CLAIM_HANDLE( AlerterHandle, "ALR", 18, 0 );
    }

    return status;

} // OpenAlerter

VOID
RecalcCoreSearchTimeout(
    VOID
    )
{
    ULONG factor;
    ULONG newTimeout;

    PAGED_CODE( );

    //
    // we reduce the timeout time by 2**factor
    //

    factor = SrvStatistics.CurrentNumberOfOpenSearches >> 9;

    //
    // Minimum is 30 secs.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );
    newTimeout = MAX(30, SrvCoreSearchTimeout >> factor);
    SrvSearchMaxTimeout = SecondsToTime( newTimeout, FALSE );
    RELEASE_LOCK( &SrvConfigurationLock );

    return;

} // RecalcCoreSearchTimeout

VOID
SrvCaptureScavengerTimeout (
    IN PLARGE_INTEGER ScavengerTimeout,
    IN PLARGE_INTEGER AlerterTimeout
    )
{
    KIRQL oldIrql;

    ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

    SrvScavengerTimeout = *ScavengerTimeout;
    SrvAlertSchedule = *AlerterTimeout;

    RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

    return;

} // SrvCaptureScavengerTimeout


#if SRVDBG_PERF
extern ULONG Trapped512s;
#endif

VOID
SrvUpdateStatisticsFromQueues (
    OUT PSRV_STATISTICS CapturedSrvStatistics OPTIONAL
    )
{
    KIRQL oldIrql;
    PWORK_QUEUE queue;

    ACQUIRE_GLOBAL_SPIN_LOCK( Statistics, &oldIrql );

    SrvStatistics.TotalBytesSent.QuadPart = 0;
    SrvStatistics.TotalBytesReceived.QuadPart = 0;
    SrvStatistics.TotalWorkContextBlocksQueued.Time.QuadPart = 0;
    SrvStatistics.TotalWorkContextBlocksQueued.Count = 0;

    //
    // Get the nonblocking statistics
    //

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        SrvStatistics.TotalBytesSent.QuadPart += queue->stats.BytesSent;
        SrvStatistics.TotalBytesReceived.QuadPart += queue->stats.BytesReceived;

        SrvStatistics.TotalWorkContextBlocksQueued.Count +=
            queue->stats.WorkItemsQueued.Count * STATISTICS_SMB_INTERVAL;

        SrvStatistics.TotalWorkContextBlocksQueued.Time.QuadPart +=
            queue->stats.WorkItemsQueued.Time.QuadPart;
    }

#if SRVDBG_PERF
    SrvStatistics.TotalWorkContextBlocksQueued.Count += Trapped512s;
    Trapped512s = 0;
#endif

    if ( ARGUMENT_PRESENT(CapturedSrvStatistics) ) {
        *CapturedSrvStatistics = SrvStatistics;
    }

    RELEASE_GLOBAL_SPIN_LOCK( Statistics, oldIrql );

    ACQUIRE_SPIN_LOCK( (PKSPIN_LOCK)IoStatisticsLock, &oldIrql );

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        **(PULONG *)&IoReadOperationCount += (ULONG)(queue->stats.ReadOperations - queue->saved.ReadOperations );
        queue->saved.ReadOperations = queue->stats.ReadOperations;

        **(PLONGLONG *)&IoReadTransferCount += (queue->stats.BytesRead - queue->saved.BytesRead );
        queue->saved.BytesRead = queue->stats.BytesRead;

        **(PULONG *)&IoWriteOperationCount += (ULONG)(queue->stats.WriteOperations - queue->saved.WriteOperations );
        queue->saved.WriteOperations = queue->stats.WriteOperations;

        **(PLONGLONG *)&IoWriteTransferCount += (queue->stats.BytesWritten - queue->saved.BytesWritten );
        queue->saved.BytesWritten = queue->stats.BytesWritten;
    }

    RELEASE_SPIN_LOCK( (PKSPIN_LOCK)IoStatisticsLock, oldIrql );

    return;

} // SrvUpdateStatisticsFromQueues

VOID
ProcessOrphanedBlocks (
    VOID
    )

/*++

Routine Description:

    Orphaned connections are connections with ref counts of 1 but
    with no workitem, etc associated with it.  They need to be cleaned
    up by a dereference.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSLIST_ENTRY listEntry;
    PQUEUEABLE_BLOCK_HEADER block;

    PAGED_CODE( );

    //
    // Run through the list of connection with pending disconnects.
    // Do the work necessary to shut the disconnection connection
    // down.
    //

    while ( TRUE ) {

        listEntry = ExInterlockedPopEntrySList(
                                &SrvBlockOrphanage,
                                &GLOBAL_SPIN_LOCK(Fsd)
                                );

        if( listEntry == NULL ) {
            break;
        }

        InterlockedDecrement( &SrvResourceOrphanedBlocks );

        block = CONTAINING_RECORD(
                            listEntry,
                            QUEUEABLE_BLOCK_HEADER,
                            SingleListEntry
                            );

        if ( GET_BLOCK_TYPE(block) == BlockTypeConnection ) {

            SrvDereferenceConnection( (PCONNECTION)block );

        } else if ( GET_BLOCK_TYPE(block) == BlockTypeRfcb ) {

            SrvDereferenceRfcb( (PRFCB)block );

        } else {
            ASSERT(0);
        }
    }

    return;

} // ProcessOrphanedBlocks

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This routine walks the rfcb list and if it is found to be marked active,
    the session LastUseTime is updated with the current time.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    ULONG listEntryOffset = SrvRfcbList.ListEntryOffset;
    PLIST_ENTRY listEntry;
    PRFCB rfcb;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the SrvRfcbList
    //

    ACQUIRE_LOCK( SrvRfcbList.Lock );

    //
    // Walk the list of blocks until we find one with a resume handle
    // greater than or equal to the specified resume handle.
    //

    for (
        listEntry = SrvRfcbList.ListHead.Flink;
        listEntry != &SrvRfcbList.ListHead;
        listEntry = listEntry->Flink ) {

        //
        // Get a pointer to the actual block.
        //

        rfcb = (PRFCB)((PCHAR)listEntry - listEntryOffset);

        //
        // Check the state of the block and if it is active,
        // reference it.  This must be done as an atomic operation
        // order to prevent the block from being deleted.
        //

        if ( rfcb->IsActive ) {

            rfcb->Lfcb->Session->LastUseTime = *CurrentTime;
            rfcb->IsActive = FALSE;
        }

    } // walk list

    RELEASE_LOCK( SrvRfcbList.Lock );
    return;

} // UpdateSessionLastUseTime
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbclose.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbclose.c

Abstract:

    This module contains routines for processing the following SMBs:

        Close

Author:

    David Treadwell (davidtr) 16-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "smbclose.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbClose )
#endif

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClose (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Close SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_CLOSE request;
    PRESP_CLOSE response;
    NTSTATUS status = STATUS_SUCCESS;

    PSESSION   session;
    PRFCB      rfcb;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CLOSE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Close file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Close file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_CLOSE)(WorkContext->RequestParameters);
    response = (PRESP_CLOSE)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbClose: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // First, verify the FID.  If verified, the RFCB and the TreeConnect
    // block are referenced and their addresses are stored in the
    // WorkContext block, and the RFCB address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there
    // is a saved write behind error for this rfcb.  The rfcb is
    // needed in order to process the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                FALSE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbClose: Invalid FID: 0x%lx\n",
                            SmbGetUshort( &request->Fid ) ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;

    } else if( rfcb->ShareType == ShareTypePrint &&
        WorkContext->UsingLpcThread == 0 ) {

        //
        // Closing this file will result in the scheduling of a print
        //  job.  This means we will have to talk with srvsvc, a lengthy
        //  operation.  Shift this close over to a LPC thread.
        //
        // NOTE: We don't allow the LPC throttle to reject this request
        // because that would result in a failure to schedule a job.
        //
        SrvQueueWorkToLpcThread( WorkContext, FALSE );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;

    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        //
        // Check the saved error.
        //

        (VOID) SrvCheckForSavedError( WorkContext, rfcb );

    }

    //
    // Set the last write time on the file from the time specified in
    // the SMB.  Even though the SMB spec says that this is optional,
    // we must support it for the following reasons:
    //
    //     1) The only way to set a file time in DOS is through a
    //        handle-based API which the DOS redir never sees; the API
    //        just sets the time in DOS's FCB, and the redir is expected
    //        set the time when it closes the file.  Therefore, if we
    //        didn't do this, there would be no way t set a file time
    //        from DOS.
    //
    //     2) It is better for a file to have a redirector's version
    //        of a time than the server's.  This keeps the time
    //        consistent for apps running on the client.  Setting
    //        the file time on close keeps the file time consistent
    //        with the time on the client.
    //
    // !!! should we do anything with the return code from this routine?

    if( rfcb->WriteAccessGranted ||
        rfcb->AppendAccessGranted ) {
        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  SmbGetUlong( &request->LastWriteTimeInSeconds ),
                  rfcb->GrantedAccess
                  );
    }

    //
    // Now proceed to do the actual close file, even if there was
    // a write behind error.
    //

    SrvCloseRfcb( rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( rfcb );
    WorkContext->Rfcb = NULL;
    WorkContext->OplockOpen = FALSE;

#if 0
    //
    // If this is a CloseAndTreeDisc SMB, do the tree disconnect.
    //

    if ( WorkContext->RequestHeader->Command == SMB_COM_CLOSE_AND_TREE_DISC ) {

        IF_SMB_DEBUG(OPEN_CLOSE1) {
            KdPrint(( "Disconnecting tree 0x%lx\n", WorkContext->TreeConnect ));
        }

        SrvCloseTreeConnect( WorkContext->TreeConnect );
    }
#endif

    //
    // Build the response SMB.
    //
    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_CLOSE,
                                        0
                                        );

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbctrl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbctrl.h

Abstract:

    This module defines control functions for SMB processing.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SMBCTRL_
#define _SMBCTRL_

//#include <ntos.h>

//#include "srvblock.h"
//#include "smbtypes.h"

//
// Control routines for SMB processing.
//

VOID SRVFASTCALL
SrvProcessSmb (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvEndSmbProcessing (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    );

//
// Restart routines.
//
VOID SRVFASTCALL
SrvRestartChainedClose (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartFsdComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartSmbReceived (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteAndUnlock (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteAndXRaw (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvBuildAndSendErrorResponse (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartLargeWriteAndX (
    IN PWORK_CONTEXT WorkContext
    );

//
// SMB Processing routines.
//

SMB_PROCESSOR_RETURN_TYPE SRVFASTCALL
SrvSmbIllegalCommand (
    IN PWORK_CONTEXT WorkContext
    );

#endif // def _SMBCTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbattr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbattr.c

Abstract:

    This module contains routines for processing the following SMBs:

        Query Information
        Set Information
        Query Information2
        Set Information2
        Query Path Information
        Set Path Information
        Query File Information
        Set File Information

Author:

    David Treadwell (davidtr) 27-Dec-1989
    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "precomp.h"
#include "smbattr.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBATTR

#pragma pack(1)

typedef struct _FILESTATUS {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    _ULONG( EaSize );           // this field intentionally misaligned!
} FILESTATUS, *PFILESTATUS;

#pragma pack()

STATIC
ULONG QueryFileInformation[] = {
         SMB_QUERY_FILE_BASIC_INFO,// Base level
         FileBasicInformation,     // Mapping for base level
         FileStandardInformation,
         FileEaInformation,
         FileNameInformation,
         FileAllocationInformation,
         FileEndOfFileInformation,
         0,                        // FileAllInformation
         FileAlternateNameInformation,
         FileStreamInformation,
         0,                        //Used to be FileOleAllInformation -- OBSOLETE
         FileCompressionInformation
};

STATIC
ULONG QueryFileInformationSize[] = {
        SMB_QUERY_FILE_BASIC_INFO,// Base level
        FileBasicInformation,     // Mapping for base level
        sizeof( FILE_BASIC_INFORMATION),
        sizeof( FILE_STANDARD_INFORMATION ),
        sizeof( FILE_EA_INFORMATION ),
        sizeof( FILE_NAME_INFORMATION ),
        sizeof( FILE_ALLOCATION_INFORMATION ),
        sizeof( FILE_END_OF_FILE_INFORMATION ),
        sizeof( FILE_ALL_INFORMATION ),
        sizeof( FILE_NAME_INFORMATION ),
        sizeof( FILE_STREAM_INFORMATION ),
        0,                      // Used to be sizeof( FILE_OLE_ALL_INFORMATION )
        sizeof( FILE_COMPRESSION_INFORMATION )
};

STATIC
ULONG SetFileInformation[] = {
         SMB_SET_FILE_BASIC_INFO,  // Base level
         FileBasicInformation,     // Mapping for base level
         FileDispositionInformation,
         FileAllocationInformation,
         FileEndOfFileInformation
};

STATIC
ULONG SetFileInformationSize[] = {
        SMB_SET_FILE_BASIC_INFO, // Base level
        FileBasicInformation,    // Mapping for base level
        sizeof( FILE_BASIC_INFORMATION ),
        sizeof( FILE_DISPOSITION_INFORMATION ),
        sizeof( FILE_ALLOCATION_INFORMATION ),
        sizeof( FILE_END_OF_FILE_INFORMATION )
};

STATIC
NTSTATUS
QueryPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_QUERY_PATH_INFORMATION Response
    );

STATIC
NTSTATUS
SetPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_SET_PATH_INFORMATION Response
    );

SMB_TRANS_STATUS
GenerateQueryPathInfoResponse (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS OpenStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbQueryInformation )
#pragma alloc_text( PAGE, SrvSmbSetInformation )
#pragma alloc_text( PAGE, SrvSmbQueryInformation2 )
#pragma alloc_text( PAGE, SrvSmbSetInformation2 )
#pragma alloc_text( PAGE, QueryPathOrFileInformation )
#pragma alloc_text( PAGE, SrvSmbQueryFileInformation )
#pragma alloc_text( PAGE, SrvSmbQueryPathInformation )
#pragma alloc_text( PAGE, GenerateQueryPathInfoResponse )
#pragma alloc_text( PAGE, SetPathOrFileInformation )
#pragma alloc_text( PAGE, SrvSmbSetFileInformation )
#pragma alloc_text( PAGE, SrvSmbSetPathInformation )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the QueryInformation SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION request;
    PRESP_QUERY_INFORMATION response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN isUnicode;
    FILE_NETWORK_OPEN_INFORMATION fileInformation;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "QueryInformation request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "QueryInformation request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_QUERY_INFORMATION)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: Invalid UID or TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            treeConnect->Share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: bad path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );


    //
    // "Be the client" for access checking
    //
    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        status = SrvGetShareRootHandle( treeConnect->Share );

        if( NT_SUCCESS( status ) ) {
            //
            // The file name is always relative to the share root
            //
            status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
            if( !NT_SUCCESS( status ) )
            {
                goto SnapError;
            }

            //
            // Get the information
            //
            if( IoFastQueryNetworkAttributes(
                &objectAttributes,
                FILE_READ_ATTRIBUTES,
                0,
                &ioStatusBlock,
                &fileInformation
                ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            status = ioStatusBlock.Status;

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS( status ) )
                {
                    goto SnapError;
                }

                if( IoFastQueryNetworkAttributes(
                    &objectAttributes,
                    FILE_READ_ATTRIBUTES,
                    0,
                    &ioStatusBlock,
                    &fileInformation
                    ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

            }

SnapError:
            SrvReleaseShareRootHandle( treeConnect->Share );
        }

        REVERT();
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    //
    // Build the response SMB.
    //

    if ( !NT_SUCCESS(status) ) {

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: "
                        "SrvQueryInformationFileAbbreviated failed: %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );

    } else {

        USHORT smbFileAttributes;
        LARGE_INTEGER newTime;

        response->WordCount = 10;

        SRV_NT_ATTRIBUTES_TO_SMB(
            fileInformation.FileAttributes,
            fileInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &smbFileAttributes
        );

        SmbPutUshort( &response->FileAttributes, smbFileAttributes );

        //
        // Convert the time to that which the SMB protocol needs
        //
        ExSystemTimeToLocalTime( &fileInformation.LastWriteTime, &newTime );
        newTime.QuadPart += AlmostTwoSeconds;

        if ( !RtlTimeToSecondsSince1970( &newTime, &fileInformation.LastWriteTime.LowPart ) ) {
            fileInformation.LastWriteTime.LowPart = 0;
        }

        //
        // Round to 2 seconds
        //
        fileInformation.LastWriteTime.LowPart &= ~1;

        SmbPutUlong(
            &response->LastWriteTimeInSeconds,
            fileInformation.LastWriteTime.LowPart
            );

        SmbPutUlong( &response->FileSize, fileInformation.EndOfFile.LowPart );
        RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_QUERY_INFORMATION,
                                            0
                                            );
    }

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the SetInformation SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SET_INFORMATION request;
    PRESP_SET_INFORMATION response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN isUnicode;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG lastWriteTimeInSeconds;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_INFORMATION;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SetInformation request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "SetInformation request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_SET_INFORMATION)WorkContext->RequestParameters;
    response = (PRESP_SET_INFORMATION)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                  WorkContext,
                  &session,
                  &treeConnect,
                  ShareTypeDisk
                  );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: Invalid UID and TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: Invalid TID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Concatenate PathName from the share block and PathName from the
    // incoming SMB to generate the full path name to the file.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            treeConnect->Share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: bad path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the client is trying to delete the root of the share, reject
    // the request.
    //

    if ( objectName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: attempting to set info on "
                          "share root\n" ));
        }

        if (!SMB_IS_UNICODE( WorkContext )) {
            RtlFreeUnicodeString( &objectName );
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    IF_SMB_DEBUG(QUERY_SET2) KdPrint(( "Opening file %wZ\n", &objectName ));

    //
    // Open the file--must be opened in order to have a handle to pass
    // to NtSetInformationFile.  We will close it after setting the
    // necessary information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // *** FILE_WRITE_ATTRIBUTES does not cause oplock breaks!
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 FILE_WRITE_ATTRIBUTES,                     // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE,                      // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 treeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     FILE_WRITE_ATTRIBUTES,                     // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,                      // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     treeConnect->Share
                     );
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    if ( NT_SUCCESS(status) ) {

        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 20, 0 );

        //
        // Ensure this client's RFCB cache is empty.  This covers the case
        //  where a client opened a file for writing, closed it, set the
        //  attributes to readonly, and then tried to reopen the file for
        //  writing.  This sequence should fail, but it will succeed if the
        //  file was in the RFCB cache.
        //
        SrvCloseCachedRfcbsOnConnection( WorkContext->Connection );

    } else {

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetInformation: SrvIoCreateFile "
                        "failed: %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    //
    // Set fields of fileBasicInformation to pass to NtSetInformationFile.
    // Note that we zero the creation, last access, and change times so
    // that they are not actually changed.
    //

    RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

    lastWriteTimeInSeconds = SmbGetUlong( &request->LastWriteTimeInSeconds );
    if ( lastWriteTimeInSeconds != 0 ) {
        RtlSecondsSince1970ToTime(
            lastWriteTimeInSeconds,
            &fileBasicInformation.LastWriteTime
            );

        ExLocalTimeToSystemTime(
            &fileBasicInformation.LastWriteTime,
            &fileBasicInformation.LastWriteTime
            );

    }

    //
    // Set the new file attributes.  Note that we don't return an error
    // if the client tries to set the Directory or Volume bits -- we
    // assume that the remote redirector filters such requests.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbGetUshort( &request->FileAttributes ),
        NULL,
        &fileBasicInformation.FileAttributes
        );

    //
    // Set the new file information.
    //

    status = NtSetInformationFile(
                 fileHandle,
                 &ioStatusBlock,
                 &fileBasicInformation,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    //
    // Close the file--it was only opened to set the attributes.
    //

    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 30, 0 );
    SrvNtClose( fileHandle, TRUE );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbSetInformation: NtSetInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_SET_INFORMATION,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetInformation complete.\n" ));
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbSetInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the QueryInformation2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION2 request;
    PRESP_QUERY_INFORMATION2 response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    SRV_FILE_INFORMATION fileInformation;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "QueryInformation2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "QueryInformation2 request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_QUERY_INFORMATION2)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION2)WorkContext->ResponseParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbQueryInformation2: Status %X on fid 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has read attributes access to the file via
    // the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_QUERY_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbQueryInformation2: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Get the necessary information about the file.
    //

    status = SrvQueryInformationFile(
                rfcb->Lfcb->FileHandle,
                rfcb->Lfcb->FileObject,
                &fileInformation,
                (SHARE_TYPE) -1,
                FALSE
                );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbQueryInformation2: SrvQueryInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 11;
    SmbPutDate( &response->CreationDate, fileInformation.CreationDate );
    SmbPutTime( &response->CreationTime, fileInformation.CreationTime );
    SmbPutDate( &response->LastAccessDate, fileInformation.LastAccessDate );
    SmbPutTime( &response->LastAccessTime, fileInformation.LastAccessTime );
    SmbPutDate( &response->LastWriteDate, fileInformation.LastWriteDate );
    SmbPutTime( &response->LastWriteTime, fileInformation.LastWriteTime );
    SmbPutUlong( &response->FileDataSize, fileInformation.DataSize.LowPart );
    SmbPutUlong(
        &response->FileAllocationSize,
        fileInformation.AllocationSize.LowPart
        );
    SmbPutUshort( &response->FileAttributes, fileInformation.Attributes );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_QUERY_INFORMATION2,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbQueryInformation2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformation2


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Set Information2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SET_INFORMATION2 request;
    PRESP_SET_INFORMATION2 response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    FILE_BASIC_INFORMATION fileBasicInformation;
    IO_STATUS_BLOCK ioStatusBlock;
    SMB_DATE date;
    SMB_TIME time;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_INFORMATION2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SetInformation2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "SetInformation2 request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_SET_INFORMATION2)WorkContext->RequestParameters;
    response = (PRESP_SET_INFORMATION2)WorkContext->ResponseParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSetInformation2: Status %X on fid 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has write attributes access to the file
    // via the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetInformation2: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Convert the DOS dates and times passed in the SMB to NT TIMEs
    // to pass to NtSetInformationFile.  Note that we zero the rest
    // of the fileBasicInformation structure so that the corresponding
    // fields are not changed.
    //

    RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

    SmbMoveDate( &date, &request->CreationDate );
    SmbMoveTime( &time, &request->CreationTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.CreationTime, date, time );
    }

    SmbMoveDate( &date, &request->LastAccessDate );
    SmbMoveTime( &time, &request->LastAccessTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.LastAccessTime, date, time );
    }

    SmbMoveDate( &date, &request->LastWriteDate );
    SmbMoveTime( &time, &request->LastWriteTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.LastWriteTime, date, time );
    }

    //
    // Call NtSetInformationFile to set the information from the SMB.
    //


    status = NtSetInformationFile(
                 rfcb->Lfcb->FileHandle,
                 &ioStatusBlock,
                 &fileBasicInformation,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbSetInformation2: NtSetInformationFile failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // reset the WrittenTo flag.  This will allow this rfcb to be cached.
    //

    rfcb->WrittenTo = FALSE;

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_SET_INFORMATION2,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetInformation2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetInformation2


STATIC
NTSTATUS
QueryPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_QUERY_PATH_INFORMATION Response
    )

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    SRV_FILE_INFORMATION fileInformation;
    BOOLEAN queryEaSize;
    USHORT eaErrorOffset;
    PFILE_ALL_INFORMATION fileAllInformation;
    ULONG nameInformationSize;
    PVOID currentLocation;
    ULONG dataSize;

    PUNICODE_STRING pathName;
    ULONG inputBufferLength;
    PPATHNAME_BUFFER inputBuffer;

    PFILE_NAME_INFORMATION nameInfoBuffer;
    PSHARE share;

    PAGED_CODE( );

    Transaction->SetupCount = 0;
    Transaction->ParameterCount = 0;

    if( InformationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( InformationLevel ) {
        case SMB_INFO_STANDARD:
        case SMB_INFO_QUERY_EA_SIZE:

            //
            // Information level is either STANDARD or QUERY_EA_SIZE.  Both
            // return normal file information; the latter also returns the
            // length of the file's EAs.
            //

            queryEaSize = (BOOLEAN)(InformationLevel == SMB_INFO_QUERY_EA_SIZE);

            status = SrvQueryInformationFile(
                        FileHandle,
                        NULL,
                        &fileInformation,
                        (SHARE_TYPE) -1, // Don't care
                        queryEaSize
                        );

            if ( NT_SUCCESS(status) ) {

                //
                // Build the output parameter and data structures.
                //

                PFILESTATUS fileStatus = (PFILESTATUS)Transaction->OutData;

                Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );
                SmbPutUshort( &Response->EaErrorOffset, 0 );
                Transaction->DataCount = queryEaSize ? 26 : 22;

                SmbPutDate(
                    &fileStatus->CreationDate,
                    fileInformation.CreationDate
                    );
                SmbPutTime(
                    &fileStatus->CreationTime,
                    fileInformation.CreationTime
                    );

                SmbPutDate(
                    &fileStatus->LastAccessDate,
                    fileInformation.LastAccessDate
                    );
                SmbPutTime(
                    &fileStatus->LastAccessTime,
                    fileInformation.LastAccessTime
                    );

                SmbPutDate(
                    &fileStatus->LastWriteDate,
                    fileInformation.LastWriteDate
                    );
                SmbPutTime(
                    &fileStatus->LastWriteTime,
                    fileInformation.LastWriteTime
                    );

                SmbPutUlong( &fileStatus->DataSize, fileInformation.DataSize.LowPart );
                SmbPutUlong(
                    &fileStatus->AllocationSize,
                    fileInformation.AllocationSize.LowPart
                    );

                SmbPutUshort(
                    &fileStatus->Attributes,
                    fileInformation.Attributes
                    );

                if ( queryEaSize ) {
                    SmbPutUlong( &fileStatus->EaSize, fileInformation.EaSize );
                }

            } else {

                //
                // Set the data count to zero so that no data is returned to the
                // client.
                //

                Transaction->DataCount = 0;

                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "QueryPathOrFileInformation: SrvQueryInformationFile"
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

            }

            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:

            //
            // The request is for EAs, either all of them or a subset.
            //

            status = SrvQueryOs2FeaList(
                         FileHandle,
                         InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ?
                             (PGEALIST)Transaction->InData : NULL,
                         NULL,
                         Transaction->DataCount,
                         (PFEALIST)Transaction->OutData,
                         Transaction->MaxDataCount,
                         &eaErrorOffset
                         );

            if ( NT_SUCCESS(status) ) {

                //
                // The first longword of the OutData buffer holds the length
                // of the remaining data written (the cbList field of the
                // FEALIST).  Add four (the longword itself) to get the number
                // of data bytes written.
                //

                Transaction->DataCount =
                       SmbGetAlignedUlong( (PULONG)Transaction->OutData );

#if     0
                //
                // If there were no EAs, convert the error to
                // STATUS_NO_EAS_ON_FILE.  OS/2 clients expect STATUS_SUCCESS.
                //

                if ( (Transaction->DataCount == 4) &&
                     IS_NT_DIALECT( Transaction->Connection->SmbDialect ) ) {

                    status = STATUS_NO_EAS_ON_FILE;
                }
#endif
            } else {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "QueryPathOrFileInformation: "
                                "SrvQueryOs2FeaList failed: %X\n", status ));
                }

                Transaction->DataCount = 0;
            }

            //
            // Build the output parameter and data structures.
            //

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );
            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );

            break;

        case SMB_INFO_IS_NAME_VALID:
            status = STATUS_SUCCESS;
            Transaction->DataCount = 0;

            break;

        case SMB_QUERY_FILE_BASIC_INFO:
        case SMB_QUERY_FILE_STANDARD_INFO:
        case SMB_QUERY_FILE_EA_INFO:
        case SMB_QUERY_FILE_ALT_NAME_INFO:
        case SMB_QUERY_FILE_STREAM_INFO:
        case SMB_QUERY_FILE_COMPRESSION_INFO:

            //
            // Pass the data buffer directly to the file system as it
            // is already in NT format.
            //

            if( Transaction->MaxDataCount <
                MAP_SMB_INFO_TO_MIN_NT_SIZE(QueryFileInformationSize, InformationLevel ) ) {

                //
                // The buffer is too small.  Return an error.
                //
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = NtQueryInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             Transaction->OutData,
                             Transaction->MaxDataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 QueryFileInformation,
                                 InformationLevel
                                 )
                             );
            }

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            if (NT_SUCCESS( status) || (status == STATUS_BUFFER_OVERFLOW)) {
                Transaction->DataCount = (ULONG)ioStatusBlock.Information;
            } else {
                Transaction->DataCount = 0;
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

DoFileNameInfo:
            share = Transaction->TreeConnect->Share;

            nameInfoBuffer = (PFILE_NAME_INFORMATION)Transaction->OutData;

            if ( Transaction->MaxDataCount < FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) ) {

                //
                // The buffer is too small to fit even the fixed part.
                // Return an error.
                //

                status = STATUS_INFO_LENGTH_MISMATCH;
                Transaction->DataCount = 0;

            } else if ( share->ShareType != ShareTypeDisk ) {

                //
                // This is not a disk share.  Pass the request straight to
                // the file system.
                //

                status = NtQueryInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             nameInfoBuffer,
                             Transaction->MaxDataCount,
                             FileNameInformation
                             );

                Transaction->DataCount = (ULONG)ioStatusBlock.Information;

            } else {

                //
                // We need a temporary buffer since the file system will
                // return the share path together with the file name.  The
                // total length might be larger than the max data allowed
                // in the transaction, though the actual name might fit.
                //

                PFILE_NAME_INFORMATION tempBuffer;
                ULONG tempBufferLength;

                ASSERT( share->QueryNamePrefixLength >= 0 );

                tempBufferLength = Transaction->MaxDataCount + share->QueryNamePrefixLength;

                tempBuffer = ALLOCATE_HEAP( tempBufferLength, BlockTypeBuffer );

                if ( tempBuffer == NULL ) {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                } else {
                    status = NtQueryInformationFile(
                                 FileHandle,
                                 &ioStatusBlock,
                                 tempBuffer,
                                 tempBufferLength,
                                 FileNameInformation
                                 );
                }

                //
                // remove the share part
                //

                if ( (status == STATUS_SUCCESS) || (status == STATUS_BUFFER_OVERFLOW) ) {

                    LONG bytesToMove;
                    PWCHAR source;
                    WCHAR slash = L'\\';

                    //
                    // Calculate how long the name string is, not including the root prefix.
                    //

                    bytesToMove = (LONG)(tempBuffer->FileNameLength - share->QueryNamePrefixLength);

                    if ( bytesToMove <= 0 ) {

                        //
                        // bytesToMove will be zero if this is the root of
                        // the share.  Return just a \ for this case.
                        //

                        bytesToMove = sizeof(WCHAR);
                        source = &slash;

                    } else {

                        source = tempBuffer->FileName + share->QueryNamePrefixLength/sizeof(WCHAR);

                    }

                    //
                    // Store the actual file name length.
                    //

                    SmbPutUlong( &nameInfoBuffer->FileNameLength, bytesToMove );

                    //
                    // If the buffer isn't big enough, return an error and
                    // reduce the amount to be copied.
                    //

                    if ( (ULONG)bytesToMove >
                         (Transaction->MaxDataCount -
                            FIELD_OFFSET(FILE_NAME_INFORMATION,FileName)) ) {

                        status = STATUS_BUFFER_OVERFLOW;
                        bytesToMove = Transaction->MaxDataCount -
                                    FIELD_OFFSET(FILE_NAME_INFORMATION,FileName);

                    } else {
                        status = STATUS_SUCCESS;
                    }

                    //
                    // Copy all but the prefix.
                    //

                    RtlCopyMemory(
                        nameInfoBuffer->FileName,
                        source,
                        bytesToMove
                        );

                    Transaction->DataCount =
                        FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) + bytesToMove;

                } else {
                    Transaction->DataCount = 0;
                }

                if ( tempBuffer != NULL ) {
                    FREE_HEAP( tempBuffer );
                }

            }

            SmbPutUshort( &Response->EaErrorOffset, 0 );
            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            break;

        case SMB_QUERY_FILE_ALL_INFO:

DoFileAllInfo:
            //
            // Setup early for the response in case the call to the file
            // system fails.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            //
            // Allocate a buffer large enough to return all the information.
            // The buffer size we request is the size requested by the client
            // plus room for the extra information returned by the file system
            // that the server doesn't return to the client.
            //

            dataSize = Transaction->MaxDataCount +
                           sizeof( FILE_ALL_INFORMATION )
                           - sizeof( FILE_BASIC_INFORMATION )
                           - sizeof( FILE_STANDARD_INFORMATION )
                           - sizeof( FILE_EA_INFORMATION )
                           - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );

            if (dataSize < sizeof( FILE_ALL_INFORMATION ) ) {

                //
                // The buffer is too small.  Return an error.
                //
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            fileAllInformation = ALLOCATE_HEAP_COLD( dataSize, BlockTypeDataBuffer );

            if ( fileAllInformation == NULL ) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatusBlock,
                         fileAllInformation,
                         dataSize,
                         FileAllInformation
                         );

            if ( NT_SUCCESS( status ) ) {

                //
                // Calculate the size of data we will return.  We do not
                // return the entire buffer, just specific fields.
                //

                nameInformationSize =
                    FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) +
                    fileAllInformation->NameInformation.FileNameLength;

                Transaction->DataCount =
                    sizeof( FILE_BASIC_INFORMATION ) +
                    sizeof( FILE_STANDARD_INFORMATION ) +
                    sizeof( FILE_EA_INFORMATION ) +
                    nameInformationSize;

                //
                // Now copy the data into the transaction buffer.  Start with
                // the fixed sized fields.
                //

                currentLocation = Transaction->OutData;

                *((PFILE_BASIC_INFORMATION)currentLocation)++ =
                     fileAllInformation->BasicInformation;
                *((PFILE_STANDARD_INFORMATION)currentLocation)++ =
                     fileAllInformation->StandardInformation;
                *((PFILE_EA_INFORMATION)currentLocation)++ =
                     fileAllInformation->EaInformation;

                RtlCopyMemory(
                    currentLocation,
                    &fileAllInformation->NameInformation,
                    nameInformationSize
                    );

            } else {
                Transaction->DataCount = 0;
            }

            FREE_HEAP( fileAllInformation );

            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "QueryPathOrFileInformation: bad info level %d\n",
                           InformationLevel ));
            }

            status = STATUS_INVALID_SMB;

            break;
        }

    } else {

        InformationLevel -= SMB_INFO_PASSTHROUGH;

        if( InformationLevel == FileNameInformation ) {
            goto DoFileNameInfo;
        } else if( InformationLevel == FileAllInformation ) {
            goto DoFileAllInfo;
        }

        //
        // See if the supplied parameters are correct.
        //
        status = IoCheckQuerySetFileInformation( InformationLevel,
                                                 Transaction->MaxDataCount,
                                                 FALSE );

        if( NT_SUCCESS( status ) ) {

            //
            // Some information levels require us to impersonate the client.  Do it for all.
            //
            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryInformationFile(
                                 FileHandle,
                                 &ioStatusBlock,
                                 Transaction->OutData,
                                 Transaction->MaxDataCount,
                                 InformationLevel
                                 );
                REVERT();
            }
        }

        SmbPutUshort( &Response->EaErrorOffset, 0 );

        Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

        if (NT_SUCCESS( status) || (status == STATUS_BUFFER_OVERFLOW)) {
            Transaction->DataCount = (ULONG)ioStatusBlock.Information;
        } else {
            Transaction->DataCount = 0;
        }
    }

    return status;

} // QueryPathOrFileInformation


SMB_TRANS_STATUS
SrvSmbQueryFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query File Information request.  This request arrives
    in a Transaction2 SMB.  Query File Information corresponds to the
    OS/2 DosQFileInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_QUERY_FILE_INFORMATION request;
    PRESP_QUERY_FILE_INFORMATION response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT informationLevel;
    ACCESS_MASK grantedAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_FILE_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query File Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_QUERY_FILE_INFORMATION)transaction->InParameters;
    response = (PRESP_QUERY_FILE_INFORMATION)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_QUERY_FILE_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_QUERY_FILE_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(QUERY_SET1) {
            KdPrint(( "SrvSmbQueryFileInformation: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbQueryFileInformation: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );
    grantedAccess = rfcb->GrantedAccess;

    status = STATUS_SUCCESS;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:

            if ( transaction->MaxDataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbQueryFileInformation: invalid MaxDataCount "
                                "%ld\n", transaction->MaxDataCount ));
                }
                status = STATUS_INVALID_SMB;
                break;
            }

            //
            // Verify that the client has read attributes access to the file
            // via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            if ( transaction->MaxDataCount < 26 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbQueryFileInformation: invalid MaxDataCount "
                                "%ld\n", transaction->MaxDataCount ));
                }
                status = STATUS_INVALID_SMB;
                break;
            }

            //
            // Verify that the client has read EA access to the file via the
            // specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(SMB_ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:


            //
            // Verify that the client has read EA access to the file via the
            // specified handle.
            //

            CHECK_FUNCTION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_EA,
                0,
                0,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;


        case SMB_QUERY_FILE_BASIC_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STANDARD_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStandardInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_EA_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALL_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAllInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALT_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAlternateNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STREAM_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStreamInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_COMPRESSION_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileCompressionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        default:

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbQueryFileInformation: invalid info level %ld\n",
                            informationLevel ));
            }

            status = STATUS_OS2_INVALID_LEVEL;
            break;
        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;
        }

        if( NT_SUCCESS( status ) ) {
            status = IoCheckQuerySetFileInformation( informationLevel - SMB_INFO_PASSTHROUGH,
                                                 0xFFFFFFFF,
                                                 FALSE
                                                );
        }

        if( NT_SUCCESS( status ) ) {
            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );
        }
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the necessary information about the file.
    //

    status = QueryPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 rfcb->Lfcb->FileHandle,
                 (PRESP_QUERY_PATH_INFORMATION)response
                 );

    //
    // Map STATUS_BUFFER_OVERFLOW for OS/2 clients.
    //

    if ( status == STATUS_BUFFER_OVERFLOW &&
         !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

        status = STATUS_BUFFER_TOO_SMALL;

    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // QueryPathOrFileInformation already filled in the response
        // information, so just set the error and return.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbQueryFileInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryFileInformation


SMB_TRANS_STATUS
SrvSmbQueryPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the Query Path Information request.  This request arrives
    in a Transaction2 SMB.  Query Path Information corresponds to the
    OS/2 DosQPathInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/
{
    PTRANSACTION transaction;
    PREQ_QUERY_PATH_INFORMATION request;
    PRESP_QUERY_PATH_INFORMATION response;
    USHORT informationLevel;
    NTSTATUS         status    = STATUS_SUCCESS;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    BOOLEAN isUnicode;

    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;
    ACCESS_MASK desiredAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_PATH_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query Path Information entered; transaction 0x%p\n",
                    transaction ));
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( (transaction->ParameterCount <
            sizeof(REQ_QUERY_PATH_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_QUERY_PATH_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryPathInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    request = (PREQ_QUERY_PATH_INFORMATION)transaction->InParameters;
    informationLevel = SmbGetUshort( &request->InformationLevel );

    //
    // The response formats for Query Path and Query File and identical,
    // so just use the RESP_QUERY_PATH_INFORMATION structure for both.
    // The request formats differ, so conditionalize access to them.
    //
    response = (PRESP_QUERY_PATH_INFORMATION)transaction->OutParameters;

    switch( informationLevel ) {
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_INFO_QUERY_ALL_EAS:

        //
        // For these info levels, we must be in a blocking thread because we
        // might end up waiting for an oplock break.
        //
        if( WorkContext->UsingBlockingThread == 0 ) {
            WorkContext->FspRestartRoutine = SrvRestartExecuteTransaction;
            SrvQueueWorkToBlockingThread( WorkContext );
            smbStatus = SmbTransStatusInProgress;
            goto Cleanup;
        }
        desiredAccess = FILE_READ_EA;
        break;

    default:
        desiredAccess = FILE_READ_ATTRIBUTES;
        break;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            WorkContext->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryPathInformation: bad path name: %s\n",
                        request->Buffer ));
        }

        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Special case: If this is the IS_PATH_VALID information level, then
    // the user just wants to know if the path syntax is correct.  Do not
    // attempt to open the file.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    if ( informationLevel == SMB_INFO_IS_NAME_VALID ) {

        transaction->InData = (PVOID)&objectName;

        //
        // Get the Share root handle.
        //
        smbStatus = SrvGetShareRootHandle( WorkContext->TreeConnect->Share );

        if ( !NT_SUCCESS(smbStatus) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbQueryPathInformation: SrvGetShareRootHandle failed %x.\n",
                            smbStatus ));
            }

            if (!isUnicode) {
                RtlFreeUnicodeString( &objectName );
            }

            SrvSetSmbError( WorkContext, smbStatus );
            status    = smbStatus;
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        status = SrvSnapGetRootHandle( WorkContext, &WorkContext->Parameters2.FileInformation.FileHandle );
        if( !NT_SUCCESS(status) )
        {
            SrvSetSmbError( WorkContext, status );
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }


        smbStatus = GenerateQueryPathInfoResponse(
                       WorkContext,
                       SmbTransStatusSuccess
                       );

        //
        // Release the root handle for removable devices
        //

        SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         transaction->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Take the fast path for this if we can
    //
    if( informationLevel == SMB_QUERY_FILE_BASIC_INFO ) {

        FILE_NETWORK_OPEN_INFORMATION fileInformation;
        UNALIGNED FILE_BASIC_INFORMATION *pbInfo = (PFILE_BASIC_INFORMATION)transaction->OutData;

        if( transaction->MaxDataCount < sizeof( FILE_BASIC_INFORMATION ) ) {
            SrvSetSmbError( WorkContext, STATUS_INFO_LENGTH_MISMATCH );
            status    = STATUS_INFO_LENGTH_MISMATCH;
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = SrvGetShareRootHandle( transaction->TreeConnect->Share );

            if( NT_SUCCESS( status ) ) {

                //
                // The file name is always relative to the share root
                //
                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS(status) )
                {
                    goto SnapError;
                }

                //
                // Get the information
                //
                if( IoFastQueryNetworkAttributes(
                        &objectAttributes,
                        FILE_READ_ATTRIBUTES,
                        0,
                        &ioStatusBlock,
                        &fileInformation
                        ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( transaction->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    //
                    // Get the information
                    //
                    if( IoFastQueryNetworkAttributes(
                            &objectAttributes,
                            FILE_READ_ATTRIBUTES,
                            0,
                            &ioStatusBlock,
                            &fileInformation
                            ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatusBlock.Status;
                }

SnapError:

                SrvReleaseShareRootHandle( transaction->TreeConnect->Share );
            }

            REVERT();
        }

        if( status == STATUS_BUFFER_OVERFLOW ) {
            goto hard_way;
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }

        if ( !NT_SUCCESS( status ) ) {
            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbQueryPathInformation: IoFastQueryNetworkAttributes "
                    "failed: %X\n", status ));
            }

            SrvSetSmbError( WorkContext, status );
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        // FORMULATE THE RESPONSE

        transaction->SetupCount = 0;
        transaction->DataCount = sizeof( *pbInfo );
        transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

        SmbPutUshort( &response->EaErrorOffset, 0 );

        pbInfo->CreationTime =   fileInformation.CreationTime;
        pbInfo->LastAccessTime = fileInformation.LastAccessTime;
        pbInfo->LastWriteTime =  fileInformation.LastWriteTime;
        pbInfo->ChangeTime =     fileInformation.ChangeTime;
        pbInfo->FileAttributes = fileInformation.FileAttributes;

        smbStatus = SmbTransStatusSuccess;
        goto Cleanup;
    }

hard_way:

    IF_SMB_DEBUG(QUERY_SET2) KdPrint(( "Opening file %wZ\n", &objectName ));

    //
    // Open the file -- must be opened in order to have a handle to pass
    // to NtQueryInformationFile.  We will close it after getting the
    // necessary information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // !!! We may block if the file is oplocked.  We must do this, because
    //     it is required to get the FS to break a batch oplock.
    //     We should figure out a way to do this without blocking.
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 desiredAccess,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE,                      // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 transaction->TreeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,                      // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     transaction->TreeConnect->Share
                     );
    }

    if ( NT_SUCCESS(status) ) {
        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 21, 0 );
    }
    else {
        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    //
    // Save a copy of the file handle for the restart routine.
    //

    WorkContext->Parameters2.FileInformation.FileHandle = fileHandle;

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    smbStatus = GenerateQueryPathInfoResponse( WorkContext, status );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return smbStatus;

} // SrvSmbQueryPathInformation


SMB_TRANS_STATUS
GenerateQueryPathInfoResponse (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS OpenStatus
    )

/*++

Routine Description:

    This function completes processing for and generates a response to a
    query path information response SMB.

Arguments:

    WorkContext - A pointer to the work context block for this SMB
    OpenStatus - The completion status of the open.

Return Value:

    The status of the SMB processing.

--*/

{
    PREQ_QUERY_PATH_INFORMATION request;
    PRESP_QUERY_PATH_INFORMATION response;
    PTRANSACTION transaction;

    NTSTATUS status;
    BOOLEAN error;
    HANDLE fileHandle;
    USHORT informationLevel;

    PFILE_OBJECT fileObject;
    OBJECT_HANDLE_INFORMATION handleInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query Path Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_QUERY_PATH_INFORMATION)transaction->InParameters;
    response = (PRESP_QUERY_PATH_INFORMATION)transaction->OutParameters;

    fileHandle = WorkContext->Parameters2.FileInformation.FileHandle;

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( OpenStatus == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS( OpenStatus ) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateQueryPathInfoResponse: SrvIoCreateFile failed: %X\n", OpenStatus ));
        }

        SrvSetSmbError( WorkContext, OpenStatus );

        return SmbTransStatusErrorWithoutData;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    //
    // Find out the access the user has.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "GenerateQueryPathInfoResponse: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, OpenStatus );
        return SmbTransStatusErrorWithoutData;

    }

    ObDereferenceObject( fileObject );

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    error = FALSE;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:
            if ( transaction->MaxDataCount < 22 ) {
                IF_SMB_DEBUG(QUERY_SET1) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EA_SIZE:
            if ( transaction->MaxDataCount < 26 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:
            if ( transaction->MaxDataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_IS_NAME_VALID:
            break;

        case SMB_QUERY_FILE_BASIC_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STANDARD_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStandardInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_EA_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALL_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAllInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALT_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAlternateNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STREAM_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStreamInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_COMPRESSION_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileCompressionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "GenerateQueryPathInfoResponse: invalid info level"
                          "%ld\n", informationLevel ));
            }
            error = TRUE;
            break;
        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;
        }

        if( NT_SUCCESS( status ) ) {
            status = IoCheckQuerySetFileInformation( informationLevel - SMB_INFO_PASSTHROUGH,
                                                 0xFFFFFFFF,
                                                 FALSE
                                                );
        }

        if( NT_SUCCESS( status ) ) {
            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );

        } else {

            error = TRUE;

        }
    }

    if ( error ) {

        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 32, 0 );
        SrvNtClose( fileHandle, TRUE );
        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get the necessary information about the file.
    //

    status = QueryPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 fileHandle,
                 (PRESP_QUERY_PATH_INFORMATION)response
                 );

    //
    // Map STATUS_BUFFER_OVERFLOW for OS/2 clients.
    //

    if ( status == STATUS_BUFFER_OVERFLOW &&
         !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

        status = STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Close the file--it was only opened to read the attributes.
    //

    if ( informationLevel != SMB_INFO_IS_NAME_VALID ) {
        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 33, 0 );
        SrvNtClose( fileHandle, TRUE );
    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // QueryPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    IF_DEBUG(TRACE2) KdPrint(( "GenerateQueryPathInfoResponse complete.\n" ));
    return SmbTransStatusSuccess;

} // GenerateQueryPathInfoResponse


STATIC
NTSTATUS
SetPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_SET_PATH_INFORMATION Response
    )

{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    SMB_DATE date;
    SMB_TIME time;
    PWCHAR p, ep;

    PFILESTATUS fileStatus = (PFILESTATUS)Transaction->InData;
    FILE_BASIC_INFORMATION fileBasicInformation;

    USHORT eaErrorOffset;

    PAGED_CODE( );

    if( InformationLevel < SMB_INFO_PASSTHROUGH ) {
        switch( InformationLevel ) {

        case SMB_INFO_STANDARD:

            //
            // Information level is STANDARD.  Set normal file information.
            // Convert the DOS dates and times passed in the SMB to NT TIMEs
            // to pass to NtSetInformationFile.  Note that we zero the rest
            // of the fileBasicInformation structure so that the corresponding
            // fields are not changed.  Note also that the file attributes
            // are not changed.
            //

            RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

            if ( !SmbIsDateZero(&fileStatus->CreationDate) ||
                 !SmbIsTimeZero(&fileStatus->CreationTime) ) {

                SmbMoveDate( &date, &fileStatus->CreationDate );
                SmbMoveTime( &time, &fileStatus->CreationTime );

                SrvDosTimeToTime( &fileBasicInformation.CreationTime, date, time );
            }

            if ( !SmbIsDateZero(&fileStatus->LastAccessDate) ||
                 !SmbIsTimeZero(&fileStatus->LastAccessTime) ) {

                SmbMoveDate( &date, &fileStatus->LastAccessDate );
                SmbMoveTime( &time, &fileStatus->LastAccessTime );

                SrvDosTimeToTime( &fileBasicInformation.LastAccessTime, date, time );
            }

            if ( !SmbIsDateZero(&fileStatus->LastWriteDate) ||
                 !SmbIsTimeZero(&fileStatus->LastWriteTime) ) {

                SmbMoveDate( &date, &fileStatus->LastWriteDate );
                SmbMoveTime( &time, &fileStatus->LastWriteTime );

                SrvDosTimeToTime( &fileBasicInformation.LastWriteTime, date, time );
            }

            //
            // Call NtSetInformationFile to set the information from the SMB.
            //

            status = NtSetInformationFile(
                         FileHandle,
                         &ioStatusBlock,
                         &fileBasicInformation,
                         sizeof(FILE_BASIC_INFORMATION),
                         FileBasicInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SetPathOrFileInformation: SrvSetInformationFile returned: %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            }

            //
            // No EAs to deal with.  Set EA error offset to zero.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            //
            // The request is to set the file's EAs.
            //

            status = SrvSetOs2FeaList(
                         FileHandle,
                         (PFEALIST)Transaction->InData,
                         Transaction->DataCount,
                         &eaErrorOffset
                         );

            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SetPathOrFileInformation: SrvSetOs2FeaList "
                                "failed: %X\n", status ));
                }
            }

            //
            // Return the EA error offset in the response.
            //

            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );

            break;


        case SMB_SET_FILE_BASIC_INFO:
        case SMB_SET_FILE_DISPOSITION_INFO:
        case SMB_SET_FILE_ALLOCATION_INFO:
        case SMB_SET_FILE_END_OF_FILE_INFO:

            //
            // The data buffer is in NT format.  Pass it directly to the
            // filesystem.
            //
            if( Transaction->DataCount <
                MAP_SMB_INFO_TO_MIN_NT_SIZE(SetFileInformationSize, InformationLevel ) ) {

                //
                // The buffer is too small.  Return an error.
                //
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = NtSetInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             Transaction->InData,
                             Transaction->DataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 SetFileInformation,
                                 InformationLevel
                                 )
                             );

            }

            //
            // No EAs to deal with.  Set EA error offset to zero.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            break;

        default:
            status = STATUS_OS2_INVALID_LEVEL;
            break;
        }

    } else {
        PFILE_RENAME_INFORMATION setInfo = NULL;
        ULONG setInfoLength;
#ifdef _WIN64
        PFILE_RENAME_INFORMATION32 pRemoteInfo;
#endif

        InformationLevel -= SMB_INFO_PASSTHROUGH;

        setInfo = (PFILE_RENAME_INFORMATION)Transaction->InData;
        setInfoLength = Transaction->DataCount;

        //
        // There are some info levels which we do not allow in this path.  Unless we
        // put in special handling, we can not allow any that pass handles.  And we
        // would need to be careful on any that allow renaming or linking (to prevent
        // escaping the share).  These are the ones we restrict or disallow,
        // which the I/O subsystem may otherwise allow:
        //
        switch( InformationLevel ) {
        case FileLinkInformation:
        case FileMoveClusterInformation:
        case FileTrackingInformation:
        case FileCompletionInformation:
        case FileMailslotSetInformation:
            status = STATUS_NOT_SUPPORTED;
            break;

        case FileRenameInformation: {

            PWCHAR s, es;

#ifdef _WIN64
            pRemoteInfo = (PFILE_RENAME_INFORMATION32)Transaction->InData;
            setInfoLength = Transaction->DataCount + sizeof(PVOID)-sizeof(ULONG);
            setInfo = (PFILE_RENAME_INFORMATION)ALLOCATE_NONPAGED_POOL( setInfoLength, BlockTypeMisc );
            if( !setInfo )
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            // Thunk most of the structure but wait to copy until we validate the file
            // name length is correct
            setInfo->ReplaceIfExists = pRemoteInfo->ReplaceIfExists;
            setInfo->RootDirectory = UlongToHandle( pRemoteInfo->RootDirectory );
            setInfo->FileNameLength = pRemoteInfo->FileNameLength;
#endif

            //
            // See if the structure is internally consistent
            //
            if( setInfoLength < sizeof( FILE_RENAME_INFORMATION ) ||
                setInfo->RootDirectory != NULL ||
                setInfo->FileNameLength > setInfoLength ||
                (setInfo->FileNameLength & (sizeof(WCHAR)-1)) ||
                setInfo->FileNameLength +
                    FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName ) >
                    setInfoLength ) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

#ifdef _WIN64
            // We've validated the original buffer, so lets copy the filename
            RtlCopyMemory( setInfo->FileName, pRemoteInfo->FileName, setInfo->FileNameLength );
#endif

            //
            // If there are any path separaters in the name, then we do not support
            //   this operation.
            //
            es = &setInfo->FileName[ setInfo->FileNameLength / sizeof( WCHAR ) ];
            for( s = setInfo->FileName; s < es; s++ ) {
                if( IS_UNICODE_PATH_SEPARATOR( *s ) ) {
                    status = STATUS_NOT_SUPPORTED;
                    break;
                }
            }
        }

        }

        if( NT_SUCCESS( status ) ) {

            //
            // See if the supplied parameters are correct.
            //
            status = IoCheckQuerySetFileInformation( InformationLevel,
                                                     setInfoLength,
                                                     TRUE
                                                    );
            if( NT_SUCCESS( status ) ) {

                //
                // Some information levels require us to impersonate the client.
                //
                status = IMPERSONATE( WorkContext );

                if( NT_SUCCESS( status ) ) {
                    status = NtSetInformationFile(
                                                 FileHandle,
                                                 &ioStatusBlock,
                                                 setInfo,
                                                 setInfoLength,
                                                 InformationLevel
                                                 );
                    REVERT();

                    //
                    // No EAs to deal with.  Set EA error offset to zero.
                    //
                    SmbPutUshort( &Response->EaErrorOffset, 0 );
                }
            }
        }

#ifdef _WIN64
        if( (FileRenameInformation == InformationLevel) && setInfo )
        {
            DEALLOCATE_NONPAGED_POOL( setInfo );
            setInfo = NULL;
        }
#endif

    }

    //
    // Build the output parameter and data structures.  It is basically
    // the same for all info levels reguardless of the completion status.
    //

    Transaction->SetupCount = 0;
    Transaction->ParameterCount = 2;
    Transaction->DataCount = 0;

    return status;

} // SetPathOrFileInformation


SMB_TRANS_STATUS
SrvSmbSetFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set File Information request.  This request arrives
    in a Transaction2 SMB.  Set File Information corresponds to the
    OS/2 DosSetFileInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_SET_FILE_INFORMATION request;
    PRESP_SET_FILE_INFORMATION response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT informationLevel;
    USHORT NtInformationLevel;
    ACCESS_MASK grantedAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_FILE_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Set File Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_SET_FILE_INFORMATION)transaction->InParameters;
    response = (PRESP_SET_FILE_INFORMATION)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_SET_FILE_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_SET_FILE_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetFileInformation: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );
    grantedAccess = rfcb->GrantedAccess;

    status = STATUS_SUCCESS;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:

            if ( transaction->DataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            if ( transaction->DataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->MaxParameterCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write EA access to the file via
            // the specified handle.
            //

            CHECK_FUNCTION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_EA,
                0,
                0,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_BASIC_INFO:

            if ( transaction->DataCount != sizeof( FILE_BASIC_INFORMATION ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

#if     0 // No longer supported
        case SMB_SET_FILE_RENAME_INFO:

            //
            // The data must contain rename information plus a non-zero
            // length name.
            //

            if ( transaction->DataCount <=
                        FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName  ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileRenameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;
#endif

        case SMB_SET_FILE_DISPOSITION_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_DISPOSITION_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileDispositionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_ALLOCATION_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_ALLOCATION_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileAllocationInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_END_OF_FILE_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_END_OF_FILE_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileEndOfFileInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        default:

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbSetFileInformation: invalid info level %ld\n",
                            informationLevel ));
            }
            status = STATUS_OS2_INVALID_LEVEL;

        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;

        } else {

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );
        }

        IF_DEBUG(ERRORS) {
            if ( !NT_SUCCESS(status) ) {
                KdPrint(( "SrvSmbSetFileInformation level %u: IoCheckFunctionAccess "
                            "failed: 0x%X, GrantedAccess: %lx\n",
                            informationLevel, status, grantedAccess ));
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Set the appropriate information about the file.
    //

    status = SetPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 rfcb->Lfcb->FileHandle,
                 (PRESP_SET_PATH_INFORMATION)response
                 );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // SetPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }

    //
    // reset this boolean so that the rfcb will not be cached after client close
    //
    rfcb->IsCacheable = FALSE;
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetFileInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetFileInformation


SMB_TRANS_STATUS
SrvSmbSetPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set Path Information request.  This request arrives
    in a Transaction2 SMB.  Set Path Information corresponds to the
    OS/2 DosSetPathInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PTRANSACTION transaction;
    PREQ_SET_PATH_INFORMATION request;
    USHORT informationLevel;
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    BOOLEAN isUnicode;
    ACCESS_MASK desiredAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_PATH_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SrvSmbSetPathInformation entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_SET_PATH_INFORMATION)transaction->InParameters;
    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch( informationLevel ) {
    case SMB_SET_FILE_ALLOCATION_INFO:
    case SMB_SET_FILE_END_OF_FILE_INFO:
        desiredAccess = FILE_WRITE_DATA;
        break;

    case SMB_SET_FILE_DISPOSITION_INFO:
        desiredAccess = DELETE;
        break;

    case SMB_INFO_SET_EAS:
        desiredAccess = FILE_WRITE_EA;
        break;

    default:
        desiredAccess = FILE_WRITE_ATTRIBUTES;
        break;
    }

    if( desiredAccess != FILE_WRITE_ATTRIBUTES &&
        WorkContext->UsingBlockingThread == 0 ) {

        //
        // We can't process the SMB in a nonblocking thread because this
        // info level requires opening the file, which may be oplocked, so
        // the open operation may block.
        //

        WorkContext->FspRestartRoutine = SrvRestartExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    request = (PREQ_SET_PATH_INFORMATION)transaction->InParameters;

    if ( (transaction->ParameterCount <
            sizeof(REQ_SET_PATH_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_SET_PATH_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, transaction->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            transaction->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: bad path name: %s\n",
                        request->Buffer ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // If the client is trying to operate on the root of the share, reject
    // the request.
    //

    if ( objectName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: attempting to set info on "
                          "share root\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status = STATUS_ACCESS_DENIED;
        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         transaction->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "Opening file %wZ\n", &objectName ));
    }

    //
    // Open the file -- must be opened in order to have a handle to pass
    // to NtSetInformationFile.  We will close it after getting the
    // necessary information.
    //
    // The DosQPathInfo API insures that EAs are written directly to
    // the disk rather than cached, so if EAs are being written, open
    // with FILE_WRITE_THROUGH.  See OS/2 1.2 DCR 581 for more
    // information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 desiredAccess,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                     FILE_SHARE_DELETE,                     // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 transaction->TreeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                         FILE_SHARE_DELETE,                     // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     transaction->TreeConnect->Share
                     );
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( NT_SUCCESS(status) ) {
        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 22, 0 );
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    if ( !NT_SUCCESS( status ) ) {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //
        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: SrvIoCreateFile failed: "
                        "%X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        //
        // Verify the information level and the number of input and output
        // data bytes available.
        //

        BOOLEAN error = FALSE;

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:
            if ( transaction->DataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetPathInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EA_SIZE:
        case SMB_INFO_QUERY_ALL_EAS:
            if ( transaction->DataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetPathInformation: invalid DataCount %ld\n",
                                transaction->MaxParameterCount ));
                }
                error = TRUE;
            }
            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbSetPathInformation: invalid info level %ld\n",
                            informationLevel ));
            }
            error = TRUE;

        }

        if ( error ) {

            //
            // Just return an error condition.
            //

            SrvSetSmbError2( WorkContext, STATUS_OS2_INVALID_LEVEL, TRUE );
            status    = STATUS_OS2_INVALID_LEVEL;
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }
    }

    //
    // Set the appropriate information about the file.
    //

    status = SetPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 fileHandle,
                 (PRESP_SET_PATH_INFORMATION)transaction->OutParameters
                 );

    //
    // Close the file--it was only opened to write the attributes.
    //

    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 35, 0 );
    SrvNtClose( fileHandle, TRUE );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // SetPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetPathInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetPathInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\share.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    share.c

Abstract:

    This module contains routines for adding, deleting, and enumerating
    shared resources.

Author:

    David Treadwell (davidtr) 15-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "share.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvVerifyShare )
#pragma alloc_text( PAGE, SrvFindShare )
#pragma alloc_text( PAGE, SrvRemoveShare )
#pragma alloc_text( PAGE, SrvAddShare )
#pragma alloc_text( PAGE, SrvShareEnumApiHandler )
#endif


PSHARE
SrvVerifyShare (
    IN PWORK_CONTEXT WorkContext,
    IN PSZ ShareName,
    IN PSZ ShareTypeString,
    IN BOOLEAN ShareNameIsUnicode,
    IN BOOLEAN IsNullSession,
    OUT PNTSTATUS Status,
    OUT PUNICODE_STRING ServerName OPTIONAL
    )

/*++

Routine Description:

    Attempts to find a share that matches a given name and share type.

Arguments:

    ShareName - name of share to verify, including the server name.
        (I.e., of the form "\\server\share", as received in the SMB.)

    ShareTypeString - type of the share (A:, LPT1:, COMM, IPC, or ?????).

    ShareNameIsUnicode - if TRUE, the share name is Unicode.

    IsNullSession - Is this the NULL session?

    Status - Reason why this call failed.  Not used if a share is returned.

    ServerName - The servername part of the requested resource.

Return Value:

    A pointer to a share matching the given name and share type, or NULL
    if none exists.

--*/

{
    PSHARE share;
    BOOLEAN anyShareType = FALSE;
    SHARE_TYPE shareType;
    PWCH nameOnly;
    UNICODE_STRING nameOnlyString;
    UNICODE_STRING shareName;

    PAGED_CODE( );

    if( ARGUMENT_PRESENT( ServerName ) ) {
        ServerName->Buffer = NULL;
        ServerName->MaximumLength = ServerName->Length = 0;
    }

    //
    // If the client passed in a malformed type string, then bail out
    //
    if( SrvGetStringLength( ShareTypeString,
                            END_OF_REQUEST_SMB( WorkContext ),
                            FALSE, TRUE ) == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvVerifyShare: Invalid share type length!\n" ));
        }

        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;
    }

    if( SrvGetStringLength( ShareName,
                            END_OF_REQUEST_SMB( WorkContext ),
                            ShareNameIsUnicode, TRUE ) == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvVerifyShare: Invalid share name!\n" ));
        }

        *Status = STATUS_BAD_NETWORK_NAME;
        return NULL;
    }

    //
    // First ensure that the share type string is valid.
    //

    if ( _stricmp( StrShareTypeNames[ShareTypeDisk], ShareTypeString ) == 0 ) {
        shareType = ShareTypeDisk;
    } else if ( _stricmp( StrShareTypeNames[ShareTypePipe], ShareTypeString ) == 0 ) {
        shareType = ShareTypePipe;
    } else if ( _stricmp( StrShareTypeNames[ShareTypePrint], ShareTypeString ) == 0 ) {
        shareType = ShareTypePrint;
    } else if ( _stricmp( StrShareTypeNames[ShareTypeWild], ShareTypeString ) == 0 ) {
        anyShareType = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: Invalid share type: %s\n",
                        ShareTypeString );
        }
        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;
    }

    //
    // If the passed-in server\share combination is not Unicode, convert
    // it to Unicode.
    //

    if ( ShareNameIsUnicode ) {
        ShareName = ALIGN_SMB_WSTR( ShareName );
    }

    if ( !NT_SUCCESS(SrvMakeUnicodeString(
                        ShareNameIsUnicode,
                        &shareName,
                        ShareName,
                        NULL
                        )) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvVerifyShare: Unable to allocate heap for Unicode share name string\n" );
        }
        *Status = STATUS_INSUFF_SERVER_RESOURCES;
        return NULL;
    }

    //
    // Skip past the "\\server\" part of the input string.  If there is
    // no leading "\\", assume that the input string contains the share
    // name only.  If there is a "\\", but no subsequent "\", assume
    // that the input string contains just a server name, and points to
    // the end of that name, thus fabricating a null share name.
    //

    nameOnly = shareName.Buffer;


    if ( (*nameOnly == DIRECTORY_SEPARATOR_CHAR) &&
         (*(nameOnly+1) == DIRECTORY_SEPARATOR_CHAR) ) {

        PWSTR nextSlash;


        nameOnly += 2;
        nextSlash = wcschr( nameOnly, DIRECTORY_SEPARATOR_CHAR );

        if( ShareNameIsUnicode && ARGUMENT_PRESENT( ServerName ) ) {
            ServerName->Buffer = nameOnly;
            ServerName->MaximumLength = ServerName->Length = (USHORT)((nextSlash - nameOnly) * sizeof( WCHAR ));
        }

        if ( nextSlash == NULL ) {
            nameOnly = NULL;
        } else {
            nameOnly = nextSlash + 1;
        }
    }

    RtlInitUnicodeString( &nameOnlyString, nameOnly );

    //
    // Try to match share name against available share names.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &nameOnlyString );

    if ( share == NULL ) {

        RELEASE_LOCK( &SrvShareLock );

        //
        // Perhaps the client is DFS aware.  In this case, see if the DFS
        //  driver can help us out.
        //


        if( ( (anyShareType == TRUE) || (shareType == ShareTypeDisk) ) &&
            SMB_CONTAINS_DFS_NAME( WorkContext )) {

            *Status = DfsFindShareName( &nameOnlyString );

        } else {

            *Status = STATUS_BAD_NETWORK_NAME;

        }

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: Unknown share name: %wZ\n",
                        &nameOnlyString );
        }

        if ( !ShareNameIsUnicode ) {
            RtlFreeUnicodeString( &shareName );
        }

        return NULL;
    }

#if SRVNTVERCHK
    //
    // If we are watching out for old client versions or bad domains, do not allow
    //  it to connect to this share if it is a disk share
    //
    if( WorkContext->Connection &&
        (share->ShareType == ShareTypeDisk || SrvMinNT5ClientIPCToo) &&
        (WorkContext->Connection->PagedConnection->ClientTooOld ||
         (WorkContext->Session && WorkContext->Session->ClientBadDomain) )) {

        //
        // This client may not connect to this share!
        //
        RELEASE_LOCK( &SrvShareLock );

        if ( !ShareNameIsUnicode ) {
            RtlFreeUnicodeString( &shareName );
        }

        *Status = WorkContext->Connection->PagedConnection->ClientTooOld ?
                    STATUS_REVISION_MISMATCH : STATUS_ACCOUNT_RESTRICTION;

        return NULL;
    }
#endif

    //
    // If this is the null session, allow it to connect only to IPC$ or
    // to shares specified in the NullSessionShares list.
    //

    if ( IsNullSession &&
         SrvRestrictNullSessionAccess &&
         ( share->ShareType != ShareTypePipe ) ) {

        BOOLEAN matchFound = FALSE;
        ULONG i;

        ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

        for ( i = 0; SrvNullSessionShares[i] != NULL ; i++ ) {

            if ( _wcsicmp(
                    SrvNullSessionShares[i],
                    nameOnlyString.Buffer
                    ) == 0 ) {

                matchFound = TRUE;
                break;
            }
        }

        RELEASE_LOCK( &SrvConfigurationLock );

        if ( !matchFound ) {

            RELEASE_LOCK( &SrvShareLock );

            IF_DEBUG(ERRORS) {
                SrvPrint0( "SrvVerifyShare: Illegal null session access.\n");
            }

            if ( !ShareNameIsUnicode ) {
                RtlFreeUnicodeString( &shareName );
            }

            *Status = STATUS_ACCESS_DENIED;
            return(NULL);
        }
    }

    if ( !ShareNameIsUnicode ) {
        RtlFreeUnicodeString( &shareName );
    }

    if ( anyShareType || (share->ShareType == shareType) ) {

        //
        // Put share in work context block and reference it.
        //

        SrvReferenceShare( share );

        RELEASE_LOCK( &SrvShareLock );

        WorkContext->Share = share;
        return share;

    } else {

        RELEASE_LOCK( &SrvShareLock );

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: incorrect share type: %s\n",
                        ShareTypeString );
        }

        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;

    }

} // SrvVerifyShare


PSHARE
SrvFindShare (
    IN PUNICODE_STRING ShareName
    )

/*++

Routine Description:

    Attempts to find a share that matches a given name.

    *** This routine must be called with the share lock (SrvShareLock)
        held.

Arguments:

    ShareName - name of share to Find.

Return Value:

    A pointer to a share matching the given name, or NULL if none exists.

--*/

{
    PSHARE share;
    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG hashValue;

    PAGED_CODE( );

    //
    // Try to match share name against available share names.
    //

    COMPUTE_STRING_HASH( ShareName, &hashValue );
    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( hashValue ) ];

    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        share = CONTAINING_RECORD( listEntry, SHARE, GlobalShareList );

        if( share->ShareNameHashValue == hashValue &&
            RtlCompareUnicodeString(
                &share->ShareName,
                ShareName,
                TRUE
                ) == 0 ) {

            //
            // Found a matching share.  If it is active return its
            // address.
            //

            if ( GET_BLOCK_STATE( share ) == BlockStateActive ) {
                return share;
            }
        }
    }

    //
    // Couldn't find a matching share that was active.
    //

    return NULL;

} // SrvFindShare

VOID
SrvRemoveShare(
    PSHARE Share
)
{
    PAGED_CODE();

    RemoveEntryList( &Share->GlobalShareList );
}

VOID
SrvAddShare(
    PSHARE Share
)
{
    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG hashValue;

    PAGED_CODE();

    COMPUTE_STRING_HASH( &Share->ShareName, &hashValue );
    Share->ShareNameHashValue = hashValue;
    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( hashValue ) ];

    InsertTailList( listEntryRoot, &Share->GlobalShareList );
}

NTSTATUS
SrvShareEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    )

/*++

Routine Description:

    All share Enum and GetInfo APIs are handled by this routine in the server
    FSD.  It takes the ResumeHandle in the SRP to find the first
    appropriate share, then calls the passed-in filter routine to check
    if the share should be filled in.  If it should, we call the filter
    routine, then try to get another shar.  This continues until the
    entire list has been walked.

Arguments:

    Srp - a pointer to the SRP for the operation.

    OutputBuffer - the buffer in which to fill output information.

    BufferLength - the length of the buffer.

    FilterRoutine - a pointer to a function that will check a share entry
        against information in the SRP to determine whether the
        information in the share should be placed in the output
        buffer.

    SizeRoutine - a pointer to a function that will find the total size
        a single share will take up in the output buffer.  This routine
        is used to check whether we should bother to call the fill
        routine.

    FillRoutine - a pointer to a function that will fill in the output
        buffer with information from a share.

Return Value:

    NTSTATUS - results of operation.

--*/

{
    PSHARE share;
    ULONG totalEntries;
    ULONG entriesRead;
    ULONG bytesRequired;

    PCHAR fixedStructurePointer;
    PCHAR variableData;
    ULONG blockSize;

    BOOLEAN bufferOverflow = FALSE;
    BOOLEAN entryReturned = FALSE;

    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG oldSkipCount;
    ULONG newResumeKey;

    PAGED_CODE( );

    //
    // Set up local variables.
    //

    fixedStructurePointer = OutputBuffer;
    variableData = fixedStructurePointer + BufferLength;
    variableData = (PCHAR)((ULONG_PTR)variableData & ~1);

    entriesRead = 0;
    totalEntries = 0;
    bytesRequired = 0;

    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( Srp->Parameters.Get.ResumeHandle >> 16 ) ];
    oldSkipCount = Srp->Parameters.Get.ResumeHandle & 0xff;

    ACQUIRE_LOCK_SHARED( &SrvShareLock );

    for( ;
         listEntryRoot < &SrvShareHashTable[ NSHARE_HASH_TABLE ];
         listEntryRoot++, newResumeKey = 0 ) {

        newResumeKey = (ULONG)((listEntryRoot - SrvShareHashTable) << 16);

        for( listEntry = listEntryRoot->Flink;
             listEntry != listEntryRoot;
             listEntry = listEntry->Flink, newResumeKey++ ) {

            if( oldSkipCount ) {
                --oldSkipCount;
                ++newResumeKey;
                continue;
            }

            share = CONTAINING_RECORD( listEntry, SHARE, GlobalShareList );

            //
            // Call the filter routine to determine whether we should
            // return this share.
            //

            if ( FilterRoutine( Srp, share ) ) {

                blockSize = SizeRoutine( Srp, share );

                totalEntries++;
                bytesRequired += blockSize;

                //
                // If all the information in the share will fit in the
                // output buffer, write it.  Otherwise, indicate that there
                // was an overflow.  As soon as an entry doesn't fit, stop
                // putting them in the buffer.  This ensures that the resume
                // mechanism will work--retuning partial entries would make
                // it nearly impossible to use the resumability of the APIs,
                // since the caller would have to resume from an imcomplete
                // entry.
                //

                if ( (ULONG_PTR)fixedStructurePointer + blockSize <=
                         (ULONG_PTR)variableData && !bufferOverflow ) {

                    FillRoutine(
                        Srp,
                        share,
                        (PVOID *)&fixedStructurePointer,
                        (LPWSTR *)&variableData
                        );

                    entriesRead++;
                    newResumeKey++;

                } else {

                    bufferOverflow = TRUE;
                }
            }
        }
    }

    RELEASE_LOCK( &SrvShareLock );

    //
    // Set the information to pass back to the server service.
    //

    Srp->Parameters.Get.EntriesRead = entriesRead;
    Srp->Parameters.Get.TotalEntries = totalEntries;
    Srp->Parameters.Get.TotalBytesNeeded = bytesRequired;

    //
    // Return appropriate status.
    //

    if ( entriesRead == 0 && totalEntries > 0 ) {

        //
        // Not even a single entry fit.
        //

        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;

    } else if ( bufferOverflow ) {

        //
        // At least one entry fit, but not all of them.
        //

        Srp->ErrorCode = ERROR_MORE_DATA;
        Srp->Parameters.Get.ResumeHandle = newResumeKey;
        return STATUS_SUCCESS;

    } else {

        //
        // All entries fit.
        //

        Srp->ErrorCode = NO_ERROR;
        Srp->Parameters.Get.ResumeHandle = 0;
        return STATUS_SUCCESS;
    }

} // SrvEnumApiHandler


NTSTATUS
SrvClearDfsOnShares()
/*++

Routine Description:

    Clears all DFS marks on all shares.  This is called when the DFS service
    is stopping
    
Arguments:

    None
    
Return Value:

    NTSTATUS - results of operation.
    
Notes:

    The SrvShareLock MUST be held across this operation

--*/
{
    PSHARE share;
    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG iteration;

    PAGED_CODE( );

    for( iteration = 0; iteration < NSHARE_HASH_TABLE; iteration ++ )
    {
        listEntryRoot = &SrvShareHashTable[ iteration ];

        for( listEntry = listEntryRoot->Flink;
             listEntry != listEntryRoot;
             listEntry = listEntry->Flink ) {

            share = CONTAINING_RECORD( listEntry, SHARE, GlobalShareList );

            share->IsDfs = share->IsDfsRoot = FALSE;           
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbadmin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbadmin.c

Abstract:

    This module contains routines for processing the administrative SMBs:
    negotiate, session setup, tree connect, and logoff.

Author:

    David Treadwell (davidtr)    30-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "smbadmin.tmh"
#pragma hdrstop

#define ENCRYPT_TEXT_LENGTH 20

VOID
GetEncryptionKey (
    OUT CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH]
    );

VOID SRVFASTCALL
BlockingSessionSetupAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
GetNtSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PCHAR *CasesensitivePassword,
    OUT PULONG CasesensitivePasswordLength,
    OUT PCHAR *CaseInsensitivePassword,
    OUT PULONG CaseInsensitivePasswordLength,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PCHAR *RestOfDataBuffer,
    OUT PULONG RestOfDataLength );

VOID
BuildSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN UCHAR NextCommand,
    IN USHORT Action,
    IN BOOLEAN IsUnicode);

NTSTATUS
GetExtendedSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PUCHAR *SecurityBuffer,
    OUT PULONG SecurityBufferLength,
    OUT PCHAR  *RestOfDataBuffer,
    OUT PULONG RestOfDataLength );

VOID
BuildExtendedSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN ULONG SecurityBlobLength,
    IN NTSTATUS Status,
    IN UCHAR NextCommand,
    IN BOOLEAN IsUnicode);

NTSTATUS
InsertNativeOSAndType(
    IN BOOLEAN IsUnicode,
    OUT PCHAR Buffer,
    IN OUT PUSHORT ByteCount);

//
// EncryptionKeyCount is a monotonically increasing count of the number
// of times GetEncryptionKey has been called.  This number is added to
// the system time to ensure that we do not use the same seed twice in
// generating a random challenge.
//

STATIC
ULONG EncryptionKeyCount = 0;

ULONG SrvKsecValidErrors = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbNegotiate )
#pragma alloc_text( PAGE, SrvSmbProcessExit )
#pragma alloc_text( PAGE, SrvSmbSessionSetupAndX )
#pragma alloc_text( PAGE, BlockingSessionSetupAndX )
#pragma alloc_text( PAGE, SrvSmbLogoffAndX )
#pragma alloc_text( PAGE, GetEncryptionKey )
#pragma alloc_text( PAGE, GetNtSecurityParameters )
#pragma alloc_text( PAGE, BuildSessionSetupAndXResponse )
#pragma alloc_text( PAGE, GetExtendedSecurityParameters )
#pragma alloc_text( PAGE, BuildExtendedSessionSetupAndXResponse )
#pragma alloc_text( PAGE, InsertNativeOSAndType )

#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNegotiate (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a negotiate SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_NEGOTIATE request;
    PRESP_NT_NEGOTIATE ntResponse;
    PRESP_NEGOTIATE response;
    PRESP_OLD_NEGOTIATE respOldNegotiate;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection;
    USHORT byteCount;
    USHORT flags2;
    PSMB_HEADER smbHeader;

    PSZ s, es;
    SMB_DIALECT bestDialect, serverDialect, firstDialect;
    USHORT consumerDialectChosen, consumerDialect;
    LARGE_INTEGER serverTime;
    SMB_DATE date;
    SMB_TIME time;
    ULONG capabilities;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NEGOTIATE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Negotiate request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Negotiate request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up input and output buffers for parameters.
    //

    request = (PREQ_NEGOTIATE)WorkContext->RequestParameters;
    response = (PRESP_NEGOTIATE)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_NEGOTIATE)WorkContext->ResponseParameters;
    smbHeader = WorkContext->RequestHeader;

    //
    // Make sure that this is the first negotiate command sent.
    // SrvStartListen() sets the dialect to illegal, so if it has changed
    // then a negotiate SMB has already been sent.
    //

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;
    endpoint = connection->Endpoint;
    if ( connection->SmbDialect != SmbDialectIllegal ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNegotiate: Command already sent.\n" );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // We don't know anything about the version number of this client yet.
    //
    pagedConnection->ClientBuildNumber = 0;

#if SRVNTVERCHK
    pagedConnection->ClientTooOld = FALSE;
#endif

    //
    // Find out which (if any) of the sent dialect strings matches the
    // dialect strings known by this server.  The ByteCount is verified
    // to be legitimate in SrvProcessSmb, so it is not possible to walk
    // off the end of the SMB here.
    //

    bestDialect = SmbDialectIllegal;
    consumerDialectChosen = (USHORT)0xFFFF;
    es = END_OF_REQUEST_SMB( WorkContext );

    if( endpoint->IsPrimaryName ) {
        firstDialect = FIRST_DIALECT;
    } else {
        firstDialect = FIRST_DIALECT_EMULATED;
    }

    for ( s = (PSZ)request->Buffer, consumerDialect = 0;
          s <= es && s < SmbGetUshort( &request->ByteCount ) + (PSZ)request->Buffer;
          consumerDialect++ ) {

        if ( *s++ != SMB_FORMAT_DIALECT ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbNegotiate: Invalid dialect format code.\n" );
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        for ( serverDialect = firstDialect;
             serverDialect < bestDialect;
             serverDialect++ ) {

            if ( !strncmp( s, StrDialects[serverDialect], es-s+1 ) ) {
                IF_SMB_DEBUG(ADMIN2) {
                    SrvPrint2( "Matched: %s and %s\n",
                                StrDialects[serverDialect], s );
                }

                bestDialect = serverDialect;
                consumerDialectChosen = consumerDialect;
            }
        }

        //
        // Go to the next dialect string
        //
        for( ; *s && s < es; s++ )
            ;

        //
        // We are now at the end of the buffer, or are pointing to the NULL.
        // Advance the pointer.  If we are at the end of the buffer, the test in
        // the loop will terminate.
        //
        s++;
    }

    connection->SmbDialect = bestDialect;

    if( bestDialect <= SmbDialectNtLanMan ) {
        connection->IpxDropDuplicateCount = MIN_IPXDROPDUP;
    } else {
        connection->IpxDropDuplicateCount = MAX_IPXDROPDUP;
    }

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Choosing dialect #%ld, string = %s\n",
                    consumerDialectChosen, StrDialects[bestDialect] );
    }

    //
    //  Determine the current system time on the server.  We use this
    //  to determine the time zone of the server and to tell the client
    //  the current time of day on the server.
    //

    KeQuerySystemTime( &serverTime );

    //
    // If the consumer only knows the core protocol, return short (old)
    // form of the negotiate response.  Also, if no dialect is acceptable,
    // return 0xFFFF as the selected dialect.
    //

    if ( bestDialect == SmbDialectPcNet10 ||
         consumerDialectChosen == (USHORT)0xFFFF ) {

        respOldNegotiate = (PRESP_OLD_NEGOTIATE)response;
        respOldNegotiate->WordCount = 1;
        SmbPutUshort( &respOldNegotiate->DialectIndex, consumerDialectChosen );
        SmbPutUshort( &respOldNegotiate->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            respOldNegotiate,
                                            RESP_OLD_NEGOTIATE,
                                            0
                                            );

    }

    else if ( bestDialect > SmbDialectNtLanMan ) {

        USHORT securityMode;

        //
        // Send the OS/2 LAN Man SMB response.
        //

        WorkContext->ResponseHeader->Flags =
            (UCHAR)(WorkContext->RequestHeader->Flags | SMB_FLAGS_LOCK_AND_READ_OK);

        response->WordCount = 13;
        SmbPutUshort( &response->DialectIndex, consumerDialectChosen );

        //
        // Indicate that we're user-level security and that we
        // want encrypted passwords.
        //

        securityMode = NEGOTIATE_USER_SECURITY | NEGOTIATE_ENCRYPT_PASSWORDS;

        SmbPutUshort(
            &response->SecurityMode,
            securityMode
            );

        //
        // Get an encryption key for this connection.
        //

        GetEncryptionKey( pagedConnection->EncryptionKey );

        SmbPutUshort( &response->EncryptionKeyLength, MSV1_0_CHALLENGE_LENGTH );
        SmbPutUshort( &response->Reserved, 0 );
        byteCount = MSV1_0_CHALLENGE_LENGTH;

        if( response->Buffer + MSV1_0_CHALLENGE_LENGTH > END_OF_RESPONSE_BUFFER(WorkContext) )
        {
            SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
            status    = STATUS_BUFFER_OVERFLOW;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        RtlCopyMemory(
            response->Buffer,
            pagedConnection->EncryptionKey,
            MSV1_0_CHALLENGE_LENGTH
            );

        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;
            ULONG maxBufferSize;

            //
            // Our server max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            maxBufferSize = GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        SrvReceiveBufferLength
                                        );

            SmbPutUshort(
                &response->MaxBufferSize,
                (USHORT)maxBufferSize
                );

        } else {

            SmbPutUshort(
                &response->MaxBufferSize,
                (USHORT)SrvReceiveBufferLength
                );
        }

        SmbPutUshort( &response->MaxMpxCount, MIN(125, SrvMaxMpxCount) );   // Only send max of 125 to Win9x machines since they'll not connect if higher
        SmbPutUshort( &response->MaxNumberVcs, (USHORT)SrvMaxNumberVcs );
        SmbPutUlong( &response->SessionKey, 0 );

        //
        // If this is an MS-NET 1.03 client or before, then tell him that we
        // don't support raw writes.  MS-NET 1.03 does different things with
        // raw writes that are more trouble than they're worth, and since
        // raw is simply a performance issue, we don't support it.
        //

        if ( bestDialect >= SmbDialectMsNet103 ) {

            SmbPutUshort(
                &response->RawMode,
                (USHORT)(SrvEnableRawMode ?
                        NEGOTIATE_READ_RAW_SUPPORTED :
                        0)
                );

        } else {

            SmbPutUshort(
                &response->RawMode,
                (USHORT)(SrvEnableRawMode ?
                        NEGOTIATE_READ_RAW_SUPPORTED |
                        NEGOTIATE_WRITE_RAW_SUPPORTED :
                        0)
                );
        }

        SmbPutUlong( &response->SessionKey, 0 );

        SrvTimeToDosTime( &serverTime, &date, &time );

        SmbPutDate( &response->ServerDate, date );
        SmbPutTime( &response->ServerTime, time );

        //
        // Get time zone bias.  We compute this during session
        // setup  rather than once during server startup because
        // we might switch from daylight time to standard time
        // or vice versa during normal server operation.
        //

        SmbPutUshort( &response->ServerTimeZone,
                      SrvGetOs2TimeZone(&serverTime) );

        if ( bestDialect == SmbDialectLanMan21 ||
             bestDialect == SmbDialectDosLanMan21 ) {

            //
            // Append the domain to the SMB.
            //
            if( response->Buffer + byteCount + endpoint->OemDomainName.Length + sizeof(CHAR) > END_OF_RESPONSE_BUFFER(WorkContext) )
            {
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            RtlCopyMemory(
                response->Buffer + byteCount,
                endpoint->OemDomainName.Buffer,
                endpoint->OemDomainName.Length + sizeof(CHAR)
                );

            byteCount += endpoint->OemDomainName.Length + sizeof(CHAR);

        }

        SmbPutUshort( &response->ByteCount, byteCount );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                              response,
                                              RESP_NEGOTIATE,
                                              byteCount
                                              );

    } else {

        //
        // NT or better protocol has been negotiated.
        //

        flags2 = SmbGetAlignedUshort( &smbHeader->Flags2 );

        //
        // We are going to attempt to validate this user with one of the listed
        // security packages at the end of the smb.  Currently the smb will
        // simply contain the output of EnumerateSecurityPackages.
        //

        if ( flags2 & SMB_FLAGS2_EXTENDED_SECURITY ) {

            if (!WorkContext->UsingExtraSmbBuffer) {
                status = SrvAllocateExtraSmbBuffer(WorkContext);
                if (!NT_SUCCESS(status)) {
                    SrvSetSmbError(WorkContext, status);
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    WorkContext->ResponseHeader,
                    WorkContext->RequestHeader,
                    sizeof( SMB_HEADER )
                    );
            }
            ntResponse = (PRESP_NT_NEGOTIATE)WorkContext->ResponseParameters;
            capabilities = CAP_EXTENDED_SECURITY;
        } else {
            capabilities = 0;
        }

        ntResponse->WordCount = 17;
        SmbPutUshort( &ntResponse->DialectIndex, consumerDialectChosen );

        // !!! This says that we don't want encrypted passwords.

        // If this is negotiating NtLanMan, but not UNICODE, we know its not a Win9x client
        // so it can handle MaxMpx larger than 125
        if( flags2 & SMB_FLAGS2_UNICODE )
        {
            SmbPutUshort( &ntResponse->MaxMpxCount, SrvMaxMpxCount );
        }
        else
        {
            // Again, for the Win9x problems we need to minimize the Mpx count.
            SmbPutUshort( &ntResponse->MaxMpxCount, MIN(125,SrvMaxMpxCount) );
        }
        SmbPutUshort( &ntResponse->MaxNumberVcs, (USHORT)SrvMaxNumberVcs );
        SmbPutUlong( &ntResponse->MaxRawSize, 64 * 1024 ); // !!!
        SmbPutUlong( &ntResponse->SessionKey, 0 );

        capabilities |= CAP_RAW_MODE            |
                       CAP_UNICODE              |
                       CAP_LARGE_FILES          |
                       CAP_NT_SMBS              |
                       CAP_NT_FIND              |
                       CAP_RPC_REMOTE_APIS      |
                       CAP_NT_STATUS            |
                       CAP_LEVEL_II_OPLOCKS     |
                       CAP_INFOLEVEL_PASSTHRU   |
                       CAP_LOCK_AND_READ;

    //
    // Enable LWIO by default.
    //
    capabilities |= CAP_LWIO;

        //
        // If we're supporting Dfs operations, let the client know about it.
        //
        if( SrvDfsFastIoDeviceControl ) {
            capabilities |= CAP_DFS;
        }

        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;
            ULONG maxBufferSize;

            capabilities |= CAP_MPX_MODE;
            capabilities &= ~CAP_RAW_MODE;

            //
            // Our server max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            maxBufferSize = GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        SrvReceiveBufferLength
                                        );

            SmbPutUlong(
                &ntResponse->MaxBufferSize,
                maxBufferSize
                );

        } else {

            SmbPutUlong(
                &ntResponse->MaxBufferSize,
                SrvReceiveBufferLength
                );

            if( !SrvDisableLargeRead )
            {
                capabilities |= CAP_LARGE_READX;
            }

            //
            // Unfortunately, NetBT is the only protocol that reliably supports
            //  transfers exceeding the negotiated buffer size.  So disable the
            //  other protocols for now (hopefully)
            //
            if( !SrvDisableLargeWrite && !connection->Endpoint->IsConnectionless ) {
                capabilities |= CAP_LARGE_WRITEX;
            }
        }

        SmbPutUlong( &ntResponse->Capabilities, capabilities );

        //
        // Stick the servers system time and timezone in the negotiate
        // response.
        //

        SmbPutUlong( &ntResponse->SystemTimeLow, serverTime.LowPart );
        SmbPutUlong( &ntResponse->SystemTimeHigh, serverTime.HighPart );

        SmbPutUshort( &ntResponse->ServerTimeZone,
                      SrvGetOs2TimeZone(&serverTime) );

        //
        // Indicate that we're user-level security and that we
        // want encrypted passwords.
        //

        ntResponse->SecurityMode =
                NEGOTIATE_USER_SECURITY | NEGOTIATE_ENCRYPT_PASSWORDS;

        //
        // There is a bug in some W9x clients that preclude the use of security
        //  signatures.  We have produced a fix for vredir.vxd for this, but we
        //  can not tell whether or not we are working with one of these fixed
        //  clients.  The only way i can think of to tell the difference between
        //  a W9x client and a properly functioning NT client is to look to see
        //  if the client understands NT status codes.
        //
        if( SrvSmbSecuritySignaturesEnabled &&

            ( SrvEnableW9xSecuritySignatures == TRUE ||
              (flags2 & SMB_FLAGS2_NT_STATUS) ) ) {

            ntResponse->SecurityMode |= NEGOTIATE_SECURITY_SIGNATURES_ENABLED;

            if( SrvSmbSecuritySignaturesRequired ) {
                ntResponse->SecurityMode |= NEGOTIATE_SECURITY_SIGNATURES_REQUIRED;
            }
        }

        //
        // Get an encryption key for this connection.
        //

        if ((capabilities & CAP_EXTENDED_SECURITY) == 0) {
            GetEncryptionKey( pagedConnection->EncryptionKey );

            if( response->Buffer + MSV1_0_CHALLENGE_LENGTH > END_OF_RESPONSE_BUFFER(WorkContext) )
            {
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            RtlCopyMemory(
                ntResponse->Buffer,
                pagedConnection->EncryptionKey,
                MSV1_0_CHALLENGE_LENGTH
                );

            ASSERT ( MSV1_0_CHALLENGE_LENGTH <= 0xff ) ;

            ntResponse->EncryptionKeyLength = MSV1_0_CHALLENGE_LENGTH;

            byteCount = MSV1_0_CHALLENGE_LENGTH;

            {
                USHORT domainLength;
                PWCH buffer = (PWCHAR)( ntResponse->Buffer+byteCount );
                PWCH ptr;

                domainLength = endpoint->DomainName.Length +
                                      sizeof(UNICODE_NULL);
                ptr = endpoint->DomainName.Buffer;

                if( (PUCHAR)buffer + domainLength > END_OF_RESPONSE_BUFFER(WorkContext) )
                {
                    SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                    status    = STATUS_BUFFER_OVERFLOW;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    buffer,
                    ptr,
                    domainLength
                    );

                byteCount += domainLength;

                //
                // Append the server name to the response.
                //
                if( SrvComputerName.Buffer ) {

                    buffer = (PWCHAR)((LPSTR)buffer + domainLength);

                    if( (PUCHAR)buffer + SrvComputerName.Length > END_OF_RESPONSE_BUFFER(WorkContext) )
                    {
                        SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                        status    = STATUS_BUFFER_OVERFLOW;
                        SmbStatus = SmbStatusSendResponse;
                        goto Cleanup;
                    }

                    RtlCopyMemory( buffer,
                                   SrvComputerName.Buffer,
                                   SrvComputerName.Length
                                 );

                    SmbPutUshort( &buffer[ SrvComputerName.Length / 2 ], UNICODE_NULL );

                    byteCount += SrvComputerName.Length + sizeof( UNICODE_NULL );
                }

            }

            SmbPutUshort( &ntResponse->ByteCount, byteCount );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  ntResponse,
                                                  RESP_NT_NEGOTIATE,
                                                  byteCount
                                                  );

        } // if !(capabilities & CAP_EXTENDED_SECURITY)
        else {
            CtxtHandle negotiateHandle;
            ULONG bufferLength;
            PCHAR buffer;

            //
            // Reserved if extended security negotiated (MBZ!)
            //

            ntResponse->EncryptionKeyLength = 0;

            //
            // SrvGetExtensibleSecurityNegotiateBuffer will fill in the
            // securityblob field and return the length of that information.
            //

            RtlCopyMemory(&ntResponse->Buffer, &ServerGuid, sizeof(ServerGuid) );
            byteCount = sizeof(ServerGuid);

            buffer = ntResponse->Buffer + byteCount;
            bufferLength = WorkContext->ResponseBuffer->BufferLength - (ULONG)(buffer - (PCHAR)WorkContext->ResponseBuffer->Buffer);

            status = SrvGetExtensibleSecurityNegotiateBuffer(
                                    &negotiateHandle,
                                    buffer,
                                    &bufferLength
                                    );


            if (!NT_SUCCESS(status)) {
                SrvSetSmbError(WorkContext, STATUS_ACCESS_DENIED);
                status    = STATUS_ACCESS_DENIED;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            if( bufferLength > 0xFF00 )
            {
                // byteCount is still a USHORT, so don't accept really really big responses
                // Note we should never get this since our buffer size is never over 64k, but just in case
                SrvSetSmbError(WorkContext, STATUS_ACCESS_DENIED);
                status    = STATUS_ACCESS_DENIED;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // Grab the session locks here...
            //

            ACQUIRE_LOCK( &connection->Lock );

            connection->NegotiateHandle = negotiateHandle;

            RELEASE_LOCK( &connection->Lock );

            byteCount += (USHORT)bufferLength;

            SmbPutUshort( &ntResponse->ByteCount, byteCount );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  ntResponse,
                                                  RESP_NT_NEGOTIATE,
                                                  byteCount
                                                  );
        }
    } // else (NT protocol has been negotiated).

    SmbStatus = SmbStatusSendResponse;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbNegotiate complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNegotiate


SMB_PROCESSOR_RETURN_TYPE
SrvSmbProcessExit (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Process Exit SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_PROCESS_EXIT request;
    PRESP_PROCESS_EXIT response;

    PSESSION session;
    USHORT pid;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_PROCESS_EXIT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Process exit request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Process exit request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up parameters.
    //

    request = (PREQ_PROCESS_EXIT)(WorkContext->RequestParameters);
    response = (PRESP_PROCESS_EXIT)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbProcessExit: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status = STATUS_SMB_BAD_UID;
        goto Cleanup;
    }

    //
    // Close all files with the same PID as in the header for this request.
    //

    pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    IF_SMB_DEBUG(ADMIN1) SrvPrint1( "Closing files with PID = %lx\n", pid );

    SrvCloseRfcbsOnSessionOrPid( session, &pid );

    //
    // Close all searches with the same PID as in the header for this request.
    //

    IF_SMB_DEBUG(ADMIN1) SrvPrint1( "Closing searches with PID = %lx\n", pid );

    SrvCloseSearches(
            session->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnPid,
            (PVOID) pid,
            NULL
            );

    //
    // Close any cached directories for this client
    //
    SrvCloseCachedDirectoryEntries( session->Connection );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_PROCESS_EXIT,
                                          0
                                          );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbProcessExit


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSessionSetupAndX(
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a session setup and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SESSION_SETUP_AND_X;
    SrvWmiStartContext(WorkContext);

    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingSessionSetupAndX;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbSessionSetupAndX


VOID SRVFASTCALL
BlockingSessionSetupAndX(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes a session setup and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_SESSION_SETUP_ANDX request;
    PREQ_NT_SESSION_SETUP_ANDX ntRequest;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedRequest;
    PRESP_SESSION_SETUP_ANDX response;

    NTSTATUS SecStatus ;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_ENTRY entry;
    LUID logonId;
    SHORT uidIndex;
    USHORT reqAndXOffset;
    UCHAR nextCommand;
    PCHAR smbInformation;
    ULONG smbInformationLength;
    ULONG returnBufferLength = 0;
    UNICODE_STRING nameString;
    UNICODE_STRING domainString;
    USHORT action = 0;
    USHORT byteCount;
    BOOLEAN locksHeld;
    BOOLEAN isUnicode, isExtendedSecurity;
    BOOLEAN smbSecuritySignatureRequired = FALSE;
    BOOLEAN previousSecuritySignatureState;

    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SESSION_SETUP_AND_X;
    SrvWmiStartContext(WorkContext);

    //
    // If the connection has closed (timed out), abort.
    //

    connection = WorkContext->Connection;

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvSmbSessionSetupAndX: Connection closing\n" );
        }

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;

    }

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Session setup request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Session setup request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Initialize local variables for error cleanup.
    //

    nameString.Buffer = NULL;
    domainString.Buffer = NULL;
    session = NULL;
    locksHeld = FALSE;
    isExtendedSecurity = FALSE;

    //
    // Set up parameters.
    //

    request = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    ntRequest = (PREQ_NT_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    ntExtendedRequest = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_SESSION_SETUP_ANDX)(WorkContext->ResponseParameters);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    previousSecuritySignatureState = connection->SmbSecuritySignatureActive;

    //
    // First verify that the SMB format is correct.
    //

    if ( (connection->SmbDialect <= SmbDialectNtLanMan &&
         (!((request->WordCount == 13) ||
            ((request->WordCount == 12) &&
             ((ntExtendedRequest->Capabilities & CAP_EXTENDED_SECURITY) != 0))))) ||
         (connection->SmbDialect > SmbDialectNtLanMan &&
                                          request->WordCount != 10 )   ||
         (connection->SmbDialect == SmbDialectIllegal ) ) {

        //
        // The SMB word count is invalid.
        //

        IF_DEBUG(SMB_ERRORS) {

            if ( connection->SmbDialect == SmbDialectIllegal ) {

                SrvPrint1("BlockingSessionSetupAndX: Client %z is using an "
                "illegal dialect.\n", (PCSTRING)&connection->OemClientMachineNameString );
            }
        }
        status = STATUS_INVALID_SMB;
        goto error_exit1;
    }

    //
    // Convert the client name to unicode
    //

    if ( connection->ClientMachineNameString.Length == 0 ) {

        UNICODE_STRING clientMachineName;
        clientMachineName.Buffer = connection->ClientMachineName;
        clientMachineName.MaximumLength =
                        (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

        (VOID)RtlOemStringToUnicodeString(
                        &clientMachineName,
                        &connection->OemClientMachineNameString,
                        FALSE
                        );

        //
        // Add the double backslashes to the length
        //

        connection->ClientMachineNameString.Length =
                        (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

    }

    //
    // If this is LanMan 2.1 or better, the session setup response may
    // be longer than the request.  Allocate an extra SMB buffer.  The
    // buffer is freed after we have finished sending the SMB response.
    //
    // !!! Try to be smarter before grabbing the extra buffer.
    //

    if ( connection->SmbDialect <= SmbDialectDosLanMan21 &&
                                    !WorkContext->UsingExtraSmbBuffer) {

        status = SrvAllocateExtraSmbBuffer( WorkContext );
        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

        response = (PRESP_SESSION_SETUP_ANDX)(WorkContext->ResponseParameters);

        RtlCopyMemory(
            WorkContext->ResponseHeader,
            WorkContext->RequestHeader,
            sizeof( SMB_HEADER )
            );
    }

    //
    // Get the client capabilities
    //

    if ( connection->SmbDialect <= SmbDialectNtLanMan ) {

        if (ntRequest->WordCount == 13) {

            connection->ClientCapabilities =
                SmbGetUlong( &ntRequest->Capabilities ) &
                                        ( CAP_UNICODE |
                                          CAP_LARGE_FILES |
                                          CAP_NT_SMBS |
                                          CAP_NT_FIND |
                                          CAP_NT_STATUS |
                                          CAP_DYNAMIC_REAUTH |
                                          CAP_EXTENDED_SECURITY |
                                          CAP_LEVEL_II_OPLOCKS );

        } else {

            connection->ClientCapabilities =
                SmbGetUlong( &ntExtendedRequest->Capabilities ) &
                                        ( CAP_UNICODE |
                                          CAP_LARGE_FILES |
                                          CAP_NT_SMBS |
                                          CAP_NT_FIND |
                                          CAP_NT_STATUS |
                                          CAP_DYNAMIC_REAUTH |
                                          CAP_EXTENDED_SECURITY |
                                          CAP_LEVEL_II_OPLOCKS );

        }

        if ( connection->ClientCapabilities & CAP_NT_SMBS ) {
            connection->ClientCapabilities |= CAP_NT_FIND;
        }
    }

    //
    // See if the client is requesting the use of SMB security signatures
    //
    if( SrvSmbSecuritySignaturesEnabled == TRUE &&
        connection->Endpoint->IsConnectionless == FALSE &&
        connection->SmbSecuritySignatureActive == FALSE &&
        ( SrvSmbSecuritySignaturesRequired == TRUE ||
        (WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_SMB_SECURITY_SIGNATURE)) ) {

        smbSecuritySignatureRequired = TRUE;

    } else {

        smbSecuritySignatureRequired = FALSE;

    }

    //
    // Figure out what kind of security to use, use it to validate the
    // session setup request, and construct the session if request checks out.
    //

    isExtendedSecurity = CLIENT_CAPABLE_OF( EXTENDED_SECURITY, connection );

    if( isExtendedSecurity ) {
        USHORT flags2;

        flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );
        isExtendedSecurity = ((flags2 & SMB_FLAGS2_EXTENDED_SECURITY) != 0);
    }

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ((connection->SmbDialect <= SmbDialectNtLanMan) && isExtendedSecurity) {
        //
        // We are validating a client using extended security.  This meansthat
        //  there may be multiple round-trips necessary for the SessionSetup&X
        //  SMB.  Each request and response carries a "security blob", which is
        //  fed into the security system.  The security system may generate
        //  a new blob which is transmitted to the other end.  This exchange
        //  may require an arbitrary number of round trips.
        //

        PUCHAR securityBuffer;
        ULONG securityBufferLength;

        PRESP_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedResponse =
                (PRESP_NT_EXTENDED_SESSION_SETUP_ANDX)( WorkContext->ResponseParameters );

        //
        // No AndX is permitted with extended security logons
        //
        if( request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ) {

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "No follow-on command allowed for extended SS&X\n" ));
            }

            status = STATUS_INVALID_SMB;

        } else {

            //
            // Clean up old dead connections from this client
            //
            if( SmbGetUshort( &ntRequest->VcNumber ) == 0 ) {
                SrvCloseConnectionsFromClient( connection, FALSE );
            }

            status = GetExtendedSecurityParameters(
                        WorkContext,
                        &securityBuffer,
                        &securityBufferLength,
                        &smbInformation,
                        &smbInformationLength );
        }

        if (NT_SUCCESS(status)) {

            USHORT Uid = SmbGetAlignedUshort(&WorkContext->RequestHeader->Uid);

            //
            // Let's see if we have a session with this UID already around.
            //
            if( Uid ) {

                session = SrvVerifyUid ( WorkContext, Uid );

                if( session != NULL ) {
                    //
                    // This is an attempt to either refresh the UID, or we are
                    // in the middle of an extended security negotiation.
                    //

                    ACQUIRE_LOCK( &connection->Lock );

                    if( session->LogonSequenceInProgress == FALSE ) {
                        //
                        // We are just beginning to start the refresh
                        // of the UID.
                        //
                        session->LogonSequenceInProgress = TRUE;
                        session->IsAdmin = FALSE;
                        session->IsSessionExpired = TRUE;
                        status = SrvFreeSecurityContexts( session );

                        //
                        // Reduce the session count, as it will be incremented if authentication succeeds
                        //
                        ExInterlockedAddUlong(
                              &SrvStatistics.CurrentNumberOfSessions,
                              -1,
                              &GLOBAL_SPIN_LOCK(Statistics)
                              );
                    }

                    RELEASE_LOCK( &connection->Lock );

                } else {
                    //
                    // We don't know anything about the UID which
                    //  the client gave to us.
                    //
                    status = STATUS_SMB_BAD_UID;
                }

            } else {
                //
                // This is the first SS&X for this user id
                //
                SrvAllocateSession( &session, NULL, NULL );
                if( session == NULL ) {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                }
            }

            if( session != NULL ) {

                PSECURITY_CONTEXT SecurityContext = NULL;
                BOOL bNewContext = FALSE;

                //
                // Validate the security buffer sent from the client.  Note that
                //  this may change the UserHandle value, so we need to own
                //  the connection lock.
                //

                ACQUIRE_LOCK( &connection->Lock );

                if( session->LogonSequenceInProgress &&
                    session->SecurityContext != NULL )
                {
                    SecurityContext = session->SecurityContext;
                }
                else
                {
                    SecurityContext = SrvAllocateSecurityContext();
                    bNewContext = TRUE;
                }

                if( SecurityContext == NULL )
                {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                    RELEASE_LOCK( &connection->Lock );
                }
                else
                {
                    //
                    // Try to authenticate this user.  If we get NT_SUCCESS(), then
                    //  the user is fully authenticated. If we get
                    //  STATUS_NOT_MORE_PROCESSING_REQUIRED, then things are going well,
                    //  but we need to do some more exchanges with the client before
                    //  authentication is complete. Anything else is an error
                    //

                    returnBufferLength = WorkContext->ResponseBuffer->BufferLength -
                                         PTR_DIFF(ntExtendedResponse->Buffer,
                                                  WorkContext->ResponseBuffer->Buffer);

                    status = SrvValidateSecurityBuffer(
                                WorkContext->Connection,
                                &SecurityContext->UserHandle,
                                session,
                                securityBuffer,
                                securityBufferLength,
                                smbSecuritySignatureRequired,
                                ntExtendedResponse->Buffer,
                                &returnBufferLength,
                                &session->LogOffTime,
                                session->NtUserSessionKey,
                                &session->LogonId,
                                &session->GuestLogon
                                );

                    SecStatus = KSecValidateBuffer(
                                    ntExtendedResponse->Buffer,
                                    returnBufferLength );

                    if ( !NT_SUCCESS( SecStatus ) ) {
    #if DBG
                        KdPrint(( "SRV: invalid buffer from KsecDD: %p,%lx\n",
                            ntExtendedResponse->Buffer, returnBufferLength ));
    #endif
                        SrvKsecValidErrors++;
                    }

                    if( !NT_SUCCESS(status) &&
                        (status != STATUS_MORE_PROCESSING_REQUIRED) )
                    {
                        if( bNewContext ) SrvDereferenceSecurityContext( SecurityContext );
                    }
                    else
                    {
                        if( bNewContext ) {
                            SrvReplaceSessionSecurityContext( session, SecurityContext, WorkContext );
                        }
                        session->IsAdmin = SrvIsAdmin( session->SecurityContext->UserHandle );
                        session->IsNullSession = SrvIsNullSession( session->SecurityContext->UserHandle );
                    }

                    RELEASE_LOCK( &connection->Lock );

                    if( NT_SUCCESS(status) ) {
                        //
                        // This client is now fully authenticated!
                        //
                        session->KickOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
                        session->EncryptedLogon = TRUE;
                        session->LogonSequenceInProgress = FALSE;
                        session->IsSessionExpired = FALSE;

                        if( session->IsNullSession ) {
                            session->LogOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
                        }

    #if SRVNTVERCHK
                        //
                        // If we are restricting the domains of our clients, grab the
                        //  domain string of this client and compare against the list.
                        //  If the client is in the list, set the flag that disallows
                        //  access to disk shares.
                        //
                        if( SrvInvalidDomainNames != NULL ) {
                            if( domainString.Buffer == NULL ) {
                                SrvGetUserAndDomainName( session, NULL, &domainString );
                            }

                            ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );
                            if( SrvInvalidDomainNames != NULL && domainString.Buffer != NULL ) {
                                int i;
                                for( i = 0; SrvInvalidDomainNames[i]; i++ ) {
                                    if( _wcsicmp( SrvInvalidDomainNames[i],
                                                  domainString.Buffer
                                                ) == 0 ) {

                                        session->ClientBadDomain = TRUE;
                                        break;
                                    }
                                }
                            }
                            RELEASE_LOCK( &SrvConfigurationLock );
                        }
    #endif
                    } else {
                        if( status == STATUS_MORE_PROCESSING_REQUIRED ) {
                            session->LogonSequenceInProgress = TRUE;
                        }
                    }
                }
            }
        }

    } else {

        PCHAR caseInsensitivePassword;
        CLONG caseInsensitivePasswordLength;
        PCHAR caseSensitivePassword;
        CLONG caseSensitivePasswordLength;

        status = GetNtSecurityParameters(
                    WorkContext,
                    &caseSensitivePassword,
                    &caseSensitivePasswordLength,
                    &caseInsensitivePassword,
                    &caseInsensitivePasswordLength,
                    &nameString,
                    &domainString,
                    &smbInformation,
                    &smbInformationLength );

        if (NT_SUCCESS(status)) {

            PSECURITY_CONTEXT SecurityContext = SrvAllocateSecurityContext();
            if( SecurityContext != NULL )
            {
                SrvAllocateSession( &session, &nameString, &domainString );

                if( session != NULL ) {

                    status = SrvValidateUser(
                                        &SecurityContext->UserHandle,
                                        session,
                                        WorkContext->Connection,
                                        &nameString,
                                        caseInsensitivePassword,
                                        caseInsensitivePasswordLength,
                                        caseSensitivePassword,
                                        caseSensitivePasswordLength,
                                        smbSecuritySignatureRequired,
                                        &action
                                        );

                    if( NT_SUCCESS(status) )
                    {
                        ACQUIRE_LOCK( &connection->Lock );
                        SrvReplaceSessionSecurityContext( session, SecurityContext, WorkContext );
                        RELEASE_LOCK( &connection->Lock );
                    }
                    else
                    {
                        SrvDereferenceSecurityContext( SecurityContext );
                    }

                } else {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                    SrvDereferenceSecurityContext( SecurityContext );
                }
            }
            else
            {
                status = STATUS_INSUFF_SERVER_RESOURCES;
            }

        }
    }

    //
    // Done with the name strings - they were captured into the session
    // structure if needed.
    //

    if (!isUnicode || isExtendedSecurity) {

        if (nameString.Buffer != NULL) {
            RtlFreeUnicodeString( &nameString );
            nameString.Buffer = NULL;
        }

        if (domainString.Buffer != NULL) {
            RtlFreeUnicodeString( &domainString );
            domainString.Buffer = NULL;
        }
    }

    //
    // If a bad name/password combination was sent, return an error.
    //
    if ( !NT_SUCCESS(status) && status != STATUS_MORE_PROCESSING_REQUIRED ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "BlockingSessionSetupAndX: Bad user/password combination.\n" );
        }

        SrvStatistics.LogonErrors++;

        goto error_exit;

    }

    if( previousSecuritySignatureState == FALSE &&
        connection->SmbSecuritySignatureActive == TRUE ) {

        //
        // We have 'turned on' SMB security signatures.  Make sure that the
        //  signature for the Session Setup & X is correct
        //

        //
        // The client's index was 0
        //
        WorkContext->SmbSecuritySignatureIndex = 0;

        //
        // Our response index is 1
        //
        WorkContext->ResponseSmbSecuritySignatureIndex = 1;

        //
        // And the next request should be index 2
        //
        connection->SmbSecuritySignatureIndex = 2;
    }

    //
    // If we have a new session, fill in the remaining required information.  We
    //  may be operating on an already existing session if we are in the middle
    //  of a multi-round-trip extended security blob exchange, or if we are
    //  renewing a session.
    //
    if ( WorkContext->Session == NULL ) {

         if( connection->SmbDialect <= SmbDialectDosLanMan21 ) {

            ACQUIRE_LOCK( &connection->Lock );

            if ( connection->ClientOSType.Buffer == NULL ) {

                ULONG length;
                PWCH infoBuffer;

                //
                // If the SMB buffer is ANSI, adjust the size of the buffer we
                // are allocating to Unicode size.
                //

                if ( isUnicode ) {
                    smbInformation = ALIGN_SMB_WSTR(smbInformation);
                }

                length = isUnicode ? smbInformationLength : smbInformationLength * sizeof( WCHAR );
                infoBuffer = ALLOCATE_NONPAGED_POOL(
                                length,
                                BlockTypeDataBuffer );

                if ( infoBuffer == NULL ) {
                    RELEASE_LOCK( &connection->Lock );
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                    goto error_exit;
                }

                connection->ClientOSType.Buffer = (PWCH)infoBuffer;
                connection->ClientOSType.MaximumLength = (USHORT)length;

                //
                // Copy the client OS type to the new buffer.
                //

                length = SrvGetString(
                             &connection->ClientOSType,
                             smbInformation,
                             END_OF_REQUEST_SMB( WorkContext ),
                             isUnicode
                             );

                if ( length == (USHORT)-1) {
                    connection->ClientOSType.Buffer = NULL;
                    RELEASE_LOCK( &connection->Lock );
                    DEALLOCATE_NONPAGED_POOL( infoBuffer );
                    status =  STATUS_INVALID_SMB;
                    goto error_exit;
                }

                smbInformation += length + sizeof( WCHAR );

                connection->ClientLanManType.Buffer = (PWCH)(
                                (PCHAR)connection->ClientOSType.Buffer +
                                connection->ClientOSType.Length +
                                sizeof( WCHAR ) );

                connection->ClientLanManType.MaximumLength =
                                    connection->ClientOSType.MaximumLength -
                                    connection->ClientOSType.Length -
                                    sizeof( WCHAR );

                //
                // Copy the client LAN Manager type to the new buffer.
                //

                length = SrvGetString(
                             &connection->ClientLanManType,
                             smbInformation,
                             END_OF_REQUEST_SMB( WorkContext ),
                             isUnicode
                             );

                if ( length == (USHORT)-1) {
                    connection->ClientOSType.Buffer = NULL;
                    RELEASE_LOCK( &connection->Lock );
                    DEALLOCATE_NONPAGED_POOL( infoBuffer );
                    status = STATUS_INVALID_SMB;
                    goto error_exit;
                }

                //
                // If we have an NT5 or later client, grab the build number from the
                //   OS version string.
                //
                if( isExtendedSecurity &&
                    connection->ClientOSType.Length &&
                    connection->PagedConnection->ClientBuildNumber == 0 ) {

                    PWCHAR pdigit = connection->ClientOSType.Buffer;
                    PWCHAR epdigit = pdigit + connection->ClientOSType.Length/sizeof(WCHAR);
                    ULONG clientBuildNumber = 0;

                    //
                    // Scan the ClientOSType string to find the last number, and
                    //  convert to a ULONG.  It should be the build number
                    //
                    while( 1 ) {
                        //
                        // Scan the string until we find a number.
                        //
                        for( ; pdigit < epdigit; pdigit++ ) {
                            if( *pdigit >= L'0' && *pdigit <= L'9' ) {
                                break;
                            }
                        }

                        //
                        // If we've hit the end of the string, we are done
                        //
                        if( pdigit == epdigit ) {
                            break;
                        }

                        clientBuildNumber = 0;

                        //
                        // Convert the number to a ULONG, assuming it is the build number
                        //
                        while( pdigit < epdigit && *pdigit >= L'0' && *pdigit <= '9' ) {
                            clientBuildNumber *= 10;
                            clientBuildNumber += (*pdigit++ - L'0');
                        }
                    }

                    connection->PagedConnection->ClientBuildNumber = clientBuildNumber;

#if SRVNTVERCHK
                    if( SrvMinNT5Client > 0 ) {

                        BOOLEAN allowThisClient = FALSE;
                        DWORD i;

                        //
                        // See if we should allow this client, because it is a well-known
                        // IP address.  This is to allow the build lab to more slowly upgrade
                        // than the rest of us.
                        //
                        if( connection->ClientIPAddress != 0 &&
                            connection->Endpoint->IsConnectionless == FALSE ) {

                            for( i = 0; SrvAllowIPAddress[i]; i++ ) {
                                if( SrvAllowIPAddress[i] == connection->ClientIPAddress ) {
                                    allowThisClient = TRUE;
                                    break;
                                }
                            }
                        }

                        if( allowThisClient == FALSE &&
                            connection->PagedConnection->ClientBuildNumber < SrvMinNT5Client ) {
                                connection->PagedConnection->ClientTooOld = TRUE;
                        }
                    }
#endif
                }
            }
            RELEASE_LOCK( &connection->Lock );
        }

        //
        // If using uppercase pathnames, indicate in the session block.  DOS
        // always uses uppercase paths.
        //

        if ( (WorkContext->RequestHeader->Flags &
                  SMB_FLAGS_CANONICALIZED_PATHS) != 0 ||
                                IS_DOS_DIALECT( connection->SmbDialect ) ) {
            session->UsingUppercasePaths = TRUE;
        } else {
            session->UsingUppercasePaths = FALSE;
        }

        //
        // Enter data from request SMB into the session block.  If MaxMpx is 1
        // disable oplocks on this connection.
        //

        endpoint = connection->Endpoint;
        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;

            //
            // Our session max buffer size is the smaller of the
            // client buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            session->MaxBufferSize =
                    (USHORT)GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        (ULONG)SmbGetUshort(&request->MaxBufferSize)
                                        );

        } else {

            session->MaxBufferSize = SmbGetUshort( &request->MaxBufferSize );
        }

        //
        // Make sure the MaxBufferSize is correctly sized
        //
        session->MaxBufferSize &= ~03;

        if( session->MaxBufferSize < SrvMinClientBufferSize ) {
            //
            // Client asked for a buffer size that is too small!
            //
            IF_DEBUG(ERRORS) {
                KdPrint(( "BlockingSessionSetupAndX: Bad Client Buffer Size: %u\n",
                    session->MaxBufferSize ));
            }
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        session->MaxMpxCount = SmbGetUshort( &request->MaxMpxCount );

        if ( session->MaxMpxCount < 2 ) {
            connection->OplocksAlwaysDisabled = TRUE;
        }
    }

    //
    // If we have completely authenticated the client, and the client thinks
    // that it is the first user on this connection, get rid of other
    // connections (may be due to rebooting of client).  Also get rid of other
    // sessions on this connection with the same user name--this handles a
    // DOS "weirdness" where it sends multiple session setups if a tree connect
    // fails.
    //
    // *** If VcNumber is non-zero, we do nothing special.  This is the
    //     case even though the SrvMaxVcNumber configurable variable
    //     should always be equal to one.  If a second VC is established
    //     between machines, a new session must also be established.
    //     This duplicates the LM 2.0 server's behavior.
    //

    if( isExtendedSecurity == FALSE &&
        NT_SUCCESS( status ) &&
        SmbGetUshort( &request->VcNumber ) == 0 ) {

        UNICODE_STRING userName;

        SrvCloseConnectionsFromClient( connection, FALSE );

        //
        // If a client is smart enough to use extended security, then it
        //  is presumably smart enough to know what it wants to do with
        //  its sessions.  So don't just blow off sessions from this client.
        //
        SrvGetUserAndDomainName( session, &userName, NULL );

        if( userName.Buffer ) {
            SrvCloseSessionsOnConnection( connection, &userName );
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }
    }

    if( WorkContext->Session == NULL ) {

        //
        // Making a new session visible is a multiple-step operation.  It
        // must be inserted in the global ordered tree connect list and the
        // containing connection's session table, and the connection must be
        // referenced.  We need to make these operations appear atomic, so
        // that the session cannot be accessed elsewhere before we're done
        // setting it up.  In order to do this, we hold all necessary locks
        // the entire time we're doing the operations.  The first operation
        // is protected by the global ordered list lock
        // (SrvOrderedListLock), while the other operations are protected by
        // the per-connection lock.  We take out the ordered list lock
        // first, then the connection lock.  This ordering is required by
        // lock levels (see lock.h).
        //

        ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );
        ACQUIRE_LOCK( SrvSessionList.Lock );

        ACQUIRE_LOCK( &connection->Lock );

        locksHeld = TRUE;

        //
        // Ready to try to find a UID for the session.  Check to see if the
        // connection is being closed, and if so, terminate this operation.
        //

        if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

            IF_DEBUG(ERRORS) {
                SrvPrint0( "BlockingSessionSetupAndX: Connection closing\n" );
            }

            status = STATUS_INVALID_PARAMETER;
            goto error_exit;

        }

        //
        // If this client speaks a dialect above LM 1.0, find a UID that can
        // be used for this session.  Otherwise, just use location 0 of the
        // table because those clients will not send a UID in SMBs and they
        // can have only one session.
        //

        if ( connection->SmbDialect < SmbDialectLanMan10 ) {
            NTSTATUS TableStatus;

            if ( pagedConnection->SessionTable.FirstFreeEntry == -1
                 &&
                 SrvGrowTable(
                     &pagedConnection->SessionTable,
                     SrvInitialSessionTableSize,
                     SrvMaxSessionTableSize,
                     &TableStatus ) == FALSE
               ) {

                //
                // No free entries in the user table.  Reject the request.
                //

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "BlockingSessionSetupAndX: No more UIDs available.\n" );
                }

                if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
                {
                    // The table size is being exceeded, log an error
                    SrvLogTableFullError( SRV_TABLE_SESSION );
                    status = STATUS_SMB_TOO_MANY_UIDS;
                }
                else
                {
                    // Memory allocation error, report it
                    status = TableStatus;
                }

                goto error_exit;

            }

            uidIndex = pagedConnection->SessionTable.FirstFreeEntry;

        } else {          // if ( dialect < SmbDialectLanMan10 )

            //
            // If this client already has a session at this server, abort.
            // The session should have been closed by the call to
            // SrvCloseSessionsOnConnection above.  (We could try to work
            // around the existence of the session by closing it, but that
            // would involve releasing the locks, closing the session, and
            // retrying.  This case shouldn't happen.)
            //

            if ( pagedConnection->SessionTable.Table[0].Owner != NULL ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "BlockingSessionSetupAndX: Core client already has session.\n" );
                }

                status = STATUS_SMB_TOO_MANY_UIDS;
                goto error_exit;
            }

            //
            // Use location 0 of the session table.
            //

            IF_SMB_DEBUG(ADMIN2) {
                SrvPrint0( "Client LM 1.0 or before--using location 0 of session table.\n" );
            }

            uidIndex = 0;

        }

        //
        // Remove the UID slot from the free list and set its owner and
        // sequence number.  Create a UID for the session.  Increment count
        // of sessions.
        //

        entry = &pagedConnection->SessionTable.Table[uidIndex];

        pagedConnection->SessionTable.FirstFreeEntry = entry->NextFreeEntry;
        DEBUG entry->NextFreeEntry = -2;
        if ( pagedConnection->SessionTable.LastFreeEntry == uidIndex ) {
            pagedConnection->SessionTable.LastFreeEntry = -1;
        }

        INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        if ( uidIndex == 0 && entry->SequenceNumber == 0 ) {
            INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        }
        session->Uid = MAKE_UID( uidIndex, entry->SequenceNumber );

        entry->Owner = session;

        connection->CurrentNumberOfSessions++;

        IF_SMB_DEBUG(ADMIN1) {
            SrvPrint2( "Found UID.  Index = 0x%lx, sequence = 0x%lx\n",
                        UID_INDEX( session->Uid ),
                        UID_SEQUENCE( session->Uid ) );
        }

        //
        // Insert the session on the global session list.
        //

        SrvInsertEntryOrderedList( &SrvSessionList, session );

        //
        // Reference the connection block to account for the new session.
        //

        SrvReferenceConnection( connection );
        session->Connection = connection;

        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // Session successfully created.  Insert the session in the global
        // list of active sessions.  Remember its address in the work
        // context block.
        //
        // *** Note that the reference count on the session block is
        //     initially set to 2, to allow for the active status on the
        //     block and the pointer that we're maintaining.  In other
        //     words, this is a referenced pointer, and the pointer must be
        //     dereferenced when processing of this SMB is complete.
        //

        WorkContext->Session = session;
    }

    //
    // Build response SMB, making sure to save request fields first in
    // case the response overwrites the request.  Save the
    // newly-assigned UID in both the request SMB and the response SMB
    // so that subsequent command processors and the client,
    // respectively, can see it.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Uid, session->Uid );
    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Uid, session->Uid );

    if (isExtendedSecurity) {

        BuildExtendedSessionSetupAndXResponse(
            WorkContext,
            returnBufferLength,
            status,
            nextCommand,
            isUnicode);

    } else {

        BuildSessionSetupAndXResponse(
            WorkContext,
            nextCommand,
            action,
            isUnicode);

    }

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_TREE_CONNECT_ANDX:
    case SMB_COM_OPEN:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_CREATE:
    case SMB_COM_CREATE_NEW:
    case SMB_COM_CREATE_DIRECTORY:
    case SMB_COM_DELETE:
    case SMB_COM_DELETE_DIRECTORY:
    case SMB_COM_FIND:
    case SMB_COM_FIND_UNIQUE:
    case SMB_COM_COPY:
    case SMB_COM_RENAME:
    case SMB_COM_NT_RENAME:
    case SMB_COM_CHECK_DIRECTORY:
    case SMB_COM_QUERY_INFORMATION:
    case SMB_COM_SET_INFORMATION:
    case SMB_COM_QUERY_INFORMATION_SRV:
    case SMB_COM_OPEN_PRINT_FILE:
    case SMB_COM_GET_PRINT_QUEUE:
    case SMB_COM_TRANSACTION:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "BlockingSessionSetupAndX: Illegal followon command: "
                        "0x%lx\n", nextCommand );
        }

        status = STATUS_INVALID_SMB;
        goto error_exit1;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SrvProcessSmb( WorkContext );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;

    }

    IF_DEBUG(TRACE2) SrvPrint0( "BlockingSessionSetupAndX complete.\n" );
    goto normal_exit;

error_exit:

    if ( locksHeld ) {
        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );
    }

    if ( session != NULL ) {
        if( WorkContext->Session ) {
            //
            // A re-validation of the session failed, or the extended exchange
            //  of security blobs failed.  Get rid of this user.
            //

            SrvCloseSession( session );

            SrvStatistics.SessionsLoggedOff++;

            //
            // Dereference the session, since it's no longer valid
            //
            SrvDereferenceSession( session );

            WorkContext->Session = NULL;

        } else {

            SrvFreeSession( session );
        }
    }

    if ( !isUnicode ) {
        if ( domainString.Buffer != NULL ) {
            RtlFreeUnicodeString( &domainString );
        }
        if ( nameString.Buffer != NULL ) {
            RtlFreeUnicodeString( &nameString );
        }
    }

error_exit1:

    SrvSetSmbError( WorkContext, status );

normal_exit:
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingSessionSetupAndX


NTSTATUS
GetExtendedSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PUCHAR *SecurityBuffer,
    OUT PULONG SecurityBufferLength,
    OUT PCHAR  *RestOfDataBuffer,
    OUT PULONG RestOfDataLength)

/*++

Routine Description:

    Extracts the extensible security parameters from an extended session
    setup and X SMB.

Arguments:

    WorkContext - Context of the SMB

    SecurityBuffer - On return, points to the security buffer inside the
        extended session setup and X SMB

    SecurityBufferLength - On return, size in bytes of SecurityBuffer.

    RestOfDataBuffer - On return, points just past the security buffer

    ResetOfDataLength - On return, size in bytes of *RestOfDataBuffer

Return Value:

    STATUS_SUCCESS - This routine merely returns pointers within an SMB

--*/


{
    NTSTATUS status;
    PCONNECTION connection;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedRequest;
    ULONG maxlength;

    connection = WorkContext->Connection;
    ASSERT( connection->SmbDialect <= SmbDialectNtLanMan );

    ntExtendedRequest = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)
                            (WorkContext->RequestParameters);

    maxlength = (ULONG)(WorkContext->RequestBuffer->DataLength + sizeof( USHORT ) -
                        ((ULONG_PTR)ntExtendedRequest->Buffer -
                         (ULONG_PTR)WorkContext->RequestBuffer->Buffer));


    //
    // Get the extended security buffer
    //

    *SecurityBuffer = (PUCHAR) ntExtendedRequest->Buffer;
    *SecurityBufferLength = ntExtendedRequest->SecurityBlobLength;

    *RestOfDataBuffer = ntExtendedRequest->Buffer +
                            ntExtendedRequest->SecurityBlobLength;

    *RestOfDataLength = (USHORT)( (PUCHAR)ntExtendedRequest->Buffer +
                                  sizeof(USHORT) +
                                  SmbGetUshort( &ntExtendedRequest->ByteCount) -
                                  (*RestOfDataBuffer)
                                );

    if( *SecurityBufferLength > maxlength ||
        *RestOfDataLength > maxlength - *SecurityBufferLength ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "GetExtendedSecurityParameters: Invalid security buffer\n" ));
        }

        return STATUS_INVALID_SMB;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
GetNtSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PCHAR *CaseSensitivePassword,
    OUT PULONG CaseSensitivePasswordLength,
    OUT PCHAR *CaseInsensitivePassword,
    OUT PULONG CaseInsensitivePasswordLength,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PCHAR *RestOfDataBuffer,
    OUT PULONG RestOfDataLength)
{

    NTSTATUS status = STATUS_SUCCESS;
    PCONNECTION connection;
    PREQ_NT_SESSION_SETUP_ANDX ntRequest;
    PREQ_SESSION_SETUP_ANDX request;
    PSZ userName;
    USHORT nameLength;
    BOOLEAN isUnicode;

    connection = WorkContext->Connection;

    ntRequest = (PREQ_NT_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    request = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);

    //
    // Get the account name, and additional information from the SMB buffer.
    //

    if ( connection->SmbDialect <= SmbDialectNtLanMan) {

        //
        // The NT-NT SMB protocol passes both case sensitive (Unicode,
        // mixed case) and case insensitive (ANSI, uppercased) passwords.
        // Get pointers to them to pass to SrvValidateUser.
        //

        *CaseInsensitivePasswordLength =
            (CLONG)SmbGetUshort(&ntRequest->CaseInsensitivePasswordLength);
        *CaseInsensitivePassword = (PCHAR)(ntRequest->Buffer);
        *CaseSensitivePasswordLength =
            (CLONG)SmbGetUshort( &ntRequest->CaseSensitivePasswordLength );
        *CaseSensitivePassword =
           *CaseInsensitivePassword + *CaseInsensitivePasswordLength;
        userName = (PSZ)(*CaseSensitivePassword +
                                            *CaseSensitivePasswordLength);

    } else {

        //
        // Downlevel clients do not pass the case sensitive password;
        // just get the case insensitive password and use NULL as the
        // case sensitive password.  LSA will do the right thing with
        // it.
        //

        *CaseInsensitivePasswordLength =
            (CLONG)SmbGetUshort( &request->PasswordLength );
        *CaseInsensitivePassword = (PCHAR)request->Buffer;
        *CaseSensitivePasswordLength = 0;
        *CaseSensitivePassword = NULL;
        userName = (PSZ)(request->Buffer + *CaseInsensitivePasswordLength);
    }

    if( (*CaseInsensitivePassword) != NULL &&
        (*CaseInsensitivePassword) + (*CaseInsensitivePasswordLength) >
        END_OF_REQUEST_SMB( WorkContext ) ) {

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    if( (*CaseSensitivePassword) != NULL &&
        (*CaseSensitivePassword) + (*CaseSensitivePasswordLength) >
        END_OF_REQUEST_SMB( WorkContext ) ) {

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    isUnicode = SMB_IS_UNICODE( WorkContext );
    if ( isUnicode ) {
        userName = ALIGN_SMB_WSTR( userName );
    }

    nameLength = SrvGetStringLength(
                     userName,
                     END_OF_REQUEST_SMB( WorkContext ),
                     isUnicode,
                     FALSE      // don't include null terminator
                     );

    if ( nameLength == (USHORT)-1 ) {
        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    status = SrvMakeUnicodeString(
                 isUnicode,
                 UserName,
                 userName,
                 &nameLength );

    if ( !NT_SUCCESS( status ) ) {
        goto error_exit;
    }

    //
    // If client information strings exists, extract the information
    // from the SMB buffer.
    //

    if ( connection->SmbDialect <= SmbDialectDosLanMan21) {

        PCHAR smbInformation;
        USHORT length;
        PWCH infoBuffer;

        smbInformation = userName + nameLength +
                                    ( isUnicode ? sizeof( WCHAR ) : 1 );

        //
        // Now copy the strings to the allocated buffer.
        //

        if ( isUnicode ) {
            smbInformation = ALIGN_SMB_WSTR( smbInformation );
        }

        length = SrvGetStringLength(
                     smbInformation,
                     END_OF_REQUEST_SMB( WorkContext ),
                     isUnicode,
                     FALSE      // don't include null terminator
                     );

        if ( length == (USHORT)-1) {
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        //
        // DOS clients send an empty domain name if they don't know
        // their domain name (e.g., during logon).  OS/2 clients send
        // a name of "?".  This confuses the LSA.  Convert such a name
        // to an empty name.
        //

        if ( isUnicode ) {
            if ( (length == sizeof(WCHAR)) &&
                 (*(PWCH)smbInformation == '?') ) {
                length = 0;
            }
        } else {
            if ( (length == 1) && (*smbInformation == '?') ) {
                length = 0;
            }
        }

        status = SrvMakeUnicodeString(
                     isUnicode,
                     DomainName,
                     smbInformation,
                     &length
                     );

        if ( !NT_SUCCESS( status ) ) {
            goto error_exit;
        }

        smbInformation += length + ( isUnicode ? sizeof(WCHAR) : 1 );

        *RestOfDataBuffer = smbInformation;

        if (connection->SmbDialect <= SmbDialectNtLanMan) {

            *RestOfDataLength = (USHORT) ( (PUCHAR)&ntRequest->ByteCount +
                                            sizeof(USHORT) +
                                            SmbGetUshort(&ntRequest->ByteCount) -
                                            smbInformation
                                         );
        } else {

            PREQ_SESSION_SETUP_ANDX sessionSetupRequest;

            sessionSetupRequest = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);

            *RestOfDataLength = (USHORT) ( (PUCHAR)&sessionSetupRequest->ByteCount +
                                            sizeof(USHORT) +
                                            SmbGetUshort(&sessionSetupRequest->ByteCount) -
                                            smbInformation
                                         );

        }

    } else {

        DomainName->Length = 0;

        *RestOfDataBuffer = NULL;

        *RestOfDataLength = 0;

    }

error_exit:

    return( status );

}


VOID
BuildExtendedSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN ULONG ReturnBufferLength,
    IN NTSTATUS Status,
    IN UCHAR NextCommand,
    IN BOOLEAN IsUnicode)
{
    PRESP_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedResponse;
    PCHAR buffer;
    USHORT byteCount;
    USHORT maxByteCount;
    NTSTATUS status;

    ntExtendedResponse = (PRESP_NT_EXTENDED_SESSION_SETUP_ANDX)
                            (WorkContext->ResponseParameters);

    ntExtendedResponse->WordCount = 4;
    ntExtendedResponse->AndXCommand = NextCommand;
    ntExtendedResponse->AndXReserved = 0;

    if( WorkContext->Session && WorkContext->Session->GuestLogon ) {
        SmbPutUshort( &ntExtendedResponse->Action, SMB_SETUP_GUEST );
    } else {
        SmbPutUshort( &ntExtendedResponse->Action, 0 );
    }

    SmbPutUshort( &ntExtendedResponse->SecurityBlobLength,(USHORT)ReturnBufferLength );

    buffer = ntExtendedResponse->Buffer + ReturnBufferLength;
    maxByteCount = (USHORT)(END_OF_RESPONSE_BUFFER(WorkContext) - buffer + 1);

    if (IsUnicode)
        buffer = ALIGN_SMB_WSTR( buffer );

    status = InsertNativeOSAndType( IsUnicode, buffer, &maxByteCount );
    if( NT_SUCCESS(status) )
    {
        byteCount = maxByteCount;
    }
    else
    {
        Status = status;
    }

    byteCount += (USHORT)ReturnBufferLength;

    SmbPutUshort( &ntExtendedResponse->ByteCount, byteCount );

    SmbPutUshort( &ntExtendedResponse->AndXOffset, GET_ANDX_OFFSET(
                                             WorkContext->ResponseHeader,
                                             WorkContext->ResponseParameters,
                                             RESP_NT_EXTENDED_SESSION_SETUP_ANDX,
                                             byteCount
                                             ) );

    //
    // Make sure we return the error status here, as the client uses it to
    //  determine if extra round trips are necessary
    //
    SrvSetSmbError2 ( WorkContext, Status, TRUE );
}


VOID
BuildSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN UCHAR NextCommand,
    IN USHORT Action,
    IN BOOLEAN IsUnicode)
{

    PRESP_SESSION_SETUP_ANDX response;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PCHAR buffer;
    USHORT byteCount;
    USHORT maxByteCount;
    NTSTATUS status;

    response = (PRESP_SESSION_SETUP_ANDX) (WorkContext->ResponseParameters);

    connection = WorkContext->Connection;

    endpoint = connection->Endpoint;

    response->WordCount = 3;
    response->AndXCommand = NextCommand;
    response->AndXReserved = 0;

    if (connection->SmbDialect <= SmbDialectDosLanMan21) {
        USHORT OsTypeByteCount;

        buffer = response->Buffer;

        if (IsUnicode)
            buffer = ALIGN_SMB_WSTR( buffer );

        maxByteCount = OsTypeByteCount = (USHORT)(END_OF_RESPONSE_BUFFER(WorkContext)-buffer+1);
        byteCount = 0;

        status = InsertNativeOSAndType( IsUnicode, buffer, &OsTypeByteCount );
        if( NT_SUCCESS(status) )
        {
            byteCount += OsTypeByteCount;
        }
        else
        {
            SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
            goto insuff_buffer;
        }

        buffer = buffer + byteCount;

        if (connection->SmbDialect <= SmbDialectNtLanMan) {

            USHORT stringLength;

            if ( IsUnicode ) {

                buffer = ALIGN_SMB_WSTR( buffer );

                stringLength = endpoint->DomainName.Length + sizeof(UNICODE_NULL);
                if( byteCount + stringLength > maxByteCount )
                {
                    SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                    goto insuff_buffer;
                }

                RtlCopyMemory(
                    buffer,
                    endpoint->DomainName.Buffer,
                    stringLength
                    );

                byteCount += (USHORT)stringLength;

            } else {

                stringLength = endpoint->OemDomainName.Length + sizeof(CHAR);
                if( byteCount + stringLength > maxByteCount )
                {
                    SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                    goto insuff_buffer;
                }

                RtlCopyMemory(
                    (PVOID) buffer,
                    endpoint->OemDomainName.Buffer,
                    stringLength
                    );

                byteCount += (USHORT)stringLength;

            }

        }

    } else {

insuff_buffer:
        byteCount = 0;
    }

    SmbPutUshort( &response->ByteCount, byteCount );

    //
    // Normally, turning on bit 0 of Action indicates that the user was
    // logged on as GUEST.  However, NT does not have automatic guest
    // logon--a user ID and password are required for every single logon
    // (though the password may have null length).  Therefore, the
    // server need not concern itself with what kind of account the
    // client gets.
    //
    // Bit 1 tells the client that the user was logged on
    // using the lm session key instead of the user session key.
    //

    SmbPutUshort( &response->Action, Action );

    SmbPutUshort( &response->AndXOffset, GET_ANDX_OFFSET(
                                             WorkContext->ResponseHeader,
                                             WorkContext->ResponseParameters,
                                             RESP_SESSION_SETUP_ANDX,
                                             byteCount
                                             ) );

}


NTSTATUS
InsertNativeOSAndType(
    IN BOOLEAN IsUnicode,
    OUT PCHAR Buffer,
    IN OUT PUSHORT ByteCount)
{
    USHORT availible = *ByteCount;
    USHORT stringLength;

    *ByteCount = 0;

    if ( IsUnicode ) {

        stringLength = SrvNativeOS.Length;

        if( availible < stringLength )
        {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory(
            Buffer,
            SrvNativeOS.Buffer,
            stringLength
            );

        *ByteCount = stringLength;
        availible -= stringLength;

        stringLength = SrvNativeLanMan.Length;

        if( availible < stringLength )
        {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory(
            (PCHAR)Buffer + *ByteCount,
            SrvNativeLanMan.Buffer,
            stringLength
            );

        *ByteCount += (USHORT)stringLength;
        availible -= stringLength;

    } else {

        stringLength = SrvOemNativeOS.Length;

        if( availible < stringLength )
        {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory(
            Buffer,
            SrvOemNativeOS.Buffer,
            stringLength
            );

        *ByteCount = stringLength;
        availible -= stringLength;

        stringLength = SrvOemNativeLanMan.Length;

        if( availible < stringLength )
        {
            return STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory(
            (PCHAR)Buffer + *ByteCount,
            SrvOemNativeLanMan.Buffer,
            stringLength
            );

        *ByteCount += stringLength;
        availible -= stringLength;
    }

    return STATUS_SUCCESS;
}



SMB_PROCESSOR_RETURN_TYPE
SrvSmbLogoffAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Logoff and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_LOGOFF_ANDX request;
    PRESP_LOGOFF_ANDX response;

    PSESSION session;
    USHORT reqAndXOffset;
    UCHAR nextCommand;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOGOFF_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Logoff request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Logoff request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up parameters.
    //

    request = (PREQ_LOGOFF_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_LOGOFF_ANDX)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbLogoffAndX: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If we need to visit the license server, get over to a blocking
    // thread to ensure that we don't consume the nonblocking threads
    //
    if( WorkContext->UsingBlockingThread == 0 &&
        session->IsLSNotified == TRUE ) {
            //
            // Insert the work item at the tail of the blocking work queue
            //
            SrvInsertWorkQueueTail(
                GET_BLOCKING_WORK_QUEUE(),
                (PQUEUEABLE_BLOCK_HEADER)WorkContext
            );

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
    }

    //
    // Do the actual logoff.
    //

    SrvCloseSession( session );

    SrvStatistics.SessionsLoggedOff++;

    //
    // Dereference the session, since it's no longer valid, but we may
    // end up processing a chained command.  Clear the session pointer
    // in the work context block to indicate that we've done this.
    //

    SrvDereferenceSession( session );

    WorkContext->Session = NULL;

    if( WorkContext->SecurityContext )
    {
        SrvDereferenceSecurityContext( WorkContext->SecurityContext );
        WorkContext->SecurityContext = NULL;
    }

    //
    // Build the response SMB, making sure to save request fields first
    // in case the response overwrites the request.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );
    nextCommand = request->AndXCommand;

    response->WordCount = 2;
    response->AndXCommand = request->AndXCommand;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, GET_ANDX_OFFSET(
                                            WorkContext->ResponseHeader,
                                            WorkContext->ResponseParameters,
                                            RESP_LOGOFF_ANDX,
                                            0
                                            ) );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {

    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_SESSION_SETUP_ANDX:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbLogoffAndX: Illegal followon command: 0x%lx\n",
                        nextCommand );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SmbStatus = SmbStatusMoreCommands;
        goto Cleanup;
    }
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbLogoffAndX complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbLogoffAndX


STATIC
VOID
GetEncryptionKey (
    OUT CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH]
    )

/*++

Routine Description:

    Creates an encryption key to use as a challenge for a logon.

    *** Although the MSV1_0 authentication package has a function that
        returns an encryption key, we do not use that function in order
        to avoid a trip through LPC and into LSA.

Arguments:

    EncryptionKey - a pointer to a buffer which receives the encryption
        key.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    union {
        LARGE_INTEGER time;
        UCHAR bytes[8];
    } u;
    ULONG seed;
    ULONG challenge[2];
    ULONG result3;

    //
    // Create a pseudo-random 8-byte number by munging the system time
    // for use as a random number seed.
    //
    // Start by getting the system time.
    //

    ASSERT( MSV1_0_CHALLENGE_LENGTH == 2 * sizeof(ULONG) );

    KeQuerySystemTime( &u.time );

    //
    // To ensure that we don't use the same system time twice, add in the
    // count of the number of times this routine has been called.  Then
    // increment the counter.
    //
    // *** Since we don't use the low byte of the system time (it doesn't
    //     take on enough different values, because of the timer
    //     resolution), we increment the counter by 0x100.
    //
    // *** We don't interlock the counter because we don't really care
    //     if it's not 100% accurate.
    //

    u.time.LowPart += EncryptionKeyCount;

    EncryptionKeyCount += 0x100;

    //
    // Now use parts of the system time as a seed for the random
    // number generator.
    //
    // *** Because the middle two bytes of the low part of the system
    //     time change most rapidly, we use those in forming the seed.
    //

    seed = ((u.bytes[1] + 1) <<  0) |
           ((u.bytes[2] + 0) <<  8) |
           ((u.bytes[2] - 1) << 16) |
           ((u.bytes[1] + 0) << 24);

    //
    // Now get two random numbers.  RtlRandom does not return negative
    // numbers, so we pseudo-randomly negate them.
    //

    challenge[0] = RtlRandom( &seed );
    challenge[1] = RtlRandom( &seed );
    result3 = RtlRandom( &seed );

    if ( (result3 & 0x1) != 0 ) {
        challenge[0] |= 0x80000000;
    }
    if ( (result3 & 0x2) != 0 ) {
        challenge[1] |= 0x80000000;
    }

    //
    // Return the challenge.
    //

    RtlCopyMemory( EncryptionKey, challenge, MSV1_0_CHALLENGE_LENGTH );

} // GetEncryptionKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbdir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbdir.c

Abstract:

    This module implements directory control SMB processors:

        Create Directory
        Create Directory2
        Delete Directory
        Check Directory

--*/

#include "precomp.h"
#include "smbdir.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbCreateDirectory )
#pragma alloc_text( PAGE, SrvSmbCreateDirectory2 )
#pragma alloc_text( PAGE, SrvSmbDeleteDirectory )
#pragma alloc_text( PAGE, SrvSmbCheckDirectory )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Create Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_CREATE_DIRECTORY request;
    PRESP_CREATE_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    HANDLE directoryHandle;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_DIRECTORY;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Create directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Create directory request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_CREATE_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_CREATE_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbCreateDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer because the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCreateDirectory: illegal path name: %s\n",
                        (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Attempt to create the directory.  Since we must specify some desired
    // access, request TRAVERSE_DIRECTORY even though we are going to close
    // the directory just after we create it. The SMB protocol has no way
    // of specifying attributes, so assume a normal file.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Creating directory %wZ\n", objectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &directoryHandle,
                 FILE_TRAVERSE,                             // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 0L,                                        // AllocationSize
                 FILE_ATTRIBUTE_NORMAL,                     // FileAttributes
                 0L,                                        // ShareAccess
                 FILE_CREATE,                               // Disposition
                 FILE_DIRECTORY_FILE,                       // CreateOptions
                 NULL,                                      // EaBuffer
                 0L,                                        // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 share
                 );

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    //
    // Special error mapping to return correct error.
    //

    if ( status == STATUS_OBJECT_NAME_COLLISION &&
            !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection)) {
        status = STATUS_ACCESS_DENIED;
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCreateDirectory: SrvIoCreateFile failed, "
                        "status = %X\n", status );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 23, 0 );
    SrvStatistics.TotalFilesOpened++;

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // The SMB protocol has no concept of open directories; just close the
    // handle now that we have created the directory.
    //

    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 36, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_CREATE_DIRECTORY,
                                        0
                                        );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbCreateDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;
} // SrvSmbCreateDirectory


SMB_TRANS_STATUS
SrvSmbCreateDirectory2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Create Directory2 request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_CREATE_DIRECTORY2 request;
    PRESP_CREATE_DIRECTORY2 response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    UNICODE_STRING directoryName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE directoryHandle;

    PFILE_FULL_EA_INFORMATION ntFullEa = NULL;
    ULONG ntFullEaLength = 0;
    USHORT eaErrorOffset = 0;

    PTREE_CONNECT treeConnect;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_DIRECTORY2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint1( "Create Directory2 entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_CREATE_DIRECTORY2)transaction->InParameters;
    response = (PRESP_CREATE_DIRECTORY2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_CREATE_DIRECTORY2)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_CREATE_DIRECTORY2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbCreateDirectory2: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the tree connect block from the transaction block and the share
    // block from the tree connect block.  These don't need to be referenced
    // pointers because they are referenced by the transaction and the
    // tree connect, respectively.
    //

    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCreateDirectory2: illegal path name: %ws\n",
                          directoryName.Buffer );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // If an FEALIST was passed and it has valid size, convert it to
    // NT style.  SrvOs2FeaListToNt allocates space for the NT full EA
    // list which must be deallocated.  Note that sizeof(FEALIST) includes
    // space for 1 FEA entry.  Without at least much information, the EA
    // code below should be skipped.
    //

    if ( transaction->DataCount > sizeof(FEALIST) &&
         SmbGetUlong( &((PFEALIST)transaction->InData)->cbList ) > sizeof(FEALIST) &&
         SmbGetUlong( &((PFEALIST)transaction->InData)->cbList ) <= transaction->DataCount ) {

        status = SrvOs2FeaListToNt(
                     (PFEALIST)transaction->InData,
                     &ntFullEa,
                     &ntFullEaLength,
                     &eaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvSmbCreateDirectory2: SrvOs2FeaListToNt failed, "
                            "status = %X\n", status );
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &directoryName );
            }

            SrvSetSmbError2( WorkContext, status, TRUE );
            transaction->SetupCount = 0;
            transaction->ParameterCount = 2;
            SmbPutUshort( &response->EaErrorOffset, eaErrorOffset );
            transaction->DataCount = 0;

            SmbStatus = SmbTransStatusErrorWithData;
            goto Cleanup;
        }
    }

    //
    // Attempt to create the directory.  Since we must specify some desired
    // access, request FILE_TRAVERSE even though we are going to close
    // the directory just after we create it. The SMB protocol has no way
    // of specifying attributes, so assume a normal file.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Creating directory %wZ\n", objectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( ntFullEa ) ) {
        ULONG ntEaErrorOffset = 0;
        status = IoCheckEaBufferValidity( ntFullEa, ntFullEaLength, &ntEaErrorOffset );
        eaErrorOffset = (USHORT)ntEaErrorOffset;
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        status = SrvIoCreateFile(
                     WorkContext,
                     &directoryHandle,
                     FILE_TRAVERSE,                   // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     0L,                              // AllocationSize
                     FILE_ATTRIBUTE_NORMAL,           // FileAttributes
                     0L,                              // ShareAccess
                     FILE_CREATE,                     // Disposition
                     FILE_DIRECTORY_FILE,             // CreateOptions
                     ntFullEa,                        // EaBuffer
                     ntFullEaLength,                  // EaLength
                     CreateFileTypeNone,
                     NULL,                            // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,           // Options
                     share
                     );
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( ARGUMENT_PRESENT( ntFullEa ) ) {
        DEALLOCATE_NONPAGED_POOL( ntFullEa );
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCreateDirectory2: SrvIoCreateFile failed, "
                        "status = %X\n", status );
        }

        SrvSetSmbError2( WorkContext, status, TRUE );

        transaction->SetupCount = 0;
        transaction->ParameterCount = 2;
        SmbPutUshort( &response->EaErrorOffset, eaErrorOffset );
        transaction->DataCount = 0;

        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // The SMB protocol has no concept of open directories; just close the
    // handle now that we have created the directory.
    //

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 24, 0 );
    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 37, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    SmbPutUshort( &response->EaErrorOffset, 0 );
    transaction->DataCount = 0;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbCreateDirectory2


SMB_PROCESSOR_RETURN_TYPE
SrvSmbDeleteDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Delete Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_DELETE_DIRECTORY request;
    PRESP_DELETE_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    HANDLE directoryHandle;
    FILE_DISPOSITION_INFORMATION fileDispositionInformation;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_DELETE_DIRECTORY;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Delete directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Delete directory request params at 0x%p, response params at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_DELETE_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_DELETE_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbDeleteDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer becsue the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbDeleteDirectory: illegal path name: %s\n",
                          (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // If the client is trying to delete the root of the share, reject
    // the request.
    //

    if ( directoryName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbDeleteDirectory: attempting to delete share root\n" );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.  Open relative to the
    // share root directory handle.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &directoryName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
            WorkContext->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Attempt to open the directory.  We just need DELETE access to delete
    // the directory.
    //

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "Opening directory %wZ\n", &directoryName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &directoryHandle,
                 DELETE,                                    // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0L,                                        // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN,                                 // Disposition
                 FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, // CreateOptions
                 NULL,                                      // EaBuffer
                 0L,                                        // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &directoryHandle,
                     DELETE,                                    // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0L,                                        // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,                                 // Disposition
                     FILE_DIRECTORY_FILE,                       // CreateOptions
                     NULL,                                      // EaBuffer
                     0L,                                        // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     share
                     );
    }

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint2( "SrvDeleteDirectory: SrvIoCreateFile (%s) failed, "
                        "status = %X\n", (PSZ)request->Buffer + 1, status );
        }

        //
        // If returned error is STATUS_NOT_A_DIRECTORY, downlevel clients
        // expect ERROR_ACCESS_DENIED
        //

        if ( (status == STATUS_NOT_A_DIRECTORY) &&
             !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {

            status = STATUS_ACCESS_DENIED;
        }

        SrvSetSmbError( WorkContext, status );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        goto Cleanup;
    }

    SRVDBG_CLAIM_HANDLE( directoryHandle, "DIR", 25, 0 );

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint1( "SrvIoCreateFile succeeded, handle = 0x%p\n",
                    directoryHandle );
    }

    //
    // Delete the directory with NtSetInformationFile.
    //

    fileDispositionInformation.DeleteFile = TRUE;

    status = NtSetInformationFile(
                 directoryHandle,
                 &ioStatusBlock,
                 &fileDispositionInformation,
                 sizeof(FILE_DISPOSITION_INFORMATION),
                 FileDispositionInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint2( "SrvDeleteDirectory: NtSetInformationFile for directory "
                      "%s returned %X\n", (PSZ)request->Buffer + 1, status );
        }

        SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 38, 0 );
        SrvNtClose( directoryHandle, TRUE );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &directoryName );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;

    } else {

        //
        // Remove this directory name from the cache, since it has been deleted
        //
        SrvRemoveCachedDirectoryName( WorkContext, &directoryName );
    }

    IF_SMB_DEBUG(DIRECTORY2) {
        SrvPrint0( "SrvSmbDeleteDirectory: NtSetInformationFile succeeded.\n" );
    }

    //
    // Close the directory handle so that the directory will be deleted.
    //

    SRVDBG_RELEASE_HANDLE( directoryHandle, "DIR", 39, 0 );
    SrvNtClose( directoryHandle, TRUE );

    //
    // Close all DOS directory searches on this directory and its
    // subdirectories.
    //

    SrvCloseSearches(
            treeConnect->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnDelete,
            (PVOID) &directoryName,
            (PVOID) treeConnect
            );


    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_DELETE_DIRECTORY,
                                        0
                                        );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbDeleteDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbDeleteDirectory


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCheckDirectory (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Check Directory SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/
{
    PREQ_CHECK_DIRECTORY request;
    PRESP_CHECK_DIRECTORY response;

    NTSTATUS status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING directoryName;
    FILE_NETWORK_OPEN_INFORMATION fileInformation;
    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CHECK_DIRECTORY;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(DIRECTORY1) {
        SrvPrint2( "Check directory request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Check directory request params at 0x%p, response params at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_CHECK_DIRECTORY)WorkContext->RequestParameters;
    response = (PRESP_CHECK_DIRECTORY)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbCheckDirectory: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto Cleanup;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer because the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &directoryName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbCheckDirectory: illegal path name: %s\n",
                          (PSZ)request->Buffer + 1 );
        }

        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // See if we can find this directory in the CachedDirectoryList
    //
    if( SrvIsDirectoryCached( WorkContext, &directoryName ) == FALSE ) {

        //
        // Is not in the cache, must really check.
        //
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &directoryName,
            (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                WorkContext->Session->UsingUppercasePaths) ?
                OBJ_CASE_INSENSITIVE : 0L,
            NULL,
            NULL
            );

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = SrvGetShareRootHandle( share );

            if( NT_SUCCESS( status ) ) {
                ULONG FileOptions = FILE_DIRECTORY_FILE;

                if (SeSinglePrivilegeCheck(
                        SeExports->SeBackupPrivilege,
                        KernelMode)) {
                    FileOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
                }

                //
                // The file name is always relative to the share root
                //
                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS(status) )
                {
                    goto SnapError;
                }

                //
                // Find out what this thing is
                //

                if( IoFastQueryNetworkAttributes( &objectAttributes,
                                                  FILE_TRAVERSE,
                                                  FileOptions,
                                                  &ioStatusBlock,
                                                  &fileInformation
                                                    ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    if( IoFastQueryNetworkAttributes( &objectAttributes,
                                                      FILE_TRAVERSE,
                                                      FILE_DIRECTORY_FILE,
                                                      &ioStatusBlock,
                                                      &fileInformation
                                                        ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatusBlock.Status;
                }

SnapError:

                SrvReleaseShareRootHandle( share );
            }

            REVERT();
        }
    }


    if ( !isUnicode ) {
        RtlFreeUnicodeString( &directoryName );
    }

    if ( NT_SUCCESS(status) ) {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_CHECK_DIRECTORY,
                                            0
                                            );
    } else {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //
        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        if (CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection)) {
            SrvSetSmbError( WorkContext, status );
        } else {
            SrvSetSmbError( WorkContext, STATUS_OBJECT_PATH_NOT_FOUND );
        }
    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbCheckDirectory complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbCheckDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbfind.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsrch.c

Abstract:

    This module contains routines for processing the find 2 SMBs:

        Find 2 (First/Next/Rewind)
        Find 2 Close

Author:

    David Treadwell (davidtr)    13-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbfind.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBFIND

UNICODE_STRING SrvDownlevelTimewarpToken = { 12, 12, L"@GMT-*" };

VOID SRVFASTCALL
BlockingFindFirst2 (
    IN PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
DoFindFirst2 (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingFindNext2 (
    IN PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
DoFindNext2 (
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    );

NTSTATUS
SrvDownlevelTWarpFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    );

VOID
ConvertFileInfo (
    IN PFILE_DIRECTORY_INFORMATION File,
    IN PWCH FileName,
    IN BOOLEAN Directory,
    IN BOOLEAN ClientIsUnicode,
    OUT PSMB_FIND_BUFFER FindBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbFindFirst2 )
#pragma alloc_text( PAGE, BlockingFindFirst2 )
#pragma alloc_text( PAGE, DoFindFirst2 )
#pragma alloc_text( PAGE, SrvSmbFindNext2 )
#pragma alloc_text( PAGE, BlockingFindNext2 )
#pragma alloc_text( PAGE, DoFindNext2 )
#pragma alloc_text( PAGE, SrvFind2Loop )
#pragma alloc_text( PAGE, ConvertFileInfo )
#pragma alloc_text( PAGE, SrvSmbFindClose2 )
#pragma alloc_text( PAGE, SrvDownlevelTWarpFind2Loop )
#endif


SMB_TRANS_STATUS
SrvSmbFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_FIND_FIRST2 request;
    PTRANSACTION transaction;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_FIRST2;
    SrvWmiStartContext(WorkContext);

    //
    // If the infomation level is QUERY_EAS_FROM_LIST, and we
    // are not in a blocking thread, requeue the request to a blocking
    // thread.
    //
    // We can't process the SMB in a non blocking thread because this
    // info level requires opening the file, which may be oplocked,
    // so the open operation may block.
    //

    transaction = WorkContext->Parameters.Transaction;
    request = (PREQ_FIND_FIRST2)transaction->InParameters;

    if ( transaction->ParameterCount >= sizeof(REQ_FIND_FIRST2) &&
         SmbGetUshort( &request->InformationLevel ) == SMB_INFO_QUERY_EAS_FROM_LIST ) {

        WorkContext->FspRestartRoutine = BlockingFindFirst2;
        SrvQueueWorkToBlockingThread(WorkContext);
        SmbStatus = SmbTransStatusInProgress;
    }
    else {
        SmbStatus = DoFindFirst2(WorkContext);
    }

    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbFindFirst2


VOID SRVFASTCALL
BlockingFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_FIRST2;
    SrvWmiStartContext(WorkContext);

    smbStatus = DoFindFirst2( WorkContext );
    if ( smbStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction( WorkContext, smbStatus );
    }

    SrvWmiEndContext(WorkContext);
    return;

} // BlockingFindFirst2


SMB_TRANS_STATUS
DoFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{

    PREQ_FIND_FIRST2 request;
    PRESP_FIND_FIRST2 response;
    PTRANSACTION transaction;
    PCONNECTION connection;

    NTSTATUS status,TableStatus;
    UNICODE_STRING fileName;
    PTABLE_ENTRY entry = NULL;
    PTABLE_HEADER searchTable;
    SHORT sidIndex = 0;
    USHORT sequence;
    USHORT maxCount;
    USHORT flags;
    USHORT informationLevel;
    BOOLEAN isUnicode;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    CLONG nonPagedBufferSize;
    BOOLEAN isTimewarpSearch = FALSE;

    PSEARCH search = NULL;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint1( "Find First2 entered; transaction 0x%p\n", transaction );
    }

    request = (PREQ_FIND_FIRST2)transaction->InParameters;
    response = (PRESP_FIND_FIRST2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_FIND_FIRST2)) ||
         (transaction->MaxParameterCount < sizeof(RESP_FIND_FIRST2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "DoFindFirst2: bad parameter byte counts: "
                      "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Make sure this really is a disk type share
    //
    if( transaction->TreeConnect->Share->ShareType != ShareTypeDisk ) {
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, transaction->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Initialize the string containing the search name specification.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    status =  SrvCanonicalizePathName(
            WorkContext,
            transaction->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            FALSE,
            isUnicode,
            &fileName
            );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get parameters from the request SMB.
    //

    maxCount = SmbGetUshort( &request->SearchCount );
    flags = SmbGetUshort( &request->Flags );

    //
    // Make sure that the informationLevel is supported.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch ( informationLevel ) {

    case SMB_INFO_STANDARD:
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO:
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindFirst2: Bad info level: %ld\n",
                          informationLevel );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Allocate a search block on the assumption that a search table
    // entry will be available when needed.
    //

    SrvAllocateSearch( &search, &fileName, FALSE );

    if ( search == NULL ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: unable to allocate search block.\n" );
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }
    search->SearchStorageType = SmbGetUlong(&request->SearchStorageType);

    //
    // Allocate an SID for the search.  The SID is used to locate the
    // search block on FindNexts.  If there are no free entries in the
    // table, attempt to grow the table.  If we are unable to grow the table,
    // attempt to timeout a search block using the shorter timeout period.
    // If this fails, reject the request.
    //

    connection = WorkContext->Connection;
    searchTable = &connection->PagedConnection->SearchTable;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Before inserting this search block, make sure the session and tree
    // connect is still active.  If this gets inserted after the session
    // is closed, the search might not be cleaned up properly.
    //

    if (GET_BLOCK_STATE(WorkContext->Session) != BlockStateActive) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Session Closing.\n" );
        }

        RELEASE_LOCK( &connection->Lock );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        return SmbTransStatusErrorWithoutData;

    } else if (GET_BLOCK_STATE(WorkContext->TreeConnect) != BlockStateActive) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Tree Connect Closing.\n" );
        }

        RELEASE_LOCK( &connection->Lock );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Set up referenced session and tree connect pointers and increment
    // the count of open files on the session.  This prevents an idle
    // session with an open search from being autodisconnected.
    //

    search->Session = WorkContext->Session;
    SrvReferenceSession( WorkContext->Session );

    search->TreeConnect = WorkContext->TreeConnect;
    SrvReferenceTreeConnect( WorkContext->TreeConnect );

    WorkContext->Session->CurrentSearchOpenCount++;

    if ( searchTable->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             searchTable,
             SrvInitialSearchTableSize,
             SrvMaxSearchTableSize,
             &TableStatus ) == FALSE
         &&
         SrvTimeoutSearches(
             NULL,
             connection,
             TRUE ) == 0
       ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "DoFindFirst2: Connection SearchTable full.\n" );
        }

        //
        // Decrement the counts of open searches.
        //

        WorkContext->Session->CurrentSearchOpenCount--;
        RELEASE_LOCK( &connection->Lock );

        SrvDereferenceTreeConnect( search->TreeConnect );
        SrvDereferenceSession( search->Session );

        FREE_HEAP( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_SEARCH);
            SrvSetSmbError( WorkContext, STATUS_OS2_NO_MORE_SIDS );
        }
        else {
            SrvSetSmbError( WorkContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        return SmbTransStatusErrorWithoutData;
    }

    sidIndex = searchTable->FirstFreeEntry;

    //
    // A free SID was found.  Remove it from the free list and set
    // its owner and sequence number.
    //

    entry = &searchTable->Table[sidIndex];

    searchTable->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( searchTable->LastFreeEntry == sidIndex ) {
        searchTable->LastFreeEntry = -1;
    }

    INCREMENT_SID_SEQUENCE( entry->SequenceNumber );

    //
    // SID = sequence | sidIndex == 0 is illegal.  If this is
    // the current value, increment the sequence.
    //

    if ( entry->SequenceNumber == 0 && sidIndex == 0 ) {
        INCREMENT_SID_SEQUENCE( entry->SequenceNumber );
    }

    sequence = entry->SequenceNumber;

    entry->Owner = search;

    RELEASE_LOCK( &connection->Lock );

    //
    // Fill in other fields of the search block.
    //

    search->SearchAttributes = SmbGetUshort( &request->SearchAttributes );
    search->TableIndex = sidIndex;

    //
    // Store the Flags2 field of the smb in the search block.  This is
    // used as a workaround for an OS/2 client side bug where the
    // findfirst and findnext flags2 bits are inconsistent.
    //

    search->Flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    if ( search->Flags2 & SMB_FLAGS2_KNOWS_LONG_NAMES ) {

        search->Flags2 |= SMB_FLAGS2_KNOWS_EAS;

    }

    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and information,
    // so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more then the number of files we need to
    // return.  We get space to hold two extra files in case some
    // files do not meet the search criteria (eg directories).
    //

    if ( maxCount > MAX_FILES_FOR_MED_FIND2 ) {
        nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
    } else if ( maxCount > MAX_FILES_FOR_MIN_FIND2 ) {
        nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
    } else {
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
    }

    directoryInformation = ALLOCATE_NONPAGED_POOL(
                               nonPagedBufferSize,
                               BlockTypeDataBuffer
                               );

    if ( directoryInformation == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "DoFindFirst2: could not allocate nonpaged pool.",
            NULL,
            NULL
            );

        SrvCloseSearch( search );
        SrvDereferenceSearch( search );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }

    directoryInformation->DirectoryHandle = 0;
    directoryInformation->DownlevelTimewarp = FALSE;

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                      nonPagedBufferSize, directoryInformation );
    }

    //
    // Call SrvFind2Loop to fill the data section of the transaction with
    // file entries.  It writes into the response parameters section
    // of the SMB information relating to the results of the search.
    // The information is the same as the response parameters for
    // a FindNext2, so that structure is used.  The FindFirst2 parameters
    // are identical to the FindNext2 parameters except for the Sid
    // at the beginning of the FindFirst2 response.
    //
    if( !CLIENT_CAPABLE_OF( NT_STATUS, WorkContext->Connection ) &&
        !SrvDisableDownlevelTimewarp )
    {
        UNICODE_STRING lastElement;

        SrvGetBaseFileName( &fileName, &lastElement );
        isTimewarpSearch = RtlEqualUnicodeString( &lastElement, &SrvDownlevelTimewarpToken, TRUE );
    }

    if( isTimewarpSearch )
    {
        search->DownlevelTimewarp = TRUE;

        status = SrvSnapRefreshSnapShotsForShare( WorkContext->TreeConnect->Share );
        if( NT_SUCCESS(status) )
        {
            status = SrvDownlevelTWarpFind2Loop(
                         WorkContext,
                         TRUE,
                         NULL,
                         flags,
                         informationLevel,
                         transaction,
                         directoryInformation,
                         nonPagedBufferSize,
                         search->SearchAttributes,
                         &fileName,
                         maxCount,
                         (PRESP_FIND_NEXT2)( &response->SearchCount ),
                         search
                         );
        }
    }
    else
    {
        status = SrvFind2Loop(
                     WorkContext,
                     TRUE,
                     NULL,
                     flags,
                     informationLevel,
                     transaction,
                     directoryInformation,
                     nonPagedBufferSize,
                     search->SearchAttributes,
                     &fileName,
                     maxCount,
                     (PRESP_FIND_NEXT2)( &response->SearchCount ),
                     search
                     );
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    //
    // Map the error, if necessary
    //

    if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
        if ( status == STATUS_NO_SUCH_FILE ) {
            status = STATUS_NO_MORE_FILES;
        }
    }

    if ( !NT_SUCCESS(status) && SmbGetUshort( &response->SearchCount ) == 0 ) {

        //
        // If an error was encountered on a find first, we close the search
        // block.
        //

        search->DirectoryHandle = NULL;

        SrvCloseSearch( search );
        SrvDereferenceSearch( search );

        SrvCloseQueryDirectory( directoryInformation );

        DEALLOCATE_NONPAGED_POOL( directoryInformation );

        SrvSetSmbError2( WorkContext, status, TRUE );
        transaction->SetupCount = 0;
        transaction->ParameterCount = sizeof(RESP_FIND_FIRST2);
        SmbPutUshort( &response->Sid, 0 );

        return SmbTransStatusErrorWithData;
    }

    //
    // If the client told us to close the search after this request, or
    // close at end-of-search, or this no files were found, close the
    // search block and call SrvCloseQueryDirectory.  Otherwise, store
    // information in the search block.
    //

    if ( ( flags & SMB_FIND_CLOSE_AFTER_REQUEST ) != 0 ||
         ( status == STATUS_NO_MORE_FILES &&
             ( flags & SMB_FIND_CLOSE_AT_EOS ) != 0 ) ) {

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Closing search at %p\n", search );
        }

        search->DirectoryHandle = NULL;

        SrvCloseSearch( search );
        SrvCloseQueryDirectory( directoryInformation );

    } else {

        search->DirectoryHandle = directoryInformation->DirectoryHandle;
        search->Wildcards = directoryInformation->Wildcards;
        search->DownlevelTimewarp = directoryInformation->DownlevelTimewarp;
    }

    //
    // Free the buffer used for the search and dereference our pointer to
    // the search block.
    //

    DEALLOCATE_NONPAGED_POOL( directoryInformation );

    search->InUse = FALSE;
    SrvDereferenceSearch( search );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_FIND_FIRST2);
    SmbPutUshort( &response->Sid, MAKE_SID( sidIndex, sequence ) );

    return SmbTransStatusSuccess;

} // DoFindFirst2


SMB_TRANS_STATUS
SrvSmbFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find Next2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PTRANSACTION transaction;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_NEXT2;
    SrvWmiStartContext(WorkContext);

    //
    // If the infomation level is QUERY_EAS_FROM_LIST, and we
    // are not in a blocking thread, requeue the request to a blocking
    // thread.
    //
    // We can't process the SMB in a non blocking thread because this
    // info level requires opening the file, which may be oplocked,
    // so the open operation may block.
    //

    transaction = WorkContext->Parameters.Transaction;

    if( transaction->ParameterCount >= sizeof(REQ_FIND_NEXT2) ) {

        PREQ_FIND_NEXT2 request = (PREQ_FIND_NEXT2)transaction->InParameters;
        USHORT informationLevel = SmbGetUshort( &request->InformationLevel );

        if ( informationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

            WorkContext->FspRestartRoutine = BlockingFindNext2;
            SrvQueueWorkToBlockingThread( WorkContext );
            SmbStatus = SmbTransStatusInProgress;
            goto Cleanup;
        }
    }

    SmbStatus = DoFindNext2( WorkContext );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbFindNext2


VOID SRVFASTCALL
BlockingFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find Next2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_NEXT2;
    SrvWmiStartContext(WorkContext);
    smbStatus = DoFindNext2( WorkContext );
    if ( smbStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction( WorkContext, smbStatus );
    }

    SrvWmiEndContext(WorkContext);
    return;

} // BlockingFindNext2


SMB_TRANS_STATUS
DoFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Find First2 request.  This request arrives in a
    Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_FIND_NEXT2 request;
    PRESP_FIND_NEXT2 response;
    PTRANSACTION transaction;

    NTSTATUS status;
    USHORT i;
    PCHAR ansiChar;
    PWCH unicodeChar;
    ULONG maxIndex;
    BOOLEAN illegalPath;
    BOOLEAN freeFileName;
    UNICODE_STRING fileName;
    PTABLE_ENTRY entry = NULL;
    USHORT maxCount;
    USHORT informationLevel;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    CLONG nonPagedBufferSize;
    ULONG resumeFileIndex;
    USHORT flags;
    USHORT sid;

    PSEARCH search = NULL;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint1( "Find Next2 entered; transaction %p\n", transaction );
    }

    request = (PREQ_FIND_NEXT2)transaction->InParameters;
    response = (PRESP_FIND_NEXT2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_FIND_NEXT2)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_FIND_NEXT2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "DoFindNext2: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get parameters from the request SMB.
    //

    maxCount = SmbGetUshort( &request->SearchCount );
    resumeFileIndex = SmbGetUlong( &request->ResumeKey );
    flags = SmbGetUshort( &request->Flags );

    //
    // Make sure that the informationLevel is supported.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch ( informationLevel ) {

    case SMB_INFO_STANDARD:
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO:
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindNext2: Bad info level: %ld\n",
                          informationLevel );
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and information,
    // so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more then the number of files we need to
    // return.  We get space to hold two extra files in case some
    // files do not meet the search criteria (eg directories).
    //

    if ( maxCount > MAX_FILES_FOR_MED_FIND2 ) {
        nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
    } else if ( maxCount > MAX_FILES_FOR_MIN_FIND2 ) {
        nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
    } else {
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
    }

    directoryInformation = ALLOCATE_NONPAGED_POOL(
                               nonPagedBufferSize,
                               BlockTypeDataBuffer
                               );

    if ( directoryInformation == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "DoFindFirst2: unable to allocate nonpaged pool.",
            NULL,
            NULL
            );

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        return SmbTransStatusErrorWithoutData;
    }

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                      nonPagedBufferSize, directoryInformation );
    }

    //
    // Get the search block corresponding to this SID.  SrvVerifySid
    // references the search block and fills in fields of
    // directoryInformation so it is ready to be used by
    // SrvQueryDirectoryFile.
    //

    sid = SmbGetUshort( &request->Sid );

    search = SrvVerifySid(
                 WorkContext,
                 SID_INDEX2( sid ),
                 SID_SEQUENCE2( sid ),
                 directoryInformation,
                 nonPagedBufferSize
                 );

    if ( search == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "DoFindNext2: Invalid SID: %lx.\n", sid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
        return SmbTransStatusErrorWithoutData;
    }

    directoryInformation->DownlevelTimewarp = search->DownlevelTimewarp;

    //
    // Initialize the string containing the resume name specification.
    // If the client requested that we resume from the last file returned,
    // use the file name and index stored in the search block.
    //

    if ( ( flags & SMB_FIND_CONTINUE_FROM_LAST ) == 0 ) {

        //
        // Test and use the information passed by the client.  A file
        // name may not be longer than MAXIMUM_FILENAME_LENGTH characters,
        // and it should not contain any directory information.
        //

        illegalPath = FALSE;
        freeFileName = FALSE;

        if ( SMB_IS_UNICODE( WorkContext ) ) {

            fileName.Buffer = ALIGN_SMB_WSTR( (PWCH)request->Buffer );

            maxIndex = (ULONG)((END_OF_REQUEST_SMB( WorkContext ) -
                               (PUCHAR)fileName.Buffer) / sizeof(WCHAR));

            for ( i = 0, unicodeChar = fileName.Buffer;
                  (i < MAXIMUM_FILENAME_LENGTH) && (i < maxIndex);
                  i++, unicodeChar++ ) {

                if ( *unicodeChar == '\0' ) {
                    break;
                }

                if ( IS_UNICODE_PATH_SEPARATOR( *unicodeChar ) ) {
                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint1( "DoFindNext2: illegal path name: %ws\n",
                                      fileName.Buffer );
                    }
                    illegalPath = TRUE;
                    break;
                }

            }

            fileName.Length = (USHORT) (i * sizeof(WCHAR));
            fileName.MaximumLength = fileName.Length;

        } else {

            ansiChar = (PCHAR)request->Buffer;

            maxIndex = (ULONG)(END_OF_REQUEST_SMB( WorkContext ) - ansiChar);

            for ( i = 0;
                  (i < MAXIMUM_FILENAME_LENGTH) && (i < maxIndex);
                  i++, ansiChar++ ) {

                if ( *ansiChar == '\0' ) {
                    break;
                }

                if ( IS_ANSI_PATH_SEPARATOR( *ansiChar ) ) {
                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint1( "DoFindNext2: illegal path name: %s\n",
                                      request->Buffer );
                    }
                    illegalPath = TRUE;
                    break;
                }

            }

            if ( !illegalPath ) {

                status = SrvMakeUnicodeString(
                            FALSE,
                            &fileName,
                            request->Buffer,
                            &i
                            );

                if ( !NT_SUCCESS(status) ) {

                    IF_DEBUG(SMB_ERRORS) {
                        SrvPrint0( "DoFindNext2: unable to allocate Unicode string\n" );
                    }

                    search->InUse = FALSE;
                    SrvDereferenceSearch( search );
                    DEALLOCATE_NONPAGED_POOL( directoryInformation );

                    SrvSetSmbError2(
                        WorkContext,
                        STATUS_OBJECT_PATH_SYNTAX_BAD,
                        TRUE
                        );
                    return SmbTransStatusErrorWithoutData;

                }

                freeFileName = TRUE;

            }

        }

        if ( illegalPath ) {

            search->InUse = FALSE;
            SrvDereferenceSearch( search );
            DEALLOCATE_NONPAGED_POOL( directoryInformation );

            SrvSetSmbError( WorkContext, STATUS_OBJECT_PATH_SYNTAX_BAD );
            return SmbTransStatusErrorWithoutData;

        }

    } else {

        //
        // Use the information in the search block.
        //

        fileName = search->LastFileNameReturned;

        freeFileName = FALSE;

        resumeFileIndex = search->LastFileIndexReturned;

    }

    //
    // Call SrvFind2Loop to fill the SMB buffer and set output parameters.
    //
    // !!! The NULL that might get passed for the resume file index is
    //     a real hack.  I doubt it is necessary, but it could prevent
    //     a server crash if we somehow failed to store the resume file
    //     name.

    if( directoryInformation->DownlevelTimewarp )
    {
        status = SrvDownlevelTWarpFind2Loop(
                     WorkContext,
                     FALSE,
                     fileName.Buffer != NULL ? &resumeFileIndex : NULL,
                     flags,
                     informationLevel,
                     transaction,
                     directoryInformation,
                     nonPagedBufferSize,
                     search->SearchAttributes,
                     &fileName,
                     maxCount,
                     response,
                     search
                     );
    }
    else
    {
        status = SrvFind2Loop(
                     WorkContext,
                     FALSE,
                     fileName.Buffer != NULL ? &resumeFileIndex : NULL,
                     flags,
                     informationLevel,
                     transaction,
                     directoryInformation,
                     nonPagedBufferSize,
                     search->SearchAttributes,
                     &fileName,
                     maxCount,
                     response,
                     search
                     );
    }


    if ( freeFileName ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( !NT_SUCCESS(status) && status != STATUS_NO_MORE_FILES ) {

        search->InUse = FALSE;
        SrvDereferenceSearch( search );

        DEALLOCATE_NONPAGED_POOL( directoryInformation );

        transaction->SetupCount = 0;
        transaction->ParameterCount = sizeof(RESP_FIND_NEXT2);

        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    //
    // If the client told us to close the search after this request,
    // or close at end-of-search, close the search block and call
    // SrvCloseQueryDirectory.
    //

    if ( ( flags & SMB_FIND_CLOSE_AFTER_REQUEST ) != 0 ||
         ( status == STATUS_NO_MORE_FILES &&
             ( flags & SMB_FIND_CLOSE_AT_EOS ) != 0 ) ) {

        search->DirectoryHandle = NULL;
        SrvCloseSearch( search );
        SrvCloseQueryDirectory( directoryInformation );
    }

    //
    // Dereference our pointer to the search block and free the buffer.
    //

    DEALLOCATE_NONPAGED_POOL( directoryInformation );

    search->InUse = FALSE;
    SrvDereferenceSearch( search );

    //
    // Build the output parameter and data structures.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_FIND_NEXT2);

    return SmbTransStatusSuccess;

} // DoFindNext2


NTSTATUS
SrvFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    )

/*++

Routine Description:

    This routine does the looping necessary to get files and put them
    into an SMB buffer for the Find First2 and Find Next2 transaction
    protocols.

Arguments:

    WorkContext -

    IsFirstCall - TRUE if this is a Find First and this is the first call
        to SrvQueryDirectoryFile.

    ResumeFileIndex - if non-NULL, a pointer to the file index to resume
        from.

    Flags - the Flags field of the request SMB.

    InformationLevel - the InformationLevel field of the request SMB.  The
        validity of this value should be verified by the calling routine.

    Transaction - a pointer to the transaction block to use.

    DirectoryInformation - a pointer to the SRV_DIRECTORY_INFORMATION
        structure to use.

    BufferSize - size of the DirectoryInformation buffer.

    SearchAttributes - the SMB-style attributes to pass to
        SrvQueryDirectoryFile.

    FileName - if non-NULL the file name to resume the search from.

    MaxCount - the maximum number of files to get.

    Response - a pointer to the response field of the SMB.  If this is
        a Find First2, it is a pointer to the SearchCount field of the
        response SMB--Find First2 and Find Next2 response formats are
        identical from this point on.

    Search - a pointer to the search block to use.

Return Value:

    NTSTATUS indicating results.

--*/

{
    NTSTATUS status;

    PCHAR bufferLocation;
    BOOLEAN resumeKeysRequested;
    BOOLEAN allowExtraLongNames;
    BOOLEAN isUnicode;
    USHORT count = 0;
    PCHAR lastEntry;
    CLONG totalBytesWritten;
    OEM_STRING oemString;
    UNICODE_STRING unicodeString;
    UNICODE_STRING lastFileName;
    ULONG lastFileIndex = (ULONG)0xFFFFFFFF;
    HANDLE fileHandle;
    PFILE_GET_EA_INFORMATION ntGetEa;
    ULONG ntGetEaLength;
    USHORT eaErrorOffset = 0;
    BOOLEAN filterLongNames;
    BOOLEAN errorOnFileOpen;
    BOOLEAN findWithBackupIntent;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN createNullEas;

    PAGED_CODE( );

    //
    // If the client is requesting an NT info level for search information,
    // do not return resume keys outside the actual file entry.  Resume
    // keys (aka FileIndex) are part of every NT info structure.
    //
    // Also, for NT info levels we can return file names longer than 255
    // bytes, because the NT info levels have name length fields that
    // are four bytes wide, whereas the downlevel info levels only have
    // one-byte name length fields.
    //

    if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_NAMES_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO
       ) {

        resumeKeysRequested = FALSE;
        allowExtraLongNames = TRUE;

    } else {

        resumeKeysRequested =
            (BOOLEAN)((Flags & SMB_FIND_RETURN_RESUME_KEYS) != 0 ? TRUE : FALSE);
        allowExtraLongNames = FALSE;
    }

    //
    // Is this for backup intent?
    //

    if ( (Flags & SMB_FIND_WITH_BACKUP_INTENT) != 0 ) {
        findWithBackupIntent = TRUE;
    } else {
        findWithBackupIntent = FALSE;
    }

    //
    // Is this request in Unicode?
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    //
    // Initialize count of files found.
    //

    SmbPutUshort( &Response->SearchCount, 0 );

    //
    // If this a request to return EAs, convert the OS/2 1.2 EA list
    // to NT format.  This routine allocates space for the NT list
    // which must be deallocated before we exit.
    //

    if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

        PGEALIST geaList = (PGEALIST)Transaction->InData;

        if (Transaction->DataCount < sizeof(GEALIST) ||
            SmbGetUshort(&geaList->cbList) < sizeof(GEALIST) ||
            SmbGetUshort(&geaList->cbList) > Transaction->DataCount) {

            SmbPutUshort( &Response->SearchCount, 0 );
            SmbPutUshort( &Response->EndOfSearch, 0 );
            SmbPutUshort( &Response->EaErrorOffset, 0 );
            SmbPutUshort( &Response->LastNameOffset, 0 );
            Transaction->DataCount = 0;

            return STATUS_OS2_EA_LIST_INCONSISTENT;
        }

        status = SrvOs2GeaListToNt(
                     geaList,
                     &ntGetEa,
                     &ntGetEaLength,
                     &eaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvFind2Loop: SrvOs2GeaListToNt failed, "
                          "status = %X\n", status );
            }

            SmbPutUshort( &Response->SearchCount, 0 );
            SmbPutUshort( &Response->EndOfSearch, 0 );
            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
            SmbPutUshort( &Response->LastNameOffset, 0 );
            Transaction->DataCount = 0;

            return status;
        }
    }

    //
    // Determine whether long filenames (non-8.3) should be filtered out
    // or returned to the client.
    //
    // There is a bug in the LanMan21 that makes the redir forget that
    // he knows about long names.

    if ( ( ( Search->Flags2 & SMB_FLAGS2_KNOWS_LONG_NAMES ) != 0 ) &&
         !IS_DOS_DIALECT( WorkContext->Connection->SmbDialect ) ) {
        filterLongNames = FALSE;
    } else {
        filterLongNames = TRUE;
    }

    //
    // If the client says he doesn't know about long names and this is
    // a request for any info level other than SMB_INFO_STANDARD, we
    // need to fail the request.
    //

    if ( filterLongNames && InformationLevel != SMB_INFO_STANDARD ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvFind2Loop: client doesn't know long names.\n" );
        }

        SmbPutUshort( &Response->SearchCount, 0 );
        SmbPutUshort( &Response->EndOfSearch, 0 );
        SmbPutUshort( &Response->EaErrorOffset, 0 );
        SmbPutUshort( &Response->LastNameOffset, 0 );
        Transaction->DataCount = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Loop calling SrvQueryDirectoryFile to get files.  We do this until
    // one of the following conditions is met:
    //
    //   1) There are no more files to return.
    //   2) We have obtained as many files as were requested.
    //   3) We have put in as much data as MaxDataCount allows.
    //

    bufferLocation = Transaction->OutData;
    lastEntry = bufferLocation;
    totalBytesWritten = 0;

    do {

        //
        // The ff fields have the same offsets in the three directory
        // information structures:
        //      NextEntryOffset
        //      FileIndex
        //      CreationTime
        //      LastAccessTime
        //      LastWriteTime
        //      ChangeTime
        //      EndOfFile
        //      AllocationSize
        //      FileAttributes
        //      FileNameLength
        //

        PFILE_DIRECTORY_INFORMATION fileBasic;
        PFILE_FULL_DIR_INFORMATION fileFull;
        PFILE_BOTH_DIR_INFORMATION fileBoth;
        PFILE_ID_FULL_DIR_INFORMATION fileIdFull;
        PFILE_ID_BOTH_DIR_INFORMATION fileIdBoth;
        ULONG ntInformationLevel;

        //
        // Make sure these asserts hold.
        //

        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileNameLength ) );

        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileNameLength ) );

        //
        // Set the info level to be used for the NT call.  If
        // SMB_FIND_FILE_NAMES_INFO is the info level, use
        // FileDirectoryInformation as it returns all the correct
        // information and works with SrvQueryDirectoryFile.
        //

        if ( InformationLevel == SMB_INFO_QUERY_EA_SIZE ||
                InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ) {

            ntInformationLevel = FileFullDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
                InformationLevel == SMB_INFO_STANDARD ) {

            ntInformationLevel = FileBothDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ) {

            ntInformationLevel = FileIdFullDirectoryInformation;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {

            ntInformationLevel = FileIdBothDirectoryInformation;

        }
        else {

            //
            // SMB_INFO_QUERY_EAS_FROM_LIST
            // SMB_FIND_NAMES_INFO
            // SMB_FIND_FILE_DIRECTORY_INFO
            //

            ntInformationLevel = FileDirectoryInformation;
        }

        //
        // Call SrvQueryDirectoryFile to get a file.
        //

        status = SrvQueryDirectoryFile(
                     WorkContext,
                     IsFirstCall,
                     filterLongNames,
                     findWithBackupIntent,
                     ntInformationLevel,
                     Search->SearchStorageType,
                     FileName,
                     ResumeFileIndex,
                     SearchAttributes,
                     DirectoryInformation,
                     BufferSize             // !!! optimizations?
                     );

        //
        // If the client requested EA information, open the file.
        //
        // If the found file is '.' (current directory) or '..' (parent
        // directory) do not open the file.  This is because we do not want
        // to perform any operations on these files at this point (don't
        // return EA size, etc.).
        //

        fileBasic = DirectoryInformation->CurrentEntry;
        fileBoth = (PFILE_BOTH_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileFull = (PFILE_FULL_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileIdBoth = (PFILE_ID_BOTH_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileIdFull = (PFILE_ID_FULL_DIR_INFORMATION)DirectoryInformation->CurrentEntry;

        errorOnFileOpen = FALSE;
        createNullEas = FALSE;

        if ( NT_SUCCESS( status ) &&
             InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST &&

             !( ( fileBasic->FileNameLength == sizeof(WCHAR)   &&
                  fileBasic->FileName[0] == '.' )
                       ||
                ( fileBasic->FileNameLength == 2*sizeof(WCHAR)  &&
                  fileBasic->FileName[0] == '.' &&
                  fileBasic->FileName[1] == '.' ) )
            ) {


            UNICODE_STRING fileName;

            //
            // Set up local variables for the filename to open.
            //

            fileName.Length = (SHORT)fileBasic->FileNameLength;
            fileName.MaximumLength = fileName.Length;
            fileName.Buffer = (PWCH)fileBasic->FileName;

            //
            // Set up the object attributes structure for SrvIoCreateFile.
            //

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &fileName,
                (WorkContext->RequestHeader->Flags &
                    SMB_FLAGS_CASE_INSENSITIVE ||
                    WorkContext->Session->UsingUppercasePaths) ?
                    OBJ_CASE_INSENSITIVE : 0L,
                DirectoryInformation->DirectoryHandle,
                NULL
                );

            IF_DEBUG(SEARCH) {
                SrvPrint1( "SrvQueryDirectoryFile: Opening file %wZ\n", &fileName );
            }

            //
            // Attempt to open the file, using the client's security
            // profile to check access.  (We call SrvIoCreateFile, rather than
            // NtOpenFile, in order to get user-mode access checking.)
            //

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         FILE_READ_EA,
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,                        // AllocationSize
                         0,                           // FileAttributes
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN,                   // Disposition
                         0, // FILE_COMPLETE_IF_OPLOCKED,   // CreateOptions
                         NULL,                        // EaBuffer
                         0,                           // EaLength
                         CreateFileTypeNone,          // File type
                         NULL,                        // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,       // Options
                         NULL
                         );
            if ( NT_SUCCESS(status) ) {
                SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 29, Search );

            } else if( RtlCompareUnicodeString( &fileName, &SrvEaFileName, TRUE ) == 0 ) {
                //
                // They were trying to open up the  EA data file.  We expect this
                //   failure and skip past it.  This file has no EAs
                //
                IF_DEBUG(SEARCH) {
                    SrvPrint1( "SrvQueryDirectoryFile: Skipping file %wZ\n", &fileName );
                }
                status = STATUS_SUCCESS;
                goto skipit;
            }

            //
            // If the user didn't have this permission, update the statistics
            // database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            //
            // If the file is oplocked, wait for the oplock to break
            // synchronously.
            //

#if 1
            ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );
#else
            if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {
                status = SrvWaitForOplockBreak( WorkContext, fileHandle );
                if ( !NT_SUCCESS(status) ) {
                    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 45, Search );
                    SrvNtClose( fileHandle, TRUE );
                }
            }
#endif

            if ( !NT_SUCCESS(status) ) {
                errorOnFileOpen = TRUE;
                fileHandle = NULL;

                IF_DEBUG(ERRORS) {
                    SrvPrint2( "Find2Loop: SrvIoCreateFile for file %wZ "
                              "failed: %X\n",
                                  &fileName, status );
                }
            } else {
                SrvStatistics.TotalFilesOpened++;
            }

        } else {
skipit:
            createNullEas = TRUE;
            fileHandle = NULL;
        }

        //
        // If SrvQueryDirectoryFile returns an error, break out of the
        // loop.  If the error occurred in opening the file for one of
        // the higher info levels, then we want to return the files we
        // have obtained so far.
        //
        // If the error occurred on the file open *and* we haven't
        // returned any files yet, then we want to return this file
        // along with the code ERROR_EA_ACCESS_DENIED.
        //

        if ( !NT_SUCCESS(status) ) {

            if ( count == 0 && errorOnFileOpen ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint1( "EA access denied on first file of search (%x).\n",
                                   status );
                }

                fileHandle = NULL;
                status = STATUS_OS2_EA_ACCESS_DENIED;
                break;

            } else if ( status == STATUS_NO_MORE_FILES && count == 0 ) {

                SmbPutUshort( &Response->SearchCount, 0 );
                SmbPutUshort( &Response->EndOfSearch, 0 );
                SmbPutUshort( &Response->EaErrorOffset, 0 );
                SmbPutUshort( &Response->LastNameOffset, 0 );
                Transaction->DataCount = 0;

                return status;

            } else {

                break;
            }
        }

        //
        // Since it is no longer the first call to SrvQueryDirectoryFile,
        // reset the isFirstCall local variable.  If necessary, we already
        // rewound the search, so set the ResumeFileIndex to NULL.
        //

        IsFirstCall = FALSE;
        ResumeFileIndex = NULL;

        IF_SMB_DEBUG(SEARCH2) {
            UNICODE_STRING nameString;

            switch (ntInformationLevel) {
            case FileFullDirectoryInformation:
                nameString.Buffer = fileFull->FileName;
                nameString.Length = (USHORT)fileFull->FileNameLength;
                break;
            case FileBothDirectoryInformation:
                nameString.Buffer = fileBoth->FileName;
                nameString.Length = (USHORT)fileBoth->FileNameLength;
                break;
            default:
                nameString.Buffer = fileBasic->FileName;
                nameString.Length = (USHORT)fileBasic->FileNameLength;
                break;
            }
            SrvPrint4( "SrvQueryDirectoryFile(%ld)-- %p, length=%ld, "
                      "status=%X\n", count,
                      &nameString,
                      nameString.Length,
                      status );
        }

        //
        // Downlevel info levels have no provision for file names longer
        // than 8 bits, while the NT info levels return 32 bits.  If the
        // file name is too long, skip it.
        //

        if ( !allowExtraLongNames ) {
            if ( isUnicode ) {
                if ( fileBasic->FileNameLength > 255 ) {
                    continue;
                }
            } else {
                if ( fileBasic->FileNameLength > 255*sizeof(WCHAR) ) {
                    continue;
                }
            }
        }

        //
        // If the client has requested that resume keys (really file
        // indices for the purposes of this protocol), put in the
        // four bytes just before the actual file information.
        //
        // Make sure that we don't write beyond the buffer when we do
        // this.  The fact that the buffer is full will be caught later.
        //

        if ( resumeKeysRequested &&
             ( (CLONG)( (bufferLocation+4) - Transaction->OutData ) <
                Transaction->MaxDataCount ) ) {

            SmbPutUlong( (PSMB_ULONG)bufferLocation, fileBasic->FileIndex );
            bufferLocation += 4;
        }

        //
        // Convert the information from NT style to the SMB protocol format,
        // which is identical to the OS/2 1.2 semantics.  Use an if
        // statement rather than a switch so that a break will cause
        // termination of the do loop.
        //

        if ( InformationLevel == SMB_INFO_STANDARD ) {

            PSMB_FIND_BUFFER findBuffer = (PSMB_FIND_BUFFER)bufferLocation;
            ULONG fileNameLength;
            UNICODE_STRING fileName;

            //
            // Find the file name.  If a short name is present, and the
            // redirector ask for short names only, use it.  Otherwise
            // use the full file name.
            //

            if ( filterLongNames &&
                 fileBoth->ShortNameLength != 0 ) {

                fileName.Buffer = fileBoth->ShortName;
                fileName.Length = fileBoth->ShortNameLength;
                fileName.MaximumLength = fileBoth->ShortNameLength;

            } else {

                fileName.Buffer = fileBoth->FileName;
                fileName.Length = (USHORT)fileBoth->FileNameLength;
                fileName.MaximumLength = (USHORT)fileBoth->FileNameLength;

            }

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry in
            // the buffer.  The +1 is for the zero terminator on the file
            // name.
            //

            if ( isUnicode ) {
                bufferLocation = ALIGN_SMB_WSTR( findBuffer->FileName );
                bufferLocation += fileName.Length + sizeof(WCHAR);
            } else {
                unicodeString.Buffer = fileName.Buffer;
                unicodeString.Length = fileName.Length;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation = (PCHAR)(findBuffer->FileName + fileNameLength);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileName.Buffer,
                (BOOLEAN)((fileBoth->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                findBuffer
                );

            //
            // Put the file name in the buffer, in Unicode or ANSI
            // depending what was negotiated.
            //

            if ( isUnicode ) {

                PWCH buffer = ALIGN_SMB_WSTR( findBuffer->FileName );

                //
                // We need to upper case the name if the client does
                // not understand long names.  This is done for compatibility
                // reasons (FAT upper cases names).
                //

                if ( filterLongNames ) {

                    (VOID)RtlUpcaseUnicodeString(
                                            &fileName,
                                            &fileName,
                                            FALSE
                                            );

                }


                RtlCopyMemory(
                    buffer,
                    fileName.Buffer,
                    fileName.Length
                    );

                ASSERT(fileName.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)fileName.Length;

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PCHAR)findBuffer->FileName;

                //
                // We need to upper case the name if the client does
                // not understand long names.  This is done for compatibility
                // reasons (FAT upper cases names).
                //

                if ( filterLongNames ) {
                    status = RtlUpcaseUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );

                } else {
                    status = RtlUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );

                }

                ASSERT( NT_SUCCESS(status) );

                ASSERT(oemString.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)oemString.Length;
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileName.Buffer;
            lastFileName.Length = (USHORT)fileName.Length;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBoth->FileIndex;

        } else if ( InformationLevel == SMB_INFO_QUERY_EA_SIZE ) {

            PSMB_FIND_BUFFER2 findBuffer = (PSMB_FIND_BUFFER2)bufferLocation;
            ULONG fileNameLength;

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry in
            // the buffer.  The +1 is for the zero terminator on the file
            // name.
            //

            if ( isUnicode ) {
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileFull->FileNameLength + 1);
            } else {
                unicodeString.Buffer = fileFull->FileName;
                unicodeString.Length = (USHORT)fileFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation = (PCHAR)(findBuffer->FileName + fileNameLength);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileFull->FileName,
                (BOOLEAN)((fileFull->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                (PSMB_FIND_BUFFER)findBuffer
                );

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileFull->FileName,
                    fileFull->FileNameLength
                    );

                ASSERT(fileFull->FileNameLength <= 255);

                findBuffer->FileNameLength = (UCHAR)fileFull->FileNameLength;

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PCHAR)(findBuffer->FileName);
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );

                ASSERT(oemString.Length <= 255);

                findBuffer->FileNameLength = (UCHAR)oemString.Length;
            }

            if ( fileFull->EaSize == 0) {
                SmbPutUlong( &findBuffer->EaSize, 4 );
            } else {
                SmbPutUlong( &findBuffer->EaSize, fileFull->EaSize );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileFull->FileName;
            lastFileName.Length = (USHORT)fileFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileFull->FileIndex;

        } else if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {

            PSMB_FIND_BUFFER2 findBuffer = (PSMB_FIND_BUFFER2)bufferLocation;
            PFEALIST feaList;
            PCHAR fileNameInfo;
            ULONG fileNameLength;

            //
            // Find the new buffer location.  This is not used until the
            // next pass through the loop, but we do it here in order to
            // check if there is enough space for the current file entry
            // in the buffer.  The +1 is for the zero terminator on the
            // file name.  A check is made later on to see if the EAs
            // actually fit, and the bufferLocation variable is reset to
            // account for the actual size of the EA.
            //

            if ( isUnicode ) {
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileBasic->FileNameLength + 1);
            } else {
                unicodeString.Buffer = fileBasic->FileName;
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
                bufferLocation =
                    (PCHAR)(findBuffer->FileName + fileNameLength + 1);
            }

            //
            // Make sure that there is enough space in the buffer before
            // writing the filename.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 46, Search );
                SrvNtClose( fileHandle, TRUE );
                fileHandle = NULL;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Put information about the file into the SMB buffer.
            //

            ConvertFileInfo(
                fileBasic,
                fileBasic->FileName,
                (BOOLEAN)((fileBasic->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0),
                isUnicode,
                (PSMB_FIND_BUFFER)findBuffer
                );

            //
            // Get the EAs corresponding to the GEA list passed by the
            // client.
            //

            feaList = (PFEALIST)&findBuffer->EaSize;

            if ( ( fileHandle != NULL ) || createNullEas ) {

                if ( fileHandle != NULL ) {

                    //
                    // Get the file's EAs.  The buffer space available is
                    // the space remaining in the buffer less enough space
                    // to write the file name, name length, and zero
                    // terminator.
                    //

                    status = SrvQueryOs2FeaList(
                                 fileHandle,
                                 NULL,
                                 ntGetEa,
                                 ntGetEaLength,
                                 feaList,
                                 (Transaction->MaxDataCount -
                                     (ULONG)( (PCHAR)feaList - Transaction->OutData ) -
                                     fileBasic->FileNameLength - 2),
                                 &eaErrorOffset
                                 );

                    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 47, Search );
                    SrvNtClose( fileHandle, TRUE );

                } else {

                    //
                    // if file is . or .. or "EA DATA. SF"
                    //

                    status = SrvConstructNullOs2FeaList(
                                 ntGetEa,
                                 feaList,
                                 (Transaction->MaxDataCount -
                                  (ULONG)( (PCHAR)feaList - Transaction->OutData ) -
                                     fileBasic->FileNameLength - 2)
                                 );

                }

                if ( !NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW ) {

                    IF_DEBUG(ERRORS) {
                        SrvPrint1( "SrvQueryOs2FeaList failed, status = %X\n",
                                      status );
                    }

                    //
                    // If this is the first file, return it anyway with
                    // an error code.
                    //

                    if ( status == STATUS_INVALID_EA_NAME ) {
                        SmbPutUshort( &Response->SearchCount, 0 );
                        SmbPutUshort( &Response->EndOfSearch, 0 );
                        SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
                        SmbPutUshort( &Response->LastNameOffset, 0 );
                        Transaction->DataCount = 0;
                        return status;
                    }

                    if ( count == 0 ) {
                        status = STATUS_OS2_EA_ACCESS_DENIED;
                        SmbPutUlong( &findBuffer->EaSize, 0 );
                    } else {
                        break;
                    }
                }

                //
                // We already checked to see if the information other
                // than EAs would fit in the buffer.  If the EAs didn't
                // fit as well, and this is the first file, then return
                // information on this file but no EAs.  Return
                // STATUS_OS2_EAS_DIDNT_FIT.  The EA size of the file
                // should be in the EaSize field of the output buffer,
                // put there by SrvQueryOs2FeaList.
                //
                // Also do this if we couldn't get at the file's EAs.
                //

                if ( count == 0 &&
                     ( status == STATUS_BUFFER_OVERFLOW ||
                       status == STATUS_OS2_EA_ACCESS_DENIED ) ) {

                    IF_DEBUG(ERRORS) {
                        SrvPrint0( "First file's EAs would not fit.\n" );
                    }

                    count = 1;

                    //
                    // Write the file name information (length and name).
                    //

                    if ( isUnicode ) {

                        RtlCopyMemory(
                            (PVOID) (&findBuffer->FileNameLength + 1),
                            fileBasic->FileName,
                            fileBasic->FileNameLength
                            );

                        findBuffer->FileNameLength = (UCHAR)fileBasic->FileNameLength;
                        bufferLocation = (PCHAR)
                            (findBuffer->FileName + fileBasic->FileNameLength + 1);

                    } else {

                        NTSTATUS rtlStatus;

                        oemString.MaximumLength = (USHORT)fileNameLength;
                        oemString.Buffer =
                                (PUCHAR)(&findBuffer->FileNameLength + 1);
                        rtlStatus = RtlUnicodeStringToOemString(
                                     &oemString,
                                     &unicodeString,
                                     FALSE
                                     );
                        ASSERT( NT_SUCCESS(rtlStatus) );

                        findBuffer->FileNameLength = (UCHAR)oemString.Length;
                        bufferLocation = (PCHAR)
                            (findBuffer->FileName + oemString.Length + 1);
                    }

                    lastEntry = (PCHAR)findBuffer;
                    lastFileName.Buffer = fileBasic->FileName;
                    lastFileName.Length = (USHORT)fileBasic->FileNameLength;
                    lastFileName.MaximumLength = lastFileName.Length;
                    lastFileIndex = fileBasic->FileIndex;

                    if ( status == STATUS_BUFFER_OVERFLOW ) {
                        status = STATUS_OS2_EAS_DIDNT_FIT;
                    }

                    break;
                }

            } else {

                SmbPutUlong( &feaList->cbList, sizeof(feaList->cbList) );

            }

            //
            // Make sure that there is enough buffer space to write the
            // file name and name size.  The +2 is to account for the
            // file name size field and the zero terminator.
            //

            fileNameInfo = (PCHAR)feaList->list +
                               SmbGetUlong( &feaList->cbList ) -
                               sizeof(feaList->cbList);
            if ( isUnicode ) {
                bufferLocation = fileNameInfo + fileBasic->FileNameLength + 2;
            } else {
                bufferLocation = fileNameInfo + fileNameLength + 1;
            }


            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Write the file name information (length and name).
            //

            if ( isUnicode ) {

                RtlCopyMemory(
                    fileNameInfo + 1,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                NTSTATUS rtlStatus;

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = fileNameInfo + 1;
                rtlStatus = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(rtlStatus) );
            }

            *fileNameInfo++ = (UCHAR)oemString.Length;

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "EA size is %ld\n", SmbGetUlong( &feaList->cbList ) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ) {

            FILE_DIRECTORY_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBasic->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBasic->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                                 FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName ) +
                                 fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileBasic,
                FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ) {

            FILE_FULL_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileFull->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileFull->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_FULL_DIR_INFORMATION, FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileFull,
                FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileFull->FileName,
                    fileFull->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileFull->FileName;
            lastFileName.Length = (USHORT)fileFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileFull->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ) {

            FILE_BOTH_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBoth->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBoth->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBoth->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileBoth,
                FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBoth->FileName,
                    fileBoth->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBoth->FileName;
            lastFileName.Length = (USHORT)fileBoth->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBoth->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_NAMES_INFO ) {

            PFILE_NAMES_INFORMATION findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBasic->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBasic->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBasic->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_NAMES_INFORMATION,FileName) +
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            findBuffer->FileIndex = fileBasic->FileIndex;

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBasic->FileName,
                    fileBasic->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBasic->FileName;
            lastFileName.Length = (USHORT)fileBasic->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBasic->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO ) {

            FILE_ID_FULL_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileIdFull->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileIdFull->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileIdFull->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET(FILE_ID_FULL_DIR_INFORMATION, FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileIdFull,
                FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileIdFull->FileName,
                    fileIdFull->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileIdFull->FileName;
            lastFileName.Length = (USHORT)fileIdFull->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileIdFull->FileIndex;

        } else if ( InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {

            FILE_ID_BOTH_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileIdBoth->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileIdBoth->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileIdBoth->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileIdBoth,
                FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileIdBoth->FileName,
                    fileIdBoth->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileIdBoth->FileName;
            lastFileName.Length = (USHORT)fileIdBoth->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileIdBoth->FileIndex;
        }

        count++;

        if ( status == STATUS_OS2_EA_ACCESS_DENIED ) {
            break;
        }

    } while ( count < MaxCount );

    IF_SMB_DEBUG(SEARCH2) {

        SrvPrint0( "Stopped putting entries in buffer.  Reason:\n" );

        if ( !NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW ) {
            SrvPrint1( "    status = %X\n", status );
        } else if ( count >= MaxCount ) {
            SrvPrint2( "    count = %ld, maxCount = %ld\n", count, MaxCount );
        } else {
            SrvPrint3( "    buffer location = 0x%p, trans->OD = 0x%p, "
                      "trans->MaxOD = 0x%lx\n", bufferLocation,
                          Transaction->OutData, Transaction->MaxDataCount );
        }
    }

    //
    // Deallocate the pool used for the NT get EA list if this was the
    // right information level.
    //

    if ( InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ) {
        DEALLOCATE_NONPAGED_POOL( ntGetEa );
    }

    //
    // If we have not found any files and an error occurred, or the first
    // file file we found had EAs to large to fit in the buffer, then return
    // the error to the client.  If an error occurred and we have found
    // files, return what we have found.
    //

    if ( count == 0 && !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "Find2 processing error; status = %X\n", status );
        }

        SrvSetSmbError( WorkContext, status );
        return status;

    } else if ( count == 1 &&
                ( status == STATUS_OS2_EAS_DIDNT_FIT ||
                  status == STATUS_OS2_EA_ACCESS_DENIED ) ) {

        PVOID temp;

        temp = WorkContext->ResponseParameters;
        SrvSetSmbError( WorkContext, status );
        WorkContext->ResponseParameters = temp;

        status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS(status) && status != STATUS_NO_MORE_FILES ) {

        status = STATUS_SUCCESS;
    }

    //
    // If this is a level for the SMB 4.0 protocol (NT), set the
    // NextEntryOffset field of the last entry to zero.
    //

    if ( InformationLevel == SMB_FIND_FILE_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_FULL_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_NAMES_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ||
             InformationLevel == SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO ) {

        ((PFILE_DIRECTORY_INFORMATION)lastEntry)->NextEntryOffset = 0;
    }

    //
    // At the end of the loop, bufferLocation points to the first location
    // AFTER the last entry we wrote, so it may be used to find the total
    // number of data bytes that we intend to return.
    //

    totalBytesWritten = PTR_DIFF(bufferLocation, Transaction->OutData);

    //
    // Free the buffer that holds the last file name if it was in use,
    // then allocate a new one and store the name and index of the last
    // file returned in the search block so that it can resume the search
    // if the client requests.
    //

    if ( Search->LastFileNameReturned.Buffer != NULL ) {
        FREE_HEAP( Search->LastFileNameReturned.Buffer );
    }

    Search->LastFileNameReturned.Buffer =
        ALLOCATE_HEAP_COLD(
            lastFileName.Length,
            BlockTypeDataBuffer
            );

    if ( Search->LastFileNameReturned.Buffer == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFind2Loop: unable to allocate %d bytes from heap.",
            lastFileName.Length,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    Search->LastFileNameReturned.Length = lastFileName.Length;
    Search->LastFileNameReturned.MaximumLength = lastFileName.Length;

    RtlCopyMemory(
        Search->LastFileNameReturned.Buffer,
        lastFileName.Buffer,
        lastFileName.Length
        );

    Search->LastFileIndexReturned = lastFileIndex;

    //
    // Put data in the response SMB.
    //

    SmbPutUshort( &Response->SearchCount, count );
    SmbPutUshort(
        &Response->EndOfSearch,
        (USHORT)(status == STATUS_NO_MORE_FILES)
        );
    SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );
    SmbPutUshort(
        &Response->LastNameOffset,
        (USHORT)(lastEntry - Transaction->OutData)
        );
    Transaction->DataCount = totalBytesWritten;

    return status;

} // SrvFind2Loop

NTSTATUS
SrvDownlevelTWarpFind2Loop (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT Flags,
    IN USHORT InformationLevel,
    IN PTRANSACTION Transaction,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize,
    IN USHORT SearchAttributes,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN USHORT MaxCount,
    IN PRESP_FIND_NEXT2 Response,
    OUT PSEARCH Search
    )

/*++

Routine Description:

    This routine does the looping necessary to get files and put them
    into an SMB buffer for the Find First2 and Find Next2 transaction
    protocols.

Arguments:

    WorkContext -

    IsFirstCall - TRUE if this is a Find First and this is the first call
        to SrvQueryDirectoryFile.

    ResumeFileIndex - if non-NULL, a pointer to the file index to resume
        from.

    Flags - the Flags field of the request SMB.

    InformationLevel - the InformationLevel field of the request SMB.  The
        validity of this value should be verified by the calling routine.

    Transaction - a pointer to the transaction block to use.

    DirectoryInformation - a pointer to the SRV_DIRECTORY_INFORMATION
        structure to use.

    BufferSize - size of the DirectoryInformation buffer.

    SearchAttributes - the SMB-style attributes to pass to
        SrvQueryDirectoryFile.

    FileName - if non-NULL the file name to resume the search from.

    MaxCount - the maximum number of files to get.

    Response - a pointer to the response field of the SMB.  If this is
        a Find First2, it is a pointer to the SearchCount field of the
        response SMB--Find First2 and Find Next2 response formats are
        identical from this point on.

    Search - a pointer to the search block to use.

Return Value:

    NTSTATUS indicating results.

--*/

{
    NTSTATUS status;

    PCHAR bufferLocation;
    BOOLEAN resumeKeysRequested;
    BOOLEAN allowExtraLongNames;
    BOOLEAN isUnicode;
    USHORT count = 0;
    PCHAR lastEntry;
    CLONG totalBytesWritten;
    OEM_STRING oemString;
    UNICODE_STRING unicodeString;
    UNICODE_STRING lastFileName;
    ULONG lastFileIndex = (ULONG)0xFFFFFFFF;
    HANDLE fileHandle;
    BOOLEAN filterLongNames;
    BOOLEAN errorOnFileOpen;
    BOOLEAN findWithBackupIntent;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN createNullEas;

    PAGED_CODE( );

    //
    // If the client is requesting an NT info level for search information,
    // do not return resume keys outside the actual file entry.  Resume
    // keys (aka FileIndex) are part of every NT info structure.
    //
    // Also, for NT info levels we can return file names longer than 255
    // bytes, because the NT info levels have name length fields that
    // are four bytes wide, whereas the downlevel info levels only have
    // one-byte name length fields.
    //

    if ( InformationLevel == SMB_FIND_FILE_BOTH_DIRECTORY_INFO ) {

        resumeKeysRequested = FALSE;
        allowExtraLongNames = TRUE;

    } else {

        SmbPutUshort( &Response->SearchCount, 0 );
        SmbPutUshort( &Response->EndOfSearch, 0 );
        SmbPutUshort( &Response->EaErrorOffset, 0 );
        SmbPutUshort( &Response->LastNameOffset, 0 );
        Transaction->DataCount = 0;

        return STATUS_INVALID_PARAMETER;
    }

    isUnicode = SMB_IS_UNICODE( WorkContext );
    filterLongNames = FALSE;

    //
    // Initialize count of files found.
    //

    SmbPutUshort( &Response->SearchCount, 0 );

    //
    // Loop calling SrvQueryDirectoryFile to get files.  We do this until
    // one of the following conditions is met:
    //
    //   1) There are no more files to return.
    //   2) We have obtained as many files as were requested.
    //   3) We have put in as much data as MaxDataCount allows.
    //

    bufferLocation = Transaction->OutData;
    lastEntry = bufferLocation;
    totalBytesWritten = 0;
    DirectoryInformation->DownlevelTimewarp = TRUE;

    do {

        //
        // The ff fields have the same offsets in the three directory
        // information structures:
        //      NextEntryOffset
        //      FileIndex
        //      CreationTime
        //      LastAccessTime
        //      LastWriteTime
        //      ChangeTime
        //      EndOfFile
        //      AllocationSize
        //      FileAttributes
        //      FileNameLength
        //

        PFILE_BOTH_DIR_INFORMATION fileBoth;
        PFILE_DIRECTORY_INFORMATION fileBasic;
        ULONG ntInformationLevel;

        ntInformationLevel = FileBothDirectoryInformation;

        //
        // Call SrvQueryDirectoryFile to get a file.
        //

        status = SrvDownlevelTWarpQueryDirectoryFile(
                     WorkContext,
                     IsFirstCall,
                     filterLongNames,
                     FALSE,
                     ntInformationLevel,
                     Search->SearchStorageType,
                     FileName,
                     ResumeFileIndex,
                     SearchAttributes,
                     DirectoryInformation,
                     BufferSize             // !!! optimizations?
                     );

        fileBoth = (PFILE_BOTH_DIR_INFORMATION)DirectoryInformation->CurrentEntry;
        fileBasic = DirectoryInformation->CurrentEntry;

        errorOnFileOpen = FALSE;
        createNullEas = FALSE;

        //
        // If SrvQueryDirectoryFile returns an error, break out of the
        // loop.  If the error occurred in opening the file for one of
        // the higher info levels, then we want to return the files we
        // have obtained so far.
        //
        // If the error occurred on the file open *and* we haven't
        // returned any files yet, then we want to return this file
        // along with the code ERROR_EA_ACCESS_DENIED.
        //

        if ( !NT_SUCCESS(status) ) {

            if ( count == 0 && errorOnFileOpen ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint1( "EA access denied on first file of search (%x).\n",
                                   status );
                }

                fileHandle = NULL;
                status = STATUS_OS2_EA_ACCESS_DENIED;
                break;

            } else if ( status == STATUS_NO_MORE_FILES && count == 0 ) {

                SmbPutUshort( &Response->SearchCount, 0 );
                SmbPutUshort( &Response->EndOfSearch, 0 );
                SmbPutUshort( &Response->EaErrorOffset, 0 );
                SmbPutUshort( &Response->LastNameOffset, 0 );
                Transaction->DataCount = 0;

                return status;

            } else {

                break;
            }
        }

        //
        // Since it is no longer the first call to SrvQueryDirectoryFile,
        // reset the isFirstCall local variable.  If necessary, we already
        // rewound the search, so set the ResumeFileIndex to NULL.
        //

        IsFirstCall = FALSE;
        ResumeFileIndex = NULL;

        //
        // If the client has requested that resume keys (really file
        // indices for the purposes of this protocol), put in the
        // four bytes just before the actual file information.
        //
        // Make sure that we don't write beyond the buffer when we do
        // this.  The fact that the buffer is full will be caught later.
        //

        if ( resumeKeysRequested &&
             ( (CLONG)( (bufferLocation+4) - Transaction->OutData ) <
                Transaction->MaxDataCount ) ) {

            SmbPutUlong( (PSMB_ULONG)bufferLocation, fileBasic->FileIndex );
            bufferLocation += 4;
        }

        {

            FILE_BOTH_DIR_INFORMATION UNALIGNED *findBuffer = (PVOID)bufferLocation;
            ULONG fileNameLength;

            //
            // If the client is not speaking Unicode, we need to convert
            // the file name to ANSI.
            //

            if ( isUnicode ) {
                fileNameLength = fileBoth->FileNameLength;
            } else {
                unicodeString.Length = (USHORT)fileBoth->FileNameLength;
                unicodeString.MaximumLength = unicodeString.Length;
                unicodeString.Buffer = fileBoth->FileName;
                fileNameLength = RtlUnicodeStringToOemSize( &unicodeString );
            }

            //
            // Find the new buffer location.  It won't be used until the
            // next pass through the loop, but we need to make sure that
            // this entry will fit.
            //

            bufferLocation = bufferLocation +
                             FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,FileName)+
                             fileNameLength;

            bufferLocation = (PCHAR)(((ULONG_PTR)bufferLocation + 7) & ~7);

            //
            // Check whether this entry will fit in the output buffer.
            //

            if ( (CLONG)(bufferLocation - Transaction->OutData) >
                     Transaction->MaxDataCount ) {

                status = STATUS_BUFFER_OVERFLOW;
                bufferLocation = (PCHAR)findBuffer;
                break;
            }

            //
            // Copy over the information about the entry.
            //

            RtlCopyMemory(
                findBuffer,
                fileBoth,
                FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName )
                );

            findBuffer->NextEntryOffset =
                PTR_DIFF(bufferLocation, findBuffer);
            findBuffer->FileNameLength = fileNameLength;

            if ( isUnicode ) {

                RtlCopyMemory(
                    findBuffer->FileName,
                    fileBoth->FileName,
                    fileBoth->FileNameLength
                    );

            } else {

                oemString.MaximumLength = (USHORT)fileNameLength;
                oemString.Buffer = (PSZ)findBuffer->FileName;
                status = RtlUnicodeStringToOemString(
                             &oemString,
                             &unicodeString,
                             FALSE
                             );
                ASSERT( NT_SUCCESS(status) );
            }

            //
            // The lastEntry variable holds a pointer to the last file entry
            // that we wrote--an offset to this entry must be returned
            // in the response SMB.
            //

            lastEntry = (PCHAR)findBuffer;

            //
            // The file name and index of the last file returned must be
            // stored in the search block.  Save the name pointer, length,
            // and file index here.
            //

            lastFileName.Buffer = fileBoth->FileName;
            lastFileName.Length = (USHORT)fileBoth->FileNameLength;
            lastFileName.MaximumLength = lastFileName.Length;
            lastFileIndex = fileBoth->FileIndex;

        }

        count++;

        if ( status == STATUS_OS2_EA_ACCESS_DENIED ) {
            break;
        }

    } while ( count < MaxCount );

    //
    // If we have not found any files and an error occurred, or the first
    // file file we found had EAs to large to fit in the buffer, then return
    // the error to the client.  If an error occurred and we have found
    // files, return what we have found.
    //

    if ( count == 0 && !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "Find2 processing error; status = %X\n", status );
        }

        SrvSetSmbError( WorkContext, status );
        return status;

    } else if ( count == 1 &&
                ( status == STATUS_OS2_EAS_DIDNT_FIT ||
                  status == STATUS_OS2_EA_ACCESS_DENIED ) ) {

        PVOID temp;

        temp = WorkContext->ResponseParameters;
        SrvSetSmbError( WorkContext, status );
        WorkContext->ResponseParameters = temp;

        status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS(status) && status != STATUS_NO_MORE_FILES ) {

        status = STATUS_SUCCESS;
    }

    //
    // If this is a level for the SMB 4.0 protocol (NT), set the
    // NextEntryOffset field of the last entry to zero.
    //

    ((PFILE_DIRECTORY_INFORMATION)lastEntry)->NextEntryOffset = 0;

    //
    // At the end of the loop, bufferLocation points to the first location
    // AFTER the last entry we wrote, so it may be used to find the total
    // number of data bytes that we intend to return.
    //

    totalBytesWritten = PTR_DIFF(bufferLocation, Transaction->OutData);

    //
    // Free the buffer that holds the last file name if it was in use,
    // then allocate a new one and store the name and index of the last
    // file returned in the search block so that it can resume the search
    // if the client requests.
    //

    if ( Search->LastFileNameReturned.Buffer != NULL ) {
        FREE_HEAP( Search->LastFileNameReturned.Buffer );
    }

    Search->LastFileNameReturned.Buffer =
        ALLOCATE_HEAP_COLD(
            lastFileName.Length,
            BlockTypeDataBuffer
            );

    if ( Search->LastFileNameReturned.Buffer == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFind2Loop: unable to allocate %d bytes from heap.",
            lastFileName.Length,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    Search->LastFileNameReturned.Length = lastFileName.Length;
    Search->LastFileNameReturned.MaximumLength = lastFileName.Length;

    RtlCopyMemory(
        Search->LastFileNameReturned.Buffer,
        lastFileName.Buffer,
        lastFileName.Length
        );

    Search->LastFileIndexReturned = lastFileIndex;

    //
    // Put data in the response SMB.
    //

    SmbPutUshort( &Response->SearchCount, count );
    SmbPutUshort(
        &Response->EndOfSearch,
        (USHORT)(status == STATUS_NO_MORE_FILES)
        );
    SmbPutUshort( &Response->EaErrorOffset, 0 );
    SmbPutUshort(
        &Response->LastNameOffset,
        (USHORT)(lastEntry - Transaction->OutData)
        );
    Transaction->DataCount = totalBytesWritten;

    return status;

} // SrvDownlevelTWarpFind2Loop



VOID
ConvertFileInfo (
    IN PFILE_DIRECTORY_INFORMATION File,
    IN PWCH FileName,
    IN BOOLEAN Directory,
    IN BOOLEAN ClientIsUnicode,
    OUT PSMB_FIND_BUFFER FindBuffer
    )

/*++

Routine Description:

    This routine does the looping necessary to get files and put them
    into an SMB buffer for the Find First2 and Find Next2 transaction
    protocols.

Arguments:

    File - a pointer to the structure containing the information about
        the file.

    FileName - name of the file.

    Directory - a boolean indicating whether it is a file or directory.
        The existence of this field allows File to point to a
        FILE_FULL_DIR_INFORMATION structure if necessary.

    FileBuffer - where to write the results in OS/2 format.

Return Value:

    None

--*/

{
    SMB_DATE smbDate;
    SMB_TIME smbTime;
    USHORT smbFileAttributes;
    UNICODE_STRING unicodeString;

    PAGED_CODE( );

    //
    // Convert the various times from NT format to SMB format.
    //

    SrvTimeToDosTime( &File->CreationTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->CreationDate, smbDate );
    SmbPutTime( &FindBuffer->CreationTime, smbTime );

    SrvTimeToDosTime( &File->LastAccessTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->LastAccessDate, smbDate );
    SmbPutTime( &FindBuffer->LastAccessTime, smbTime );

    SrvTimeToDosTime( &File->LastWriteTime, &smbDate, &smbTime );
    SmbPutDate( &FindBuffer->LastWriteDate, smbDate );
    SmbPutTime( &FindBuffer->LastWriteTime, smbTime );

    //
    // SMB protocol only allows 32-bit file sizes.  Only return the low
    // 32 bits, and too bad if the file is larger.
    //

    SmbPutUlong( &FindBuffer->DataSize, File->EndOfFile.LowPart );
    SmbPutUlong(
        &FindBuffer->AllocationSize,
        File->AllocationSize.LowPart
        );

    SRV_NT_ATTRIBUTES_TO_SMB(
        File->FileAttributes,
        Directory,
        &smbFileAttributes
        );

    SmbPutUshort( &FindBuffer->Attributes, smbFileAttributes );

    if ( ClientIsUnicode ) {
        FindBuffer->FileNameLength = (UCHAR)(File->FileNameLength);
    } else {
        unicodeString.Buffer = FileName;
        unicodeString.Length = (USHORT)File->FileNameLength;
        unicodeString.MaximumLength = unicodeString.Length;
        FindBuffer->FileNameLength =
            (UCHAR)RtlUnicodeStringToOemSize( &unicodeString );
    }

    return;

} // ConvertFileInfo


SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindClose2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Find Close2 SMB.  This SMB is used to
    close a search started by a Find First2 transaction.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PSEARCH search;
    PSESSION session;
    SRV_DIRECTORY_INFORMATION directoryInformation;
    USHORT sid;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_FIND_CLOSE2 request;
    PRESP_FIND_CLOSE2 response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FIND_CLOSE2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint2( "Find Close2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Find Close2 request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_FIND_CLOSE2)WorkContext->RequestParameters;
    response = (PRESP_FIND_CLOSE2)WorkContext->ResponseParameters;


    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbSearch: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
    }

    //
    // Get the search block corresponding to this SID.  SrvVerifySid
    // references the search block.
    //

    sid = SmbGetUshort( &request->Sid );

    search = SrvVerifySid(
                 WorkContext,
                 SID_INDEX2( sid ),
                 SID_SEQUENCE2( sid ),
                 &directoryInformation,
                 sizeof(SRV_DIRECTORY_INFORMATION)
                 );

    if ( search == NULL ) {

        IF_DEBUG(SMB_ERRORS) SrvPrint0( "SrvSmbFindClose2: Invalid SID.\n" );

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        status    = STATUS_INVALID_HANDLE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Close the query directory and the search, then dereference our
    // pointer to the search block.
    //

    search->DirectoryHandle = NULL;
    SrvCloseSearch( search );
    SrvCloseQueryDirectory( &directoryInformation );
    SrvDereferenceSearch( search );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_FIND_CLOSE2,
                                          0
                                          );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbFindClose2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smblock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smblock.c

Abstract:

    This module contains routines for processing the following SMBs:

        Lock Byte Range
        Unlock Byte Range
        Locking and X

    The SMB commands "Lock and Read" and "Write and Unlock" are
    processed in smbrdwrt.c.

Author:

    Chuck Lenzmeier (chuckl) 26-Apr-1990

Revision History:

    29-Aug-1991 mannyw


--*/

#include "precomp.h"
#include "smblock.tmh"
#pragma hdrstop

#if SRVDBG_PERF
UCHAR LockBypass = 0;
BOOLEAN LockWaitForever = 0;
ULONG LockBypassConst = 0x10000000;
ULONG LockBypassMirror = 0x01000000;
#endif

//
// Forward declarations
//

BOOLEAN
CancelLockRequest (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT TargetFid,
    IN USHORT TargetPid,
    IN LARGE_INTEGER TargetOffset,
    IN LARGE_INTEGER TargetLength
    );

VOID
DoLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN SkipFastPath
    );

STATIC
BOOLEAN
ProcessOplockBreakResponse(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN PREQ_LOCKING_ANDX Request
    );

STATIC
VOID SRVFASTCALL
RestartLockByteRange (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbLockByteRange )
#pragma alloc_text( PAGE, RestartLockByteRange )
#pragma alloc_text( PAGE, ProcessOplockBreakResponse )
#pragma alloc_text( PAGE, SrvSmbUnlockByteRange )
#pragma alloc_text( PAGE, SrvSmbLockingAndX )
#pragma alloc_text( PAGE, DoLockingAndX )
#pragma alloc_text( PAGE, RestartLockingAndX )
#pragma alloc_text( PAGE, SrvAcknowledgeOplockBreak )
#pragma alloc_text( PAGE8FIL, CancelLockRequest )
#pragma alloc_text( PAGE8FIL, TimeoutLockRequest )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockByteRange (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Lock Byte Range SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_LOCK_BYTE_RANGE request;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN failImmediately;

    PRFCB rfcb;
    PLFCB lfcb;
    PSRV_TIMER timer;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_BYTE_RANGE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_LOCK_BYTE_RANGE)WorkContext->RequestParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    fid = SmbGetUshort( &request->Fid );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockByteRange: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has lock access to the file via the
    // specified handle.
    //

    if ( rfcb->LockAccessGranted && rfcb->ExclusiveLockGranted ) {

        //
        // Get the offset and length of the range being locked.  Combine
        // the FID with the caller's PID to form the local lock key.
        //
        // *** The FID must be included in the key in order to account
        //     for the folding of multiple remote compatibility mode
        //     opens into a single local open.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );
        length.QuadPart = SmbGetUlong( &request->Count );

        key = rfcb->ShiftedFid |
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

        IF_SMB_DEBUG(LOCK1) {
            KdPrint(( "Lock request; FID 0x%lx, count %ld, offset %ld\n",
                        fid, length.LowPart, offset.LowPart ));
        }

        rfcb = WorkContext->Rfcb;
        lfcb = rfcb->Lfcb;

        IF_SMB_DEBUG(LOCK2) {
            KdPrint(( "SrvSmbLockByteRange: Locking in file 0x%p: (%ld,%ld), key 0x%lx\n",
                        lfcb->FileObject, offset.LowPart, length.LowPart, key ));
        }

        //
        // Try the turbo lock path first.  If the client is retrying the
        // lock that just failed, or if the lock is above the
        // always-wait limit we want FailImmediately to be FALSE, so
        // that the fast path fails if there's a conflict.
        //

        failImmediately = (BOOLEAN)(
            (offset.QuadPart != rfcb->PagedRfcb->LastFailingLockOffset.QuadPart)
            &&
            (offset.QuadPart < SrvLockViolationOffset) );

        if ( lfcb->FastIoLock != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

            if ( lfcb->FastIoLock(
                    lfcb->FileObject,
                    &offset,
                    &length,
                    IoGetCurrentProcess(),
                    key,
                    failImmediately,
                    TRUE,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The turbo path worked.  Call the restart routine
                // directly.
                //

                WorkContext->Parameters.Lock.Timer = NULL;
                RestartLockByteRange( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );

        }

        //
        // The turbo path failed (or didn't exist).  Start the lock request,
        // reusing the receive IRP.  If the client is retrying the lock that
        // just failed, start a timer for the request.
        //

        timer = NULL;
        if ( !failImmediately ) {
            timer = SrvAllocateTimer( );
            if ( timer == NULL ) {
                failImmediately = TRUE;
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            offset,                             // byte offset
            length,                             // range length
            key,                                // lock key
            failImmediately,
            TRUE                                // exclusive lock?
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLockByteRange;

        //
        // Start the timer, if necessary.
        //

        WorkContext->Parameters.Lock.Timer = timer;
        if ( timer != NULL ) {
            SrvSetTimer(
                timer,
                &SrvLockViolationDelayRelative,
                TimeoutLockRequest,
                WorkContext
                );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockByteRange complete\n" ));
        SmbStatus = SmbStatusInProgress;
    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockByteRange: Lock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockByteRange


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockingAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Locking and X SMB.  This SMB is used to unlock zero
    or more ranges, then lock zero or more ranges.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_LOCKING_ANDX request;
    PRESP_LOCKING_ANDX response;

    PNTLOCKING_ANDX_RANGE largeRange;
    PLOCKING_ANDX_RANGE smallRange;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    USHORT pid;
    ULONG unlockCount;
    ULONG lockCount;
    ULONG maxPossible;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    ULONG lockTimeout;
    BOOLEAN oplockBreakResponse = FALSE;
    BOOLEAN largeFileLock;
    BOOLEAN exclusiveLock;

    UCHAR nextCommand;
    USHORT reqAndXOffset;

    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;

    PREQ_CLOSE closeRequest;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCKING_AND_X;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
    response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;

    //
    // Get the FID, which is combined with the PIDs in the various
    // lock/unlock ranges to form the local lock key.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(LOCK1) {
        unlockCount = SmbGetUshort( &request->NumberOfUnlocks );
        lockCount = SmbGetUshort( &request->NumberOfLocks );
        KdPrint(( "Locking and X request; FID 0x%lx, Unlocks: %ld, "
                    "Locks: %ld\n", fid, unlockCount, lockCount ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockingAndX: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

start_lockingAndX:

    //
    // Loop through the unlock ranges.
    //

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Ensure the SMB is big enough to hold all of the requests
    //

    unlockCount = SmbGetUshort( &request->NumberOfUnlocks );
    lockCount = SmbGetUshort( &request->NumberOfLocks );

    //
    // Find out how many entries could possibly be in this smb
    //
    maxPossible = (ULONG)(((PCHAR)WorkContext->RequestBuffer->Buffer +
                           WorkContext->RequestBuffer->DataLength) -
                           (PCHAR)request->Buffer);

    if( largeFileLock ) {
        maxPossible /= sizeof( NTLOCKING_ANDX_RANGE );
        largeRange = (PNTLOCKING_ANDX_RANGE)request->Buffer;
    } else {
        maxPossible /= sizeof( LOCKING_ANDX_RANGE );
        smallRange = (PLOCKING_ANDX_RANGE)request->Buffer;
    }

    //
    // If the request holds more than could possibly be in this SMB, return
    //  and error
    //
    if( unlockCount + lockCount > maxPossible ) {
        //
        // They don't all fit!
        //

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvSmbLockingAndX: unlockCount %u, lockCount %u, maxPossible %u\n",
                        unlockCount, lockCount, maxPossible ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If an Unlock is being requested, verify that the client has
    // unlock access to the file via the specified handle.
    //

    if ( unlockCount != 0 ) {
        if  ( rfcb->UnlockAccessGranted ) {

            IO_STATUS_BLOCK iosb;

            do {

                //
                // Form the key for this lock.  Get the offset and length of the
                // range.
                //

                ParseLockData(
                    largeFileLock,
                    smallRange,
                    largeRange,
                    &pid,
                    &offset,
                    &length
                    );

                key = rfcb->ShiftedFid | pid;

                IF_SMB_DEBUG(LOCK2) {
                    KdPrint(( "SrvSmbLockingAndX: Unlocking in file 0x%p: ",
                                lfcb->FileObject ));
                    KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                offset.HighPart, offset.LowPart,
                                length.HighPart, length.LowPart ));
                    KdPrint(( "key 0x%lx\n", key ));
                }

                //
                // Issue the Unlock request.
                //
                // *** Note that we do the Unlock synchronously.  Unlock is a
                //     quick operation, so there's no point in doing it
                //     asynchronously.  In order to do this, we have to let
                //     normal I/O completion happen (so the event is set), which
                //     means that we have to allocate a new IRP (I/O completion
                //     likes to deallocate an IRP).  This is a little wasteful,
                //     since we've got a perfectly good IRP hanging around.
                //     However, we do try to use the turbo path first, so in
                //     most cases we won't actually issue an I/O request.
                //

                //
                // Try the turbo unlock path first.
                //

#if SRVDBG_PERF
                iosb.Status = STATUS_SUCCESS;
                if ( (LockBypass == 3) ||
                     ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                     ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
                if (
#endif
                     ((lfcb->FastIoUnlockSingle != NULL) &&
                      lfcb->FastIoUnlockSingle(
                                        lfcb->FileObject,
                                        &offset,
                                        &length,
                                        IoGetCurrentProcess(),
                                        key,
                                        &iosb,
                                        lfcb->DeviceObject
                                        )) ) {

                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
                    status = iosb.Status;

                } else {

                    if ( lfcb->FastIoUnlockSingle != NULL ) {

                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );
                    }

                    status = SrvIssueUnlockSingleRequest(
                            lfcb->FileObject,               // target file object
                            &lfcb->DeviceObject,            // target device object
                            offset,                         // byte offset
                            length,                         // range length
                            key                             // lock key
                            );
                }

                //
                // If the unlock request failed, set an error status in the
                // response header and jump out.
                //

                if ( !NT_SUCCESS(status) ) {

                    IF_DEBUG(SMB_ERRORS) {
                        KdPrint(( "SrvSmbLockingAndX: Unlock failed: %X\n", status ));
                    }
                    SrvSetSmbError( WorkContext, status );

                    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockingAndX complete\n" ));
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Update the count of locks on the RFCB.
                //

                InterlockedDecrement( &rfcb->NumberOfLocks );

                //
                // Update both range pointers, only one is meaningful - the
                // other pointer is never referenced.
                //

                ++smallRange;
                ++largeRange;

            } while ( --unlockCount > 0 );

        } else {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbLockByteRange: Unlock access not granted.\n"));
            }
            SrvStatistics.GrantedAccessErrors++;
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // We've now unlocked all of the specified ranges.  We did the
    // unlocks synchronously, but we're not willing to do that with the
    // lock requests, which can take an indefinite amount of time.
    // Instead, we start the first lock request here and allow the
    // restart routine to handle the remaining lock ranges.
    //

    if ( lockCount != 0 ) {

        //
        // Does the client want an exclusive lock or a shared lock?
        //

        exclusiveLock = (BOOLEAN)( (request->LockType &
                                    LOCKING_ANDX_SHARED_LOCK) == 0 );

        if ( rfcb->LockAccessGranted && (!exclusiveLock || rfcb->ExclusiveLockGranted) ) {

            if ( !(request->LockType & LOCKING_ANDX_CANCEL_LOCK ) &&
                 !(request->LockType & LOCKING_ANDX_CHANGE_LOCKTYPE) ) {

                BOOLEAN failImmediately;

                //
                // Get the lock timeout.  We will change this later if
                // it's 0 but we want to wait anyway.
                //

                lockTimeout = SmbGetUlong( &request->Timeout );

                //
                // Indicate that no timer has been associated with this
                // request.
                //

                WorkContext->Parameters.Lock.Timer = NULL;

                //
                // There is at least one lock request.  Set up context
                // information.  We use the NumberOfUnlocks field of the
                // request to count how many of the lock requests we've
                // performed.  This field also tells us how many unlocks
                // we have to do if one of the lock attempts fails.  We
                // use the LockRange field of WorkContext->Parameters to
                // point to the current lock range in the request.
                //
                // Short circuit if only one lock request.
                //

                if ( lockCount == 1 ) {

                    //
                    // Form the key for the lock.  Get the offset and length
                    // of the range.
                    //

                    ParseLockData(
                        largeFileLock,
                        smallRange,
                        largeRange,
                        &pid,
                        &offset,
                        &length
                        );

                    key = rfcb->ShiftedFid | pid;

                    IF_SMB_DEBUG(LOCK2) {
                        KdPrint(( "SrvSmbLockingAndX: Locking in file 0x%p: ",
                                    lfcb->FileObject ));
                        KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                    offset.HighPart, offset.LowPart,
                                    length.HighPart, length.LowPart ));
                        KdPrint(( "key 0x%lx\n", key ));
                    }

                    //
                    // Try the turbo lock path first.  Set FailImmediately
                    // based on whether we plan to wait for the lock to
                    // become available.  If the client wants to wait,
                    // or if the client doesn't want to wait but a)
                    // previously tried to get this lock and failed or
                    // b) this lock is above our lock delay limit (in
                    // which cases WE want to wait), then we set
                    // FailImmedately to FALSE.  This will cause the
                    // fast path to fail if the range is not available,
                    // and we will build an IRP to try again.
                    //

                    failImmediately = ((lockTimeout == 0) &&
                        (offset.QuadPart != pagedRfcb->LastFailingLockOffset.QuadPart) &&
                        (offset.QuadPart < SrvLockViolationOffset) );
#if SRVDBG_PERF
                    if ( LockWaitForever ) failImmediately = FALSE;
#endif

#if SRVDBG_PERF
                    WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
                    if ( (LockBypass == 3) ||
                         ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                         ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
                    if (
#endif
                         ((lfcb->FastIoLock != NULL) &&
                          lfcb->FastIoLock(
                                    lfcb->FileObject,
                                    &offset,
                                    &length,
                                    IoGetCurrentProcess(),
                                    key,
                                    failImmediately,
                                    exclusiveLock,
                                    &WorkContext->Irp->IoStatus,
                                    lfcb->DeviceObject
                                    )) ) {

                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

                        if ( NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

                            //
                            // The lock request succeeded.  Update the count
                            // of locks on the RFCB.
                            //

                            InterlockedIncrement( &rfcb->NumberOfLocks );

                            goto try_next_andx;

                        } else {

                            //
                            // The lock request failed.
                            //

                            SmbPutUshort( &request->NumberOfUnlocks, 0 );
                            WorkContext->Parameters.Lock.LockRange =
                                largeFileLock ? (PVOID)largeRange :
                                                (PVOID)smallRange;
                            RestartLockingAndX( WorkContext );
                            SmbStatus = SmbStatusInProgress;
                            goto Cleanup;
                        }
                    }

                    //
                    // The turbo path failed, or didn't exist.
                    //

                    if ( lfcb->FastIoLock != NULL ) {
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
                    }

                }

                //
                // Either there is more than one lock request in the SMB,
                // or the fast path failed (which means that we want to
                // try again, with a timeout).
                //

                SmbPutUshort( &request->NumberOfUnlocks, 0 );
                WorkContext->Parameters.Lock.LockRange =
                        largeFileLock ? (PVOID)largeRange : (PVOID)smallRange;

                DoLockingAndX(
                    WorkContext,
                    (BOOLEAN)(lockCount == 1) // skip fast path?
                    );

                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            } else if ( request->LockType & LOCKING_ANDX_CANCEL_LOCK ) {

                //
                // This is a Cancel request.  Try to cancel the first lock
                // range.  We ignore any subsequent ranges that may be
                // present.
                //
                // !!! Is this right?
                //
                // Get the pid, offset, and length of the lock request
                //

                ParseLockData(
                    largeFileLock,
                    smallRange,
                    largeRange,
                    &pid,
                    &offset,
                    &length
                    );

                WorkContext->Parameters.Lock.LockRange =
                        largeFileLock ? (PVOID)largeRange : (PVOID)smallRange;

                IF_SMB_DEBUG(LOCK2) {
                    KdPrint(( "SrvSmbLockingAndX: Locking in file 0x%p: ",
                                lfcb->FileObject ));
                    KdPrint(( "(%lx%08lx, %lx%08lx), ",
                                offset.HighPart, offset.LowPart,
                                length.HighPart, length.LowPart ));
                }

                if ( CancelLockRequest( WorkContext, fid, pid, offset, length ) ) {
                    SrvSetSmbError( WorkContext, STATUS_SUCCESS );
                    status = STATUS_SUCCESS;
                } else {
                    SrvSetSmbError( WorkContext, STATUS_OS2_CANCEL_VIOLATION );
                    status = STATUS_OS2_CANCEL_VIOLATION;
                }

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            } else if ( request->LockType & LOCKING_ANDX_CHANGE_LOCKTYPE ) {

                //
                // This is a request from a Cruiser client for us to atomically
                // change a lock type from exclusive to shared or vice versa.
                // Since we cannot do this atomically, and would risk losing
                // the lock entirely if we tried this as a two step operation,
                // reject the request.
                //

                SrvSetSmbError( WorkContext, STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED );

                status    = STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

        } else {

            //
            // We can't do locks.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbLockByteRange: Lock access not granted.\n"));
            }
            SrvStatistics.GrantedAccessErrors++;
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

try_next_andx:

    //
    // Check for the Oplock Release flag.
    //

    nextCommand = request->AndXCommand;
    if ( (request->LockType & LOCKING_ANDX_OPLOCK_RELEASE) != 0 ) {

        oplockBreakResponse = ProcessOplockBreakResponse(
                                                WorkContext,
                                                rfcb,
                                                request
                                                );

        //
        // We have (synchronously) completed processing this SMB.  If this
        // was an oplock break response, with no lock request, and no And X
        // command, do not send a reply.
        //

        if( lockCount == 0 && nextCommand == SMB_COM_NO_ANDX_COMMAND ) {
            if( oplockBreakResponse || unlockCount == 0 ) {
                SmbStatus = SmbStatusNoResponse;
                goto Cleanup;
            }
        }
    }

    //
    //
    // Set up the response, then check for an AndX command.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_LOCKING_ANDX,
            0
            )
        );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    if ( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockingAndX complete.\n" ));
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbLockingAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if ( nextCommand == SMB_COM_LOCKING_ANDX ) {

        UCHAR wordCount;
        PSMB_USHORT byteCount;
        ULONG availableSpaceForSmb;

        WorkContext->NextCommand = nextCommand;


        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        //
        // Validate the next locking and x chain
        //

        //
        // Get the WordCount and ByteCount values to make sure that there
        // was enough information sent to satisfy the specifications.
        //

        wordCount = *((PUCHAR)WorkContext->RequestParameters);
        byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                    sizeof(UCHAR) + (8 * sizeof(USHORT)) );
        availableSpaceForSmb = (ULONG)(WorkContext->RequestBuffer->DataLength -
                                       ( (PCHAR)WorkContext->ResponseParameters -
                                         (PCHAR)WorkContext->RequestBuffer->Buffer ));


        if ( (wordCount == 8)
            &&
             ((PCHAR)byteCount <= (PCHAR)WorkContext->RequestBuffer->Buffer +
                                WorkContext->RequestBuffer->DataLength -
                                sizeof(USHORT))
            &&
             (8*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                SmbGetUshort( byteCount ) <= availableSpaceForSmb) ) {

            //
            // Update the request/response pointers
            //

            request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
            response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;
            goto start_lockingAndX;

        } else {

            //
            // Let the regular check fail this.
            //

            SmbStatus = SmbStatusMoreCommands;
            goto Cleanup;
        }
    }

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_FLUSH:

        break;

    case SMB_COM_CLOSE:

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        closeRequest = (PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        //
        // Make sure we stay within the SMB buffer
        //
        if( (PCHAR)closeRequest + FIELD_OFFSET(REQ_CLOSE,ByteCount) <=
            END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime = closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        /* Falls Through! */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbLockingAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    WorkContext->NextCommand = nextCommand;
    WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                        reqAndXOffset;

    SmbStatus = SmbStatusMoreCommands;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockingAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbUnlockByteRange (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Unlock SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_UNLOCK_BYTE_RANGE request;
    PRESP_UNLOCK_BYTE_RANGE response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;

    PRFCB rfcb;
    PLFCB lfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_UNLOCK_BYTE_RANGE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_UNLOCK_BYTE_RANGE)WorkContext->RequestParameters;
    response = (PRESP_UNLOCK_BYTE_RANGE)WorkContext->ResponseParameters;

    //
    // Get the offset and length of the range being locked.  Combine the
    // FID with the caller's PID to form the local lock key.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );
    length.QuadPart = SmbGetUlong( &request->Count );
    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(LOCK1) {
        KdPrint(( "Unlock request; FID 0x%lx, count %ld, offset %ld\n",
                    fid, length.LowPart, offset.LowPart ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbUnlockByteRange: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;

    //
    // Verify that the client has unlock access to the file via the
    // specified handle.
    //

    if ( !rfcb->UnlockAccessGranted) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockByteRange: Unlock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Issue the Unlock request.
    //
    // *** Note that we do the Unlock synchronously.  Unlock is a quick
    //     operation, so there's no point in doing it asynchronously.
    //     In order to do this, we have to let normal I/O completion
    //     happen (so the event is set), which means that we have to
    //     allocate a new IRP (I/O completion likes to deallocate an
    //     IRP).  This is a little wasteful, since we've got a perfectly
    //     good IRP hanging around.  However, we do try to use the turbo
    //     path first, so in most cases we won't actually issue an I/O
    //     request.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    IF_SMB_DEBUG(LOCK2) {
        KdPrint(( "SrvSmbUnlockByteRange: Unlocking in file 0x%p: ",
                   lfcb->FileObject ));
        KdPrint(( "(%lx%08lx,%lx%08lx), ",
                   offset.HighPart, offset.LowPart,
                   length.HighPart, length.LowPart ));
        KdPrint(( "key 0x%lx\n", key ));
    }

    status = SrvIssueUnlockRequest(
                lfcb->FileObject,               // target file object
                &lfcb->DeviceObject,            // target device object
                IRP_MN_UNLOCK_SINGLE,           // unlock operation
                offset,                         // byte offset
                length,                         // range length
                key                             // lock key
                );

    //
    // If the unlock request failed, set an error status in the response
    // header; otherwise, build a normal response message.
    //

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbUnlockByteRange: Unlock failed: %X\n", status ));
        }
        SrvSetSmbError( WorkContext, status );

    } else {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        InterlockedDecrement( &rfcb->NumberOfLocks );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_UNLOCK_BYTE_RANGE,
                                            0
                                            );

    }

    //
    // Processing of the SMB is complete.
    //
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbUnlockByteRange complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbUnlockByteRange


BOOLEAN
CancelLockRequest (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT TargetFid,
    IN USHORT TargetPid,
    IN LARGE_INTEGER TargetOffset,
    IN LARGE_INTEGER TargetLength
    )

/*++

Routine Description:

    This function searches for a lock request in progress.  If the request
    is found, the request IRP is cancelled.

Arguments:

    WorkContext - A pointer to the work information for this request.

    TargetFid - The server supplied FID of the file for the original lock
        request

    TargetPid - The server supplied PID of the file for the original lock
        request

    TargetOffset - The offset in the file of the original lock request

    TargetLength - The length of the byte range of the original lock request

Return Value:

    TRUE - The lock request was cancelled.
    FALSE - The lock request could not be cancelled.

--*/

{
    BOOLEAN match;
    USHORT targetTid, targetUid;
    PWORK_CONTEXT workContext;
    PCONNECTION connection;
    PSMB_HEADER header;
    PREQ_LOCKING_ANDX request;
    BOOLEAN success;

    PNTLOCKING_ANDX_RANGE largeRange;
    PLOCKING_ANDX_RANGE smallRange;
    BOOLEAN largeFileLock;
    USHORT pid;
    LARGE_INTEGER offset;
    LARGE_INTEGER length;

    KIRQL oldIrql;

    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;

    UNLOCKABLE_CODE( 8FIL );

    match = FALSE;
    targetTid = WorkContext->RequestHeader->Tid;
    targetUid = WorkContext->RequestHeader->Uid;

    connection = WorkContext->Connection;

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    //
    // Scan the list of SMBs in progress looking for a locking and X SMB
    // that exactly matches the one we are trying to cancel.
    //

    listHead = &WorkContext->Connection->InProgressWorkItemList;
    listEntry = listHead;
    while ( listEntry->Flink != listHead ) {

        listEntry = listEntry->Flink;

        workContext = CONTAINING_RECORD(
                                     listEntry,
                                     WORK_CONTEXT,
                                     InProgressListEntry
                                     );

        header = workContext->RequestHeader;
        request = (PREQ_LOCKING_ANDX) workContext->RequestParameters;

        //
        // Some workitems in the inprogressworkitemlist are added
        // during a receive indication and the requestheader field
        // has not been set yet.  We can probably set it at that time
        // but this seems to be the safest fix.
        //

        if ( header != NULL && request != NULL ) {

            smallRange = WorkContext->Parameters.Lock.LockRange;
            largeRange = WorkContext->Parameters.Lock.LockRange;

            largeFileLock =
                (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

            ParseLockData(
                largeFileLock,
                smallRange,
                largeRange,
                &pid,
                &offset,
                &length
                );

            ACQUIRE_DPC_SPIN_LOCK( &workContext->SpinLock );
            if ( (workContext->BlockHeader.ReferenceCount != 0) &&
                 (workContext->ProcessingCount != 0) &&
                 header->Command == SMB_COM_LOCKING_ANDX &&
                 request->Fid == TargetFid &&
                 SmbGetAlignedUshort( &header->Tid ) == targetTid &&
                 SmbGetAlignedUshort( &header->Uid ) == targetUid &&
                 pid == TargetPid &&
                 offset.QuadPart == TargetOffset.QuadPart &&
                 length.QuadPart == TargetLength.QuadPart ) {

                match = TRUE;
                break;
            }
            RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );

        }
    }

    if ( match ) {

        //
        // Reference the work item, so that it cannot get used to process
        // a new SMB while we are trying to cancel the old one.
        //

        SrvReferenceWorkItem( workContext );
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        success = IoCancelIrp( workContext->Irp );
        SrvDereferenceWorkItem( workContext );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        success = FALSE;
    }

    return success;

} // CancelLockRequest


VOID
DoLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN SkipFastPath
    )

/*++

Routine Description:

    Processes the LockingAndX SMB, using the fast lock path.  As long
    as the fast lock path works, we continue to loop through the locks
    specified in the LockingAndX request.  As soon as the fast path
    fails, however, we jump into the slow IRP-based path.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    SkipFastPath - Indicates whether this routine should try the fast
        lock path before submitting an IRP.

Return Value:

    None.

--*/

{
    PREQ_LOCKING_ANDX request;

    PLOCKING_ANDX_RANGE smallRange;
    PNTLOCKING_ANDX_RANGE largeRange;

    PRFCB rfcb;
    PLFCB lfcb;
    USHORT pid;
    CLONG lockCount;
    CLONG count;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN largeFileLock;

    BOOLEAN failImmediately;
    BOOLEAN exclusiveLock;

    ULONG lockTimeout;
    PSRV_TIMER timer;

    PAGED_CODE( );

    //
    // Get the request parameter pointer.
    //

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;

    //
    // Get the file pointer, the count of locks requested, the count of
    // locks already performed, and a pointer to the current lock range.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    lockCount = SmbGetUshort( &request->NumberOfLocks );
    count = SmbGetUshort( &request->NumberOfUnlocks );

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Only one of the two pointers below is actually ever referenced.
    //

    smallRange = WorkContext->Parameters.Lock.LockRange;
    largeRange = WorkContext->Parameters.Lock.LockRange;

    //
    // Does the client want an exclusive lock or a shared lock?
    //

    exclusiveLock = (BOOLEAN)( (request->LockType &
                                LOCKING_ANDX_SHARED_LOCK) == 0 );

    //
    // Loop through the lock requests.  We exit this loop when either
    // we have processed all of the lock ranges or the fast lock path
    // fails.
    //

    ASSERT ( count < lockCount );

    while ( TRUE ) {

        //
        // Form the key for the lock.  Get the offset and length
        // of the range.
        //

        ParseLockData(
            largeFileLock,
            smallRange,
            largeRange,
            &pid,
            &offset,
            &length
            );

        key = rfcb->ShiftedFid | pid;

        IF_SMB_DEBUG(LOCK2) {
            KdPrint(( "DoLockingAndX: Locking in file 0x%p: ",
                        lfcb->FileObject ));
            KdPrint(( "(%lx%08lx, %lx%08lx), ",
                        offset.HighPart, offset.LowPart,
                        length.HighPart, length.LowPart ));
            KdPrint(( "key 0x%lx\n", key ));
        }

        lockTimeout = SmbGetUlong( &request->Timeout );
        if ( (lockTimeout < SrvLockViolationDelay) &&
             ((offset.QuadPart == rfcb->PagedRfcb->LastFailingLockOffset.QuadPart) ||
              (offset.QuadPart >= SrvLockViolationOffset)) ) {
            lockTimeout = SrvLockViolationDelay;
        }
#if SRVDBG_PERF
        if ( LockWaitForever ) {
            lockTimeout = (ULONG)-1;
        }
#endif
        failImmediately = (BOOLEAN)(lockTimeout == 0);

        if ( SkipFastPath ) {

            SkipFastPath = FALSE;

        } else {

            //
            // Try the turbo lock path first.
            //

#if SRVDBG_PERF
            WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
            if ( (LockBypass == 3) ||
                 ((LockBypass == 2) && (offset.LowPart >= LockBypassMirror)) ||
                 ((LockBypass == 1) && (offset.LowPart >= LockBypassConst)) ||
#else
            if (
#endif
                 ((lfcb->FastIoLock != NULL) &&
                  lfcb->FastIoLock(
                            lfcb->FileObject,
                            &offset,
                            &length,
                            IoGetCurrentProcess(),
                            key,
                            failImmediately,
                            exclusiveLock,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            )) ) {

                //
                // The turbo path worked.  If the lock was not obtained,
                // drop into the restart routine to return the error.
                // Otherwise, update pointers and counters and continue.
                //

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                    RestartLockingAndX( WorkContext );
                    return;
                }

                //
                // Increment the count of locks on the file.
                //

                InterlockedIncrement( &rfcb->NumberOfLocks );

                //
                // If this isn't the last lock, update context
                // information.  If it is, RestartLockingAndX will do
                // this.
                //

                count++;                          // another lock obtained

                if ( count < lockCount ) {

                    SmbPutUshort( &request->NumberOfUnlocks, (USHORT)count );

                    if (largeFileLock) {
                        largeRange++;   // point to next lock range
                        WorkContext->Parameters.Lock.LockRange = (PVOID)largeRange;
                    } else {
                        smallRange++;   // point to next lock range
                        WorkContext->Parameters.Lock.LockRange = (PVOID)smallRange;
                    }

                } else {

                    //
                    // The fast lock path successfully locked all of the
                    // requested ranges.  Call RestartLockingAndX
                    // directly to complete processing of the SMB.
                    //

                    WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
                    RestartLockingAndX( WorkContext );
                    return;

                }

                continue;

            } else {

                //
                // The turbo path failed, or didn't exist.
                //

                if ( lfcb->FastIoLock ) {
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
                }

            }

        }

        //
        // The turbo path failed, or was bypassed, or didn't exist.
        // Start the lock request, reusing the receive IRP.
        //
        // If we plan to wait for the range to be available, but not
        // indefinitely, we'll need a timer structure.
        //

        timer = NULL;
        if ( !failImmediately ) {
            ASSERT( lockTimeout != 0 );
            if ( lockTimeout != (ULONG)-1 ) {
                timer = SrvAllocateTimer( );
                if ( timer == NULL ) {
                    failImmediately = TRUE;
                }
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,           // input IRP address
            lfcb->FileObject,           // target file object address
            WorkContext,                // context
            offset,                     // byte offset
            length,                     // range length
            key,                        // lock key
            failImmediately,
            exclusiveLock
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLockingAndX;

        //
        // Start the timer, if necessary.
        //

        if ( timer != NULL ) {
            LARGE_INTEGER TimeOut;

            ASSERT( lockTimeout != 0 );
            ASSERT( !failImmediately );
            WorkContext->Parameters.Lock.Timer = timer;
            TimeOut.QuadPart = Int32x32To64( lockTimeout, -1*10*1000);

            SrvSetTimer( timer, &TimeOut, TimeoutLockRequest, WorkContext );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "DoLockingAndX complete\n" ));
        return;

    } // while ( TRUE )

    // can't get here

} // DoLockingAndX


BOOLEAN
ProcessOplockBreakResponse(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb,
    IN PREQ_LOCKING_ANDX Request
    )

/*++

Routine Description:

    This function searches for a lock request in progress.  If the request
    is found, the request IRP is cancelled.

Arguments:

    WorkContext - A pointer to the work information for this request.
    Rfcb - A pointer to the rfcb containing the file and oplock information.
    Request - The request lockingandx smb.

Return Value:

    TRUE - Valid oplock break response
    FALSE - otherwise.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    if ( Rfcb->OnOplockBreaksInProgressList ) {

        Rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;

        //
        // Remove the Rfcb from the Oplock breaks in progress list, and
        // release the Rfcb reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &Rfcb->ListEntry );
        Rfcb->OnOplockBreaksInProgressList = FALSE;
#if DBG
        Rfcb->ListEntry.Flink = Rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );

        //
        // Update the session lock sequence number.
        //

        WorkContext->Connection->LatestOplockBreakResponse =
                                           WorkContext->Timestamp;

        SrvAcknowledgeOplockBreak( Rfcb, Request->OplockLevel );
        SrvDereferenceRfcb( Rfcb );

        ExInterlockedAddUlong(
            &WorkContext->Connection->OplockBreaksInProgress,
            (ULONG)-1,
            WorkContext->Connection->EndpointSpinLock
            );

        return(TRUE);

    } else {

        RELEASE_LOCK( &SrvOplockBreakListLock );

    }

    return(FALSE);

} // ProcessOplockBreakResponse


VOID SRVFASTCALL
RestartLockByteRange (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Lock SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_LOCK_BYTE_RANGE request;
    PRESP_LOCK_BYTE_RANGE response;

    LARGE_INTEGER offset;
    NTSTATUS status = STATUS_SUCCESS;
    PSRV_TIMER timer;
    BOOLEAN iAmBlockingThread = (WorkContext->UsingBlockingThread != 0);

    PAGED_CODE( );
    if (iAmBlockingThread) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_BYTE_RANGE;
        SrvWmiStartContext(WorkContext);
    }

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockByteRange\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
    }

    //
    // Get the request and response parameter pointers.
    //

    response = (PRESP_LOCK_BYTE_RANGE)WorkContext->ResponseParameters;

    status = WorkContext->Irp->IoStatus.Status;

    if ( NT_SUCCESS(status) ) {

        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        InterlockedIncrement(
            &WorkContext->Rfcb->NumberOfLocks
            );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_LOCK_BYTE_RANGE,
                                            0
                                            );

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );


    } else {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );

        //
        // Store the failing lock offset.
        //

        request = (PREQ_LOCK_BYTE_RANGE)WorkContext->RequestParameters;
        offset.QuadPart = SmbGetUlong( &request->Offset );

        WorkContext->Rfcb->PagedRfcb->LastFailingLockOffset = offset;

        //
        // Send error message back
        //

        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }

    IF_DEBUG(TRACE2) KdPrint(( "RestartLockByteRange complete\n" ));
    if (iAmBlockingThread) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartLockByteRange


VOID SRVFASTCALL
RestartLockingAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Locking and X SMB.  If more
    lock requests are present in the SMB, it starts the next one.  If
    not, it formats a response and starts the next command in the chain,
    if any.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_LOCKING_ANDX request;
    PRESP_LOCKING_ANDX response;
    PLOCKING_ANDX_RANGE smallRange;
    PNTLOCKING_ANDX_RANGE largeRange;

    NTSTATUS status = STATUS_SUCCESS;
    USHORT pid;
    CLONG lockCount;
    CLONG count;

    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN largeFileLock;

    UCHAR nextCommand;
    USHORT reqAndXOffset;

    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    PSRV_TIMER timer;

    PREQ_CLOSE closeRequest;
    BOOLEAN iAmBlockingThread =
        (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LOCKING_AND_X);

    PAGED_CODE( );
    if (iAmBlockingThread) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCKING_AND_X;
        SrvWmiStartContext(WorkContext);
    }

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockingAndX\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
        WorkContext->Parameters.Lock.Timer = NULL;
    }

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_LOCKING_ANDX)WorkContext->RequestParameters;
    response = (PRESP_LOCKING_ANDX)WorkContext->ResponseParameters;

    //
    // Get the file pointer, the count of locks requested, the count of
    // locks already performed, and a pointer to the current lock range.
    //

    rfcb = WorkContext->Rfcb;
    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    lockCount = SmbGetUshort( &request->NumberOfLocks );
    count = SmbGetUshort( &request->NumberOfUnlocks );

    largeFileLock =
            (BOOLEAN)( (request->LockType & LOCKING_ANDX_LARGE_FILES) != 0 );

    //
    // Only one of the two pointers below is actually ever referenced.
    //

    smallRange = WorkContext->Parameters.Lock.LockRange;
    largeRange = WorkContext->Parameters.Lock.LockRange;

    //
    // If the lock request failed, set an error status in the response
    // header and release any previously obtained locks.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );

        IF_DEBUG(ERRORS) {
            KdPrint(( "RestartLockingAndX: lock failed: %X\n", status ));
        }
        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );

        ParseLockData(
            largeFileLock,
            smallRange,
            largeRange,
            &pid,
            &offset,
            &length
            );

        //
        // Store the failing lock offset.
        //

        pagedRfcb->LastFailingLockOffset = offset;

        //
        // Release any previously obtained locks, in reverse order.
        //

        for ( smallRange--, largeRange--;
              count > 0;
              count--, smallRange--, largeRange-- ) {

            //
            // Form the key for this lock.  Get the offset and length of
            // the range.
            //

            ParseLockData(
                largeFileLock,
                smallRange,
                largeRange,
                &pid,
                &offset,
                &length
                );

            key = rfcb->ShiftedFid | pid;

            IF_SMB_DEBUG(LOCK2) {
                KdPrint(( "RestartLockingAndX: Unlocking in file 0x%p: ",
                           lfcb->FileObject ));
                KdPrint(( "(%lx%08lx,%lx%08lx), ",
                           offset.HighPart, offset.LowPart,
                           length.HighPart, length.LowPart ));
                KdPrint(( "key 0x%lx\n", key ));
            }

            //
            // Issue the Unlock request.
            //

            status = SrvIssueUnlockRequest(
                        lfcb->FileObject,           // target file object
                        &lfcb->DeviceObject,        // target device object
                        IRP_MN_UNLOCK_SINGLE,       // unlock operation
                        offset,                     // byte offset
                        length,                     // range length
                        key                         // lock key
                        );

            if ( NT_SUCCESS(status) ) {
                InterlockedDecrement( &rfcb->NumberOfLocks );
            } else {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "RestartLockingAndX: Unlock failed: %X\n",
                                status ));
                }
            }

        } // for ( range--; count > 0; count--, range-- )

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // The lock request succeeded.  Update the count of locks on the
    // RFCB and start the next one, if any.
    //

    InterlockedIncrement( &rfcb->NumberOfLocks );

    count++;                          // another lock obtained
    smallRange++, largeRange++;       // point to next lock range

    if ( count < lockCount ) {

        //
        // There is at least one more lock request.  Save the updated
        // context information.
        //

        SmbPutUshort( &request->NumberOfUnlocks, (USHORT)count );

        if (largeFileLock) {
            WorkContext->Parameters.Lock.LockRange = (PVOID)largeRange;
        } else {
            WorkContext->Parameters.Lock.LockRange = (PVOID)smallRange;
        }

        //
        // Call the lock request processor.  (Note that DoLockingAndX
        // can call this routine (RestartLockingAndX) recursively, but
        // only with !NT_SUCCESS(status), so we won't get back here and
        // won't get stuck.
        //
        // Form the key for the lock.  Get the offset and length of the
        // range.
        //

        DoLockingAndX( WorkContext, FALSE );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // There are no more lock requests in the SMB.  Check for the Oplock
    // Release flag.
    //

    if ( (request->LockType & LOCKING_ANDX_OPLOCK_RELEASE) != 0 ) {

        (VOID)ProcessOplockBreakResponse( WorkContext, rfcb, request);
    }

    //
    // We have (asynchronously) completed processing this SMB.  Set up
    // the response, then check for an AndX command.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_LOCKING_ANDX,
            0
            )
        );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {

        //
        // Processing of the SMB is complete.  Call SrvEndSmbProcessing
        // to send the response.
        //
        // Build the response parameters.
        //

        PRESP_CLOSE closeResponse = WorkContext->ResponseParameters;

        closeResponse->WordCount = 0;
        SmbPutUshort( &closeResponse->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            closeResponse,
                                            RESP_CLOSE,
                                            0
                                            );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "RestartLockingAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        goto Cleanup;
    }

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_LOCKING_ANDX:
    case SMB_COM_FLUSH:

        break;

    case SMB_COM_CLOSE:

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        closeRequest = (PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        if( (PCHAR)closeRequest + FIELD_OFFSET(REQ_CLOSE,ByteCount) <=
            END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime = closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );
            goto Cleanup;
        }

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "RestartLockingAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        //
        // Return an error indicating that the followon command was bad.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));
        goto Cleanup;
    }

    WorkContext->NextCommand = nextCommand;

    WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                        reqAndXOffset;

    SrvProcessSmb( WorkContext );
    IF_DEBUG(TRACE2) KdPrint(( "RestartLockingAndX complete\n" ));

Cleanup:
    if (iAmBlockingThread) {
        SrvWmiEndContext(WorkContext);
    }
    return;
} // RestartLockingAndX


VOID
SrvAcknowledgeOplockBreak (
    IN PRFCB Rfcb,
    IN UCHAR NewOplockLevel
    )

/*++

Routine Description:

    This function is called when a client has sent an oplock break
    acknowledgement.  It acknowledges the oplock break locally.

Arguments:

    Rfcb - A pointer to the RFCB for the file on which the oplock is
           being released.

    NewOplockLevel - The oplock level to break to.

Return Value:

    None.

--*/

{
    PPAGED_RFCB pagedRfcb = Rfcb->PagedRfcb;

    PAGED_CODE( );

    IF_DEBUG( OPLOCK ) {
        KdPrint(( "SrvAcknowledgeOplockBreak:  received oplock break response\n" ));
    }

    //
    // Reference the RFCB to account for the IRP we about to submit.
    // If the RFCB is closing, do not bother to acknowledge the oplock.
    //

    if ( !SrvCheckAndReferenceRfcb( Rfcb ) ) {
        return;
    }

    if ( Rfcb->OplockState == OplockStateNone ) {
        KdPrint(("SrvAcknowledgeOplockBreak:  ACKed break for RFCB %p, but no break sent\n", Rfcb));
        SrvDereferenceRfcb( Rfcb );
        return;
    }

    if ( NewOplockLevel == OPLOCK_BROKEN_TO_II ) {
        Rfcb->OplockState = OplockStateOwnLevelII;
    } else {
        Rfcb->OplockState = OplockStateNone;
    }

    //
    // Set this event to NULL to indicate the completion routine should clean
    // up the irp.
    //

    Rfcb->RetryOplockRequest = NULL;

    //
    // Generate and issue the oplock break IRP.  This will attempt to
    // break the oplock to level 2.
    //
    // *** If the client understands level II oplocks, do a regular
    //     acknowledge.  If not, do a special acknowledge that does
    //     not allow the oplock to change to level II.  This prevents
    //     the situation where the oplock package thinks there's a
    //     level II oplock, but the client(s) don't.  In that situation,
    //     fast I/O (esp. reads) is disabled unnecessarily.
    //

    SrvBuildIoControlRequest(
        Rfcb->Irp,
        Rfcb->Lfcb->FileObject,
        Rfcb,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        (CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, Rfcb->Connection ) ?
            FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
            FSCTL_OPLOCK_BREAK_ACK_NO_2),
        NULL,                        // Main buffer
        0,                           // Input buffer length
        NULL,                        // Auxiliary buffer
        0,                           // Output buffer length
        NULL,                        // MDL
        SrvFsdOplockCompletionRoutine
        );

    (VOID)IoCallDriver(
              Rfcb->Lfcb->DeviceObject,
              Rfcb->Irp
              );

} // SrvAcknowledgeOplockBreak


VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSRV_TIMER timer;

    //
    // A lock request has been waiting too long.  Cancel it.
    //

    IoCancelIrp( ((PWORK_CONTEXT)DeferredContext)->Irp );

    //
    // Set the event indicating that the timer routine is done.
    //

    timer = CONTAINING_RECORD( Dpc, SRV_TIMER, Dpc );
    KeSetEvent( &timer->Event, 0, FALSE );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbfile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbfile.c

Abstract:

    This module implements file-control SMB processors:

        Flush
        Delete
        Rename
        Move
        Copy

Author:

    David Treadwell (davidtr) 15-Dec-1989

Revision History:

--*/

#include "precomp.h"
#include "smbfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBFILE

//
// Forward declarations
//

VOID SRVFASTCALL
BlockingDelete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingMove (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingRename (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
DoDelete (
    IN PUNICODE_STRING FullFileName,
    IN PUNICODE_STRING RelativeFileName,
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbSearchAttributes,
    IN PSHARE Share
    );

NTSTATUS
FindAndFlushFile (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartFlush (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
StartFlush (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbFlush )
#pragma alloc_text( PAGE, RestartFlush )
#pragma alloc_text( PAGE, StartFlush )
#pragma alloc_text( PAGE, SrvSmbDelete )
#pragma alloc_text( PAGE, BlockingDelete )
#pragma alloc_text( PAGE, DoDelete )
#pragma alloc_text( PAGE, SrvSmbRename )
#pragma alloc_text( PAGE, BlockingRename )
#pragma alloc_text( PAGE, SrvSmbMove )
#pragma alloc_text( PAGE, BlockingMove )
#pragma alloc_text( PAGE, SrvSmbNtRename )
#endif
#if 0
#pragma alloc_text( PAGECONN, FindAndFlushFile )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbFlush (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Flush SMB.  It ensures that all data and
    allocation information for the specified file has been written out
    before the response is sent.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_FLUSH request;
    PRESP_FLUSH response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PRFCB rfcb;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FLUSH;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_FLUSH)WorkContext->RequestParameters;
    response = (PRESP_FLUSH)WorkContext->ResponseParameters;

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush request; FID 0x%lx\n",
                    SmbGetUshort( &request->Fid ) ));
    }

    //
    // If a FID was specified, flush just that file.  If FID == -1,
    // then flush all files corresponding to the PID passed in the
    // SMB header.
    //

    if ( SmbGetUshort( &request->Fid ) == (USHORT)0xFFFF ) {

        //
        // Find a single file to flush and flush it.  We'll start one
        // flush here, then RestartFlush will handle flushing the rest
        // of the files.
        //

        WorkContext->Parameters.CurrentTableIndex = 0;
        status = FindAndFlushFile( WorkContext );

        if ( status == STATUS_NO_MORE_FILES ) {

            //
            // There were no files that needed to be flushed.  Build and
            // send a response SMB.
            //

            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                NEXT_LOCATION( response, RESP_FLUSH, 0 );

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Flush of a specific file.  Verify the FID.  If verified, the
    // RFCB block is referenced and its address is stored in the
    // WorkContext block, and the RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
               WorkContext,
               SmbGetUshort( &request->Fid ),
               TRUE,
               SrvRestartSmbReceived,   // serialize with raw write
               &status
               );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbFlush: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Set the CurrentTableIndex field of the work context block to
    // NULL so that the restart routine will know that only a single
    // file is to be flushed.
    //

    WorkContext->Parameters.CurrentTableIndex = -1;

    IF_SMB_DEBUG(FILE_CONTROL2) {
        KdPrint(( "Flushing buffers for FID %lx, RFCB %p\n", rfcb->Fid, rfcb ));
    }

    //
    // Start the flush operation on the file corresponding to the RFCB.
    //

    status = StartFlush( WorkContext, rfcb );

    if ( !NT_SUCCESS(status) ) {

        //
        // Unable to start the I/O.  Clean up the I/O request.  Return
        // an error to the client.
        //

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // The flush request was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //
    SmbStatus = SmbStatusInProgress;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbFlush complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbFlush


NTSTATUS
FindAndFlushFile (
    IN PWORK_CONTEXT WorkContext
    )

{
    NTSTATUS status;
    LONG currentTableIndex;
    PRFCB rfcb;
    USHORT pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    PCONNECTION connection = WorkContext->Connection;
    PTABLE_HEADER tableHeader;
    KIRQL oldIrql;

    //UNLOCKABLE_CODE( CONN );

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush FID == -1; flush all files for PID %lx\n", pid ));
    }

    //
    // Walk the connection's file table, looking an RFCB with a PID
    // equal to the PID passed in the SMB header.
    //
    // Acquire the lock that protects the connection's file table.
    // This prevents an RFCB from going away between when we find a
    // pointer to it and when we reference it.
    //

    tableHeader = &connection->FileTable;
    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( currentTableIndex = WorkContext->Parameters.CurrentTableIndex;
          currentTableIndex < (LONG)tableHeader->TableSize;
          currentTableIndex++ ) {

        rfcb = tableHeader->Table[currentTableIndex].Owner;

        IF_SMB_DEBUG(FILE_CONTROL1) {
            KdPrint(( "Looking at RFCB %p, PID %lx, FID %lx\n",
                          rfcb, rfcb != NULL ? rfcb->Pid : 0,
                          rfcb != NULL ? rfcb->Fid : 0 ));
        }

        if ( rfcb == NULL || rfcb->Pid != pid ) {
            continue;
        }

        //
        // Reference the rfcb if it is active.
        //

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            continue;
        }
        rfcb->BlockHeader.ReferenceCount++;

        //
        // Now that the RFCB has been referenced, we can safely
        // release the lock that protects the connection's file
        // table.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        WorkContext->Rfcb = rfcb;

        //
        // Mark the rfcb as active
        //

        rfcb->IsActive = TRUE;

        //
        // Set the CurrentTableIndex field of the work context
        // block so that the restart routine knows where to
        // continue looking for RFCBs to flush.
        //

        WorkContext->Parameters.CurrentTableIndex = currentTableIndex;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Flushing buffers for FID %lx, RFCB %p\n",
                          rfcb->Fid, rfcb ));
        }

        //
        // Start the I/O to flush the file.
        //

        status = StartFlush( WorkContext, rfcb );

        //
        // If there was an access violation or some other error,
        // simply continue walking through the file table.
        // We ignore these errors for flush with FID=-1.
        //
        // Note that StartFlush only returns an error if the IO
        // operation *was*not* started.  If the operation was
        // started, then errors will be processed in this routine
        // when it is called later by IoCompleteRequest.
        //

        if ( status != STATUS_PENDING ) {
            SrvDereferenceRfcb( rfcb );
            WorkContext->Rfcb = NULL;
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            continue;
        }

        //
        // The flush request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "RestartFlush complete\n" ));
        return STATUS_SUCCESS;

    } // for ( ; ; )   (walk file table)

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return STATUS_NO_MORE_FILES;

} // FindAndFlushFile


VOID SRVFASTCALL
RestartFlush (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes flush completion.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PRESP_FLUSH response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FLUSH;
    SrvWmiStartContext(WorkContext);

    IF_DEBUG(WORKER1) KdPrint(( " - RestartFlush\n" ));

    response = (PRESP_FLUSH)WorkContext->ResponseParameters;

    //
    // If the flush request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    //
    // If an error occurred during processing of the flush, return the
    // error to the client.  No more further files will be flushed.
    //
    // *** This should be very rare.  STATUS_DISK_FULL is probably the
    //     main culprit.

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) KdPrint(( "Flush failed: %X\n", status ));
        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartFlush complete\n" ));
        return;
    }

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush operation for RFCB %p was successful.\n",
                      WorkContext->Rfcb ));
    }

    //
    // If the FID in the original request was -1, look for more files
    // to flush.
    //

    if ( WorkContext->Parameters.CurrentTableIndex != -1 ) {

        //
        // Dereference the RFCB that was stored in the work context block,
        // and set the pointer to NULL so that it isn't accidentally
        // dereferenced again later.
        //

        SrvDereferenceRfcb( WorkContext->Rfcb );
        WorkContext->Rfcb = NULL;

        //
        // Find a file to flush and flush it.
        //

        WorkContext->Parameters.CurrentTableIndex++;

        status = FindAndFlushFile( WorkContext );

        //
        // If a file was found and IO operation started, then return.  If
        // all the appropriate files have been flushed, send a response SMB.
        //

        if ( status != STATUS_NO_MORE_FILES ) {
            return;
        }

    } // if ( WorkContext->Parameters.CurrentTableIndex != -1 )

    //
    // All files have been flushed.  Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_FLUSH, 0 );

    //
    // Processing of the SMB is complete.  Call SrvEndSmbProcessing to
    // send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbFlush complete.\n" ));
    SrvWmiEndContext(WorkContext);
    return;

} // RestartFlush


NTSTATUS
StartFlush (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    Processes the actual file flush.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    Rfcb - a pointer to the RFCB corresponding to the file to flush.

Return Value:

    STATUS_PENDING if the IO operation was started, or an error from
        CHECK_FUNCTION_ACCESS (STATUS_ACCESS_DENIED, for example).

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    CHECK_FUNCTION_ACCESS(
        Rfcb->GrantedAccess,
        IRP_MJ_FLUSH_BUFFERS,
        0,
        0,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "StartFlush: IoCheckFunctionAccess failed: "
              "0x%X, GrantedAccess: %lx.  Access granted anyway.\n",
              status, Rfcb->GrantedAccess ));
        }

        //
        // Some dumb apps flush files opened for r/o.  If this happens,
        // assume the flush worked.  OS/2 let's the
        // flush through and we should do the same.
        //

        WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
        RestartFlush( WorkContext );
        return(STATUS_PENDING);
    }

    //
    // Flush the file's buffers.
    //

    SrvBuildFlushRequest(
        WorkContext->Irp,                // input IRP address
        Rfcb->Lfcb->FileObject,          // target file object address
        WorkContext                      // context
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartFlush;

    (VOID)IoCallDriver( Rfcb->Lfcb->DeviceObject, WorkContext->Irp );

    return STATUS_PENDING;

} // StartFlush


SMB_PROCESSOR_RETURN_TYPE
SrvSmbDelete (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Delete SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();

    //
    // This SMB must be processed in a blocking thread.
    //

    if( !WorkContext->UsingBlockingThread ) {
        WorkContext->FspRestartRoutine = BlockingDelete;
        SrvQueueWorkToBlockingThread( WorkContext );
    } else {
        BlockingDelete( WorkContext );
    }

    return SmbStatusInProgress;

} // SrvSmbDelete


VOID SRVFASTCALL
BlockingDelete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Delete SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_DELETE request;
    PRESP_DELETE response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING filePathName;
    UNICODE_STRING fullPathName;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;
    ULONG deleteRetries;
    PSRV_DIRECTORY_INFORMATION directoryInformation;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_DELETE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Delete file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Delete file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_DELETE)WorkContext->RequestParameters;
    response = (PRESP_DELETE)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbDelete: Invalid UID or TID\n" ));
        }
        goto error_exit;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer becsue the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &filePathName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbDelete: illegal path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        goto error_exit;
    }

    //
    // Find out whether there are wildcards in the file name.  If so,
    // then call SrvQueryDirectoryFile to expand the wildcards; if not,
    // just delete the file directly.
    //

    if ( !FsRtlDoesNameContainWildCards( &filePathName ) ) {

        //
        // Build a full pathname to the file.
        //

        SrvAllocateAndBuildPathName(
            &treeConnect->Share->DosPathName,
            &filePathName,
            NULL,
            &fullPathName
            );

        if ( fullPathName.Buffer == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName failed\n" ));
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &filePathName );
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
        }

        //
        // Perform the actual delete operation on this filename.
        //

        deleteRetries = SrvSharingViolationRetryCount;

start_retry1:

        status = DoDelete(
                     &fullPathName,
                     &filePathName,
                     WorkContext,
                     SmbGetUshort( &request->SearchAttributes ),
                     treeConnect->Share
                     );

        if ( (status == STATUS_SHARING_VIOLATION) &&
             (deleteRetries-- > 0) ) {

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            goto start_retry1;
        }

        FREE_HEAP( fullPathName.Buffer );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &filePathName );
        }

        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

    } else {

        BOOLEAN firstCall = TRUE;
        CLONG bufferLength;
        UNICODE_STRING subdirInfo;
        BOOLEAN filterLongNames;

        //
        // A buffer of non-paged pool is required for
        // SrvQueryDirectoryFile.  Since this routine does not use any
        // of the SMB buffer after the pathname of the file to delete,
        // we can use this.  The buffer should be quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)( (ULONG_PTR)((PCHAR)request->Buffer +
            SmbGetUshort( &request->ByteCount ) + 7) & ~7 );

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = filePathName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &filePathName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Subdirectory info is %wZ\n", &subdirInfo ));
        }

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // When we call SrvQueryDirectoryFile, it will open the file for
        // us, so all we have to do is delete it with
        // NtSetInformationFile.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to delete long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &filePathName,
                               NULL,
                               SmbGetUshort( &request->SearchAttributes ),
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;
            UNICODE_STRING name;
            UNICODE_STRING relativeName;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvQueryDirectoryFile failed: "
                                "%X\n", status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                goto error_exit1;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // Note that we use the standard name to do the delete, even
            // though we may have matched on the NTFS short name.  The
            // client doesn't care which name we use to do the delete.
            //

            name.Length = (SHORT)bothDirInfo->FileNameLength;
            name.MaximumLength = name.Length;
            name.Buffer = bothDirInfo->FileName;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &name,
                            directoryInformation->CurrentEntry->FileNameLength,
                            status ));
            }

            firstCall = FALSE;

            //
            // Build a full pathname to the file.
            //

            SrvAllocateAndBuildPathName(
                &treeConnect->Share->DosPathName,
                &subdirInfo,
                &name,
                &fullPathName
                );

            if ( fullPathName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName "
                                "failed\n" ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit1;
            }

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
            }

            //
            // Build the relative path name to the file.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &name,
                NULL,
                &relativeName
                );

            if ( relativeName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName failed\n" ));
                }

                FREE_HEAP( fullPathName.Buffer );

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit1;
            }

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
            }

            //
            // Perform the actual delete operation on this filename.
            //
            // *** SrvQueryDirectoryFile has already filtered based on
            //     the search attributes, so tell DoDelete that files
            //     with the system and hidden bits are OK.  This will
            //     prevent the call to NtQueryDirectoryFile performed
            //     in SrvCheckSearchAttributesForHandle.

            deleteRetries = SrvSharingViolationRetryCount;

start_retry2:

            status = DoDelete(
                         &fullPathName,
                         &relativeName,
                         WorkContext,
                         (USHORT)(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN),
                         treeConnect->Share
                         );

            if ( (status == STATUS_SHARING_VIOLATION) &&
                 (deleteRetries-- > 0) ) {

                (VOID) KeDelayExecutionThread(
                                        KernelMode,
                                        FALSE,
                                        &SrvSharingViolationDelay
                                        );

                goto start_retry2;
            }

            FREE_HEAP( relativeName.Buffer );
            FREE_HEAP( fullPathName.Buffer );

            if ( !NT_SUCCESS(status) ) {

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                goto error_exit1;
            }
        }

        //
        // Close the directory search.
        //

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &filePathName );
        }

        SrvCloseQueryDirectory( directoryInformation );

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto error_exit;
        }

    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_DELETE,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbDelete complete.\n" ));
    goto normal_exit;

error_exit1:

    SrvCloseQueryDirectory( directoryInformation );

error_exit:

    SrvSetSmbError( WorkContext, status );

normal_exit:

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingDelete


NTSTATUS
DoDelete (
    IN PUNICODE_STRING FullFileName,
    IN PUNICODE_STRING RelativeFileName,
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbSearchAttributes,
    IN PSHARE Share
    )

/*++

Routine Description:

    This routine performs the core of a file delete.

Arguments:

    FileName - a full path name, from the system name space root, to the
        file to delete.

    RelativeFileName - the name of the file relative to the share root.

    WorkContext - context block for the operation.  The RequestHeader and
        Session fields are used.

    SmbSearchAttributes - the search attributes passed in the request
        SMB.  The actual file attributes are verified against these to
        make sure that the operation is legitimate.

Return Value:

    NTSTATUS - indicates result of operation.

--*/

{
    NTSTATUS status;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    FILE_DISPOSITION_INFORMATION fileDispositionInformation;
    HANDLE fileHandle = NULL;
    ULONG caseInsensitive;
    IO_STATUS_BLOCK ioStatusBlock;
    PSRV_LOCK mfcbLock;
    ULONG hashValue;

    PAGED_CODE( );

    //
    // See if that file is already open.  If it is open in
    // compatibility mode or is an FCB open, we have to close all of
    // that client's opens.
    //
    // *** SrvFindMfcb references the MFCB--remember to dereference it.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
         WorkContext->Session->UsingUppercasePaths ) {
        caseInsensitive = OBJ_CASE_INSENSITIVE;
        mfcb = SrvFindMfcb( FullFileName, TRUE, &mfcbLock, &hashValue, WorkContext );
    } else {
        caseInsensitive = 0;
        mfcb = SrvFindMfcb( FullFileName, FALSE, &mfcbLock, &hashValue, WorkContext );
    }

    if ( mfcb != NULL ) {
        nonpagedMfcb = mfcb->NonpagedMfcb;
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );
    }

    if( mfcbLock ) {
        RELEASE_LOCK( mfcbLock );
    }

    if ( mfcb == NULL || !mfcb->CompatibilityOpen ) {

        ACCESS_MASK deleteAccess = DELETE;
        OBJECT_ATTRIBUTES objectAttributes;

        //
        // Either the file wasn't opened by the server or it was not
        // a compatibility/FCB open, so open it here for the delete.
        //

del_no_file_handle:

        //
        // If there was an MFCB for this file, we now hold its lock and a
        // referenced pointer.  Undo both.
        //

        if ( mfcb != NULL ) {
            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );
        }

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeFileName,
            caseInsensitive,
            NULL,
            NULL
            );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     DELETE,                            // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                              // AllocationSize
                     0L,                                // FileAttributes
                     0L,                                // ShareAccess
                     FILE_OPEN,                         // Disposition
                     FILE_NON_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, // CreateOptions
                     NULL,                              // EaBuffer
                     0L,                                // EaLength
                     CreateFileTypeNone,
                     NULL,                              // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,             // Options
                     WorkContext->TreeConnect->Share
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         DELETE,                            // DesiredAccess
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,                              // AllocationSize
                         0L,                                // FileAttributes
                         0L,                                // ShareAccess
                         FILE_OPEN,                         // Disposition
                         FILE_NON_DIRECTORY_FILE,           // CreateOptions
                         NULL,                              // EaBuffer
                         0L,                                // EaLength
                         CreateFileTypeNone,
                         NULL,                              // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,             // Options
                         WorkContext->TreeConnect->Share
                         );
        }

        if ( NT_SUCCESS(status) ) {
            SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 27, 0 );
        }

        ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbDelete: SrvIoCreateFile failed: %X\n",
                            status ));
            }

            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            if ( fileHandle != NULL ) {
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 41, 0 );
                SrvNtClose( fileHandle, TRUE );
            }
            return status;
        }

        //
        // Make sure that the search attributes jive with the attributes
        // on the file.
        //

        status = SrvCheckSearchAttributesForHandle( fileHandle, SmbSearchAttributes );

        if ( !NT_SUCCESS(status) ) {
            SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 42, 0 );
            SrvNtClose( fileHandle, TRUE );
            return status;
        }

        //
        // Now that the file has been opened, delete it with
        // NtSetInformationFile.
        //

        SrvStatistics.TotalFilesOpened++;

        fileDispositionInformation.DeleteFile = TRUE;

        status = NtSetInformationFile(
                     fileHandle,
                     &ioStatusBlock,
                     &fileDispositionInformation,
                     sizeof(FILE_DISPOSITION_INFORMATION),
                     FileDispositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbDelete: NtSetInformationFile (file disposition) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

            SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 43, 0 );
            SrvNtClose( fileHandle, TRUE );
            return status;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            if( NT_SUCCESS( status ) ) {
                KdPrint(( "SrvSmbDelete: %wZ successfully deleted.\n", FullFileName ));
            }
        }

        //
        // Close the opened file so that it can be deleted.  This will
        // happen automatically, since the FCB_STATE_FLAG_DELETE_ON_CLOSE
        // flag of the FCB has been set by NtSetInformationFile.
        //

        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 44, 0 );
        SrvNtClose( fileHandle, TRUE );

    } else {

        //
        // The file was opened by the server in compatibility mode
        // or as an FCB open.  Check the granted access to make sure
        // that the file can be deleted.
        //

        ACCESS_MASK deleteAccess = DELETE;
        PLFCB lfcb = CONTAINING_RECORD( mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        //
        // If this file has been closed.  Go back to no mfcb case.
        //
        // *** The specific motivation for this change was to fix a problem
        //     where a compatibility mode open was closed, the response was
        //     sent, and a Delete SMB was received before the mfcb was
        //     completely cleaned up.  This resulted in the MFCB and LFCB
        //     still being present, which caused the delete processing to
        //     try to use the file handle in the LFCB.
        //

        if ( lfcb->FileHandle == 0 ) {
            goto del_no_file_handle;
        }

        //
        // Make sure that the session which sent this request is the
        // same as the one which has the file open.
        //

        if ( lfcb->Session != WorkContext->Session ) {

            //
            // A different session has the file open in compatibility
            // mode, so reject the request.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return STATUS_SHARING_VIOLATION;
        }

        if ( !NT_SUCCESS(IoCheckDesiredAccess(
                          &deleteAccess,
                          lfcb->GrantedAccess )) ) {

            //
            // The client cannot delete this file, so close all the
            // RFCBs and return an error.
            //

            SrvCloseRfcbsOnLfcb( lfcb );

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return STATUS_ACCESS_DENIED;
        }

        //
        // Delete the file with NtSetInformationFile.
        //

        fileHandle = lfcb->FileHandle;

        fileDispositionInformation.DeleteFile = TRUE;

        status = NtSetInformationFile(
                     fileHandle,
                     &ioStatusBlock,
                     &fileDispositionInformation,
                     sizeof(FILE_DISPOSITION_INFORMATION),
                     FileDispositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbDelete: NtSetInformationFile (disposition) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

            SrvCloseRfcbsOnLfcb( lfcb );

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return status;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "SrvSmbDelete: %wZ successfully deleted.\n", FullFileName ));
        }

        //
        // Close the RFCBs on the MFCB.  Since this is a compatability
        // or FCB open, there is only a single LFCB for the MFCB.  This
        // will result in the LFCB's file handle being closed, so there
        // is no need to call NtClose here.
        //

        SrvCloseRfcbsOnLfcb( lfcb );

        RELEASE_LOCK( &nonpagedMfcb->Lock );
        SrvDereferenceMfcb( mfcb );

    }

    return STATUS_SUCCESS;

} // DoDelete


SMB_PROCESSOR_RETURN_TYPE
SrvSmbRename (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Rename SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_RENAME;
    SrvWmiStartContext(WorkContext);
    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingRename;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbRename


VOID SRVFASTCALL
BlockingRename (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Rename SMB.

Arguments:

    WorkContext - work context block

Return Value:

    None.

--*/

{
    PREQ_RENAME request;
    PREQ_NTRENAME ntrequest;
    PUCHAR RenameBuffer;
    PRESP_RENAME response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING sourceName;
    UNICODE_STRING targetName;

    USHORT smbFlags;
    USHORT ByteCount;
    PCHAR target;
    PCHAR lastPositionInBuffer;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;
    BOOLEAN isNtRename;
    BOOLEAN isDfs;
    PSRV_DIRECTORY_INFORMATION directoryInformation;
    ULONG renameRetries;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_RENAME;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Rename file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Rename file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    response = (PRESP_RENAME)WorkContext->ResponseParameters;

    request = (PREQ_RENAME)WorkContext->RequestParameters;
    ntrequest = (PREQ_NTRENAME)WorkContext->RequestParameters;
    isNtRename =
        (BOOLEAN)(WorkContext->RequestHeader->Command == SMB_COM_NT_RENAME);

    if (isNtRename) {
        RenameBuffer = ntrequest->Buffer;
        ByteCount = MIN(SmbGetUshort(&ntrequest->ByteCount), (USHORT)(END_OF_REQUEST_SMB(WorkContext) + 1 - (PCHAR)RenameBuffer));
    } else {
        RenameBuffer = request->Buffer;
        ByteCount = MIN(SmbGetUshort(&request->ByteCount), (USHORT)(END_OF_REQUEST_SMB(WorkContext) + 1 - (PCHAR)RenameBuffer));
    }

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: Invalid UID or TID\n" ));
        }
        goto error_exit;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }

    //
    // Get the share block from the tree connect block.  This does not need
    // to be a referenced pointer because we have referenced the tree
    // connect, and it has the share referenced.
    //

    share = treeConnect->Share;

    //
    // Set up the path name for the file we will search for.  The +1
    // accounts for the ASCII token of the SMB protocol.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    isDfs = SMB_CONTAINS_DFS_NAME( WorkContext );

    //
    // Get a pointer to the new pathname of the file.  This is in the
    // buffer field of the request SMB after the source name.  The
    // target is delimited by the SMB_FORMAT_ASCII.
    //
    // While doing this, make sure that we do not walk off the end of the
    // SMB buffer if the client did not include the SMB_FORMAT_ASCII
    // token.
    //

    lastPositionInBuffer = (PCHAR)RenameBuffer + ByteCount;

    if( !isUnicode ) {
        for ( target = (PCHAR)RenameBuffer + 1;
              (target < lastPositionInBuffer) && (*target != SMB_FORMAT_ASCII);
              target++ ) {
            ;
        }
    } else {
        PWCHAR p = (PWCHAR)(RenameBuffer + 1);

        //
        // Skip the Original filename part. The name is null-terminated
        // (see rdr\utils.c RdrCopyNetworkPath())
        //

        //
        // Ensure p is suitably aligned
        //
        p = ALIGN_SMB_WSTR(p);

        //
        // Skip over the source filename
        //
        for( p = ALIGN_SMB_WSTR(p);
             p < (PWCHAR)lastPositionInBuffer && *p != UNICODE_NULL;
             p++ ) {
            ;
        }

        //
        // Search for SMB_FORMAT_ASCII which preceeds the target name
        //
        //
        for ( target = (PUCHAR)(p + 1);
              target < lastPositionInBuffer && *target != SMB_FORMAT_ASCII;
              target++ ) {
            ;
        }
    }

    //
    // If there was no SMB_FORMAT_ASCII in the passed buffer, fail.
    //

    if ( (target >= lastPositionInBuffer) || (*target != SMB_FORMAT_ASCII) ) {

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    // Canonicalize out the Source name
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(RenameBuffer + 1),
            target,
            TRUE,
            isUnicode,
            &sourceName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: illegal path name: %s\n",
                        (PSZ)RenameBuffer + 1 ));
        }

        goto error_exit;
    }

    if( !sourceName.Length ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: No source name\n" ));
        }
        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    }


    //
    // If the SMB was originally marked as containing Dfs names, then the
    // call to SrvCanonicalizePathName for the source path has cleared that
    // flag. So, re-mark the SMB as containing Dfs names before calling
    // SrvCanonicalizePathName on the target path.
    //

    if (isDfs) {
        SMB_MARK_AS_DFS_NAME( WorkContext );
    }

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            target + 1,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &targetName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: illegal path name: %s\n", target + 1 ));
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        goto error_exit;
    }

    if( !targetName.Length ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingRename: No target name\n" ));
        }

        if( !isUnicode ) {
            RtlFreeUnicodeString( &sourceName );
        }

        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    }

    //
    // Ensure this client's RFCB cache is empty.  This covers the case
    //  where a client has open files in a directory we are trying
    //  to rename.
    //
    SrvCloseCachedRfcbsOnConnection( WorkContext->Connection );

    if ( !FsRtlDoesNameContainWildCards( &sourceName ) ) {
        USHORT InformationLevel = SMB_NT_RENAME_RENAME_FILE;
        ULONG ClusterCount = 0;

        if (isNtRename) {
             InformationLevel = SmbGetUshort(&ntrequest->InformationLevel);
             ClusterCount = SmbGetUlong(&ntrequest->ClusterCount);
        }

        smbFlags = 0;

        //
        // Use SrvMoveFile to rename the file.  The SmbOpenFunction is
        // set to indicate that existing files may not be overwritten,
        // and we may create new files.  Also, the target may not be
        // a directory; if it already exists as a directory, fail.
        //

        renameRetries = SrvSharingViolationRetryCount;

start_retry1:

        status = SrvMoveFile(
                     WorkContext,
                     WorkContext->TreeConnect->Share,
                     SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL,
                     &smbFlags,
                     SmbGetUshort( &request->SearchAttributes ),
                     TRUE,
                     InformationLevel,
                     ClusterCount,
                     &sourceName,
                     &targetName
                     );

        if ( (status == STATUS_SHARING_VIOLATION) &&
             (renameRetries-- > 0) ) {

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            goto start_retry1;

        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &targetName );
            RtlFreeUnicodeString( &sourceName );
        }

        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

    } else if (isNtRename) {             // Wild cards not allowed!
        status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto error_exit;
    } else {

        BOOLEAN firstCall = TRUE;
        UNICODE_STRING subdirInfo;
        CLONG bufferLength;
        BOOLEAN filterLongNames;

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = sourceName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &sourceName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        //
        // SrvQueryDirectoryFile requires a buffer from nonpaged pool.
        // Since this routine does not use the buffer field of the
        // request SMB after the pathname, use this.  The buffer must be
        // quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)((ULONG_PTR)((PCHAR)RenameBuffer + ByteCount + 7) & ~7);

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        smbFlags = 0;

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // Call SrvQueryDirectoryFile to get file(s) to rename, renaming as
        // we get each file.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to rename long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &sourceName,
                               NULL,
                               SmbGetUshort( &request->SearchAttributes ),
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;
            UNICODE_STRING sourceFileName;
            UNICODE_STRING sourcePathName;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingRename: SrvQueryDirectoryFile failed: %X\n",
                                status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                goto error_exit1;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // Note that we use the standard name to do the delete, even
            // though we may have matched on the NTFS short name.  The
            // client doesn't care which name we use to do the delete.
            //

            sourceFileName.Length = (SHORT)bothDirInfo->FileNameLength;
            sourceFileName.MaximumLength = sourceFileName.Length;
            sourceFileName.Buffer = bothDirInfo->FileName;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &sourceFileName,
                            sourceFileName.Length,
                            status ));
            }

            firstCall = FALSE;

            //
            // Set up the full source name string.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &sourceFileName,
                NULL,
                &sourcePathName
                );

            if ( sourcePathName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingRename: SrvAllocateAndBuildPathName failed: "
                                  "%X\n", status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit1;
            }

            //
            // Use SrvMoveFile to copy or rename the file.  The
            // SmbOpenFunction is set to indicate that existing files
            // may not be overwritten, and we may create new files.
            //
            // *** SrvQueryDirectoryFile has already filtered based on
            //     the search attributes, so tell SrvMoveFile that files
            //     with the system and hidden bits are OK.  This will
            //     prevent the call to NtQueryDirectoryFile performed in
            //     SrvCheckSearchAttributesForHandle.
            //

            renameRetries = SrvSharingViolationRetryCount;

start_retry2:

            status = SrvMoveFile(
                         WorkContext,
                         WorkContext->TreeConnect->Share,
                         SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL,
                         &smbFlags,
                         (USHORT)(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN),
                         TRUE,
                         SMB_NT_RENAME_RENAME_FILE,
                         0,
                         &sourcePathName,
                         &targetName
                         );

            if ( (status == STATUS_SHARING_VIOLATION) &&
                 (renameRetries-- > 0) ) {

                (VOID) KeDelayExecutionThread(
                                        KernelMode,
                                        FALSE,
                                        &SrvSharingViolationDelay
                                        );

                goto start_retry2;

            }

            FREE_HEAP( sourcePathName.Buffer );

            if ( !NT_SUCCESS(status) ) {

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &targetName );
                    RtlFreeUnicodeString( &sourceName );
                }

                goto error_exit1;
            }
        }

        //
        // Clean up now that the search is done.
        //

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &targetName );
            RtlFreeUnicodeString( &sourceName );
        }

        SrvCloseQueryDirectory( directoryInformation );

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto error_exit;
        }
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_RENAME,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "BlockingRename complete.\n" ));
    goto normal_exit;

error_exit1:

    SrvCloseQueryDirectory( directoryInformation );

error_exit:

    SrvSetSmbError( WorkContext, status );

normal_exit:

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingRename


SMB_PROCESSOR_RETURN_TYPE
SrvSmbMove (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Move SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_MOVE;
    SrvWmiStartContext(WorkContext);

    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingMove;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbMove


VOID SRVFASTCALL
BlockingMove (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Move SMB.

Arguments:

    WorkContext - work context block

Return Value:

    None.

--*/

{
    PREQ_MOVE request;
    PRESP_MOVE response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING sourceName;
    UNICODE_STRING sourceFileName;
    UNICODE_STRING sourcePathName;
    UNICODE_STRING targetName;

    PSRV_DIRECTORY_INFORMATION directoryInformation;

    USHORT tid2;
    USHORT smbFlags;
    PCHAR lastPositionInBuffer;
    PCHAR target;
    BOOLEAN isRenameOperation;
    BOOLEAN isUnicode = TRUE;
    BOOLEAN isDfs;
    USHORT smbOpenFunction;
    USHORT errorPathNameLength = 0;
    USHORT count = 0;

    PTREE_CONNECT sourceTreeConnect, targetTreeConnect;
    PSESSION session;
    PSHARE share;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_MOVE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Move/Copy request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Move/Copy request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_MOVE)WorkContext->RequestParameters;
    response = (PRESP_MOVE)WorkContext->ResponseParameters;

    //
    // Set pointers to NULL so that we know how to clean up on exit.
    //

    directoryInformation = NULL;
    targetTreeConnect = NULL;
    sourceName.Buffer = NULL;
    targetName.Buffer = NULL;
    sourcePathName.Buffer = NULL;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &sourceTreeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: Invalid UID or TID\n" ));
        }
        goto exit;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        goto exit;
    }

    //
    // Get the share block from the tree connect block.  This does not need
    // to be a referenced pointer because we have referenced the tree
    // connect, and it has the share referenced.
    //

    share = sourceTreeConnect->Share;

    //
    // Get the target tree connect.  The TID for this is in the Tid2
    // field of the request SMB.  Because SrvVerifyTid sets the
    // TreeConnect field of the WorkContext block, set it back after
    // calling the routine.  Remember to dereference this pointer before
    // exiting this routine, as it will not be automatically
    // dereferenced because it is not in the WorkContext block.
    //
    // If Tid2 is -1 (0xFFFF), then the TID specified in the SMB header
    // is used.
    //

    tid2 = SmbGetUshort( &request->Tid2 );
    if ( tid2 == (USHORT)0xFFFF ) {
        tid2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid );
    }

    WorkContext->TreeConnect = NULL;         // Must be NULL for SrvVerifyTid

    targetTreeConnect = SrvVerifyTid( WorkContext, tid2 );

    WorkContext->TreeConnect = sourceTreeConnect;

    if ( targetTreeConnect == NULL ||
         targetTreeConnect->Share->ShareType != ShareTypeDisk ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: Invalid TID2: 0x%lx\n", tid2 ));
        }

        status = STATUS_SMB_BAD_TID;
        goto exit;
    }

    //
    // Determine whether this is a rename or a copy.
    //

    if ( WorkContext->RequestHeader->Command == SMB_COM_MOVE ) {
        isRenameOperation = TRUE;
    } else {
        isRenameOperation = FALSE;
    }

    //
    // Store the open function.
    //

    smbOpenFunction = SmbGetUshort( &request->OpenFunction );

    //
    // Set up the target pathnames.  We must do the target first, as the
    // SMB rename extended protocol does not use the ASCII tokens, so we
    // will lose the information about the start of the target name when
    // we canonicalize the source name.
    //
    // Instead of using strlen() to find the end of the source string,
    // do it here so that we can make a check to ensure that we don't
    // walk off the end of the SMB buffer and cause an access violation.
    //

    lastPositionInBuffer = (PCHAR)request->Buffer +
                           SmbGetUshort( &request->ByteCount );
    if( lastPositionInBuffer > END_OF_REQUEST_SMB( WorkContext )+1 )
    {
        SrvLogInvalidSmb( WorkContext );

        status = STATUS_INVALID_SMB;
        goto exit;
    }

    for ( target = (PCHAR)request->Buffer;
          (target < lastPositionInBuffer) && (*target != 0);
          target++ ) {
        ;
    }

    //
    // If there was no zero terminator in the buffer, fail.
    //

    if ( (target == lastPositionInBuffer) || (*target != 0) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "No terminator on first name.\n" ));
        }

        SrvLogInvalidSmb( WorkContext );

        status = STATUS_INVALID_SMB;
        goto exit;

    }

    target++;

    isUnicode = SMB_IS_UNICODE( WorkContext );
    isDfs = SMB_CONTAINS_DFS_NAME( WorkContext );
    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            target,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &targetName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: illegal path name (target): %wZ\n",
                        &targetName ));
        }

        goto exit;
    }

    //
    // If the SMB was originally marked as containing Dfs names, then the
    // call to SrvCanonicalizePathName for the target path has cleared that
    // flag. So, re-mark the SMB as containing Dfs names before calling
    // SrvCanonicalizePathName on the source path.
    //

    if (isDfs) {
        SMB_MARK_AS_DFS_NAME( WorkContext );
    }

    //
    // Set up the source name.
    //

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            request->Buffer,
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &sourceName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "BlockingMove: illegal path name (source): %s\n",
                          request->Buffer ));
        }

        goto exit;
    }

    smbFlags = SmbGetUshort( &request->Flags );

    //
    // Copy interprets ; as *.  If the last character was ; and this was
    // not at the end of a file name with other characters (as in
    // "file;" then convert the ; to *.
    //

    if ( sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-1] == ';' &&
             ( sourceName.Length == 2 ||
               sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-2] == '\\' ) ) {

        sourceName.Buffer[(sourceName.Length/sizeof(WCHAR))-1] = '*';
    }

    //
    // Tree copy not implemented.  If this is a single file copy,
    // let it go through.  For now, we make sure that it does not
    // have any wild card characters, we do additional checking
    // inside SrvMoveFile.
    //

    if ( ( (smbFlags & SMB_COPY_TREE) != 0 ) &&
         FsRtlDoesNameContainWildCards(&sourceName) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "Tree copy not implemented.",
            NULL,
            NULL
            );
        status = STATUS_NOT_IMPLEMENTED;
        goto exit;
    }

    if ( !FsRtlDoesNameContainWildCards( &sourceName ) ) {

        //
        // Use SrvMoveFile to copy or move the file.
        //
        // *** These SMBs do not include search attributes, so set
        //     this field equal to zero.  If will not be possible
        //     to move a file that has the system or hidden bits on.

        status = SrvMoveFile(
                     WorkContext,
                     targetTreeConnect->Share,
                     smbOpenFunction,
                     &smbFlags,
                     (USHORT)0,             // SmbSearchAttributes
                     FALSE,
                     (USHORT)(isRenameOperation?
                         SMB_NT_RENAME_RENAME_FILE : SMB_NT_RENAME_MOVE_FILE),
                     0,
                     &sourceName,
                     &targetName
                     );

        if ( !NT_SUCCESS(status) ) {
            goto exit;
        }

        count = 1;

    } else {

        UNICODE_STRING subdirInfo;

        BOOLEAN firstCall = TRUE;
        CLONG bufferLength;
        BOOLEAN filterLongNames;

        //
        // If wildcards were in the original source name, we set the
        // SmbFlags to SMB_TARGET_IS_DIRECTORY to indicate that the
        // target must be a directory--this is always the case when
        // wildcards are used for a rename.  (For a copy, it is legal to
        // specify that the destination is a file and append to that
        // file--then all the source files are concatenated to that one
        // target file.)
        //

        if ( isRenameOperation  ) {
            smbFlags |= SMB_TARGET_IS_DIRECTORY;
        }

        //
        // SrvQueryDirectoryFile requires a buffer from nonpaged pool.
        // Since this routine does not use the buffer field of the
        // request SMB after the pathname, use this.  The buffer must be
        // quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)( (ULONG_PTR)((PCHAR)request->Buffer +
            SmbGetUshort( &request->ByteCount ) + 7) & ~7 );

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = sourceName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &sourceName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // As long as SrvQueryDirectoryFile is able to return file names,
        // keep renaming.
        //
        // *** Set search attributes to find archive files, but not
        //     system or hidden files.  This duplicates the LM 2.0
        //     server behavior.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to move long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &sourceName,
                               NULL,
                               FILE_ATTRIBUTE_ARCHIVE, // SmbSearchAttributes
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "BlockingMove: SrvQueryDirectoryFile failed: %X\n",
                                status ));
                }

                goto exit;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // If we're filtering long names, and the file has a short
            // name equivalent, then use that name to do the delete.  We
            // do this because we need to return a name to the client if
            // the operation fails, and we don't want to return a long
            // name.  Note that if the file has no short name, and we're
            // filtering, then the standard name must be a valid 8.3
            // name, so it's OK to return to the client.
            //

            if ( filterLongNames && (bothDirInfo->ShortNameLength != 0) ) {
                sourceFileName.Length = (SHORT)bothDirInfo->ShortNameLength;
                sourceFileName.Buffer = bothDirInfo->ShortName;
            } else {
                sourceFileName.Length = (SHORT)bothDirInfo->FileNameLength;
                sourceFileName.Buffer = bothDirInfo->FileName;
            }
            sourceFileName.MaximumLength = sourceFileName.Length;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &sourceFileName,
                            sourceFileName.Length,
                            status ));
            }

            firstCall = FALSE;

            //
            // Set up the full source name string.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &sourceFileName,
                NULL,
                &sourcePathName
                );

            if ( sourcePathName.Buffer == NULL ) {
                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto exit;
            }

            //
            // Use SrvMoveFile to copy or rename the file.
            //

            status = SrvMoveFile(
                         WorkContext,
                         targetTreeConnect->Share,
                         smbOpenFunction,
                         &smbFlags,
                         (USHORT)0,          // SmbSearchAttributes
                         FALSE,
                         (USHORT)(isRenameOperation?
                           SMB_NT_RENAME_RENAME_FILE : SMB_NT_RENAME_MOVE_FILE),
                         0,
                         &sourcePathName,
                         &targetName
                         );

            if ( !NT_SUCCESS(status) ) {
                goto exit;
            }

            count++;

            //
            // Free the buffer that holds that source name.
            //

            FREE_HEAP( sourcePathName.Buffer );
            sourcePathName.Buffer = NULL;

            //
            // If this is a copy operation with wildcards and the target is
            // a file, then all files should be appended to the target.  The
            // target is truncated on the first call to SrvMoveFile if that
            // was specified by the caller.
            //
            // This is done by turning off the truncate bit in the
            // SmbOpenFunction and turning on the append bit.
            //

            if ( !isRenameOperation && directoryInformation->Wildcards &&
                     (smbFlags & SMB_TARGET_IS_FILE) ) {
                smbOpenFunction &= ~SMB_OFUN_OPEN_TRUNCATE;
                smbOpenFunction |= SMB_OFUN_OPEN_APPEND;
            }
        }

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto exit;
        }
    }

    //
    // Build the response SMB.
    //

    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_MOVE, 0 );

    status = STATUS_SUCCESS;

exit:

    response->WordCount = 1;
    SmbPutUshort( &response->Count, count );

    if ( directoryInformation != NULL ) {
        SrvCloseQueryDirectory( directoryInformation );
    }

    if ( targetTreeConnect != NULL) {
        SrvDereferenceTreeConnect( targetTreeConnect );
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );

        if ( sourcePathName.Buffer != NULL ) {

            //
            // Put the name of the file where the error occurred in the
            // buffer field of the response SMB.
            //

            RtlCopyMemory(
                response->Buffer,
                sourcePathName.Buffer,
                sourcePathName.Length
                );

            response->Buffer[sourcePathName.Length] = '\0';
            SmbPutUshort( &response->ByteCount, (SHORT)(sourcePathName.Length+1) );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_MOVE,
                                                  sourcePathName.Length+1
                                                  );

            FREE_HEAP( sourcePathName.Buffer );

        } else if ( sourceName.Buffer != NULL ) {

            //
            // Put the name of the file where the error occurred in the
            // buffer field of the response SMB.
            //

            RtlCopyMemory(
                response->Buffer,
                sourceName.Buffer,
                sourceName.Length
                );

            response->Buffer[sourceName.Length] = '\0';
            SmbPutUshort( &response->ByteCount, (SHORT)(sourceName.Length+1) );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_MOVE,
                                                  sourceName.Length+1
                                                  );
        }
    }

    if ( !isUnicode ) {
        if ( targetName.Buffer != NULL ) {
            RtlFreeUnicodeString( &targetName );
        }
        if ( sourceName.Buffer != NULL ) {
            RtlFreeUnicodeString( &sourceName );
        }
    }

    IF_DEBUG(TRACE2) KdPrint(( "BlockingMove complete.\n" ));
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingMove


SMB_TRANS_STATUS
SrvSmbNtRename (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the NT rename request.  This request arrives in an NT
    transact SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_NT_RENAME request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG( FILE_CONTROL1 ) {
        KdPrint(( "SrvSmbNtRename entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_NT_RENAME)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( transaction->ParameterCount < sizeof(REQ_NT_RENAME) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG( FILE_CONTROL1 ) {
            KdPrint(( "SrvSmbNtRename: bad parameter byte count: "
                        "%ld\n", transaction->ParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint((
                "SrvSmbNtRename: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                ));
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //


    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbNtRename complete.\n" ));
    return SmbTransStatusSuccess;

} // SrvSmbNtRename
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbctl.c

Abstract:

    This module implements the IoControl and FsControl SMBs.

    Transact2 Ioctl
    Nt Transaction Io Control

Author:

    Manny Weiser (mannyw) 10-Oct-91

Revision History:

--*/

#include "precomp.h"
#include "smbioctl.tmh"
#pragma hdrstop

NTSTATUS
ProcessOs2Ioctl (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Category,
    IN USHORT Function,
    IN PVOID Parameters,
    IN ULONG InputParameterCount,
    IN PULONG OutputParameterCount,
    IN PVOID Data,
    IN ULONG InputDataCount,
    IN ULONG MaxOutputData,
    IN PULONG OutputDataCount
    );

VOID SRVFASTCALL
RestartNtIoctl (
    IN PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbIoctl )
#pragma alloc_text( PAGE, SrvSmbIoctlSecondary )
#pragma alloc_text( PAGE, RestartNtIoctl )
#pragma alloc_text( PAGE, SrvSmbIoctl2 )
#pragma alloc_text( PAGE, SrvSmbFsctl )
#pragma alloc_text( PAGE, ProcessOs2Ioctl )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctl (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_IOCTL request;
    PRESP_IOCTL response;
    PSMB_HEADER header;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PSESSION session;
    PTREE_CONNECT treeConnect;
    PRFCB rfcb;

    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG parameterSize;        // Max of input and output parameter counts
    CLONG dataOffset;
    CLONG responseDataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG dataSize;             // Max of input and output data counts

    CLONG smbLength;
    CLONG numberOfPaddings = 0;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_IOCTL;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_IOCTL)WorkContext->RequestParameters;
    response = (PRESP_IOCTL)WorkContext->ResponseParameters;

    //
    // Since we do I/O from the SMB buffer, verify that the request and
    // response buffers are one and the same.
    //

    ASSERT( (PVOID)request == (PVOID)response );

    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        KdPrint(( "Ioctl (primary) request\n" ));
    }

    //
    // !!! Verify ioctl subcommand early?
    //

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    totalParameterCount = SmbGetUshort( &request->TotalParameterCount );
    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    totalDataCount = SmbGetUshort( &request->TotalDataCount );

    smbLength = WorkContext->RequestBuffer->DataLength;

    dataSize = MAX( dataCount, maxDataCount );
    parameterSize = MAX( parameterCount, maxParameterCount );

    if ( parameterCount != 0 ) {
        responseDataOffset = parameterOffset + parameterSize;
    } else {

        //
        // Some ioctls requests have  data offset of zero like
        // category 0x53, function 0x60.  If this is the case,
        // calculate the dataoffset by hand.
        //

        if ( dataOffset != 0 ) {
            responseDataOffset = dataOffset;
        } else {
            responseDataOffset = (CLONG) ((PUCHAR) response->Buffer -
                           (PUCHAR) WorkContext->ResponseHeader);
            numberOfPaddings = ( responseDataOffset & 0x01 );
            responseDataOffset = responseDataOffset + numberOfPaddings;
        }
    }

    //
    // Verify the size of the smb buffer:
    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //
    // We need room in the smb buffer for the response.  Ensure that
    // there is enough room.
    //
    // No ioctl secondary is expected.  Ensure that all data and
    // parameters have arrrived.
    //
    // Check that the response will fit in a single buffer.
    //

    if ( ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( (responseDataOffset + dataCount) >
            WorkContext->ResponseBuffer->BufferLength ) ||

         ( dataCount != totalDataCount ) ||
         ( parameterCount != totalParameterCount ) ||

         ( (parameterOffset > dataOffset) && (dataCount != 0) ) ) {


        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTransaction: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;",
                      parameterOffset, parameterCount ));
            KdPrint(( "dOff=%ld,dCnt=%ld;", dataOffset, dataCount ));
            KdPrint(( "smbLen=%ld", smbLength ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // If a tree connect block has not already been assigned to the
    // current work context, find the tree connect corresponding to the
    // given TID.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbIoctl: Invalid UID or TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                request->Fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbIoctl: Status %X on FID: 0x%lx\n",
                    request->Fid,
                    status
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Make room in the SMB buffer for return parameters by copying data
    //

    if ( dataOffset != responseDataOffset && dataCount != 0) {
        RtlMoveMemory(
            (PCHAR)header + responseDataOffset,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Process the ioctl.  The response will overwrite the request buffer.
    //

    status = ProcessOs2Ioctl(
                WorkContext,
                request->Category,
                request->Function,
                (PCHAR)WorkContext->RequestHeader + parameterOffset,
                totalParameterCount,
                &maxParameterCount,
                (PCHAR)WorkContext->RequestHeader + responseDataOffset,
                totalDataCount,
                WorkContext->ResponseBuffer->BufferLength -
                    PTR_DIFF(WorkContext->RequestHeader,
                             WorkContext->ResponseBuffer->Buffer) -
                    responseDataOffset,
                &maxDataCount
                );

    //
    // Format and send the response, the parameter and data bytes are
    // already in place.
    //

    if ( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    response->WordCount = 8;
    SmbPutUshort( &response->TotalParameterCount, (USHORT)maxParameterCount );
    SmbPutUshort( &response->TotalDataCount, (USHORT)maxDataCount );
    SmbPutUshort( &response->ParameterCount, (USHORT)maxParameterCount );
    SmbPutUshort( &response->ParameterOffset, (USHORT)parameterOffset );
    SmbPutUshort( &response->ParameterDisplacement, 0);
    SmbPutUshort( &response->DataCount, (USHORT)maxDataCount );
    SmbPutUshort( &response->DataOffset, (USHORT)responseDataOffset );
    SmbPutUshort( &response->DataDisplacement, 0 );

    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(maxDataCount + numberOfPaddings)
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_IOCTL,
                                          maxDataCount + numberOfPaddings
                                          );

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbIoctl


SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctlSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PAGED_CODE( );

    //
    // This SMB is not supported.
    //

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
    return SmbStatusSendResponse;
}


SMB_TRANS_STATUS
SrvSmbNtIoctl (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Nt Ioctl SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    NTSTATUS status;
    ULONG functionCode;
    USHORT fid;
    BOOLEAN isFsctl;

    PREQ_NT_IO_CONTROL request;

    PTRANSACTION transaction;
    PRFCB rfcb;
    PMDL mdl = NULL;

    transaction = WorkContext->Parameters.Transaction;

    if( transaction->SetupCount * sizeof(USHORT) < sizeof(REQ_NT_IO_CONTROL ) )
    {
        IF_DEBUG(ERRORS) {
            KdPrint(("SrvSmbNtIoctl: Not enough Setup bytes sent\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    request = (PREQ_NT_IO_CONTROL)transaction->InSetup;

    functionCode = SmbGetAlignedUlong( &request->FunctionCode );
    fid = SmbGetAlignedUshort( &request->Fid );
    isFsctl = request->IsFsctl;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbNtIoctl: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            return SmbTransStatusErrorWithoutData;

        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Only allow these fellows against disk files
    //
    if( rfcb->ShareType != ShareTypeDisk ) {
        SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
        SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
        return SmbTransStatusInProgress;
    }

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        (UCHAR)(isFsctl ? IRP_MJ_FILE_SYSTEM_CONTROL : IRP_MJ_DEVICE_CONTROL),
        0,
        functionCode,
        &status
        );

    if ( !NT_SUCCESS( status ) ) {
        SrvStatistics.GrantedAccessErrors++;
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // There are some functions which we cannot allow.  Weed them out here
    //
    switch( functionCode ) {
    case FSCTL_SET_REPARSE_POINT:

        //
        // If there's not enough data, or the structure is internally inconsistent --
        //  fail the request
        //
        status = STATUS_SUCCESS;

        if( transaction->DataCount == 0 ) {
            status = STATUS_INVALID_BUFFER_SIZE;

        } else if ( transaction->DataCount < REPARSE_DATA_BUFFER_HEADER_SIZE ||
            ((PREPARSE_DATA_BUFFER)transaction->InData)->ReparseDataLength >
            transaction->DataCount - FIELD_OFFSET( REPARSE_DATA_BUFFER, GenericReparseBuffer )
        ) {
            status = STATUS_IO_REPARSE_DATA_INVALID;
        }

        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        //
        // Only an administrator is allowed to set generalized reparse points,
        //  otherwise it is too easy to escape the share.  This seems safer
        //  than a path check, and it also allows the administrator to point
        //  the reparse point to wherever s/he desires.
        //
        if( !WorkContext->Session->IsAdmin ) {
            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        break;

    case FSCTL_SRV_ENUMERATE_SNAPSHOTS:
        {
            if( SrvProductTypeServer )
            {
                status = SrvSnapEnumerateSnapShots( WorkContext );
                if( !NT_SUCCESS(status) )
                {
                    SrvSetSmbError( WorkContext, status );
                    SrvCompleteExecuteTransaction( WorkContext, (status==STATUS_BUFFER_OVERFLOW)?SmbTransStatusErrorWithData:SmbTransStatusErrorWithoutData );
                }
                else
                {
                    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusSuccess );
                }
                return SmbTransStatusInProgress;
            }
            else
            {
                status = STATUS_NOT_IMPLEMENTED;
                SrvSetSmbError( WorkContext, status );
                SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
                return SmbTransStatusInProgress;
            }
        }
        break;

    case FSCTL_SRV_REQUEST_RESUME_KEY:
        {
            // Queries the Resume Key for a given file
            ULONG resumeKey = rfcb->GlobalRfcbListEntry.ResumeHandle;

            if( transaction->MaxDataCount < sizeof(SRV_REQUEST_RESUME_KEY) )
            {
                status = STATUS_INVALID_PARAMETER;
                SrvSetSmbError( WorkContext, status );
                SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            }
            else
            {
                PSRV_REQUEST_RESUME_KEY pResumeData = (PSRV_REQUEST_RESUME_KEY)transaction->OutData;
        ULONG   InLength = transaction->DataCount;

                transaction->DataCount = sizeof(SRV_REQUEST_RESUME_KEY);

                pResumeData->Key.ResumeKey = (UINT64)(rfcb->GlobalRfcbListEntry.ResumeHandle);
                pResumeData->Key.Timestamp = (UINT64)(rfcb->PagedRfcb->OpenTime.QuadPart);
                pResumeData->Key.Pid       = (UINT64)SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
                pResumeData->Key.Pid       |= ((UINT64)SmbGetAlignedUshort( &WorkContext->RequestHeader->PidHigh ) << 16);

                ACQUIRE_LOCK( &SrvConfigurationLock );
                if( SrvLWIOContext )
                {
                    if( transaction->MaxDataCount < FIELD_OFFSET(SRV_REQUEST_RESUME_KEY, Context) + SrvLWIOContextLength )
                    {
            pResumeData->ContextLength = SrvLWIOContextLength;
                        status = STATUS_BUFFER_TOO_SMALL;
                    }
                    else
                    {
                        RtlCopyMemory( pResumeData->Context, SrvLWIOContext, SrvLWIOContextLength );
                        pResumeData->ContextLength = SrvLWIOContextLength;

                        if( SrvLWIOCallback )
                        {
                            status = SrvLWIOCallback( WorkContext->Connection->OemClientMachineName,
                              WorkContext->SecurityContext->UserHandle,
                              pResumeData, transaction->MaxDataCount,
                              transaction->InData, InLength);
                        }
                        else
                        {
                            status = STATUS_SUCCESS;
                        }

                        transaction->DataCount = FIELD_OFFSET(SRV_REQUEST_RESUME_KEY, Context) + pResumeData->ContextLength;
                    }
                }
                else
                {
                    pResumeData->ContextLength = 0;
                    status = STATUS_SUCCESS;
                }

                RELEASE_LOCK( &SrvConfigurationLock );

                if( !NT_SUCCESS(status) )
                {
                    SrvSetSmbError( WorkContext, status );
                    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
                }
                else
                {
                    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusSuccess );
                }
            }

            return SmbTransStatusInProgress;
        }
        break;

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_MOVE_FILE:
    case FSCTL_MARK_HANDLE:
    case FSCTL_QUERY_RETRIEVAL_POINTERS:
    case FSCTL_PIPE_ASSIGN_EVENT:
    case FSCTL_GET_VOLUME_BITMAP:
    case FSCTL_GET_NTFS_FILE_RECORD:
    case FSCTL_INVALIDATE_VOLUMES:

    // We don't support USN journal calls because they require a volume handle
    case FSCTL_READ_USN_JOURNAL:
    case FSCTL_CREATE_USN_JOURNAL:
    case FSCTL_QUERY_USN_JOURNAL:
    case FSCTL_DELETE_USN_JOURNAL:
    case FSCTL_ENUM_USN_DATA:
        SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
        SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
        return SmbTransStatusInProgress;
    }

    if (functionCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION) {

        // This is a FSCTL that is used for link tracking purposes. It is
        // an internal FSCTL issued by the I/O subsystem. Currently this
        // is being handled in the context of a worker thread. We need
        // to ensure that this arm of the code is only executed in the
        // context of a blocking thread.

        // Also note that the incoming structure will always be the 32-bit structure, even
        // from 64-bit machines.  All structures on the wire are 32-bit for backwards compatibility

        KIRQL        oldIrql;
        PRFCB        rfcbTarget = NULL;
        USHORT       TargetFid;
        PVOID        TargetHandle;
        ULONG        TargetInformationLength;
        ULONG        LinkTrackingInformationSize;

        if( transaction->DataCount < sizeof( REMOTE_LINK_TRACKING_INFORMATION32 ) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        TargetHandle = UlongToHandle( SmbGetUlong(
                           (PUCHAR)transaction->InData +
                           FIELD_OFFSET(
                               REMOTE_LINK_TRACKING_INFORMATION32,
                               TargetFileObject)) );

        TargetInformationLength = SmbGetUlong(
                                      (PUCHAR)transaction->InData +
                                      FIELD_OFFSET(
                                          REMOTE_LINK_TRACKING_INFORMATION32,
                                          TargetLinkTrackingInformationLength));

        LinkTrackingInformationSize = FIELD_OFFSET(
                                          FILE_TRACKING_INFORMATION32,
                                          ObjectInformation) +
                                          TargetInformationLength;

        //
        // Make sure the REMOTE_LINK_TRACKING_INFORMATION structure is reasonable
        //
        if( TargetInformationLength > transaction->DataCount ||
            LinkTrackingInformationSize > transaction->DataCount ) {

            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        if (TargetHandle != NULL) {

            TargetFid = (USHORT)TargetHandle;

            //
            // Verify the FID.  This code is lifted from SrvVerifyFid2.
            //

            //
            // Acquire the spin lock that guards the connection's file table.
            //

            ACQUIRE_SPIN_LOCK( &WorkContext->Connection->SpinLock, &oldIrql );

            //
            // See if this is the cached rfcb
            //

            if ( WorkContext->Connection->CachedFid == (ULONG)TargetFid ) {

                rfcbTarget = WorkContext->Connection->CachedRfcb;

            } else {
                USHORT index;
                USHORT sequence;
                PTABLE_HEADER tableHeader;

                //
                // Verify that the FID is in range, is in use, and has the correct
                // sequence number.

                index = FID_INDEX( TargetFid );
                sequence = FID_SEQUENCE( TargetFid );
                tableHeader = &WorkContext->Connection->FileTable;

                if ( (index < (USHORT)tableHeader->TableSize) &&
                     (tableHeader->Table[index].Owner != NULL) &&
                     (tableHeader->Table[index].SequenceNumber == sequence) &&
                     (GET_BLOCK_STATE(tableHeader->Table[index].Owner) == BlockStateActive) ) {

                    rfcbTarget = tableHeader->Table[index].Owner;

                    //
                    // Cache the fid.
                    //

                    WorkContext->Connection->CachedRfcb = rfcbTarget;
                    WorkContext->Connection->CachedFid = (ULONG)TargetFid;

                }
            }

            RELEASE_SPIN_LOCK( &WorkContext->Connection->SpinLock, oldIrql );
        }

        if( rfcbTarget != NULL || TargetHandle == NULL ) {

            PFILE_TRACKING_INFORMATION pTrackingInformation;
            IO_STATUS_BLOCK   ioStatusBlock;

            // Since the data in the InData buffer is unaligned we need to allocate
            // a copy of the data that is aligned and copy the information over
            // before passing it on in the SetInformationCall
            // We also resize the buffer to the native structure on 64 bit (no change occurs on 32 bit)

            pTrackingInformation = ALLOCATE_HEAP( LinkTrackingInformationSize + sizeof(PVOID) - sizeof(ULONG), BlockTypeMisc );

            if (pTrackingInformation != NULL) {
                if (rfcbTarget != NULL) {
                    pTrackingInformation->DestinationFile =
                        rfcbTarget->Lfcb->FileHandle;
                } else {
                    pTrackingInformation->DestinationFile = NULL;
                }

                pTrackingInformation->ObjectInformationLength =
                    TargetInformationLength;

                RtlCopyMemory(
                    pTrackingInformation->ObjectInformation,
                    ((PUCHAR)transaction->InData +
                     FIELD_OFFSET(
                         REMOTE_LINK_TRACKING_INFORMATION,
                         TargetLinkTrackingInformationBuffer)),
                    TargetInformationLength);

                status = NtSetInformationFile(
                             rfcb->Lfcb->FileHandle,
                             &ioStatusBlock,
                             pTrackingInformation,
                             LinkTrackingInformationSize,
                             FileTrackingInformation);

                FREE_HEAP(pTrackingInformation);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        if (!NT_SUCCESS(status)) {
            SrvSetSmbError( WorkContext, status );
            SrvCompleteExecuteTransaction(
                WorkContext,
                SmbTransStatusErrorWithoutData
                );
        } else {
            transaction->DataCount = 0;
            transaction->ParameterCount = 0;

            SrvCompleteExecuteTransaction(
                WorkContext,
                SmbTransStatusSuccess
                );
        }

        return SmbTransStatusInProgress;

    }

    //
    // Since we are doing ioctls to this file, it doesn't seem like it's
    //  a "normal" file.  We had better not cache its handle after the close.
    //  Specifically, remote setting of the file's compression state is
    //  not reflected to the directory entry until the file is closed.  And
    //  setting a file's compression state is done with an ioctl
    //
    rfcb->IsCacheable = FALSE;

    if (functionCode == FSCTL_SIS_COPYFILE) {

        //
        // This the single-instance store copy FSCTL. We need to modify
        // the file names, which are passed as share-relative names,
        // to be full NT paths.
        //

        PSI_COPYFILE copyFile;
        PSI_COPYFILE newCopyFile;
        ULONG bufferLength;
        PWCHAR source;
        ULONG sourceLength;
        PWCHAR dest;
        ULONG destLength;
        PSHARE share;
        PWCHAR prefix;
        ULONG prefixLength;
        PCHAR p;
        ULONG addSlashToSource;
        ULONG addSlashToDest;

        copyFile = (PSI_COPYFILE)transaction->InData;
        bufferLength = transaction->DataCount;

        if( bufferLength < sizeof( SI_COPYFILE ) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusErrorWithoutData );
            return SmbTransStatusInProgress;
        }

        //
        // Get the share-relative paths.
        //

        source = copyFile->FileNameBuffer;
        sourceLength = copyFile->SourceFileNameLength;
        dest = source + (sourceLength / sizeof(WCHAR));
        destLength = copyFile->DestinationFileNameLength;

        //
        // Verify that the input structure is reasonable.
        //

        if ( (sourceLength > bufferLength || sourceLength == 0 ) ||
             (destLength > bufferLength || destLength == 0 ) ||
             ((FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) + sourceLength + destLength) > bufferLength) ||
             (*(source + (sourceLength/sizeof(WCHAR)-1)) != 0) ||
             (*(dest + (destLength/sizeof(WCHAR)-1)) != 0) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            return SmbTransStatusErrorWithoutData;
        }

        ASSERT( (FSCTL_SIS_COPYFILE & 3) == METHOD_BUFFERED );

        //
        // Get the NT path prefix for the share.
        //

        share = WorkContext->TreeConnect->Share;
        prefix = share->NtPathName.Buffer;
        prefixLength = share->NtPathName.Length;

        //
        // Make sure there is exactly one slash between the share prefix
        // and the paths in the request.
        //

        addSlashToSource = 0;
        addSlashToDest = 0;
        if ( IS_UNICODE_PATH_SEPARATOR(*(prefix + (prefixLength/sizeof(WCHAR)-1))) ) {
            if ( IS_UNICODE_PATH_SEPARATOR(*source) ) {
                source++;
                sourceLength -= sizeof(WCHAR);
            }
            if ( IS_UNICODE_PATH_SEPARATOR(*dest) ) {
                dest++;
                destLength -= sizeof(WCHAR);
            }
        } else {
            if ( !IS_UNICODE_PATH_SEPARATOR(*source) ) {
                addSlashToSource = sizeof(WCHAR);
            }
            if ( !IS_UNICODE_PATH_SEPARATOR(*dest) ) {
                addSlashToDest = sizeof(WCHAR);
            }
        }

        //
        // Allocate space for a new FSCTL command buffer.
        //

        bufferLength = FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) +
                       prefixLength + addSlashToSource + sourceLength +
                       prefixLength + addSlashToSource + destLength;
        newCopyFile = ALLOCATE_HEAP( bufferLength, BlockTypeBuffer );

        if( newCopyFile == NULL ) {
           SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
           return SmbTransStatusErrorWithoutData;
        }

        //
        // Initialize the FSCTL input buffer with the full NT path names.
        //

        newCopyFile->SourceFileNameLength = prefixLength + addSlashToSource + sourceLength;
        newCopyFile->DestinationFileNameLength = prefixLength + addSlashToDest + destLength;
        newCopyFile->Flags = copyFile->Flags;
        p = (PCHAR)newCopyFile->FileNameBuffer;
        RtlCopyMemory( p, prefix, prefixLength );
        p += prefixLength;
        if ( addSlashToSource != 0 ) {
            *(PWCHAR)p = UNICODE_DIR_SEPARATOR_CHAR;
            p += sizeof(WCHAR);
        }
        RtlCopyMemory( p, source, sourceLength );
        p += sourceLength;
        RtlCopyMemory( p, prefix, prefixLength );
        p += prefixLength;
        if ( addSlashToDest != 0 ) {
            *(PWCHAR)p = UNICODE_DIR_SEPARATOR_CHAR;
            p += sizeof(WCHAR);
        }
        RtlCopyMemory( p, dest, destLength );

        //
        // Modify the transaction to point to the new buffer and indicate
        // that the buffer should be freed when the transaction is done.
        // (Note that the original buffer was allocated as part of the
        // transaction block and doesn't need to be freed separately.)
        //

        transaction->InData = (PVOID)newCopyFile;
        transaction->OutData = (PVOID)newCopyFile;
        transaction->DataCount = bufferLength;
        transaction->OutputBufferCopied = TRUE;
        transaction->OutDataAllocated = TRUE;
    }

    switch( functionCode & 3 ) {
    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:

        if( transaction->TotalDataCount ) {
            //
            // Need an mdl
            //
            status = STATUS_SUCCESS;

            mdl = IoAllocateMdl(
                      transaction->InData,
                      transaction->TotalDataCount,
                      FALSE,
                      FALSE,
                      NULL
                      );

            if ( mdl == NULL ) {
                status = STATUS_INSUFF_SERVER_RESOURCES;
            } else {

                //
                // Build the mdl
                //

                try {
                    MmProbeAndLockPages(
                        mdl,
                        KernelMode,
                        IoReadAccess
                        );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    status = GetExceptionCode();
                    IoFreeMdl( mdl );
                    mdl = NULL;
                }
            }

            if( !NT_SUCCESS( status ) ) {
                SrvSetSmbError( WorkContext, status );
                return SmbTransStatusErrorWithoutData;
            }
        }
        break;

    case METHOD_NEITHER:
        //
        // We need to allocate the output buffer for this fsctl, because at
        //  this point both the input and output buffers point to the same
        //  region of memory.  This can't be guaranteed to work for METHOD_NEITHER
        //

        if( transaction->MaxDataCount ) {
            //
            // Let's not let the allocation get out of hand!
            //
            if( transaction->MaxDataCount > SrvMaxFsctlBufferSize ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                return SmbTransStatusErrorWithoutData;
            }

            transaction->OutData = ALLOCATE_HEAP( transaction->MaxDataCount, BlockTypeBuffer );

            if( transaction->OutData == NULL ) {
               SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
               return SmbTransStatusErrorWithoutData;
            }

            RtlZeroMemory( transaction->OutData, transaction->MaxDataCount );
            transaction->OutputBufferCopied = TRUE;
            transaction->OutDataAllocated = TRUE;
        }

        break;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartNtIoctl;

    //
    // Build the IRP to start the I/O control.
    // Pass this request to the filesystem.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        (UCHAR)(isFsctl ? IRP_MJ_FILE_SYSTEM_CONTROL : IRP_MJ_DEVICE_CONTROL),
        functionCode,
        transaction->InData,
        transaction->DataCount,
        transaction->OutData,
        transaction->MaxDataCount,
        mdl,
        NULL        // Completion routine
        );

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject(rfcb->Lfcb->FileObject ),
                WorkContext->Irp
                );

    //
    // The call was successfully started, return InProgress to the caller
    //

    return SmbTransStatusInProgress;

} // SrvSmbNtIoctl


VOID SRVFASTCALL
RestartNtIoctl (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the completion of an NT Io control SMB.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG length;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // Free the MDL if one was allocated.
    //

    if ( WorkContext->Irp->MdlAddress != NULL ) {
        MmUnlockPages( WorkContext->Irp->MdlAddress );
        IoFreeMdl( WorkContext->Irp->MdlAddress );
        WorkContext->Irp->MdlAddress = NULL;
    }

    //
    // If the Io Control request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( NT_ERROR(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "RestartNtIoctl:  Io control failed: %X\n",
                        status ));
        }
        SrvSetSmbError( WorkContext, status );

        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );

    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction = WorkContext->Parameters.Transaction;

        length = MIN( (ULONG)WorkContext->Irp->IoStatus.Information, transaction->MaxDataCount );

        if ( transaction->MaxSetupCount > 0 ) {
            transaction->SetupCount = 1;
            SmbPutUshort( transaction->OutSetup, (USHORT)length );
        }

        transaction->ParameterCount = transaction->MaxParameterCount;
        transaction->DataCount = length;

        if (!NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "RestartNtIoctl:  Io control failed: %X\n",
                            status ));
            }
            SrvSetSmbError2( WorkContext, status, TRUE );

            SrvCompleteExecuteTransaction(
                            WorkContext,
                            SmbTransStatusErrorWithData
                            );
        } else {
            SrvCompleteExecuteTransaction(
                            WorkContext,
                            SmbTransStatusSuccess);
        }

    }

    return;

} // RestartNtIoctl


SMB_TRANS_STATUS
SrvSmbIoctl2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the Ioctl request.  This request arrives in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_IOCTL2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(TRANSACTION2) {
        KdPrint(( "Ioctl2 entered; transaction 0x%p\n",
                    transaction ));
    }

    //request = (PREQ_IOCTL2)transaction->InSetup;

    //
    // Verify the setup count.
    //

    if ( transaction->SetupCount != 4 * sizeof( USHORT ) ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                transaction->InSetup[1],
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbIoctl2: Status %X on FID: 0x%lx\n",
                    transaction->InSetup[1],
                    status
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    transaction->Category = transaction->InSetup[2];
    transaction->Function = transaction->InSetup[3];

    //
    // Perform the Ioctl
    //

    status = ProcessOs2Ioctl(
                 WorkContext,
                 transaction->InSetup[2],
                 transaction->InSetup[3],
                 transaction->InParameters,
                 transaction->ParameterCount,
                 &transaction->MaxParameterCount,
                 transaction->OutData,
                 transaction->DataCount,
                 transaction->MaxDataCount,
                 &transaction->MaxDataCount
                 );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = transaction->MaxParameterCount;
    transaction->DataCount = transaction->MaxDataCount;
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbIoctl2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbIoctl2


SMB_TRANS_STATUS
SrvSmbFsctl (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );

    //
    // The OS/2 redirector never sends a remote FS control request.
    // If we get one, simply reply that we cannot handle it.
    //

    return SrvTransactionNotImplemented( WorkContext );

} // SrvSmbFsctl


#define SERIAL_DEVICE           0x1
#define PRINTER_DEVICE          0x5
#define GENERAL_DEVICE          0xB
#define SPOOLER_DEVICE          0x53

//
// Serial device functions supported
//

#define SET_BAUD_RATE          0x41
#define SET_LINE_CONTROL       0x42
#define SET_TRANSMIT_TIMEOUT   0x44
#define SET_BREAK_OFF          0x45
#define SET_MODEM_CONTROL      0x46
#define SET_BREAK_ON           0x4B
#define STOP_TRANSMIT          0x47
#define START_TRANSMIT         0x48
#define SET_DCB_INFORMATION    0x53
#define GET_BAUD_RATE          0x61
#define GET_LINE_CONTROL       0x62
#define GET_COMM_STATUS        0x64
#define GET_LINE_STATUS        0x65
#define GET_MODEM_OUTPUT       0x66
#define GET_MODEM_INPUT        0x67
#define GET_INQUEUE_COUNT      0x68
#define GET_OUTQUEUE_COUNT     0x69
#define GET_COMM_ERROR         0x6D
#define GET_COMM_EVENT         0x72
#define GET_DCB_INFORMATION    0x73

//
// Print device function supported.
//
// *** Note:  The OS/2 server supports 2 additional Ioctl functions.
//            ActivateFont (0x48) and QueryActiveFont (0x69).  Since these
//            were designed only to support IBM proplus printer from OS/2
//            and we can't correctly support these function, we don't.
//

#define GET_PRINTER_ID         0x60
#define GET_PRINTER_STATUS     0x66

#define OS2_STATUS_PRINTER_HAPPY 0x90

typedef struct _SMB_IOCTL_LINECONTROL {
    UCHAR DataBits;
    UCHAR Parity;
    UCHAR StopBits;
    UCHAR TransBreak;
} SMB_IOCTL_LINE_CONTROL, *PSMB_IOCTL_LINE_CONTROL;

typedef struct _SMB_IOCTL_BAUD_RATE {
    USHORT BaudRate;
} SMB_IOCTL_BAUD_RATE, *PSMB_IOCTL_BAUD_RATE;

typedef struct _SMB_IOCTL_DEVICE_CONTROL {
    USHORT WriteTimeout;
    USHORT ReadTimeout;
    UCHAR ControlHandShake;
    UCHAR FlowReplace;
    UCHAR Timeout;
    UCHAR ErrorReplacementChar;
    UCHAR BreakReplacementChar;
    UCHAR XonChar;
    UCHAR XoffChar;
} SMB_IOCTL_DEVICE_CONTROL, *PSMB_IOCTL_DEVICE_CONTROL;

typedef struct _SMB_IOCTL_COMM_ERROR {
    USHORT Error;
} SMB_IOCTL_COMM_ERROR, *PSMB_IOCTL_COMM_ERROR;

typedef struct _SMB_IOCTL_PRINTER_ID {
    USHORT JobId;
    UCHAR Buffer[1]; // server name and share name
} SMB_IOCTL_PRINTER_ID;

typedef SMB_IOCTL_PRINTER_ID SMB_UNALIGNED *PSMB_IOCTL_PRINTER_ID;

NTSTATUS
ProcessOs2Ioctl (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Category,
    IN USHORT Function,
    IN PVOID Parameters,
    IN ULONG InputParameterCount,
    IN OUT PULONG OutputParameterCount,
    IN PVOID Data,
    IN ULONG InputDataCount,
    IN ULONG MaxOutputData,
    IN OUT PULONG OutputDataCount
    )

/*++

Routine Description:

    This function handles an OS/2 ioctl.  It convert the Ioctl SMB data
    into an NT ioctl call, makes the call, and format the returned data
    into Ioctl SMB return data.

Arguments:

    WorkContext
    Category
    Function
    Parameters
    InputParameterCount
    OutputParameterCount
    Data
    InputDataCount
    OutputDataCount

Return Value:

    NTSTATUS

--*/

{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    PCHAR buffer;
    PLFCB lfcb = WorkContext->Rfcb->Lfcb;
    HANDLE Handle = lfcb->FileHandle;

    union NT_PARAMTERS {
        SERIAL_BAUD_RATE BaudRate;
        SERIAL_LINE_CONTROL LineControl;
        SERIAL_TIMEOUTS Timeouts;
        SERIAL_QUEUE_SIZE QueueSize;
        ULONG WaitMask;
        ULONG PurgeMask;
        UCHAR ImmediateChar;
        UCHAR Reserved[3];
        SERIAL_CHARS Chars;
        SERIAL_HANDFLOW Handflow;
        SERIAL_STATUS SerialStatus;
    } ntBuffer;

    union SMB_PARAMETERS {
        PSMB_IOCTL_BAUD_RATE BaudRate;
        PSMB_IOCTL_LINE_CONTROL LineControl;
        PSMB_IOCTL_DEVICE_CONTROL DeviceControl;
        PSMB_IOCTL_COMM_ERROR CommError;
        PSMB_IOCTL_PRINTER_ID PrinterId;
    } smbParameters, smbData;

    PAGED_CODE( );

    InputParameterCount, InputDataCount;

    switch ( Category ) {

    case SERIAL_DEVICE:
        switch ( Function )  {

        case GET_BAUD_RATE:
            if( MaxOutputData < sizeof( SMB_IOCTL_BAUD_RATE ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_BAUD_RATE,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_BAUD_RATE )
                         );

           //
           // Convert the response to OS/2 format.
           //
           // !!! ULONG to USHORT conversion.
           //

           smbData.BaudRate = (PSMB_IOCTL_BAUD_RATE)Data;

           if ( NT_SUCCESS( status ) ) {
               smbData.BaudRate->BaudRate = (USHORT) ntBuffer.BaudRate.BaudRate;

               *OutputParameterCount = 0;
               *OutputDataCount = sizeof( SMB_IOCTL_BAUD_RATE );
           }

           break;

        case SET_BAUD_RATE:

           if( InputParameterCount < sizeof(SMB_IOCTL_BAUD_RATE) )
           {
               status = STATUS_INVALID_SMB;
               break;
           }

           //
           // Convert the request to NT format.
           //

           smbParameters.BaudRate =
               (PSMB_IOCTL_BAUD_RATE)Parameters;

           ntBuffer.BaudRate.BaudRate = smbParameters.BaudRate->BaudRate;

           status = NtDeviceIoControlFile(
                        Handle,
                        0,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        IOCTL_SERIAL_SET_BAUD_RATE,
                        &ntBuffer,
                        sizeof( SERIAL_BAUD_RATE ),
                        NULL,
                        0
                        );

            *OutputParameterCount = 0;
            *OutputDataCount = 0;

            break;

        case SET_LINE_CONTROL:

            if( InputParameterCount < sizeof(SMB_IOCTL_LINE_CONTROL) )
            {
                status = STATUS_INVALID_SMB;
                break;
            }

            //
            // Convert the request to NT format.
            //

            smbParameters.LineControl =
                (PSMB_IOCTL_LINE_CONTROL)Parameters;

            ntBuffer.LineControl.StopBits = smbParameters.LineControl->StopBits;
            ntBuffer.LineControl.Parity = smbParameters.LineControl->Parity;
            ntBuffer.LineControl.WordLength = smbParameters.LineControl->DataBits;

            // !!! What about TransmitBreak?

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_SET_LINE_CONTROL,
                         &ntBuffer,
                         sizeof( SERIAL_LINE_CONTROL ),
                         NULL,
                         0
                         );

             *OutputParameterCount = 0;
             *OutputDataCount = 0;

             break;

        case GET_LINE_CONTROL:

            if( MaxOutputData < sizeof( SMB_IOCTL_LINE_CONTROL ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

            smbData.LineControl = (PSMB_IOCTL_LINE_CONTROL)Data;

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_LINE_CONTROL,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_LINE_CONTROL )
                         );

            //
            // Convert the response to OS/2 format.
            //

            if ( NT_SUCCESS( status ) ) {
                smbData.LineControl->DataBits =  ntBuffer.LineControl.WordLength;
                smbData.LineControl->Parity =  ntBuffer.LineControl.Parity;
                smbData.LineControl->StopBits =  ntBuffer.LineControl.StopBits;
                smbData.LineControl->TransBreak = 0; // !!!

                *OutputParameterCount = 0;
                *OutputDataCount = sizeof( SMB_IOCTL_LINE_CONTROL );
            }

            break;

        case GET_DCB_INFORMATION:

            if( MaxOutputData < sizeof( SMB_IOCTL_DEVICE_CONTROL ) ) {
                status = STATUS_INVALID_SMB;
                break;
            }

           smbData.DeviceControl =
                (PSMB_IOCTL_DEVICE_CONTROL)Data;

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_TIMEOUTS,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_TIMEOUTS )
                         );

           //
           // Convert the response to OS/2 format.
           //

           // !!! Verify units are correct

           if ( NT_SUCCESS( status ) ) {
               smbData.DeviceControl->WriteTimeout = (USHORT)ntBuffer.Timeouts.ReadIntervalTimeout; // !!!
               smbData.DeviceControl->ReadTimeout = (USHORT)ntBuffer.Timeouts.ReadIntervalTimeout;
           } else {
               break;
           }

            status = NtDeviceIoControlFile(
                         Handle,
                         0,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IOCTL_SERIAL_GET_TIMEOUTS,
                         NULL,
                         0,
                         &ntBuffer,
                         sizeof( SERIAL_TIMEOUTS )
                         );

           //
           // Convert the response to OS/2 format.
           //

           if ( NT_SUCCESS( status ) ) {
               smbData.DeviceControl->XonChar = ntBuffer.Chars.XonChar;
               smbData.DeviceControl->XoffChar = ntBuffer.Chars.XoffChar;
               smbData.DeviceControl->ErrorReplacementChar = ntBuffer.Chars.ErrorChar;
               smbData.DeviceControl->BreakReplacementChar = ntBuffer.Chars.BreakChar;
           } else {
               break;
           }

           smbData.DeviceControl->ControlHandShake = 0; // !!!
           smbData.DeviceControl->FlowReplace = 0; // !!!
           smbData.DeviceControl->Timeout = 0; // !!!

           *OutputParameterCount = 0;
           *OutputDataCount = sizeof( SMB_IOCTL_DEVICE_CONTROL );

           break;

        case SET_DCB_INFORMATION:

            //
            // Lie.  Pretend this succeeded.
            //

            status = STATUS_SUCCESS;

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            break;

        case GET_COMM_ERROR:

            //
            // Pretend that there is no comm error.
            //
            if( MaxOutputData < sizeof(SMB_IOCTL_COMM_ERROR) )
            {
                status = STATUS_INVALID_SMB;
                break;
            }

            smbData.CommError = (PSMB_IOCTL_COMM_ERROR)Data;

            status = STATUS_SUCCESS;

            if ( NT_SUCCESS( status ) ) {
                smbData.CommError->Error = 0;

                *OutputParameterCount = 0;
                *OutputDataCount = sizeof( SMB_IOCTL_COMM_ERROR );
            }

            break;

        case SET_TRANSMIT_TIMEOUT:
        case SET_BREAK_OFF:
        case SET_MODEM_CONTROL:
        case SET_BREAK_ON:
        case STOP_TRANSMIT:
        case START_TRANSMIT:
        case GET_COMM_STATUS:
        case GET_LINE_STATUS:
        case GET_MODEM_OUTPUT:
        case GET_MODEM_INPUT:
        case GET_INQUEUE_COUNT:
        case GET_OUTQUEUE_COUNT:
        case GET_COMM_EVENT:
            status =  STATUS_NOT_IMPLEMENTED;
            break;

        default:
            status = STATUS_INVALID_PARAMETER;

        }

        break;


    case PRINTER_DEVICE:
        IF_SMB_DEBUG( TRANSACTION2 ) {
            KdPrint(( "ProcessOs2Ioctl: print IOCTL function %lx received.\n",
                       Function ));
        }

        switch ( Function )  {

        case GET_PRINTER_STATUS:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;

            if ( InputParameterCount < sizeof(CHAR) ||
                 *(PCHAR)Parameters != 0 ) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Always return STATUS_PRINTER_HAPPY
                //

                if( MaxOutputData < sizeof( CHAR ) ) {
                    status = STATUS_INVALID_SMB;
                } else {
                    *(PCHAR)Data = (CHAR)OS2_STATUS_PRINTER_HAPPY;

                    *OutputParameterCount = 0;
                    *OutputDataCount = sizeof( CHAR );
                    status = STATUS_SUCCESS;
                }
                break;
            }

        default:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            status = STATUS_NOT_SUPPORTED;
        }

        status = STATUS_SUCCESS;
        *OutputParameterCount = 0;
        *OutputDataCount = 0;
        break;


    case SPOOLER_DEVICE:
        IF_SMB_DEBUG( TRANSACTION2 ) {
            KdPrint(( "ProcessOs2Ioctl: spool IOCTL function %lx received.\n",
                       Function ));
        }

        switch ( Function )  {

        case GET_PRINTER_ID:

            {
                PUNICODE_STRING shareName = &WorkContext->TreeConnect->Share->ShareName;
                OEM_STRING ansiShare;

                if( MaxOutputData < 2 * (LM20_CNLEN + 1) ) {
                    status = STATUS_INVALID_SMB;
                    break;
                }

                smbData.PrinterId = (PSMB_IOCTL_PRINTER_ID) Data;
                smbData.PrinterId->JobId = (USHORT)lfcb->JobId;

                buffer = (PCHAR)smbData.PrinterId->Buffer;

                if ( WorkContext->Connection->Endpoint->TransportAddress.Buffer != NULL ) {
                    RtlCopyMemory(
                            buffer,
                            WorkContext->Connection->Endpoint->TransportAddress.Buffer,
                            MIN(WorkContext->Connection->Endpoint->TransportAddress.Length+1,LM20_CNLEN)
                            );
                } else {
                    *buffer = '\0';
                }

                buffer += LM20_CNLEN;
                *buffer++ = '\0';

                status = RtlUnicodeStringToOemString(
                                    &ansiShare,
                                    shareName,
                                    TRUE
                                    );

                if ( NT_SUCCESS(status) ) {

                    if ( ansiShare.Length >= LM20_NNLEN ) {
                        RtlCopyMemory(
                                buffer,
                                ansiShare.Buffer,
                                LM20_NNLEN
                                );
                    } else {
                        RtlCopyMemory(
                                buffer,
                                ansiShare.Buffer,
                                ansiShare.Length + 1
                                );

                    }

                    RtlFreeAnsiString(&ansiShare);

                } else {

                    *buffer = '\0';

                }

                status = STATUS_SUCCESS;

                buffer += LM20_NNLEN;
                *buffer++ = '\0';

                *OutputParameterCount = 0;

                //
                // data length is equal to the job id +
                // the computer name + the share name + 1
                // I don't know what the last + 1 is for but OS/2
                // sends it.
                //

                *OutputDataCount = sizeof(USHORT) + LM20_CNLEN + 1 +
                                    LM20_NNLEN + 2;


            }

            break;


        default:

            *OutputParameterCount = 0;
            *OutputDataCount = 0;
            status = STATUS_NOT_SUPPORTED;

        }

        break;


    case GENERAL_DEVICE:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    default:

        // for OS/2 1.x compatibility

        status = STATUS_SUCCESS;
        *OutputParameterCount = 0;
        *OutputDataCount = 0;
    }

    IF_SMB_DEBUG( TRANSACTION2 ) {

        KdPrint( (
            "Category %x, Function %x returns %lx\n",
            Category,
            Function,
            status
            ));
    }

    return status;

} // ProcessOs2Ioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbmisc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbmisc.c

Abstract:

    This module contains routines for processing MISC class SMBs:
        Echo
        Query FS Information
        Set FS Information
        Query Disk Information

Author:

    Chuck Lenzmeier (chuckl) 9-Nov-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbmisc.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBMISC
#define MAX_SMB_ECHO_COUNT 8

STATIC
ULONG QueryVolumeInformation[] = {
         SMB_QUERY_FS_LABEL_INFO,  // Base level
         FileFsLabelInformation,   // Mapping for base level
         FileFsVolumeInformation,
         FileFsSizeInformation,
         FileFsDeviceInformation,
         FileFsAttributeInformation
};

STATIC
VOID SRVFASTCALL
RestartEcho (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbEcho )
#pragma alloc_text( PAGE, RestartEcho )
#pragma alloc_text( PAGE, SrvSmbQueryFsInformation )
#pragma alloc_text( PAGE, SrvSmbSetFsInformation )
#pragma alloc_text( PAGE, SrvSmbQueryInformationDisk )
#pragma alloc_text( PAGE, SrvSmbSetSecurityDescriptor )
#pragma alloc_text( PAGE, SrvSmbQuerySecurityDescriptor )
#pragma alloc_text( PAGE, SrvSmbQueryQuota )
#pragma alloc_text( PAGE, SrvSmbSetQuota )
#endif
#if 0
NOT PAGEABLE -- SrvSmbNtCancel
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbEcho (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Echo SMB.  It sends the first echo, if any, specifying
    RestartEcho as the restart routine.  That routine sends the
    remaining echoes.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_ECHO request;
    PRESP_ECHO response;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_ECHO;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_ECHO)WorkContext->RequestParameters;
    response = (PRESP_ECHO)WorkContext->ResponseParameters;

    //
    // If the echo count is 0, there are no echoes to send.
    //

    if ( SmbGetUshort( &request->EchoCount ) == 0 ) {
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    //
    // The echo count is not zero.  Save it in the work context, then
    // send the first echo.
    //
    // *** This code depends on the response buffer being the same as
    //     the request buffer.  It does not copy the echo data from the
    //     request to the response.  It does not update the DataLength
    //     of the response buffer.
    //
    // !!! Need to put in code to verify the requested TID, if any.
    //

    SrvReleaseContext( WorkContext );

    WorkContext->Parameters.RemainingEchoCount =
        MIN( (USHORT)(SmbGetUshort( &request->EchoCount ) - 1), MAX_SMB_ECHO_COUNT );

    ASSERT( WorkContext->ResponseHeader == WorkContext->RequestHeader );

    SmbPutUshort( &response->SequenceNumber, 1 );

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the echo.  Notice that the smb statistics will be updated
    // here.  Instead of measuring the time to finish all the echos,
    // we just measure the time to respond to the first.  This will
    // save us the trouble of storing the timestamp somewhere.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvQueueWorkToFspAtSendCompletion,
        NULL,
        RestartEcho
        );

    //
    // The echo has been started.  Tell the main SMB processor not to
    // do anything more with the current SMB.
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbEcho


VOID SRVFASTCALL
RestartEcho (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for an Echo.  If more echoes are required,
    it sends the next one.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_ECHO;
    SrvWmiStartContext(WorkContext);

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartEcho\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.  (The endpoint is valid because the
    // connection references the endpoint.)
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) SrvPrint2( "  connection %p, endpoint %p\n",
                                        connection, WorkContext->Endpoint );

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
         !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Indicate that SMB processing is complete.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );
        goto Cleanup;

    }

    //
    // The request was successful, and the connection is still active.
    // If there are no more echoes to be sent, indicate that SMB
    // processing is complete.
    //

    if ( WorkContext->Parameters.RemainingEchoCount == 0 ) {

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );
        goto Cleanup;

    }

    --WorkContext->Parameters.RemainingEchoCount;

    //
    // There are more echoes to be sent.  Increment the sequence number
    // in the response SMB, and send another echo.
    //

    SmbPutUshort(
        &((PRESP_ECHO)WorkContext->ResponseParameters)->SequenceNumber,
        (USHORT)(SmbGetUshort(
            &((PRESP_ECHO)WorkContext->ResponseParameters)->SequenceNumber
            ) + 1)
        );

    //
    // Don't do smb statistics a second time.
    //

    WorkContext->StartTime = 0;

    //
    // Send the echo.  (Note that the response bit has already been
    // set.)
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvQueueWorkToFspAtSendCompletion,
        NULL,
        RestartEcho
        );
    IF_DEBUG(TRACE2) SrvPrint0( "RestartEcho complete\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // RestartEcho


SMB_TRANS_STATUS
SrvSmbQueryFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query FS Information request.  This request arrives
    in a Transaction2 SMB.  Query FS Information corresponds to the
    OS/2 DosQFSInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    USHORT informationLevel;

    USHORT trans2code;
    HANDLE fileHandle;

    FILE_FS_SIZE_INFORMATION fsSizeInfo;
    PFSALLOCATE fsAllocate;

    PFILE_FS_VOLUME_INFORMATION fsVolumeInfo;
    ULONG fsVolumeInfoLength;
    PFSINFO fsInfo;
    ULONG lengthVolumeLabel;
    BOOLEAN isUnicode;
    PREQ_QUERY_FS_INFORMATION request;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_FS_INFORMATION;
    SrvWmiStartContext(WorkContext);

    isUnicode = SMB_IS_UNICODE( WorkContext );
    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1( "Query FS Information entered; transaction 0x%p\n",
                    transaction );
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.  Query FS information has no
    // response parameters.
    //


    if ( (transaction->ParameterCount < sizeof(REQ_QUERY_FS_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbQueryFSInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // See if a non-admin user is trying to access information on an Administrative share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    trans2code = SmbGetAlignedUshort(transaction->InSetup);
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1("SrvSmbQueryFSInformation: Trans2 function = %x\n", trans2code);
    }

    request = (PREQ_QUERY_FS_INFORMATION) transaction->InParameters;

    ASSERT( trans2code == TRANS2_QUERY_FS_INFORMATION );

    informationLevel = SmbGetUshort( &request->InformationLevel );

    //
    // *** The share handle is used to get the allocation
    //     information.  This is a "storage channel," and as a
    //     result could allow people to get information to which
    //     they are not entitled.  For a B2 security rating this may
    //     need to be changed.
    //

    status = SrvGetShareRootHandle( WorkContext->TreeConnect->Share );

    if (!NT_SUCCESS(status)) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSmbQueryFsInformation: SrvGetShareRootHandle failed %x.\n",
                        status );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );
    if( !NT_SUCCESS(status)) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(MISC1) {
        SrvPrint0("SrvSmbQueryFSInformation: Using share root handle\n");
    }

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( informationLevel ) {

        case SMB_INFO_ALLOCATION:

            //
            // Return information about the disk.
            //

            fsAllocate = (PFSALLOCATE)transaction->OutData;

            if ( transaction->MaxDataCount < sizeof(FSALLOCATE) ) {
                SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }


            //
            // *** The share handle is used to get the allocation
            //     information.  This is a "storage channel," and as a
            //     result could allow people to get information to which
            //     they are not entitled.  For a B2 security rating this may
            //     need to be changed.
            //

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {
                status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             &fsSizeInfo,
                             sizeof(FILE_FS_SIZE_INFORMATION),
                             FileFsSizeInformation
                             );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                 fileHandle,
                                 &ioStatusBlock,
                                 &fsSizeInfo,
                                 sizeof(FILE_FS_SIZE_INFORMATION),
                                 FileFsSizeInformation
                                 );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //

            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbQueryFsInformation: NtQueryVolumeInformationFile "
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            SmbPutAlignedUlong( &fsAllocate->idFileSystem, 0 );
            SmbPutAlignedUlong(
                &fsAllocate->cSectorUnit,
                fsSizeInfo.SectorsPerAllocationUnit
                );

            //
            // *** If .HighPart is non-zero, there is a problem, as we can
            //     only return 32 bits for the volume size.  In this case,
            //     we return the largest value that will fit.
            //

            SmbPutAlignedUlong(
                &fsAllocate->cUnit,
                fsSizeInfo.TotalAllocationUnits.HighPart == 0 ?
                    fsSizeInfo.TotalAllocationUnits.LowPart :
                    0xffffffff
                );
            SmbPutAlignedUlong(
                &fsAllocate->cUnitAvail,
                fsSizeInfo.AvailableAllocationUnits.HighPart == 0 ?
                    fsSizeInfo.AvailableAllocationUnits.LowPart :
                    0xffffffff
                );

            SmbPutAlignedUshort(
                &fsAllocate->cbSector,
                (USHORT)fsSizeInfo.BytesPerSector );

            transaction->DataCount = sizeof(FSALLOCATE);

            break;

        case SMB_INFO_VOLUME:

            //
            // Query the volume label.
            //

            fsInfo = (PFSINFO)transaction->OutData;

            //
            // The maximum volume label length we are able to return, given
            // the VOLUMELABEL structure (1 byte describes length of label),
            // is 255 characters.  Therefore, allocate a buffer large enough
            // to hold a label that size, and if the label is longer then we
            // will get STATUS_BUFFER_OVERFLOW from NtQueryVolumeInformationFile.
            //

            fsVolumeInfoLength = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel ) +
                                 255 * sizeof(WCHAR);
            fsVolumeInfo = ALLOCATE_HEAP_COLD( fsVolumeInfoLength, BlockTypeDataBuffer );

            if ( fsVolumeInfo == NULL ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }


            //
            // Get the label information.
            //

            status = NtQueryVolumeInformationFile(
                         fileHandle,
                         &ioStatusBlock,
                         fsVolumeInfo,
                         fsVolumeInfoLength,
                         FileFsVolumeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                if( NT_SUCCESS(status) )
                {
                    status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             fsVolumeInfo,
                             fsVolumeInfoLength,
                             FileFsVolumeInformation
                             );
                }
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbQueryFSInformation: NtQueryVolumeInformationFile "
                        "returned %X",
                    status,
                    NULL
                    );

                FREE_HEAP( fsVolumeInfo );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            lengthVolumeLabel = fsVolumeInfo->VolumeLabelLength;

            //
            // Make sure that the client can accept enough data.  The volume
            // label length is limited to 13 characters (8 + '.' + 3 + zero
            // terminator) in OS/2, so return STATUS_BUFFER_OVERFLOW if the
            // label is too long.
            //

            if ( !isUnicode &&
                    !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

                //
                // For a non-NT client, we truncate the volume label in case
                // it is longer than 11+1 characters.
                //

                if ( lengthVolumeLabel > 11 * sizeof(WCHAR) ) {
                    lengthVolumeLabel = 11 * sizeof(WCHAR);
                }

                //
                // Wedge a '.' into the name if it's longer than 8 characters long
                //
                if( lengthVolumeLabel > 8 * sizeof( WCHAR ) ) {

                    LPWSTR p = &fsVolumeInfo->VolumeLabel[11];

                    *p = *(p-1);        // VolumeLabel[11] = VolumeLabel[10]
                    --p;
                    *p = *(p-1);        // VolumeLabel[10] = VolumeLabel[9]
                    --p;
                    *p = *(p-1);        // VolumeLabel[9] = VolumeLabel[8]
                    --p;
                    *p = L'.';          // VolumeLabel[8] = '.'

                }

            }

            if ( (ULONG)transaction->MaxDataCount <
                     ( sizeof(FSINFO) - sizeof(VOLUMELABEL) + sizeof( UCHAR ) +
                       lengthVolumeLabel / (isUnicode ? 1 : sizeof(WCHAR)) ) ) {

                FREE_HEAP( fsVolumeInfo );
                SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                status    = STATUS_BUFFER_OVERFLOW;
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            SmbPutUlong( &fsInfo->ulVsn, fsVolumeInfo->VolumeSerialNumber );

            //
            // Put the label in the SMB in Unicode or OEM, depending on what
            // was negotiated.
            //

            if ( isUnicode ) {

                RtlCopyMemory(
                    fsInfo->vol.szVolLabel,
                    fsVolumeInfo->VolumeLabel,
                    lengthVolumeLabel
                    );

                transaction->DataCount = sizeof(FSINFO) -
                                    sizeof(VOLUMELABEL) + lengthVolumeLabel;

                fsInfo->vol.cch = (UCHAR)lengthVolumeLabel;

            } else {

                ULONG i;
                OEM_STRING oemString;
                UNICODE_STRING unicodeString;

                if ( lengthVolumeLabel != 0 ) {

                    oemString.Buffer = fsInfo->vol.szVolLabel;
                    oemString.MaximumLength = 12;

                    unicodeString.Buffer = (PWCH)fsVolumeInfo->VolumeLabel;
                    unicodeString.Length = (USHORT) lengthVolumeLabel;
                    unicodeString.MaximumLength = (USHORT) lengthVolumeLabel;

                    status = RtlUnicodeStringToOemString(
                                 &oemString,
                                 &unicodeString,
                                 FALSE
                                 );
                    ASSERT( NT_SUCCESS(status) );
                }

                fsInfo->vol.cch = (UCHAR) (lengthVolumeLabel / sizeof(WCHAR));

                //
                // Pad the end of the volume name with zeros to fill 12
                // characters.
                //

                for ( i = fsInfo->vol.cch + 1 ; i < 12; i++ ) {
                    fsInfo->vol.szVolLabel[i] = '\0';
                }

                transaction->DataCount = sizeof(FSINFO);
            }

            IF_SMB_DEBUG(MISC1) {
                SrvPrint2( "volume label length is %d and label is %s\n",
                              fsInfo->vol.cch, fsInfo->vol.szVolLabel );
            }

            FREE_HEAP( fsVolumeInfo );

            break;

        case SMB_QUERY_FS_VOLUME_INFO:
        case SMB_QUERY_FS_DEVICE_INFO:
        case SMB_QUERY_FS_ATTRIBUTE_INFO:

            //
            // These are NT infolevels.  We always return unicode.
            //  Except for the fact that NEXUS on WFW calls through here and is
            //  not unicode (isaache)
            //
            // ASSERT( isUnicode );

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {
                status = NtQueryVolumeInformationFile(
                             fileHandle,
                             &ioStatusBlock,
                             transaction->OutData,
                             transaction->MaxDataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 QueryVolumeInformation,
                                 informationLevel
                                 )
                             );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                     fileHandle,
                                     &ioStatusBlock,
                                     transaction->OutData,
                                     transaction->MaxDataCount,
                                     MAP_SMB_INFO_TYPE_TO_NT(
                                         QueryVolumeInformation,
                                         informationLevel
                                         )
                                 );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( NT_SUCCESS( status ) ) {
                //
                // We need to return FAT to the client if the host volume is really
                // FAT32
                //
                if( informationLevel == SMB_QUERY_FS_ATTRIBUTE_INFO &&
                    ioStatusBlock.Information > sizeof( FILE_FS_ATTRIBUTE_INFORMATION ) ) {

                    PFILE_FS_ATTRIBUTE_INFORMATION attrInfo =
                        (PFILE_FS_ATTRIBUTE_INFORMATION)(transaction->OutData);

                    if( attrInfo->FileSystemNameLength > 3*sizeof(WCHAR) &&
                        attrInfo->FileSystemName[0] == L'F' &&
                        attrInfo->FileSystemName[1] == L'A' &&
                        attrInfo->FileSystemName[2] == L'T' ) {

                        ioStatusBlock.Information =
                            ioStatusBlock.Information -
                            (attrInfo->FileSystemNameLength - 3*sizeof(WCHAR) );

                        attrInfo->FileSystemNameLength = 3 * sizeof(WCHAR);
                        attrInfo->FileSystemName[3] = UNICODE_NULL;
                    }
                }

                transaction->DataCount = (ULONG)ioStatusBlock.Information;

            } else {
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            break;

        case SMB_QUERY_FS_SIZE_INFO:

            //
            // These are NT infolevels.  We always return unicode.
            //  Except for the fact that NEXUS on WFW calls through here and is
            //  not unicode (isaache)
            //
            // ASSERT( isUnicode );


            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryVolumeInformationFile(
                                 fileHandle,
                                 &ioStatusBlock,
                                 transaction->OutData,
                                 transaction->MaxDataCount,
                                 MAP_SMB_INFO_TYPE_TO_NT(
                                     QueryVolumeInformation,
                                     informationLevel
                                     )
                                 );
                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                         fileHandle,
                                         &ioStatusBlock,
                                         transaction->OutData,
                                         transaction->MaxDataCount,
                                         MAP_SMB_INFO_TYPE_TO_NT(
                                             QueryVolumeInformation,
                                             informationLevel
                                             )
                                         );
                    }
                }

                REVERT();
            }

            //
            // Release the share root handle
            //
            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( NT_SUCCESS( status ) ) {
                transaction->DataCount = (ULONG)ioStatusBlock.Information;
            } else {
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbTransStatusErrorWithoutData;
                goto Cleanup;
            }

            break;

        default:

            //
            // An invalid information level was passed.
            //

            SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
            status    = STATUS_OS2_INVALID_LEVEL;
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

    } else {

        informationLevel -= SMB_INFO_PASSTHROUGH;

        status = IoCheckQuerySetVolumeInformation(  informationLevel,
                                                    transaction->MaxDataCount,
                                                    FALSE
                                                 );

        if( NT_SUCCESS( status ) ) {

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryVolumeInformationFile(
                                fileHandle,
                                &ioStatusBlock,
                                transaction->OutData,
                                transaction->MaxDataCount,
                                informationLevel
                                );

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &fileHandle );

                    if( NT_SUCCESS(status) )
                    {
                        status = NtQueryVolumeInformationFile(
                                        fileHandle,
                                        &ioStatusBlock,
                                        transaction->OutData,
                                        transaction->MaxDataCount,
                                        informationLevel
                                        );
                    }
                }

                REVERT();
            }
        }

        SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

        if ( NT_SUCCESS( status ) ) {
            transaction->DataCount = (ULONG)ioStatusBlock.Information;
        } else {
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryFsInformation


SMB_TRANS_STATUS
SrvSmbSetFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set FS Information request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    SMB_TRANS_STATUS transactionStatus = SmbTransStatusInProgress;
    PREQ_SET_FS_INFORMATION request;
    NTSTATUS         status    = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    PTRANSACTION transaction;
    USHORT informationLevel;
    PSESSION      session;
    PTREE_CONNECT treeConnect;
    PRFCB rfcb;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_FS_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(MISC1) {
        SrvPrint1( "Set FS Information entered; transaction 0x%p\n",
                    transaction );
    }

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if( !NT_SUCCESS( status ) ) {
        goto out;
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.  Set FS information has no
    // response parameters.
    //

    request = (PREQ_SET_FS_INFORMATION)transaction->InParameters;

    if ( (transaction->ParameterCount < sizeof(REQ_SET_FS_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(ERRORS) {
            SrvPrint2( "SrvSmbSetFSInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        status = STATUS_INVALID_SMB;
        SrvLogInvalidSmb( WorkContext );
        goto out;
    }

    //
    // Confirm that the information level is legitimate.
    //
    informationLevel = SmbGetUshort( &request->InformationLevel );

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        status = STATUS_NOT_SUPPORTED;
        goto out;
    }

    informationLevel -= SMB_INFO_PASSTHROUGH;

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );

    if( !NT_SUCCESS( status ) ) {
        goto out;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //
    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {
        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFsInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        goto out;
    }

    status = IoCheckQuerySetVolumeInformation(
                 informationLevel,
                 transaction->DataCount,
                 TRUE
                 );

    if( NT_SUCCESS( status ) ) {

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = NtSetVolumeInformationFile(
                         rfcb->Lfcb->FileHandle,
                         &ioStatusBlock,
                         transaction->InData,
                         transaction->DataCount,
                         informationLevel
                         );

            REVERT();
        }
    }

out:
    if ( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        transactionStatus = SmbTransStatusErrorWithoutData;
    } else {
        transactionStatus =  SmbTransStatusSuccess;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    SrvWmiEndContext(WorkContext);
    return transactionStatus;

} // SrvSmbSetFsInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformationDisk (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Query Information Disk SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION_DISK request;
    PRESP_QUERY_INFORMATION_DISK response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_FS_SIZE_INFORMATION fsSizeInfo;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    USHORT totalUnits, freeUnits;
    ULONG sectorsPerUnit, bytesPerSector;
    LARGE_INTEGER result;
    BOOLEAN highpart;
    ULONG searchword;
    CCHAR highbit, extrabits;

    BOOLEAN isDos;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION_DISK;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(MISC1) {
        SrvPrint2( "Query Information Disk request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Query Information Disk request params at 0x%p, response params%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    request = (PREQ_QUERY_INFORMATION_DISK)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION_DISK)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbQueryInformationDisk: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, treeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    //
    // Get the Share root handle.
    //

    status = SrvGetShareRootHandle( treeConnect->Share );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSmbQueryInformationDisk: SrvGetShareRootHandle failed %x.\n",
                        status );
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // *** The share handle is used to get the allocation information.
    //     This is a "storage channel," and as a result could allow
    //     people to get information to which they are not entitled.
    //     For a B2 security rating this may need to be changed.
    //

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        HANDLE RootHandle;

        status = SrvSnapGetRootHandle( WorkContext, &RootHandle );
        if( NT_SUCCESS(status) )
        {
            status = NtQueryVolumeInformationFile(
                         RootHandle,
                         &ioStatusBlock,
                         &fsSizeInfo,
                         sizeof(FILE_FS_SIZE_INFORMATION),
                         FileFsSizeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( WorkContext->TreeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &RootHandle );
                if( NT_SUCCESS(status) )
                {
                    status = NtQueryVolumeInformationFile(
                                 RootHandle,
                                 &ioStatusBlock,
                                 &fsSizeInfo,
                                 sizeof(FILE_FS_SIZE_INFORMATION),
                                 FileFsSizeInformation
                                 );
                }
            }
        }

        REVERT();
    }

    //
    // Release the share root handle
    //

    SrvReleaseShareRootHandle( treeConnect->Share );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbQueryInformationDisk: NtQueryVolumeInformationFile"
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_VOL_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // *** Problem.
    //
    // This SMB only return 16 bits of information for each field, but we
    // may need to return large numbers.  In particular TotalAllocationUnits
    // is commonly > 64K.
    //
    // Fortunately, it turns out the all the client cares about is the total
    // disk size, in bytes, and the free space, in bytes.  So - if one number
    // is too big adjust it and adjust the other numbers so that the totals
    // come out the same.
    //
    // If after all adjustment, the number are still too high, return the
    // largest possible value for TotalUnit or FreeUnits (i.e. 0xFFFF).
    //
    // A caveat here is that some DOS apps (like the command interpreter!)
    // assume that the cluster size (bytes per sector times sectors per
    // cluster) will fit in 16 bits, and will calculate bogus geometry if
    // it doesn't.  So the first thing we do is ensure that the real
    // cluster size is less than 0x10000, if the client is a DOS client.
    // This may make the TotalUnits or FreeUnits counts too big, so we'll
    // have to round them down, but that's life.
    //
    // Since we use shifts to adjust the numbers it is possible to lose
    // 1 bits when we shift a number to the right.  We don't care, we're
    // doing our best to fix a broken protocol.  NT clients will use
    // QueryFSAttribute and will get the correct answer.
    //

    //
    // If this is a DOS client, make the cluster size < 0x10000.
    //

    isDos = IS_DOS_DIALECT( WorkContext->Connection->SmbDialect );

    sectorsPerUnit = fsSizeInfo.SectorsPerAllocationUnit;
    bytesPerSector = fsSizeInfo.BytesPerSector;

    if ( isDos ) {
        while ( (sectorsPerUnit * bytesPerSector) > 0xFFFF ) {
            if ( sectorsPerUnit >= 2 ) {
                sectorsPerUnit /= 2;
            } else {
                bytesPerSector /= 2;
            }
            fsSizeInfo.TotalAllocationUnits.QuadPart *= 2;
            fsSizeInfo.AvailableAllocationUnits.QuadPart *= 2;
        }
    }

    //
    // Calculate how much the total cluster count needs to be shifted in
    // order to fit in a word.
    //

    if ( fsSizeInfo.TotalAllocationUnits.HighPart != 0 ) {
        highpart = TRUE;
        searchword = fsSizeInfo.TotalAllocationUnits.HighPart;
    } else {
        highpart = FALSE;
        searchword = fsSizeInfo.TotalAllocationUnits.LowPart;
    }

    highbit = 0;
    while ( searchword != 0 ) {
        highbit++;
        searchword /= 2;
    }

    if ( highpart ) {
        highbit += 32;
    } else {
        if ( highbit < 16) {
            highbit = 0;
        } else {
            highbit -= 16;
        }
    }

    if ( highbit > 0 ) {

        //
        // Attempt to adjust the other values to absorb the excess bits.
        // If this is a DOS client, don't let the cluster size get
        // bigger than 0xFFFF.
        //

        extrabits = highbit;

        if ( isDos ) {

            while ( (highbit > 0) &&
                    ((sectorsPerUnit*bytesPerSector) < 0x8000) ) {
                sectorsPerUnit *= 2;
                highbit--;
            }

        } else {

            while ( (highbit > 0) && (sectorsPerUnit < 0x8000) ) {
                sectorsPerUnit *= 2;
                highbit--;
            }

            while ( (highbit > 0) && (bytesPerSector < 0x8000) ) {
                bytesPerSector *= 2;
                highbit--;
            }

        }

        //
        // Adjust the total and free unit counts.
        //

        if ( highbit > 0 ) {

            //
            // There is no way to get the information to fit.  Use the
            // maximum possible value.
            //


            totalUnits = 0xFFFF;

        } else {

            result.QuadPart = fsSizeInfo.TotalAllocationUnits.QuadPart >> extrabits;

            ASSERT( result.HighPart == 0 );
            ASSERT( result.LowPart < 0x10000 );

            totalUnits = (USHORT)result.LowPart;

        }

        result.QuadPart =  fsSizeInfo.AvailableAllocationUnits.QuadPart >>
                                            (CCHAR)(extrabits - highbit);

        if ( result.HighPart != 0 || result.LowPart > 0xFFFF ) {
            freeUnits = 0xFFFF;
        } else {
            freeUnits = (USHORT)result.LowPart;
        }

    } else {

        totalUnits = (USHORT)fsSizeInfo.TotalAllocationUnits.LowPart;
        freeUnits = (USHORT)fsSizeInfo.AvailableAllocationUnits.LowPart;

    }

    //
    // Build the response SMB.
    //

    response->WordCount = 5;

    SmbPutUshort( &response->TotalUnits, totalUnits );
    SmbPutUshort( &response->BlocksPerUnit, (USHORT)sectorsPerUnit );
    SmbPutUshort( &response->BlockSize, (USHORT)bytesPerSector );
    SmbPutUshort( &response->FreeUnits, freeUnits );

    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_QUERY_INFORMATION_DISK,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbQueryInformationDisk complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformationDisk


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCancel (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Nt Cancel SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PCONNECTION connection;
    USHORT targetUid, targetPid, targetTid, targetMid;
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PSMB_HEADER header;
    BOOLEAN match;
    KIRQL oldIrql;

    PREQ_NT_CANCEL request;
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CANCEL;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_NT_CANCEL)WorkContext->RequestParameters;

    //
    // The word count has already been checked.  Now make sure that
    // the byte count is zero.
    //

    if ( SmbGetUshort( &request->ByteCount) != 0 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNtCancel: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Check the work in-progress list to see if this work item is
    // cancellable.
    //

    targetUid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid );
    targetPid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    targetTid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid );
    targetMid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Mid );

    match = FALSE;

    connection = WorkContext->Connection;

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    listHead = &connection->InProgressWorkItemList;
    listEntry = listHead;
    while ( listEntry->Flink != listHead ) {

        listEntry = listEntry->Flink;

        workContext = CONTAINING_RECORD(
                                     listEntry,
                                     WORK_CONTEXT,
                                     InProgressListEntry
                                     );

        header = workContext->RequestHeader;

        //
        // Some workitems in the inprogressworkitemlist are added
        // during a receive indication and the requestheader field
        // has not been set yet.  We can probably set it at that time
        // but this seems to be the safest fix.
        //
        // We have to check whether the workitem ref count is zero or
        // not since we dereference it before removing it from the
        // InProgressWorkItemList queue.  This prevents the workitem
        // from being cleaned up twice.
        //
        // We also need to check the processing count of the workitem.
        // Work items being used for actual smb requests will have
        // a processing count of at least 1.  This will prevent us
        // from touching oplock breaks and pending tdi receives.
        //

        ACQUIRE_DPC_SPIN_LOCK( &workContext->SpinLock );
        if ( (workContext->BlockHeader.ReferenceCount != 0) &&
             (workContext->ProcessingCount != 0) &&
             header != NULL &&
             header->Command != SMB_COM_NT_CANCEL &&
             SmbGetAlignedUshort( &header->Mid ) == targetMid &&
             SmbGetAlignedUshort( &header->Pid ) == targetPid &&
             SmbGetAlignedUshort( &header->Tid ) == targetTid &&
             SmbGetAlignedUshort( &header->Uid ) == targetUid ) {

            match = TRUE;
            break;
        }
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );

    }

    if ( match ) {

        //
        // Reference the work item, so that it cannot get used to process
        // a new SMB while we are trying to cancel the old one.
        //

        SrvReferenceWorkItem( workContext );
        RELEASE_DPC_SPIN_LOCK( &workContext->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        (VOID)IoCancelIrp( workContext->Irp );
        SrvDereferenceWorkItem( workContext );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    }

    //
    // Done.  Do not send a response
    //
    SmbStatus = SmbStatusNoResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNtCancel


SMB_TRANS_STATUS
SrvSmbSetSecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set Security Descriptor request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_SET_SECURITY_DESCRIPTOR request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    SECURITY_INFORMATION securityInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        SrvPrint1( "Set Security Descriptor entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_SET_SECURITY_DESCRIPTOR)transaction->InParameters;

    //
    // Verify that enough setup bytes were sent.
    //

    if ( transaction->ParameterCount < sizeof(REQ_SET_SECURITY_DESCRIPTOR ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbSetSecurityInformation: bad setup byte count: "
                        "%ld\n",
                        transaction->ParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    //  First we'll validate that the security descriptor isn't bogus.
    //  This needs to be done here because NtSetSecurityObject has no
    //  idea what the buffer size is.
    //
    if( !RtlValidRelativeSecurityDescriptor( transaction->InData,
                                             transaction->DataCount,
                                             0 )) {
        //
        //  We were passed a bogus security descriptor to set.  Bounce the
        //  request as an invalid SMB.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SECURITY_DESCR );
        return SmbTransStatusErrorWithoutData;
    }

    securityInformation = SmbGetUlong( &request->SecurityInformation );

    //
    // Make sure the caller is allowed to set security information on this object
    //
    status = IoCheckFunctionAccess( rfcb->GrantedAccess,
                                    IRP_MJ_SET_SECURITY,
                                    0,
                                    0,
                                    &securityInformation,
                                    NULL
                                   );

    if( NT_SUCCESS( status ) ) {
        //
        //  Attempt to set the security descriptor.  We need to be in the
        //  the user context to do this, in case the security information
        //  specifies change ownership.
        //

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            status = NtSetSecurityObject(
                     rfcb->Lfcb->FileHandle,
                     securityInformation,
                     transaction->InData
                     );

            REVERT();
        }
    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // We probably shouldn't cache this file descriptor on close, since
    //  the security setting changed.
    //
    rfcb->IsCacheable = FALSE;

    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    return SmbTransStatusSuccess;

} // SrvSmbSetSecurityDescriptor


SMB_TRANS_STATUS
SrvSmbQuerySecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query Security Descriptor request.  This request arrives
    in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_QUERY_SECURITY_DESCRIPTOR request;
    PRESP_QUERY_SECURITY_DESCRIPTOR response;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    ULONG lengthNeeded;
    SECURITY_INFORMATION securityInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        SrvPrint1( "Query Security Descriptor entered; transaction 0x%p\n",
                    transaction );
    }

    request = (PREQ_QUERY_SECURITY_DESCRIPTOR)transaction->InParameters;
    response = (PRESP_QUERY_SECURITY_DESCRIPTOR)transaction->OutParameters;

    //
    // Verify that enough setup bytes were sent.
    //

    if ( transaction->ParameterCount < sizeof(REQ_QUERY_SECURITY_DESCRIPTOR ) ||
         transaction->MaxParameterCount <
             sizeof( RESP_QUERY_SECURITY_DESCRIPTOR ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint2( "SrvSmbQuerySecurityInformation: bad parameter byte or "
                        "return parameter count: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint2(
                "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                status,
                SmbGetUshort( &request->Fid )
                );
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    securityInformation = SmbGetUlong( &request->SecurityInformation ),

    //
    // Make sure the caller is allowed to query security information on this object
    //
    status = IoCheckFunctionAccess( rfcb->GrantedAccess,
                                    IRP_MJ_QUERY_SECURITY,
                                    0,
                                    0,
                                    &securityInformation,
                                    NULL
                                   );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    //  Attempt to query the security descriptor
    //
    status = NtQuerySecurityObject(
                 rfcb->Lfcb->FileHandle,
                 securityInformation,
                 transaction->OutData,
                 transaction->MaxDataCount,
                 &lengthNeeded
                 );

    SmbPutUlong( &response->LengthNeeded, lengthNeeded );
    transaction->ParameterCount = sizeof( RESP_QUERY_SECURITY_DESCRIPTOR );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        transaction->DataCount = 0;
        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    } else {
        transaction->DataCount =
                RtlLengthSecurityDescriptor( transaction->OutData );
    }

    return SmbTransStatusSuccess;

} // SrvSmbQuerySecurityDescriptor

SMB_TRANS_STATUS
SrvSmbQueryQuota (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NtQueryQuotaInformationFile request.  This request arrives in an
    Nt Transaction SMB.

--*/
{
    PREQ_NT_QUERY_FS_QUOTA_INFO  request;
    PRESP_NT_QUERY_FS_QUOTA_INFO response;

    NTSTATUS status;
    PTRANSACTION transaction;

    PRFCB  rfcb;
    PVOID  sidList;
    ULONG  sidListLength,startSidLength,startSidOffset;
    PVOID  sidListBuffer = NULL;
    PULONG startSid = NULL;
    ULONG  errorOffset;

    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_NT_QUERY_FS_QUOTA_INFO)transaction->InParameters;
    response = (PRESP_NT_QUERY_FS_QUOTA_INFO)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( transaction->ParameterCount < sizeof( *request ) ||
         transaction->MaxParameterCount < sizeof( *response ) ) {

        //
        // Not enough parameter bytes were sent.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    sidListLength  = SmbGetUlong( &request->SidListLength );
    startSidLength = SmbGetUlong( &request->StartSidLength );
    startSidOffset = SmbGetUlong( &request->StartSidOffset );

    //
    // If a Sid List is supplied, make sure it is OK
    //

    if( sidListLength != 0 ) {
        //
        // Length OK?
        //
        if( sidListLength > transaction->DataCount ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SID );
            return SmbTransStatusErrorWithoutData;
        }

        sidListBuffer = transaction->InData;

        //
        // Alignment OK?
        //
        if( (ULONG_PTR)sidListBuffer & (sizeof(ULONG)-1) ) {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SID );
            return SmbTransStatusErrorWithoutData;
        }
        //
        // Content OK?
        //
#if XXX
        status = IopCheckGetQuotaBufferValidity( sidListBuffer, sidListLength, errorOffset );
        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
            return SmbTransStatusErrorWithoutData;
        }
#endif
    }

    // The way the transaction buffers are setup the same buffer pointer is used
    // for the incoming data and the outgoing data. This will not work for
    // NtQueryQuotaInformationFile since the underlying driver zeroes the
    // output buffer before processing the input buffer. This presents us with
    // two options ... (1) we can adjust the copying to be staggerred assuming
    // that we can contain both the buffers into the transaction buffer or (2)
    // allocate anew buffer before calling the QueryQuotaInformationFile.
    // The second approach has been implemented since it is well contained.
    // If this turns out to be a performance problem we will revert back to the
    // first option.

    if (sidListLength + startSidLength > 0 &&
        startSidOffset <= transaction->DataCount &&
        startSidLength <= transaction->DataCount &&
        startSidOffset >= sidListLength &&
        startSidOffset + startSidLength <= transaction->DataCount ) {

        sidListBuffer = ALLOCATE_HEAP( MAX(startSidOffset + startSidLength, sidListLength), BlockTypeMisc );

        if (sidListBuffer != NULL) {

            RtlCopyMemory(
                sidListBuffer,
                transaction->InData,
                sidListLength);

            if (startSidLength != 0) {
                startSid = (PULONG)((PBYTE)sidListBuffer + startSidOffset);

                RtlCopyMemory(
                    startSid,
                    ((PBYTE)transaction->InData + startSidOffset),
                    startSidLength);

            }
        }
    } else {
        sidListBuffer = NULL;
    }


    iosb.Information = 0;

    //
    // Go ahead and query the quota information!
    //
    status = NtQueryQuotaInformationFile(
                            rfcb->Lfcb->FileHandle,
                            &iosb,
                            transaction->OutData,
                            transaction->MaxDataCount,
                            request->ReturnSingleEntry,
                            sidListBuffer,
                            sidListLength,
                            startSid,
                            request->RestartScan
            );

    if (sidListBuffer != NULL) {
        FREE_HEAP(sidListBuffer);
    }

    //
    // Paranoia
    //
    if( iosb.Information > transaction->MaxDataCount ) {
        iosb.Information = transaction->MaxDataCount;
    }

    transaction->SetupCount = 0;

    SmbPutUlong( &response->Length, (ULONG)iosb.Information );
    transaction->ParameterCount = sizeof( *response );
    transaction->DataCount = (ULONG)iosb.Information;

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    return SmbTransStatusSuccess;

} // SrvSmbQueryQuota


SMB_TRANS_STATUS
SrvSmbSetQuota (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NtSetQuotaInformationFile request.  This request arrives in an
    Nt Transaction SMB.

--*/
{
    PREQ_NT_SET_FS_QUOTA_INFO request;

    NTSTATUS status;
    PTRANSACTION transaction;

    PRFCB rfcb;
    PVOID buffer,pQuotaInfo=NULL;
    ULONG errorOffset;

    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_NT_SET_FS_QUOTA_INFO)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( transaction->ParameterCount < sizeof( *request ) ) {
        //
        // Not enough parameter bytes were sent.
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // We do not need to check the buffer for validity, because
    //     IopSetEaOrQuotaInformationFile does this even for kernel mode callers!
    //

    iosb.Information = 0;

    // we have to do allocation here in order to get a QUAD_WORD
    // aligned pointer. This is so because this is a requirement on
    // alpha for the quota buffer

    pQuotaInfo = ALLOCATE_HEAP_COLD( transaction->DataCount, BlockTypeDataBuffer );

    if (pQuotaInfo)
    {
        RtlCopyMemory(
            pQuotaInfo,
            transaction->InData,
            transaction->DataCount
            );

        //
        // Go ahead and set the quota information!
        //
        status = NtSetQuotaInformationFile(
                                rfcb->Lfcb->FileHandle,
                                &iosb,
                                pQuotaInfo,
                                transaction->DataCount
                                );

        if( !NT_SUCCESS( status ) ) {
            SrvSetSmbError( WorkContext, status );
        }

        //
        // Nothing to return to the client except the status
        //
        transaction->SetupCount = 0;
        transaction->ParameterCount = 0;
        transaction->DataCount = 0;

        FREE_HEAP(pQuotaInfo);
    }
    else
    {
        SrvSetSmbError( WorkContext, STATUS_INSUFFICIENT_RESOURCES );
    }
    return SmbTransStatusSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbnotfy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbnotfy.c

Abstract:

    This module contains routine for processing the following SMBs:

        NT Notify Change.

Author:

    Manny Weiser (mannyw) 29-Oct-1991

Revision History:

--*/

#include "precomp.h"
#include "smbnotfy.tmh"
#pragma hdrstop

//
// Forward declarations
//

VOID SRVFASTCALL
RestartNtNotifyChange (
    PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbNtNotifyChange )
#pragma alloc_text( PAGE, RestartNtNotifyChange )
#pragma alloc_text( PAGE, SrvSmbFindNotify )
#pragma alloc_text( PAGE, SrvSmbFindNotifyClose )
#endif


SMB_TRANS_STATUS
SrvSmbNtNotifyChange (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an NT notify change SMB.  This request arrives in an
    NT Transaction SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_NOTIFY_CHANGE request;

    NTSTATUS status;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT fid;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    request = (PREQ_NOTIFY_CHANGE)transaction->InSetup;

    if( transaction->SetupCount * sizeof( USHORT ) < sizeof( REQ_NOTIFY_CHANGE ) ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;
    }

    fid = SmbGetUshort( &request->Fid );

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                NULL,   // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID or write behind error.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint((
                "SrvSmbNtIoctl: Status %X on FID: 0x%lx\n",
                status,
                fid
                ));
        }

        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;

    }

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_DIRECTORY_CONTROL,
        IRP_MN_NOTIFY_CHANGE_DIRECTORY,
        0,
        &status
        );

    if ( !NT_SUCCESS( status ) ) {
        SrvStatistics.GrantedAccessErrors++;
        SrvSetSmbError( WorkContext, status );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartNtNotifyChange;

    //
    // Build the IRP to start a the I/O control.
    // Pass this request to the filesystem.
    //

    SrvBuildNotifyChangeRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        SmbGetUlong( &request->CompletionFilter ),
        transaction->OutParameters,
        transaction->MaxParameterCount,
        request->WatchTree
        );

#if DBG_STUCK

    //
    // Since change notify can take an arbitrary amount of time, do
    //  not include it in the "stuck detection & printout" code in the
    //  scavenger
    //
    WorkContext->IsNotStuck = TRUE;

#endif

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject( rfcb->Lfcb->FileObject ),
                WorkContext->Irp
                );

    //
    // The call was successfully started, return InProgress to the caller
    //

    return SmbTransStatusInProgress;

}


VOID SRVFASTCALL
RestartNtNotifyChange (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an NT Notify Change SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;
    PIRP irp;
    ULONG length;

    PAGED_CODE( );

    //
    // If we built an MDL for this IRP, free it now.
    //

    irp = WorkContext->Irp;

    if ( irp->MdlAddress != NULL ) {
        MmUnlockPages( irp->MdlAddress );
        IoFreeMdl( irp->MdlAddress );
        irp->MdlAddress = NULL;
    }

    status = irp->IoStatus.Status;

    if ( !NT_SUCCESS( status ) ) {

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );

        return;
    }

    //
    // The Notify change request has completed successfully.  Send the
    // response.
    //

    length = (ULONG)irp->IoStatus.Information;
    transaction = WorkContext->Parameters.Transaction;  

    ASSERT( length <= transaction->MaxParameterCount );

    if ( irp->UserBuffer != NULL ) {

        //
        // The file system wanted "neither" I/O for this request.  This
        // means that the file system will have allocated a system
        // buffer for the returned data.  Normally this would be copied
        // back to our user buffer during I/O completion, but we
        // short-circuit I/O completion before the copy happens.  So we
        // have to copy the data ourselves.
        //

        if ( irp->AssociatedIrp.SystemBuffer != NULL ) {
            ASSERT( irp->UserBuffer == transaction->OutParameters );
            RtlCopyMemory( irp->UserBuffer, irp->AssociatedIrp.SystemBuffer, length );
        }
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = length;
    transaction->DataCount = 0;

    //
    // !!! Mask a base notify bug, remove when the bug is fixed.
    //

    if ( status == STATUS_NOTIFY_CLEANUP ) {
        transaction->ParameterCount = 0;
    }

    SrvCompleteExecuteTransaction( WorkContext, SmbTransStatusSuccess );
    return;

} // RestartNtNotifyChange


//
// Since OS/2 chose not to expose the DosFindNotifyFirst/Next/Close APIs,
// OS/2 LAN Man does not officially support these SMBs.  This is true,
// even though the Find Notify SMB is documented as a LAN Man 2.0 SMB
// there is code in both the LM2.0 server and redir to support it.
//
// Therefore the NT server will also not support these SMBs.
//

SMB_TRANS_STATUS
SrvSmbFindNotify (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );
    return SrvTransactionNotImplemented( WorkContext );
}

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindNotifyClose (
    SMB_PROCESSOR_PARAMETERS
    )
{
    PAGED_CODE( );
    return SrvSmbNotImplemented( SMB_PROCESSOR_ARGUMENTS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbopen.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbopen.c

Abstract:

    This module contains routines for processing the following SMBs:

        Open
        Open and X
        Create
        Create New
        Create Temporary

    *** The SearchAttributes field in open/create SMBs is always
        ignored.  This duplicates the LM 2.0 server behavior.

Author:

    David Treadwell (davidtr) 23-Nov-1989
    Manny Weiser (mannyw)     15-Apr-1991  (oplock support)

Revision History:

    16-Apr-1991 mannyw



--*/

#include "precomp.h"
#include "smbopen.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBOPEN
#define MAX_TEMP_OPEN_RETRIES 24

//
// in smbtrans.c
//

SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Local functions
//

VOID
SetEofToMatchAllocation (
    IN HANDLE FileHandle,
    IN ULONG AllocationSize
    );

VOID SRVFASTCALL
RestartOpen (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateOpenResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartOpenAndX (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateOpenAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartOpen2 (
    PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
GenerateOpen2Response (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartNtCreateAndX (
    PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateNtCreateAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartCreateWithSdOrEa (
    PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
GenerateCreateWithSdOrEaResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    );

VOID SRVFASTCALL
RestartSmbCreate(
    IN PWORK_CONTEXT WorkContext
    );

SMB_PROCESSOR_RETURN_TYPE
GenerateCreateResponse(
    PWORK_CONTEXT WorkContext,
    NTSTATUS CreateStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbOpen )
#pragma alloc_text( PAGE, RestartOpen )
#pragma alloc_text( PAGE, GenerateOpenResponse )
#pragma alloc_text( PAGE, SrvSmbOpenAndX )
#pragma alloc_text( PAGE, RestartOpenAndX )
#pragma alloc_text( PAGE, GenerateOpenAndXResponse )
#pragma alloc_text( PAGE, SrvSmbOpen2 )
#pragma alloc_text( PAGE, RestartOpen2 )
#pragma alloc_text( PAGE, GenerateOpen2Response )
#pragma alloc_text( PAGE, SrvSmbNtCreateAndX )
#pragma alloc_text( PAGE, RestartNtCreateAndX )
#pragma alloc_text( PAGE, GenerateNtCreateAndXResponse )
#pragma alloc_text( PAGE, SrvSmbCreateWithSdOrEa )
#pragma alloc_text( PAGE, RestartCreateWithSdOrEa )
#pragma alloc_text( PAGE, GenerateCreateWithSdOrEaResponse )
#pragma alloc_text( PAGE, SrvSmbCreate )
#pragma alloc_text( PAGE, SrvSmbCreateTemporary )
#pragma alloc_text( PAGE, SetEofToMatchAllocation )
#pragma alloc_text( PAGE, RestartSmbCreate )
#pragma alloc_text( PAGE, GenerateCreateResponse )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpen (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an Open SMB.  (This is the 'core' Open.)

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_OPEN request;

    NTSTATUS   status    = STATUS_SUCCESS;
    USHORT     access;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Open file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Open file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_OPEN)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );

    status = SrvCreateFile(
                 WorkContext,
                 (USHORT)(access & ~SMB_DA_WRITE_THROUGH), // Allow write behind
                 (USHORT)0,                                // SmbFileAttributes
                 SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL,
                 (ULONG)0,                                 // SmbAllocationSize
                 (PCHAR)(request->Buffer + 1),
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                    OplockTypeBatch :
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpen
                 );


    if (status == STATUS_OPLOCK_BREAK_IN_PROGRESS) {

        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a response.
        //
        SmbStatus = SmbStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //
        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
    } else {

        // The open has completed.  Generate and send the reply.
        //
        SmbStatus = GenerateOpenResponse( WorkContext, status );
    }
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbOpen


VOID SRVFASTCALL
RestartOpen (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open SMB.  (This is the 'core' Open.)

Arguments:

    WorkContext - A pointer to the work context block for this SMB.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpenResponse(
                    WorkContext,
                    openStatus
                    );

    SrvEndSmbProcessing( WorkContext, smbStatus );
    SrvWmiEndContext(WorkContext);
    return;
} // RestartOpen


SMB_PROCESSOR_RETURN_TYPE
GenerateOpenResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open SMB.  (This is the 'core' Open.)

Arguments:

    WorkContext -

    Status - The status of the open operation.

Return Value:

    The status of the SMB processing.

--*/

{
    PRESP_OPEN response;
    PREQ_OPEN request;
    NTSTATUS status;

    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    PRFCB rfcb;
    USHORT access;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );
        return SmbStatusSendResponse;
    }

    rfcb = WorkContext->Rfcb;
    response = (PRESP_OPEN)WorkContext->ResponseParameters;
    request = (PREQ_OPEN)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    //
    // Get the additional information that needs to be returned in the
    // response SMB.  We always open with FILE_READ_ATTRIBUTES, so no
    // access check is required.
    //

    status = SrvQueryInformationFileAbbreviated(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 &srvFileInformation,
                 FALSE,
                 WorkContext->TreeConnect->Share->ShareType
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateOpenResponse: SrvQueryInformationFile failed: %X\n",
                        status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError( WorkContext, status );
        return SmbStatusSendResponse;
    }

    rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;

    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up fields of response SMB.  Note that we copy the desired
    // access to the granted access in the response.  They must be the
    // same, else the request would have failed.
    //
    // !!! This will not be the case for compatibility mode and FCB opens!
    //

    response->WordCount = 7;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUshort( &response->FileAttributes, srvFileInformation.Attributes );
    SmbPutUlong(
        &response->LastWriteTimeInSeconds,
        srvFileInformation.LastWriteTimeInSeconds
        );
    SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );
    SmbPutUshort(
        &response->GrantedAccess,
        access );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_OPEN, 0 );

    IF_DEBUG(TRACE2) KdPrint(( "GenerateOpenResponse complete.\n" ));

    return SmbStatusSendResponse;

} // GenerateOpenResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenAndX (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes an OpenAndX SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_OPEN_ANDX request;

    NTSTATUS   status    = STATUS_SUCCESS;
    USHORT     access;
    SMB_STATUS smbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_AND_X;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Open file and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Open file and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // If we are not on a blocking thread and we don't have a license
    //  from the license server, shift the request over to the blocking work
    //  queue since acquiring a license is an expensive operation and we don't
    //  want to congest our nonblocking worker threads
    //
    if( WorkContext->UsingBlockingThread == 0 ) {

        PSESSION session;
        PTREE_CONNECT treeConnect;

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbOpenAndX: Invalid UID or TID\n" ));
            }
            smbStatus = GenerateOpenAndXResponse( WorkContext, status );
            goto Cleanup;
        }

        if( session->IsLSNotified == FALSE ) {

            //
            // Insert the work item at the tail of the blocking work queue.
            //
            SrvInsertWorkQueueTail(
                GET_BLOCKING_WORK_QUEUE(),
                (PQUEUEABLE_BLOCK_HEADER)WorkContext
            );

            smbStatus = SmbStatusInProgress;
            goto Cleanup;
        }
    }

    request = (PREQ_OPEN_ANDX)WorkContext->RequestParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    status = SrvCreateFile(
                 WorkContext,
                 access,
                 SmbGetUshort( &request->FileAttributes ),
                 SmbGetUshort( &request->OpenFunction ),
                 SmbGetUlong( &request->AllocationSize ),
                 (PCHAR)request->Buffer,
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (SmbGetUshort(&request->Flags) & SMB_OPEN_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (SmbGetUshort(&request->Flags) & SMB_OPEN_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpenAndX
                 );

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        smbStatus = SmbStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        smbStatus = SmbStatusInProgress;

    } else {

        //
        // The open has completed.  Generate and send the reply.
        //

        smbStatus = GenerateOpenAndXResponse( WorkContext, status );

    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return smbStatus;
} // SrvSmbOpenAndX


VOID SRVFASTCALL
RestartOpenAndX (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open and X SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_AND_X;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpenAndXResponse(
                    WorkContext,
                    openStatus
                    );

    if ( smbStatus == SmbStatusMoreCommands ) {

        SrvProcessSmb( WorkContext );

    } else {

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }
    SrvWmiEndContext(WorkContext);

    return;

} // RestartOpenAndX


SMB_PROCESSOR_RETURN_TYPE
GenerateOpenAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_OPEN_ANDX request;
    PRESP_OPEN_ANDX response;

    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    BOOLEAN reqAdditionalInformation;
    BOOLEAN reqExtendedResponse;
    PRFCB rfcb;
    PLFCB lfcb;
    PIO_STATUS_BLOCK ioStatusBlock;
    UCHAR nextCommand;
    USHORT reqAndXOffset;
    USHORT access;
    USHORT action = 0;
    OPLOCK_TYPE oplockType;

    NTSTATUS status;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        return SmbStatusSendResponse;
    }

    request = (PREQ_OPEN_ANDX)WorkContext->RequestParameters;
    response = (PRESP_OPEN_ANDX)WorkContext->ResponseParameters;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use
    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    reqExtendedResponse = (BOOLEAN)( (SmbGetUshort(&request->Flags) &
            SMB_OPEN_EXTENDED_RESPONSE) != 0);

    //
    // Attempt to acquire the oplock.
    //

    if ( WorkContext->TreeConnect->Share->ShareType != ShareTypePrint ) {

        if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPBATCH) != 0 ) {
            oplockType = OplockTypeBatch;
        } else if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPLOCK) != 0 ) {
            oplockType = OplockTypeExclusive;
        } else {
            oplockType = OplockTypeServerBatch;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, FALSE ) ) {

            //
            // The oplock was granted.  Save in action so that we tell
            // the client he has an oplock and update statistics.
            //

            action = SMB_OACT_OPLOCK;

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.  Update statistics.
            //

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }
    }

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //
    ioStatusBlock = &WorkContext->Irp->IoStatus;

    if ( (ioStatusBlock->Information == FILE_CREATED) ||
         (ioStatusBlock->Information == FILE_OVERWRITTEN) ) {

        //
        // Extending EOF is only legal if the client has write access
        // to the file.  If the client doesn't have write access, don't
        // extend the file.
        //
        // *** This is an incompatibility with OS/2.

        if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            SetEofToMatchAllocation(
                lfcb->FileHandle,
                SmbGetUlong( &request->AllocationSize )
                );
        } else {
            SrvStatistics.GrantedAccessErrors++;
        }
    }

    //
    // If the consumer requested additional information, find it now.
    //

    reqAdditionalInformation = (BOOLEAN)( (SmbGetUshort(&request->Flags) &
            SMB_OPEN_QUERY_INFORMATION) != 0);

    if ( reqAdditionalInformation ||
        ( !rfcb->WriteAccessGranted && rfcb->AppendAccessGranted) ) {

        //
        // We always open with at least FILE_READ_ATTRIBUTES, so no
        // access check is needed.
        //

        status = SrvQueryInformationFileAbbreviated(
                     lfcb->FileHandle,
                     lfcb->FileObject,
                     &srvFileInformation,
                     reqExtendedResponse,
                     WorkContext->TreeConnect->Share->ShareType
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbOpenAndX: SrvQueryInformationFile failed: "
                            "%X\n", status ));
            }

            SrvCloseRfcb( rfcb );

            SrvSetSmbError( WorkContext, status );
            return SmbStatusSendResponse;
        }

        rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;
    }

    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up response SMB.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    if (reqExtendedResponse) {
        NTSTATUS ExtendedResponseStatus;

        PRESP_EXTENDED_OPEN_ANDX ExtendedResponse;

        ExtendedResponse = (PRESP_EXTENDED_OPEN_ANDX)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &ExtendedResponse->MaximalAccessRights,
                                     &ExtendedResponse->GuestMaximalAccessRights);

        // Fall back to regular response if there was an error in obtainaing
        // the maximal access rights
        reqExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if (!reqExtendedResponse) {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_OPEN_ANDX,
                0
                )
            );

        response->WordCount = 15;
    } else {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_EXTENDED_OPEN_ANDX,
                0
                )
            );

        response->WordCount = 19;
    }

    SmbPutUshort( &response->Fid, rfcb->Fid );

    //
    // If the consumer requested additional information, set appropiate
    // fields, else set the fields to zero.
    //

    if ( reqAdditionalInformation ) {

        SmbPutUshort(
            &response->FileAttributes,
            srvFileInformation.Attributes
            );
        SmbPutUlong(
            &response->LastWriteTimeInSeconds,
            srvFileInformation.LastWriteTimeInSeconds
            );
        SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );

        access &= SMB_DA_SHARE_MASK;

        if( rfcb->ReadAccessGranted && (rfcb->WriteAccessGranted || rfcb->AppendAccessGranted) ) {
            access |= SMB_DA_ACCESS_READ_WRITE;
        } else if( rfcb->ReadAccessGranted ) {
            access |= SMB_DA_ACCESS_READ;
        } else if( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            access |= SMB_DA_ACCESS_WRITE;
        }

        SmbPutUshort( &response->GrantedAccess, access );
        SmbPutUshort( &response->FileType, srvFileInformation.Type );
        SmbPutUshort( &response->DeviceState, srvFileInformation.HandleState );

    } else {

        RtlZeroMemory( (PVOID)&response->FileAttributes, 16 );

    }

    //
    // Bit field mapping of Action:
    //
    //    Lrrr rrrr rrrr rrOO
    //
    // where:
    //
    //    L - Lock (single-user total file lock status)
    //       0 - file opened by another user
    //       1 - file is opened only by this user at the present time
    //
    //    O - Open (action taken on open)
    //       1 - the file existed and was opened
    //       2 - the file did not exist but was created
    //       3 - the file existed and was truncated
    //

    switch ( ioStatusBlock->Information ) {

    case FILE_OPENED:

        action |= SMB_OACT_OPENED;
        break;

    case FILE_CREATED:

        action |= SMB_OACT_CREATED;
        break;

    case FILE_OVERWRITTEN:

        action |= SMB_OACT_TRUNCATED;
        break;

    default:

        IF_DEBUG(ERRORS) {
            KdPrint(( "Unknown Information value in IO status block: 0x%p\n",
                        (PVOID)(ioStatusBlock->Information) ));
        }

    }

    SmbPutUshort( &response->Action, action );

    SmbPutUlong( &response->ServerFid, (ULONG)0 );

    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_IOCTL:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbOpenAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        //
        // Return an error indicating that the followon command was bad.
        // Note that the open is still considered successful, so the
        // file remains open.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbStatusSendResponse;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        return SmbStatusMoreCommands;

    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpenAndX complete.\n" ));
    return SmbStatusSendResponse;

} // GenerateOpenAndXResponse


SMB_TRANS_STATUS
SrvSmbOpen2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an Open2 SMB.  This request arrives in a Transaction2 SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/

{
    PREQ_OPEN2 request;
    PRESP_OPEN2 response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    USHORT access;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    USHORT os2EaErrorOffset = 0;
    PFILE_FULL_EA_INFORMATION ntFullEa;
    ULONG ntFullEaBufferLength;
    PFEALIST feaList;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN2;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_OPEN2)transaction->InParameters;
    response = (PRESP_OPEN2)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_OPEN2)) ||
         (transaction->MaxParameterCount < sizeof(RESP_OPEN2)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS)
            KdPrint(( "SrvSmbOpen2: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError2( WorkContext, STATUS_INVALID_SMB, TRUE );
        status = STATUS_INVALID_SMB;
        goto err_exit;
    }

    //
    // Convert the EA list to NT style.
    //

    eaErrorOffset = 0;
    feaList = (PFEALIST)transaction->InData;

    //
    // Make sure that the value in Fealist->cbList is legitimate and that
    // there is at least sufficient data for a single EA.
    //
    // This code will fail if no EA list is indicated.  Don't know
    // if this is correct, but it was the previous behavior so
    // it's been enforced.
    //

    if ( transaction->DataCount <= sizeof(FEALIST) ||
         SmbGetUlong( &feaList->cbList ) <= sizeof(FEALIST) ||
         SmbGetUlong( &feaList->cbList ) > transaction->DataCount) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "EA list size bad: size =  %ld, data sent was %ld\n",
                          SmbGetUlong( &feaList->cbList ), transaction->DataCount ));
        }
        SrvSetSmbError2( WorkContext, STATUS_OS2_EA_LIST_INCONSISTENT, TRUE );
        status = STATUS_OS2_EA_LIST_INCONSISTENT;
        goto err_exit;
    }

    //
    // Convert the FEALIST to NT style.
    //

    status = SrvOs2FeaListToNt(
                 feaList,
                 &ntFullEa,
                 &ntFullEaBufferLength,
                 &os2EaErrorOffset
                 );

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        goto err_exit;
    }

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    status = SrvCreateFile(
                 WorkContext,
                 access,
                 SmbGetUshort( &request->FileAttributes ),
                 SmbGetUshort( &request->OpenFunction ),
                 SmbGetUlong( &request->AllocationSize ),
                 (PCHAR)request->Buffer,
                 END_OF_TRANSACTION_PARAMETERS( transaction ),
                 ntFullEa,
                 ntFullEaBufferLength,
                 &eaErrorOffset,
                 (SmbGetUshort(&request->Flags) & SMB_OPEN_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (SmbGetUshort(&request->Flags) & SMB_OPEN_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartOpen2
                 );

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        //
        // Save a pointer to the full ea structure
        //

        WorkContext->Parameters2.Open.NtFullEa = ntFullEa;
        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //
        // We need to free the EA buffer in this case.
        //

        DEALLOCATE_NONPAGED_POOL(ntFullEa);
        WorkContext->FspRestartRoutine = (PRESTART_ROUTINE)ExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else {

        //
        // Save a pointer to the full ea structure
        //

        WorkContext->Parameters2.Open.NtFullEa = ntFullEa;
        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        //
        // The open has completed.  Generate and send the reply.
        //

        SmbStatus = GenerateOpen2Response( WorkContext, status );
        goto Cleanup;
    }

err_exit:

    RtlZeroMemory( (PVOID)&response->Fid, 24 );
    SmbPutUshort( &response->EaErrorOffset, os2EaErrorOffset );
    SmbPutUlong( &response->EaLength, 0 );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    SmbStatus = SmbTransStatusErrorWithData;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbOpen2


VOID SRVFASTCALL
RestartOpen2 (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open2 SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN2;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateOpen2Response(
                    WorkContext,
                    openStatus
                    );


    SrvCompleteExecuteTransaction( WorkContext, smbStatus );

    SrvWmiEndContext(WorkContext);
    return;

} // RestartOpen2


SMB_TRANS_STATUS
GenerateOpen2Response (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Open and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_OPEN2 request;
    PRESP_OPEN2 response;

    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    BOOLEAN reqAdditionalInformation;
    SRV_FILE_INFORMATION_ABBREVIATED srvFileInformation;
    BOOLEAN reqEaLength;
    FILE_EA_INFORMATION fileEaInformation;
    USHORT access;
    USHORT action = 0;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    USHORT os2EaErrorOffset = 0;
    PFILE_FULL_EA_INFORMATION ntFullEa;
    PFEALIST feaList;
    OPLOCK_TYPE oplockType;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_OPEN2)transaction->InParameters;
    response = (PRESP_OPEN2)transaction->OutParameters;

    feaList = (PFEALIST)transaction->InData;
    ntFullEa = WorkContext->Parameters2.Open.NtFullEa;
    eaErrorOffset = WorkContext->Parameters2.Open.EaErrorOffset;

    access = SmbGetUshort( &request->DesiredAccess );   // save for later use

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {

        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS.
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        //
        // If an EA error offset was returned, convert it from an offset
        // into the NT full EA list to an offset in the OS/2 1.2 FEALIST.
        //

        if ( eaErrorOffset != 0 ) {
            os2EaErrorOffset = SrvGetOs2FeaOffsetOfError(
                                   eaErrorOffset,
                                   ntFullEa,
                                   feaList
                                   );
        }


        DEALLOCATE_NONPAGED_POOL( ntFullEa );
        goto err_exit;
    }

    DEALLOCATE_NONPAGED_POOL( ntFullEa );

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    if ( (WorkContext->Irp->IoStatus.Information == FILE_CREATED) ||
         (WorkContext->Irp->IoStatus.Information == FILE_OVERWRITTEN) ) {


        //
        // Extending EOF is only legal if the client has write access
        // to the file.  If the client doesn't have write access, don't
        // extend the file.
        //
        // *** This is an incompatibility with OS/2.

        if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {
            SetEofToMatchAllocation(
                lfcb->FileHandle,
                SmbGetUlong( &request->AllocationSize )
                );
        } else {
            SrvStatistics.GrantedAccessErrors++;
        }
    }

    //
    // If the consumer requested additional information, find it now.
    //

    reqAdditionalInformation =
        (BOOLEAN)((SmbGetUshort( &request->Flags ) &
            SMB_OPEN_QUERY_INFORMATION) != 0);
    reqEaLength =
        (BOOLEAN)((SmbGetUshort( &request->Flags ) &
            SMB_OPEN_QUERY_EA_LENGTH) != 0);

    if ( reqAdditionalInformation ||
        (!rfcb->WriteAccessGranted && rfcb->AppendAccessGranted) ) {

        //
        // We always open with at least FILE_READ_ATTRIBUTES, so no
        // access check is needed.
        //

        status = SrvQueryInformationFileAbbreviated(
                     lfcb->FileHandle,
                     lfcb->FileObject,
                     &srvFileInformation,
                     FALSE,
                     WorkContext->TreeConnect->Share->ShareType
                     );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbOpen2: SrvQueryInformationFile failed: "
                            "%X\n", status ));
            }

            SrvCloseRfcb( rfcb );

            SrvSetSmbError2( WorkContext, status, TRUE );
            goto err_exit;
        }

        rfcb->Mfcb->NonpagedMfcb->OpenFileSize = srvFileInformation.DataSize;
    }

    if ( reqEaLength ) {

        IO_STATUS_BLOCK eaIoStatusBlock;

        status = NtQueryInformationFile(
                     lfcb->FileHandle,
                     &eaIoStatusBlock,
                     &fileEaInformation,
                     sizeof(FILE_EA_INFORMATION),
                     FileEaInformation
                     );

        if ( NT_SUCCESS(status) ) {
            status = eaIoStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbOpen2: NtQueryInformationFile (file information)"
                    "returned %X",
                status,
                NULL
                );

            SrvCloseRfcb( rfcb );

            SrvSetSmbError2( WorkContext, status, TRUE );
            goto err_exit;
        } else {

            //
            // Adjust the EA size.  If there are no EAs, OS/2 expects
            // EA size = 4.
            //

            if (fileEaInformation.EaSize == 0) {
                fileEaInformation.EaSize = 4;
            }
        }

    } else {

        fileEaInformation.EaSize = 0;
    }

    //
    // Attempt to acquire the oplock.
    //

    if ( WorkContext->TreeConnect->Share->ShareType != ShareTypePrint ) {

        if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPBATCH) != 0 ) {
            oplockType = OplockTypeBatch;
        } else if ( (SmbGetUshort( &request->Flags ) & SMB_OPEN_OPLOCK) != 0 ) {
            oplockType = OplockTypeExclusive;
        } else {
            oplockType = OplockTypeServerBatch;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, FALSE ) ) {
            action = SMB_OACT_OPLOCK;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );
        } else {
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );
        }
    }

    //
    // Set up response SMB.
    //

    SmbPutUshort( &response->Fid, rfcb->Fid );

    //
    // If the consumer requested additional information, set appropiate
    // fields, else set the fields to zero.
    //

    if ( reqAdditionalInformation ) {

        SmbPutUshort(
            &response->FileAttributes,
            srvFileInformation.Attributes
            );
        SmbPutUlong( &response->DataSize, srvFileInformation.DataSize.LowPart );
        SmbPutUshort( &response->GrantedAccess, access );
        SmbPutUshort( &response->FileType, srvFileInformation.Type );
        SmbPutUshort( &response->DeviceState, srvFileInformation.HandleState );

    } else {

        RtlZeroMemory( (PVOID)&response->FileAttributes, 16 );

    }

    //
    // Bit field mapping of Action:
    //
    //    Lrrr rrrr rrrr rrOO
    //
    // where:
    //
    //    L - Lock (single-user total file lock status)
    //       0 - file opened by another user
    //       1 - file is opened only by this user at the present time
    //
    //    O - Open (action taken on open)
    //       1 - the file existed and was opened
    //       2 - the file did not exist but was created
    //       3 - the file existed and was truncated
    //

    switch ( WorkContext->Irp->IoStatus.Information ) {

    case FILE_OPENED:

        action |= SMB_OACT_OPENED;
        break;

    case FILE_CREATED:

        action |= SMB_OACT_CREATED;
        break;

    case FILE_OVERWRITTEN:

        action |= SMB_OACT_TRUNCATED;
        break;

    default:

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbOpen2: Unknown Information value in IO status"
                "block: 0x%lx\n",
            WorkContext->Irp->IoStatus.Information,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_IO_CREATE_FILE,
                              (ULONG)WorkContext->Irp->IoStatus.Information );

    }

    SmbPutUshort( &response->Action, action );

    SmbPutUlong( &response->ServerFid, (ULONG)0 );

    SmbPutUshort( &response->EaErrorOffset, 0 );
    SmbPutUlong( &response->EaLength, fileEaInformation.EaSize );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpen2 complete.\n" ));
    return SmbTransStatusSuccess;

err_exit:

    RtlZeroMemory( (PVOID)&response->Fid, 24 );
    SmbPutUshort( &response->EaErrorOffset, os2EaErrorOffset );
    SmbPutUlong( &response->EaLength, 0 );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_OPEN2);
    transaction->DataCount = 0;

    return SmbTransStatusErrorWithData;

} // GenerateOpen2Response


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCreateAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes an NtCreateAndX SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_NT_CREATE_ANDX request;
    ULONG flags;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    LARGE_INTEGER allocationSize;
    UNICODE_STRING fileName;
    PUCHAR name;
    USHORT nameLength;
    SECURITY_QUALITY_OF_SERVICE qualityOfService;
    BOOLEAN isUnicode;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CREATE_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create file and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create file and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_NT_CREATE_ANDX)WorkContext->RequestParameters;

    allocationSize.HighPart = SmbGetUlong( &request->AllocationSize.HighPart );
    allocationSize.LowPart = SmbGetUlong( &request->AllocationSize.LowPart );

    flags = SmbGetUlong( &request->Flags );

    //
    // First verify that the file path name does not extend beyond the
    // end of the SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    //
    //  if this request has IfModifiedSince fields, the request is of a
    //  slightly different format, the Name field is lower.
    //
    name = (PUCHAR)request->Buffer;

    if ( isUnicode ) {
        name = ALIGN_SMB_WSTR( name );
    }

    nameLength = SmbGetUshort( &request->NameLength );
    if ( name + nameLength > ( END_OF_REQUEST_SMB( WorkContext ) + 1 ) ) {
        status    = STATUS_INVALID_SMB;
        SmbStatus = GenerateNtCreateAndXResponse( WorkContext, STATUS_INVALID_SMB );
        goto Cleanup;
    }

    //
    // Convert the file name to a Unicode string.
    //

    status = SrvMakeUnicodeString(
                 isUnicode,
                 &fileName,
                 name,
                 &nameLength
                 );

    if ( !NT_SUCCESS( status ) ) {
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = GenerateNtCreateAndXResponse(
                   WorkContext,
                   STATUS_INSUFF_SERVER_RESOURCES
                   );
        goto Cleanup;
    }

    //
    // *** We always ask for STATIC tracking, not DYNAMIC, because we
    //     don't support dynamic tracking over the net yet.
    //
    // !!! Note that once we support dynamic tracking, we MUST CHANGE
    //     THE NAMED PIPE PROCESSING to not do writes/transceives at DPC
    //     level, because the NPFS needs to call SeCreateClientSecurity
    //     on every write when dynamic tracking is selected!
    //

    qualityOfService.Length = sizeof( qualityOfService );
    qualityOfService.ImpersonationLevel =
        SmbGetUlong( &request->ImpersonationLevel );
    qualityOfService.ContextTrackingMode = FALSE;
    //qualityOfService.ContextTrackingMode = (BOOLEAN)
    //    (request->SecurityFlags & SMB_SECURITY_DYNAMIC_TRACKING);
    qualityOfService.EffectiveOnly = (BOOLEAN)
        (request->SecurityFlags & SMB_SECURITY_EFFECTIVE_ONLY);

    status = SrvNtCreateFile(
                 WorkContext,
                 SmbGetUlong( &request->RootDirectoryFid ),
                 SmbGetUlong( &request->DesiredAccess ),
                 allocationSize,
                 SmbGetUlong( &request->FileAttributes ),
                 SmbGetUlong( &request->ShareAccess ),
                 SmbGetUlong( &request->CreateDisposition ),
                 SmbGetUlong( &request->CreateOptions),
                 NULL,
                 &fileName,
                 NULL,
                 0,
                 NULL,
                 flags,
                 &qualityOfService,
                 (request->Flags & NT_CREATE_REQUEST_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (request->Flags & NT_CREATE_REQUEST_OPLOCK) != 0 ?
                    OplockTypeExclusive : OplockTypeServerBatch,
                 RestartNtCreateAndX
                 );

    //
    // Free the unicode file name buffer if it has been allocated.
    //

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        SmbStatus = SmbStatusInProgress;
    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
    } else {

        //
        // The open has completed.  Generate and send the reply.
        //

        SmbStatus = GenerateNtCreateAndXResponse( WorkContext, status );
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNtCreateAndX


VOID SRVFASTCALL
RestartNtCreateAndX (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Nt Create and X SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS openStatus = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NT_CREATE_AND_X;
    SrvWmiStartContext(WorkContext);

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateNtCreateAndXResponse(
                    WorkContext,
                    openStatus
                    );

    if ( smbStatus == SmbStatusMoreCommands ) {

        SrvProcessSmb( WorkContext );

    } else {
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    }
    SrvWmiEndContext(WorkContext);
    return;

} // RestartNtCreateAndX


SMB_PROCESSOR_RETURN_TYPE
GenerateNtCreateAndXResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Nt Create and X SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

Notes:



--*/

{
    PREQ_NT_CREATE_ANDX request;
    PRESP_NT_CREATE_ANDX response;
    SMB_PROCESSOR_RETURN_LOCAL rc;
    BOOLEAN GenerateExtendedResponse = FALSE;

    SRV_NT_FILE_INFORMATION srvNtFileInformation;
    PRFCB rfcb;
    PIO_STATUS_BLOCK ioStatusBlock;
    UCHAR nextCommand;
    USHORT reqAndXOffset;
    OPLOCK_TYPE oplockType;
    UCHAR oplockLevel;
    BOOLEAN allowLevelII;
    BOOLEAN extendedRequested;
    ULONG CreateAction = (ULONG)WorkContext->Irp->IoStatus.Information;

    ULONG desiredAccess;

    NTSTATUS status;

    PAGED_CODE( );

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {
        SrvSetSmbError( WorkContext, OpenStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        return SmbStatusSendResponse;
    }

    request = (PREQ_NT_CREATE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_NT_CREATE_ANDX)WorkContext->ResponseParameters;

    //
    // Does the client want extended info in the response?
    //
    extendedRequested = ((request->Flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE) != 0 );

    desiredAccess = SmbGetUlong( &request->DesiredAccess );

    rfcb = WorkContext->Rfcb;

    //
    // Attempt to acquire the oplock.
    //

    if ( desiredAccess != DELETE &&
        !(request->CreateOptions & FILE_DIRECTORY_FILE) ) {

        if ( request->Flags & NT_CREATE_REQUEST_OPLOCK ) {
            allowLevelII = CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, WorkContext->Connection );
            if ( request->Flags & NT_CREATE_REQUEST_OPBATCH ) {
                oplockType = OplockTypeBatch;
                oplockLevel = SMB_OPLOCK_LEVEL_BATCH;
            } else {
                oplockType = OplockTypeExclusive;
                oplockLevel = SMB_OPLOCK_LEVEL_EXCLUSIVE;
            }
        } else {
            allowLevelII = FALSE;
            oplockType = OplockTypeServerBatch;
            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
        }

        if( SrvRequestOplock( WorkContext, &oplockType, allowLevelII ) ) {

            //
            // The oplock was granted.  Check to see if it was a level 2.
            //

            if ( oplockType == OplockTypeShareRead ) {
                oplockLevel = SMB_OPLOCK_LEVEL_II;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.
            //

            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }

    } else {

        oplockLevel = SMB_OPLOCK_LEVEL_NONE;

    }

    //
    // If the file was created, set the EOF location to be the same as
    // the size of the file.  This is necessary for compatibility with
    // OS/2, which only has EOF, not a separate allocation size.
    //

    ioStatusBlock = &WorkContext->Irp->IoStatus;

    //
    // We always open with at least FILE_READ_ATTRIBUTES, so no
    // access check is needed.
    //

    status = SrvQueryNtInformationFile(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 rfcb->ShareType,
                 extendedRequested,
                 &srvNtFileInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbNtCreateAndX: SrvQueryNtInformationFile failed: "
                        "%X\n", status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError( WorkContext, status );
        return SmbStatusSendResponse;
    }

    //
    // Save parts of the file info in the MFCB for fast tests
    //

    rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart =
                            srvNtFileInformation.NwOpenInfo.EndOfFile.QuadPart;
    rfcb->Mfcb->NonpagedMfcb->OpenFileAttributes =
                            srvNtFileInformation.NwOpenInfo.FileAttributes;

    // If the extended response is required then
    if ( extendedRequested ) {
        NTSTATUS ExtendedResponseStatus;
        PRESP_EXTENDED_NT_CREATE_ANDX pExtendedResponse;

        pExtendedResponse = (PRESP_EXTENDED_NT_CREATE_ANDX)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &pExtendedResponse->MaximalAccessRights,
                                     &pExtendedResponse->GuestMaximalAccessRights);

        GenerateExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    //
    // Set up response SMB.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if (GenerateExtendedResponse) {

        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_EXTENDED_NT_CREATE_ANDX,
                0
                )
            );

        response->WordCount = 42;

    } else {
        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_NT_CREATE_ANDX,
                0
                )
            );

        response->WordCount = 34;
    }

    response->OplockLevel = oplockLevel;

    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUlong( &response->CreateAction, CreateAction );

    SmbPutUlong(
        &response->CreationTime.HighPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.HighPart
        );
    SmbPutUlong(
        &response->CreationTime.LowPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.LowPart
        );
    SmbPutUlong(
        &response->LastAccessTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.HighPart
        );
    SmbPutUlong(
        &response->LastAccessTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.LowPart
        );
    SmbPutUlong(
        &response->LastWriteTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.HighPart
        );
    SmbPutUlong(
        &response->LastWriteTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.LowPart
        );
    SmbPutUlong(
        &response->ChangeTime.HighPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.HighPart
        );
    SmbPutUlong(
        &response->ChangeTime.LowPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.LowPart
        );

    SmbPutUlong( &response->FileAttributes, srvNtFileInformation.NwOpenInfo.FileAttributes );
    SmbPutUlong(
        &response->AllocationSize.HighPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.HighPart
        );
    SmbPutUlong(
        &response->AllocationSize.LowPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.LowPart
        );
    SmbPutUlong(
        &response->EndOfFile.HighPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.HighPart
        );
    SmbPutUlong(
        &response->EndOfFile.LowPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.LowPart
        );

    SmbPutUshort( &response->FileType, srvNtFileInformation.Type );
    SmbPutUshort( &response->DeviceState, srvNtFileInformation.HandleState );

    response->Directory = (srvNtFileInformation.NwOpenInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_IOCTL:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbNtCreateAndX: Illegal followon command: 0x%lx\n",
                        nextCommand ));
        }

        //
        // Return an error indicating that the followon command was bad.
        // Note that the open is still considered successful, so the
        // file remains open.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbStatusSendResponse;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        return SmbStatusMoreCommands;
    }

    rc = SmbStatusSendResponse;

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbNtCreateAndX complete.\n" ));
    return rc;

} // GenerateNtCreateAndXResponse

SMB_TRANS_STATUS
SrvSmbCreateWithSdOrEa (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes an Create with SD or EA SMB.  This request arrives in an
    Nt Transaction SMB.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  See smbtypes.h for a
        more complete description.

--*/
{
    PREQ_CREATE_WITH_SD_OR_EA request;
    PRESP_CREATE_WITH_SD_OR_EA response;

    NTSTATUS status;
    PTRANSACTION transaction;

    ULONG eaErrorOffset = 0;
    LARGE_INTEGER allocationSize;

    PVOID securityDescriptorBuffer;
    ULONG sdLength;
    ULONG eaLength;
    PVOID eaBuffer;

    UNICODE_STRING fileName;
    PUCHAR name;
    USHORT nameLength;
    BOOLEAN isUnicode;

    SECURITY_QUALITY_OF_SERVICE qualityOfService;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_CREATE_WITH_SD_OR_EA)transaction->InParameters;
    response = (PRESP_CREATE_WITH_SD_OR_EA)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount < sizeof(REQ_CREATE_WITH_SD_OR_EA)) ||
         (transaction->MaxParameterCount < sizeof(RESP_CREATE_WITH_SD_OR_EA)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS)
            KdPrint(( "SrvSmbCreateWithSdOrEa: bad parameter byte counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));

        SrvLogInvalidSmb( WorkContext );

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SMB
                    );

    }

    eaErrorOffset = 0;
    allocationSize.HighPart = SmbGetUlong( &request->AllocationSize.HighPart );
    allocationSize.LowPart = SmbGetUlong( &request->AllocationSize.LowPart );

    //
    // First verify that the file path name doesnot extend beyond the
    // end of the SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );
    name = (PUCHAR)request->Buffer;
    if ( isUnicode ) {
        name = ALIGN_SMB_WSTR( name );
    }

    nameLength = (USHORT)SmbGetUshort( &request->NameLength );
    if ( name + nameLength > ((PCHAR)request + transaction->ParameterCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbCreateWithSdOrEa: failed at line %u\n", __LINE__ ));
        }
        SrvLogInvalidSmb( WorkContext );

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SMB
                    );

    }

    //
    // Convert the file name to a Unicode string.
    //

    status = SrvMakeUnicodeString(
                 isUnicode,
                 &fileName,
                 name,
                 &nameLength
                 );

    if ( !NT_SUCCESS( status ) ) {
        return GenerateCreateWithSdOrEaResponse( WorkContext, status );
    }


    sdLength = SmbGetUlong( &request->SecurityDescriptorLength );
    eaLength = SmbGetUlong( &request->EaLength );

    securityDescriptorBuffer = transaction->InData;
    eaBuffer = (PCHAR)securityDescriptorBuffer + ((sdLength + 3) & ~ 3);

    if( eaLength > transaction->DataCount ||
        sdLength > transaction->DataCount ||
        (PCHAR)securityDescriptorBuffer + sdLength > (PCHAR)transaction->InData + transaction->DataCount ||
        (PCHAR)eaBuffer + eaLength > (PCHAR)transaction->InData + transaction->DataCount ||
        ((sdLength != 0) && !RtlValidRelativeSecurityDescriptor(securityDescriptorBuffer, sdLength, 0))) {

        IF_DEBUG( SMB_ERRORS ) {
            KdPrint(( "SrvSmbCreateWithSdOrEa: failed at line %u\n", __LINE__ ));
            KdPrint(( "  eaLength %u, sdLength %u, DataCount %u\n",
                        eaLength, sdLength, transaction->DataCount ));
        }

        SrvLogInvalidSmb( WorkContext );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &fileName );
        }

        return GenerateCreateWithSdOrEaResponse(
                    WorkContext,
                    STATUS_INVALID_SECURITY_DESCR
                    );
    }

    //
    // *** We always ask for STATIC tracking, not DYNAMIC, because we
    //     don't support dynamic tracking over the net yet.
    //
    // !!! Note that once we support dynamic tracking, we MUST CHANGE
    //     THE NAMED PIPE PROCESSING to not do writes/transceives at DPC
    //     level, because the NPFS needs to call SeCreateClientSecurity
    //     on every write when dynamic tracking is selected!
    //

    qualityOfService.Length = sizeof( qualityOfService );
    qualityOfService.ImpersonationLevel =
        SmbGetUlong( &request->ImpersonationLevel );
    qualityOfService.ContextTrackingMode = FALSE;
    //qualityOfService.ContextTrackingMode = (BOOLEAN)
    //    (request->SecurityFlags & SMB_SECURITY_DYNAMIC_TRACKING);
    qualityOfService.EffectiveOnly = (BOOLEAN)
        (request->SecurityFlags & SMB_SECURITY_EFFECTIVE_ONLY);

    status = SrvNtCreateFile(
                 WorkContext,
                 SmbGetUlong( &request->RootDirectoryFid ),
                 SmbGetUlong( &request->DesiredAccess ),
                 allocationSize,
                 SmbGetUlong( &request->FileAttributes ),
                 SmbGetUlong( &request->ShareAccess ),
                 SmbGetUlong( &request->CreateDisposition ),
                 SmbGetUlong( &request->CreateOptions ),
                 (sdLength == 0) ? NULL : securityDescriptorBuffer,
                 &fileName,
                 (eaLength == 0) ? NULL : eaBuffer,
                 eaLength,
                 &eaErrorOffset,
                 SmbGetUlong( &request->Flags ),
                 &qualityOfService,
                 (request->Flags & NT_CREATE_REQUEST_OPBATCH) != 0 ?
                    OplockTypeBatch :
                    (request->Flags & NT_CREATE_REQUEST_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartCreateWithSdOrEa
                 );

    //
    // Free the unicode file name buffer if it has been allocated.
    //

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &fileName );
    }

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        //
        // The open is blocked (waiting for a comm device or an oplock
        // break), do not send a reply.
        //

        //
        // Save the ea error offset
        //

        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        return SmbTransStatusInProgress;

    } else if ( WorkContext->Parameters2.Open.TemporaryOpen ) {

        //
        // The initial open failed due to a sharing violation, possibly
        // caused by an batch oplock.  Requeue the open to a blocking
        // thread.
        //

        WorkContext->FspRestartRoutine = (PRESTART_ROUTINE)ExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        return SmbStatusInProgress;


    } else {

        //
        // Save the ea error offset
        //

        WorkContext->Parameters2.Open.EaErrorOffset = eaErrorOffset;

        //
        // The open has completed.  Generate and send the reply.
        //

        return GenerateCreateWithSdOrEaResponse( WorkContext, status );

    }

} // SrvSmbCreateWithSdOrEa


VOID SRVFASTCALL
RestartCreateWithSdOrEa (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes processing of an Open2 SMB.

Arguments:

    WorkContext - Work context block for the operation.

Return Value:

    None.

--*/

{
    SMB_TRANS_STATUS smbStatus;
    NTSTATUS openStatus;

    PAGED_CODE( );

    openStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if ( NT_SUCCESS( openStatus ) ) {

        openStatus = WorkContext->Irp->IoStatus.Status;

        if( NT_SUCCESS( openStatus ) ) {
            //
            // It's obvious that the file already existed, because we've
            //  been working on an oplock break.  So set the
            //  IoStatus.Information field correctly.
            //
            WorkContext->Irp->IoStatus.Information = FILE_OPENED;
        }

    } else {

        //
        // This open was waiting for an oplock break to occur, but
        // timed out.  Close our handle to this file, then fail the open.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );

    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;
    smbStatus = GenerateCreateWithSdOrEaResponse( WorkContext, openStatus );

    SrvCompleteExecuteTransaction( WorkContext, smbStatus );

    return;

} // RestartCreateWithSdOrEa


SMB_TRANS_STATUS
GenerateCreateWithSdOrEaResponse (
    PWORK_CONTEXT WorkContext,
    NTSTATUS OpenStatus
    )

/*++

Routine Description:

    Generates a response to an Create With SD or EA SMB and setup for furthur
    SMB processing.

Arguments:

    WorkContext - Work context block for the operation.

    OpenStatus - The status of the open operation.

Return Value:

    None.

--*/

{
    PREQ_CREATE_WITH_SD_OR_EA request;
    PRESP_CREATE_WITH_SD_OR_EA response;

    PRFCB rfcb;
    NTSTATUS status;
    SRV_NT_FILE_INFORMATION srvNtFileInformation;
    PTRANSACTION transaction;

    OPLOCK_TYPE oplockType;
    UCHAR oplockLevel;
    BOOLEAN allowLevelII;

    BOOLEAN SendExtendedResponse = FALSE;
    ACCESS_MASK MaximalAccessRights;
    ACCESS_MASK GuestMaximalAccessRights;

    ULONG eaErrorOffset;
    BOOLEAN extendedRequested;

    ULONG CreateAction = (ULONG)WorkContext->Irp->IoStatus.Information;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_CREATE_WITH_SD_OR_EA)transaction->InParameters;
    response = (PRESP_CREATE_WITH_SD_OR_EA)transaction->OutParameters;

    extendedRequested = ((request->Flags & NT_CREATE_REQUEST_EXTENDED_RESPONSE) != 0 );

    rfcb = WorkContext->Rfcb;
    eaErrorOffset = WorkContext->Parameters2.Open.EaErrorOffset;

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS( OpenStatus ) ) {

        SrvSetSmbError2( WorkContext, OpenStatus, TRUE );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {
            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }

        goto err_exit;
    }


    //
    // We always open with at least FILE_READ_ATTRIBUTES, so no
    // access check is needed.
    //

    status = SrvQueryNtInformationFile(
                 rfcb->Lfcb->FileHandle,
                 rfcb->Lfcb->FileObject,
                 rfcb->ShareType,
                 extendedRequested,
                 &srvNtFileInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateCreateWithSdOrEaResponse: "
                       "SrvQueryNtInformationFile failed: %X\n", status ));
        }

        SrvCloseRfcb( rfcb );

        SrvSetSmbError2( WorkContext, status, TRUE );
        goto err_exit;
    }

    //
    // Attempt to acquire the oplock.
    //

    if ( !(request->CreateOptions & FILE_DIRECTORY_FILE) ) {

        if ( request->Flags & NT_CREATE_REQUEST_OPLOCK ) {
            allowLevelII = CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, WorkContext->Connection );
            if ( request->Flags & NT_CREATE_REQUEST_OPBATCH ) {
                oplockType = OplockTypeBatch;
                oplockLevel = SMB_OPLOCK_LEVEL_BATCH;
            } else {
                oplockType = OplockTypeExclusive;
                oplockLevel = SMB_OPLOCK_LEVEL_EXCLUSIVE;
            }
        } else {
            allowLevelII = FALSE;
            oplockType = OplockTypeServerBatch;
            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
        }

        if ( SrvRequestOplock( WorkContext, &oplockType, allowLevelII ) ) {

            //
            // The oplock was granted.  Check to see if it was a level 2.
            //

            if ( oplockType == OplockTypeShareRead ) {
                oplockLevel = SMB_OPLOCK_LEVEL_II;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksGranted );

        } else {

            //
            // The oplock request was denied.
            //

            oplockLevel = SMB_OPLOCK_LEVEL_NONE;
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksDenied );

        }

    } else {

        oplockLevel = SMB_OPLOCK_LEVEL_NONE;

    }

    if ( extendedRequested ) {
        NTSTATUS ExtendedResponseStatus;

        PRESP_EXTENDED_CREATE_WITH_SD_OR_EA ExtendedResponse;

        ExtendedResponse = (PRESP_EXTENDED_CREATE_WITH_SD_OR_EA)response;

        ExtendedResponseStatus = SrvUpdateMaximalAccessRightsInResponse(
                                     WorkContext,
                                     &ExtendedResponse->MaximalAccessRights,
                                     &ExtendedResponse->GuestMaximalAccessRights);

        SendExtendedResponse = (ExtendedResponseStatus == STATUS_SUCCESS);
    }

    //
    // Set up response SMB.
    //

    response->OplockLevel = oplockLevel;

    if (SendExtendedResponse) {
        response->ExtendedResponse = 1;
    } else {
        response->ExtendedResponse = 0;
    }

    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUlong( &response->EaErrorOffset, eaErrorOffset );
    SmbPutUlong( &response->CreateAction, CreateAction );

    SmbPutUshort( &response->FileType, srvNtFileInformation.Type );
    SmbPutUshort( &response->DeviceState, srvNtFileInformation.HandleState );
    SmbPutUlong(
        &response->CreationTime.HighPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.HighPart
        );
    SmbPutUlong(
        &response->CreationTime.LowPart,
        srvNtFileInformation.NwOpenInfo.CreationTime.LowPart
        );
    SmbPutUlong(
        &response->LastAccessTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.HighPart
        );
    SmbPutUlong(
        &response->LastAccessTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastAccessTime.LowPart
        );
    SmbPutUlong(
        &response->LastWriteTime.HighPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.HighPart
        );
    SmbPutUlong(
        &response->LastWriteTime.LowPart,
        srvNtFileInformation.NwOpenInfo.LastWriteTime.LowPart
        );
    SmbPutUlong(
        &response->ChangeTime.HighPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.HighPart
        );
    SmbPutUlong(
        &response->ChangeTime.LowPart,
        srvNtFileInformation.NwOpenInfo.ChangeTime.LowPart
        );

    SmbPutUlong( &response->FileAttributes, srvNtFileInformation.NwOpenInfo.FileAttributes );
    SmbPutUlong(
        &response->AllocationSize.HighPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.HighPart
        );
    SmbPutUlong(
        &response->AllocationSize.LowPart,
        srvNtFileInformation.NwOpenInfo.AllocationSize.LowPart
        );
    SmbPutUlong(
        &response->EndOfFile.HighPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.HighPart
        );
    SmbPutUlong(
        &response->EndOfFile.LowPart,
        srvNtFileInformation.NwOpenInfo.EndOfFile.LowPart
        );

    response->Directory = (srvNtFileInformation.NwOpenInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

    if (SendExtendedResponse) {
        transaction->ParameterCount = sizeof(RESP_EXTENDED_CREATE_WITH_SD_OR_EA);
    } else {
        transaction->ParameterCount = sizeof(RESP_CREATE_WITH_SD_OR_EA);
    }

    transaction->SetupCount = 0;
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbOpen2 complete.\n" ));
    return SmbTransStatusSuccess;

err_exit:

    RtlZeroMemory( (PVOID)response, sizeof(RESP_CREATE_WITH_SD_OR_EA) );
    SmbPutUlong( &response->EaErrorOffset, eaErrorOffset );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(RESP_CREATE_WITH_SD_OR_EA);
    transaction->DataCount = 0;

    return SmbTransStatusErrorWithData;

} // GenerateCreateWithSdOrEaResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreate (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes the Create and Create New SMBs.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_CREATE request;

    UCHAR      command;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_CREATE)WorkContext->RequestParameters;

    command = WorkContext->RequestHeader->Command;

    //
    // Open the file in compatibility mode, obtaining read/write access
    // for this FID.
    //

    status = SrvCreateFile(
                 WorkContext,
                 SMB_DA_SHARE_COMPATIBILITY | SMB_DA_ACCESS_READ_WRITE,
                 SmbGetUshort( &request->FileAttributes ),
                 (USHORT) ( ( command == SMB_COM_CREATE ?
                              SMB_OFUN_OPEN_TRUNCATE : SMB_OFUN_OPEN_FAIL )
                            | SMB_OFUN_CREATE_CREATE ),
                 0,                   // SmbAllocationSize
                 (PCHAR)(request->Buffer + 1),
                 END_OF_REQUEST_SMB( WorkContext ),
                 NULL,
                 0L,
                 NULL,
                 (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                    OplockTypeBatch :
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                        OplockTypeExclusive : OplockTypeServerBatch,
                 RestartSmbCreate
                 );

    if( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {
        //
        // The open is blocked, perhaps because some other client had this
        //  file open and is holding onto the handle with a batch oplock.
        //
        SmbStatus = SmbStatusInProgress;

    } else {
        SmbStatus = GenerateCreateResponse( WorkContext, status );
    }
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
}

VOID SRVFASTCALL
RestartSmbCreate(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Completes processing of a Create SMB.

Arguments:

    WorkContext - A pointer to the work context block for this SMB.

Return Value:

    None.

--*/
{
    SMB_PROCESSOR_RETURN_LOCAL smbStatus = SmbStatusInProgress;
    NTSTATUS createStatus = STATUS_SUCCESS;

    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE;
    SrvWmiStartContext(WorkContext);

    createStatus = SrvCheckOplockWaitState( WorkContext->WaitForOplockBreak );

    if( NT_SUCCESS( createStatus ) ) {
        createStatus = WorkContext->Irp->IoStatus.Status;

    } else {
        //
        // The create was waiting for an oplock break to occur, but
        // timed out. Close our handle to this file, then fail the create.
        //

        SrvCloseRfcb( WorkContext->Parameters2.Open.Rfcb );
    }

    WorkContext->Irp->IoStatus.Information = WorkContext->Parameters2.Open.IosbInformation;

    smbStatus = GenerateCreateResponse( WorkContext, createStatus );

    SrvEndSmbProcessing( WorkContext, smbStatus );
    SrvWmiEndContext(WorkContext);
}

SMB_PROCESSOR_RETURN_TYPE
GenerateCreateResponse(
    PWORK_CONTEXT WorkContext,
    NTSTATUS CreateStatus
    )
/*++

Routine Description:

    Generates a response to a Create SMB

Arguments:

    WorkContext -
    Status - The status of the create operation

Return Value:

    The status of the SMB processing.

--*/
{
    PREQ_CREATE request;
    PRESP_CREATE response;
    PRFCB rfcb;

    PAGED_CODE();

    request = (PREQ_CREATE)WorkContext->RequestParameters;
    response = (PRESP_CREATE)WorkContext->ResponseParameters;

    //
    // If the open failed, send an error response.
    //

    if ( !NT_SUCCESS(CreateStatus) ) {

        SrvSetSmbError( WorkContext, CreateStatus );

        //
        // Remap the error if it is ERROR_ALREADY_EXISTS.  In OS/2
        // ERROR_ALREADY_EXISTS is used for resources like Semaphores.
        // This cannot be passed back to the downlevel client and has
        // to be remapped to ERROR_FILE_EXISTS
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) &&
               SmbGetUshort( &WorkContext->ResponseHeader->Error ) ==
                   ERROR_ALREADY_EXISTS ) {

            SmbPutUshort(
                &WorkContext->ResponseHeader->Error,
                ERROR_FILE_EXISTS
                );
        }
        return SmbStatusSendResponse;
    }

    //
    // Set the time on the file.
    //
    // !!! Should we do anything with the return code?

    rfcb = WorkContext->Rfcb;

    (VOID)SrvSetLastWriteTime(
              rfcb,
              SmbGetUlong( &request->CreationTimeInSeconds ),
              rfcb->Lfcb->GrantedAccess
              );

    //
    // Give the smart card a chance to get into the act
    //
    if( WorkContext->Endpoint->IsConnectionless && SrvIpxSmartCard.Open != NULL ) {

        PVOID handle;

        IF_DEBUG( SIPX ) {
            KdPrint(( "Trying the smart card for %wZ\n", &rfcb->Mfcb->FileName ));
        }

        if( SrvIpxSmartCard.Open(
            WorkContext->RequestBuffer->Buffer,
            rfcb->Lfcb->FileObject,
            &rfcb->Mfcb->FileName,
            &(WorkContext->ClientAddress->IpxAddress.Address[0].Address[0]),
            rfcb->Lfcb->FileObject->Flags & FO_CACHE_SUPPORTED,
            &handle
            ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "%wZ handled by Smart Card.  Handle %p\n",
                           &rfcb->Mfcb->FileName, handle ));
            }

            rfcb->PagedRfcb->IpxSmartCardContext = handle;
        }
    }

    //
    // Set up response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_CREATE,
                                          0
                                          );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbCreate complete.\n" ));
    return SmbStatusSendResponse;

} // SrvSmbCreate


SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateTemporary (
    SMB_PROCESSOR_PARAMETERS
    )
/*++

Routine Description:

    Processes a Create Temporary SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_CREATE_TEMPORARY request;
    PRESP_CREATE_TEMPORARY response;

    PRFCB rfcb;
    NTSTATUS   status    = STATUS_OBJECT_NAME_COLLISION;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    CLONG nameCounter;
    USHORT i;
    PSZ nameStart, ep;
    CHAR name[9];
    LARGE_INTEGER time;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CREATE_TEMPORARY;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Create temporary file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Create temporary file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_CREATE_TEMPORARY)WorkContext->RequestParameters;
    response = (PRESP_CREATE_TEMPORARY)WorkContext->ResponseParameters;

    //
    // Find out where in the buffer the directory pathname ends.  We will
    // write the filename after this.
    //

    ep = END_OF_REQUEST_SMB( WorkContext );

    for( nameStart = (PSZ)request->Buffer; nameStart <= ep && *nameStart; nameStart++ ) {
        ;
    }

    //
    // If we didn't find a NULL, or we don't have room to add in the last part of the
    //  temporary filename, then we give up
    //
    if( nameStart > ep ||
        *nameStart ||
        WorkContext->RequestBuffer->BufferLength - WorkContext->RequestBuffer->DataLength < 9 ) {

        //
        // We did not find a valid pathname!
        //
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // The temporary file will be created with a name like SRVxxxxx, where
    // xxxxx is a hex integer.  We first try to create SRV00000, and if it
    // exists increment xxxxx until xxxxx = 0xFFFFF;
    //
    // !!! We may want to maintain a "last name" counter, to try to
    //     reduce the number of retries we need.  We may also want to
    //     have an explicit bound the number of tries, like 16 or 32, or
    //     293.
    //

    name[0] = 'S';
    name[1] = 'R';
    name[2] = 'V';
    name[8] = '\0';

    // *** for SrvCanonicalizePathName
    WorkContext->RequestBuffer->DataLength += 9;

    // Because of the possibility of security attacks, we limit the number of times we will
    // retry the create.  Thus, we pick a semi-random starting range and try the next
    // MAX_TEMP_OPEN_RETRIES in that range.  The semi-random starting value we pick is the
    // system time in ~.2 second values.  This should give enough variation across calls to
    // prevent a lot of overlap, but sufficiently protect us from DoS attacks
    KeQuerySystemTime( &time );
    time.QuadPart >>= 20;


    for ( nameCounter = 0;
          status == STATUS_OBJECT_NAME_COLLISION &&
                                            nameCounter < MAX_TEMP_OPEN_RETRIES;
          nameCounter++ ) {

        CCHAR j;
        PSZ s;
        CLONG actualNameCounter = nameCounter + time.LowPart;

        name[3] = SrvHexChars[ (actualNameCounter & (CLONG)0xF0000) >> 16 ];
        name[4] = SrvHexChars[ (actualNameCounter & (CLONG)0xF000) >> 12 ];
        name[5] = SrvHexChars[ (actualNameCounter & (CLONG)0xF00) >> 8 ];
        name[6] = SrvHexChars[ (actualNameCounter & (CLONG)0xF0) >> 4 ];
        name[7] = SrvHexChars[ (actualNameCounter & (CLONG)0xF) ];

        // *** We could get rid of this loop and the name[9] variable
        //     if we could put the name directly into the SMB buffer.

        for ( j = 0, s = nameStart; j < 9; j++, s++ ) {
            *s = name[j];
        }

        //
        // Open the file in compatibility mode, obtaining read/write
        // access for this FID.
        //

        status = SrvCreateFile(
                     WorkContext,
                     SMB_DA_SHARE_COMPATIBILITY | SMB_DA_ACCESS_READ_WRITE,
                     0,                   // SmbFileAttributes (normal)
                     SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE,
                     0,                   // SmbAllocationSize
                     (PCHAR)(request->Buffer + 1),
                     END_OF_REQUEST_SMB( WorkContext ),
                     NULL,
                     0L,
                     NULL,
                     (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK_NOTIFY_ANY) != 0 ?
                        OplockTypeBatch :
                        (WorkContext->RequestHeader->Flags & SMB_FLAGS_OPLOCK) != 0 ?
                            OplockTypeExclusive : OplockTypeServerBatch,
                     NULL
                     );

        ASSERT ( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        //
        // If the open failed, send an error response.
        //

        if ( !NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_COLLISION ) {
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    if ( nameCounter == MAX_TEMP_OPEN_RETRIES ) {

        //
        // This is either a DoS attack, or the caller is simply out of luck.  Since
        // we can't tell the difference, we fail with an error.
        //

        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Set up response SMB.
    //

    rfcb = WorkContext->Rfcb;
    rfcb->IsCacheable = FALSE;

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, rfcb->Fid );
    for ( i = 0; i < 9; i++ ) {
        response->Buffer[i] = nameStart[i];
    }
    SmbPutUshort( &response->ByteCount, 9 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_CREATE_TEMPORARY,
                                          9
                                          );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbCreateTemporary complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbCreateTemporary


VOID
SetEofToMatchAllocation (
    IN HANDLE FileHandle,
    IN ULONG AllocationSize
    )

/*++

Routine Description:

    Sets the EOF location for a file to match the size allocated when
    the file was created.  This routine is necessary in order to gain
    compatibility with OS/2, which does not have separate concepts of
    EOF and allocation size.  When the server creates a file for an OS/2
    client, if the allocation size is greater than 0, the server sets
    the EOF to match that size.

    This routine was created to allow the server to pass variations 17
    and 18 of the filio003 test.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/


{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    FILE_END_OF_FILE_INFORMATION newEndOfFile;

    PAGED_CODE( );

    //
    // Don't bother doing this if the allocated size is zero.
    //

    if ( AllocationSize != 0 ) {

        newEndOfFile.EndOfFile.QuadPart = AllocationSize;

        status = NtSetInformationFile(
                    FileHandle,
                    &iosb,
                    &newEndOfFile,
                    sizeof( newEndOfFile ),
                    FileEndOfFileInformation
                    );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SetEofToMatchAllocation: SetInformationFile returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        }

    }

    return;

} // SetEofToMatchAllocation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbprint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smbprint.c

Abstract:

    This module implements printing SMB processors:

        Open Print File
        Close Print File
        Get Print Queue

Author:

    David Treadwell (davidtr) 08-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbprint.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbOpenPrintFile )
#pragma alloc_text( PAGE, SrvSmbGetPrintQueue )
#pragma alloc_text( PAGE, SrvSmbClosePrintFile )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenPrintFile (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Open Print File SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PTREE_CONNECT treeConnect;
    PRESP_OPEN_PRINT_FILE response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_OPEN_PRINT_FILE;
    SrvWmiStartContext(WorkContext);

    //
    // Make sure we are on an LPC thread!
    //
    if( WorkContext->UsingLpcThread == 0 ) {
        status = SrvQueueWorkToLpcThread( WorkContext, TRUE );
        if( !NT_SUCCESS(status) )
        {
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        return SmbStatusInProgress;
    }

    //
    // Verify that this is a print share.
    //
    // *** We are putting in this check because some public domain Samba
    //     smb clients are trying to print through a disk share.
    //

    treeConnect = SrvVerifyTid(
                         WorkContext,
                         SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                         );

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
             KdPrint(( "SrvSmbPrintFile: Invalid TID.\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        status    = STATUS_SMB_BAD_TID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // if it's not a print share, tell the client to get lost.
    //

    if ( treeConnect->Share->ShareType != ShareTypePrint ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_DEVICE_REQUEST );
        status    = STATUS_INVALID_DEVICE_REQUEST;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Call SrvCreateFile to open a print spooler file.  None of the
    // options such as desired access, etc. are relevant for a print
    // open--they are all set to default values by SrvCreateFile.
    //

    status = SrvCreateFile(
                 WorkContext,
                 0,                   // SmbDesiredAccess
                 0,                   // SmbFileAttributes
                 0,                   // SmbOpenFunction
                 0,                   // SmbAllocationSize
                 0,                   // SmbFileName
                 NULL,                // EndOfSmbFileName
                 NULL,                // EaBuffer
                 0,                   // EaLength
                 NULL,                // EaErrorOffset
                 0,                   // RequestedOplockType
                 NULL                 // RestartRoutine
                 );

    //
    // There should never be an oplock on one of these special spooler
    // files.
    //

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Set up the response SMB.
    //

    response = (PRESP_OPEN_PRINT_FILE)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Fid, WorkContext->Rfcb->Fid );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_OPEN_PRINT_FILE,
                                          0
                                          );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbOpenPrintFile


SMB_PROCESSOR_RETURN_TYPE
SrvSmbClosePrintFile (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Close Print File SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_CLOSE_PRINT_FILE request;
    PRESP_CLOSE_PRINT_FILE response;

    PSESSION session;
    PRFCB rfcb;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CLOSE_PRINT_FILE;
    SrvWmiStartContext(WorkContext);

    //
    // Make sure we are on a blocking thread
    //
    if( WorkContext->UsingBlockingThread == 0 ) {
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Close print file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Close print file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_CLOSE_PRINT_FILE)(WorkContext->RequestParameters);
    response = (PRESP_CLOSE_PRINT_FILE)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbClose: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // First, verify the FID.  If verified, the RFCB and the TreeConnect
    // block are referenced and their addresses are stored in the
    // WorkContext block, and the RFCB address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there
    // is a saved write behind error for this rfcb.  The rfcb is
    // needed in order to process the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                FALSE,
                SrvRestartSmbReceived,  // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbClose: Invalid FID: 0x%lx\n",
                            SmbGetUshort( &request->Fid ) ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            status    = STATUS_INVALID_HANDLE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        //
        // Check the saved error.
        //

        (VOID)SrvCheckForSavedError( WorkContext, rfcb );
    }

    //
    // Now proceed to do the actual close file, even if there was
    // a write behind error.
    //

    SrvCloseRfcb( rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( rfcb );
    WorkContext->Rfcb = NULL;

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_CLOSE_PRINT_FILE,
                                        0
                                        );

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbClosePrintFile


SMB_PROCESSOR_RETURN_TYPE
SrvSmbGetPrintQueue (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Get Print Queue SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PAGED_CODE( );
    return SrvSmbNotImplemented( SMB_PROCESSOR_ARGUMENTS );

} // SrvSmbGetPrintQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbmpx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    smbmpx.c

Abstract:

    This module contains routines for processing the following SMBs:

        Read Block Multiplexed
        Write Block Multiplexed

    Note that core and raw mode SMB processors are not contained in this
    module.  Check smbrdwrt.c and smbraw.c instead.  SMB commands that
    pertain exclusively to locking (LockByteRange, UnlockByteRange, and
    LockingAndX) are processed in smblock.c.

Author:

    Chuck Lenzmeier (chuckl) 4-Nov-1993

Revision History:

--*/

#include "precomp.h"
#include "smbmpx.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBMPX

#if 0
BOOLEAN MpxDelay = TRUE;
#endif

//
// Stack overflow threshold.  This is used to determine when we are
// getting close to the end of our stack and need to stop recursing
// in SendCopy/MdlReadMpxFragment.
//

#define STACK_THRESHOLD 0xE00

//
// Forward declarations
//

VOID SRVFASTCALL
RestartReadMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
SendCopyReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SendCopyReadMpxFragment2 (
    IN OUT PWORK_CONTEXT
    );

NTSTATUS
SendMdlReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SendMdlReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMdlReadMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
CheckForWriteMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartPrepareMpxMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
AddPacketToGlom (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartAfterGlomDelay (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartCompleteGlommingInIndication(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteMpxCompleteRfcbClose (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
WriteMpxMdlWriteComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbReadMpx )
#pragma alloc_text( PAGE, RestartMdlReadMpxComplete )
#pragma alloc_text( PAGE, SrvRestartReceiveWriteMpx )
#pragma alloc_text( PAGE, SrvSmbWriteMpxSecondary )
#pragma alloc_text( PAGE, SendCopyReadMpxFragment2 )
#pragma alloc_text( PAGE, SendMdlReadMpxFragment2 )
#pragma alloc_text( PAGE8FIL, RestartReadMpx )
#pragma alloc_text( PAGE8FIL, SendCopyReadMpxFragment )
#pragma alloc_text( PAGE8FIL, RestartCopyReadMpxComplete )
#pragma alloc_text( PAGE8FIL, SendMdlReadMpxFragment )
#endif
#if 0
NOT PAGEABLE -- SrvSmbWriteMpx
NOT PAGEABLE -- RestartWriteMpx
NOT PAGEABLE -- CheckForWriteMpxComplete
NOT PAGEABLE -- RestartCompleteGlommingInIndication
NOT PAGEABLE -- RestartWriteMpxCompleteRfcbClose
NOT PAGEABLE -- WriteMpxMdlWriteComplete
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    );
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadMpx (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read Mpx SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_READ_MPX request;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    ULONG bufferOffset;
    PCHAR readAddress;
    CLONG readLength;
    ULONG key;
    LARGE_INTEGER offset;
    PMDL mdl;
    PVOID mpxBuffer;
    UCHAR minorFunction;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_MPX;
    SrvWmiStartContext(WorkContext);

    header = WorkContext->RequestHeader;
    request = (PREQ_READ_MPX)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "Read Block Multiplexed request; FID 0x%lx, "
                    "count %ld, offset %ld\n",
                    fid, SmbGetUshort( &request->MaxCount ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB address
    // is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status )) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbReadMpx: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;

    if( lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if( rfcb->MpxReadsOk == FALSE ) {

        if ( !rfcb->ReadAccessGranted ) {
            CHECK_PAGING_IO_ACCESS(
                            WorkContext,
                            rfcb->GrantedAccess,
                            &status );
            if ( !NT_SUCCESS( status ) ) {
                SrvStatistics.GrantedAccessErrors++;
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadMpx: Read access not granted.\n"));
                }
                SrvSetSmbError( WorkContext, status );
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
        }

        //
        // If this is not a disk file, tell the client to use core read.
        //

        if ( rfcb->ShareType != ShareTypeDisk ) {
            SrvSetSmbError( WorkContext, STATUS_SMB_USE_STANDARD );
            status    = STATUS_SMB_USE_STANDARD;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        rfcb->MpxReadsOk = TRUE;
    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | SmbGetAlignedUshort( &header->Pid );

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvSmbReadMpx: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvSmbReadMpx:  SmartCard Read returns TRUE\n" ));
            }

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvSmbReadMpx:  SmartCard Read returns FALSE\n" ));
        }
    }

    //
    // Get the file offset.
    //

    WorkContext->Parameters.ReadMpx.Offset = SmbGetUlong( &request->Offset );
    offset.QuadPart = WorkContext->Parameters.ReadMpx.Offset;

    //
    // Calculate the address in the buffer at which to put the data.
    // This must be rounded up to a dword boundary.  (The -1 below is
    // because sizeof(RESP_READ_MPX) includes one byte of Buffer.)
    //

    bufferOffset = (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer) + 3) & ~3;

    //
    // Calculate how much data we can send back in each fragment.  This
    // is the size of the client's buffer, rounded down to a dword multiple.
    //
    // *** Because we use the SMB buffer's partial MDL to describe the
    //     data fragments that we return, we need to limit the fragment
    //     size to the SMB buffer size.  Normally the client's buffer
    //     size is <= ours, so this shouldn't be a factor.
    //

    WorkContext->Parameters.ReadMpx.FragmentSize =
        (USHORT)((MIN( lfcb->Session->MaxBufferSize,
                       SrvReceiveBufferLength ) - bufferOffset) & ~3);

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    readLength = SmbGetUshort( &request->MaxCount );

    if ( //0 &&
         (readLength <= SrvMpxMdlReadSwitchover) ) {

do_copy_read:

        WorkContext->Parameters.ReadMpx.MdlRead = FALSE;
        WorkContext->Parameters.ReadMpx.MpxBuffer = NULL;
        WorkContext->Parameters.ReadMpx.MpxBufferMdl =
                                        WorkContext->ResponseBuffer->Mdl;

        readAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;
        WorkContext->Parameters.ReadMpx.NextFragmentAddress = readAddress;

        //
        // Try the fast I/O path first.
        //

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readAddress,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Send the data.
                    //

                    WorkContext->bAlreadyTrace = TRUE;
                    RestartReadMpx( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            readAddress,
            readLength
            );
        mdl = WorkContext->ResponseBuffer->PartialMdl;
        minorFunction = 0;

    } else {

        //
        // The SMB buffer isn't big enough.  Does the target file system
        // support the cache manager routines?
        //

        if ( //0 &&
             (lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

            WorkContext->Parameters.ReadMpx.MdlRead = TRUE;

            //
            // We can use an MDL read.  Try the fast I/O path first.
            //

            WorkContext->Irp->MdlAddress = NULL;
            WorkContext->Irp->IoStatus.Information = 0;
            WorkContext->Parameters.ReadMpx.ReadLength = readLength;

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            if ( lfcb->MdlRead &&
                 lfcb->MdlRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    key,
                    &WorkContext->Irp->MdlAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) && WorkContext->Irp->MdlAddress != NULL ) {

                //
                // The fast I/O path worked.  Send the data.
                //

                WorkContext->bAlreadyTrace = TRUE;
                RestartReadMpx( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            //
            // The fast I/O path failed.  We need to issue a regular MDL
            // read request.
            //
            // The fast path may have partially succeeded, returning a
            // partial MDL chain.  We need to adjust our read request
            // to account for that.
            //

            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

            mdl = WorkContext->Irp->MdlAddress;
            minorFunction = IRP_MN_MDL;
            readAddress = NULL;     // Not used for MDL read

        } else if (readLength > (WorkContext->ResponseBuffer->BufferLength -
                    bufferOffset)) {

            //
            // We have to use a normal "copy" read.  We need to allocate
            // a separate buffer.
            //

            WorkContext->Parameters.ReadMpx.MdlRead = FALSE;

            mpxBuffer = ALLOCATE_NONPAGED_POOL(
                            readLength,
                            BlockTypeDataBuffer
                            );
            if ( mpxBuffer == NULL ) {
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
            WorkContext->Parameters.ReadMpx.MpxBuffer = mpxBuffer;
            WorkContext->Parameters.ReadMpx.NextFragmentAddress = mpxBuffer;
            readAddress = mpxBuffer;

            //
            // We also need an MDL to describe the buffer.
            //

            mdl = IoAllocateMdl( mpxBuffer, readLength, FALSE, FALSE, NULL );
            if ( mdl == NULL ) {
                DEALLOCATE_NONPAGED_POOL( mpxBuffer );
                SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                status    = STATUS_INSUFF_SERVER_RESOURCES;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            WorkContext->Parameters.ReadMpx.MpxBufferMdl = mdl;

            //
            // Build the mdl.
            //

            MmBuildMdlForNonPagedPool( mdl );

            //
            // Try the fast I/O path first.
            //

            if ( lfcb->FastIoRead != NULL ) {

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

                try {
                    if ( lfcb->FastIoRead(
                            lfcb->FileObject,
                            &offset,
                            readLength,
                            TRUE,
                            key,
                            mpxBuffer,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            ) ) {

                        //
                        // The fast I/O path worked.  Send the data.
                        //

                        WorkContext->bAlreadyTrace = TRUE;
                        RestartReadMpx( WorkContext );
                        SmbStatus = SmbStatusInProgress;
                        goto Cleanup;
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    status = GetExceptionCode();
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            }

            //
            // The fast I/O path failed, so we need to use a regular copy
            // I/O request.
            //

            minorFunction = 0;

        } else {

            goto do_copy_read;
        }

    } // read fits in SMB buffer?

    //
    // Build the read request, reusing the receive IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_READ,                    // major function code
            minorFunction,                  // minor function code
            readAddress,                    // buffer address
            readLength,                     // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = RestartReadMpx;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbReadMpx


VOID SRVFASTCALL
RestartReadMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a Read MPX SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;

    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    USHORT readLength;
    ULONG offset;
    PMDL mdl;
    BOOLEAN mdlRead;
    PIRP irp = WorkContext->Irp;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) KdPrint(( " - RestartReadMpx\n" ));

    //
    // If we just completed an MDL read, we need to remember the address
    // of the first MDL in the returned chain, so that we can give it
    // back to the cache manager when we're done.
    //

    mdlRead = WorkContext->Parameters.ReadMpx.MdlRead;
    if ( mdlRead ) {
        mdl = irp->MdlAddress;
        //KdPrint(( "Read MDL chain:\n" ));
        //DumpMdlChain( mdl );
        WorkContext->Parameters.ReadMpx.FirstMdl = mdl;
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) && (status != STATUS_END_OF_FILE) ) {

        IF_DEBUG(ERRORS) KdPrint(( "Read failed: %X\n", status ));
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = RestartReadMpx;
            SrvQueueWorkToFsp( WorkContext );
            goto Cleanup;
        }

        SrvSetSmbError( WorkContext, status );
respond:
        if ( mdlRead ) {
            SrvFsdSendResponse2( WorkContext, RestartMdlReadMpxComplete );
        } else {
            WorkContext->ResponseBuffer->DataLength =
                (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );
            WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
            SRV_START_SEND_2(
                        WorkContext,
                        RestartCopyReadMpxComplete,
                        NULL,
                        NULL );
        }
        goto Cleanup;
    }

    //
    // Get the amount of data actually read.
    //

    if ( status == STATUS_END_OF_FILE ) {

        //
        // The read started beyond the end of the file.
        //

        readLength = 0;

    } else if ( mdlRead ) {

        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple steps, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was
        // satisfied using an IRP.
        //

        readLength = 0;
        while ( mdl != NULL ) {
            readLength += (USHORT)MmGetMdlByteCount(mdl);
            mdl = mdl->Next;
        }

    } else {

        //
        // Copy read.  The I/O status block has the length.
        //

        readLength = (USHORT)irp->IoStatus.Information;

    }

    //
    // Update the file position.
    //

    offset = WorkContext->Parameters.ReadMpx.Offset;

    WorkContext->Rfcb->CurrentPosition =  offset + readLength;

    //
    // Update statistics.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Special-case 0 bytes read.
    //

    response = (PRESP_READ_MPX)WorkContext->ResponseParameters;
    response->WordCount = 8;
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );

    if ( readLength == 0 ) {

        SmbPutUlong( &response->Offset, offset );
        SmbPutUshort( &response->Count, 0 );
        SmbPutUshort( &response->Remaining, 0 );
        SmbPutUshort( &response->DataLength, 0 );
        SmbPutUshort( &response->DataOffset, 0 );
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_READ_MPX,
                                            0
                                            );
        goto respond;
    }

    //
    // Build the static response header/parameters.
    //

    SmbPutUshort( &response->Count, readLength );
    SmbPutUshort(
        &response->DataOffset,
        (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer) + 3) & ~3
        );

    //
    // We will use two MDLs to describe the packet we're sending -- one
    // for the header and parameters, and another for the data.  So we
    // set the "response length" to not include the data.  This is what
    // SrvStartSend uses to set the first MDL's length.
    //
    // Handling of the second MDL varies depending on whether we did a
    // copy read or an MDL read.
    //

    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer)) & 3) == 3 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ_MPX,
                                        1 // pad byte
                                        );
    WorkContext->ResponseBuffer->Mdl->ByteCount =
                    (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Start sending fragments.
    //

    WorkContext->Parameters.ReadMpx.RemainingLength = readLength;
    ASSERT( WorkContext->ResponseBuffer->Mdl->Next == NULL );
    WorkContext->ResponseBuffer->Mdl->Next =
                                WorkContext->ResponseBuffer->PartialMdl;
    WorkContext->ResponseBuffer->PartialMdl->Next = NULL;

    if ( mdlRead ) {

        WorkContext->Parameters.ReadMpx.CurrentMdl =
                            WorkContext->Parameters.ReadMpx.FirstMdl;
        WorkContext->Parameters.ReadMpx.CurrentMdlOffset = 0;
        (VOID)SendMdlReadMpxFragment( NULL, irp, WorkContext );

    } else {

        (VOID)SendCopyReadMpxFragment( NULL, irp, WorkContext );
    }

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartReadMpx

VOID SRVFASTCALL
SendCopyReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Stub to call actual routine.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    (VOID) SendCopyReadMpxFragment( NULL, WorkContext->Irp, WorkContext );

} // SendCopyReadMpxFragment2

NTSTATUS
SendCopyReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sends a Read Mpx response fragment when copy read was used.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;

    USHORT fragmentSize;
    USHORT remainingLength;
    ULONG offset;
    PCHAR fragmentAddress;

    PIO_COMPLETION_ROUTINE sendCompletionRoutine;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Turn off cancel boolean
    //

    Irp->Cancel = FALSE;

    //
    // Get context.
    //

    fragmentSize = WorkContext->Parameters.ReadMpx.FragmentSize;
    remainingLength = WorkContext->Parameters.ReadMpx.RemainingLength;
    offset = WorkContext->Parameters.ReadMpx.Offset;
    fragmentAddress = WorkContext->Parameters.ReadMpx.NextFragmentAddress;

    //
    // If the amount left to send is less than the fragment size, only
    // send the remaining amount.  Update the remaining amount.
    //

    if ( remainingLength < fragmentSize ) {
        fragmentSize = remainingLength;
    }
    ASSERT( fragmentSize != 0 );
    remainingLength -= fragmentSize;

    //
    // Build the response parameters.
    //

    response = (PRESP_READ_MPX)(WorkContext->ResponseHeader + 1);
    SmbPutUshort( &response->Remaining, remainingLength );
    SmbPutUlong( &response->Offset, offset );
    SmbPutUshort( &response->DataLength, fragmentSize );
    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX, Buffer)) & 3) == 3 );
    SmbPutUshort( &response->ByteCount, fragmentSize + 1 ); // account for padding

    //
    // Build a partial MDL describing the data.
    //

    IoBuildPartialMdl(
        WorkContext->Parameters.ReadMpx.MpxBufferMdl,
        WorkContext->ResponseBuffer->PartialMdl,
        fragmentAddress,
        fragmentSize
        );

    //
    // Final preparation for the send depends on whether this is the
    // last fragment.
    //

    if ( remainingLength != 0 ) {

        //
        // Not done.  Update context.  Set up to restart after the send
        // in this routine.  We want do this as an FSD restart routine.
        // But this may recurse, if the send doesn't pend, so we may use
        // up the stack.  If we are running out of stack, restart here
        // in the FSP.
        //

        WorkContext->Parameters.ReadMpx.RemainingLength = remainingLength;
        WorkContext->Parameters.ReadMpx.Offset += fragmentSize;
        WorkContext->Parameters.ReadMpx.NextFragmentAddress += fragmentSize;

        if ( IoGetRemainingStackSize() >= STACK_THRESHOLD ) {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            sendCompletionRoutine = SendCopyReadMpxFragment;
        } else {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            WorkContext->FspRestartRoutine = SendCopyReadMpxFragment2;
            sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
        }

    } else {

        //
        // This is the last fragment.  Restart in the cleanup routine.
        //

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        DEBUG WorkContext->FspRestartRoutine = NULL;
        sendCompletionRoutine = RestartCopyReadMpxComplete;
    }

    //
    // Send the fragment.
    //

    WorkContext->ResponseBuffer->DataLength =  // +1 for pad
        sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1 + fragmentSize;

    if ( WorkContext->Endpoint->IsConnectionless ) {
        SrvIpxStartSend( WorkContext, sendCompletionRoutine );
    } else {
        SrvStartSend2( WorkContext, sendCompletionRoutine );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SendCopyReadMpxFragment

VOID SRVFASTCALL
SendMdlReadMpxFragment2 (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Stub to call actual routine.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    (VOID) SendMdlReadMpxFragment( NULL, WorkContext->Irp, WorkContext );

} // SendMdlReadMpxFragment2

NTSTATUS
SendMdlReadMpxFragment (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sends a Read Mpx response fragment when MDL read was used.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_MPX response;
    PIO_COMPLETION_ROUTINE sendCompletionRoutine;

    USHORT fragmentSize;
    USHORT remainingLength;
    ULONG offset;
    PCHAR fragmentAddress;
    PMDL mdl;
    ULONG mdlOffset;
    ULONG partialLength;
    ULONG lengthNeeded;
    PCHAR startVa;
    PCHAR systemVa;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Turn off cancel boolean
    //

    Irp->Cancel = FALSE;

    //
    // Get context.
    //

    fragmentSize = WorkContext->Parameters.ReadMpx.FragmentSize,
    remainingLength = WorkContext->Parameters.ReadMpx.RemainingLength;
    offset = WorkContext->Parameters.ReadMpx.Offset;

    //
    // If the amount left to send is less than the fragment size, only
    // send the remaining amount.  Update the remaining amount.
    //

    if ( remainingLength < fragmentSize ) {
        fragmentSize = remainingLength;
    }
    ASSERT( fragmentSize != 0 );
    remainingLength -= fragmentSize;

    //
    // Build the response parameters.
    //

    response = (PRESP_READ_MPX)(WorkContext->ResponseHeader + 1);
    SmbPutUshort( &response->Remaining, remainingLength );
    SmbPutUlong( &response->Offset, offset );
    SmbPutUshort( &response->DataLength, fragmentSize );
    ASSERT( ((sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer)) & 3) == 3 );
    SmbPutUshort( &response->ByteCount, fragmentSize + 1 ); // account for padding

    //
    // If the current MDL doesn't describe all of the data we need to
    // send, we need to play some games.
    //

    MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );

    mdl = WorkContext->Parameters.ReadMpx.CurrentMdl;
    startVa = MmGetMdlVirtualAddress( mdl );
    mdlOffset = WorkContext->Parameters.ReadMpx.CurrentMdlOffset;
    partialLength = MmGetMdlByteCount(mdl) - mdlOffset;

    if ( partialLength >= fragmentSize ) {

        //
        // The current MDL has all of the data we need to send.  Build
        // a partial MDL describing that data.
        //

        IoBuildPartialMdl(
            mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            startVa + mdlOffset,
            fragmentSize
            );

        //
        // Indicate how much data we're taking out of the current MDL.
        //

        partialLength = fragmentSize;

    } else {

        //
        // The data we need is spread across more than one MDL.  Painful
        // as this seems, we need to copy the data into the standard
        // response buffer.  It's possible that we could play some games
        // with the MDLs and avoid the copy, but it doesn't seem worth it.
        // There is, after all, additional cost in the NDIS driver for
        // chaining MDLs together.
        //
        // *** Note that we still send a second MDL, even though the data
        //     for this send will abut the response parameters.
        //
        // Calculate the address of the buffer.  Build a partial MDL
        // describing it.
        //

        fragmentAddress = (PCHAR)WorkContext->ResponseBuffer->Buffer +
                            sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1;

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            fragmentAddress,
            fragmentSize
            );
        ASSERT( WorkContext->ResponseBuffer->PartialMdl->Next == NULL );

        //
        // Copy from the current MDL into the buffer.
        //

        systemVa = MmGetSystemAddressForMdl( mdl );
        RtlCopyMemory( fragmentAddress, systemVa + mdlOffset, partialLength );

        //
        // Update the destination address and set the remaining copy
        // amount.
        //

        fragmentAddress += partialLength;
        lengthNeeded = fragmentSize - partialLength;
        ASSERT( lengthNeeded != 0 );

        do {

            //
            // Move to the next MDL.
            //

            mdl = mdl->Next;
            ASSERT( mdl != NULL );

            //
            // Calculate how much we can (and need to) copy out of this
            // MDL, and do the copy.
            //

            startVa = MmGetMdlVirtualAddress( mdl );
            partialLength = MIN( MmGetMdlByteCount(mdl), lengthNeeded );
            systemVa = MmGetSystemAddressForMdl( mdl );
            RtlCopyMemory( fragmentAddress, systemVa, partialLength );

            //
            // Update the destination address and the remaining copy
            // amount.  We may be done.
            //

            fragmentAddress += partialLength;
            lengthNeeded -= partialLength;

        } while ( lengthNeeded != 0 );

        //
        // We just copied from the beginning of the current MDL.
        //

        mdlOffset = 0;

    }

    //
    // Final preparation for the send depends on whether this is the
    // last fragment.
    //

    if ( remainingLength != 0 ) {

        //
        // Not done.  Update the current MDL position.  If we have
        // finished off the current MDL, move to the next one.
        //

        mdlOffset += partialLength;
        if ( mdlOffset >= MmGetMdlByteCount(mdl) ) {
            mdl = mdl->Next;
            ASSERT( mdl != NULL );
            mdlOffset = 0;
        }

        //
        // Update context.  Set up to restart after the send in this
        // routine.  We want do this as an FSD restart routine.  But
        // this may recurse, if the send doesn't pend, so we may use up
        // the stack.  If we are running out of stack, restart here in
        // the FSP.
        //

        WorkContext->Parameters.ReadMpx.CurrentMdl = mdl;
        WorkContext->Parameters.ReadMpx.CurrentMdlOffset = (USHORT)mdlOffset;
        WorkContext->Parameters.ReadMpx.RemainingLength = remainingLength;
        WorkContext->Parameters.ReadMpx.Offset += fragmentSize;

        if ( IoGetRemainingStackSize() >= STACK_THRESHOLD ) {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            sendCompletionRoutine = SendMdlReadMpxFragment;
        } else {
            DEBUG WorkContext->FsdRestartRoutine = NULL;
            WorkContext->FspRestartRoutine = SendMdlReadMpxFragment2;
            sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
        }

    } else {

        //
        // This is the last fragment.  Restart in the cleanup routine.
        //

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        WorkContext->FspRestartRoutine = RestartMdlReadMpxComplete;
        sendCompletionRoutine = SrvQueueWorkToFspAtSendCompletion;
    }

    //
    // Send the fragment.
    //

    WorkContext->ResponseBuffer->DataLength =  // +1 for pad
        sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_MPX,Buffer) + 1 + fragmentSize;

    if ( WorkContext->Endpoint->IsConnectionless ) {
        SrvIpxStartSend( WorkContext, sendCompletionRoutine );
    } else {
        SrvStartSend2( WorkContext, sendCompletionRoutine );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SendMdlReadMpxFragment


NTSTATUS
RestartCopyReadMpxComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the final completion routine for Read Mpx when copy read is
    used.  It is called after the send of the last fragment completes.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    KIRQL oldIrql;
    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    ASSERT( !WorkContext->Parameters.ReadMpx.MdlRead );

    //
    // If we allocated a separate buffer to do the read, free it and its
    // MDL now.
    //

    if ( WorkContext->Parameters.ReadMpx.MpxBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL( WorkContext->Parameters.ReadMpx.MpxBuffer );
        IoFreeMdl( WorkContext->Parameters.ReadMpx.MpxBufferMdl );
    }

    WorkContext->ResponseBuffer->Mdl->Next = NULL;

    //
    // Complete and requeue the work item.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    SrvFsdRestartSmbComplete( WorkContext );
    KeLowerIrql( oldIrql );

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartCopyReadMpxComplete


VOID SRVFASTCALL
RestartMdlReadMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the final completion routine for Read Mpx when MDL read is
    used.  It is called after the send of the last fragment completes.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    LARGE_INTEGER offset;

    PAGED_CODE( );

    ASSERT( WorkContext->Parameters.ReadMpx.MdlRead );

    //
    // Give the MDL back to the cache manager.  (If the read failed or
    // returned no data, there will be no MDL.)
    //

    MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );

    if ( WorkContext->Parameters.ReadMpx.FirstMdl != NULL ) {
        //KdPrint(( "Freeing MDL chain:\n" ));
        //DumpMdlChain( WorkContext->Parameters.ReadMpx.FirstMdl );

        if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

            WorkContext->Rfcb->Lfcb->MdlReadComplete(
                WorkContext->Rfcb->Lfcb->FileObject,
                WorkContext->Parameters.ReadMpx.FirstMdl,
                WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

            offset.QuadPart = WorkContext->Parameters.ReadMpx.Offset;

            //
            // Fast path didn't work, try an IRP...
            //
            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 WorkContext->Parameters.ReadMpx.FirstMdl,
                                                 IRP_MJ_READ,
                                                 &offset,
                                                 WorkContext->Parameters.ReadMpx.ReadLength
                                               );
            if( !NT_SUCCESS( status ) ) {
                //
                // All we can do is complain now!
                //
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }

        }
    }

    WorkContext->ResponseBuffer->Mdl->Next = NULL;

    //
    // Free the work item by dereferencing it.
    //

    SrvDereferenceWorkItem( WorkContext );
    return;

} // RestartMdlReadMpxComplete

VOID SRVFASTCALL
SrvRestartReceiveWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine replaces the normal restart routine for TDI Receive
    completion when a Write Mpx SMB is received over IPX.  If a receive
    error occurs, or if the SMB is invalid, it cleans up the active
    write mpx state that was set up in SrvIpxServerDatagramHandler.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    SMB_STATUS smbStatus;
    PCONNECTION connection;
    PIRP irp;
    PSMB_HEADER header;
    ULONG length;

    PAGED_CODE( );

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    //
    // Save the length of the received message.  Store the length
    // in the work context block for statistics gathering.
    //

    length = (ULONG)irp->IoStatus.Information;
    WorkContext->RequestBuffer->DataLength = length;
    WorkContext->CurrentWorkQueue->stats.BytesReceived += length;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;

    //
    // Update the server network error count.  If the TDI receive
    // failed or was canceled, don't try to process an SMB.
    //

    status = irp->IoStatus.Status;
    if ( irp->Cancel || !NT_SUCCESS(status) ) {
        IF_DEBUG(NETWORK_ERRORS) {
            KdPrint(( "SrvRestartReceiveWriteMpx: status = %X for IRP %p\n",
                irp->IoStatus.Status, irp ));
        }
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
        if ( NT_SUCCESS(status) ) status = STATUS_CANCELLED;
        goto cleanup;
    }

    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // Initialize the error class and code fields in the header to
    // indicate success.
    //

    header = WorkContext->ResponseHeader;

    SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

    //
    // If the connection is closing or the server is shutting down,
    // ignore this SMB.
    //

    if ( (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         SrvFspTransitioning ) {
        goto cleanup;
    }

    //
    // Verify the SMB to make sure that it has a valid header, and that
    // the word count and byte count are within range.
    //

    WorkContext->NextCommand = header->Command;

    if ( !SrvValidateSmb( WorkContext ) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvRestartReceiveWriteMpx: Invalid SMB.\n" ));
            KdPrint(( "  SMB received from %z\n",
                       (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));
        }

        //
        // The SMB is invalid.  We send back an INVALID_SMB status.
        //

        status = STATUS_INVALID_SMB;
        goto cleanup;
    }

    //
    // Clear the flag that indicates the we just sent an oplock break II
    // to none.  This allows subsequent raw reads to be processed.
    //

    //not needed on IPX//connection->BreakIIToNoneJustSent = FALSE;

    //
    // Process the received SMB.  The called routine is responsible
    // for sending any response(s) that are needed and for getting
    // the receive buffer back onto the receive queue as soon as
    // possible.
    //

    smbStatus = SrvSmbWriteMpx( WorkContext );
    ASSERT( smbStatus != SmbStatusMoreCommands );

    if ( smbStatus != SmbStatusInProgress ) {
        //
        // Return the TransportContext
        //
        if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
            TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
        }
        SrvEndSmbProcessing( WorkContext, smbStatus );
    }

    return;

cleanup:

    //
    // We will not be processing this write.  We still need to check
    // for whether this is the last Write Mpx active on the RFCB, and
    // if so, send the response to the write.
    //
    // *** Note that if we are here because we received an invalid
    //     SMB, the completion of the Write Mpx overrides the sending
    //     of an error response.
    //

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    if ( CheckForWriteMpxComplete( WorkContext ) ) {
        SrvFsdSendResponse( WorkContext );
    } else if ( status == STATUS_INVALID_SMB ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvFsdSendResponse( WorkContext );
    } else {
        SrvDereferenceWorkItem( WorkContext );
    }

    return;

} // SrvRestartReceiveWriteMpx


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpx (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Mpx SMB.

    *** The server currently does not support multiplexed mode reads and
        writes on connection-based transports.  When such requests are
        received, the error "use standard mode" is returned.
        Multiplexed mode turns out not to be the performance win it was
        thought to be (on local nets), so we haven't implemented it,
        except over IPX.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    USHORT mid;
    PRFCB rfcb;
    PLFCB lfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG key;
    LARGE_INTEGER offset;
    USHORT writeMode;
    BOOLEAN writeThrough;
    KIRQL oldIrql;
    PMDL mdl;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
    SrvWmiStartContext(WorkContext);

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "Write Block Multipliexed request; FID 0x%lx, "
                    "count %ld, offset %ld\n",
                    fid, SmbGetUshort( &request->Count ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    writeMode = SmbGetUshort( &request->WriteMode );

    if( (writeMode & SMB_WMODE_DATAGRAM) == 0 ||
        !WorkContext->Endpoint->IsConnectionless ) {

        SrvFsdBuildWriteCompleteResponse( WorkContext, STATUS_SMB_USE_STANDARD, 0 );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteMpx: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            goto error;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvFsdBuildWriteCompleteResponse( WorkContext, status, 0 );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if( !rfcb->MpxWritesOk ) {

        if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbWriteMpx: Write access not granted.\n"));
            }
            status = STATUS_ACCESS_DENIED;
            goto error;
        }

        //
        // If this is not a disk or a print file tell the client to use core write.
        //

        if ( rfcb->ShareType != ShareTypeDisk &&
              rfcb->ShareType != ShareTypePrint ) {

            status = STATUS_SMB_USE_STANDARD;
            goto error;
        }

        rfcb->MpxWritesOk = TRUE;
    }

    rfcb->WrittenTo = TRUE;

    //
    // If this a stale packet, ignore it.  Stale here means that the MID
    // of the packet is not equal to the MID of the current write mux.
    // Such a packet can be received if a duplicate packet from a
    // previous write mux is delivered after a new write mux starts.
    //

    writeMpx = &rfcb->WriteMpx;

    mid = SmbGetAlignedUshort( &header->Mid );

    if ( mid != writeMpx->Mid ) {

        //
        // Set the sequence number to 0 so that we don't send a response
        // unless we have to because the Write Mpx refcount drops to 0.
        //

        SmbPutAlignedUshort( &header->SequenceNumber, 0 );
        goto error;
    }

    //
    // Get the file offset.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    //
    // If we have the transport context, then setup WriteAddress accordingly.
    //

    WorkContext->Parameters.WriteMpx.DataMdl = NULL;

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

        writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer + bufferOffset;

    } else {

        writeAddress = (PCHAR)header + bufferOffset;

    }

    writeLength =
        (USHORT)(MIN( (CLONG)SmbGetUshort( &request->DataLength ),
                      WorkContext->ResponseBuffer->DataLength - bufferOffset ));

    //
    // Save context for the restart routine.
    //

    WorkContext->Parameters.WriteMpx.WriteLength = writeLength;

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | SmbGetAlignedUshort( &header->Pid );

    //
    // If this is the first packet of a new MID, set up to glom the
    // packets into one big write.
    //

    lfcb = rfcb->Lfcb;

    if ( WorkContext->Parameters.WriteMpx.FirstPacketOfGlom ) {

        //
        // Try the fast path first.
        //

        WorkContext->Irp->MdlAddress = NULL;
        WorkContext->Irp->IoStatus.Information = 0;

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        ASSERT( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED );

        writeLength = SmbGetUshort( &request->Count );

        writeMpx->StartOffset = offset.LowPart;
        writeMpx->Length = writeLength;

        if ( lfcb->PrepareMdlWrite &&
             lfcb->PrepareMdlWrite(
                lfcb->FileObject,
                &offset,
                writeLength,
                key,
                &WorkContext->Irp->MdlAddress,
                &WorkContext->Irp->IoStatus,
                lfcb->DeviceObject
                ) && WorkContext->Irp->MdlAddress != NULL ) {

            //
            // The fast I/O path worked.
            //

            WorkContext->bAlreadyTrace = TRUE;
            RestartPrepareMpxMdlWrite( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

        //
        // The fast I/O path failed.  Build the write request, reusing the
        // receive IRP.
        //
        // The fast path may have partially succeeded, returning a partial
        // MDL chain.  We need to adjust our write request to account for
        // that.
        //

        offset.QuadPart += WorkContext->Irp->IoStatus.Information;

        writeLength -= (USHORT)WorkContext->Irp->IoStatus.Information;

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,                   // input IRP address
                lfcb->FileObject,                   // target file object address
                WorkContext,                        // context
                IRP_MJ_WRITE,                       // major function code
                IRP_MN_MDL,                         // minor function code
                NULL,                               // buffer address (ignored)
                writeLength,                        // buffer length
                WorkContext->Irp->MdlAddress,       // MDL address
                offset,                             // byte offset
                key                                 // lock key
                );

        //
        // Pass the request to the file system.
        //

            WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = RestartPrepareMpxMdlWrite;
        DEBUG WorkContext->FspRestartRoutine = NULL;

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The MDL write has been started.  When it completes, processing
        // resumes at RestartPrepareMpxMdlWrite.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Save context for the restart routine.
    //

    WorkContext->Parameters.WriteMpx.Offset = offset.LowPart;
    WorkContext->Parameters.WriteMpx.Mid = mid;

    if ( writeMpx->GlomPending ) {

        //
        // A glom setup is pending.  Wait for that to complete.
        //

        ACQUIRE_SPIN_LOCK( &rfcb->Connection->SpinLock, &oldIrql );

        if ( writeMpx->GlomPending ) {
            InsertTailList(
                &writeMpx->GlomDelayList,
                &WorkContext->ListEntry
                );
            RELEASE_SPIN_LOCK( &rfcb->Connection->SpinLock, oldIrql );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        RELEASE_SPIN_LOCK( &rfcb->Connection->SpinLock, oldIrql );

    }

    if ( writeMpx->Glomming ) {

        //
        // We're glomming this into one big write.  Add the data from
        // this packet.
        //

        AddPacketToGlom( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }


    //
    // We are not glomming this write, because we missed the first
    // packet of the write.  So we write each block as it arrives.
    //
    // If the file's writethrough mode needs to be changed, do so now.
    //

    writeThrough = (BOOLEAN)((writeMode & SMB_WMODE_WRITE_THROUGH) != 0);

    if ( writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) == 0
        || !writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {

        SrvSetFileWritethroughMode( lfcb, writeThrough );

    }

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //

                WorkContext->bAlreadyTrace = TRUE;
                RestartWriteMpx( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // Build an MDL describing the write buffer.  Note that if the file
    // system can complete the write immediately, the MDL isn't really
    // needed, but if the file system must send the request to its FSP,
    // the MDL _is_ needed.
    //
    // *** Note the assumption that the request buffer already has a
    //     valid full MDL from which a partial MDL can be built.
    //

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

        mdl = IoAllocateMdl(
                    writeAddress,
                    writeLength,
                    FALSE,
                    FALSE,
                    NULL
                    );

        if ( mdl == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error;
        }

        //
        // Build the mdl.
        //

        MmBuildMdlForNonPagedPool( mdl );

        WorkContext->Parameters.WriteMpx.DataMdl = mdl;

    } else {

        mdl = WorkContext->RequestBuffer->PartialMdl;

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            mdl,
            writeAddress,
            writeLength
            );

    }

    //
    // Build the IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_WRITE,                   // major function code
            0,                              // minor function code
            writeAddress,                   // buffer address
            writeLength,                    // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = RestartWriteMpx;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // RestartWriteMpx when the write completes.
    //

    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error:

    //
    // There is an error of some sort.  We still need to check for
    // whether this is the last Write Mpx active on the RFCB, and if so,
    // send the response to the write instead of the error.  If this is
    // not the last active mux request, then we either send an error
    // response (non-datagram write mux or sequenced write mux) or
    // ignore this request (unsequenced datagram).  Note that if this is
    // a non-datagram write mux, then we didn't come in over IPX, and we
    // didn't bump the Write Mpx refcount.
    //

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    if ( WorkContext->Rfcb && CheckForWriteMpxComplete( WorkContext ) ) {
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if ( SmbGetAlignedUshort(&header->SequenceNumber) != 0 ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
        response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;
        response->WordCount = 2;
        SmbPutUlong( &response->Mask, 0 );
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_WRITE_MPX_DATAGRAM,
                                            0
                                            );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SmbStatus = SmbStatusNoResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbWriteMpx


VOID SRVFASTCALL
RestartWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for a Write MPX SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    BOOLEAN rfcbClosing;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    KIRQL oldIrql;
    USHORT writeLength;
    LARGE_INTEGER position;
    USHORT sequenceNumber;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    IF_DEBUG(FSD2) KdPrint(( " - RestartWriteMpx\n" ));
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;

    status = WorkContext->Irp->IoStatus.Status;

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
        WorkContext->Parameters.WriteMpx.TransportContext = NULL;
    }

    //
    // Free the data Mdl.
    //

    if ( WorkContext->Parameters.WriteMpx.DataMdl ) {
        IoFreeMdl( WorkContext->Parameters.WriteMpx.DataMdl );
        WorkContext->Parameters.WriteMpx.DataMdl = NULL;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    //
    // If we're entered at dispatch level, and the write failed,
    // or there is a saved error, or the rfcb is closing, then
    // we need to have a worker thread call this routine.
    //

    if ( ((status != STATUS_SUCCESS) ||
          (rfcb->SavedError != STATUS_SUCCESS) ||
          (GET_BLOCK_STATE(rfcb) != BlockStateActive)) &&
         (oldIrql >= DISPATCH_LEVEL) ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        WorkContext->FspRestartRoutine = RestartWriteMpx;
        QUEUE_WORK_TO_FSP( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    //
    // If this write is from a previous mux (meaning that a new one was
    // started while we were doing this write), toss this request.
    //

    writeMpx = &rfcb->WriteMpx;

    if ( WorkContext->Parameters.WriteMpx.Mid != writeMpx->Mid ) {
        goto check_for_mux_end;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The write failed.  Remember the failure in the RFCB.
        //

        IF_DEBUG(ERRORS) KdPrint(( "Write failed: %X\n", status ));

        if ( rfcb->SavedError == STATUS_SUCCESS ) {
            rfcb->SavedError = status;
        }

    } else {

        //
        // The write succeeded.  Update the information in the write mpx
        // context block.
        //
        // !!! Need to deal with mask shifting by the redir and delayed
        //     packets.
        //

#if 0
        MpxDelay = !MpxDelay;
        if ( MpxDelay ) {
            LARGE_INTEGER interval;
            interval.QuadPart = -10*1000*100;
            KeDelayExecutionThread( KernelMode, FALSE, &interval );
        }
#endif
        writeMpx->Mask |= SmbGetUlong( &request->Mask );

    }

    //
    // Save the count of bytes written, to be used to update the server
    // statistics database.
    //

    writeLength = (USHORT)WorkContext->Irp->IoStatus.Information;
    UPDATE_WRITE_STATS( WorkContext, writeLength );

    IF_SMB_DEBUG(MPX1) {
        KdPrint(( "RestartWriteMpx:  Fid 0x%lx, wrote %ld bytes\n",
                  rfcb->Fid, writeLength ));
    }

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto check_for_mux_end;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number and update the file position.
    //

    writeMpx->SequenceNumber = sequenceNumber;

    rfcb->CurrentPosition =  WorkContext->Parameters.WriteMpx.Offset + writeLength;


check_for_mux_end:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        SrvFsdRestartSmbComplete( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    //
    // WriteMpx refcount is 0.
    //

    rfcbClosing = (GET_BLOCK_STATE(rfcb) != BlockStateActive);

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        if ( rfcbClosing ) {
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        }

        if( oldIrql >= DISPATCH_LEVEL ) {
            SrvFsdRestartSmbComplete( WorkContext );
        } else {
            SrvRestartFsdComplete( WorkContext );
        }

        goto Cleanup;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // Now we can release the lock.
    //

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    KeLowerIrql( oldIrql );

    //
    // Complete the rfcb close.
    //

    if ( rfcbClosing ) {

        RestartWriteMpxCompleteRfcbClose( WorkContext );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartWriteMpx

BOOLEAN
CheckForWriteMpxComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PRESP_WRITE_MPX_DATAGRAM response;

    NTSTATUS status;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    PCONNECTION connection = WorkContext->Connection;
    KIRQL oldIrql;

    //
    // If we have not received the sequenced command for this write mux,
    // or this is not the last active command, then return FALSE.
    // Otherwise, it's time to send the response, so build it and return
    // TRUE.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        return(FALSE);
    }

    //
    // WriteMpx refcount is 0.
    //

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        } else {
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }
        return FALSE;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    header = WorkContext->ResponseHeader;
    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // Now we can release the lock.
    //

    if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        RestartWriteMpxCompleteRfcbClose( WorkContext );

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    return TRUE;

} // CheckForWriteMpxComplete

VOID SRVFASTCALL
RestartPrepareMpxMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;

    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    USHORT writeLength;
    PCHAR writeAddress;
    KIRQL oldIrql;
    ULONG bytesCopied;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PMDL mdl;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_MPX;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;
    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;           

    rfcb = WorkContext->Rfcb;
    writeMpx = &rfcb->WriteMpx;
    connection = WorkContext->Connection;

    //
    // If the MDL write preparation succeeded, copy the data from this
    // packet into the cache.  If it failed, toss this packet.
    //

    if( NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        mdl = WorkContext->Irp->MdlAddress;
#if DBG
        IF_SMB_DEBUG(MPX2) {
            KdPrint(( "RestartPrepareMpxMdlWrite: rfcb %p, input chain:\n", rfcb ));
            DumpMdlChain( mdl );
        }
#endif
        writeMpx->MdlChain = mdl;
        writeMpx->NumberOfRuns = 1;
        writeMpx->RunList[0].Offset = 0;
        writeLength = WorkContext->Parameters.WriteMpx.WriteLength;
        writeMpx->RunList[0].Length = writeLength;

        //
        // If we have the transport context, setup writeAddress accordingly.
        //

        if ( WorkContext->Parameters.WriteMpx.TransportContext ) {

            writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer +
                                    SmbGetUshort( &request->DataOffset );
        } else {

            writeAddress = (PCHAR)WorkContext->ResponseHeader +
                                    SmbGetUshort( &request->DataOffset );
        }

        status = TdiCopyBufferToMdl(
                    writeAddress,
                    0,
                    writeLength,
                    mdl,
                    0,
                    &bytesCopied
                    );
        ASSERT( status == STATUS_SUCCESS );
        ASSERT( bytesCopied == writeLength );

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        writeMpx->Glomming = TRUE;

        ASSERT( writeMpx->Mask == 0 );
        writeMpx->Mask = SmbGetUlong( &request->Mask );

        --writeMpx->ReferenceCount;
        ASSERT( writeMpx->SequenceNumber == 0 );

    } else {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

        if ( rfcb->SavedError == STATUS_SUCCESS ) {
            rfcb->SavedError = WorkContext->Irp->IoStatus.Status;
        }

        --writeMpx->ReferenceCount;
        writeMpx->Glomming = FALSE;
    }

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                  1
                                  );
    }

    writeMpx->GlomPending = FALSE;

    while ( !IsListEmpty( &writeMpx->GlomDelayList ) ) {
        listEntry = RemoveHeadList( &writeMpx->GlomDelayList );
        workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, ListEntry );
        workContext->FspRestartRoutine = AddPacketToGlom;
        QUEUE_WORK_TO_FSP( workContext );
    }

    //
    // If the rfcb is closing and the write mpx ref count == 0,
    // then we must complete the close.
    //

    if ( (GET_BLOCK_STATE(rfcb) != BlockStateActive) &&
         (writeMpx->ReferenceCount == 0) ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        WorkContext->FspRestartRoutine = RestartWriteMpxCompleteRfcbClose;
        QUEUE_WORK_TO_FSP( WorkContext );
        KeLowerIrql( oldIrql );
        goto Cleanup;
    }

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    SrvFsdRestartSmbComplete( WorkContext );
    KeLowerIrql( oldIrql );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartPrepareMpxMdlWrite


VOID SRVFASTCALL
AddPacketToGlom (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header;
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;

    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    PCONNECTION connection;
    ULONG fileOffset;
    USHORT glomOffset;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG bytesCopied;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    USHORT sequenceNumber;
    BOOLEAN rfcbClosing;

    PWRITE_MPX_RUN run, nextRun;
    ULONG runIndex, runCount;

    USHORT runOffset;
    USHORT runLength;

    PMDL cacheMdl;
    LARGE_INTEGER cacheOffset;

    header = WorkContext->RequestHeader;
    request = (PREQ_WRITE_MPX)WorkContext->RequestParameters;

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;
    writeMpx = &rfcb->WriteMpx;
    cacheMdl = writeMpx->MdlChain;

    if( writeMpx->Glomming == FALSE ) {
        //
        // We must have encountered an error in RestartPrepareMpxMdlWrite(), but
        // we call through this routine to ensure we send a response back to the
        // client.
        //
        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto check;
    }

    ASSERT( writeMpx->Glomming );
    ASSERT( !writeMpx->GlomPending );
    ASSERT( WorkContext->Parameters.WriteMpx.Mid == writeMpx->Mid );

    //
    // Get the file offset of this packet's data.
    //

    fileOffset = WorkContext->Parameters.WriteMpx.Offset;

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    //
    // If we have the transport context, setup writeAddress accordingly.
    //

    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        writeAddress = (PCHAR)WorkContext->Parameters.WriteMpx.Buffer +
                       bufferOffset;
    } else {
        writeAddress = (PCHAR)header + bufferOffset;
    }

    writeLength = WorkContext->Parameters.WriteMpx.WriteLength;
    ASSERT( writeLength <= 0xffff );

    //
    // If the data doesn't fall within the bounds of the glommed write,
    // discard the packet.
    //
    // We always know that we've copied at least the first part of the
    // glom.
    //

    ASSERT( writeMpx->NumberOfRuns > 0 );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    if ( fileOffset <= writeMpx->StartOffset ) {
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto discard;
    }

    fileOffset -= writeMpx->StartOffset;
    if ( (fileOffset + writeLength) > writeMpx->Length ) {
        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto discard;
    }
    ASSERT( fileOffset <= 0xffff );
    ASSERT( fileOffset + writeLength <= 0xffff );

    glomOffset = (USHORT)fileOffset;

    //
    // Copy the packet data into the glom.
    //

    status = TdiCopyBufferToMdl(
                writeAddress,
                0,
                writeLength,
                cacheMdl,
                glomOffset,
                &bytesCopied
                );
    ASSERT( status == STATUS_SUCCESS );
    ASSERT( bytesCopied == writeLength );

    //
    // Return the TransportContext
    //
    if ( WorkContext->Parameters.WriteMpx.TransportContext ) {
        TdiReturnChainedReceives( &WorkContext->Parameters.WriteMpx.TransportContext,
                                      1
                                      );
    }

    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    //
    // Update the glom run information.  Note that this packet may have
    // been received multiple times, so it may already be marked in the
    // run information.
    //

    if (0) IF_SMB_DEBUG(MPX2) {
        KdPrint(( "rfcb %p, offset %lx, length %lx\n", rfcb, glomOffset, writeLength ));
    }

    runCount = writeMpx->NumberOfRuns;

    for ( runIndex = 1, nextRun = &writeMpx->RunList[1];
          runIndex < runCount;
          runIndex++, nextRun++ ) {
        if ( nextRun->Offset > glomOffset ) {
            break;
        }
    }
    run = nextRun - 1;

    runOffset = run->Offset;
    runLength = run->Length;
    ASSERT( runOffset <= glomOffset );

    if ( (runOffset + runLength) == glomOffset ) {

        //
        // This packet abuts the end of the previous run.  Add the
        // length of this packet to the run length and attempt to
        // coalesce with the next run.
        //

        runLength += writeLength;
        goto coalesce;
    }

    if ( (runOffset + runLength) > glomOffset ) {

        //
        // This packet overlaps the previous run.  If it lies completely
        // within the previous run, ignore it.
        //

        if ( (USHORT)(runOffset + runLength) >= (glomOffset + writeLength) ) {
            goto discard;
        }

        //
        // This packet overlaps and extends the previous run.  Calculate
        // the new run length and attempt to coalesce with the next run.
        //

        runLength = (glomOffset - runOffset + writeLength);
        goto coalesce;
    }

    //
    // This packet's data is disjoint from the previous run.
    //

    if ( runIndex < runCount ) {

        //
        // There is a next run.  Does this packet overlap with that run?
        //

        runOffset = nextRun->Offset;
        runLength = nextRun->Length;

        if ( (glomOffset + writeLength) >= runOffset ) {

            //
            // This packet overlaps the next run.  Calculate the new run
            // length.
            //

            nextRun->Offset = glomOffset;
            nextRun->Length = runOffset - glomOffset + runLength;
            goto check;
        }
    }

    //
    // Either this packet is disjoint from the next run, or there is no
    // next run.  Is there room in the run array for another run?  If
    // not, discard this packet.  (Note that we discard it even though
    // we have already copied the packet data.  That's OK -- it will
    // just be resent.)
    //

    if ( runCount == MAX_GLOM_RUN_COUNT ) {
        goto discard;
    }

    //
    // Add a new run.  Since we know the new run is disjoint from the
    // previous run, we know that the glom is not complete.
    //

    RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
        nextRun + 1,
        nextRun,
        (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
        );
    writeMpx->NumberOfRuns++;
    nextRun->Offset = glomOffset;
    nextRun->Length = writeLength;
    goto check;

coalesce:

    if ( runIndex == runCount ) {
        run->Length = runLength;
    } else if ( (runOffset + runLength) >= nextRun->Offset ) {
        run->Length = nextRun->Length + nextRun->Offset - runOffset;
        writeMpx->NumberOfRuns--;
        RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
            nextRun,
            nextRun + 1,
            (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
            );
    } else {
        run->Length += writeLength;
        ASSERT( (runOffset + run->Length) < nextRun->Offset );
    }

    if ( (writeMpx->NumberOfRuns == 1) &&
         (writeMpx->RunList[0].Length == writeMpx->Length) ) {

        //
        // The glom is complete.
        //

        writeMpx->GlomComplete = TRUE;
    }

check:

    if (0) IF_SMB_DEBUG(MPX2) {
        if( writeMpx->Glomming ) {
            ULONG i;
            PWRITE_MPX_RUN runi;
            for ( i = 0, runi = &writeMpx->RunList[0];
                  i < writeMpx->NumberOfRuns;
                  i++, runi++ ) {
                KdPrint(( "  run %d: offset %lx, length %lx\n", i, runi->Offset, runi->Length ));
            }
        }
    }

    writeMpx->Mask |= SmbGetUlong( &request->Mask );

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto discard;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number.
    //

    writeMpx->SequenceNumber = sequenceNumber;

discard:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( --writeMpx->ReferenceCount != 0 ) {

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        SrvFsdRestartSmbComplete( WorkContext );
        KeLowerIrql( oldIrql );
        return;
    }

    //
    // WriteMpx refcount is 0.
    //

    rfcbClosing = (GET_BLOCK_STATE(rfcb) != BlockStateActive);

    if ( writeMpx->SequenceNumber == 0 ) {

        //
        // If the rfcb is closing, complete the cleanup.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        if ( rfcbClosing ) {
            RestartWriteMpxCompleteRfcbClose( WorkContext );
        }
        SrvRestartFsdComplete( WorkContext );
        return;
    }

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // If the glom is complete, we need to complete the MDL write.  But
    // we can't do that with the lock held, so we need to clear out all
    // information related to the glom first.
    //

    if ( writeMpx->Glomming && writeMpx->GlomComplete ) {

        PWORK_CONTEXT newContext;

        //
        // Save and clear information about the active glom.
        //

        writeMpx->Glomming = FALSE;
        writeMpx->GlomComplete = FALSE;

        cacheOffset.QuadPart = writeMpx->StartOffset;
        writeLength = writeMpx->Length;

        DEBUG writeMpx->MdlChain = NULL;
        DEBUG writeMpx->StartOffset = 0;
        DEBUG writeMpx->Length = 0;

        //
        // Save the status.
        //

        status = rfcb->SavedError;
        rfcb->SavedError = STATUS_SUCCESS;

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

        ALLOCATE_WORK_CONTEXT( WorkContext->CurrentWorkQueue, &newContext );

#if DBG
        IF_SMB_DEBUG(MPX2) {
            KdPrint(( "AddPacketToGlom: rfcb %p, completed chain:\n", rfcb ));
            DumpMdlChain( cacheMdl );
        }
#endif

        if( newContext == NULL ) {

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( rfcb->Lfcb->MdlWriteComplete == NULL ||
                rfcb->Lfcb->MdlWriteComplete(
                    rfcb->Lfcb->FileObject,
                    &cacheOffset,
                    cacheMdl,
                    rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                     cacheMdl,
                                                     IRP_MJ_WRITE,
                                                     &cacheOffset,
                                                     writeLength
                                                    );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {
            //
            // Send the FsRtlMdlWriteComplete off on its way, and go ahead and send
            //  the response to the client now.
            //
            newContext->Rfcb = WorkContext->Rfcb;
            SrvReferenceRfcb( newContext->Rfcb );

            newContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset = cacheOffset;
            newContext->Parameters.WriteMpxMdlWriteComplete.WriteLength = writeLength;
            newContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl = cacheMdl;
            newContext->FspRestartRoutine = WriteMpxMdlWriteComplete;
            SrvQueueWorkToFsp( newContext );
        }

    } else {

        if( writeMpx->Glomming == FALSE ) {
            status = rfcb->SavedError;
            rfcb->SavedError = STATUS_SUCCESS;
        }

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        KeLowerIrql( oldIrql );

    }

    //
    // Complete the rfcb close.
    //

    if ( rfcbClosing ) {

        RestartWriteMpxCompleteRfcbClose( WorkContext );
    }

    //
    // Build the response message.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    return;

} // AddPacketToGlom

BOOLEAN
AddPacketToGlomInIndication (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PRFCB Rfcb,
    IN PVOID Tsdu,
    IN ULONG BytesAvailable,
    IN ULONG ReceiveDatagramFlags,
    IN PVOID SourceAddress,
    IN PVOID Options
    )

/*++

Routine Description:

    Do Write glomming at indication.

    *** connection spinlock assumed held.  Released on exit ***

Arguments:

Return Value:

    TRUE if the caller has to clean up the connection block.

--*/

{
    PREQ_WRITE_MPX request;
    PRESP_WRITE_MPX_DATAGRAM response;
    PWRITE_MPX_CONTEXT writeMpx = &Rfcb->WriteMpx;

    PCONNECTION connection = WorkContext->Connection;
    ULONG fileOffset;
    USHORT glomOffset;
    CLONG bufferOffset;
    PCHAR writeAddress;
    USHORT writeLength;
    ULONG bytesCopied;
    NTSTATUS status = STATUS_SUCCESS;
    USHORT sequenceNumber;

    PSMB_HEADER header = (PSMB_HEADER)Tsdu;
    PWRITE_MPX_RUN run, nextRun;
    ULONG runIndex, runCount;

    USHORT runOffset;
    USHORT runLength;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // copied from SrvRestartReceive.
    //

    WorkContext->CurrentWorkQueue->stats.BytesReceived += BytesAvailable;
    connection->BreakIIToNoneJustSent = FALSE;
    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // Set up locals.
    //

    request = (PREQ_WRITE_MPX)(header + 1);

    ASSERT( writeMpx->Glomming );
    ASSERT( !writeMpx->GlomPending );
    ASSERT( header->Mid == writeMpx->Mid );

    //
    // Get the file offset of this packet's data.
    //

    fileOffset = SmbGetUlong( &request->Offset );

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    writeAddress = (PCHAR)header + bufferOffset;

    writeLength =
        (USHORT)(MIN( (CLONG)SmbGetUshort( &request->DataLength ),
                      BytesAvailable - bufferOffset ));
    ASSERT( writeLength <= 0xffff );

    //
    // If the data doesn't fall within the bounds of the glommed write,
    // discard the packet.
    //
    // We always know that we've copied at least the first part of the
    // glom.
    //

    ASSERT( writeMpx->NumberOfRuns > 0 );

    if ( fileOffset <= writeMpx->StartOffset ) {
        goto discard;
    }
    fileOffset -= writeMpx->StartOffset;
    if ( (fileOffset + writeLength) > writeMpx->Length ) {
        goto discard;
    }
    ASSERT( fileOffset <= 0xffff );
    ASSERT( fileOffset + writeLength <= 0xffff );
    glomOffset = (USHORT)fileOffset;

    //
    // Copy the packet data into the glom.
    //

    status = TdiCopyBufferToMdl(
                writeAddress,
                0,
                writeLength,
                writeMpx->MdlChain,
                glomOffset,
                &bytesCopied
                );
    ASSERT( status == STATUS_SUCCESS );
    ASSERT( bytesCopied == writeLength );

    //
    // Update the glom run information.  Note that this packet may have
    // been received multiple times, so it may already be marked in the
    // run information.
    //

    if (0) IF_SMB_DEBUG(MPX2) {
        KdPrint(( "rfcb %p, offset %lx, length %lx\n", Rfcb, glomOffset, writeLength ));
    }

    runCount = writeMpx->NumberOfRuns;

    for ( runIndex = 1, nextRun = &writeMpx->RunList[1];
          runIndex < runCount;
          runIndex++, nextRun++ ) {
        if ( nextRun->Offset > glomOffset ) {
            break;
        }
    }
    run = nextRun - 1;

    runOffset = run->Offset;
    runLength = run->Length;
    ASSERT( runOffset <= glomOffset );

    if ( (runOffset + runLength) == glomOffset ) {

        //
        // This packet abuts the end of the previous run.  Add the
        // length of this packet to the run length and attempt to
        // coalesce with the next run.
        //

        runLength += writeLength;
        goto coalesce;
    }

    if ( (runOffset + runLength) > glomOffset ) {

        //
        // This packet overlaps the previous run.  If it lies completely
        // within the previous run, ignore it.
        //

        if ( (USHORT)(runOffset + runLength) >= (glomOffset + writeLength) ) {
            goto discard;
        }

        //
        // This packet overlaps and extends the previous run.  Calculate
        // the new run length and attempt to coalesce with the next run.
        //

        runLength = (glomOffset - runOffset + writeLength);
        goto coalesce;
    }

    //
    // This packet's data is disjoint from the previous run.
    //

    if ( runIndex < runCount ) {

        //
        // There is a next run.  Does this packet overlap with that run?
        //

        runOffset = nextRun->Offset;
        runLength = nextRun->Length;

        if ( (glomOffset + writeLength) >= runOffset ) {

            //
            // This packet overlaps the next run.  Calculate the new run
            // length.
            //

            nextRun->Offset = glomOffset;
            nextRun->Length = runOffset - glomOffset + runLength;
            goto check;
        }
    }

    //
    // Either this packet is disjoint from the next run, or there is no
    // next run.  Is there room in the run array for another run?  If
    // not, discard this packet.  (Note that we discard it even though
    // we have already copied the packet data.  That's OK -- it will
    // just be resent.)
    //

    if ( runCount == MAX_GLOM_RUN_COUNT ) {
        goto discard;
    }

    //
    // Add a new run.  Since we know the new run is disjoint from the
    // previous run, we know that the glom is not complete.
    //

    RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
        nextRun + 1,
        nextRun,
        (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
        );
    writeMpx->NumberOfRuns++;
    nextRun->Offset = glomOffset;
    nextRun->Length = writeLength;
    goto check;

coalesce:

    if ( runIndex == runCount ) {
        run->Length = runLength;
    } else if ( (runOffset + runLength) >= nextRun->Offset ) {
        run->Length = nextRun->Length + nextRun->Offset - runOffset;
        writeMpx->NumberOfRuns--;
        RtlMoveMemory(  // NOT RtlCopyMemory -- buffers overlap
            nextRun,
            nextRun + 1,
            (runCount - runIndex) * sizeof(WRITE_MPX_RUN)
            );
    } else {
        run->Length += writeLength;
        ASSERT( (runOffset + run->Length) < nextRun->Offset );
    }

    if ( (writeMpx->NumberOfRuns == 1) &&
         (writeMpx->RunList[0].Length == writeMpx->Length) ) {

        //
        // The glom is complete.
        //

        writeMpx->GlomComplete = TRUE;
    }

check:

    if (0) IF_SMB_DEBUG(MPX2) {
        ULONG i;
        PWRITE_MPX_RUN runi;
        for ( i = 0, runi = &writeMpx->RunList[0];
              i < writeMpx->NumberOfRuns;
              i++, runi++ ) {
            KdPrint(( "  run %d: offset %lx, length %lx\n", i, runi->Offset, runi->Length ));
        }
    }

    writeMpx->Mask |= SmbGetUlong( &request->Mask );

    //
    // If this is an unsequenced request, we're done.  We don't respond
    // until we get a sequenced request.
    //

    sequenceNumber = SmbGetAlignedUshort( &header->SequenceNumber );

    if ( sequenceNumber == 0 ) {
        goto discard;
    }

    //
    // This is the last request in this mux sent by the client.  Save
    // the sequence number.
    //

    writeMpx->SequenceNumber = sequenceNumber;

discard:

    //
    // If we have received the sequenced command for this write mux,
    // and this is the last active command, then it's time to send
    // the response.  Otherwise, we are done with this SMB.
    //

    if ( (--writeMpx->ReferenceCount != 0) ||
         (writeMpx->SequenceNumber == 0) ) {
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        return TRUE;
    }

    //
    // Copy the header portion for the response.
    //

    TdiCopyLookaheadData(
        WorkContext->RequestBuffer->Buffer,
        Tsdu,
        sizeof(SMB_HEADER),
        ReceiveDatagramFlags
        );

    // WorkContext->RequestBuffer->DataLength = BytesAvailable;

    //
    // We are done with this write mux.  Save the accumulated mask, the
    // sequence number, and the original MID, then clear the mask and
    // sequence number to indicate that we no longer are in the middle
    // of a write mux.
    //

    response = (PRESP_WRITE_MPX_DATAGRAM)WorkContext->ResponseParameters;

    SmbPutUlong( &response->Mask, writeMpx->Mask );
    writeMpx->Mask = 0;

    SmbPutAlignedUshort( &header->SequenceNumber, writeMpx->SequenceNumber );
    writeMpx->SequenceNumber = 0;

    SmbPutAlignedUshort( &header->Mid, writeMpx->Mid );

    //
    // If the glom is complete, we need to complete the MDL write.  But
    // we can't do that with the lock held, so we need to clear out all
    // information related to the glom first.
    //

    if ( writeMpx->GlomComplete ) {

        //
        // The file is active and the TID is valid.  Reference the
        // RFCB.
        //

        Rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( Rfcb, FALSE );

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

        WorkContext->Rfcb = Rfcb;

        //
        // Build the response message.
        //

        response->WordCount = 2;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_WRITE_MPX_DATAGRAM,
                                            0
                                            );

        //
        // Send this off to the fsp for final processing.  We need to do
        // this since we cannot call the cache manager at dpc level.
        //

        WorkContext->FspRestartRoutine = RestartCompleteGlommingInIndication;
        SrvQueueWorkToFsp( WorkContext );
        return FALSE;

    } else {

        //
        // Now we can release the lock.
        //

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    }

    //
    // Build the response message.
    //

    ASSERT( status == STATUS_SUCCESS );

    response->WordCount = 2;
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_MPX_DATAGRAM,
                                        0
                                        );

    //
    // Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    return FALSE;

} // AddPacketToGlomInIndication

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpxSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Mpx Secondary SMB.

    *** The server should never see this SMB, since it returns the "use
        standard read" error to the main Write Mpx SMB, except over IPX,
        which doesn't use Write Mpx Secondary.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Send a response that tells the client that this SMB is not
    // valid.
    //

    INTERNAL_ERROR(
        ERROR_LEVEL_UNEXPECTED,
        "SrvSmbWriteMpxSecondary: unexpected SMB",
        NULL,
        NULL
        );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    return SmbStatusSendResponse;

} // SrvSmbWriteMpxSecondary

VOID SRVFASTCALL
RestartCompleteGlommingInIndication(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    LARGE_INTEGER cacheOffset;
    KIRQL oldIrql;
    PMDL cacheMdl;
    NTSTATUS status;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    PCONNECTION connection = WorkContext->Connection;
    ULONG writeLength;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Save the status.
    //

    status = rfcb->SavedError;
    rfcb->SavedError = STATUS_SUCCESS;

    //
    // If the rfcb has closed, then the mdl write was completed.
    //

    if ( GET_BLOCK_STATE(rfcb) == BlockStateActive ) {

        PWORK_CONTEXT newContext;

        writeMpx->GlomComplete = FALSE;
        writeMpx->Glomming = FALSE;
        cacheOffset.QuadPart = writeMpx->StartOffset;
        cacheMdl = writeMpx->MdlChain;
        writeLength = writeMpx->Length;

        DEBUG writeMpx->MdlChain = NULL;
        DEBUG writeMpx->StartOffset = 0;
        DEBUG writeMpx->Length = 0;

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );


        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        ALLOCATE_WORK_CONTEXT( WorkContext->CurrentWorkQueue, &newContext );
        KeLowerIrql( oldIrql );

        if( newContext == NULL ) {

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( rfcb->Lfcb->MdlWriteComplete == NULL ||
                rfcb->Lfcb->MdlWriteComplete(
                    rfcb->Lfcb->FileObject,
                    &cacheOffset,
                    cacheMdl,
                    rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                     cacheMdl,
                                                     IRP_MJ_WRITE,
                                                     &cacheOffset,
                                                     writeLength
                                                    );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {
            //
            // Send the FsRtlMdlWriteComplete off on its way, and go ahead and send
            //  the response to the client now.
            //
            newContext->Rfcb = WorkContext->Rfcb;
            WorkContext->Rfcb = NULL;

            newContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset = cacheOffset;
            newContext->Parameters.WriteMpxMdlWriteComplete.WriteLength = writeLength;
            newContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl = cacheMdl;
            newContext->FspRestartRoutine = WriteMpxMdlWriteComplete;
            SrvQueueWorkToFsp( newContext );
        }

    } else {

        ASSERT( !writeMpx->Glomming );
        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    //
    // Send the response.
    //

    if ( !NT_SUCCESS(status) ) {
        SrvSetSmbError2( WorkContext, status, TRUE );
    }

    SrvFsdSendResponse( WorkContext );
    return;

} // RestartCompleteGlommingInIndication

VOID SRVFASTCALL
WriteMpxMdlWriteComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    NTSTATUS status;

    if( WorkContext->Rfcb->Lfcb->MdlWriteComplete == NULL ||

        WorkContext->Rfcb->Lfcb->MdlWriteComplete(
            WorkContext->Rfcb->Lfcb->FileObject,
            &WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset,
            WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl,
            WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

        status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                             WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheMdl,
                                             IRP_MJ_WRITE,
                                             &WorkContext->Parameters.WriteMpxMdlWriteComplete.CacheOffset,
                                             WorkContext->Parameters.WriteMpxMdlWriteComplete.WriteLength );

        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
        }
    }

    SrvDereferenceRfcb( WorkContext->Rfcb );
    WorkContext->Rfcb = NULL;
    WorkContext->FspRestartRoutine = SrvRestartReceive;
    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
#if DBG
    WorkContext->BlockHeader.ReferenceCount = 0;
#endif
    RETURN_FREE_WORKITEM( WorkContext );
}


VOID SRVFASTCALL
RestartWriteMpxCompleteRfcbClose (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Completes the rfcb close after last active writempx is finished.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    PCONNECTION connection = WorkContext->Connection;
    PRFCB rfcb = WorkContext->Rfcb;
    PWRITE_MPX_CONTEXT writeMpx = &rfcb->WriteMpx;
    LARGE_INTEGER cacheOffset;
    PMDL mdlChain;
    KIRQL oldIrql;
    ULONG writeLength;
    NTSTATUS status;

    //
    // This rfcb is closing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    ASSERT ( GET_BLOCK_STATE(rfcb) != BlockStateActive );

    writeMpx = &rfcb->WriteMpx;

    if ( writeMpx->Glomming ) {

         //
         // We need to complete this write mdl
         //

         writeMpx->Glomming = FALSE;
         writeMpx->GlomComplete = FALSE;

         //
         // Save the offset and MDL address.
         //

         cacheOffset.QuadPart = writeMpx->StartOffset;
         mdlChain = writeMpx->MdlChain;
         writeLength = writeMpx->Length;

         DEBUG writeMpx->MdlChain = NULL;
         DEBUG writeMpx->StartOffset = 0;
         DEBUG writeMpx->Length = 0;

         //
         // Now we can release the lock.
         //

         RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

         //
         // Tell the cache manager that we're done with this MDL write.
         //

         if( rfcb->Lfcb->MdlWriteComplete == NULL ||
             rfcb->Lfcb->MdlWriteComplete(
                 writeMpx->FileObject,
                 &cacheOffset,
                 mdlChain,
                 rfcb->Lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 mdlChain,
                                                 IRP_MJ_WRITE,
                                                 &cacheOffset,
                                                 writeLength );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

    } else {

         //
         // Now we can release the lock.
         //

         RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    }

    //
    // Do the actual close
    //

    SrvCompleteRfcbClose( rfcb );
    return;

} // RestartWriteMpxCompleteRfcbClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbraw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbraw.c

Abstract:

    This module contains routines for processing the following SMBs in
    the server FSP:

        Read Block Raw
        Write Block Raw

    The routines in this module generally work closely with the routines
    in fsdraw.c.

    *** There is no support here for raw writes from MS-NET 1.03 clients.
        There are very few of these machines in existence, and raw mode
        is only a performance issue, so it is not worth the trouble to
        add the necessary hacks for MS-NET 1.03, which sends raw write
        requests in a different format.

Author:

    Chuck Lenzmeier (chuckl) 8-Sep-1990
    Manny Weiser (mannyw)
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbraw.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBRAW

//
// Forward declarations
//

VOID SRVFASTCALL
AbortRawWrite(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
PrepareRawCopyWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN SRVFASTCALL
ReadRawPipe (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartPipeReadRawPeek (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbWriteRaw )
#pragma alloc_text( PAGE, AbortRawWrite )
#pragma alloc_text( PAGE, PrepareRawCopyWrite )
#pragma alloc_text( PAGE, ReadRawPipe )
#pragma alloc_text( PAGE, RestartMdlReadRawResponse )
#pragma alloc_text( PAGE, RestartPipeReadRawPeek )
#pragma alloc_text( PAGE, SrvRestartRawReceive )
#pragma alloc_text( PAGE, SrvRestartReadRawComplete )
#pragma alloc_text( PAGE, SrvRestartWriteCompleteResponse )
#pragma alloc_text( PAGE, SrvBuildAndSendWriteCompleteResponse )
#endif
#if 0
NOT PAGEABLE -- DumpMdlChain
NOT PAGEABLE -- SrvSmbReadRaw
NOT PAGEABLE -- SrvDecrementRawWriteCount
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    )
{
    ULONG mdlCount = 0;
    ULONG length = 0;

    if ( mdl == NULL ) {
        KdPrint(( "  <empty MDL chain>\n" ));
        return;
    }
    do {
        KdPrint(( "  mdl %p len %04x flags %04x sysva %p va %p offset %04x\n",
                    mdl, mdl->ByteCount, mdl->MdlFlags,
                    mdl->MappedSystemVa, mdl->StartVa, mdl->ByteOffset ));
        length += mdl->ByteCount;
        mdlCount++;
        mdl = mdl->Next;
    } while ( mdl != NULL );
    KdPrint(( "  total of %ld bytes in %ld MDLs\n", length, mdlCount ));
    return;
}
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadRaw (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read Block Raw SMB.

    Note that Read Block Raw cannot return an error response.  When the
    server is unable to process the request, for whatever reason, it
    simply responds with a zero-length message.  The client uses a
    normal Read SMB to determine what happened.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description of the
        parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_READ_RAW request;
    PREQ_NT_READ_RAW ntRequest;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCONNECTION connection;
    UCHAR minorFunction = 0;
    PVOID rawBuffer = NULL;
    CLONG readLength;
    PMDL mdl = NULL;
    ULONG key;
    LARGE_INTEGER offset;
    SHARE_TYPE shareType;
    KIRQL oldIrql;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_RAW;
    SrvWmiStartContext(WorkContext);

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsAttempted );

    request = (PREQ_READ_RAW)WorkContext->RequestParameters;
    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(RAW1) {
        KdPrint(( "Read Block Raw request; FID 0x%lx, count %ld, "
                    "offset %ld\n",
                    fid, SmbGetUshort( &request->MaxCount ),
                    SmbGetUlong( &request->Offset ) ));
    }

    //
    // If raw mode has been disabled or if the connection is unreliable,
    // reject the raw read.  Ask the client to use standard read by
    // sending a zero-length response.  The client will react by issuing
    // a normal Read SMB, which we will be able to process.
    //

    connection = WorkContext->Connection;

    if ( !SrvEnableRawMode || !connection->EnableRawIo ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "SrvSmbReadRaw: Raw mode is disabled\n" ));
        }
        goto error_exit_no_cleanup;
    }

    //
    // Get the rfcb
    //

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    if ( connection->CachedFid == fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        PTABLE_HEADER tableHeader;
        USHORT index;
        USHORT sequence;

        //
        // Initialize local variables:  obtain the connection block address
        // and crack the FID into its components.
        //

        index = FID_INDEX( fid );
        sequence = FID_SEQUENCE( fid );

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        tableHeader = &connection->FileTable;

        if ( (index >= (USHORT)tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {
            goto error_exit_no_cleanup_locked;
        }
        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            goto error_exit_no_cleanup_locked;
        }

        //
        // If there is a write behind error, reject the raw read.
        //

        if ( !NT_SUCCESS(rfcb->SavedError) ) {
            goto error_exit_no_cleanup_locked;
        }

        //
        // Cache this rfcb
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)fid;
    }

    //
    // The FID is valid within the context of this connection.  Verify
    // that the file is still active and that the owning tree connect's
    // TID is correct.
    //
    // Do not verify the UID for clients that do not understand it.
    //

    if ( (rfcb->Tid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )) ||
         ((rfcb->Uid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )) &&
           DIALECT_HONORS_UID(connection->SmbDialect)) ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    //
    // If a raw write is active, queue this work item in the RFCB
    // pending completion of the raw write.
    //

    if ( rfcb->RawWriteCount != 0 ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        //
        // These 2 fields must be set with the connection spinlock held
        // since the workitem might be picked up by another thread and
        // a race condition will occur.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        WorkContext->Rfcb = NULL;

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If this is a pipe read, we do things differently.
    //

    shareType = rfcb->ShareType;
    if ( shareType == ShareTypePipe ) {

        //
        // Indicate that a raw read is in progress on the connection.
        //

        connection->RawReadsInProgress++;

        //
        // The raw read can be accepted.  Reference the RFCB.
        //

        rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        WorkContext->Rfcb = rfcb;
        if ( !ReadRawPipe( WorkContext ) ) {
            goto error_exit_cleanup;
        }
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // If there is an oplock break in progress, return 0 bytes read.  We
    // do this because our oplock break request SMB may have crossed on
    // the wire with the read raw request and it may have been received
    // in the client's raw read buffer.  This would cause the raw data
    // to complete in the client's regular receive buffer and possibly
    // to overrun it.
    //
    // If this is not the case, the client will simply retry the read
    // using a different read protocol.  If it is the case, the client
    // must detect this and break the oplock, then redo the read.
    //

    if ( connection->OplockBreaksInProgress > 0 ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // Check to see whether we got a round trip break/response.  If so,
    // reject read raw.
    //

    if ( (LONG)(connection->LatestOplockBreakResponse -
                                            WorkContext->Timestamp) >= 0 ) {
        goto error_exit_no_cleanup_locked;
    }

    //
    // If this is the first SMB received after sending an oplock break
    // II to none, reject this read.  We need to do this because there
    // is no response to such a break, so we don't know for sure if the
    // break crossed with the read, which would mean that the break
    // actually completed the client's read, which would mean that any
    // raw data that we sent would be incorrectly received.
    //

    if ( connection->BreakIIToNoneJustSent ) {
        connection->BreakIIToNoneJustSent = FALSE;
        goto error_exit_no_cleanup_locked;
    }

    //
    // Indicate that a raw read is in progress on the connection.
    //

    connection->RawReadsInProgress++;

    //
    // The raw read can be accepted.  Reference the RFCB.
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    WorkContext->Rfcb = rfcb;

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        goto error_exit_cleanup;
    }

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    lfcb = rfcb->Lfcb;

#if SRVCATCH
    if ( rfcb->SrvCatch > 0 ) {
        //
        // Force the client through the core read path for this file
        //
        goto error_exit_cleanup;
    }
#endif

    if ( !rfcb->ReadAccessGranted ) {
        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadRaw: Read access not granted.\n"));
            }
            goto error_exit_cleanup;
        }
    }

    //
    // Calculate and save the read offset.
    //

    if ( request->WordCount == 8 ) {

        //
        // The client supplied a 32-bit offset.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );

    } else if ( request->WordCount == 10 ) {

        //
        // The client supplied a 64-bit offset.
        //

        ntRequest = (PREQ_NT_READ_RAW)WorkContext->RequestParameters;
        offset.LowPart = SmbGetUlong( &ntRequest->Offset );
        offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

        //
        // Reject negative offsets
        //

        if ( offset.QuadPart < 0 ) {
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadRaw: Negative offset rejected.\n"));
            }
            goto error_exit_cleanup;
        }

    } else {

        //
        // Invalid word count.  Return 0 bytes.
        //

        goto error_exit_cleanup;
    }

    WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset = offset;

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.
    //

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    readLength = SmbGetUshort( &request->MaxCount );
    WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Length = readLength;

    if ( //0 &&
         (readLength <= SrvMdlReadSwitchover) ) {

do_copy_read:

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer = NULL;
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        //
        // Try the fast I/O path first.
        //

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            WorkContext->ResponseBuffer->Buffer,
            readLength
            );

        mdl = WorkContext->ResponseBuffer->PartialMdl;
        rawBuffer = WorkContext->ResponseHeader;

        ASSERT( minorFunction == 0 );

    } else {

        //
        // The SMB buffer isn't big enough.  Does the target file system
        // support the cache manager routines?
        //

        if ( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED ) {

            WorkContext->Parameters.ReadRaw.MdlRead = TRUE;

            //
            // We can use an MDL read.  Try the fast I/O path first.
            //

            WorkContext->Irp->MdlAddress = NULL;
            WorkContext->Irp->IoStatus.Information = 0;

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            if ( lfcb->MdlRead &&
                 lfcb->MdlRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    key,
                    &WorkContext->Irp->MdlAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) && WorkContext->Irp->MdlAddress ) {

                //
                // The fast I/O path worked.  Send the data.
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartReadRaw( WorkContext );
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            //
            // The fast I/O path failed.  We need to issue a regular MDL
            // read request.
            //
            // The fast path may have partially succeeded, returning a
            // partial MDL chain.  We need to adjust our read request
            // to account for that.
            //

            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

            mdl = WorkContext->Irp->MdlAddress;
            minorFunction = IRP_MN_MDL;

        } else if (readLength > WorkContext->ResponseBuffer->BufferLength) {

            //
            // We have to use a normal "copy" read.  We need to allocate
            // a separate raw buffer.
            //

            ASSERT( minorFunction == 0 );
            WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

            rawBuffer = ALLOCATE_NONPAGED_POOL(
                            readLength,
                            BlockTypeDataBuffer
                            );
            IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

            if ( rawBuffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadRaw: Unable to allocate raw "
                                "buffer\n" ));
                }

                goto error_exit_cleanup;

            }

            //
            // We also need a buffer descriptor.
            //
            // *** Note: Currently, ResponseBuffer == RequestBuffer in a
            //     WorkContext block, so we don't really have to save
            //     the ResponseBuffer field.  But we do so just to be on
            //     the safe side.
            //

            WorkContext->Parameters.ReadRaw.SavedResponseBuffer =
                                             WorkContext->ResponseBuffer;

            WorkContext->ResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                            sizeof(BUFFER),
                                            BlockTypeBuffer
                                            );

            if ( WorkContext->ResponseBuffer == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvSmbReadRaw: Unable to allocate %d bytes from "
                    "nonpaged pool.",
                    sizeof(BUFFER),
                    NULL
                    );

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

                WorkContext->ResponseBuffer =
                      WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                goto error_exit_cleanup;

            }

            WorkContext->ResponseBuffer->Buffer = rawBuffer;
            WorkContext->ResponseBuffer->BufferLength = readLength;

            //
            // Finally, we need an MDL to describe the raw buffer.
            //
            // *** We used to try to use the PartialMdl for the SMB
            //     buffer here, if it was big enough.  But since we
            //     already decided that the buffer itself isn't big
            //     enough, it's extremely likely that the MDL isn't big
            //     enough either.
            //

            mdl = IoAllocateMdl( rawBuffer, readLength, FALSE, FALSE, NULL );

            if ( mdl == NULL ) {

                DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
                WorkContext->ResponseBuffer =
                   WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

                goto error_exit_cleanup;

            }

            WorkContext->ResponseBuffer->Mdl = mdl;

            //
            // Build the mdl
            //

            MmBuildMdlForNonPagedPool( mdl );

            //
            // Try the fast I/O path first.
            //

            if ( lfcb->FastIoRead != NULL ) {

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

                try {
                    if ( lfcb->FastIoRead(
                            lfcb->FileObject,
                            &offset,
                            readLength,
                            TRUE,
                            key,
                            WorkContext->ResponseBuffer->Buffer,
                            &WorkContext->Irp->IoStatus,
                            lfcb->DeviceObject
                            ) ) {

                        //
                        // The fast I/O path worked.  Send the data.
                        //
                        WorkContext->bAlreadyTrace = TRUE;
                        SrvFsdRestartReadRaw( WorkContext );
                        SmbStatus = SmbStatusInProgress;
                        goto Cleanup;
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    status = GetExceptionCode();
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

            }

            //
            // The fast I/O path failed, so we need to use a regular copy
            // I/O request.
            //

        } else {

            goto do_copy_read;
        }

    } // read fits in SMB buffer?

    //
    // Build the read request, reusing the receive IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_READ,                    // major function code
            minorFunction,                  // minor function code
            rawBuffer,                      // buffer address
            readLength,                     // buffer length
            mdl,                            // MDL address
            offset,                         // byte offset
            key                             // lock key
            );

    //
    // Pass the request to the file system.
    //
    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbReadRaw: reading from file 0x%p, offset %ld, length %ld, destination 0x%p, ",
                    lfcb->FileObject, offset.LowPart, readLength,
                    rawBuffer ));
        KdPrint(( "func 0x%lx\n", minorFunction ));
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing
    // resumes in the FSD at SrvFsdRestartReadRaw.
    //

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbReadRaw complete\n" ));
    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error_exit_no_cleanup_locked:

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

error_exit_no_cleanup:

    WorkContext->ResponseParameters = WorkContext->ResponseHeader;

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsRejected );

    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

error_exit_cleanup:

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    //
    // We are about to release the work context and possibly free the
    // connection.  Create a referenced pointer to the connection so
    // that we can send delayed oplock breaks, if necessary.
    //

    SrvReferenceConnectionLocked( connection );

    //
    // Since we cannot return an error code, we return zero bytes of
    // data.
    //

    WorkContext->ResponseParameters = WorkContext->ResponseHeader;

    //
    // If there is an oplock break request pending, then we must go to the
    // FSP to initiate the break, otherwise complete processing in the FSD.
    //

    if ( IsListEmpty( &connection->OplockWorkList ) ) {
        connection->RawReadsInProgress--;
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvFsdSendResponse( WorkContext );
    } else {
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvFsdSendResponse2( WorkContext, SrvRestartReadRawComplete );
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsRejected );

    //
    // Release the connection reference.
    //

    SrvDereferenceConnection( connection );
    SmbStatus = SmbStatusInProgress;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbReadRaw complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbReadRaw

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteRaw (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write Block Raw SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description of the
        parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_WRITE_RAW request;
    PREQ_NT_WRITE_RAW ntRequest;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb = NULL;
    PLFCB lfcb;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone = FALSE;
    USHORT fid;
    PCHAR writeAddress;
    ULONG writeLength;
    ULONG key;
    SHARE_TYPE shareType;
    LARGE_INTEGER offset;
    PWORK_CONTEXT rawWorkContext;
    PVOID finalResponseBuffer = NULL;
    PCONNECTION connection;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
    SrvWmiStartContext(WorkContext);

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawWritesAttempted );

    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_RAW)WorkContext->RequestParameters;
    fid = SmbGetUshort( &request->Fid );

    //
    // If the client is MS-NET 1.03 or before, reject him.  We don't
    // support raw writes from these clients.
    //

    connection = WorkContext->Connection;
    if ( connection->SmbDialect >= SmbDialectMsNet103 ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "Raw write request from MS-NET 1.03 client.\n" ));
        }
        status = STATUS_SMB_USE_STANDARD;
        goto error_exit_no_rfcb;
    }

    IF_SMB_DEBUG(RAW1) {
        KdPrint(( "Write Block Raw request; FID 0x%lx, count %ld, "
                    "offset %ld, immediate length %ld\n",
                    fid,
                    SmbGetUshort( &request->Count ),
                    SmbGetUlong( &request->Offset ),
                    SmbGetUshort( &request->DataLength ) ));
    }

    immediateLength = SmbGetUshort( &request->DataLength );
    writeLength = SmbGetUshort( &request->Count );

    //
    // make sure the immediate length:
    //      is not greater than the total bytes, and
    //      does not go beyond what we are given
    //

    if ( ( immediateLength > writeLength ) ||
         ( immediateLength > ( WorkContext->ResponseBuffer->DataLength -
                                    SmbGetUshort(&request->DataOffset) ) )
       ) {

        status = STATUS_INVALID_SMB;
        goto error_exit_no_rfcb;
    }

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // address is stored in the WorkContext block, and the RFCB address
    // is returned.  In addition, the active raw write count is
    // incremented.
    //

    //
    // See if the fid matches the cached fid.
    //

    rfcb = SrvVerifyFidForRawWrite(
                WorkContext,
                fid,
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteRaw: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            goto error_exit_no_rfcb;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    if( lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }

    //
    // Validate the word count.
    //

    if ( shareType == ShareTypePipe ) {

        if ( (request->WordCount != 12) && (request->WordCount != 14) ) {
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

    } else {

        if ( request->WordCount == 12 ) {

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 14 ) {

            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh ) ;
            offset.LowPart = SmbGetUlong( &ntRequest->Offset ) ;

            //
            // Reject negative offsets.  Add the offset to the immediate
            // length and make sure that the result is not negative. We do the
            // first check ( highpart >= 0x7fffffff ) so that in most cases
            // we do only one check.
            //

            if ( (ULONG)offset.HighPart >= (ULONG)0x7fffffff &&
                 ( (offset.QuadPart < 0) ||
                   ((offset.QuadPart + immediateLength) < 0) ) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbWriteRaw: Negative offset rejected.\n"));
                }

                status = STATUS_INVALID_SMB;
                goto error_exit;
            }

        } else {

            status = STATUS_INVALID_SMB;
            goto error_exit;
        }
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: Read access not granted.\n"));
        }
        status = STATUS_ACCESS_DENIED;
        goto error_exit;
    }

    //
    // Ensure that the write is extending the file if the user only has append access
    //
    if( !rfcb->WriteAccessGranted &&
        offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: Only append access to file allowed!\n" ));
        }

        SrvStatistics.GrantedAccessErrors++;
        status = STATUS_ACCESS_DENIED;
        goto error_exit;
    }

    rfcb->WrittenTo = TRUE;

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.  Note that we do NOT write immediate data -- this is the
    // same behavior as the OS/2 server.
    //
    // !!! Implement the pause comm device test.
    //

    if ( rfcb->BlockingModePipe ) {

        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Reject the request.
            //
            // !!!  Consider routing the request to the FSP, instead.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbWriteRaw: No resources for blocking "
                            "write\n" ));
            }

            SrvFailedBlockingIoCount++;
            SrvStatistics.BlockingSmbsRejected++;
            status = STATUS_SMB_USE_STANDARD;
            goto error_exit;

        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    } else if ( shareType == ShareTypeDisk &&
         ( ((ULONG)request->WriteMode & SMB_WMODE_WRITE_THROUGH) << 1 !=
           ((ULONG)lfcb->FileMode & FILE_WRITE_THROUGH) ) ) {

        //
        // Change the write through mode of the file, if necessary.
        //

        ASSERT( SMB_WMODE_WRITE_THROUGH == 0x01 );
        ASSERT( FILE_WRITE_THROUGH == 0x02 );

        SrvSetFileWritethroughMode(
            lfcb,
            (BOOLEAN)( (SmbGetUshort( &request->WriteMode )
                            & SMB_WMODE_WRITE_THROUGH) != 0 )
            );
    }

    //
    // If immediate data was sent write it first.
    //
    // If this is a named pipe, do not write the data unless all of the
    // write data was sent in the original request.  We cannot do the
    // write in 2 parts, in case this is a message mode pipe.
    //
    // *** Note that this is different from the OS/2 server.  It turns
    //     out to be easier for us to write the immediate data first,
    //     rather than copying it into a staging buffer pending receipt
    //     of the raw write data.  This is largely due to using MDL
    //     writes -- we don't allocate a staging buffer when we do an
    //     MDL write.
    //

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to
    //     account for the folding of multiple remote
    //     compatibility mode opens into a single local
    //     open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );


    if ( immediateLength != 0 ) {

        if ( (shareType != ShareTypePipe) ||
             (SmbGetUshort( &request->Count ) == (USHORT)immediateLength) ) {

            if ( lfcb->FastIoWrite != NULL ) {

                writeAddress = (PCHAR)WorkContext->RequestHeader +
                                        SmbGetUshort( &request->DataOffset );

                INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

                try {
                    immediateWriteDone = lfcb->FastIoWrite(
                                            lfcb->FileObject,
                                            &offset,
                                            immediateLength,
                                            TRUE,
                                            key,
                                            writeAddress,
                                            &WorkContext->Irp->IoStatus,
                                            lfcb->DeviceObject
                                            );
                    IF_SMB_DEBUG(RAW2) {
                        KdPrint(( "SrvSmbWriteRaw: fast immediate write %s\n",
                                immediateWriteDone ? "worked" : "failed" ));
                    }

                    if ( immediateWriteDone ) {
                        writeLength -= immediateLength;
                        offset.QuadPart += immediateLength;
                    } else {
                        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );
                    }
                }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    // Fall through to the slow path on an exception
                    status = GetExceptionCode();
                    immediateWriteDone = FALSE;
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );
                    IF_DEBUG(ERRORS) {
                        KdPrint(("FastIoRead threw exception %x\n", status ));
                    }
                }

            }

        }

    } else {

        immediateWriteDone = TRUE;

    }

    //
    // If the remaining write length is 0 (strange but legal), send a
    // success response.
    //

    if ( writeLength == 0 ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "PrepareRawWrite: No raw data !?!\n" ));
        }
        status = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // Reject Raw write if:
    //      raw mode has been disabled, or
    //      connection is unreliable, or
    //      file is non-cached and it is a write behind and it is a disk
    //          file (this condition is necessary to prevent a client
    //          from getting old data back when it does a raw read
    //          immediately after a raw write.  This can result in
    //          synchronization problems.
    //

    if ( !SrvEnableRawMode ||
         !connection->EnableRawIo ) {

        IF_SMB_DEBUG(RAW1) {
            KdPrint(( "SrvSmbWriteRaw: Raw mode is disabled\n" ));
        }

        //
        // Update server statistics.
        //

        status =  STATUS_SMB_USE_STANDARD;
        goto error_exit;
    }

    //
    // Obtain a raw mode work item from the raw mode pool.  If none are
    // available, ask the client to use a standard write request.
    //

    rawWorkContext = SrvGetRawModeWorkItem( );

    if ( rawWorkContext == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteRaw: No raw mode work items "
                        "available\n" ));
        }

        SrvOutOfRawWorkItemCount++;

        status =  STATUS_SMB_USE_STANDARD;
        goto error_exit;

    }

    IF_SMB_DEBUG(RAW2) KdPrint(( "rawWorkContext: 0x%p\n", rawWorkContext ));

    //
    // If writethough mode was specified, we'll need to send a final
    // response SMB.  Allocate a nonpaged buffer to contain the
    // response.  If this fails, ask the client to use a standard write
    // request.
    //

    if ( (SmbGetUshort( &request->WriteMode ) &
                                        SMB_WMODE_WRITE_THROUGH) != 0 ) {

        finalResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                sizeof(SMB_HEADER) +
                                    SIZEOF_SMB_PARAMS(RESP_WRITE_COMPLETE,0),
                                BlockTypeDataBuffer
                                );
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "finalResponseBuffer: 0x%p\n", finalResponseBuffer ));
        }

        if ( finalResponseBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbWriteRaw: Unable to allocate %d bytes from "
                    "nonpaged pool",
                sizeof(SMB_HEADER) + SIZEOF_SMB_PARAMS(RESP_WRITE_COMPLETE,0),
                NULL
            );

            SrvRequeueRawModeWorkItem( rawWorkContext );

            status = STATUS_SMB_USE_STANDARD;
            goto error_exit;
        }
    }

    //
    // Save necessary context information in the additional work context
    // block.
    //

    rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer = finalResponseBuffer;
    rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone = immediateWriteDone;
    rawWorkContext->Parameters.WriteRaw.ImmediateLength = immediateLength;

    rawWorkContext->Parameters.WriteRaw.Offset = offset;

    rawWorkContext->Parameters.WriteRaw.Pid =
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    WorkContext->Parameters.WriteRawPhase1.RawWorkContext = rawWorkContext;

    //
    // Copy the start time from the original work context.  Indicate
    // that no statistics should be saved from the original, and what
    // kind of statistics should be saved from the raw work context.
    //

    rawWorkContext->StartTime = 0;

    //
    // Copy pointers from the original work context to the raw work
    // context, referencing as necessary.
    //

    rawWorkContext->Endpoint = WorkContext->Endpoint; // not a referenced ptr

    rawWorkContext->Connection = connection;
    SrvReferenceConnection( connection );

    rawWorkContext->Share = NULL;
    rawWorkContext->Session = NULL;
    rawWorkContext->TreeConnect = NULL;

    rawWorkContext->Rfcb = rfcb;
    SrvReferenceRfcb( rfcb );

    //
    // Prepare either a copy write or an MDL write, as appropriate.
    //
    if ( !(lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

        //
        // The file system doesn't support MDL write.  Prepare a copy
        // write.
        //

        rawWorkContext->Parameters.WriteRaw.MdlWrite = FALSE;

        PrepareRawCopyWrite( WorkContext );
        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // The file system supports MDL write.  Prepare an MDL write.
    //

    rawWorkContext->Parameters.WriteRaw.MdlWrite = TRUE;
    rawWorkContext->Parameters.WriteRaw.Length = writeLength;

    //
    // Try the fast path first.
    //

    WorkContext->Irp->MdlAddress = NULL;
    WorkContext->Irp->IoStatus.Information = 0;
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: trying fast path for offset %ld, "
                    "length %ld\n", offset.LowPart, writeLength ));
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

    if ( lfcb->PrepareMdlWrite &&
         lfcb->PrepareMdlWrite(
            lfcb->FileObject,
            &offset,
            writeLength,
            key,
            &WorkContext->Irp->MdlAddress,
            &WorkContext->Irp->IoStatus,
            lfcb->DeviceObject
            ) && WorkContext->Irp->MdlAddress != NULL ) {

        //
        // The fast I/O path worked.  Send the go-ahead response.
        //

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvSmbWriteRaw: fast path worked; MDL %p, length 0x%p\n", WorkContext->Irp->MdlAddress,
                        (PVOID)WorkContext->Irp->IoStatus.Information ));
            DumpMdlChain( WorkContext->Irp->MdlAddress );
        }
#endif
        WorkContext->bAlreadyTrace = TRUE;
        SrvFsdRestartPrepareRawMdlWrite( WorkContext );
        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    //
    // The fast I/O path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // The fast path may have partially succeeded, returning a partial
    // MDL chain.  We need to adjust our write request to account for
    // that.
    //

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: fast path failed; MDL %p, length 0x%p\n", WorkContext->Irp->MdlAddress,
                    (PVOID)WorkContext->Irp->IoStatus.Information ));
    }

    offset.QuadPart += WorkContext->Irp->IoStatus.Information;
    writeLength -= (ULONG)WorkContext->Irp->IoStatus.Information;

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            IRP_MJ_WRITE,                       // major function code
            IRP_MN_MDL,                         // minor function code
            NULL,                               // buffer address (ignored)
            writeLength,                        // buffer length
            WorkContext->Irp->MdlAddress,       // MDL address
            offset,                             // byte offset
            key                                 // lock key
            );

    //
    // Pass the request to the file system.
    //

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvSmbWriteRaw: write to file 0x%p, offset %ld, length %ld\n",
                    lfcb->FileObject, offset.LowPart, writeLength ));
    }

        WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartPrepareRawMdlWrite;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The MDL write has been started.  When it completes, processing
    // resumes at SrvFsdRestartPrepareRawMdlWrite.
    //

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
    SmbStatus = SmbStatusInProgress;
    goto Cleanup;

error_exit:

    SrvDecrementRawWriteCount( rfcb );

error_exit_no_rfcb:

    SrvFsdBuildWriteCompleteResponse(
                                WorkContext,
                                status,
                                immediateWriteDone ? immediateLength : 0
                                );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawWritesRejected );
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbWriteRaw complete\n" ));
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbWriteRaw

VOID SRVFASTCALL
AbortRawWrite(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Handles cleanup when a raw write is aborted after the interim
    "go-ahead" response has been sent.  This routine is only used
    when a catastrophic errors occurs -- for example, the connection
    is closing.  It does not send a final response to the client.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

        This must be a pointer to the raw mode work item -- not the
        original work item that received the Write Raw SMB.

Return Value:

    None.

--*/

{
    PMDL cacheMdl;
    PMDL partialMdl;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Deallocate the final response buffer, if any.
    //

    if ( WorkContext->Parameters.WriteRaw.FinalResponseBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL(
            WorkContext->Parameters.WriteRaw.FinalResponseBuffer
            );
        WorkContext->Parameters.WriteRaw.FinalResponseBuffer = NULL;
    }

    if ( !WorkContext->Parameters.WriteRaw.MdlWrite ) {

        //
        // This was a copy write.  Deallocate the raw receive buffer.
        // Note that we do not need to unlock the raw buffer, because it
        // was allocated out of nonpaged pool and locked using
        // MmBuildMdlForNonPagedPool, which doesn't increment reference
        // counts and therefore has no inverse.
        //

        if ( WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
            DEALLOCATE_NONPAGED_POOL( WorkContext->RequestBuffer->Buffer );
        } else {
            DEALLOCATE_NONPAGED_POOL(
                (PCHAR)WorkContext->RequestBuffer->Buffer -
                        WorkContext->Parameters.WriteRaw.ImmediateLength );
        }

        //
        // Dereference control blocks and requeue the raw mode work
        // item.
        //

        WorkContext->ResponseBuffer->Buffer = NULL;
        SrvRestartWriteCompleteResponse( WorkContext );
        return;

    }

    //
    // This was an MDL write.  If a partial MDL was built (because of
    // immediate data), unmap it.  Then complete the MDL write,
    // indicating that no data was actually written.
    //

    cacheMdl = WorkContext->Parameters.WriteRaw.FirstMdl;
    partialMdl = WorkContext->Irp->MdlAddress;

    if ( partialMdl != cacheMdl ) {
        ASSERT( (partialMdl->MdlFlags & MDL_PARTIAL) != 0 );
        MmPrepareMdlForReuse( partialMdl );
    }

#if DBG
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "AbortRawWrite: Completing MDL write with length 0\n" ));
        DumpMdlChain( cacheMdl );
    }
#endif

    if( WorkContext->Rfcb->Lfcb->MdlWriteComplete == NULL ||

        WorkContext->Rfcb->Lfcb->MdlWriteComplete(
           WorkContext->Rfcb->Lfcb->FileObject,
           &WorkContext->Parameters.WriteRaw.Offset,
           cacheMdl,
           WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

        status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                             cacheMdl,
                                             IRP_MJ_WRITE,
                                             &WorkContext->Parameters.WriteRaw.Offset,
                                             WorkContext->Parameters.WriteRaw.Length
                                           );

        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
        }
    }

    SrvRestartWriteCompleteResponse( WorkContext );

    return;

} // AbortRawWrite


VOID SRVFASTCALL
PrepareRawCopyWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Prepares for a raw "copy" write.  Allocates a buffer to receive the
    raw data, prepares a work context block and an IRP describing the
    raw receive, queues it to the connection, and sends a "go-ahead"
    response.

    Any immediate data sent in the request SMB has already been written
    when this routine is called, unless this is a named pipe write, in
    which case the immediate data has not been written.  In this case,
    we alllocate a buffer big enough for the the immediate data plus the
    raw data, then copy the immediate data to the raw buffer before
    proceeding.  The raw data will be received appended to the immediate
    data.  Then both peices can be written with a single write.  This is
    needed so that data written to a message mode pipe will not be
    written in 2 pieces.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT rawWorkContext;
    PREQ_WRITE_RAW request;
    PRESP_WRITE_RAW_INTERIM response;

    NTSTATUS status;
    PVOID rawBuffer;
    PCHAR writeAddress;
    PMDL mdl;
    SHARE_TYPE shareType;
    PVOID finalResponseBuffer;

    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    ULONG writeLength;
    ULONG bufferLength;

    BOOLEAN sendWriteComplete = TRUE;

    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - PrepareRawCopyWrite\n" ));

    //
    // Set up local variables.
    //

    rawWorkContext = WorkContext->Parameters.WriteRawPhase1.RawWorkContext;
    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;
    shareType = rawWorkContext->Rfcb->ShareType;
    immediateLength = rawWorkContext->Parameters.WriteRaw.ImmediateLength;
    immediateWriteDone =
                    rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone;
    writeLength = SmbGetUshort( &request->Count ) - immediateLength;
    finalResponseBuffer =
        rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    if ( !immediateWriteDone ) {
        bufferLength = writeLength + immediateLength;
    } else {
        bufferLength = writeLength;
    }

    //
    // Allocate a nonpaged buffer to contain the write data.  If this
    // fails, ask the client to use a standard write request.
    //

    rawBuffer = ALLOCATE_NONPAGED_POOL( bufferLength, BlockTypeDataBuffer );
    IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

    if ( rawBuffer == NULL ) {

        // !!! Should we log this error?

        IF_DEBUG(ERRORS) {
            KdPrint(( "PrepareRawCopyWrite: Unable to allocate "
                        "raw buffer\n" ));
        }

        status = STATUS_SMB_USE_STANDARD;
        goto abort;

    }

    if ( !immediateWriteDone ) {

        //
        // Copy the immediate data to the raw buffer.
        //

        writeAddress = (PCHAR)WorkContext->RequestHeader +
                                        SmbGetUshort( &request->DataOffset );

        RtlCopyMemory( rawBuffer, writeAddress, immediateLength );

        //
        // Move the virtual start of the raw buffer to the end of the
        // immediate data.
        //

        rawBuffer = (PCHAR)rawBuffer + immediateLength;

    }

    //
    // If a final response is going to be sent, save information from
    // the request in the final response buffer.
    //

    if ( finalResponseBuffer != NULL ) {
        RtlCopyMemory(
            (PSMB_HEADER)finalResponseBuffer,
            WorkContext->RequestHeader,
            sizeof(SMB_HEADER)
            );
    }

    //
    // Set up the buffer descriptor for the raw buffer.
    //

    rawWorkContext->RequestBuffer->Buffer = rawBuffer;
    rawWorkContext->RequestBuffer->BufferLength = writeLength;

    //
    // Initialize the MDL to describe the raw buffer.
    // (SrvBuildIoControlRequest will lock the buffer for I/O.)
    //

    mdl = rawWorkContext->RequestBuffer->Mdl;

    MmInitializeMdl( mdl, rawBuffer, writeLength );

    //
    // Build the mdl
    //

    MmBuildMdlForNonPagedPool( mdl );

    //
    // Set up the restart routines in the work context block.
    //

    rawWorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    rawWorkContext->FspRestartRoutine = SrvRestartRawReceive;

    //
    // Build the I/O request packet.
    //

    (VOID)SrvBuildIoControlRequest(
            rawWorkContext->Irp,                // input IRP address
            NULL,                               // target file object address
            rawWorkContext,                     // context
            IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
            TDI_RECEIVE,                        // minor function
            NULL,                               // input buffer address
            0,                                  // input buffer length
            rawBuffer,                          // output buffer address
            writeLength,                        // output buffer length
            mdl,                                // MDL address
            NULL
            );

    irpSp = IoGetNextIrpStackLocation( rawWorkContext->Irp );

    //
    // If this is a writebehind write, tell the transport that we don't
    // plan to reply to the received message.
    //

    if ( finalResponseBuffer == NULL ) {
        ((PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters)->ReceiveFlags |=
                                                TDI_RECEIVE_NO_RESPONSE_EXP;
    }

    //
    // Post the receive.
    //

    irpSp->Flags = 0;
    irpSp->DeviceObject = rawWorkContext->Connection->DeviceObject;
    irpSp->FileObject = rawWorkContext->Connection->FileObject;

    ASSERT( rawWorkContext->Irp->StackCount >= irpSp->DeviceObject->StackSize );

    (VOID)IoCallDriver( irpSp->DeviceObject, rawWorkContext->Irp );

    //
    // Build the interim (go-ahead) response.
    //

    response = (PRESP_WRITE_RAW_INTERIM)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_RAW_INTERIM,
                                        0
                                        );

    //
    // Send off the interim response by ending processing of the SMB.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "PrepareRawCopyWrite complete\n" ));
    return;

abort:

    //
    // For one reason or another, we are not going to receive any raw
    // data, so clean up.
    //
    if ( finalResponseBuffer != NULL ) {
        DEALLOCATE_NONPAGED_POOL( finalResponseBuffer );
    }

    SrvRestartWriteComple