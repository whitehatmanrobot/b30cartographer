if (ValueIndex != Index)
            {
                ValueCol++;
            }
            ValueIndex = Index+1;
        }
        ++Index;
    }

    if (!ValueIndex || !pLineTxt[CurCol]) // cursor on address column
    {
        free (pLineTxt);
        return 0;
    }

    ULONG Bytes;
    Bytes = (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits + 7) / 8;

    ULONG64 Offset;
    Offset = m_OffsetRead + (CurLine * Bytes * m_Columns) + (ValueCol - 1)*Bytes;

    for (Index = ValueIndex; pLineTxt[Index] && pLineTxt[Index] != ' '; Index++) ;
    memcpy(m_ValueExpr, pLineTxt+ValueIndex, Index - ValueIndex);
    m_ValueExpr[Index-ValueIndex]=0;

    free (pLineTxt);
    if (pCharIndex)
    {
        *pCharIndex = FirstLineChar + CurCol;
    }
    if (pCRange)
    {
        pCRange->cpMin = FirstLineChar + CurCol - (CurCol - ValueIndex);
        pCRange->cpMax = pCRange->cpMin + Index - ValueIndex;
    }
    return Offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\memwin.h ===
struct _FORMATS_MEM_WIN {
    DWORD   cBits;
    FMTTYPE fmtType;
    DWORD   radix;
    DWORD   fTwoFields;
    DWORD   cchMax;
    PTSTR   lpszDescription;
};

extern _FORMATS_MEM_WIN g_FormatsMemWin[];
extern const int g_nMaxNumFormatsMemWin;





//
// Enum type and string identifier
//
extern struct _INTERFACE_TYPE_NAMES {
    INTERFACE_TYPE  type;
    PTSTR           psz;
} rgInterfaceTypeNames[MaximumInterfaceType];

extern struct _BUS_TYPE_NAMES {
    BUS_DATA_TYPE   type;
    PTSTR           psz;
} rgBusTypeNames[MaximumBusDataType];


struct GEN_MEMORY_DATA {
    MEMORY_TYPE memtype;
    int         nDisplayFormat;
    ANY_MEMORY_DATA any;
};

#define IDC_MEM_PREVIOUS 1234
#define IDC_MEM_NEXT     1235


class MEMWIN_DATA : public EDITWIN_DATA {
public:
    char            m_OffsetExpr[MAX_OFFSET_EXPR];
    BOOL            m_UpdateExpr;
    ULONG64         m_OffsetRead;
    GEN_MEMORY_DATA m_GenMemData;
    HWND            m_FormatCombo;
    HWND            m_PreviousButton;
    HWND            m_NextButton;
    ULONG           m_Columns;
    BOOL            m_AllowWrite;
    BOOL            m_UpdateValue;
    char            m_ValueExpr[MAX_OFFSET_EXPR];
    ULONG           m_WindowDataSize;

    MEMWIN_DATA();

    virtual void Validate();

    virtual BOOL HasEditableProperties();
    virtual BOOL EditProperties();

    virtual HRESULT ReadState(void);

    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    void ScrollLower(void);
    void ScrollHigher(void);
    
    void WriteValue(ULONG64 Offset);
    void UpdateOptions(void);
    ULONG64 GetAddressOfCurValue(
        PULONG pCharIndex,
        CHARRANGE *pCRange
        );
};
typedef MEMWIN_DATA *PMEMWIN_DATA;





INT_PTR
DisplayOptionsPropSheet(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    MEMORY_TYPE         memtypeStartPage
    );

















#if 0



#define MAX_CHUNK_TOREAD 4096 // maximum chunk of memory to read at one go


LRESULT
CALLBACK
MemoryEditProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

/*
void ViewMem(int view, BOOL fVoidCache);


extern TCHAR   memText[MAX_MSG_TXT]; //the selected text for memory dlg
*/

struct memItem {
    char    iStart;
    char    cch;
    char    iFmt;
};

struct memWinDesc {
    int     iFormat;
    ATOM    atmAddress;
    BOOL    fLive;
    BOOL    fHaveAddr;
    BOOL    fBadRead;               // dis we really read mem or just ??
    PTSTR   lpbBytes;
    memItem *lpMi;
    UINT    cMi;
    BOOL    fEdit;
    BOOL    fFill;
    UINT    cPerLine;
    //ADDR    addr;
    //ADDR    orig_addr;
    //ADDR    old_addr;
    TCHAR   szAddress[MAX_MSG_TXT]; //the mem address expression in ascii
    UINT    cbRead;
};

/*
extern struct memWinDesc    MemWinDesc[MAX_VIEWS];
extern struct memWinDesc    TempMemWinDesc;

//
//  Define the set of memory formats
//

enum {
    MW_ASCII = 0,
    MW_BYTE,
    MW_SHORT,
    MW_SHORT_HEX,
    MW_SHORT_UNSIGNED,
    MW_LONG,
    MW_LONG_HEX,
    MW_LONG_UNSIGNED,
    MW_QUAD,
    MW_QUAD_HEX,
    MW_QUAD_UNSIGNED,
    MW_REAL,
    MW_REAL_LONG,
    MW_REAL_TEN
};
*/

#if 0
#define MEM_FORMATS {\
            1,  /* ASCII */ \
            1,  /* BYTE  */ \
            2,  /* SHORT */ \
            2,  /* SHORT_HEX */ \
            2,  /* SHORT_UNSIGNED */ \
            4,  /* LONG */ \
            4,  /* LONG_HEX */ \
            4,  /* LONG_UNSIGNED */ \
            8,  /* QUAD */ \
            8,  /* QUAD_HEX */ \
            8,  /* QUAD_UNSIGNED */ \
            4,  /* REAL */ \
            8,  /* REAL_LONG */ \
           10,  /* REAL_TEN */ \
           16   /*  */ \
} 
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\miscdbg.cpp ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    miscdbg.cpp

Abstract:

    Contains code to aid in internal debugging.

--*/

#include "precomp.hxx"
#pragma hdrstop


#ifdef DBG

VOID
Dbg_Windbg_InitializeCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszName,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    InitializeCriticalSection( &pDbgCritSec->cs );
    pDbgCritSec->Initialize(pszName);
}


BOOL
Dbg_Windbg_TryEnterCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    BOOL b = TryEnterCriticalSection( &pDbgCritSec->cs );
    
    if (b) {
        ++pDbgCritSec->nLockCount;
        pDbgCritSec->OwnerId = GetCurrentThreadId();

        DPRINT(DP_CRITSEC_VERBOSE, 
               ( _T(" *** TryEnterCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );

        pDbgCritSec->pszLock_LastFile = pszFile;
        pDbgCritSec->nLock_LastFile = nLine;
    }

    if (pDbgCritSec->nLockCount++ > 1) {
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Locked twice. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }

    return b;
}


VOID
Dbg_Windbg_EnterCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    if (pDbgCritSec->nLockCount
        && GetCurrentThreadId() != pDbgCritSec->OwnerId ) {
        
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Waiting on another thread. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }
    
    EnterCriticalSection( &pDbgCritSec->cs );

    pDbgCritSec->OwnerId = GetCurrentThreadId();
    pDbgCritSec->pszLock_LastFile = pszFile;
    pDbgCritSec->nLock_LastFile = nLine;

    if (pDbgCritSec->nLockCount++ > 1) {
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Locked twice. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }

    DPRINT(DP_CRITSEC_VERBOSE, 
           ( _T(" *** Dbg_EnterCriticalSection \'%s\' %s %d\n"), 
           pDbgCritSec->pszName,
           pszFile, 
           nLine
           ) );
}


VOID
Dbg_Windbg_LeaveCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    DPRINT(DP_CRITSEC_VERBOSE, 
           ( _T(" *** Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
           pDbgCritSec->pszName,
           pszFile, 
           nLine
           ) );

    if (GetCurrentThreadId() != pDbgCritSec->OwnerId ) {
        
        DPRINT(DP_CRITSEC_ERROR, 
               ( _T(" *** ERROR: Not owner. Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );

        Assert(!"API lock released when not owned");
    }
    if (pDbgCritSec->nLockCount < 1) {

        DPRINT(DP_CRITSEC_ERROR, 
               ( _T(" *** ERROR: Count is 0. Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );
        Assert(!"API Lock released when count is 0");

    } else {
        if (--pDbgCritSec->nLockCount == 0) {
            pDbgCritSec->OwnerId = 0;
        }
        LeaveCriticalSection(&pDbgCritSec->cs);
    }

    pDbgCritSec->pszUnlock_LastFile = pszFile;
    pDbgCritSec->nUnlock_LastFile = nLine;
}


VOID
Dbg_Windbg_DeleteCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    DeleteCriticalSection( &pDbgCritSec->cs );
    pDbgCritSec->Delete();
}

#endif // DBG



VOID
DebugPrint(
    PTSTR szFormat,
    ...
    )
{
    __declspec( thread ) static TCHAR   rgchDebug[1024 * 4];
    __declspec( thread ) static va_list marker;

    va_start( marker, szFormat );

    _vsntprintf(rgchDebug, _tsizeof(rgchDebug), szFormat, marker);
    rgchDebug[_tsizeof(rgchDebug) - 1] = 0;

    va_end( marker);

    OutputDebugString( rgchDebug );
}                               /* DebugPrint() */



#ifdef _CPPRTTI
BOOL
RttiTypesEqual(
    const type_info & t1, 
    const type_info & t2
    )
{
    return t1 == t2;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\menu.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Menu.h

Abstract:

    This module contains the function prototypes and identifiers for
    Windbg's menus and menu items.

--*/


//
// Offset from the bottom of the menu to the popup menu
//
//
//
//      File
//      |----------------|
//      | Open           |
//
//          etc....
//
//      |----------------|
//      | MRU Files     >|       GetMenuItemCount() - 4
//      | MRU Files     >|       GetMenuItemCount() - 3
//      |----------------|       GetMenuItemCount() - 2
//      | Exit           |       GetMenuItemCount() - 1
//      |----------------|
//



// Top-level popup menus must start at this value and
// be separated by this value.
// MENU_SIGNATURE is also added in.
#define IDM_BASE 100

//
// Width of names in File and Program menu.
//
#define FILES_MENU_WIDTH            ( 72 )

enum
{
    FILE_USE_UNUSED,
    FILE_USE_SOURCE,
    FILE_USE_DUMP,
    FILE_USE_EXECUTABLE,
};

#define MAX_MRU_FILES 16

struct MRU_ENTRY
{
    ULONG FileUse;
    // This array actually contains the full name, rounded
    // to an even multiple of four bytes.
    TCHAR FileName[4];
};

extern MRU_ENTRY* g_MruFiles[];
extern HMENU g_MruMenu;

VOID
InitializeMenu(
    IN HMENU hmenu
    );

UINT
CommandIdEnabled(
    IN UINT uMenuID
    );

VOID AddFileToMru(ULONG FileUse, PTSTR File);
ULONG GetMruSize(void);
PUCHAR ReadMru(PUCHAR Data, PUCHAR End);
PUCHAR WriteMru(PUCHAR Data);

//
// Menu Resource Signature
//

#define MENU_SIGNATURE              0x4000


//
// File
//

#define IDM_FILE                    ( 100 | MENU_SIGNATURE )
#define IDM_FILE_OPEN               ( IDM_FILE + 1 )
#define IDM_FILE_CLOSE              ( IDM_FILE + 2 )
// Separator.
#define IDM_FILE_OPEN_EXECUTABLE    ( IDM_FILE + 4 )
#define IDM_FILE_ATTACH             ( IDM_FILE + 5 )
#define IDM_FILE_OPEN_CRASH_DUMP    ( IDM_FILE + 6 )
#define IDM_FILE_CONNECT_TO_REMOTE  ( IDM_FILE + 7 )
#define IDM_FILE_KERNEL_DEBUG       ( IDM_FILE + 8 )
// Separator.
#define IDM_FILE_SYMBOL_PATH        ( IDM_FILE + 10 )
#define IDM_FILE_SOURCE_PATH        ( IDM_FILE + 11 )
#define IDM_FILE_IMAGE_PATH         ( IDM_FILE + 12 )
// Separator.
#define IDM_FILE_OPEN_WORKSPACE     ( IDM_FILE + 14 )
#define IDM_FILE_SAVE_WORKSPACE     ( IDM_FILE + 15 )
#define IDM_FILE_SAVE_WORKSPACE_AS  ( IDM_FILE + 16 )
#define IDM_FILE_CLEAR_WORKSPACE    ( IDM_FILE + 17 )
#define IDM_FILE_DELETE_WORKSPACES  ( IDM_FILE + 18 )
#define IDM_FILE_OPEN_WORKSPACE_FILE ( IDM_FILE + 19 )
#define IDM_FILE_SAVE_WORKSPACE_FILE ( IDM_FILE + 20 )
// Separator.
#define IDM_FILE_MAP_NET_DRIVE      ( IDM_FILE + 22 )
#define IDM_FILE_DISCONN_NET_DRIVE  ( IDM_FILE + 23 )
// Separator.

// MRUs must be in sequential order. That way a position can be
// calculated by: IDM_FILE_MRU_FILE5 - IDM_FILE_MRU_FILE1, etc...
#define IDM_FILE_MRU_FILE1          ( IDM_FILE + 25 )
#define IDM_FILE_MRU_FILE2          ( IDM_FILE_MRU_FILE1 + 1  )
#define IDM_FILE_MRU_FILE3          ( IDM_FILE_MRU_FILE1 + 2  )
#define IDM_FILE_MRU_FILE4          ( IDM_FILE_MRU_FILE1 + 3  )
#define IDM_FILE_MRU_FILE5          ( IDM_FILE_MRU_FILE1 + 4  )
#define IDM_FILE_MRU_FILE6          ( IDM_FILE_MRU_FILE1 + 5  )
#define IDM_FILE_MRU_FILE7          ( IDM_FILE_MRU_FILE1 + 6  )
#define IDM_FILE_MRU_FILE8          ( IDM_FILE_MRU_FILE1 + 7  )
#define IDM_FILE_MRU_FILE9          ( IDM_FILE_MRU_FILE1 + 8  )
#define IDM_FILE_MRU_FILE10         ( IDM_FILE_MRU_FILE1 + 9  )
#define IDM_FILE_MRU_FILE11         ( IDM_FILE_MRU_FILE1 + 10 )
#define IDM_FILE_MRU_FILE12         ( IDM_FILE_MRU_FILE1 + 11 )
#define IDM_FILE_MRU_FILE13         ( IDM_FILE_MRU_FILE1 + 12 )
#define IDM_FILE_MRU_FILE14         ( IDM_FILE_MRU_FILE1 + 13 )
#define IDM_FILE_MRU_FILE15         ( IDM_FILE_MRU_FILE1 + 14 )
#define IDM_FILE_MRU_FILE16         ( IDM_FILE_MRU_FILE1 + 15 )

// ditto. same as above
#define IDM_FILE_MRU_WORKSPACE1     ( IDM_FILE_MRU_FILE16 + 1 )
#define IDM_FILE_MRU_WORKSPACE2     ( IDM_FILE_MRU_WORKSPACE1 + 1  )
#define IDM_FILE_MRU_WORKSPACE3     ( IDM_FILE_MRU_WORKSPACE1 + 2  )
#define IDM_FILE_MRU_WORKSPACE4     ( IDM_FILE_MRU_WORKSPACE1 + 3  )
#define IDM_FILE_MRU_WORKSPACE5     ( IDM_FILE_MRU_WORKSPACE1 + 4  )
#define IDM_FILE_MRU_WORKSPACE6     ( IDM_FILE_MRU_WORKSPACE1 + 5  )
#define IDM_FILE_MRU_WORKSPACE7     ( IDM_FILE_MRU_WORKSPACE1 + 6  )
#define IDM_FILE_MRU_WORKSPACE8     ( IDM_FILE_MRU_WORKSPACE1 + 7  )
#define IDM_FILE_MRU_WORKSPACE9     ( IDM_FILE_MRU_WORKSPACE1 + 8  )
#define IDM_FILE_MRU_WORKSPACE10    ( IDM_FILE_MRU_WORKSPACE1 + 9  )
#define IDM_FILE_MRU_WORKSPACE11    ( IDM_FILE_MRU_WORKSPACE1 + 10 )
#define IDM_FILE_MRU_WORKSPACE12    ( IDM_FILE_MRU_WORKSPACE1 + 11 )
#define IDM_FILE_MRU_WORKSPACE13    ( IDM_FILE_MRU_WORKSPACE1 + 12 )
#define IDM_FILE_MRU_WORKSPACE14    ( IDM_FILE_MRU_WORKSPACE1 + 13 )
#define IDM_FILE_MRU_WORKSPACE15    ( IDM_FILE_MRU_WORKSPACE1 + 14 )
#define IDM_FILE_MRU_WORKSPACE16    ( IDM_FILE_MRU_WORKSPACE1 + 15 )

// Included temporarily
#define IDM_FILE_EXIT               ( IDM_FILE_MRU_WORKSPACE16 + 1)
#define IDM_FILE_FIRST              IDM_FILE
#define IDM_FILE_LAST               IDM_FILE_EXIT


//
// Edit
//

#define IDM_EDIT                    ( 200 | MENU_SIGNATURE )
#define IDM_EDIT_CUT                ( IDM_EDIT + 1 )
#define IDM_EDIT_COPY               ( IDM_EDIT + 2 )
#define IDM_EDIT_PASTE              ( IDM_EDIT + 3 )
#define IDM_EDIT_SELECT_ALL         ( IDM_EDIT + 4 )
#define IDM_EDIT_WRITE_TEXT_TO_FILE ( IDM_EDIT + 5 )
#define IDM_EDIT_ADD_TO_COMMAND_HISTORY ( IDM_EDIT + 6 )
#define IDM_EDIT_CLEAR_COMMAND_HISTORY ( IDM_EDIT + 7 )
#define IDM_EDIT_FIND               ( IDM_EDIT + 8 )
#define IDM_EDIT_FIND_NEXT          ( IDM_EDIT + 9 )
#define IDM_EDIT_GOTO_ADDRESS       ( IDM_EDIT + 10 )
#define IDM_EDIT_GOTO_LINE          ( IDM_EDIT + 11 )
#define IDM_EDIT_GOTO_CURRENT_IP    ( IDM_EDIT + 12 )
#define IDM_EDIT_BREAKPOINTS        ( IDM_EDIT + 13 )
#define IDM_EDIT_TOGGLEBREAKPOINT   ( IDM_EDIT + 14 )
#define IDM_EDIT_LOG_FILE           ( IDM_EDIT + 15 )
#define IDM_EDIT_PROPERTIES         ( IDM_EDIT + 16 )
#define IDM_EDIT_FIRST              IDM_EDIT
#define IDM_EDIT_LAST               IDM_EDIT_PROPERTIES


//
// View
//

#define IDM_VIEW                    ( 300 | MENU_SIGNATURE )
#define IDM_VIEW_WATCH              ( IDM_VIEW + 1 )
#define IDM_VIEW_CALLSTACK          ( IDM_VIEW + 2 )
#define IDM_VIEW_MEMORY             ( IDM_VIEW + 3 )
#define IDM_VIEW_LOCALS             ( IDM_VIEW + 4 )
#define IDM_VIEW_REGISTERS          ( IDM_VIEW + 5 )
#define IDM_VIEW_DISASM             ( IDM_VIEW + 6 )
#define IDM_VIEW_COMMAND            ( IDM_VIEW + 7 )
#define IDM_VIEW_SCRATCH            ( IDM_VIEW + 8 )
#define IDM_VIEW_PROCESS_THREAD     ( IDM_VIEW + 9 )
#define IDM_VIEW_TOGGLE_VERBOSE     ( IDM_VIEW + 10 )
#define IDM_VIEW_SHOW_VERSION       ( IDM_VIEW + 11 )
#define IDM_VIEW_TOOLBAR            ( IDM_VIEW + 12 )
#define IDM_VIEW_STATUS             ( IDM_VIEW + 13 )
#define IDM_VIEW_FONT               ( IDM_VIEW + 14 )
#define IDM_VIEW_COLORS             ( IDM_VIEW + 15 )
#define IDM_VIEW_OPTIONS            ( IDM_VIEW + 16 )
#define IDM_VIEW_FIRST              IDM_VIEW
#define IDM_VIEW_LAST               IDM_VIEW_OPTIONS


//
// Debug
//

#define IDM_DEBUG                   ( 400 | MENU_SIGNATURE )
#define IDM_DEBUG_GO                ( IDM_DEBUG + 1 )
#define IDM_DEBUG_GO_HANDLED        ( IDM_DEBUG + 2 )
#define IDM_DEBUG_GO_UNHANDLED      ( IDM_DEBUG + 3 )
#define IDM_DEBUG_RESTART           ( IDM_DEBUG + 4 )
#define IDM_DEBUG_STOPDEBUGGING     ( IDM_DEBUG + 5 )
#define IDM_DEBUG_BREAK             ( IDM_DEBUG + 6 )
#define IDM_DEBUG_STEPINTO          ( IDM_DEBUG + 7 )
#define IDM_DEBUG_STEPOVER          ( IDM_DEBUG + 8 )
#define IDM_DEBUG_STEPOUT           ( IDM_DEBUG + 9 )
#define IDM_DEBUG_RUNTOCURSOR       ( IDM_DEBUG + 10 )
#define IDM_DEBUG_SOURCE_MODE       ( IDM_DEBUG + 11 )
#define IDM_DEBUG_EVENT_FILTERS     ( IDM_DEBUG + 12 )
#define IDM_DEBUG_MODULES           ( IDM_DEBUG + 13 )
#define IDM_DEBUG_KDEBUG            ( IDM_DEBUG + 14 )

// These are not used by the menu but by the toolbar
#define IDM_DEBUG_SOURCE_MODE_ON    ( IDM_DEBUG + 15 )
#define IDM_DEBUG_SOURCE_MODE_OFF   ( IDM_DEBUG + 16 )

// Not used by the toolbar or menu, but by the accelerator table
#define IDM_DEBUG_CTRL_C            ( IDM_DEBUG + 17 )

#define IDM_DEBUG_FIRST             IDM_DEBUG
#define IDM_DEBUG_LAST              IDM_DEBUG_KDEBUG


//
// Window
//

#define IDM_WINDOW                  ( 500 | MENU_SIGNATURE )
#define IDM_WINDOW_CASCADE          ( IDM_WINDOW + 1 )
#define IDM_WINDOW_TILE_HORZ        ( IDM_WINDOW + 2 )
#define IDM_WINDOW_TILE_VERT        ( IDM_WINDOW + 3 )
#define IDM_WINDOW_ARRANGE          ( IDM_WINDOW + 4 )
#define IDM_WINDOW_ARRANGE_ICONS    ( IDM_WINDOW + 5 )
#define IDM_WINDOW_CLOSE_ALL_DOCWIN ( IDM_WINDOW + 6 )
#define IDM_WINDOW_AUTO_ARRANGE     ( IDM_WINDOW + 7 )
#define IDM_WINDOW_ARRANGE_ALL      ( IDM_WINDOW + 8 )
#define IDM_WINDOW_OVERLAY_SOURCE   ( IDM_WINDOW + 9 )
#define IDM_WINDOW_AUTO_DISASM      ( IDM_WINDOW + 10 )
#define IDM_WINDOWCHILD             ( IDM_WINDOW + 11 )
#define IDM_WINDOW_FIRST            IDM_WINDOW
#define IDM_WINDOW_LAST             IDM_WINDOWCHILD



//
// Help
//

#define IDM_HELP                    ( 600 | MENU_SIGNATURE )
#define IDM_HELP_CONTENTS           ( IDM_HELP + 1 )
#define IDM_HELP_INDEX              ( IDM_HELP + 2 )
#define IDM_HELP_SEARCH             ( IDM_HELP + 3 )
#define IDM_HELP_ABOUT              ( IDM_HELP + 4 )
#define IDM_HELP_FIRST              IDM_HELP
#define IDM_HELP_LAST               IDM_HELP_ABOUT



//
// Debug.Kernel submenu.
//

#define IDM_KDEBUG                  ( 10000 | MENU_SIGNATURE )
#define IDM_KDEBUG_TOGGLE_BAUDRATE  ( IDM_KDEBUG + 1 )
#define IDM_KDEBUG_TOGGLE_DEBUG     ( IDM_KDEBUG + 2 )
#define IDM_KDEBUG_TOGGLE_INITBREAK ( IDM_KDEBUG + 3 )
#define IDM_KDEBUG_RECONNECT        ( IDM_KDEBUG + 4 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\menu.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Menu.c

Abstract:

    This module contains the support for Windbg's menu.

--*/

#include "precomp.hxx"
#pragma hdrstop

MRU_ENTRY* g_MruFiles[MAX_MRU_FILES];
HMENU g_MruMenu;

//
// EnableMenuItemTable contains the menu IDs for all menu items whose
// enabled state needs to be determined dynamically i.e. based on the state
// of Windbg.
//

UINT
g_EnableMenuItemTable[ ] =
{
    IDM_FILE_CLOSE,
    IDM_FILE_OPEN_EXECUTABLE,
    IDM_FILE_ATTACH,
    IDM_FILE_OPEN_CRASH_DUMP,
    IDM_FILE_CONNECT_TO_REMOTE,
    IDM_FILE_KERNEL_DEBUG,
    IDM_FILE_SAVE_WORKSPACE,
    IDM_FILE_SAVE_WORKSPACE_AS,
    IDM_FILE_CLEAR_WORKSPACE,
    IDM_FILE_SAVE_WORKSPACE_FILE,

    IDM_EDIT_CUT,
    IDM_EDIT_COPY,
    IDM_EDIT_PASTE,
    IDM_EDIT_SELECT_ALL,
    IDM_EDIT_WRITE_TEXT_TO_FILE,
    IDM_EDIT_ADD_TO_COMMAND_HISTORY,
    IDM_EDIT_CLEAR_COMMAND_HISTORY,
    IDM_EDIT_FIND,
    IDM_EDIT_FIND_NEXT,
    IDM_EDIT_GOTO_ADDRESS,
    IDM_EDIT_GOTO_LINE,
    IDM_EDIT_GOTO_CURRENT_IP,
    IDM_EDIT_BREAKPOINTS,
    IDM_EDIT_PROPERTIES,

    IDM_VIEW_TOGGLE_VERBOSE,
    IDM_VIEW_SHOW_VERSION,

    IDM_DEBUG_GO,
    IDM_DEBUG_GO_UNHANDLED,
    IDM_DEBUG_GO_HANDLED,
    IDM_DEBUG_RESTART,
    IDM_DEBUG_STOPDEBUGGING,
    IDM_DEBUG_BREAK,
    IDM_DEBUG_STEPINTO,
    IDM_DEBUG_STEPOVER,
    IDM_DEBUG_STEPOUT,
    IDM_DEBUG_RUNTOCURSOR,
    IDM_DEBUG_SOURCE_MODE,
    IDM_DEBUG_SOURCE_MODE_ON,
    IDM_DEBUG_SOURCE_MODE_OFF,
    IDM_DEBUG_EVENT_FILTERS,
    IDM_DEBUG_MODULES,
    IDM_KDEBUG_TOGGLE_BAUDRATE,
    IDM_KDEBUG_TOGGLE_INITBREAK,
    IDM_KDEBUG_RECONNECT,

    IDM_WINDOW_CASCADE,
    IDM_WINDOW_TILE_HORZ,
    IDM_WINDOW_TILE_VERT,
    IDM_WINDOW_ARRANGE,
    IDM_WINDOW_ARRANGE_ICONS,
    IDM_WINDOW_CLOSE_ALL_DOCWIN,
    IDM_WINDOW_AUTO_ARRANGE,
    IDM_WINDOW_ARRANGE_ALL,
    IDM_WINDOW_OVERLAY_SOURCE,
    IDM_WINDOW_AUTO_DISASM,
};

#define ELEMENTS_IN_ENABLE_MENU_ITEM_TABLE          \
    ( sizeof( g_EnableMenuItemTable ) / sizeof( g_EnableMenuItemTable[ 0 ] ))


UINT
CommandIdEnabled(
    IN UINT uMenuID
    )

/*++

Routine Description:

    Determines if a menu item is enabled/disabled based on the current
    state of the debugger.

Arguments:

    uMenuID - Supplies a menu id whose state is to be determined.

Return Value:

    UINT - Returns ( MF_ENABLED | MF_BYCOMMAND ) if the supplied menu ID
        is enabled, ( MF_GRAYED | MF_BYCOMMAND) otherwise.

--*/
{
    BOOL fEnabled;
    HWND hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
    PCOMMONWIN_DATA pCommonWinData;
    WIN_TYPES nDocType;

    nDocType = MINVAL_WINDOW;
    pCommonWinData = NULL;
    if (hwndChild != NULL)
    {
        pCommonWinData = GetCommonWinData(hwndChild);
        if (pCommonWinData != NULL)
        {
            nDocType = pCommonWinData->m_enumType;
        }
    }


    //
    // Assume menu item is not enabled.
    //

    fEnabled = FALSE;

    switch( uMenuID )
    {
    case IDM_FILE_SAVE_WORKSPACE:
    case IDM_FILE_SAVE_WORKSPACE_AS:
    case IDM_FILE_CLEAR_WORKSPACE:
    case IDM_FILE_SAVE_WORKSPACE_FILE:
        fEnabled = g_Workspace != NULL;
        break;
        
    case IDM_DEBUG_SOURCE_MODE:
    case IDM_DEBUG_SOURCE_MODE_ON:
    case IDM_DEBUG_SOURCE_MODE_OFF:
        fEnabled = TRUE;

        CheckMenuItem(g_hmenuMain, 
                      IDM_DEBUG_SOURCE_MODE,
                      GetSrcMode_StatusBar() ? MF_CHECKED : MF_UNCHECKED
                      );
        break;

    case IDM_FILE_CLOSE:
        fEnabled = (NULL != hwndChild);
        break;

    case IDM_FILE_OPEN_EXECUTABLE:
        if (g_ProcessServer)
        {
            // We can't provide a remote file browsing dialog
            // so just disable this option when a process
            // server is active.  In the future we could
            // potentially provide a simple dialog where
            // you could type a command line.
            fEnabled = FALSE;
            break;
        }
        // Fall through.
    case IDM_FILE_ATTACH:
    case IDM_FILE_OPEN_CRASH_DUMP:
    case IDM_FILE_CONNECT_TO_REMOTE:
    case IDM_FILE_KERNEL_DEBUG:
        fEnabled = g_TargetClass == DEBUG_CLASS_UNINITIALIZED &&
            !g_RemoteClient;
        break;

    case IDM_EDIT_CUT:
        if ( pCommonWinData )
        {
            fEnabled = pCommonWinData->CanCut();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_COPY:
        if ( pCommonWinData )
        {
            fEnabled = pCommonWinData->CanCopy();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_PASTE:
        //
        // If the window is normal, is not read only and is a document
        // or cmdwin, determine if the clipboard contains pastable data
        // (i.e. clipboard format CF_TEXT).
        //

        if ( !(pCommonWinData && pCommonWinData->CanPaste()) )
        {
            fEnabled = FALSE;
        }
        else
        {
            fEnabled = FALSE;
            if (OpenClipboard(g_hwndFrame))
            {
                UINT uFormat = 0;
                while ( uFormat = EnumClipboardFormats( uFormat ))
                {
                    if ( uFormat == CF_TEXT )
                    {
                        fEnabled = TRUE;
                        break;
                    }
                }
                CloseClipboard();
            }
        }
        break;

    case IDM_EDIT_SELECT_ALL:
        if (pCommonWinData)
        {
            fEnabled = pCommonWinData->CanSelectAll();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_WRITE_TEXT_TO_FILE:
        if (pCommonWinData)
        {
            fEnabled = pCommonWinData->CanWriteTextToFile();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;
        
    case IDM_EDIT_ADD_TO_COMMAND_HISTORY:
    case IDM_EDIT_CLEAR_COMMAND_HISTORY:
        fEnabled = GetCmdHwnd() != NULL;
        break;

    case IDM_EDIT_GOTO_LINE:
        fEnabled = pCommonWinData != NULL && pCommonWinData->CanGotoLine();
        break;
        
    case IDM_EDIT_FIND:
    case IDM_EDIT_FIND_NEXT:
        fEnabled = hwndChild != NULL;
        break;
        
    case IDM_EDIT_GOTO_ADDRESS:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;
        
    case IDM_EDIT_GOTO_CURRENT_IP:
    case IDM_EDIT_BREAKPOINTS:
        fEnabled = IS_TARGET_HALTED();
        break;
        
    case IDM_EDIT_PROPERTIES:
        if (pCommonWinData)
        {
            fEnabled = pCommonWinData->HasEditableProperties();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_VIEW_TOGGLE_VERBOSE:
    case IDM_VIEW_SHOW_VERSION:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;
        
    case IDM_DEBUG_GO:
    case IDM_DEBUG_GO_HANDLED:
    case IDM_DEBUG_GO_UNHANDLED:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_RESTART:
        // If no debuggee is running we can only restart if
        // enough information was given on the command line.
        fEnabled =
            (g_TargetClass == DEBUG_CLASS_UNINITIALIZED &&
             g_CommandLineStart == 1) ||
            (g_TargetClass != DEBUG_CLASS_UNINITIALIZED &&
             !g_RemoteClient &&
             IS_TARGET_HALTED());
        break;

    case IDM_DEBUG_STOPDEBUGGING:
        // Technically we can support stopping while the
        // debuggee is running, but that will generally
        // require terminating the engine thread as it
        // will most likely be busy and not able to
        // quickly exit to stop.  If we terminate the
        // engine thread at a random point it may
        // leave the engine in an unstable or locked state,
        // so restrict restarts to situations where
        // the engine thread should be available.
        fEnabled = g_RemoteClient || IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_BREAK:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;

    case IDM_DEBUG_STEPINTO:
    case IDM_DEBUG_STEPOVER:
    case IDM_DEBUG_STEPOUT:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_RUNTOCURSOR:
        //
        // If the document can return a code address for
        // its cursor it is a candidate for run-to-cursor.
        //

        fEnabled = FALSE;

        if (IS_TARGET_HALTED() && pCommonWinData)
        {
            fEnabled = pCommonWinData->CodeExprAtCaret(NULL, 0, NULL) == S_OK;
        }
        break;

    case IDM_DEBUG_EVENT_FILTERS:
    case IDM_DEBUG_MODULES:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_KDEBUG_TOGGLE_BAUDRATE:
    case IDM_KDEBUG_TOGGLE_INITBREAK:
    case IDM_KDEBUG_RECONNECT:
        fEnabled = g_TargetClass == DEBUG_CLASS_KERNEL &&
            g_TargetClassQual == DEBUG_KERNEL_CONNECTION;
        break;
        
    case IDM_WINDOW_CASCADE:
    case IDM_WINDOW_TILE_HORZ:
    case IDM_WINDOW_TILE_VERT:
    case IDM_WINDOW_ARRANGE:
    case IDM_WINDOW_ARRANGE_ICONS:
    case IDM_WINDOW_CLOSE_ALL_DOCWIN:
        fEnabled = hwndChild != NULL;
        break; 

    case IDM_WINDOW_AUTO_ARRANGE:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_AUTO_ARRANGE,
                      g_WinOptions & WOPT_AUTO_ARRANGE ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_ARRANGE_ALL:        
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_ARRANGE_ALL,
                      g_WinOptions & WOPT_ARRANGE_ALL ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_OVERLAY_SOURCE:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_OVERLAY_SOURCE,
                      g_WinOptions & WOPT_OVERLAY_SOURCE ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_AUTO_DISASM:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_AUTO_DISASM,
                      g_WinOptions & WOPT_AUTO_DISASM ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_FILE_OPEN:
    case IDM_VIEW_COMMAND:
    case IDM_VIEW_WATCH:
    case IDM_VIEW_CALLSTACK:
    case IDM_VIEW_MEMORY:
    case IDM_VIEW_LOCALS:
    case IDM_VIEW_REGISTERS:
    case IDM_VIEW_DISASM:
    case IDM_VIEW_SCRATCH:
    case IDM_VIEW_TOOLBAR:
    case IDM_VIEW_STATUS:
    case IDM_VIEW_FONT:
    case IDM_VIEW_OPTIONS:
    case IDM_EDIT_TOGGLEBREAKPOINT:
    case IDM_EDIT_LOG_FILE:
        // These items are not dynamically enabled
        // but are present in the toolbar.  The toolbar
        // code requests enable state for every item on it
        // so these entries need to be present to return TRUE.
        fEnabled = TRUE;
        break;
    
    default:
        DebugPrint("CommandIdEnabled: Unhandled %d (%X)\n",
                   uMenuID, uMenuID - MENU_SIGNATURE);
        // We should have handled everything.
        Assert(0);
        break;
    }

    ToolbarIdEnabled(uMenuID, fEnabled);

    return (( fEnabled ) ? MF_ENABLED : MF_GRAYED ) | MF_BYCOMMAND;
}





VOID
InitializeMenu(
    IN HMENU hMenu
    )

/*++

Routine Description:

    InitializeMenu sets the enabled/disabled state of all menu items whose
    state musr be determined dynamically.

Arguments:

    hMenu - Supplies a handle to the menu bar.

Return Value:

    None.

--*/

{
    INT     i;

    Dbg(hMenu);

    //
    // Iterate thrrough the table, enabling/disabling menu items
    // as appropriate.
    //

    for ( i = 0; i < ELEMENTS_IN_ENABLE_MENU_ITEM_TABLE; i++ )
    {
        EnableMenuItem(hMenu,
                       g_EnableMenuItemTable[ i ],
                       CommandIdEnabled( g_EnableMenuItemTable[ i ])
                       );
    }
}

ULONG
MruEntrySize(PTSTR File)
{
    ULONG Len = strlen(File) + 1;
    return sizeof(MRU_ENTRY) + (Len & ~3);
}

void
ClearMruMenu(void)
{
    while (GetMenuItemCount(g_MruMenu) > 0)
    {
        if (!DeleteMenu(g_MruMenu, 0, MF_BYPOSITION))
        {
            break;
        }
    }
}

VOID
AddFileToMru(ULONG FileUse, PTSTR File)
{
    ULONG Len = MruEntrySize(File);
    MRU_ENTRY* Entry = (MRU_ENTRY*)malloc(Len);
    if (Entry == NULL)
    {
        return;
    }

    if (g_MruFiles[0] == NULL)
    {
        // MRU list is empty.  Delete placeholder menu entry.
        ClearMruMenu();
    }
    else if (g_MruFiles[MAX_MRU_FILES - 1] != NULL)
    {
        // MRU list is full, free up the oldest entry.
        free(g_MruFiles[MAX_MRU_FILES - 1]);
    }

    // Push entries down.
    memmove(g_MruFiles + 1, g_MruFiles,
            (MAX_MRU_FILES - 1) * sizeof(*g_MruFiles));

    g_MruFiles[0] = Entry;
    Entry->FileUse = FileUse;
    strcpy(Entry->FileName, File);

    //
    // Insert file in MRU menu.
    //

    MENUITEMINFO Item;
    ULONG i;

    ZeroMemory(&Item, sizeof(Item));
    Item.cbSize = sizeof(Item);

    // Renumber existing items and remove any excess.
    i = GetMenuItemCount(g_MruMenu);
    while (i-- > 0)
    {
        if (i >= MAX_MRU_FILES)
        {
            DeleteMenu(g_MruMenu, i, MF_BYPOSITION);
        }
        else
        {
            Item.fMask = MIIM_ID;
            GetMenuItemInfo(g_MruMenu, i, TRUE, &Item);
            Item.wID++;
            SetMenuItemInfo(g_MruMenu, i, TRUE, &Item);
        }
    }
    
    Item.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING;
    Item.fType = MFT_STRING;
    Item.wID = IDM_FILE_MRU_FILE1;
    Item.dwTypeData = g_MruFiles[0]->FileName;
    InsertMenuItem(g_MruMenu, 0, TRUE, &Item);
    
    DrawMenuBar(g_hwndFrame);

    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_MRU_LIST);
    }
}

void
ClearMru(void)
{
    ULONG i;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            free(g_MruFiles[i]);
            g_MruFiles[i] = NULL;
        }
        else
        {
            break;
        }
    }

    ClearMruMenu();
    DrawMenuBar(g_hwndFrame);
}

ULONG
GetMruSize(void)
{
    ULONG i;
    ULONG Size = 0;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            Size += MruEntrySize(g_MruFiles[i]->FileName);
        }
        else
        {
            break;
        }
    }

    return Size;
}

PUCHAR
ReadMru(PUCHAR Data, PUCHAR End)
{
    ClearMru();

    ULONG i;

    i = 0;
    while (Data < End)
    {
        MRU_ENTRY* DataEntry = (MRU_ENTRY*)Data;
        ULONG Len = MruEntrySize(DataEntry->FileName);
        
        g_MruFiles[i] = (MRU_ENTRY*)malloc(Len);
        if (g_MruFiles[i] == NULL)
        {
            Data = End;
            break;
        }

        g_MruFiles[i]->FileUse = DataEntry->FileUse;
        strcpy(g_MruFiles[i]->FileName, DataEntry->FileName);
        Data += Len;
        i++;
    }
        
    MENUITEMINFO Item;

    ZeroMemory(&Item, sizeof(Item));
    Item.cbSize = sizeof(Item);
    Item.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING;
    Item.fType = MFT_STRING;
    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] == NULL)
        {
            break;
        }
        
        Item.wID = IDM_FILE_MRU_FILE1 + i;
        Item.dwTypeData = g_MruFiles[i]->FileName;
        InsertMenuItem(g_MruMenu, i, TRUE, &Item);
    }
    
    DrawMenuBar(g_hwndFrame);
    
    return Data;
}

PUCHAR
WriteMru(PUCHAR Data)
{
    ULONG i;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            MRU_ENTRY* DataEntry = (MRU_ENTRY*)Data;
            ULONG Len = MruEntrySize(g_MruFiles[i]->FileName);

            DataEntry->FileUse = g_MruFiles[i]->FileUse;
            strcpy(DataEntry->FileName, g_MruFiles[i]->FileName);
            Data += Len;
        }
        else
        {
            break;
        }
    }
    
    return Data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\prcdlg.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    prcdlg.h

Abstract:

    Header file for dialog-related functions.

--*/

#ifndef _PRCDLG_H_
#define _PRCDLG_H_

#define SHORT_MSG 256

// Find dialog, if open.
extern HWND g_FindDialog;
// Find text.
extern char g_FindText[256];
extern ULONG g_FindTextFlags;
// Message code for FINDMSGSTRING.
extern UINT g_FindMsgString;
extern FINDREPLACE g_FindRep;
extern PCOMMONWIN_DATA g_FindLast;

extern char g_ComSettings[512];
extern char g_1394Settings[256];

PTSTR __cdecl BufferString(PTSTR Buffer, ULONG Size, ULONG StrId, ...);
void SendLockStatusMessage(HWND Win, UINT Msg, HRESULT Status);

BpStateType IsBpAtOffset(BpBufferData* DataIn, ULONG64 Offset, PULONG Id);

void StartKdPropSheet(void);

INT_PTR CALLBACK DlgProc_SetBreak(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ConnectToRemote(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SymbolPath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_RegCustomize(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_GotoLine(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_GotoAddress(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_LogFile(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_KernelCom(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Kernel1394(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_KernelLocal(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ImagePath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SourcePath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_AttachProcess(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_EventFilters(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ExceptionFilter(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_FilterArgument(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_FilterCommand(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Options(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ClearWorkspace(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Modules(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_OpenWorkspace(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SaveWorkspaceAs(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_AddToCommandHistory(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_DeleteWorkspaces(HWND, UINT, WPARAM, LPARAM);

extern TCHAR szOpenExeArgs[];
UINT_PTR OpenExeWithArgsHookProc(HWND, UINT, WPARAM, LPARAM);

BOOL CreateIndexedFont(ULONG FontIndex, BOOL SetAll);
void SelectFont(HWND Parent, ULONG FontIndex);

BOOL SelectColor(HWND Parent, ULONG Index);

#endif // #ifndef _PRCDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\prcmain.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    prcmain.cpp

Abstract:

    Contains the main window proc.

--*/

#include "precomp.hxx"
#pragma hdrstop

#define TOOLBAR_UPDATE_TIMER_ID 0x100

#define WINDBG_START_DLG_FLAGS (OFN_HIDEREADONLY |      \
                                OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST)

// Path of the last files opened from a file open dlg box.
TCHAR g_ExeFilePath[_MAX_PATH];
TCHAR g_DumpFilePath[_MAX_PATH];
TCHAR g_SrcFilePath[_MAX_PATH];
TCHAR g_WriteTextFilePath[_MAX_PATH];
TCHAR g_WorkspaceFilePath[_MAX_PATH];

BOOL g_fCheckFileDate;

// Last menu id & id state.
UINT g_LastMenuId;
UINT g_LastMenuIdState;

ULONG g_LastMapLetter;

void
ShowMapDlg(void)
{
    CONNECTDLGSTRUCT ConnDlg;
    NETRESOURCE NetRes;

    ZeroMemory(&NetRes, sizeof(NetRes));
    NetRes.dwType = RESOURCETYPE_DISK;
    ConnDlg.cbStructure = sizeof(ConnDlg);
    ConnDlg.hwndOwner = g_hwndFrame;
    ConnDlg.lpConnRes = &NetRes;
    ConnDlg.dwFlags = CONNDLG_USE_MRU;
    if (WNetConnectionDialog1(&ConnDlg) == NO_ERROR)
    {
        g_LastMapLetter = ConnDlg.dwDevNum;
    }
}

void
ShowDisconnDlg(void)
{
    WNetDisconnectDialog(g_hwndFrame, RESOURCETYPE_DISK);
}

void
SaveFileOpenPath(PTSTR Path, PTSTR Global, BOOL SaveWsp, ULONG WspIndex)
{
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    TCHAR NewPath[_MAX_PATH];

    _tsplitpath(Path, Drive, Dir, NULL, NULL);
    _tmakepath(NewPath, Drive, Dir, NULL, NULL);

    if (WspIndex == WSP_GLOBAL_SRC_FILE_PATH)
    {
        // We've just referenced an interesting source file
        // so make sure the path is added to the current source
        // path.
        g_pUiLocSymbols->AppendSourcePath(NewPath);
    }
    
    if (_strcmpi(NewPath, Global) != 0)
    {
        _tcscpy(Global, NewPath);
        if (SaveWsp && g_Workspace != NULL)
        {
            g_Workspace->SetString(WspIndex, Global);
        }
    }
}

/***    MainWndProc
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**  Processes window messages.
**
*/


LRESULT
CALLBACK
MainWndProc(
    HWND  hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static UINT s_MenuItemSelected;

    HWND CommonWin;
    PCOMMONWIN_DATA CommonWinData;
    HRESULT Status;
    ULONG OutMask;

    if (message == g_FindMsgString)
    {
        FINDREPLACE* FindRep = (FINDREPLACE*)lParam;

        if (g_FindLast != NULL)
        {
            // Clear old find.
            g_FindLast->Find(NULL, 0, TRUE);
            g_FindLast = NULL;
        }
        
        if (FindRep->Flags & FR_DIALOGTERM)
        {
            // Dialog has closed.
            g_FindDialog = NULL;
        }
        else
        {
            CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
            if (CommonWin != NULL &&
                (CommonWinData = GetCommonWinData(CommonWin)) != NULL)
            {
                g_FindTextFlags = FindRep->Flags &
                    (FR_DOWN | FR_MATCHCASE | FR_WHOLEWORD);
                CommonWinData->Find(FindRep->lpstrFindWhat,
                                    g_FindTextFlags, TRUE);
                g_FindLast = CommonWinData;
            }
        }

        return 0;
    }
    
    switch (message)
    {
    case WM_CREATE:
        {
            CLIENTCREATESTRUCT ccs;

            // Find window menu where children will be listed.
            ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd), WINDOWMENU);
            ccs.idFirstChild = IDM_FIRSTCHILD;

            // Create the MDI client filling the client area.
            g_hwndMDIClient = CreateWindow(_T("mdiclient"),
                                           NULL,
                                           WS_CHILD | WS_CLIPCHILDREN,
                                           0, 0, 0, 0,
                                           hwnd, 
                                           (HMENU) 0xCAC, 
                                           g_hInst, 
                                           (PTSTR)&ccs
                                           );
            if (g_hwndMDIClient == NULL)
            {
                return -1;
            }

            //
            // Nothing interesting, here, just
            // trying to turn the Toolbar & Status bar into a
            // black box, so that the variables, etc. aren't
            // scattered all over the place.
            //

            if (!CreateToolbar(hwnd))
            {
                return -1;
            }

            if (!CreateStatusBar(hwnd))
            {
                return -1;
            }

            ShowWindow(g_hwndMDIClient, SW_SHOW);
            InitializeMenu(GetMenu(hwnd));

            g_hmenuMain = GetMenu(hwnd);
            if (g_hmenuMain == NULL)
            {
                return -1;
            }

            //
            // Create a one second timer to constantly update the state of the toolbar
            //
            SetTimer(hwnd, TOOLBAR_UPDATE_TIMER_ID, 1000, NULL);
        }
        break;

    case WM_TIMER:
        EnableToolbarControls();
        return 0;

    case WM_NOTIFY:
        {
            if (lParam == 0)
            {
                break;
            }
            
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;

            switch (lpnmhdr->code)
            {
            case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT) lParam;

                    lpToolTipText->lpszText = GetToolTipTextFor_Toolbar
                        ((UINT) lpToolTipText->hdr.idFrom);
                }
                break;
            }
        }
        break;

    case WM_QUERYOPEN:
        if (g_fCheckFileDate)
        {
            g_fCheckFileDate = FALSE;
            PostMessage(g_hwndFrame, WM_ACTIVATEAPP, 1, 0L);
        }
        goto DefProcessing;

    case WM_COMMAND:
        {
            WORD wNotifyCode = HIWORD(wParam); // notification code
            WORD wItemId = LOWORD(wParam);     // item, control, or
                                               // accelerator identifier
            HWND hwndCtl = (HWND) lParam;      // handle of control

            switch (wItemId)
            {
            case IDM_FILE_OPEN_EXECUTABLE:
                {
                    PTSTR  Path;
                    DWORD  Flags = WINDBG_START_DLG_FLAGS;

                    ClearDebuggingParams();
                    
                    Path = (PTSTR)malloc(_MAX_PATH * 4 * sizeof(TCHAR));
                    if (Path == NULL)
                    {
                        break;
                    }
                    
                    *Path = 0;
                    
                    if (StartFileDlg(hwnd,
                                     DLG_Browse_Executable_Title,
                                     DEF_Ext_EXE,
                                     IDM_FILE_OPEN,
                                     IDD_DLG_FILEOPEN_EXPLORER_EXTENSION_EXE_ARGS,
                                     g_ExeFilePath,
                                     Path,
                                     &Flags,
                                     OpenExeWithArgsHookProc) &&
                        *Path)
                    {
                        CatString(Path, szOpenExeArgs, 4 * _MAX_PATH);

                        SetAllocString(&g_DebugCommandLine, Path);
                        if (g_ExplicitWorkspace && g_Workspace != NULL)
                        {
                            g_Workspace->
                                SetUlong(WSP_GLOBAL_EXE_CREATE_FLAGS,
                                         g_DebugCreateFlags);
                            g_Workspace->
                                SetString(WSP_GLOBAL_PROCESS_START_DIR,
                                          g_ProcessStartDir);
                            g_Workspace->
                                SetString(WSP_GLOBAL_EXE_COMMAND_LINE,
                                          Path);
                        }
                        SaveFileOpenPath(Path, g_ExeFilePath,
                                         TRUE, WSP_GLOBAL_EXE_FILE_PATH);
                        StartDebugging();
                    }

                    if (g_DebugCommandLine != Path)
                    {
                        free(Path);
                    }
                }
                break;

            case IDM_FILE_ATTACH:
                StartDialog(IDD_DLG_ATTACH_PROCESS, DlgProc_AttachProcess,
                            NULL);
                break;

            case IDM_FILE_OPEN_CRASH_DUMP:
                {
                    PTSTR  Path;
                    DWORD  Flags = WINDBG_START_DLG_FLAGS;

                    ClearDebuggingParams();
                    
                    Path = (PTSTR)malloc(_MAX_PATH * sizeof(TCHAR));
                    if (Path == NULL)
                    {
                        break;
                    }
                    
                    Dbg(LoadString(g_hInst, DEF_Dump_File,
                                   Path, _MAX_PATH));

                    if (StartFileDlg(hwnd,
                                     DLG_Browse_CrashDump_Title,
                                     DEF_Ext_DUMP,
                                     0,
                                     0,
                                     g_DumpFilePath,
                                     Path,
                                     &Flags,
                                     NULL))
                    {
                        SetAllocString(&g_DumpFiles[0], Path);
                        g_NumDumpFiles = 1;
                        if (g_ExplicitWorkspace && g_Workspace != NULL)
                        {
                            g_Workspace->
                                SetString(WSP_GLOBAL_DUMP_FILE_NAME,
                                          Path);
                        }
                        SaveFileOpenPath(Path, g_DumpFilePath,
                                         TRUE, WSP_GLOBAL_DUMP_FILE_PATH);
                        StartDebugging();
                    }

                    if (g_DumpFiles[0] != Path)
                    {
                        free(Path);
                    }
                }
                break;

            case IDM_FILE_CONNECT_TO_REMOTE:
                StartDialog(IDD_DLG_CONNECTTOREMOTE, DlgProc_ConnectToRemote,
                            NULL);
                break;

            case IDM_FILE_KERNEL_DEBUG:
                StartKdPropSheet();
                break;

            case IDM_FILE_SYMBOL_PATH:
                StartDialog(IDD_DLG_SYMBOLS, DlgProc_SymbolPath, NULL);
                break;

            case IDM_FILE_IMAGE_PATH:
                StartDialog(IDD_DLG_IMAGE_PATH, DlgProc_ImagePath, NULL);
                break;

            case IDM_FILE_SOURCE_PATH:
                StartDialog(IDD_DLG_SOURCE_PATH, DlgProc_SourcePath, NULL);
                break;

            case IDM_FILE_OPEN_WORKSPACE:
                StartDialog(IDD_DLG_WORKSPACE_IO, DlgProc_OpenWorkspace,
                            FALSE);
                break;
                
            case IDM_FILE_SAVE_WORKSPACE:
                // No prompt, because we know the user wants to save.
                if (g_Workspace != NULL)
                {
                    g_Workspace->Flush(TRUE, FALSE);
                }
                break;

            case IDM_FILE_SAVE_WORKSPACE_AS:
                if (g_Workspace != NULL)
                {
                    StartDialog(IDD_DLG_WORKSPACE_IO, DlgProc_SaveWorkspaceAs,
                                TRUE);
                }
                break;
                
            case IDM_FILE_CLEAR_WORKSPACE:
                StartDialog(IDD_DLG_CLEAR_WORKSPACE, DlgProc_ClearWorkspace,
                            NULL);
                break;

            case IDM_FILE_DELETE_WORKSPACES:
                StartDialog(IDD_DLG_DELETE_WORKSPACES,
                            DlgProc_DeleteWorkspaces, NULL);
                break;

            case IDM_FILE_OPEN_WORKSPACE_FILE:
                {
                    TCHAR Path[_MAX_PATH];
                    DWORD dwFlags = WINDBG_START_DLG_FLAGS;

                    Path[0] = 0;

                    if (!StartFileDlg(hwnd, 
                                      DLG_Open_Workspace_File_Title, 
                                      DEF_Ext_Workspace,
                                      IDM_FILE_OPEN, 
                                      0,
                                      g_WorkspaceFilePath,
                                      Path, 
                                      &dwFlags, 
                                      DlgFile
                                      ))
                    {
                        // User canceled, bail out
                        break;
                    }

                    SaveFileOpenPath(Path, g_WorkspaceFilePath,
                                     FALSE, 0);
                    UiSwitchToExplicitWorkspace(WSP_NAME_FILE, Path);
                }
                break;
                
            case IDM_FILE_SAVE_WORKSPACE_FILE:
                if (g_Workspace != NULL)
                {
                    TCHAR Path[_MAX_PATH];
                    DWORD dwFlags = OFN_HIDEREADONLY | OFN_CREATEPROMPT |
                        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

                    Path[0] = 0;

                    if (!StartFileDlg(hwnd, 
                                      DLG_Save_Workspace_File_Title, 
                                      DEF_Ext_Workspace,
                                      IDM_FILE_OPEN, 
                                      0,
                                      g_WorkspaceFilePath,
                                      Path, 
                                      &dwFlags, 
                                      DlgFile
                                      ))
                    {
                        // User canceled, bail out
                        break;
                    }

                    SaveFileOpenPath(Path, g_WorkspaceFilePath,
                                     FALSE, 0);
                    UiSaveWorkspaceAs(WSP_NAME_FILE, Path);
                }
                break;
                
            case IDM_FILE_MAP_NET_DRIVE:
                ShowMapDlg();
                break;
                    
            case IDM_FILE_DISCONN_NET_DRIVE:
                ShowDisconnDlg();
                break;
                    
            case IDM_FILE_MRU_FILE1:
            case IDM_FILE_MRU_FILE2:
            case IDM_FILE_MRU_FILE3:
            case IDM_FILE_MRU_FILE4:
            case IDM_FILE_MRU_FILE5:
            case IDM_FILE_MRU_FILE6:
            case IDM_FILE_MRU_FILE7:
            case IDM_FILE_MRU_FILE8:
            case IDM_FILE_MRU_FILE9:
            case IDM_FILE_MRU_FILE10:
            case IDM_FILE_MRU_FILE11:
            case IDM_FILE_MRU_FILE12:
            case IDM_FILE_MRU_FILE13:
            case IDM_FILE_MRU_FILE14:
            case IDM_FILE_MRU_FILE15:
            case IDM_FILE_MRU_FILE16:
            case IDM_FILE_OPEN:
                {
                    TCHAR Path[_MAX_PATH];

                    if (IDM_FILE_OPEN == wItemId)
                    {
                        DWORD dwFlags = WINDBG_START_DLG_FLAGS;

                        Path[0] = 0;

                        if (!StartFileDlg(hwnd, 
                                          DLG_Open_Filebox_Title, 
                                          DEF_Ext_SOURCE,
                                          IDM_FILE_OPEN, 
                                          0,
                                          g_SrcFilePath,
                                          Path, 
                                          &dwFlags, 
                                          DlgFile
                                          ))
                        {
                            // User canceled, bail out
                            break;
                        }
                    }
                    else
                    {
                        WORD wFileIdx = wItemId - IDM_FILE_MRU_FILE1;

                        // Sanity check
                        Assert(wFileIdx < MAX_MRU_FILES);

                        _tcscpy(Path, g_MruFiles[wFileIdx]->FileName);
                    }

                    OpenOrActivateFile(Path, NULL, NULL, -1, TRUE, TRUE);

                    SaveFileOpenPath(Path, g_SrcFilePath,
                                     TRUE, WSP_GLOBAL_SRC_FILE_PATH);
                }
                break;

            case IDM_FILE_CLOSE:
                {
                    HWND hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
                    if (hwndChild)
                    {
                        SendMessage(g_hwndMDIClient, WM_MDIDESTROY,
                                    (WPARAM)hwndChild, 0L);
                    }
                }
                break;

            case IDM_FILE_EXIT:
                PostMessage(hwnd, WM_CLOSE, 0, 0L);
                break;

            case IDM_EDIT_COPY:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Copy();
                }
                break;

            case IDM_EDIT_PASTE:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Paste();
                }
                break;

            case IDM_EDIT_CUT:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Cut();
                }
                break;

            case IDM_EDIT_SELECT_ALL:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin == NULL)
                {
                    return 0;
                }
                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData != NULL)
                {
                    CommonWinData->SelectAll();
                }
                break;

            case IDM_EDIT_WRITE_TEXT_TO_FILE:
                if ((CommonWin = MDIGetActive(g_hwndMDIClient, NULL)) &&
                    (CommonWinData = GetCommonWinData(CommonWin)) &&
                    CommonWinData->CanWriteTextToFile())
                {
                    DWORD dwFlags = OFN_HIDEREADONLY | OFN_CREATEPROMPT |
                        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
                    TCHAR Path[_MAX_PATH];
                    HANDLE File;

                    Path[0] = 0;

                    if (!StartFileDlg(hwnd, 
                                      DLG_Write_Text_File_Title, 
                                      DEF_Ext_TXT,
                                      0,
                                      0,
                                      g_WriteTextFilePath,
                                      Path, 
                                      &dwFlags, 
                                      DlgFile))
                    {
                        // User canceled, bail out
                        break;
                    }

                    File = CreateFile(Path, GENERIC_WRITE, 0, NULL,
                                      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                      NULL);
                    if (!File || File == INVALID_HANDLE_VALUE)
                    {
                        Status = WIN32_LAST_STATUS();
                        ErrorBox(NULL, 0, ERR_Create_File_Failed, Path,
                                 FormatStatusCode(Status),
                                 FormatStatus(Status));
                        break;
                    }

                    SaveFileOpenPath(Path, g_WriteTextFilePath,
                                     FALSE, 0);
                    
                    Status = CommonWinData->WriteTextToFile(File);
                    
                    CloseHandle(File);

                    if (Status != S_OK)
                    {
                        ErrorBox(NULL, 0, ERR_Write_Text_File_Failed,
                                 Path, FormatStatusCode(Status),
                                 FormatStatus(Status));
                        DeleteFile(Path);
                    }
                }
                break;
                
            case IDM_EDIT_ADD_TO_COMMAND_HISTORY:
                StartDialog(IDD_DLG_ADD_TO_COMMAND_HISTORY,
                            DlgProc_AddToCommandHistory, FALSE);
                break;
                
            case IDM_EDIT_CLEAR_COMMAND_HISTORY:
                ClearCmdWindow();
                break;

            case IDM_EDIT_FIND_NEXT:
                if (!g_FindDialog &&
                    g_FindText[0] &&
                    (CommonWin = MDIGetActive(g_hwndMDIClient, NULL)) &&
                    (CommonWinData = GetCommonWinData(CommonWin)))
                {
                    ULONG Flags = g_FindTextFlags;
                    
                    // Repeat the last search.  Invert
                    // the direction on shift.
                    if (GetKeyState(VK_SHIFT) < 0)
                    {
                        Flags ^= FR_DOWN;
                    }

                    CommonWinData->Find(g_FindText, Flags, FALSE);
                    break;
                }

                // Fall through.
                
            case IDM_EDIT_FIND:
                // FindNext box may already be there.
                if (g_FindDialog != NULL)
                {
                    SetFocus(g_FindDialog);
                }
                else
                {
                    CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                    if (CommonWin != NULL &&
                        (CommonWinData = GetCommonWinData(CommonWin)) != NULL)
                    {
                        CommonWinData->SelectedText(g_FindText,
                                                    DIMA(g_FindText));
                    }
                    
                    ZeroMemory(&g_FindRep, sizeof(g_FindRep));
                    g_FindRep.lStructSize = sizeof(g_FindRep);
                    g_FindRep.hwndOwner = g_hwndFrame;
                    g_FindRep.Flags = FR_DOWN;
                    g_FindRep.lpstrFindWhat = g_FindText;
                    g_FindRep.wFindWhatLen = DIMA(g_FindText);
                    g_FindDialog = FindText(&g_FindRep);
                }
                break;

            case IDM_EDIT_PROPERTIES:
                {
                    HWND hwndmdi = MDIGetActive(g_hwndMDIClient, NULL);
                    
                    if (hwndmdi) {
                        
                        MEMWIN_DATA * pMemWinData = GetMemWinData(hwndmdi);
                        Assert(pMemWinData);
                        
                        if ( pMemWinData->HasEditableProperties() ) {
                            if (pMemWinData->EditProperties()) {
                                pMemWinData->UiRequestRead();
                            }
                        }
                    }
                }
                break;

            case IDM_EDIT_GOTO_LINE:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin)
                {
                    CommonWinData = GetCommonWinData(CommonWin);
                    Assert(CommonWinData);
                    StartDialog(IDD_DLG_GOTO_LINE, DlgProc_GotoLine,
                                (LPARAM)CommonWinData);
                }
                break;

            case IDM_EDIT_GOTO_ADDRESS:
                StartDialog(IDD_DLG_GOTO_ADDRESS, DlgProc_GotoAddress, NULL);
                break;

            case IDM_EDIT_GOTO_CURRENT_IP:
                AddStringCommand(UIC_DISPLAY_CODE_EXPR, "@@masm(@$ip)");
                break;
                
            case IDM_VIEW_REGISTERS:
                New_OpenDebugWindow(CPU_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_WATCH:
                New_OpenDebugWindow(WATCH_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_LOCALS:
                New_OpenDebugWindow(LOCALS_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_DISASM:
                New_OpenDebugWindow(DISASM_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_COMMAND:
                New_OpenDebugWindow(CMD_WINDOW, FALSE, NTH_OPEN_ALWAYS); // Not user activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_MEMORY:
                New_OpenDebugWindow(MEM_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_CALLSTACK:
                New_OpenDebugWindow(CALLS_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_SCRATCH:
                New_OpenDebugWindow(SCRATCH_PAD_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_PROCESS_THREAD:
                New_OpenDebugWindow(PROCESS_THREAD_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_TOGGLE_VERBOSE:
                g_pUiClient->GetOtherOutputMask(g_pDbgClient, &OutMask);
                OutMask ^= DEBUG_OUTPUT_VERBOSE;
                g_pUiClient->SetOtherOutputMask(g_pDbgClient, OutMask);
                g_pUiControl->SetLogMask(OutMask);
                CmdLogFmt("Verbose mode %s.\n",
                          (OutMask & DEBUG_OUTPUT_VERBOSE) ? "ON" : "OFF");
                CheckMenuItem(g_hmenuMain, 
                              IDM_VIEW_TOGGLE_VERBOSE,
                              (OutMask & DEBUG_OUTPUT_VERBOSE) ?
                              MF_CHECKED : MF_UNCHECKED);
                break;

            case IDM_VIEW_SHOW_VERSION:
                Status = g_pUiControl->
                    OutputVersionInformation(DEBUG_OUTCTL_AMBIENT);
                if (Status == HRESULT_FROM_WIN32(ERROR_BUSY))
                {
                    CmdLogFmt("Engine is busy, try again\n");
                }
                else if (Status != S_OK)
                {
                    CmdLogFmt("Unable to show version information, 0x%X\n",
                              Status);
                }
                break;

            case IDM_VIEW_TOOLBAR:
                {
                    BOOL bVisible = !g_ShowToolbar;

                    CheckMenuItem(g_hmenuMain, 
                                  IDM_VIEW_TOOLBAR,
                                  bVisible ? MF_CHECKED : MF_UNCHECKED
                                  );
                    Show_Toolbar(bVisible);
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->SetUlong(WSP_GLOBAL_VIEW_TOOL_BAR,
                                              bVisible);
                    }
                }
                break;

            case IDM_VIEW_STATUS:
                {
                    BOOL bVisible = !g_ShowStatusBar;
                    CheckMenuItem(g_hmenuMain, 
                                  IDM_VIEW_STATUS,
                                  bVisible ? MF_CHECKED : MF_UNCHECKED
                                  );
                    Show_StatusBar(bVisible);
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->SetUlong(WSP_GLOBAL_VIEW_STATUS_BAR,
                                              bVisible);
                    }
                }
                break;

            case IDM_VIEW_FONT:
                SelectFont(hwnd, FONT_FIXED);
                break;

            case IDM_VIEW_OPTIONS:
                StartDialog(IDD_DLG_OPTIONS, DlgProc_Options, NULL);
                break;

            case IDM_DEBUG_RESTART:
                if (g_EngineThreadId)
                {
                    AddEnumCommand(UIC_RESTART);
                }
                else if (g_CommandLineStart == 1)
                {
                    ParseCommandLine(FALSE);
                }
                break;

            case IDM_DEBUG_EVENT_FILTERS:
                StartDialog(IDD_DLG_EVENT_FILTERS, DlgProc_EventFilters, NULL);
                break;

            case IDM_DEBUG_GO:
                CmdExecuteCmd(_T("g"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_GO_HANDLED:
                CmdExecuteCmd(_T("gh"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_GO_UNHANDLED:
                CmdExecuteCmd(_T("gn"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_RUNTOCURSOR:
            {
                char CodeExpr[MAX_OFFSET_EXPR];
                
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin != NULL &&
                    (CommonWinData = GetCommonWinData(CommonWin)) != NULL &&
                    SUCCEEDED(CommonWinData->
                              CodeExprAtCaret(CodeExpr, DIMA(CodeExpr), NULL)))
                {
                    PrintStringCommand(UIC_EXECUTE, "g %s", CodeExpr);
                }
                break;
            }

            case IDM_DEBUG_STEPINTO:
                CmdExecuteCmd( _T("t"), UIC_EXECUTE );
                break;

            case IDM_DEBUG_STEPOVER:
                CmdExecuteCmd( _T("p"), UIC_EXECUTE );
                break;

            case IDM_DEBUG_STEPOUT:
                AddStringCommand(UIC_EXECUTE, "g @@masm(@$ra)");
                break;
                
            case IDM_DEBUG_BREAK:
                g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
                break;

            case IDM_DEBUG_STOPDEBUGGING:
                StopDebugging(HIWORD(wParam) != 0xffff);
                break;

            case IDM_EDIT_TOGGLEBREAKPOINT:
            case IDM_EDIT_BREAKPOINTS:
                if ( !IS_TARGET_HALTED() )
                {
                    ErrorBox(NULL, 0, ERR_Cant_Modify_BP_While_Running);
                    break;
                }

                if (wItemId == IDM_EDIT_TOGGLEBREAKPOINT)
                {
                    // If a disassembly or source window is up
                    // try and toggle a breakpoint at the current
                    // line.
                    CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                    if (CommonWin != NULL &&
                        (CommonWinData =
                         GetCommonWinData(CommonWin)) != NULL)
                    {
                        if (CommonWinData->m_enumType == DISASM_WINDOW ||
                            CommonWinData->m_enumType == DOC_WINDOW ||
                            CommonWinData->m_enumType == CALLS_WINDOW)
                        {
                            CommonWinData->ToggleBpAtCaret();
                            break;
                        }
                    }
                }
                
                // menu got us here or we are not in a code window
                StartDialog(IDD_DLG_BREAKPOINTS, DlgProc_SetBreak, NULL);
                break;

            case IDM_EDIT_LOG_FILE:
                StartDialog(IDD_DLG_LOG_FILE, DlgProc_LogFile, NULL);
                break;

            case IDM_DEBUG_MODULES:
                StartDialog(IDD_DLG_MODULES, DlgProc_Modules, NULL);
                break;

            case IDM_WINDOW_TILE_HORZ:
            case IDM_WINDOW_TILE_VERT:
                SendMessage(g_hwndMDIClient, 
                            WM_MDITILE,
                            (IDM_WINDOW_TILE_HORZ == wItemId) ? MDITILE_HORIZONTAL : MDITILE_VERTICAL,
                            0L
                            );
                break;

            case IDM_WINDOW_CASCADE:
                SendMessage(g_hwndMDIClient, WM_MDICASCADE, 0, 0L);
                break;

            case IDM_WINDOW_ARRANGE:
                Arrange();
                break;

            case IDM_WINDOW_ARRANGE_ICONS:
                SendMessage(g_hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
                break;

            case IDM_WINDOW_CLOSE_ALL_DOCWIN:
                CloseAllWindows(1 << DOC_WINDOW);
                break;
                
            case IDM_WINDOW_AUTO_ARRANGE:
                g_WinOptions ^= WOPT_AUTO_ARRANGE;
                if (g_AutoArrangeWarningCount != 0xffffffff)
                {
                    g_AutoArrangeWarningCount = 0;
                }
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_ARRANGE_ALL:
                g_WinOptions ^= WOPT_ARRANGE_ALL;
                if (g_WinOptions & WOPT_AUTO_ARRANGE)
                {
                    Arrange();
                }
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_OVERLAY_SOURCE:
                g_WinOptions ^= WOPT_OVERLAY_SOURCE;
                UpdateSourceOverlay();
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_AUTO_DISASM:
                g_WinOptions ^= WOPT_AUTO_DISASM;
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_HELP_CONTENTS:
                // Display the table of contents
                OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
                break;

            case IDM_HELP_INDEX:
                OpenHelpIndex("");
                break;

            case IDM_HELP_SEARCH:
                OpenHelpSearch("");
                break;

            case IDM_HELP_ABOUT:
                ShellAbout( hwnd, g_MainTitleText, NULL, NULL );
                break;

                //**************************************************
                // The following commands are not accessible via menus

            case IDM_DEBUG_SOURCE_MODE:
                SetSrcMode_StatusBar(!GetSrcMode_StatusBar());
                EnableToolbarControls();

                if (GetSrcMode_StatusBar())
                {
                    AddStringCommand(UIC_INVISIBLE_EXECUTE, "l+t");
                }
                else
                {
                    AddStringCommand(UIC_INVISIBLE_EXECUTE, "l-t");
                }
                break;

            case IDM_DEBUG_SOURCE_MODE_ON:
                SetSrcMode_StatusBar(TRUE);
                EnableToolbarControls();
                AddStringCommand(UIC_INVISIBLE_EXECUTE, "l+t");
                break;

            case IDM_DEBUG_SOURCE_MODE_OFF:
                SetSrcMode_StatusBar(FALSE);
                EnableToolbarControls();
                AddStringCommand(UIC_INVISIBLE_EXECUTE, "l-t");
                break;

            case IDM_KDEBUG_TOGGLE_BAUDRATE:
                //
                // This method is reentrant so we can call it directly
                //
                g_pUiClient->SetKernelConnectionOptions("cycle_speed");
                break;

            case IDM_KDEBUG_TOGGLE_DEBUG:
                g_pUiClient->GetOtherOutputMask(g_pDbgClient, &OutMask);
                OutMask ^= DEBUG_IOUTPUT_KD_PROTOCOL;
                g_pUiClient->SetOtherOutputMask(g_pDbgClient, OutMask);
                g_pUiControl->SetLogMask(OutMask);
                break;

            case IDM_KDEBUG_TOGGLE_INITBREAK:
                {
                    ULONG EngOptions;
                    LPSTR DebugAction;

                    //
                    // These methods are reentrant so we can call directly
                    //

                    //
                    // Toggle between the following possibilities-
                    //
                    // (0) no breakin
                    // (1) -b style (same as Control-C up the wire)
                    // (2) -d style (stop on first dll load).
                    //
                    // NB -b and -d could both be on the command line
                    // but become mutually exclusive via this method.
                    // (Maybe should be a single enum type).
                    //

                    g_pUiControl->GetEngineOptions(&EngOptions);
                    if (EngOptions & DEBUG_ENGOPT_INITIAL_BREAK)
                    {
                        //
                        // Was type 1, go to type 2.
                        //

                        EngOptions |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                        EngOptions &= ~DEBUG_ENGOPT_INITIAL_BREAK;

                        DebugAction = "breakin on first symbol load";
                    }
                    else if (EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK)
                    {
                        //
                        // Was type 2, go to type 0.
                        //

                        EngOptions &= ~DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                        DebugAction = "NOT breakin";
                    }
                    else
                    {
                        //
                        // Was type 0, go to type 1.
                        //

                        EngOptions |= DEBUG_ENGOPT_INITIAL_BREAK;
                        DebugAction = "request initial breakpoint";
                    }
                    g_pUiControl->SetEngineOptions(EngOptions);
                    CmdLogFmt("Will %s at next boot.\n", DebugAction);
                }
                break;

            case IDM_KDEBUG_RECONNECT:
                //
                // This method is reentrant so we can call it directly
                //
                g_pUiClient->SetKernelConnectionOptions("resync");
                break;

            default:
                goto DefProcessing;
            }
        }
        break;

    case WM_INITMENU:
        // TOOLBAR handling - a menu item has been selected.
        // Catches keyboard menu selecting.
        if (GetWindowLong(hwnd, GWL_STYLE) & WS_ICONIC) {
            break;
        }

        InitializeMenu((HMENU)wParam);
        break;


    case WM_MENUSELECT:
        {
            WORD wMenuItem      = (UINT) LOWORD(wParam);    // menu item or submenu index
            WORD wFlags         = (UINT) HIWORD(wParam);    // menu flags
            HMENU hmenu         = (HMENU) lParam;           // handle of menu clicked

            g_LastMenuId = LOWORD(wParam);

            if (0xFFFF == wFlags && NULL == hmenu)
            {
                //
                // Menu is closed, clear the Status Bar.
                //

                s_MenuItemSelected = 0;
                SetMessageText_StatusBar(SYS_Clear);
            }
            else if ( wFlags & MF_POPUP )
            {
                //
                // Get the menu ID for the pop-up menu.
                //

                s_MenuItemSelected =
                    ((wMenuItem + 1) * IDM_BASE) | MENU_SIGNATURE;
            }
            else
            {
                //
                // Get the menu ID for the menu item.
                //

                s_MenuItemSelected = wMenuItem;
            }
        }
        break;

    case WM_ENTERIDLE:
        SetMessageText_StatusBar(s_MenuItemSelected);
        break;

    case WM_CLOSE:
        TerminateApplication(TRUE);
        break;

    case WM_DRAWITEM:
        switch (wParam)
        {
        case IDC_STATUS_BAR:
            OwnerDrawItem_StatusBar((LPDRAWITEMSTRUCT) lParam);
            return TRUE;
        }
        goto DefProcessing;

    case WM_DESTROY:
        TerminateStatusBar();
        PostQuitMessage(0);
        break;

    case WM_MOVE:
        // This is to let the edit window
        // set a position of IME conversion window
        if ( MDIGetActive(g_hwndMDIClient, NULL) )
        {
            SendMessage(MDIGetActive(g_hwndMDIClient, NULL), WM_MOVE, 0, 0);
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        break;

    case WM_SIZE:
        {
            RECT rc;
            int nToolbarHeight = 0;   // Toolbar
            int nStatusHeight = 0;   // status bar
            int OldToolbarHeight = 0;

            if ( g_ShowToolbar )
            {
                GetWindowRect(GetHwnd_Toolbar(), &rc);
                OldToolbarHeight = rc.bottom - rc.top;
            }
            
            GetClientRect (hwnd, &rc);

            // First lets resize the toolbar
            SendMessage(GetHwnd_Toolbar(), WM_SIZE, wParam,
                MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top));

            // 2nd resize the status bar
            WM_SIZE_StatusBar(wParam, MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top));

            //On creation or resize, size the MDI client,
            //status line and toolbar.
            if ( g_ShowStatusBar )
            {
                RECT rcStatusBar;

                GetWindowRect(GetHwnd_StatusBar(), &rcStatusBar);

                nStatusHeight = rcStatusBar.bottom - rcStatusBar.top;
            }

            if (g_ShowToolbar)
            {
                RECT rcToolbar;

                GetWindowRect(GetHwnd_Toolbar(), &rcToolbar);

                nToolbarHeight = rcToolbar.bottom - rcToolbar.top;
            }

            g_MdiWidth = rc.right - rc.left;
            g_MdiHeight = rc.bottom - rc.top - nStatusHeight - nToolbarHeight;
            MoveWindow(g_hwndMDIClient,
                       rc.left, rc.top + nToolbarHeight,
                       g_MdiWidth, g_MdiHeight,
                       TRUE
                       );

            SendMessage(g_hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            // This is to let the edit window
            // set a position of IME conversion window
            if ( MDIGetActive(g_hwndMDIClient, NULL) )
            {
                SendMessage(MDIGetActive(g_hwndMDIClient, NULL), WM_MOVE, 0, 0);
            }

            if (OldToolbarHeight != nToolbarHeight)
            {
                RedrawWindow(g_hwndMDIClient, NULL, NULL,
                             RDW_ERASE | RDW_INVALIDATE | RDW_FRAME |
                             RDW_UPDATENOW | RDW_ALLCHILDREN);
            }
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        break;

    case WU_START_ENGINE:
        {
            //
            // Go start the debugger engine if the appropriate debugger
            // parameters were passed in
            //

            DWORD Id;
            
            // Start the engine thread.
            g_EngineThread = CreateThread(NULL, 0, EngineLoop, NULL, 0, &Id);
            if (g_EngineThread == NULL)
            {
                ErrorBox(NULL, 0, ERR_Engine_Failed);
                break;
            }
        }
        break;

    case WU_ENGINE_STARTED:
        if ((HRESULT)lParam == S_OK)
        {
            UpdateTitleSessionText();
            if (GetCmdHwnd() == NULL)
            {
                // If the engine is started, show the command window
                // by default
                New_OpenDebugWindow(CMD_WINDOW, FALSE, NTH_OPEN_ALWAYS);
            }
        }
        break;

    case WU_ENGINE_IDLE:
        if (g_InitialCommand != NULL)
        {
            CmdLogFmt("Processing initial command '%s'\n",
                      g_InitialCommand);
            CmdExecuteCmd(g_InitialCommand, UIC_EXECUTE);
            free(g_InitialCommand);
            g_InitialCommand = NULL;
        }
        break;

    case WU_SWITCH_WORKSPACE:
        UiDelayedSwitchWorkspace();
        break;

    case WU_UPDATE:
        // Global engine status has changed, such as
        // the current process and thread.  Update
        // global UI elements.
        SetSysPidTid_StatusBar(g_CurSystemId, g_CurSystemName,
                               g_CurProcessId, g_CurProcessSysId,
                               g_CurThreadId, g_CurThreadSysId);
        if (wParam == UPDATE_BUFFER)
        {
            SetSrcMode_StatusBar(lParam == DEBUG_LEVEL_SOURCE);
        }
        break;

DefProcessing:
    default:
        return DefFrameProc(hwnd, g_hwndMDIClient, message, wParam, lParam);
    }
    
    return (0L);
}

void
TerminateApplication(BOOL Cancellable)
{
    if (g_EngineThreadId != 0 &&
        (g_AttachProcessFlags & DEBUG_ATTACH_NONINVASIVE))
    {
        if (QuestionBox(STR_Abandoning_Noninvasive_Debuggee, MB_OKCANCEL) ==
            IDCANCEL)
        {
            return;
        }    
    }
    
    if (g_Workspace != NULL)
    {
        if (g_Workspace->Flush(FALSE, Cancellable) == S_FALSE)
        {
            // User cancelled things so don't terminate.
            return;
        }
    }

    // Destroy windows to get window cleanup behavior.
    // This must occur before g_Exit is set so that
    // the engine thread doesn't come around and kill things.
    DestroyWindow(g_hwndFrame);

    g_Exit = TRUE;

    ULONG Code;

    if (!g_RemoteClient && g_DebugCommandLine != NULL)
    {
        // Return exit code of last process to exit.
        Code = g_LastProcessExitCode;
    }
    else
    {
        Code = S_OK;
    }

    if (g_EngineThreadId != 0)
    {
        UpdateEngine();
        
        // If the engine thread is idle it'll exit and call
        // ExitDebugger.  The engine may be waiting and
        // not responsive, though, so only wait a little while before
        // bailing out.
        Sleep(1000);
        if (g_pUiClient != NULL && !g_RemoteClient)
        {
            g_pUiClient->EndSession(DEBUG_END_REENTRANT);
        }
        ExitProcess(Code);
    }
    else
    {
        ExitDebugger(g_pUiClient, Code);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\prcdlg.cpp ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    prcdlg.cpp

Abstract:

    Contains dialog-related functions.

--*/

#include "precomp.hxx"
#pragma hdrstop

#ifndef STATUS_ACCESS_DENIED
#define STATUS_ACCESS_DENIED             (0xC0000022L)
#endif

#include <shlobj.h>
#include <time.h>

// Remote client workspaces do not contain engine information
// since a remote client attaches to many engines and it's
// rare that you'd want the same piece of engine information
// applied to every connect.
#define SAVE_ENGINE_WORKSPACE() \
    (g_Workspace != NULL && !g_RemoteClient)
#define DIRTY_ENGINE_WORKSPACE(Flags) FALSE

// Find dialog, if open.
HWND g_FindDialog;
// Find text.
char g_FindText[256];
ULONG g_FindTextFlags;
// Message code for FINDMSGSTRING.
UINT g_FindMsgString;
FINDREPLACE g_FindRep;
PCOMMONWIN_DATA g_FindLast;

ULONG64 g_CurProcessServer;

char g_ComSettings[512];
char g_1394Settings[256];

TCHAR szOpenExeArgs[2 * _MAX_PATH];
TCHAR g_DlgString[2 * _MAX_PATH];
TCHAR g_DlgString2[2 * _MAX_PATH];

LPITEMIDLIST g_SymbolPathDir;
LPITEMIDLIST g_SourcePathDir;
LPITEMIDLIST g_ImagePathDir;

PCSTR g_ExecutionNames[] =
{
    "enabled", "disabled", "output", "ignore"
};
PCSTR g_ContinueNames[] =
{
    "handled", "not handled"
};

PSTR g_SymbolTypeNames[] =
{
    "None", "COFF", "CodeView", "PDB", "Export", "Deferred", "Sym",
    "DIA",
};

PTSTR __cdecl
BufferString(PTSTR Buffer, ULONG Size, ULONG StrId, ...)
{
    va_list Args;
    TCHAR FmtStr[SHORT_MSG];

    Buffer[0] = 0;
    Buffer[Size - 1] = 0;
    Dbg(LoadString(g_hInst, StrId, FmtStr, _tsizeof(FmtStr)));
    va_start(Args, StrId);
    _vsnprintf(Buffer, Size, FmtStr, Args);
    va_end(Args);
    return Buffer;
}

void
SendLockStatusMessage(HWND Win, UINT Msg, HRESULT Status)
{
    TCHAR Str[SHORT_MSG];

    if (Status == E_UNEXPECTED || Status == E_FAIL)
    {
        BufferString(Str, _tsizeof(Str), ERR_No_Debuggee_Info);
    }
    else if (FAILED(Status))
    {
        BufferString(Str, _tsizeof(Str), ERR_Unable_To_Retrieve_Info,
                     FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        BufferString(Str, _tsizeof(Str), STR_Retrieving_Information);
    }
    SendMessage(Win, Msg, 0, (LPARAM)Str);
}

void
AddWorkspaceNameToTitle(HWND Hwnd)
{
    char Title[MAX_PATH];
    
    GetWindowText(Hwnd, Title, DIMA(Title));
    CatString(Title, " - ", DIMA(Title));
    if (g_Workspace)
    {
        CatString(Title, g_Workspace->GetName(TRUE), DIMA(Title));
    }
    else
    {
        CatString(Title, "<No workspace>", DIMA(Title));
    }
    SetWindowText(Hwnd, Title);
}

void
BrowseForPathComponent(HWND Dialog, int TitleId, int DefExtId,
                       LPITEMIDLIST* InitialDir, int PathCtrl)
{
    TCHAR Path[MAX_ENGINE_PATH];
    TCHAR AddPath[MAX_ENGINE_PATH];
    ULONG_PTR Size;
    BROWSEINFO Browse;
    TCHAR Title[MAX_MSG_TXT];
    LPITEMIDLIST Result;

    Dbg(LoadString(g_hInst, TitleId, Title, DIMA(Title)));

    ZeroMemory(&Browse, sizeof(Browse));
    Browse.hwndOwner = Dialog;
    // Don't use the initial dir here as then the user
    // can't go above that directory.  I don't see a way
    // to select an initial directory while still allowing
    // the full namespace to be browsed.
    Browse.pidlRoot = NULL;
    Browse.pszDisplayName = AddPath;
    Browse.lpszTitle = Title;
    Browse.ulFlags = BIF_BROWSEINCLUDEFILES | BIF_RETURNONLYFSDIRS |
        BIF_USENEWUI;
    if (Result = SHBrowseForFolder(&Browse))
    {
        if (!SHGetPathFromIDList(Result, AddPath))
        {
            CoTaskMemFree(Result);
            return;
        }
        
        Size = SendDlgItemMessage(Dialog, PathCtrl, WM_GETTEXT,
                                  _tsizeof(Path), (LPARAM)Path);
        if (Size == 0)
        {
            Path[0] = 0;
        }
        else
        {
            CatString(Path, ";", DIMA(Path));
        }
        CatString(Path, AddPath, DIMA(Path));
        SendDlgItemMessage(Dialog, PathCtrl, WM_SETTEXT, 0, (LPARAM)Path);

        if (*InitialDir)
        {
            CoTaskMemFree(*InitialDir);
        }
        *InitialDir = Result;
    }
}

BpStateType
IsBpAtOffset(BpBufferData* DataIn, ULONG64 Offset, PULONG Id)
{
    BpBufferData* Data;
    
    if (DataIn == NULL)
    {
        if (g_BpBuffer->UiLockForRead() != S_OK)
        {
            return BP_NONE;
        }

        Data = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    }
    else
    {
        Data = DataIn;
    }
    
    ULONG i;
    BpStateType BpState = BP_NONE;

    for (i = 0; i < g_BpCount; i++)
    {
        if (Data->Offset != DEBUG_INVALID_OFFSET &&
            Data->Offset == Offset)
        {
            if (Data->Flags & DEBUG_BREAKPOINT_ENABLED)
            {
                BpState = BP_ENABLED;
            }
            else
            {
                BpState = BP_DISABLED;
            }
            if (Id != NULL)
            {
                *Id = Data->Id;
            }
            break;
        }

        Data++;
    }

    if (DataIn == NULL)
    {
        UnlockStateBuffer(g_BpBuffer);
    }

    return BpState;
}

BOOL
GetBpBufferData(ULONG Index, BpBufferData* RetData)
{
    if (Index >= g_BpCount ||
        g_BpBuffer->UiLockForRead() != S_OK)
    {
        return FALSE;
    }

    BpBufferData* Data = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    *RetData = Data[Index];

    UnlockStateBuffer(g_BpBuffer);
    return TRUE;
}

void
EnableBpButtons(BOOL UpdateAttrs)
{
    HWND Dlg = g_BpBuffer->m_Win;
    
    LRESULT Sel = SendDlgItemMessage(Dlg, ID_SETBREAK_BREAKPOINT,
                                     LB_GETCURSEL, 0, 0);
    BOOL Enable = Sel != LB_ERR;

    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_REMOVE), Enable);
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_DISABLE), Enable);
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_ENABLE), Enable);

    if (UpdateAttrs)
    {
        BpBufferData Data;
        char Text[16];

        Text[0] = 0;
        if (Sel >= 0 &&
            GetBpBufferData((ULONG)Sel, &Data) &&
            Data.Thread != DEBUG_ANY_ID)
        {
            _itoa(Data.Thread, Text, 10);
        }
        SetWindowText(GetDlgItem(Dlg, ID_SETBREAK_THREAD), Text);

        // We aren't going to try and parse 'j' commands to
        // extract conditions.
        SetWindowText(GetDlgItem(Dlg, ID_SETBREAK_CONDITION), "");
    }

    BOOL HasCommand = 
        GetWindowTextLength(GetDlgItem(Dlg, ID_SETBREAK_COMMAND)) > 0;
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_THREAD), HasCommand);
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_CONDITION), HasCommand);
}

void
FillBpList(HWND List)
{
    HRESULT Status;
    ULONG Width;
    RECT ListRect;

    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    SendMessage(List, WM_SETREDRAW, FALSE, 0);
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    GetClientRect(List, &ListRect);
    Width = ListRect.right - ListRect.left;
    
    Status = g_BpBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        PSTR Buf = (PSTR)g_BpBuffer->GetDataBuffer() + g_BpTextOffset;
        // Ignore trailing terminator.
        PSTR End = (PSTR)g_BpBuffer->GetDataBuffer() +
            g_BpBuffer->GetDataLen() - 1;

        while (Buf < End)
        {
            ULONG Len, BufWidth;

            Len = strlen(Buf) + 1;
            if (Len == 1)
            {
                // Break out on empty lines to avoid displaying
                // kernel internal breakpoint information and blank
                // line separating it from the normal breakpoints.
                break;
            }
            
            SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Buf);

            // Extra char in Len due to terminator ensures there's
            // a character of extra space to the right side.
            BufWidth = g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * Len;
            if (BufWidth > Width)
            {
                Width = BufWidth;
            }
            
            Buf += Len;
        }

        UnlockStateBuffer(g_BpBuffer);
    }
    else
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
    }

    SendMessage(List, LB_SETHORIZONTALEXTENT, Width, 0);
    SendMessage(List, WM_SETREDRAW, TRUE, 0);
    if (ListSel != LB_ERR)
    {
        SendMessage(List, LB_SETCURSEL, ListSel, 0);
    }
    EnableBpButtons(TRUE);
}

ULONG
GetBpListId(HWND List)
{
    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    if (ListSel == LB_ERR)
    {
        return DEBUG_ANY_ID;
    }

    LRESULT Len = SendMessage(List, LB_GETTEXTLEN, ListSel, 0);
    PSTR Buf = (PSTR)malloc(Len + 1);
    if (Buf == NULL)
    {
        return DEBUG_ANY_ID;
    }

    SendMessage(List, LB_GETTEXT, ListSel, (LPARAM)Buf);

    ULONG Id;
    if (sscanf(Buf, "%d", &Id) != 1)
    {
        return DEBUG_ANY_ID;
    }
    else
    {
        return Id;
    }
}

// Space for "Pending: ".
#define BP_PENDING_CHARS 9

void
AddBpCommandString(HWND List, PSTR CmdBuf, ULONG Thread, PSTR CondBuf)
{
    BOOL HasThread = FALSE;
    BOOL IsBpCmd = FALSE;
    PCSTR Scan;
    
    //
    // If the string looks like a real command just pass
    // it on for execution.  Otherwise, assume it's
    // a code breakpoint address expression.
    //
    
    Scan = CmdBuf + BP_PENDING_CHARS;
    
    if (*Scan == '~')
    {
        Scan++;
        HasThread = TRUE;
        
        // Skip optional thread indicator.
        if (*Scan == '.' || *Scan == '#')
        {
            Scan++;
        }
        else
        {
            while (*Scan >= '0' && *Scan <= '9')
            {
                Scan++;
            }
        }
    }
    
    if (*Scan == 'b' || *Scan == 'B')
    {
        Scan++;
        if (*Scan == 'a' || *Scan == 'A' ||
            *Scan == 'i' || *Scan == 'I' ||
            *Scan == 'm' || *Scan == 'm' ||
            *Scan == 'p' || *Scan == 'P' ||
            *Scan == 'u' || *Scan == 'U' ||
            *Scan == 'w' || *Scan == 'W')
        {
            Scan++;

            // Skip optional bp id.
            while (*Scan >= '0' && *Scan <= '9')
            {
                Scan++;
            }
            
            if (*Scan == ' ')
            {
                IsBpCmd = TRUE;
            }
        }
        else if (*Scan == 'c' || *Scan == 'C' ||
                 *Scan == 'd' || *Scan == 'D' ||
                 *Scan == 'e' || *Scan == 'E')
        {
            Scan++;
            if (*Scan == ' ')
            {
                IsBpCmd = TRUE;
            }
        }
    }

    // Immediately add the breakpoint string to the listbox
    // to indicate that it's pending.
    memcpy(CmdBuf, "Pending: ", BP_PENDING_CHARS);
    LRESULT Sel = SendMessage(List, LB_ADDSTRING, 0, (LPARAM)CmdBuf);
    if (Sel != LB_ERR && Sel != LB_ERRSPACE)
    {
        SendMessage(List, LB_SETCURSEL, Sel, 0);
    }

    CmdBuf += BP_PENDING_CHARS;
    if (IsBpCmd)
    {
        if (HasThread || Thread == DEBUG_ANY_ID)
        {
            AddStringCommand(UIC_SILENT_EXECUTE, CmdBuf);
        }
        else
        {
            PrintStringCommand(UIC_SILENT_EXECUTE, "~%d%s",
                               Thread, CmdBuf);
        }
    }
    else
    {
        char ThreadBuf[64];
        PCSTR Format;

        if (Thread != DEBUG_ANY_ID)
        {
            sprintf(ThreadBuf, "~%u", Thread);
        }
        else
        {
            ThreadBuf[0] = 0;
        }

        if (CondBuf[0])
        {
            Format = "%sbu %s \"j(%s) "
                "'.echo \\\"Breakpoint hit, condition %s\\\"' ; 'g'\"";
        }
        else
        {
            Format = "%sbu %s";
        }
        
        PrintStringCommand(UIC_SILENT_EXECUTE, Format,
                           ThreadBuf, CmdBuf, CondBuf, CondBuf);
    }
}

#define BP_CMD_MAX 1024
#define BP_COND_MAX 1024

INT_PTR CALLBACK
DlgProc_SetBreak(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    static UINT s_CmdLen;
    HWND List;
    HWND Ctrl;
    ULONG Id;
    
    List = GetDlgItem(Hwnd, ID_SETBREAK_BREAKPOINT);
    switch(Message)
    {
    case WM_INITDIALOG:
        s_CmdLen = 0;
        g_BpBuffer->m_Win = Hwnd;
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        SendMessage(List, LB_SETCURSEL, -1, 0);
        SendDlgItemMessage(Hwnd, ID_SETBREAK_COMMAND, EM_LIMITTEXT,
                           BP_CMD_MAX, 0);
        SendDlgItemMessage(Hwnd, ID_SETBREAK_CONDITION, EM_LIMITTEXT,
                           BP_COND_MAX, 0);
        FillBpList(List);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case ID_SETBREAK_COMMAND:
            if (HIWORD(Wpm) == EN_CHANGE)
            {
                EnableBpButtons(FALSE);

                UINT NewLen = GetWindowTextLength
                    (GetDlgItem(Hwnd, ID_SETBREAK_COMMAND));
                if (NewLen == 1 && s_CmdLen == 0)
                {
                    // If we're starting a new breakpoint command
                    // default the attributes to nothing.
                    SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_THREAD), "");
                    SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_CONDITION), "");
                }
                s_CmdLen = NewLen;
            }
            break;
            
        case ID_SETBREAK_BREAKPOINT:
            SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
            EnableBpButtons(TRUE);
            break;
            
        case ID_SETBREAK_REMOVE:
            Id = GetBpListId(List);
            if (Id != DEBUG_ANY_ID)
            {
                SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
                PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", Id);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            }
            break;

        case ID_SETBREAK_REMOVEALL:
            SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
            AddStringCommand(UIC_SILENT_EXECUTE, "bc *");
            DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            break;
            
        case ID_SETBREAK_ENABLE:
        case ID_SETBREAK_DISABLE:
            Id = GetBpListId(List);
            if (Id != DEBUG_ANY_ID)
            {
                SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
                PrintStringCommand(UIC_SILENT_EXECUTE, "b%c %d",
                                   LOWORD(Wpm) == ID_SETBREAK_ENABLE ?
                                   'e' : 'd', Id);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_BREAKPOINTS);
            break;
            
        case IDOK:
            char CmdBuf[BP_CMD_MAX + BP_PENDING_CHARS];
            char CondBuf[BP_COND_MAX];
            UINT Thread;
            BOOL ThreadValid;

            Thread = GetDlgItemInt(Hwnd, ID_SETBREAK_THREAD,
                                   &ThreadValid, FALSE);
            if (!ThreadValid)
            {
                Thread = DEBUG_ANY_ID;
            }
            
            Ctrl = GetDlgItem(Hwnd, ID_SETBREAK_COMMAND);
            if (SendMessage(Ctrl, WM_GETTEXT,
                            _tsizeof(CmdBuf) - BP_PENDING_CHARS,
                            (LPARAM)(CmdBuf + BP_PENDING_CHARS)) > 0)
            {
                if (!SendMessage(GetDlgItem(Hwnd, ID_SETBREAK_CONDITION),
                                 WM_GETTEXT, _tsizeof(CondBuf),
                                 (LPARAM)CondBuf))
                {
                    CondBuf[0] = 0;
                }
                
                AddBpCommandString(List, CmdBuf, Thread, CondBuf);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
                SendMessage(Ctrl, WM_SETTEXT, 0, (LPARAM)"");
                SendMessage(GetDlgItem(Hwnd, ID_SETBREAK_CONDITION),
                            WM_SETTEXT, 0, (LPARAM)"");
                // A command was executed so do not close the dialog.
                break;
            }
            
            // No command so fall through to close dialog.
            
        case IDCANCEL:
            g_BpBuffer->m_Win = NULL;
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    case LB_RESETCONTENT:
        FillBpList(List);
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}


UINT_PTR
OpenExeWithArgsHookProc(
    HWND    hDlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Allows the user to specify command line arguments when opening an
    executable.

Return Value:

    TRUE if we replaced default processing of the message, FALSE otherwise

--*/
{
    switch(msg)
    {
    case WM_INITDIALOG:
        CheckDlgButton(hDlg, IDC_EXEOPEN_CHILD_PROCESSES, FALSE);
        return TRUE;

    case WM_NOTIFY:
        if (((LPOFNOTIFY) lParam)->hdr.code == CDN_FILEOK)
        {
            GetDlgItemText(hDlg,
                           IDC_EXEOPEN_START_DIR,
                           szOpenExeArgs,
                           _tsizeof(szOpenExeArgs));
            DupAllocString(&g_ProcessStartDir, szOpenExeArgs);
            
            *szOpenExeArgs = _T(' ');

            GetDlgItemText(hDlg,
                           IDC_EDIT_ARGS,
                           szOpenExeArgs + 1,
                           _tsizeof(szOpenExeArgs) - 1);
            
            if (IsDlgButtonChecked(hDlg, IDC_EXEOPEN_CHILD_PROCESSES) ==
                BST_CHECKED)
            {
                g_DebugCreateFlags |= DEBUG_PROCESS;
                g_DebugCreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            }
            else
            {
                g_DebugCreateFlags &= ~DEBUG_PROCESS;
                g_DebugCreateFlags |= DEBUG_ONLY_THIS_PROCESS;
            }
            
            return 0;
        }
    }

    return DlgFile(hDlg, msg, wParam, lParam);
}

#define NO_SERVERS "No servers registered"

void
FillServersList(HWND List, PCSTR Machine)
{
    HRESULT Status;
    
    g_pUiClient->SetOutputCallbacks(&g_UiOutStateBuf);
    g_UiOutStateBuf.SetBuffer(&g_UiOutputCapture);
    g_UiOutStateBuf.Start(TRUE);
    Status = g_pUiClient->OutputServers(DEBUG_OUTCTL_THIS_CLIENT, Machine,
                                        DEBUG_SERVERS_DEBUGGER);
    g_pUiClient->SetOutputCallbacks(NULL);
    if (Status == S_OK)
    {
        Status = g_UiOutStateBuf.End(FALSE);
    }
    else
    {
        g_UiOutStateBuf.End(FALSE);
    }
    g_UiOutStateBuf.ReplaceChar('\n', 0);

    SendMessage(List, LB_RESETCONTENT, 0, 0);
    if (Status == S_OK)
    {
        PSTR Line, End;
    
        Line = (PSTR)g_UiOutputCapture.GetDataBuffer();
        End = Line + g_UiOutputCapture.GetDataLen() - 1;
        if (Line == NULL || Line >= End)
        {
            SendMessage(List, LB_ADDSTRING, 0, (LPARAM)NO_SERVERS);
        }
        else
        {
            while (Line < End)
            {
                SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Line);
                Line += strlen(Line) + 1;
            }
        }
    }
    else
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
    }
    SendMessage(List, LB_SETCURSEL, 0, 0);

    g_UiOutputCapture.Free();
}

INT_PTR CALLBACK
DlgProc_BrowseServers(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Machine[128];
    LRESULT Sel;

    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, EM_LIMITTEXT,
                           _tsizeof(Machine) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_BROWSE_MACHINE), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_BROWSE_REFRESH:
            if (SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, WM_GETTEXT,
                                   _tsizeof(Machine), (LPARAM)Machine))
            {
                FillServersList(GetDlgItem(Hwnd, IDC_BROWSE_SERVERS_LIST),
                                Machine);
            }
            break;

        case IDC_BROWSE_SERVERS_LIST:
            switch(HIWORD(Wpm))
            {
            case LBN_DBLCLK:
                Wpm = IDOK;
                goto SelectAndEnd;
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION);
            break;
            
        case IDOK:
        SelectAndEnd:
            Sel = SendDlgItemMessage(Hwnd, IDC_BROWSE_SERVERS_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_BROWSE_SERVERS_LIST,
                                   LB_GETTEXT, Sel, (LPARAM)g_DlgString) > 0 &&
                strcmp(g_DlgString, NO_SERVERS) &&
                SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, WM_GETTEXT,
                                   _tsizeof(Machine), (LPARAM)Machine))
            {
                CatString(g_DlgString, ",Server=", DIMA(g_DlgString));
                CatString(g_DlgString, Machine, DIMA(g_DlgString));
            }
            else
            {
                g_DlgString[0] = 0;
            }
            
            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_ConnectToRemote(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR ConnectString[1024];

    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SendDlgItemMessage(Hwnd, IDC_REM_CONNECT, EM_LIMITTEXT,
                           _tsizeof(ConnectString) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_REM_CONNECT), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_REM_BROWSE:
            if (StartDialog(IDD_DLG_BROWSE_SERVERS, DlgProc_BrowseServers,
                            NULL) == IDOK && g_DlgString[0])
            {
                // Skip "<Server type> - " at the beginning.
                PSTR Start = strchr(g_DlgString, '-');
                if (Start != NULL)
                {
                    SetWindowText(GetDlgItem(Hwnd, IDC_REM_CONNECT),
                                  Start + 2);
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_REM_CONNECT, WM_GETTEXT,
                                   _tsizeof(ConnectString),
                                   (LPARAM)ConnectString))
            {
                ClearDebuggingParams();
                
                if (CreateUiInterfaces(TRUE, ConnectString))
                {
                    StartDebugging();
                    EndDialog(Hwnd, IDOK);
                }
                else if (!CreateUiInterfaces(FALSE, NULL))
                {
                    // CreateUiInterfaces discards any previous
                    // interfaces so we need to recreate something
                    // so there are UI thread interfaces.
                    InternalError(E_OUTOFMEMORY, "CreateUiInterfaces");
                    ErrorExit(NULL, "Unable to recreate UI interfaces\n");
                }
            }

            return TRUE;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR
CALLBACK
DlgProc_SymbolPath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR   SymPath[MAX_ENGINE_PATH];
    ULONG   PathSize;
    LRESULT Size;
    HRESULT Hr;

    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //

        Hr = g_pUiSymbols->GetSymbolPath(SymPath, _tsizeof(SymPath),
                                         &PathSize);
        if (Hr != S_OK)
        {
            InternalError(Hr, "UI GetSymPath");
        }

        SendDlgItemMessage(Hwnd, IDC_SYMPATH, WM_SETTEXT, 0, (LPARAM)SymPath);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_PATH_BROWSE:
            BrowseForPathComponent(Hwnd,
                                   DLG_Browse_Symbol_Path_Title,
                                   DEF_Ext_Symbols,
                                   &g_SymbolPathDir,
                                   IDC_SYMPATH);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SYMBOL_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_SYMPATH, WM_GETTEXT,
                                      _tsizeof(SymPath), (LPARAM)SymPath);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            SymPath[Size] = 0;

            Hr = g_pUiSymbols->SetSymbolPath(SymPath);
            if (Hr != S_OK)
            {
                InternalError(Hr, "UI SetSymPath");
            }

            if (SAVE_ENGINE_WORKSPACE())
            {
                g_Workspace->SetString(WSP_GLOBAL_SYMBOL_PATH, SymPath);
            }
                                             
            if (IsDlgButtonChecked(Hwnd, IDC_PATH_RELOAD) == BST_CHECKED)
            {
                AddStringCommand(UIC_EXECUTE, ".reload");
            }
            
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_RegCustomize(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    RegisterNamesStateBuffer* NameBuf;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(Hwnd, DWLP_USER, Lpm);
        NameBuf = (RegisterNamesStateBuffer*)Lpm;
        NameBuf->GetRegisterMapText(GetDlgItem(Hwnd, IDC_REGCUST_ENTRY));
        CheckDlgButton(Hwnd, IDC_REGCUST_CHANGED_FIRST,
                       NameBuf->m_Flags & REGCUST_CHANGED_FIRST);
        CheckDlgButton(Hwnd, IDC_REGCUST_NO_SUBREG,
                       NameBuf->m_Flags & REGCUST_NO_SUBREG);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_REGISTERS);
            break;
            
        case IDOK:
            NameBuf = (RegisterNamesStateBuffer*)
                GetWindowLongPtr(Hwnd, DWLP_USER);
            
            NameBuf->ScanRegisterMapText(GetDlgItem(Hwnd, IDC_REGCUST_ENTRY));

            NameBuf->m_Flags &= ~(REGCUST_CHANGED_FIRST |
                                  REGCUST_NO_SUBREG);
            if (IsDlgButtonChecked(Hwnd, IDC_REGCUST_CHANGED_FIRST) ==
                BST_CHECKED)
            {
                NameBuf->m_Flags |= REGCUST_CHANGED_FIRST;
            }
            if (IsDlgButtonChecked(Hwnd, IDC_REGCUST_NO_SUBREG) ==
                BST_CHECKED)
            {
                NameBuf->m_Flags |= REGCUST_NO_SUBREG;
            }

            if (NameBuf->m_RegisterMap != NULL && g_Workspace != NULL)
            {
                WSP_ENTRY* Entry = NULL;

                //
                // Clear any existing entry for this processor and
                // any old-style register map entry.
                //
                    
                while (Entry = g_Workspace->
                       GetNext(Entry, WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP,
                               WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP))
                {
                    if (*WSP_ENTRY_DATA(PULONG, Entry) == NameBuf->m_ProcType)
                    {
                        g_Workspace->DeleteEntry(Entry);
                        break;
                    }
                }
                g_Workspace->Delete(WSP_GLOBAL_REGISTER_MAP,
                                    WSP_GLOBAL_REGISTER_MAP);
                g_Workspace->Delete(WSP_GLOBAL_PROC_REGISTER_MAP,
                                    WSP_GLOBAL_PROC_REGISTER_MAP);

                //
                // Add new entry for this processor.
                //
                
                Entry = g_Workspace->
                    Add(WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP,
                        2 * sizeof(ULONG) + NameBuf->m_RegisterMapEntries *
                        sizeof(*NameBuf->m_RegisterMap));
                if (Entry != NULL)
                {
                    PULONG Data = WSP_ENTRY_DATA(PULONG, Entry);
                    *Data++ = NameBuf->m_ProcType;
                    *Data++ = NameBuf->m_Flags;
                    memcpy(Data, NameBuf->m_RegisterMap,
                           NameBuf->m_RegisterMapEntries *
                           sizeof(*NameBuf->m_RegisterMap));
                }
            }
            
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_GotoLine(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    int Line;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(Hwnd, DWLP_USER, Lpm);
        SendDlgItemMessage(Hwnd, IDC_LINE_ENTRY, EM_LIMITTEXT,
                           _tsizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_LINE_ENTRY), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_GO_TO_LINE);
            break;
            
        case IDOK:
            COMMONWIN_DATA* CommonWinData;
            CommonWinData = (COMMONWIN_DATA*)GetWindowLongPtr(Hwnd, DWLP_USER);
            GetWindowText(GetDlgItem(Hwnd, IDC_LINE_ENTRY),
                          Text, _tsizeof(Text));
            Line = atoi(Text);
            if (Line > 0)
            {
                CommonWinData->GotoLine(Line);
            }
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_GotoAddress(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_ADDRESS_ENTRY, EM_LIMITTEXT,
                           _tsizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ADDRESS_ENTRY), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_GO_TO_ADDRESS);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ADDRESS_ENTRY),
                          Text, _tsizeof(Text));
            AddStringCommand(UIC_DISPLAY_CODE_EXPR, Text);
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_LogFile(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HRESULT Status;
    char LogFile[MAX_PATH];
    BOOL Append;
    HWND Ctrl;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        Append = FALSE;
        Ctrl = GetDlgItem(Hwnd, IDC_LOG_FILE_NAME);
        SendMessage(Ctrl, EM_LIMITTEXT, _tsizeof(LogFile) - 1, 0);
        Status = g_pUiControl->GetLogFile(LogFile, _tsizeof(LogFile), NULL,
                                          &Append);
        if (Status == E_NOINTERFACE)
        {
            // No current log file.
            SetWindowText(Ctrl, "");
        }
        else if (Status != S_OK)
        {
            SetWindowText(Ctrl, "Unable to retrieve name");
        }
        else
        {
            SetWindowText(Ctrl, LogFile);
        }
        EnableWindow(GetDlgItem(Hwnd, IDC_LOG_CLOSE), Status == S_OK);
        CheckDlgButton(Hwnd, IDC_LOG_APPEND,
                       Append ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_LOG_CLOSE:
            g_pUiControl->CloseLogFile();
            DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_LOG_FILE);
            SetWindowText(GetDlgItem(Hwnd, IDC_LOG_FILE_NAME), "");
            EnableWindow(GetDlgItem(Hwnd, IDC_LOG_CLOSE), FALSE);
            break;

        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_LOG_FILE);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_LOG_FILE_NAME),
                          LogFile, _tsizeof(LogFile));
            Append = IsDlgButtonChecked(Hwnd, IDC_LOG_APPEND) ==
                BST_CHECKED;
            if (LogFile[0] != 0)
            {
                g_pUiControl->OpenLogFile(LogFile, Append);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_LOG_FILE);
            }
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DLGPROC g_CurrentKd;

INT_PTR
CALLBACK
DlgProc_KernelCom(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_PORT), g_ComSettings);
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_BAUDRATE),
                      g_ComSettings + strlen(g_ComSettings) + 1);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_KernelCom;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_KernelCom)
            {
                // This isn't the current page so ignore.
                break;
            }
            
            TCHAR Com[256];
            TCHAR Baud[256];

            if (SendDlgItemMessage(Hwnd, IDC_KD_PORT, WM_GETTEXT,
                                   _tsizeof(Com), (LPARAM)Com) &&
                SendDlgItemMessage(Hwnd, IDC_KD_BAUDRATE, WM_GETTEXT,
                                   _tsizeof(Baud), (LPARAM)Baud))
            {
                if (PrintAllocString(&g_KernelConnectOptions, 256,
                                     "com:port=%s,baud=%s", Com, Baud))
                {
                    strcpy(g_ComSettings, Com);
                    strcpy(g_ComSettings + strlen(Com) + 1, Baud);
                    if (SAVE_ENGINE_WORKSPACE())
                    {
                        PCSTR Settings[2];

                        Settings[0] = Com;
                        Settings[1] = Baud;
                        g_Workspace->SetStrings(WSP_GLOBAL_COM_SETTINGS, 2,
                                                Settings);
                    }
                }
            }
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
DlgProc_Kernel1394(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_1394_CHANNEL), g_1394Settings);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_Kernel1394;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_Kernel1394)
            {
                // This isn't the current page so ignore.
                break;
            }
            
            TCHAR Channel[256];

            if (SendDlgItemMessage(Hwnd, IDC_KD_1394_CHANNEL, WM_GETTEXT,
                                   _tsizeof(Channel), (LPARAM)Channel))
            {
                if (PrintAllocString(&g_KernelConnectOptions, 256,
                                     "1394:channel=%s", Channel))
                {
                    strcpy(g_1394Settings, Channel);
                    if (SAVE_ENGINE_WORKSPACE())
                    {
                        g_Workspace->SetString(WSP_GLOBAL_1394_SETTINGS,
                                               g_1394Settings);
                    }
                }
            }
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
DlgProc_KernelLocal(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch (Message)
    {
    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_KernelLocal;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_KernelLocal)
            {
                // This isn't the current page so ignore.
                break;
            }

            g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

void
StartKdPropSheet(void)
{
    PROPSHEETHEADER Sheet;
    PROPSHEETPAGE Pages[3];

    ClearDebuggingParams();
    
    ZeroMemory(&Sheet, sizeof(Sheet));
    Sheet.dwSize = sizeof(PROPSHEETHEADER);
    Sheet.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_HASHELP;
    Sheet.hwndParent = g_hwndFrame;
    Sheet.hInstance = g_hInst;
    Sheet.pszCaption = "Kernel Debugging";
    Sheet.nPages = 3;
    Sheet.ppsp = Pages;

    ZeroMemory(Pages, sizeof(Pages[0]));
    Pages[0].dwSize = sizeof(Pages[0]);
    Pages[0].dwFlags = PSP_HASHELP;
    Pages[0].hInstance = g_hInst;

    Pages[1] = Pages[0];
    Pages[2] = Pages[0];
    
    Pages[0].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_COM);
    Pages[0].pfnDlgProc = DlgProc_KernelCom;

    Pages[1].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_1394);
    Pages[1].pfnDlgProc = DlgProc_Kernel1394;

    Pages[2].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_LOCAL);
    Pages[2].pfnDlgProc = DlgProc_KernelLocal;

    g_CurrentKd = NULL;

    INT_PTR Status = PropertySheet(&Sheet);
    if (Status == IDOK)
    {
        if (g_ExplicitWorkspace && g_Workspace != NULL)
        {
            g_Workspace->SetUlong(WSP_GLOBAL_ATTACH_KERNEL_FLAGS,
                                  g_AttachKernelFlags);
        }
        StartDebugging();
    }
}

INT_PTR
CALLBACK
DlgProc_ImagePath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR Path[MAX_ENGINE_PATH];
    LRESULT Size;
    HRESULT Hr;

    switch(Message)
    {
    case WM_INITDIALOG:
        Hr = g_pUiSymbols->GetImagePath(Path, _tsizeof(Path), NULL);
        if (Hr != S_OK)
        {
            InternalError(Hr, "UI GetImagePath");
        }

        SendDlgItemMessage(Hwnd, IDC_IMAGE_PATH, WM_SETTEXT, 0, (LPARAM)Path);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_PATH_BROWSE:
            BrowseForPathComponent(Hwnd,
                                   DLG_Browse_Image_Path_Title,
                                   DEF_Ext_DLL,
                                   &g_ImagePathDir,
                                   IDC_IMAGE_PATH);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_IMAGE_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_IMAGE_PATH, WM_GETTEXT,
                                      _tsizeof(Path), (LPARAM)Path);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            Path[Size] = 0;

            Hr = g_pUiSymbols->SetImagePath(Path);
            if (Hr != S_OK)
            {
                InternalError(Hr, "UI SetImagePath");
            }

            if (SAVE_ENGINE_WORKSPACE())
            {
                g_Workspace->SetString(WSP_GLOBAL_IMAGE_PATH, Path);
            }
                                             
            if (IsDlgButtonChecked(Hwnd, IDC_PATH_RELOAD) == BST_CHECKED)
            {
                AddStringCommand(UIC_EXECUTE, ".reload");
            }
            
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


INT_PTR
CALLBACK
DlgProc_SourcePath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR Path[MAX_ENGINE_PATH];
    LRESULT Size;
    HRESULT Hr;
    HWND Ctrl;
    ULONG Tag;

    switch(Message)
    {
    case WM_INITDIALOG:
        Ctrl = GetDlgItem(Hwnd, IDC_LOCAL_SOURCE);
        SendMessage(Ctrl, BM_SETCHECK, TRUE, 0);
        if (!g_RemoteClient)
        {
            EnableWindow(Ctrl, FALSE);
            
            Hr = g_pUiSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
        }
        else
        {
            EnableWindow(Ctrl, TRUE);

            Hr = g_pUiLocSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
        }
        if (Hr != S_OK)
        {
            InternalError(Hr, "UI GetSourcePath");
        }

        SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_SETTEXT, 0, (LPARAM)Path);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_PATH_BROWSE:
            BrowseForPathComponent(Hwnd,
                                   DLG_Browse_Source_Path_Title,
                                   DEF_Ext_SOURCE,
                                   &g_SourcePathDir,
                                   IDC_SOURCE_PATH);
            break;
            
        case IDC_LOCAL_SOURCE:
            if (IsDlgButtonChecked(Hwnd, IDC_LOCAL_SOURCE) != BST_CHECKED)
            {
                Hr = g_pUiSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
            }
            else
            {
                Hr = g_pUiLocSymbols->GetSourcePath(Path, _tsizeof(Path),
                                                    NULL);
            }
            if (Hr != S_OK)
            {
                InternalError(Hr, "UI GetSourcePath");
            }

            SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_SETTEXT, 0,
                               (LPARAM)Path);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SOURCE_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_GETTEXT,
                                      _tsizeof(Path), (LPARAM)Path);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            Path[Size] = 0;

            if (!g_RemoteClient ||
                IsDlgButtonChecked(Hwnd, IDC_LOCAL_SOURCE) != BST_CHECKED)
            {
                Hr = g_pUiSymbols->SetSourcePath(Path);
                Tag = WSP_GLOBAL_SOURCE_PATH;
            }
            else
            {
                Hr = g_pUiLocSymbols->SetSourcePath(Path);
                Tag = WSP_GLOBAL_LOCAL_SOURCE_PATH;
            }
            if (Hr != S_OK)
            {
                InternalError(Hr, "UI SetSourcePath");
            }

            if (g_Workspace != NULL)
            {
                g_Workspace->SetString(Tag, Path);
            }
                                             
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

#define MAX_IDS 4000

HTREEITEM
AppendTextToTree(HWND Tree, HTREEITEM Parent,
                 PSTR Text, int Children, LPARAM Param)
{
    TVINSERTSTRUCT Insert;

    Insert.hParent = Parent;
    Insert.hInsertAfter = TVI_LAST;
    Insert.item.mask = TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM;
    Insert.item.pszText = Text;
    Insert.item.cChildren = Children;
    Insert.item.lParam = Param;
    return TreeView_InsertItem(Tree, &Insert);
}

void
FillProcessList(HWND Tree)
{
    HRESULT Status;
    ULONG Ids[MAX_IDS];
    ULONG IdCount;
    ULONG i;

    TreeView_DeleteAllItems(Tree);

    if (g_ProcessServer && !g_CurProcessServer)
    {
        AppendTextToTree(Tree, TVI_ROOT,
                         "Unable to connect to process server", 0, 0);
        return;
    }
    
    if ((Status = g_pUiClient->
         GetRunningProcessSystemIds(g_CurProcessServer, Ids, MAX_IDS,
                                    &IdCount)) != S_OK)
    {
        AppendTextToTree(Tree, TVI_ROOT,
                         "Unable to get process IDs", 0, 0);
        return;
    }

    if (IdCount > MAX_IDS)
    {
        AppendTextToTree(Tree, TVI_ROOT,
                         "Incomplete process list", 0, 0);
        IdCount = MAX_IDS;
    }
    
    for (i = 0; i < IdCount; i++)
    {
        char IdAndExeName[MAX_PATH + 16];
        PSTR ExeName;

        if (Ids[i] >= 0x80000000)
        {
            sprintf(IdAndExeName, "0x%x", Ids[i]);
        }
        else
        {
            sprintf(IdAndExeName, "%4d", Ids[i]);
        }
        ExeName = IdAndExeName + strlen(IdAndExeName);
        *ExeName++ = ' ';

        Status = g_pUiClient->
            GetRunningProcessDescription(g_CurProcessServer, Ids[i],
                                         DEBUG_PROC_DESC_NO_PATHS,
                                         ExeName,
                                         (ULONG)(_tsizeof(IdAndExeName) -
                                                 (ExeName - IdAndExeName)),
                                         NULL,
                                         NULL, 0, NULL);
        if (FAILED(Status))
        {
            if (Status == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ||
                Status == HRESULT_FROM_NT(STATUS_ACCESS_DENIED))
            {
                sprintf(ExeName, "Access denied, check debug privilege");
            }
            else
            {
                sprintf(ExeName, "Error 0x%08X", Status);
            }
        }

        // Force a child so that we can lazily expand the
        // process description.
        // Parameter is the process ID.
        AppendTextToTree(Tree, TVI_ROOT, IdAndExeName, 1, Ids[i]);
    }
}

void
FillProcessChild(HWND Tree, LPTVITEM Parent)
{
    HRESULT Status;
    char DescBuf[2 * MAX_PATH];

    Status = g_pUiClient->
        GetRunningProcessDescription(g_CurProcessServer,
                                     (ULONG)Parent->lParam,
                                     DEBUG_PROC_DESC_DEFAULT,
                                     NULL, 0, NULL,
                                     DescBuf, _tsizeof(DescBuf), NULL);
    if (FAILED(Status))
    {
        sprintf(DescBuf, "<Error 0x%08X>", Status);
    }
    else if (!DescBuf[0])
    {
        strcpy(DescBuf, "<No information>");
    }

    AppendTextToTree(Tree, Parent->hItem, DescBuf, 0, 0);
}

INT_PTR CALLBACK
DlgProc_AttachProcess(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_PATH];
    HWND List;
    ULONG Pid;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        ClearDebuggingParams();
        
        if (g_ProcessServer != NULL)
        {
            if (g_pUiClient->
                ConnectProcessServer(g_ProcessServer,
                                     &g_CurProcessServer) != S_OK)
            {
                g_CurProcessServer = 0;
            }
        }
    
        List = GetDlgItem(Hwnd, IDC_ATTACH_PROC_LIST);
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        FillProcessList(List);
        SendDlgItemMessage(Hwnd, IDC_ATTACH_PID, WM_SETFONT,
                           (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        SendDlgItemMessage(Hwnd, IDC_ATTACH_PID, EM_LIMITTEXT,
                           _tsizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID), "");
        CheckDlgButton(Hwnd, IDC_ATTACH_NONINVASIVE, BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_ATTACH_TO_PROCESS);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID),
                          Text, _tsizeof(Text));
            Pid = strtoul(Text, NULL, 0);
            if (Pid)
            {
                g_PidToDebug = Pid;
                if (IsDlgButtonChecked(Hwnd, IDC_ATTACH_NONINVASIVE) ==
                    BST_CHECKED)
                {
                    g_AttachProcessFlags |= DEBUG_ATTACH_NONINVASIVE;
                }

                StartDebugging();
            }

            // Fall through.
        case IDCANCEL:
            if (g_CurProcessServer != 0)
            {
                g_pUiClient->DisconnectProcessServer(g_CurProcessServer);
                g_CurProcessServer = 0;
            }
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    case WM_NOTIFY:
        LPNMTREEVIEW Tvn;

        Tvn = (LPNMTREEVIEW)Lpm;
        if (Tvn->hdr.idFrom != IDC_ATTACH_PROC_LIST)
        {
            return 0;
        }

        switch(Tvn->hdr.code)
        {
        case TVN_SELCHANGED:
            if (Tvn->itemNew.lParam)
            {
                if (Tvn->itemNew.lParam >= 0x80000000)
                {
                    sprintf(Text, "0x%x", (ULONG)Tvn->itemNew.lParam);
                }
                else
                {
                    sprintf(Text, "%u", (ULONG)Tvn->itemNew.lParam);
                }
            }
            else
            {
                Text[0] = 0;
            }
            SetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID), Text);
            return 0;
        case TVN_ITEMEXPANDING:
            if (!(Tvn->itemNew.state & TVIS_EXPANDEDONCE))
            {
                FillProcessChild(Tvn->hdr.hwndFrom, &Tvn->itemNew);
            }
            return 0;
        default:
            return 0;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
FillEventFilters(HWND List)
{
    HRESULT Status;
    ULONG Width;
    RECT ListRect;

    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    SendMessage(List, WM_SETREDRAW, FALSE, 0);
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    GetClientRect(List, &ListRect);
    Width = ListRect.right - ListRect.left;
    
    Status = g_FilterBuffer->UiLockForRead();
    if (Status != S_OK)
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
        goto Update;
    }
    Status = g_FilterTextBuffer->UiLockForRead();
    if (Status != S_OK)
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
        goto UnlockFilter;
    }
    
    ULONG i;
    PSTR FilterArg, FilterText;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    char Str[256];
    ULONG Len;
    
    FilterText = (PSTR)g_FilterTextBuffer->GetDataBuffer();
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    ExParams =
        (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + g_NumSpecEvents);
    FilterArg = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterArgsOffset;

    for (i = 0; i < g_NumSpecEvents; i++)
    {
        CopyString(Str, FilterText, DIMA(Str));
        if (SpecParams->ArgumentSize > 1)
        {
            CatString(Str, " ", DIMA(Str));
            CatString(Str, FilterArg, DIMA(Str));
            FilterArg += strlen(FilterArg) + 1;
        }
        Len = strlen(Str);
        PrintString(Str + Len, DIMA(Str) - Len, " - %s - %s",
                    g_ExecutionNames[SpecParams->ExecutionOption],
                    g_ContinueNames[SpecParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        FilterText += strlen(FilterText) + 1;
        SpecParams++;
    }
    for (i = 0; i < g_NumSpecEx; i++)
    {
        PrintString(Str, DIMA(Str), "%s - %s - %s",
                    FilterText,
                    g_ExecutionNames[ExParams->ExecutionOption],
                    g_ContinueNames[ExParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        FilterText += strlen(FilterText) + 1;
        ExParams++;
    }
    for (i = 0; i < g_NumArbEx; i++)
    {
        PrintString(Str, DIMA(Str), "Exception %08X - %s - %s",
                    ExParams->ExceptionCode,
                    g_ExecutionNames[ExParams->ExecutionOption],
                    g_ContinueNames[ExParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        ExParams++;
    }

    UnlockStateBuffer(g_FilterTextBuffer);
 UnlockFilter:
    UnlockStateBuffer(g_FilterBuffer);

 Update:
    SendMessage(List, LB_SETHORIZONTALEXTENT, Width, 0);
    SendMessage(List, WM_SETREDRAW, TRUE, 0);
    if (ListSel != LB_ERR)
    {
        SendMessage(List, LB_SETCURSEL, ListSel, 0);
    }
}

void
GetFilterOptions(int Index, PULONG CodeArg, PULONG Exe, PULONG Cont)
{
    *CodeArg = 0;
    *Exe = 0;
    *Cont = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    ExParams =
        (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + g_NumSpecEvents);

    if ((ULONG)Index < g_NumSpecEvents)
    {
        SpecParams += Index;
        *CodeArg = SpecParams->ArgumentSize;
        *Exe = SpecParams->ExecutionOption;
        *Cont = SpecParams->ContinueOption;
    }
    else
    {
        ExParams += Index - g_NumSpecEvents;
        *CodeArg = ExParams->ExceptionCode;
        *Exe = ExParams->ExecutionOption;
        *Cont = ExParams->ContinueOption;
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

void
GetFilterArgument(int Index, PTSTR Argument, ULONG Size)
{
    *Argument = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    int i;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PSTR FilterArg;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    FilterArg = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterArgsOffset;
    
    for (i = 0; i < Index; i++)
    {
        if (SpecParams->ArgumentSize > 1)
        {
            FilterArg += strlen(FilterArg) + 1;
        }

        SpecParams++;
    }

    if (SpecParams->ArgumentSize > 1)
    {
        CopyString(Argument, FilterArg, Size);
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

void
GetFilterCommands(ULONG Index,
                  PTSTR Argument1, ULONG Size1,
                  PTSTR Argument2, ULONG Size2)
{
    *Argument1 = 0;
    *Argument2 = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    ULONG i, Limit;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PSTR FilterCmd;
    ULONG CmdSize1, CmdSize2;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    FilterCmd = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterCmdsOffset;

    if (Index < g_NumSpecEvents)
    {
        Limit = Index;
    }
    else
    {
        Limit = g_NumSpecEvents;
    }
    
    for (i = 0; i < Limit; i++)
    {
        if (SpecParams->CommandSize > 0)
        {
            FilterCmd += strlen(FilterCmd) + 1;
        }

        SpecParams++;
    }

    if (Index >= g_NumSpecEvents)
    {
        PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams =
            (PDEBUG_EXCEPTION_FILTER_PARAMETERS)SpecParams;
        while (i < Index)
        {
            if (ExParams->CommandSize > 0)
            {
                FilterCmd += strlen(FilterCmd) + 1;
            }
            if (ExParams->SecondCommandSize > 0)
            {
                FilterCmd += strlen(FilterCmd) + 1;
            }

            i++;
            ExParams++;
        }

        CmdSize1 = ExParams->CommandSize;
        CmdSize2 = ExParams->SecondCommandSize;
    }
    else
    {
        CmdSize1 = SpecParams->CommandSize;
        CmdSize2 = 0;
    }

    if (CmdSize1 > 0)
    {
        CopyString(Argument1, FilterCmd, Size1);
    }
    if (CmdSize2 > 0)
    {
        FilterCmd += strlen(FilterCmd) + 1;
        CopyString(Argument2, FilterCmd, Size2);
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

INT_PTR CALLBACK
DlgProc_EventFilters(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    UIC_SET_FILTER_DATA* SetFilter;
    HWND List = GetDlgItem(Hwnd, IDC_FILTERS);
    int Sel = (int)SendMessage(List, LB_GETCURSEL, 0, 0);
    HWND Remove, Command, Arg;
    ULONG CodeArg, Exe, Cont;
    UINT Id;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        g_FilterBuffer->m_Win = Hwnd;
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        FillEventFilters(List);
        break;

    case WM_COMMAND:
        Id = LOWORD(Wpm);
        switch(Id)
        {
        case IDC_FILTERS:
            Remove = GetDlgItem(Hwnd, IDC_FILTER_REMOVE);
            Arg = GetDlgItem(Hwnd, IDC_FILTER_ARGUMENT);
            Command = GetDlgItem(Hwnd, IDC_FILTER_COMMAND);
            if (Sel >= 0)
            {
                EnableWindow(Remove,
                             (ULONG)Sel >= g_NumSpecEvents + g_NumSpecEx);
                GetFilterOptions(Sel, &CodeArg, &Exe, &Cont);
                CheckRadioButton(Hwnd, IDC_FILTER_ENABLED,
                                 IDC_FILTER_IGNORE,
                                 (Exe - DEBUG_FILTER_BREAK) +
                                 IDC_FILTER_ENABLED);
                CheckRadioButton(Hwnd, IDC_FILTER_HANDLED,
                                 IDC_FILTER_NOT_HANDLED,
                                 (Cont - DEBUG_FILTER_GO_HANDLED) +
                                 IDC_FILTER_HANDLED);
                
                if ((ULONG)Sel < g_NumSpecEvents)
                {
                    GetFilterOptions(Sel, &CodeArg, &Exe, &Cont);
                    EnableWindow(Arg, CodeArg > 0);
                }

                EnableWindow(Command, TRUE);
            }
            else
            {
                EnableWindow(Remove, FALSE);
                EnableWindow(Arg, FALSE);
                EnableWindow(Command, FALSE);
            }
            break;

        case IDC_FILTER_ADD:
            StartDialog(IDD_DLG_EXCEPTION_FILTER, DlgProc_ExceptionFilter,
                        NULL);
            break;

        case IDC_FILTER_REMOVE:
            if (Sel >= 0)
            {
                SetFilter = StartStructCommand(UIC_SET_FILTER);
                if (SetFilter != NULL)
                {
                    SetFilter->Index = 0xffffffff;
                    GetFilterOptions(Sel,
                                     &SetFilter->Code,
                                     &SetFilter->Execution,
                                     &SetFilter->Continue);
                    SetFilter->Execution = DEBUG_FILTER_REMOVE;
                    FinishCommand();
                }
            }
            break;

        case IDC_FILTER_ARGUMENT:
            if (Sel >= 0 && (ULONG)Sel < g_NumSpecEvents)
            {
                GetFilterArgument(Sel, g_DlgString,
                                  _tsizeof(g_DlgString));
                
                if (StartDialog(IDD_DLG_FILTER_ARGUMENT,
                                DlgProc_FilterArgument,
                                NULL) == IDOK)
                {
                    UIC_SET_FILTER_ARGUMENT_DATA* SetFilterArg;
                    SetFilterArg = (UIC_SET_FILTER_ARGUMENT_DATA*)
                        StartCommand(UIC_SET_FILTER_ARGUMENT,
                                     sizeof(*SetFilterArg) +
                                     strlen(g_DlgString));
                    if (SetFilterArg != NULL)
                    {
                        SetFilterArg->Index = Sel;
                        strcpy(SetFilterArg->Argument, g_DlgString);
                        FinishCommand();
                    }
                }
            }
            break;
            
        case IDC_FILTER_COMMAND:
            if (Sel >= 0)
            {
                GetFilterCommands(Sel,
                                  g_DlgString, _tsizeof(g_DlgString),
                                  g_DlgString2, _tsizeof(g_DlgString2));

                if (StartDialog(IDD_DLG_FILTER_COMMAND,
                                DlgProc_FilterCommand,
                                (ULONG)Sel >= g_NumSpecEvents) == IDOK)
                {
                    UIC_SET_FILTER_COMMAND_DATA* SetFilterCmd;
                    
                    SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)
                        StartCommand(UIC_SET_FILTER_COMMAND,
                                     sizeof(*SetFilterCmd) +
                                     strlen(g_DlgString));
                    if (SetFilterCmd != NULL)
                    {
                        SetFilterCmd->Which = 0;
                        SetFilterCmd->Index = Sel;
                        strcpy(SetFilterCmd->Command, g_DlgString);
                        FinishCommand();
                    }

                    if ((ULONG)Sel <= g_NumSpecEvents)
                    {
                        break;
                    }
                    
                    SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)
                        StartCommand(UIC_SET_FILTER_COMMAND,
                                     sizeof(*SetFilterCmd) +
                                     strlen(g_DlgString2));
                    if (SetFilterCmd != NULL)
                    {
                        SetFilterCmd->Which = 1;
                        SetFilterCmd->Index = Sel;
                        strcpy(SetFilterCmd->Command, g_DlgString2);
                        FinishCommand();
                    }
                }
            }
            break;
            
        case IDC_FILTER_ENABLED:
        case IDC_FILTER_DISABLED:
        case IDC_FILTER_OUTPUT:
        case IDC_FILTER_IGNORE:
        case IDC_FILTER_HANDLED:
        case IDC_FILTER_NOT_HANDLED:
            if (Sel >= 0)
            {
                SetFilter = StartStructCommand(UIC_SET_FILTER);
                if (SetFilter != NULL)
                {
                    SetFilter->Index = (ULONG)Sel < g_NumSpecEvents ?
                        Sel : 0xffffffff;
                    GetFilterOptions(Sel,
                                     &SetFilter->Code,
                                     &SetFilter->Execution,
                                     &SetFilter->Continue);
                    if (Id >= IDC_FILTER_ENABLED && Id <= IDC_FILTER_IGNORE)
                    {
                        SetFilter->Execution = (Id - IDC_FILTER_ENABLED) +
                            DEBUG_FILTER_BREAK;
                    }
                    else
                    {
                        SetFilter->Continue = (Id - IDC_FILTER_HANDLED) +
                            DEBUG_FILTER_GO_HANDLED;
                    }
                    FinishCommand();
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDCANCEL:
            g_FilterBuffer->m_Win = NULL;
            EndDialog(Hwnd, Id);
            break;
        }
        break;

    case LB_RESETCONTENT:
        FillEventFilters(List);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_ExceptionFilter(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Code = GetDlgItem(Hwnd, IDC_FILTER_CODE);
    char CodeText[80];
    UIC_SET_FILTER_DATA* SetFilter;
    static UINT s_Execution;
    static UINT s_Continue;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Code, EM_LIMITTEXT, _tsizeof(CodeText) - 1, 0);
        SetWindowText(Code, "");
        s_Execution = IDC_FILTER_ENABLED;
        s_Continue = IDC_FILTER_NOT_HANDLED;
        CheckRadioButton(Hwnd, IDC_FILTER_ENABLED,
                         IDC_FILTER_IGNORE, s_Execution);
        CheckRadioButton(Hwnd, IDC_FILTER_HANDLED,
                         IDC_FILTER_NOT_HANDLED, s_Continue);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_FILTER_ENABLED:
        case IDC_FILTER_DISABLED:
        case IDC_FILTER_OUTPUT:
        case IDC_FILTER_IGNORE:
            s_Execution = LOWORD(Wpm);
            break;

        case IDC_FILTER_HANDLED:
        case IDC_FILTER_NOT_HANDLED:
            s_Continue = LOWORD(Wpm);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            int InputCode;

            if (GetWindowText(Code, CodeText, _tsizeof(CodeText)) == 0)
            {
                MessageBeep(-1);
                break;
            }

            if (sscanf(CodeText, "%x", &InputCode) != 1)
            {
                MessageBeep(-1);
                break;
            }
            
            SetFilter = StartStructCommand(UIC_SET_FILTER);
            if (SetFilter != NULL)
            {
                SetFilter->Index = 0xffffffff;
                SetFilter->Code = InputCode;
                SetFilter->Execution = (s_Execution - IDC_FILTER_ENABLED) +
                    DEBUG_FILTER_BREAK;
                SetFilter->Continue = (s_Continue - IDC_FILTER_HANDLED) +
                    DEBUG_FILTER_GO_HANDLED;
                FinishCommand();
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_FilterArgument(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Arg = GetDlgItem(Hwnd, IDC_FILTER_ARGUMENT);
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Arg, EM_LIMITTEXT, _tsizeof(g_DlgString) - 1, 0);
        SetWindowText(Arg, g_DlgString);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            if (GetWindowText(Arg, g_DlgString,
                              _tsizeof(g_DlgString)) == 0)
            {
                g_DlgString[0] = 0;
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_FilterCommand(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Cmd1 = GetDlgItem(Hwnd, IDC_FILTER_COMMAND);
    HWND Cmd2 = GetDlgItem(Hwnd, IDC_FILTER_COMMAND2);
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Cmd1, EM_LIMITTEXT, _tsizeof(g_DlgString) - 1, 0);
        SetWindowText(Cmd1, g_DlgString);
        SendMessage(Cmd2, EM_LIMITTEXT, _tsizeof(g_DlgString2) - 1, 0);
        SetWindowText(Cmd2, g_DlgString2);
        EnableWindow(Cmd2, (BOOL)Lpm);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            if (GetWindowText(Cmd1, g_DlgString, _tsizeof(g_DlgString)) == 0)
            {
                g_DlgString[0] = 0;
            }
            if (GetWindowText(Cmd2, g_DlgString2, _tsizeof(g_DlgString2)) == 0)
            {
                g_DlgString2[0] = 0;
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

ULONG
EditTabToUserTab(ULONG EditTab)
{
    return EditTab / 4;
}

ULONG
UserTabToEditTab(ULONG UserTab)
{
    return UserTab * 4;
}

INT_PTR CALLBACK
DlgProc_Options(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Ctrl;
    char Text[256];
    LRESULT Sel, Idx;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        ULONG EngOptions;
        LONG Width;
        HDC FontDc;
            
        SendDlgItemMessage(Hwnd, IDC_OPTION_TAB_WIDTH, EM_LIMITTEXT,
                           _tsizeof(Text) - 1, 0);
        _itoa(EditTabToUserTab(g_TabWidth), Text, 10);
        SetWindowText(GetDlgItem(Hwnd, IDC_OPTION_TAB_WIDTH), Text);
        
        g_pUiControl->GetEngineOptions(&EngOptions);
        CheckDlgButton(Hwnd, IDC_OPTION_REPEAT_COMMANDS,
                       (EngOptions & DEBUG_ENGOPT_NO_EXECUTE_REPEAT) == 0 ?
                       BST_CHECKED : BST_UNCHECKED);

        Ctrl = GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST);
        SendMessage(Ctrl, WM_SETFONT, (WPARAM)g_Fonts[FONT_VARIABLE].Font, 0);
        FontDc = GetDC(Ctrl);
        SelectObject(FontDc, g_Fonts[FONT_VARIABLE].Font);
        Width = 0;
        SendMessage(Ctrl, LB_RESETCONTENT, 0, 0);
        for (Sel = 0; Sel < COL_COUNT; Sel++)
        {
            Idx = SendMessage(Ctrl, LB_ADDSTRING,
                              0, (LPARAM)g_Colors[Sel].Name);
            SendMessage(Ctrl, LB_SETITEMDATA, Idx, Sel);
            if (FontDc != NULL)
            {
                SIZE Extent;

                if (GetTextExtentPoint32(FontDc, g_Colors[Sel].Name,
                                         strlen(g_Colors[Sel].Name),
                                         &Extent) &&
                    Extent.cx > Width)
                {
                    Width = Extent.cx;
                }
            }
        }
        for (Sel = 0; Sel < OUT_MASK_COL_COUNT; Sel++)
        {
            if (g_OutMaskColors[Sel].Name != NULL)
            {
                Idx = SendMessage(Ctrl, LB_ADDSTRING,
                                  0, (LPARAM)g_OutMaskColors[Sel].Name);
                SendMessage(Ctrl, LB_SETITEMDATA,
                            Idx, Sel + OUT_MASK_COL_BASE);
                if (FontDc != NULL)
                {
                    SIZE Extent;

                    if (GetTextExtentPoint32(FontDc, g_OutMaskColors[Sel].Name,
                                             strlen(g_OutMaskColors[Sel].Name),
                                             &Extent) &&
                        Extent.cx > Width)
                    {
                        Width = Extent.cx;
                    }
                }
            }
        }
        SendMessage(Ctrl, LB_SETCURSEL, 0, 0);
        if (FontDc != NULL)
        {
            ReleaseDC(Ctrl, FontDc);
        }
        Width += g_Fonts[FONT_VARIABLE].Metrics.tmAveCharWidth;
        SendMessage(Ctrl, LB_SETHORIZONTALEXTENT, Width, 0);
        
        CheckDlgButton(Hwnd, IDC_OPTION_DISASM_ACTIVATE_SOURCE,
                       g_DisasmActivateSource ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(Hwnd, IDC_OPTION_AUTO_CMD_SCROLL,
                       g_AutoCmdScroll ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_CTLCOLORSTATIC:
        if ((HWND)Lpm == GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY))
        {
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                Idx = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                                  LB_GETITEMDATA, Sel, 0);
                INDEXED_COLOR* IdxCol = GetIndexedColor((ULONG)Idx);
                if (IdxCol != NULL)
                {
                    return (INT_PTR)IdxCol->Brush;
                }
            }
        }
        break;
        
    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_OPTION_COLOR_LIST:
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                InvalidateRect(GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY),
                               NULL, TRUE);
            }
            break;

        case IDC_OPTION_COLOR_CHANGE:
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                Idx = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                                  LB_GETITEMDATA, Sel, 0);
                if (SelectColor(g_hwndFrame, (ULONG)Idx))
                {
                    InvalidateRect(GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY),
                                   NULL, TRUE);
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_OPTIONS);
            break;
            
        case IDOK:
            if (GetWindowText(GetDlgItem(Hwnd, IDC_OPTION_TAB_WIDTH),
                              Text, _tsizeof(Text)) == 0)
            {
                MessageBeep(-1);
                break;
            }

            if (sscanf(Text, "%d", &g_TabWidth) != 1)
            {
                MessageBeep(-1);
            }
            
            g_TabWidth = UserTabToEditTab(g_TabWidth);
            SetTabWidth(g_TabWidth);

            ULONG RepeatState;
            
            if (IsDlgButtonChecked(Hwnd, IDC_OPTION_REPEAT_COMMANDS) ==
                BST_CHECKED)
            {
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
                RepeatState = TRUE;
            }
            else
            {
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
                RepeatState = FALSE;
            }
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_REPEAT_COMMANDS, RepeatState);
            }

            UpdateAllColors();
            
            g_DisasmActivateSource =
                IsDlgButtonChecked(Hwnd, IDC_OPTION_DISASM_ACTIVATE_SOURCE) ==
                BST_CHECKED;
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_DISASM_ACTIVATE_SOURCE,
                                      g_DisasmActivateSource);
            }
            
            g_AutoCmdScroll =
                IsDlgButtonChecked(Hwnd, IDC_OPTION_AUTO_CMD_SCROLL) ==
                BST_CHECKED;
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_AUTO_CMD_SCROLL,
                                      g_AutoCmdScroll);
            }
            
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
ClwFillSaveList(HWND List)
{
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    if (g_Workspace != NULL)
    {
        WSP_ENTRY* Entry = NULL;
        LRESULT Idx;
        BOOL CommonWinDone = FALSE;
        BOOL RegCustomize = FALSE;
    
        while ((Entry = g_Workspace->NextEntry(Entry)) != NULL)
        {
            if (Entry->Tag == WSP_WINDOW_COMMONWIN_1)
            {
                if (CommonWinDone)
                {
                    continue;
                }
                
                CommonWinDone = TRUE;
            }
            else if (Entry->Tag == WSP_GLOBAL_REGISTER_MAP ||
                     Entry->Tag == WSP_GLOBAL_PROC_REGISTER_MAP ||
                     Entry->Tag == WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP)
            {
                if (RegCustomize)
                {
                    continue;
                }

                RegCustomize = TRUE;
            }
            
            Idx = SendMessage(List, LB_ADDSTRING, 0, (LPARAM)
                              GetWspTagName(Entry->Tag));
            SendMessage(List, LB_SETITEMDATA, Idx, (LPARAM)Entry->Tag);
        }
    }
    
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

void
ClwMoveBetweenLists(HWND From, HWND To, LRESULT Item)
{
    LPARAM Data = SendMessage(From, LB_GETITEMDATA, Item, 0);
    SendMessage(From, LB_DELETESTRING, Item, 0);
    Item = SendMessage(To, LB_ADDSTRING, 0, (LPARAM)
                       GetWspTagName((WSP_TAG)Data));
    SendMessage(To, LB_SETITEMDATA, Item, Data);
}

void
ClwMoveAllBetweenLists(HWND From, HWND To)
{
    LRESULT Count = SendMessage(From, LB_GETCOUNT, 0, 0);
    while (Count-- > 0)
    {
        ClwMoveBetweenLists(From, To, 0);
    }
}

void
ClwMoveSelectedBetweenLists(HWND From, HWND To)
{
    int Sel[1];
    LRESULT Count;

    // Move items one at a time as the indices change
    // when items are moved.
    for (;;)
    {
        Count = SendMessage(From, LB_GETSELITEMS,
                            sizeof(Sel) / sizeof(Sel[0]), (LPARAM)Sel);
        if (Count <= 0)
        {
            break;
        }

        ClwMoveBetweenLists(From, To, Sel[0]);
    }
}

void
ClwProcessClearList(HWND List)
{
    LRESULT Count = SendMessage(List, LB_GETCOUNT, 0, 0);
    LRESULT i;
    WSP_TAG Tag;

    for (i = 0; i < Count; i++)
    {
        Tag = (WSP_TAG)SendMessage(List, LB_GETITEMDATA, i, 0);
        g_Workspace->Delete(Tag, WSP_GROUP_MASK | WSP_ITEM_MASK);
    }

    // If everything is deleted from an explicit workspace
    // delete the workspace from the explicit registry area.
    if (g_ExplicitWorkspace && g_Workspace->IsEmpty())
    {
        g_Workspace->DeleteReg(TRUE);
        delete g_Workspace;
        g_Workspace = NULL;
    }
}

INT_PTR CALLBACK
DlgProc_ClearWorkspace(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch(Message)
    {
    case WM_INITDIALOG:
        AddWorkspaceNameToTitle(Hwnd);
        ClwFillSaveList(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_CLW_CLEAR:
            ClwMoveSelectedBetweenLists(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST),
                                        GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            break;
        case IDC_CLW_CLEAR_ALL:
            ClwMoveAllBetweenLists(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST),
                                   GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            break;
        case IDC_CLW_SAVE:
            ClwMoveSelectedBetweenLists(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST),
                                        GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
            break;
        case IDC_CLW_SAVE_ALL:
            ClwMoveAllBetweenLists(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST),
                                   GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CLEAR_WORKSPACE);
            break;

        case IDOK:
            ClwProcessClearList(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

enum
{
    MODCOL_NAME,
    MODCOL_START,
    MODCOL_END,
    MODCOL_TIMESTAMP,
    MODCOL_CHECKSUM,
    MODCOL_SYMBOL_TYPE,
    MODCOL_SYMBOL_FILE
};

void
InitializeModuleList(HWND List)
{
    SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
    
    LVCOLUMN Column;

    // First column is for the module name.
    Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
    Column.fmt = LVCFMT_LEFT;
    Column.pszText = "Name";
    Column.cx = 15 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_NAME;
    ListView_InsertColumn(List, 0, &Column);

    // Second column is for start address.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Start";
    Column.cx = (10 + (g_Ptr64 ? 9 : 0)) *
        g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_START;
    ListView_InsertColumn(List, 1, &Column);

    // Third column is for end address.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "End";
    Column.cx = (10 + (g_Ptr64 ? 9 : 0)) *
        g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_END;
    ListView_InsertColumn(List, 2, &Column);

    // Fourth column is for timestamp.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Timestamp";
    Column.cx = 37 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_TIMESTAMP;
    ListView_InsertColumn(List, 3, &Column);

    // Fifth column is for checksum.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Checksum";
    Column.cx = 10 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_CHECKSUM;
    ListView_InsertColumn(List, 4, &Column);

    // Sixth column is for symbol type.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Symbols";
    Column.cx = 9 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_SYMBOL_TYPE;
    ListView_InsertColumn(List, 5, &Column);

    // Seventh column is for symbol file.
    Column.fmt = LVCFMT_LEFT;
    Column.pszText = "Symbol file";
    Column.cx = 80 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_SYMBOL_FILE;
    ListView_InsertColumn(List, 6, &Column);
}

void
FillModuleList(HWND List)
{
    LVCOLUMN Column;

    Column.mask = LVCF_FMT;
    if (!ListView_GetColumn(List, 0, &Column))
    {
        InitializeModuleList(List);
    }

    LVITEM Item;
    ULONG i;
    char Image[128];
    char Text[128];
    char Path[MAX_PATH];
    
    ListView_DeleteAllItems(List);

    if (g_ModuleBuffer->UiLockForRead() != S_OK)
    {
        Item.mask = LVIF_TEXT;
        Item.iItem = 0;
        Item.iSubItem = 0;
        Item.pszText = "Unable to retrieve module list";
        ListView_InsertItem(List, &Item);
        return;
    }

    PDEBUG_MODULE_PARAMETERS Params = (PDEBUG_MODULE_PARAMETERS)
        g_ModuleBuffer->GetDataBuffer();
    
    for (i = 0; i < g_NumModules; i++)
    {
        PSTR LoadBuf;
        ULONG LoadBufLen;
        
        if ((Params->Flags & DEBUG_MODULE_UNLOADED) ||
            g_pUiSymbols2 == NULL ||
            g_pUiSymbols2->
            GetModuleNameString(DEBUG_MODNAME_SYMBOL_FILE, DEBUG_ANY_ID,
                                Params->Base, Path, _tsizeof(Path),
                                NULL) != S_OK)
        {
            LoadBuf = Path;
            LoadBufLen = _tsizeof(Path);
        }
        else
        {
            LoadBuf = NULL;
            LoadBufLen = 0;
        }
        
        if (g_pUiSymbols->GetModuleNames(DEBUG_ANY_ID, Params->Base,
                                         Image, _tsizeof(Image), NULL,
                                         Text, _tsizeof(Text), NULL,
                                         LoadBuf, LoadBufLen, NULL) != S_OK)
        {
            strcpy(Text, "<Unable to get name>");
            if (LoadBuf != NULL)
            {
                strcpy(LoadBuf, "<Unable to get name>");
            }
        }

        if (Params->Flags & DEBUG_MODULE_UNLOADED)
        {
            strcpy(Text, "<Unloaded>");
            strcpy(Path, Image);
        }
        
        Item.mask = LVIF_TEXT | LVIF_PARAM;
        Item.iItem = i;
        Item.iSubItem = MODCOL_NAME;
        Item.pszText = Text;
        Item.lParam = i;
        ListView_InsertItem(List, &Item);

        ListView_SetItemText(List, i, MODCOL_START,
                             FormatAddr64(Params->Base));
        
        ListView_SetItemText(List, i, MODCOL_END,
                             FormatAddr64(Params->Base + Params->Size));

        if (Params->TimeDateStamp < 0xfffffffe)
        {
            ULONG Len;
            
            time_t Time = (time_t)Params->TimeDateStamp;
            CopyString(Text, ctime(&Time), DIMA(Text));
            Len = strlen(Text) - 1;
            PrintString(Text + Len, DIMA(Text) - Len,
                        " (%08x)", Params->TimeDateStamp);
        }
        else
        {
            strcpy(Text, "Unavailable");
        }
        ListView_SetItemText(List, i, MODCOL_TIMESTAMP, Text);

        sprintf(Text, "%08x", Params->Checksum);
        ListView_SetItemText(List, i, MODCOL_CHECKSUM, Text);

        if (Params->SymbolType != DEBUG_SYMTYPE_DEFERRED &&
            Params->SymbolType <
            sizeof(g_SymbolTypeNames) / sizeof(g_SymbolTypeNames[0]))
        {
            ListView_SetItemText(List, i, MODCOL_SYMBOL_TYPE,
                                 g_SymbolTypeNames[Params->SymbolType]);
        }
        else
        {
            ListView_SetItemText(List, i, MODCOL_SYMBOL_TYPE, "");
        }

        ListView_SetItemText(List, i, MODCOL_SYMBOL_FILE, Path);
        
        Params++;
    }

    UnlockStateBuffer(g_ModuleBuffer);
}

struct SORT_MODULE
{
    HWND List;
    int Column;
    BOOL Invert;
};

int CALLBACK
SortModuleCompare(LPARAM Lpm1, LPARAM Lpm2, LPARAM LpmSort)
{
    SORT_MODULE* Sort = (SORT_MODULE*)LpmSort;
    LVITEM Item;
    char Text1[MAX_PATH], Text2[MAX_PATH];
    PDEBUG_MODULE_PARAMETERS Param1, Param2;
    int Invert = Sort->Invert ? -1 : 1;

    switch(Sort->Column)
    {
    case MODCOL_NAME:
    case MODCOL_START:
    case MODCOL_END:
    case MODCOL_CHECKSUM:
    case MODCOL_SYMBOL_TYPE:
    case MODCOL_SYMBOL_FILE:
        Item.mask = LVIF_TEXT;
        Item.iItem = (int)Lpm1;
        Item.iSubItem = Sort->Column;
        Item.pszText = Text1;
        Item.cchTextMax = _tsizeof(Text1);
        ListView_GetItem(Sort->List, &Item);
        Item.iItem = (int)Lpm2;
        Item.pszText = Text2;
        Item.cchTextMax = _tsizeof(Text2);
        ListView_GetItem(Sort->List, &Item);
        
        // Sort all empty text towards the bottom.
        if (Text1[0] == 0 && Text2[0] != 0)
        {
            return 1;
        }
        else if (Text2[0] == 0 && Text1[0] != 0)
        {
            return -1;
        }
        
        return _strcmpi(Text1, Text2) * Invert;
        
    case MODCOL_TIMESTAMP:
        Item.mask = LVIF_PARAM;
        Item.iItem = (int)Lpm1;
        Item.iSubItem = 0;
        ListView_GetItem(Sort->List, &Item);
        Param1 = (PDEBUG_MODULE_PARAMETERS)
            g_ModuleBuffer->GetDataBuffer() + Item.lParam;
        Item.iItem = (int)Lpm2;
        ListView_GetItem(Sort->List, &Item);
        Param2 = (PDEBUG_MODULE_PARAMETERS)
            g_ModuleBuffer->GetDataBuffer() + Item.lParam;
        switch(Sort->Column)
        {
        case MODCOL_TIMESTAMP:
            return Param1->TimeDateStamp < Param2->TimeDateStamp ?
                (-1 * Invert) :
                    (Param1->TimeDateStamp > Param2->TimeDateStamp ?
                     (1 * Invert) : 0);
        }
    }

    return 0;
}

void
SortModuleColumns(HWND List, int Column, BOOL Invert)
{
    if (g_ModuleBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    SORT_MODULE Sort = {List, Column, Invert};
    ListView_SortItemsEx(List, SortModuleCompare, (LPARAM)&Sort);

    UnlockStateBuffer(g_ModuleBuffer);
}

INT_PTR CALLBACK
DlgProc_Modules(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    static int s_LastSortCol;
    static BOOL s_Invert;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        s_LastSortCol = -1;
        s_Invert = FALSE;
        g_ModuleBuffer->m_Win = Hwnd;
        FillModuleList(GetDlgItem(Hwnd, IDC_MODULE_LIST));
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_MODULES);
            break;

        case IDCANCEL:
            g_ModuleBuffer->m_Win = NULL;
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    case WM_NOTIFY:
        if (Wpm == IDC_MODULE_LIST)
        {
            LPNMLISTVIEW Notify = (LPNMLISTVIEW)Lpm;
            
            if (Notify->hdr.code == LVN_COLUMNCLICK)
            {
                if (Notify->iSubItem == s_LastSortCol)
                {
                    s_Invert = !s_Invert;
                }
                s_LastSortCol = Notify->iSubItem;
                SortModuleColumns(GetDlgItem(Hwnd, IDC_MODULE_LIST),
                                  Notify->iSubItem, s_Invert);
            }
        }
        break;
        
    case LB_RESETCONTENT:
        FillModuleList(GetDlgItem(Hwnd, IDC_MODULE_LIST));
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}

void
EnumWorkspaceKey(HWND List, HKEY BaseKey, ULONG SubKey, BOOL ShowSubKey,
                 BOOL OmitCurrent)
{
    LONG Status;
    HKEY Key;
    char Text[128];

    sprintf(Text, WSP_REG_KEY "\\%s", g_WorkspaceKeyNames[SubKey]);
    if ((Status = RegOpenKeyEx(BaseKey, Text,
                               0, KEY_ALL_ACCESS, &Key)) != ERROR_SUCCESS)
    {
        return;
    }

    ULONG Index;
    char Name[MAX_WSP_NAME];
    ULONG NameLen;
    ULONG Type;
    ULONG Item;

    Index = 0;
    for (;;)
    {
        NameLen = sizeof(Name);
        if ((Status = RegEnumValue(Key, Index, Name, &NameLen,
                                   NULL, &Type, NULL, 0)) != ERROR_SUCCESS)
        {
            // Done with the enumeration.
            break;
        }
        if (Type != REG_BINARY)
        {
            // Only binary values should be present.
            break;
        }

        if (OmitCurrent && g_Workspace &&
            SubKey == g_Workspace->GetKey() &&
            !strcmp(g_Workspace->GetValue(), Name))
        {
            Index++;
            continue;
        }
        
        if (ShowSubKey)
        {
            PrintString(Text, DIMA(Text), "%s - %s",
                        g_WorkspaceKeyDescriptions[SubKey], Name);
            Item = (ULONG)SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Text);
        }
        else
        {
            Item = (ULONG)SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Name);
        }
        SendMessage(List, LB_SETITEMDATA, Item, SubKey);
        
        Index++;
    }

    RegCloseKey(Key);
}

void
FillWorkspaceList(HWND List)
{
    SendMessage(List, LB_RESETCONTENT, 0, 0);
    EnumWorkspaceKey(List, HKEY_CURRENT_USER, WSP_NAME_EXPLICIT,
                     FALSE, FALSE);
    EnumWorkspaceKey(List, HKEY_LOCAL_MACHINE, WSP_NAME_EXPLICIT,
                     FALSE, FALSE);
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

INT_PTR CALLBACK
DlgProc_OpenWorkspace(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Name[MAX_WSP_NAME];
    LRESULT Sel;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowText(Hwnd, "Open Workspace");
        SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, EM_LIMITTEXT,
                           _tsizeof(Name) - 1, 0);
        FillWorkspaceList(GetDlgItem(Hwnd, IDC_WORKSPACE_LIST));
        SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            Sel = SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST, LB_GETTEXT,
                                   Sel, (LPARAM)Name))
            {
                SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), Name);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_OPEN_WORKSPACE);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, WM_GETTEXT,
                                   _tsizeof(Name), (LPARAM)Name))
            {
                UiSwitchToExplicitWorkspace(WSP_NAME_EXPLICIT, Name);
            }
            
            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_SaveWorkspaceAs(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Name[MAX_WSP_NAME];
    LRESULT Sel;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowText(Hwnd, "Save Workspace As");
        AddWorkspaceNameToTitle(Hwnd);
        SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, EM_LIMITTEXT,
                           _tsizeof(Name) - 1, 0);
        FillWorkspaceList(GetDlgItem(Hwnd, IDC_WORKSPACE_LIST));
        SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME),
                      g_Workspace->GetValue());
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            Sel = SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST, LB_GETTEXT,
                                   Sel, (LPARAM)Name))
            {
                SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), Name);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SAVE_WORKSPACE_AS);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, WM_GETTEXT,
                                   _tsizeof(Name), (LPARAM)Name) == 0)
            {
                MessageBeep(0);
                break;
            }

            UiSaveWorkspaceAs(WSP_NAME_EXPLICIT, Name);

            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_AddToCommandHistory(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    PSTR TextEnd;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_ATCH_TEXT, EM_LIMITTEXT,
                           _tsizeof(Text) - 2, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ATCH_TEXT), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_ADD_TO_COMMAND_OUTPUT);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ATCH_TEXT),
                          Text, _tsizeof(Text) - 1);
            TextEnd = Text + strlen(Text);
            *TextEnd++ = '\n';
            *TextEnd = 0;
            CmdOutput(Text,
                      g_OutMaskColors[USER_OUT_MASK_COL].Color,
                      g_OutMaskColors[USER_OUT_MASK_COL + 1].Color);
            // Send output for logging only.
            g_pUiControl->ControlledOutput(DEBUG_OUTCTL_LOG_ONLY,
                                           DEBUG_OUTPUT_NORMAL,
                                           "%s", Text);
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
FillDeleteWorkspacesList(HWND List)
{
    int i;
    
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    for (i = 0; i < WSP_REG_NAME_COUNT; i++)
    {
        EnumWorkspaceKey(List, HKEY_CURRENT_USER, i, TRUE, TRUE);
        EnumWorkspaceKey(List, HKEY_LOCAL_MACHINE, i, TRUE, TRUE);
    }
    
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

INT_PTR CALLBACK
DlgProc_DeleteWorkspaces(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND List = GetDlgItem(Hwnd, IDC_WORKSPACE_LIST);
    LRESULT Sel;
    char NameBuf[MAX_WSP_NAME];
    PSTR Name;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        FillDeleteWorkspacesList(List);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            if (HIWORD(Wpm) == LBN_DBLCLK)
            {
                goto DelItem;
            }
            break;

        case IDC_DELETE_WORKSPACE:
        DelItem:
            Sel = SendMessage(List, LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                ULONG Key;

                Key = (ULONG)SendMessage(List, LB_GETITEMDATA, Sel, 0);
                SendMessage(List, LB_GETTEXT, Sel, (LPARAM)NameBuf);
                // Skip over introductory key description.
                Name = NameBuf + strlen(g_WorkspaceKeyDescriptions[Key]) + 3;
                Workspace::DeleteRegKey(TRUE, Key, Name);
                Workspace::DeleteRegKey(FALSE, Key, Name);
                FillDeleteWorkspacesList(List);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_DELETE_WORKSPACES);
            break;
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CreateIndexedFont(ULONG FontIndex, BOOL SetAll)
{
    HFONT Font;

    Font = CreateFontIndirect(&g_Fonts[FontIndex].LogFont);
    if (Font != NULL)
    {
        if (g_Fonts[FontIndex].Font)
        {
            DeleteObject(g_Fonts[FontIndex].Font);
        }
        g_Fonts[FontIndex].Font = Font;
        g_Fonts[FontIndex].LogFontSet = TRUE;
            
        HDC Dc = GetDC(NULL);
        if (Dc != NULL)
        {
            SelectObject(Dc, Font);
            GetTextMetrics(Dc, &g_Fonts[FontIndex].Metrics);
            ReleaseDC(NULL, Dc);
        }

        if (SetAll)
        {
            SetAllFonts(FontIndex);
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
SelectFont(HWND Parent, ULONG FontIndex)
{
    CHOOSEFONT Choose;

    ZeroMemory(&Choose, sizeof(Choose));
    Choose.lStructSize = sizeof(Choose);
    Choose.hwndOwner = Parent;
    Choose.lpLogFont = &g_Fonts[FontIndex].LogFont;
    Choose.Flags = CF_FIXEDPITCHONLY | CF_FORCEFONTEXIST |
        CF_SCREENFONTS | (g_Fonts[FontIndex].LogFontSet ?
                          CF_INITTOLOGFONTSTRUCT : 0);
    if (ChooseFont(&Choose))
    {
        if (CreateIndexedFont(FontIndex, TRUE) && g_Workspace != NULL)
        {
            // If this function really is used to select different
            // fonts the tag will have to be dynamically chosen.
            g_Workspace->SetBuffer(WSP_GLOBAL_FIXED_LOGFONT,
                                   &g_Fonts[FontIndex].LogFont,
                                   sizeof(g_Fonts[FontIndex].LogFont));
        }
    }
}

BOOL
SelectColor(HWND Parent, ULONG Index)
{
    CHOOSECOLOR Choose;
    INDEXED_COLOR* IdxCol = GetIndexedColor(Index);

    ZeroMemory(&Choose, sizeof(Choose));
    Choose.lStructSize = sizeof(Choose);
    Choose.hwndOwner = Parent;
    Choose.rgbResult = IdxCol->Color;
    Choose.lpCustColors = g_CustomColors;
    Choose.Flags = CC_ANYCOLOR | CC_RGBINIT;
    if (ChooseColor(&Choose))
    {
        if (g_Workspace != NULL)
        {
            g_Workspace->SetUlong(DEF_WSP_TAG(WSP_GROUP_COLORS, Index),
                                  (ULONG)Choose.rgbResult);
        }

        SetColor(Index, Choose.rgbResult);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\miscdbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    miscdbg.h

Abstract:

    

Environment:

    Win32, User Mode

--*/


#ifndef DBG

//
// Debugging code for critical sections
//
#define DBG_CRITICAL_SECTION            CRITICAL_SECTION


#define Dbg_InitializeCriticalSection   InitializeCriticalSection
#define Dbg_TryEnterCriticalSection     TryEnterCriticalSection
#define Dbg_EnterCriticalSection        EnterCriticalSection

#define Dbg_LeaveCriticalSection        LeaveCriticalSection
#define Dbg_DeleteCriticalSection       DeleteCriticalSection

#define Dbg_CriticalSectionOwned(p)     FALSE
#define Dbg_CriticalSectionUnowned(p)   FALSE

#else


typedef struct _DBG_WINDBG_CRITICAL_SECTION {
    CRITICAL_SECTION    cs;
    int	                nLockCount;
    DWORD               OwnerId;
    PTSTR               pszName;

    PTSTR               pszLock_LastFile;
    int                 nLock_LastFile;
    
    PTSTR               pszUnlock_LastFile;
    int                 nUnlock_LastFile;

    void
    Initialize(
        PTSTR pszCritSecName
        )
    {
        //
        // Initialize the structure here to rather than in the CPP file,
        // because it is common to add member variables and forget to initialize
        // them in the CPP file. So we do it here.
        //
        nLockCount = 0;
        OwnerId = 0;
        pszName = _tcsdup(pszCritSecName);
        pszLock_LastFile = NULL;
        nLock_LastFile = 0;    
        pszUnlock_LastFile = NULL;
        nUnlock_LastFile = 0;
    }

    void
    Delete()
    {
        free(pszName);
    }
    

} DBG_WINDBG_CRITICAL_SECTION, *PDBG_WINDBG_CRITICAL_SECTION;

#define DBG_CRITICAL_SECTION            _DBG_WINDBG_CRITICAL_SECTION

#define Dbg_InitializeCriticalSection(p)    Dbg_Windbg_InitializeCriticalSection(p, _T(#p), _T(__FILE__), __LINE__);
#define Dbg_TryEnterCriticalSection(p)      Dbg_Windbg_TryEnterCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_EnterCriticalSection(p)         Dbg_Windbg_EnterCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_LeaveCriticalSection(p)         Dbg_Windbg_LeaveCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_DeleteCriticalSection(p)        Dbg_Windbg_DeleteCriticalSection(p, _T(__FILE__), __LINE__);

#define Dbg_CriticalSectionOwned(p)         ((p)->OwnerId == GetCurrentThreadId())
#define Dbg_CriticalSectionUnowned(p)       ((p)->OwnerId == 0)


VOID Dbg_Windbg_InitializeCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, PTSTR, int);
BOOL Dbg_Windbg_TryEnterCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_EnterCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_LeaveCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_DeleteCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);


//
// Code to aid in outputing messages
//

#define DP_CRITSEC_WARN         0x00000001
#define DP_CRITSEC_ERROR        0x00000002
#define DP_CRITSEC_INFO         0x00000004
#define DP_CRITSEC_VERBOSE      0x00000008
#define DP_FATAL_ERROR          0x00000010

#define DP_CRITSEC_ALL          ( DP_CRITSEC_WARN | DP_CRITSEC_ERROR | DP_CRITSEC_INFO | DP_CRITSEC_VERBOSE )



#define MIN_VERBOSITY_LEVEL (DP_FATAL_ERROR | DP_CRITSEC_ERROR)

extern DWORD dwVerboseLevel;

#define DPRINT(dwFlag, args)        \
    if (dwFlag & dwVerboseLevel) {  \
        (DebugPrint) args;          \
    }



#endif

void DebugPrint(PTSTR, ...);


//
//
// RTTI: Used for sanity checks, to be removed from the retail version.
// Used to verify the type of object we are referencing.
//
// ei:
//    AssertType(pPointer, ClassFoo *);
//      Verify that the pointer we have is of that type.
//
//    AssertType(*pPointer, ClassFoo);
//      Verify that what we are pointing to, is of that object.
//
//    AssertChildOf(*pPointer, ClassFoo);
//      Verify that pPointer points to a class derived from ClassFoo.
//
#ifdef _CPPRTTI

BOOL RttiTypesEqual(const type_info & t1, const type_info & t2);

#define AssertType(Obj1, Obj2)		Assert( RttiTypesEqual(typeid(Obj1), typeid(Obj2)) )
#define AssertNotType(Obj1, Obj2)	Assert( !RttiTypesEqual(typeid(Obj1), typeid(Obj2)) )

#else

#define AssertType(Obj1, Obj2)					((void)0)
#define AssertNotType(Obj1, Obj2)				((void)0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\resource.h ===
#define HELPCURSOR      3001


// These icons must have the same enumeration order
// as WIN_TYPES.
#define WINDBGICON      3002
#define DOCICON         3003
#define WATCHICON       3004
#define LOCALSICON      3005
#define CPUICON         3006
#define DISASMICON      3007
#define CMDICON         3008
#define SPADICON        3009
#define MEMORYICON      3010
#define QUICKWICON      3011
#define CALLSTACKICON   3012
#define PROCTHREADICON  3013

#define MINVAL_WINDOW_ICON WINDBGICON


#define IDB_BMP_TOOLBAR     3040



#define MAIN_MENU           3050
#define MAIN_ACC            3051
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\statebuf.cpp ===
//----------------------------------------------------------------------------
//
// Debuggee state buffers.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

#include <malloc.h>

#if 0
#define DBG_BUFFER
#endif

StateBuffer g_UiOutputCapture(256);

#define MAX_REG_NAMES 8

RegisterNamesStateBuffer g_RegisterNameBuffers[MAX_REG_NAMES];

//----------------------------------------------------------------------------
//
// StateBuffer.
//
//----------------------------------------------------------------------------

StateBuffer::StateBuffer(ULONG ChangeBy)
{
    Dbg_InitializeCriticalSection(&m_Lock);
                              
    Flink = NULL;
    Blink = NULL;
    
    m_ChangeBy = ChangeBy;
    m_Win = NULL;
    m_UpdateTypes = 0;
    m_UpdateType = UPDATE_BUFFER;
    m_UpdateMessage = WU_UPDATE;
    m_Status = S_OK;
    // The buffer must start out with an outstanding
    // read request to indicate that it doesn't have valid content.
    m_ReadRequest = 1;
    m_ReadDone = 0;
    SetNoData();
}

StateBuffer::~StateBuffer(void)
{
    Free();

    Dbg_DeleteCriticalSection(&m_Lock);
}

PVOID
StateBuffer::AddData(ULONG Len)
{
    PVOID Ret;
    ULONG Needed;
    
    Needed = m_DataUsed + Len;
    if (Needed > m_DataLen)
    {
        if (Resize(Needed) != S_OK)
        {
            return NULL;
        }
    }
    
    Ret = m_Data + m_DataUsed;
    m_DataUsed += Len;
    
    return Ret;
}

BOOL
StateBuffer::AddString(PCSTR Str, BOOL SoftTerminate)
{
    ULONG Len = strlen(Str) + 1;
    PSTR Buf = (PSTR)AddData(Len);
    if (Buf != NULL)
    {
        memcpy(Buf, Str, Len);

        if (SoftTerminate)
        {
            // Back up to pack strings without intervening
            // terminators.  Buffer isn't shrunk so terminator
            // remains to terminate the overall buffer until
            // new data.
            RemoveTail(1);
        }
        
        return TRUE;
    }

    return FALSE;
}

void
StateBuffer::RemoveHead(ULONG Len)
{
    if (Len > m_DataUsed)
    {
        Len = m_DataUsed;
    }

    ULONG Left = m_DataUsed - Len;
    
    if (Len > 0 && Left > 0)
    {
        memmove(m_Data, (PBYTE)m_Data + Len, Left);
    }
    
    m_DataUsed = Left;
}

void
StateBuffer::RemoveMiddle(ULONG Start, ULONG Len)
{
    if (Start >= m_DataUsed)
    {
        return;
    }
    
    if (Start + Len > m_DataUsed)
    {
        Len = m_DataUsed - Start;
    }

    ULONG Left = m_DataUsed - Len - Start;
    
    if (Len > 0 && Left > 0)
    {
        memmove(m_Data + Start, (PBYTE)m_Data + Start + Len, Left);
    }
    
    m_DataUsed = Start + Left;
}

void
StateBuffer::RemoveTail(ULONG Len)
{
    if (Len > m_DataUsed)
    {
        Len = m_DataUsed;
    }

    m_DataUsed -= Len;
}

HRESULT
StateBuffer::Resize(ULONG Len)
{
    PBYTE NewData;
    ULONG NewLen;

    if (Len == m_DataLen)
    {
        return S_OK;
    }
    
    NewLen = m_DataLen;
    if (Len < NewLen)
    {
        do
        {
            NewLen -= m_ChangeBy;
        }
        while (NewLen > Len);
        NewLen += m_ChangeBy;
    }
    else
    {
        do
        {
            NewLen += m_ChangeBy;
        }
        while (NewLen < Len);
    }

#if DBG
    // Force every resize to go to a new memory block
    // and backfill the old block to make it obvious
    // when pointers are being held across resizes.
    if (NewLen == 0)
    {
        free(m_Data);
        NewData = NULL;
    }
    else
    {
        NewData = (PBYTE)malloc(NewLen);
        if (NewData != NULL && m_Data != NULL)
        {
            ULONG OldLen = _msize(m_Data);
            ULONG CopyLen = min(OldLen, NewLen);
            memcpy(NewData, m_Data, CopyLen);
            memset(m_Data, 0xfe, OldLen);
            free(m_Data);
        }
    }
#else
    NewData = (PBYTE)realloc(m_Data, NewLen);
#endif
    if (NewLen > 0 && NewData == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_Data = NewData;
    m_DataLen = NewLen;

    return S_OK;
}

void
StateBuffer::Free(void)
{
    free(m_Data);
    SetNoData();
}

HRESULT
StateBuffer::Update(void)
{
    ULONG Request;

    // First sample the request value.  This
    // value will be set as the done value if
    // a read is performed and therefore must
    // be sampled first to make it the most
    // conservative estimate of what was done.
    Request = m_ReadRequest;
    if (Request != m_ReadDone)
    {
        LockStateBuffer(this);
                
        m_Status = ReadState();
        // Always mark the buffer with the latest completed
        // sequence so that errors get picked up in addition
        // to successful reads.
        m_ReadDone = Request;

#ifdef DBG_BUFFER
        if (m_Status != S_OK)
        {
            DebugPrint("State buffer %p:%d fill failed, 0x%X\n",
                       this, m_enumType, m_Status);
        }
        if (m_ReadRequest != m_ReadDone)
        {
            DebugPrint("State buffer %p:%d fill out of date, "
                       "req %X, done %X\n",
                       this, m_enumType, m_ReadRequest, m_ReadDone);
        }
#endif
        
        UnlockStateBuffer(this);

        if (m_Win != NULL)
        {
            PostMessage(m_Win, m_UpdateMessage, 0, 0);
        }
        if (m_Status == S_OK && m_UpdateTypes)
        {
            UpdateBufferWindows(m_UpdateTypes, m_UpdateType);
        }
    }

    return m_Status;
}

void
StateBuffer::UiRequestRead(void)
{
    //
    // Called on the UI thread.
    //
    
    // No need to lock here as a race for
    // the read request value is not a problem.
    // If the read request value is sampled early
    // and a read request does not occur it'll
    // happen the next time around since this routine
    // also wakes the engine.
    RequestRead();
    UpdateEngine();
}

HRESULT
StateBuffer::UiLockForRead(void)
{
    ULONG Done;
    
    //
    // Called on the UI thread.
    //
    
    // First sample the read count without locking.
    Done = m_ReadDone;

    // Now check whether the request is newer than the
    // last read done.  The UI thread is the only thread
    // that updates the request count so this should be safe.
    if (Done == m_ReadRequest)
    {
        HRESULT Status;
        
        LockStateBuffer(this);

        Status = m_Status;
        if (FAILED(Status))
        {
            // If there was an error when filling the buffer
            // return it and leave the buffer unlocked.
            UnlockStateBuffer(this);
            return Status;
        }

        // Buffer is locked and valid.
        return S_OK;
    }
    else
    {
        // Buffer content is out-of-date so don't lock.
        // Make sure the engine is active to update the buffer.
        return S_FALSE;
    }
}

HRESULT
StateBuffer::ReadState(void)
{
    return S_OK;
}

//----------------------------------------------------------------------------
//
// OutputToStateBuffer.
//
//----------------------------------------------------------------------------

HRESULT
OutputToStateBuffer::Start(BOOL Empty)
{
    if (Empty)
    {
        m_Buffer->Empty();
    }
    m_DataStart = m_Buffer->GetDataLen();
    m_Status = S_OK;
    m_NewLineCount = 0;
    m_PartialLine = 0;

    return S_OK;
}

HRESULT
OutputToStateBuffer::End(BOOL RemoveLastNewLine)
{
    if (RemoveLastNewLine && m_PartialLine == 0)
    {
        // Remove the final newline so that richedit doesn't leave
        // a blank line at the bottom of the window when the
        // text is displayed.
        *((PSTR)m_Buffer->GetDataBuffer() + m_Buffer->GetDataLen() - 1) = 0;
    }
    else
    {
        // Every individual line allocates space for a terminator
        // and then backs up.  This requested space should always
        // be available.
        PVOID Data = m_Buffer->AddData(1);
        Assert(Data != NULL);
    }

    return m_Status;
}

void
OutputToStateBuffer::ReplaceChar(char From, char To)
{
    PSTR Buf = (PSTR)m_Buffer->GetDataBuffer() + m_DataStart;
    PSTR End = (PSTR)m_Buffer->GetDataBuffer() + m_Buffer->GetDataLen();

    while (Buf < End)
    {
        if (*Buf == From)
        {
            *Buf = To;
        }

        Buf++;
    }
}

STDMETHODIMP
OutputToStateBuffer::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if (!m_Buffer->AddString(Text, TRUE))
    {
        return E_OUTOFMEMORY;
    }

    AddLines(Text);
    return S_OK;
}

void
OutputToStateBuffer::AddLines(PCSTR Start)
{
    PCSTR LastNl = Start;
    PCSTR Nl;
    
    for (;;)
    {
        Nl = strchr(LastNl, '\n');
        if (Nl == NULL)
        {
            break;
        }

        m_NewLineCount++;
        LastNl = Nl + 1;
    }

    // If the last newline wasn't at the end of the text there's
    // a partial line which needs to count in the line count
    // but only until a finishing newline comes in.
    m_PartialLine = *LastNl != 0 ? 1 : 0;
}

OutputToStateBuffer g_OutStateBuf;
OutputToStateBuffer g_UiOutStateBuf;

//----------------------------------------------------------------------------
//
// Dynamic state buffers.
//
//----------------------------------------------------------------------------

// Keep the amount of text retrieved for the system name short
// so that it doesn't dominate the status bar.
#define MAX_SYSNAME 8

LIST_ENTRY g_StateList;

DBG_CRITICAL_SECTION g_QuickLock;

ULONG64 g_CodeIp;
char g_CodeFileFound[MAX_SOURCE_PATH];
char g_CodeSymFile[MAX_SOURCE_PATH];
char g_CodePathComponent[MAX_SOURCE_PATH];
ULONG g_CodeLine;
BOOL g_CodeUserActivated;
ULONG g_CodeBufferSequence;

ULONG64 g_EventIp;
ULONG g_CurSystemId;
char g_CurSystemName[MAX_SYSNAME];
ULONG g_CurProcessId, g_CurProcessSysId;
ULONG g_CurThreadId, g_CurThreadSysId;
ULONG g_EventBufferRequest;
ULONG g_EventBufferDone;

void
FillCodeBuffer(ULONG64 Ip, BOOL UserActivated)
{
    char File[MAX_SOURCE_PATH];
    char Found[MAX_SOURCE_PATH];
    char PathComp[MAX_SOURCE_PATH];
    ULONG Line;
    ULONG64 Disp;
    BOOL Changed;

    // Fill local information rather than global information
    // to avoid changing the global information until all
    // event information has been collected.
    
    if (g_pDbgSymbols->
        GetLineByOffset(Ip, &Line, File, sizeof(File), NULL, &Disp) != S_OK)
    {
        // This will be hit if the buffer is too small
        // to hold the filename.  This could be switched to dynamically
        // allocate the filename buffer but that seems like overkill.
        File[0] = 0;
        Found[0] = 0;
    }
    else
    {
        ULONG FoundElt;
        
        // Source information is one-based but the source
        // window lines are zero-based.
        Line--;

        // Look up the reported file along the source path.
        // XXX drewb - Use first-match and then element walk to
        // determine ambiguities and display resolution UI.
        if (g_pLocSymbols->
            FindSourceFile(0, File,
                           DEBUG_FIND_SOURCE_BEST_MATCH |
                           DEBUG_FIND_SOURCE_FULL_PATH,
                           &FoundElt, Found, sizeof(Found), NULL) != S_OK)
        {
            // XXX drewb - Display UI instead of just disabling source?
            Found[0] = 0;
        }
        else if (g_pLocSymbols->
                 GetSourcePathElement(FoundElt, PathComp, sizeof(PathComp),
                                      NULL) != S_OK)
        {
            PathComp[0] = 0;
        }
    }

    // Now that all of the information has been collected
    // take the lock and update the global state.
    Dbg_EnterCriticalSection(&g_QuickLock);

    //
    // Avoid updating the code buffer unless there's been
    // an actual change to avoid excessive window position changes
    // when the current-IP location is brought to the front.
    //
    // If the user has requested the change, always do it
    // to force such window changes.
    //
    
    Changed = FALSE;
    
    if (g_CodeIp != Ip)
    {
        g_CodeIp = Ip;
        Changed = TRUE;
    }
    if (strcmp(g_CodeFileFound, Found))
    {
        strcpy(g_CodeFileFound, Found);
        Changed = TRUE;
    }
    if (strcmp(g_CodeSymFile, File))
    {
        strcpy(g_CodeSymFile, File);
        Changed = TRUE;
    }
    if (strcmp(g_CodePathComponent, PathComp))
    {
        strcpy(g_CodePathComponent, PathComp);
        Changed = TRUE;
    }
    if (g_CodeLine != Line)
    {
        g_CodeLine = Line;
        Changed = TRUE;
    }
    if (g_CodeUserActivated != UserActivated)
    {
        g_CodeUserActivated = UserActivated;
        Changed = TRUE;
    }
    if (Changed || UserActivated)
    {
        g_CodeBufferSequence++;
    }

    Dbg_LeaveCriticalSection(&g_QuickLock);

    // Wake up the UI thread to process the new event location.
    UpdateUi();
}

void
FillEventBuffer(void)
{
    ULONG64 Ip;
    ULONG64 ScopeIp;
    ULONG SystemId;
    char FullSysName[MAX_PATH + 32];
    char SystemName[MAX_SYSNAME];
    ULONG ProcessId, ProcessSysId;
    ULONG ThreadId, ThreadSysId;
    ULONG Done = g_EventBufferRequest;
    HRESULT Status;

    if (g_pDbgRegisters->GetInstructionOffset(&Ip) != S_OK ||
        g_pDbgSystem->GetCurrentProcessId(&ProcessId) != S_OK ||
        g_pDbgSystem->GetCurrentThreadId(&ThreadId) != S_OK)
    {
        return;
    }

    if (g_pDbgSystem3)
    {
        if (g_pDbgSystem3->GetCurrentSystemId(&SystemId) != S_OK ||
            FAILED(g_pDbgSystem3->
                   GetCurrentSystemServerName(FullSysName, sizeof(FullSysName),
                                              NULL)))
        {
            return;
        }

        PSTR Scan;
        
        // System names are generally "<Type>: <Specifics>".  As
        // we only have a small amount of space, strip off the type.
        Scan = strchr(FullSysName, ':');
        if (Scan)
        {
            Scan++;
            if (*Scan == ' ')
            {
                Scan++;
            }
        }
        else
        {
            Scan = FullSysName;
        }
        CopyString(SystemName, Scan, DIMA(SystemName));
    }
    else
    {
        // Old dbgeng.dll which doesn't support multisystem.
        SystemId = 0;
        strcpy(SystemName, "<Old>");
    }
    
    // Kernel mode doesn't implement system IDs as the process
    // and threads are fakes and not real system objects.  Just
    // use zero if E_NOTIMPL is returned.
    if ((Status = g_pDbgSystem->
         GetCurrentProcessSystemId(&ProcessSysId)) != S_OK)
    {
        if (Status == E_NOTIMPL)
        {
            ProcessSysId = 0;
        }
        else
        {
            // Unexpected error, must be a real problem.
            return;
        }
    }
    if ((Status = g_pDbgSystem->
         GetCurrentThreadSystemId(&ThreadSysId)) != S_OK)
    {
        if (Status == E_NOTIMPL)
        {
            ThreadSysId = 0;
        }
        else
        {
            // Unexpected error, must be a real problem.
            return;
        }
    }
    
    // Fill code buffer with scope Ip
    if (g_pDbgSymbols->GetScope(&ScopeIp, NULL, NULL, 0) != S_OK)
    {
	return;
    }
    
    FillCodeBuffer(ScopeIp, FALSE);
    g_EventIp = Ip;
    g_CurSystemId = SystemId;
    strcpy(g_CurSystemName, SystemName);
    g_CurProcessId = ProcessId;
    g_CurProcessSysId = ProcessSysId;
    g_CurThreadId = ThreadId;
    g_CurThreadSysId = ThreadSysId;

    if (!g_CodeLevelLocked)
    {
        ULONG CodeLevel;
    
        if (g_CodeFileFound[0] == 0)
        {
            // No source so switch to assembly mode.
            CodeLevel = DEBUG_LEVEL_ASSEMBLY;
        }
        else
        {
            if (GetSrcMode_StatusBar())
            {
                CodeLevel = DEBUG_LEVEL_SOURCE;
            }
            else
            {
                CodeLevel = DEBUG_LEVEL_ASSEMBLY;
            }
        }
        g_IgnoreCodeLevelChange = TRUE;
        g_pDbgControl->SetCodeLevel(CodeLevel);
        g_IgnoreCodeLevelChange = FALSE;
    }
    
    g_EventBufferDone = Done;
    PostMessage(g_hwndFrame, WU_UPDATE, UPDATE_EXEC, 0);
}

class BpStateBuffer : public StateBuffer
{
public:
    BpStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = BP_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
        m_UpdateTypes = (1 << DOC_WINDOW) | (1 << DISASM_WINDOW);
        m_UpdateType = UPDATE_BP;
    }

    virtual HRESULT ReadState(void);
};

// #define DBG_BPBUF
#define BP_EXTRA_ENTRIES 8

ULONG g_BpCount;
BpStateBuffer g_PrivateBpBuffer;
StateBuffer* g_BpBuffer = &g_PrivateBpBuffer;
ULONG g_BpTextOffset;

HRESULT
BpStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG Count;
    ULONG TextOffset;
    BpBufferData* Data;
    ULONG i;
    PDEBUG_BREAKPOINT_PARAMETERS Params;
    char FileBuf[MAX_SOURCE_PATH];

    // Reserve room for BP descriptions in front of the text.
    // When doing so, reserve extra slots to allow for free
    // slots the next time around.
    Empty();
    Status = g_pDbgControl->GetNumberBreakpoints(&Count);
    if (Status != S_OK)
    {
        return Status;
    }

    TextOffset = (Count + BP_EXTRA_ENTRIES) * sizeof(BpBufferData);
    Data = (BpBufferData*)AddData(TextOffset);
    if (Data == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate a temporary buffer for bulk breakpoint retrieval.
    Params = new DEBUG_BREAKPOINT_PARAMETERS[Count];
    if (Params == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // GetBreakpointParameters can return S_FALSE when there
    // are hidden breakpoints.
    if (FAILED(Status = g_pDbgControl->
               GetBreakpointParameters(Count, NULL, 0, Params)) != S_OK)
    {
        delete [] Params;
        return Status;
    }
    
    // Iterate over breakpoints and retrieve offsets for
    // all execution breakpoints.
    // Take advantage of the fact that Empty does not actually
    // discard data to distinguish changed breakpoints from
    // unchanged breakpoints.
    ULONG Write = 0;
    
    for (i = 0; i < Count; i++)
    {
        if (Params[i].Id == DEBUG_ANY_ID ||
            Params[i].Offset == DEBUG_INVALID_OFFSET ||
            (Params[i].BreakType == DEBUG_BREAKPOINT_DATA &&
             Params[i].DataAccessType != DEBUG_BREAK_EXECUTE))
        {
            // Not a breakpoint that we care about, skip.
            continue;
        }

        // Check and see if this offset is already known.
        ULONG Match;

        for (Match = 0; Match < g_BpCount; Match++)
        {
            // NOTE: This compresses duplicate breakpoints
            // with a first-writer-wins on the ID.
            if (Data[Match].Offset == Params[i].Offset)
            {
                break;
            }
        }
        if (Match < g_BpCount)
        {
            BpBufferData Temp;
            
            // Keep the old record for this offset to minimize
            // UI updates.
            if (Match > Write)
            {
                Temp = Data[Match];
                Data[Match] = Data[Write];
                Data[Write] = Temp;
                Match = Write;
            }

#ifdef DBG_BPBUF
            DebugPrint("Match %d:%I64X %d:%d into %d\n",
                       Params[i].Id, Params[i].Offset, Data[Match].Id,
                       Match, Write);
#endif
            
            Write++;

            // We mostly ignore flag differences.  ENABLED, however,
            // is important to have accurate and in the most-enabled
            // way.
            if ((Data[Match].Flags ^ Params[i].Flags) &
                DEBUG_BREAKPOINT_ENABLED)
            {
                if (Data[Match].Id != Params[i].Id)
                {
                    Data[Match].Flags |=
                        Params[i].Flags & DEBUG_BREAKPOINT_ENABLED;
                }
                else
                {
                    Data[Match].Flags = Params[i].Flags;
                }
                Data[Match].Thread = Params[i].MatchThread;
                Data[Match].Sequence = g_CommandSequence;
            }
        }
        else
        {
            // Fill in a new record.  This will potentially destroy
            // an old record and so reduce the effectivess of delta
            // checking but the front of the buffer is packed
            // with the extra entries to handle these changes hopefully
            // without eating into the actual entries.
#ifdef DBG_BPBUF
            DebugPrint("Write %d:%I64X into %d\n", Params[i].Id,
                       Params[i].Offset, Write);
#endif
            
            Data[Write].Offset = Params[i].Offset;
            Data[Write].Id = Params[i].Id;
            Data[Write].Flags = Params[i].Flags;
            Data[Write].Thread = Params[i].MatchThread;
            Data[Write].Sequence = g_CommandSequence;
            Write++;
        }
    }

    delete [] Params;
    
    // Pack unused entries at the front of the buffer so that
    // they get used first in the next delta computation.
    Count += BP_EXTRA_ENTRIES;

#ifdef DBG_BPBUF
    DebugPrint("Used %d of %d\n", Write, Count);
#endif

    if (Write < Count)
    {
        ULONG Extra = Count - Write;
        
        memmove(Data + Extra, Data, Write * sizeof(*Data));
        for (i = 0; i < Extra; i++)
        {
            Data[i].Offset = DEBUG_INVALID_OFFSET;
        }
    }

    //
    // Now go through the valid breakpoints and look up
    // what file they're in, if any.
    //

    for (i = 0; i < Count; i++)
    {
        ULONG Line;
        PSTR FileSpace;

        // Refresh every time since growth may have caused
        // a realloc.
        Data = (BpBufferData*)m_Data;
        Data[i].FileOffset = 0;
        
        if (Data[i].Offset != DEBUG_INVALID_OFFSET &&
            g_pDbgSymbols->GetLineByOffset(Data[i].Offset, &Line,
                                           FileBuf, sizeof(FileBuf), NULL,
                                           NULL) == S_OK)
        {
            // Do this first before m_DataUsed is updated and
            // Data is invalidated.
            Data[i].FileOffset = m_DataUsed;

            FileSpace = (PSTR)AddData(sizeof(Line) + strlen(FileBuf) + 1);
            if (FileSpace == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *(ULONG UNALIGNED *)FileSpace = Line;
            FileSpace += sizeof(Line);
            strcpy(FileSpace, FileBuf);
        }
    }

    TextOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        return Status;
    }

    // Get breakpoint list.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       "bl", DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
        if (Status == S_OK)
        {
            // Separate lines by nulls to make them easier
            // to process as individual strings.
            g_OutStateBuf.ReplaceChar('\n', 0);
        }
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }
    
    if (Status == S_OK)
    {
        g_BpCount = Count;
        g_BpTextOffset = TextOffset;
    }

    return Status;
}

class BpCmdsStateBuffer : public StateBuffer
{
public:
    BpCmdsStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = BP_CMDS_BIT;
    }

    virtual HRESULT ReadState(void);
};

BpCmdsStateBuffer g_PrivateBpCmdsBuffer;
StateBuffer* g_BpCmdsBuffer = &g_PrivateBpCmdsBuffer;

HRESULT
BpCmdsStateBuffer::ReadState(void)
{
    HRESULT Status;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(TRUE)) != S_OK)
    {
        return Status;
    }

    // Get breakpoint commands.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       ".bpcmds -e -m -p 0",
                                       DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }
    
    return Status;
}

class FilterTextStateBuffer : public StateBuffer
{
public:
    FilterTextStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = MINVAL_WINDOW;
        m_UpdateMessage = 0;
    }

    virtual HRESULT ReadState(void);
};

FilterTextStateBuffer g_PrivateFilterTextBuffer;
StateBuffer* g_FilterTextBuffer = &g_PrivateFilterTextBuffer;

HRESULT
FilterTextStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG SpecEvents, SpecEx, ArbEx;
    ULONG i;
    PSTR Text;

    if ((Status = g_pDbgControl->
         GetNumberEventFilters(&SpecEvents, &SpecEx, &ArbEx)) != S_OK)
    {
        return Status;
    }

    Empty();

    DEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    
    for (i = 0; i < SpecEvents; i++)
    {
        if ((Status = g_pDbgControl->
             GetSpecificFilterParameters(i, 1, &SpecParams)) != S_OK)
        {
            return Status;
        }

        if (SpecParams.TextSize == 0)
        {
            // Put a terminator in anyway to keep the
            // indexing correct.
            if ((Text = (PSTR)AddData(1)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *Text = 0;
        }
        else
        {
            if ((Text = (PSTR)AddData(SpecParams.TextSize)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterText(i, Text, SpecParams.TextSize,
                                    NULL)) != S_OK)
            {
                return Status;
            }
        }
    }

    DEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    
    for (i = 0; i < SpecEx; i++)
    {
        if ((Status = g_pDbgControl->
             GetExceptionFilterParameters(1, NULL, i + SpecEvents,
                                          &ExParams)) != S_OK)
        {
            return Status;
        }

        if (ExParams.TextSize == 0)
        {
            // Put a terminator in anyway to keep the
            // indexing correct.
            if ((Text = (PSTR)AddData(1)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *Text = 0;
        }
        else
        {
            if ((Text = (PSTR)AddData(ExParams.TextSize)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterText(i + SpecEvents, Text, ExParams.TextSize,
                                    NULL)) != S_OK)
            {
                return Status;
            }
        }
    }

    return S_OK;
}

class FilterStateBuffer : public StateBuffer
{
public:
    FilterStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = FILTER_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
    }

    virtual HRESULT ReadState(void);
};

FilterStateBuffer g_PrivateFilterBuffer;
StateBuffer* g_FilterBuffer = &g_PrivateFilterBuffer;
ULONG g_FilterArgsOffset;
ULONG g_FilterCmdsOffset;
ULONG g_FilterWspCmdsOffset;
ULONG g_NumSpecEvents, g_NumSpecEx, g_NumArbEx;

HRESULT
FilterStateBuffer::ReadState(void)
{
    ULONG SpecEvents, SpecEx, ArbEx;
    HRESULT Status;
    ULONG ArgsOffset, CmdsOffset, WspCmdsOffset;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    ULONG i;

    if ((Status = g_pDbgControl->
         GetNumberEventFilters(&SpecEvents, &SpecEx, &ArbEx)) != S_OK)
    {
        return Status;
    }

    Empty();
    if ((SpecParams = (PDEBUG_SPECIFIC_FILTER_PARAMETERS)
         AddData((SpecEvents * sizeof(*SpecParams) +
                  (SpecEx + ArbEx) * sizeof(*ExParams)))) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ExParams = (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + SpecEvents);
    
    if ((Status = g_pDbgControl->
         GetSpecificFilterParameters(0, SpecEvents, SpecParams)) != S_OK ||
        (Status = g_pDbgControl->
         GetExceptionFilterParameters(SpecEx + ArbEx, NULL, SpecEvents,
                                      ExParams)) != S_OK)
    {
        return Status;
    }

    ArgsOffset = m_DataUsed;

    for (i = 0; i < SpecEvents; i++)
    {
        if (SpecParams[i].ArgumentSize > 1)
        {
            PSTR Arg = (PSTR)AddData(SpecParams[i].ArgumentSize);
            if (Arg == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetSpecificFilterArgument(i, Arg, SpecParams[i].ArgumentSize,
                                           NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    CmdsOffset = m_DataUsed;

    for (i = 0; i < SpecEvents; i++)
    {
        if (SpecParams[i].CommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(SpecParams[i].CommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterCommand(i, Cmd, SpecParams[i].CommandSize,
                                       NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    for (i = 0; i < SpecEx + ArbEx; i++)
    {
        if (ExParams[i].CommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(ExParams[i].CommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterCommand(i + SpecEvents,
                                       Cmd, ExParams[i].CommandSize,
                                       NULL)) != S_OK)
            {
                return Status;
            }
        }

        if (ExParams[i].SecondCommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(ExParams[i].SecondCommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetExceptionFilterSecondCommand(i + SpecEvents,
                                                 Cmd,
                                                 ExParams[i].SecondCommandSize,
                                                 NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    WspCmdsOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        return Status;
    }

    // Get filter commands.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       ".sxcmds",
                                       DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }

    if (Status == S_OK)
    {
        g_FilterArgsOffset = ArgsOffset;
        g_FilterCmdsOffset = CmdsOffset;
        g_FilterWspCmdsOffset = WspCmdsOffset;
        g_NumSpecEvents = SpecEvents;
        g_NumSpecEx = SpecEx;
        g_NumArbEx = ArbEx;
    }
    
    return Status;
}

class ModuleStateBuffer : public StateBuffer
{
public:
    ModuleStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = MODULE_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
    }

    virtual HRESULT ReadState(void);
};

ModuleStateBuffer g_PrivateModuleBuffer;
StateBuffer* g_ModuleBuffer = &g_PrivateModuleBuffer;
ULONG g_NumModules;

HRESULT
ModuleStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG NumModules, Loaded, Unloaded;
    PDEBUG_MODULE_PARAMETERS Params;

    if ((Status = g_pDbgSymbols->GetNumberModules(&Loaded,
                                                  &Unloaded)) != S_OK)
    {
        return Status;
    }

    Empty();
    NumModules = Loaded + Unloaded;
    if (NumModules > 0)
    {
        if ((Params = (PDEBUG_MODULE_PARAMETERS)
             AddData(NumModules * sizeof(*Params))) == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if ((Status = g_pDbgSymbols->
             GetModuleParameters(NumModules, NULL, 0, Params)) != S_OK)
        {
            return Status;
        }
    }

    g_NumModules = NumModules;
    return S_OK;
}

class AliasStateBuffer : public StateBuffer
{
public:
    AliasStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = ALIAS_BIT;
    }

    virtual HRESULT ReadState(void);
};

AliasStateBuffer g_PrivateAliasBuffer;
StateBuffer* g_AliasBuffer = &g_PrivateAliasBuffer;

HRESULT
AliasStateBuffer::ReadState(void)
{
    HRESULT Status;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(TRUE)) != S_OK)
    {
        return Status;
    }

    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       ".aliascmds",
                                       DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }

    return Status;
}

void
ReadStateBuffers(void)
{
    ULONG i;
    
    // Fill event information first so other fills can
    // refer to it.
    if (g_EventBufferRequest != g_EventBufferDone)
    {
        FillEventBuffer();
    }

    g_BpBuffer->Update();
    g_BpCmdsBuffer->Update();
    g_FilterBuffer->Update();
    g_ModuleBuffer->Update();
    g_AliasBuffer->Update();

    for (i = 0; i < MAX_REG_NAMES; i++)
    {
        if (g_RegisterNameBuffers[i].m_ProcType !=
            IMAGE_FILE_MACHINE_UNKNOWN)
        {
            g_RegisterNameBuffers[i].Update();
        }
    }
    
    // No need to lock to sample the list head.
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;
    StateBuffer* BufferNext;

    while (Buffer != &g_StateList)
    {
        BufferNext = (StateBuffer*)Buffer->Flink;

        if (Buffer->m_Win == NULL)
        {
            // This window has been closed and can be cleaned up.
            Dbg_EnterCriticalSection(&g_QuickLock);
            RemoveEntryList(Buffer);
            Dbg_LeaveCriticalSection(&g_QuickLock);
            delete Buffer;
        }
        else
        {
            Buffer->Update();
        }

        Buffer = BufferNext;
    }
}

void
InvalidateStateBuffers(ULONG Types)
{
    // This routine can be called from both
    // the engine thread and the UI thread.
    // Care should be taken to make the code
    // here work in both threads.
    
    if (Types & (1 << EVENT_BIT))
    {
        InterlockedIncrement((PLONG)&g_EventBufferRequest);
    }
    if (Types & (1 << BP_BIT))
    {
        g_BpBuffer->RequestRead();
    }
    if (Types & (1 << BP_CMDS_BIT))
    {
        g_BpCmdsBuffer->RequestRead();
    }
    if (Types & (1 << FILTER_BIT))
    {
        g_FilterBuffer->RequestRead();
    }
    if (Types & (1 << MODULE_BIT))
    {
        g_ModuleBuffer->RequestRead();
    }
    if (Types & (1 << ALIAS_BIT))
    {
        g_AliasBuffer->RequestRead();
    }

    // This routine must hold the list lock so that it
    // can traverse the list properly in the UI thread
    // when the engine thread might be deleting things.
    // The code in the lock should execute quickly to
    // avoid contention.

    Dbg_EnterCriticalSection(&g_QuickLock);
    
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;

    while (Buffer != &g_StateList)
    {
        if (Types & (1 << Buffer->m_enumType))
        {
            // Request a read but do not send an update to
            // the window.  The window will display the old
            // content until the buffer is updated.
            Buffer->RequestRead();
        }
        
        Buffer = (StateBuffer*)Buffer->Flink;
    }
    
    Dbg_LeaveCriticalSection(&g_QuickLock);
}

void
UpdateBufferWindows(ULONG Types, UpdateType Type)
{
    // This routine can be called from both
    // the engine thread and the UI thread.
    // Care should be taken to make the code
    // here work in both threads.
    
    // This routine must hold the list lock so that it
    // can traverse the list properly in the UI thread
    // when the engine thread might be deleting things.
    // The code in the lock should execute quickly to
    // avoid contention.

    Dbg_EnterCriticalSection(&g_QuickLock);
    
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;

    while (Buffer != &g_StateList)
    {
        if ((Types & (1 << Buffer->m_enumType)) &&
            Buffer->m_Win != NULL)
        {
            PostMessage(Buffer->m_Win, WU_UPDATE, Type, 0);
        }
        
        Buffer = (StateBuffer*)Buffer->Flink;
    }
    
    Dbg_LeaveCriticalSection(&g_QuickLock);
}

//----------------------------------------------------------------------------
//
// Static state buffers.
//
//----------------------------------------------------------------------------

HRESULT
RegisterNamesStateBuffer::ReadState(void)
{
    HRESULT Status;
    char Name[1024];
    DEBUG_REGISTER_DESCRIPTION Desc;
    ULONG i;
    PSTR BufName;
    ULONG Len;
    ULONG NumReg;
    ULONG OldProcType;
    ULONG NamesOffset;
    PULONG Type;

    if (m_ProcType == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        return E_UNEXPECTED;
    }
        
    if ((Status = g_pDbgControl->
         GetEffectiveProcessorType(&OldProcType)) != S_OK ||
        (Status = g_pDbgControl->
         SetEffectiveProcessorType(m_ProcType)) != S_OK)
    {
        return Status;
    }
    
    if ((Status = g_pDbgRegisters->
         GetNumberRegisters(&NumReg)) != S_OK)
    {
        goto EH_EffProc;
    }
    
    Empty();

    NamesOffset = NumReg * 2 * sizeof(ULONG);
    if (!AddData(NamesOffset))
    {
        Status = E_OUTOFMEMORY;
        goto EH_EffProc;
    }
    
    for (i = 0; i < NumReg; i++)
    {
        if ((Status = g_pDbgRegisters->GetDescription(i, Name, sizeof(Name),
                                                      NULL, &Desc)) != S_OK)
        {
            goto EH_EffProc;
        }

        Len = strlen(Name) + 1;
        BufName = (PSTR)AddData(Len);
        if (BufName == NULL)
        {
            Status = E_OUTOFMEMORY;
            goto EH_EffProc;
        }

        memcpy(BufName, Name, Len);

        Type = (PULONG)GetDataBuffer() + 2 * i;
        Type[0] = Desc.Type;
        Type[1] = Desc.Flags;
    }

    Status = S_OK;
    m_NumRegisters = NumReg;
    m_NamesOffset = NamesOffset;

 EH_EffProc:
    g_pDbgControl->SetEffectiveProcessorType(OldProcType);
    return Status;
}

void
RegisterNamesStateBuffer::GetRegisterMapText(HWND Edit)
{
    ULONG i;
    PSTR Name;
    CHARRANGE Range;
    
    AssertStateBufferLocked(this);

    Range.cpMin = 0;
    Range.cpMax = INT_MAX;
    SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)&Range);
    
    for (i = 0; i < m_NumRegisters; i++)
    {
        ULONG MapIndex = MapUserToEngine(i);
            
        Name = (PSTR)GetDataBuffer() + m_NamesOffset;
        while (MapIndex-- > 0)
        {
            Name += strlen(Name) + 1;
        }

        if (i > 0)
        {
            SendMessage(Edit, EM_REPLACESEL, 0, (LPARAM)" ");
        }
        SendMessage(Edit, EM_REPLACESEL, 0, (LPARAM)Name);
    }
}

void
RegisterNamesStateBuffer::ScanRegisterMapText(HWND Edit)
{
    PSTR Text, TextBuffer;
    PULONG Used, UsedBuffer;
    ULONG i;
    
    AssertStateBufferLocked(this);

    //
    // Allocate a buffer for the control text
    // and a new register map.
    //
    
    i = (ULONG)SendMessage(Edit, WM_GETTEXTLENGTH, 0, 0) + 1;
    TextBuffer = new CHAR[i];
    if (TextBuffer == NULL)
    {
        return;
    }
    Text = TextBuffer;
    
    UsedBuffer = new ULONG[m_NumRegisters];
    if (UsedBuffer == NULL)
    {
        delete [] TextBuffer;
        return;
    }
    Used = UsedBuffer;
        
    // Map may need to change size.
    delete [] m_RegisterMap;

    m_RegisterMap = new USHORT[m_NumRegisters];
    if (m_RegisterMap == NULL)
    {
        delete [] TextBuffer;
        delete [] UsedBuffer;
        return;
    }
    m_RegisterMapEntries = m_NumRegisters;

    ZeroMemory(Used, m_NumRegisters * sizeof(Used[0]));
    
    //
    // Retrieve the text and scan it for register names.
    //
    
    GetWindowText(Edit, Text, i);
    Text[i - 1] = 0;

    PSTR Name;
    BOOL End;
    PUSHORT Map;
    PSTR Reg;

    Map = m_RegisterMap;
    for (;;)
    {
        while (isspace(*Text))
        {
            Text++;
        }

        if (*Text == 0)
        {
            break;
        }

        // Collect name.
        Name = Text;
        while (*Text && !isspace(*Text))
        {
            Text++;
        }

        End = *Text == 0;
        *Text = 0;

        // Check against known registers.
        Reg = (PSTR)GetDataBuffer() + m_NamesOffset;
        for (i = 0; i < m_NumRegisters; i++)
        {
            if (!Used[i] && !_strcmpi(Name, Reg))
            {
                Used[i] = TRUE;
                *Map++ = (USHORT)i;
                break;
            }

            Reg += strlen(Reg) + 1;
        }
        
        if (End)
        {
            break;
        }

        Text++;
    }

    //
    // Fill out any remaining map entries with registers
    // which aren't in the map so far.
    //
    
    PUSHORT MapEnd = m_RegisterMap + m_RegisterMapEntries;
    
    i = 0;
    while (Map < MapEnd)
    {
        while (Used[i])
        {
            i++;
        }
        Assert(i < m_NumRegisters);

        *Map++ = (USHORT)(i++);
    }
    
    delete [] TextBuffer;
    delete [] UsedBuffer;
}

void
RegisterNamesStateBuffer::SetRegisterMap(ULONG Count, PUSHORT Data)
{
    delete m_RegisterMap;
    m_RegisterMapEntries = 0;
    
    m_RegisterMap = new USHORT[Count];
    if (m_RegisterMap != NULL)
    {
        memcpy(m_RegisterMap, Data, Count * sizeof(*m_RegisterMap));
        m_RegisterMapEntries = Count;
    }
}

USHORT
RegisterNamesStateBuffer::MapEngineToUser(ULONG Eng)
{
    ULONG i;

    if (!m_RegisterMap)
    {
        return (USHORT)Eng;
    }
    
    for (i = 0; i < m_RegisterMapEntries; i++)
    {
        if (m_RegisterMap[i] == Eng)
        {
            return (USHORT)i;
        }
    }

    return (USHORT)Eng;
}

RegisterNamesStateBuffer*
GetRegisterNames(ULONG ProcType)
{
    ULONG i, Unused;

    if (ProcType == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        return NULL;
    }
    
    Dbg_EnterCriticalSection(&g_QuickLock);
    
    Unused = MAX_REG_NAMES;
    for (i = 0; i < MAX_REG_NAMES; i++)
    {
        if (g_RegisterNameBuffers[i].m_ProcType == ProcType)
        {
            Dbg_LeaveCriticalSection(&g_QuickLock);
            return &g_RegisterNameBuffers[i];
        }

        if (g_RegisterNameBuffers[i].m_ProcType ==
            IMAGE_FILE_MACHINE_UNKNOWN &&
            Unused == MAX_REG_NAMES)
        {
            Unused = i;
        }
    }

    if (Unused == MAX_REG_NAMES)
    {
        Dbg_LeaveCriticalSection(&g_QuickLock);
        return NULL;
    }

    g_RegisterNameBuffers[Unused].m_ProcType = ProcType;
    g_RegisterNameBuffers[Unused].UiRequestRead();
    Dbg_LeaveCriticalSection(&g_QuickLock);
    return &g_RegisterNameBuffers[Unused];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\res_str.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Res_str.h

Abstract:

    This module contains the ids for loadable resource strings.

Environment:

    Win32, User Mode

--*/

#if ! defined( _RES_STR_ )
#define _RES_STR_


#ifdef RESOURCES
#define RES_STR(a, b, c) b, c
STRINGTABLE
BEGIN
#else

enum _RESOURCEIDS {
#define RES_STR(a, b, c) a = b,
#endif


//
// Error Messages
//


RES_STR(ERR_Engine_Failed,                1020, "Debugger did not start - please check your initialization parameters")
RES_STR(ERR_Assertion_Failed,             1021, "Assertion Failed")
RES_STR(ERR_Init_Application,             1022, "WinDbg cannot be initialized")
RES_STR(ERR_File_Name_Too_Long,           1023, "'%s' is too long for a filename")
RES_STR(ERR_Internal_Error,               1024, "An internal debugger error (%s) occurred in component '%s'.  Please contact Microsoft Technical Support.\n\n%s")
RES_STR(ERR_File_Open,                    1025, "The file '%s' cannot be opened")
RES_STR(ERR_Path_Too_Long,                1026, "The maximum length for a path is %d characters.\n Please truncate the following path:\n\n%s")
// Attach to a process
RES_STR(ERR_Invalid_Process_Name,         1027, "Invalid Process Name %s")
RES_STR(ERR_Invalid_Process_Id,           1028, "Invalid process ID %ld")
RES_STR(ERR_Invalid_Command_Line,         1029, "The command line arguments passed to WinDbg are invalid")
RES_STR(ERR_Bad_Remote,                   1030, "The remote debugger connection to (%s) failed")
RES_STR(ERR_Unable_To_Connect,            1031, "The debugger could not connect using '%s', %s\n\n%s")
RES_STR(ERR_Invalid_Dump_File_Name,       1032, "Could not find the %s Dump File, %s\n\n%s")
RES_STR(ERR_Invalid_Process_Attach,       1033, "Could not attach to process %d, %s\n\n%s")
RES_STR(ERR_Invalid_Kernel_Attach,        1034, "Could not start kernel debugging using %s parameters, %s\n\n%s")
RES_STR(ERR_No_Register_Names,            1035, "Registers are not yet known")
RES_STR(ERR_Invalid_Server_Param,         1036, "The 'server' command was not given the correct parameters.  Please consult the documentation for a description of the 'server' command parameters")
RES_STR(ERR_Invalid_Remote_Param,         1037, "The 'remote' command was not given the correct parameters.  Please consult the documentation for a description of the 'remote' command parameters")
RES_STR(ERR_Fail_Inst_Postmortem_Dbg,     1039, "Windbg was not successfully installed as the default postmortem debugger.   This operation requires administrative privileges.")
RES_STR(ERR_Success_Inst_Postmortem_Dbg,  1040, "Windbg was successfully installed as the default postmortem debugger.")
RES_STR(ERR_Invalid_Process_Create,       1041, "Could not create process '%s', %s\n\n%s")
RES_STR(ERR_Unable_To_Open_Dump,          1042, "Failure when opening dump file '%s', %s\nIt may be corrupt or in a format not understood by the debugger.\n\n%s")
RES_STR(ERR_Connection_In_Use,            1043, "The remoting connection is already in use")
RES_STR(ERR_Connect_Process_Server,       1044, "Unable to connect to process server '%s', %s\n\n%s")
RES_STR(ERR_Get_Named_Process,            1045, "Unable to find process '%s', %s\n\n%s")
RES_STR(ERR_Path_Empty,                   1046, "Please enter a value for the path")
RES_STR(ERR_No_Detach_On_Exit,            1048, "The system does not support detach on exit")
RES_STR(ERR_No_Code_For_File_Line,        1049, "Code not found, breakpoint not set")
RES_STR(ERR_Deferred_Source_Breakpoint,     1050, "No symbolic information was found for this file.\nA deferred breakpoint has been set")
RES_STR(ERR_Cant_Open_Workspace,          1051, "Unable to open workspace, %s\n\n%s")
RES_STR(ERR_Workspace_Already_Exists,     1052, "Workspace %s already exists.  Overwrite?")
RES_STR(ERR_Cant_Save_Workspace,          1053, "Unable to save workspace, %s\n\n%s")
RES_STR(ERR_File_Has_Changed,             1054, "%s has changed since it was opened.  This may result in invalid breakpoints or other incorrect behavior.\n\nDo you want to reload the file?  NOTE: This will not update breakpoint locations")
RES_STR(ERR_Wake_Failed,                  1055, "Process %d is not a sleeping debugger")
RES_STR(ERR_Cant_Add_Dump_Info_File,      1056, "The debugger doesn't support additional dump information files")
RES_STR(ERR_Add_Dump_Info_File_Failed,    1057, "Unable to use '%s', %s\n\n%s")
RES_STR(ERR_Workspace_Session_Conflict,   1058, "The selected workspace will start a new debugging session.\nPlease stop the current debugging session first.")
RES_STR(ERR_Client_Disconnect,            1059, "The client cannot communicate with the server.  The session will be shut down.")
RES_STR(ERR_Ambiguous_Named_Process,      1060, "There is more than one '%s' process running.  Find the process ID\nof the instance you are interested in and use -p <pid>.")
RES_STR(STR_May_Not_Be_Source,            1061, "The file you selected has an executable file or crash dump file extension.\nFile.Open Executable and File.Open Crash Dump should be used to open such files.\n\nDo you want to open this file as a source file?")

RES_STR(ERR_Cant_Modify_BP_While_Running, 1410, "Debuggee must be stopped before breakpoints can be modified.")
RES_STR(ERR_NULL_Workspace,               1419, "Workspace could not be created")
RES_STR(ERR_Unable_To_Retrieve_Info,      1420, "Unable to retrieve information, %s: %s")
RES_STR(STR_Retrieving_Information,       1421, "Retrieving information...")
RES_STR(ERR_No_More_Matches,              1422, "Can't find '%s'")
RES_STR(STR_Save_Workspace,               1424, "Save %s workspace information?")
RES_STR(ERR_No_Remote_Server,             1425, "The debugger could not contact the remote server given in '%s'")
RES_STR(ERR_Remoting_Version_Mismatch,    1426, "The client is not using the same version of the remoting protocol as the server")
RES_STR(ERR_No_Local_Kernel_Debugging,    1427, "The system does not support local kernel debugging")
RES_STR(ERR_Failed_Local_Kernel_Debugging,1428, "Unable to debug the local kernel, %s\n\n%s")
RES_STR(STR_Abandoning_Noninvasive_Debuggee, 1430, "Exiting without using 'q' or Stop Debugging may leave the debuggee in an unusable state.  Continue?")
RES_STR(STR_Unresolved_Source_Expr,       1431, "Symbol information for the current line could not be located in the currently loaded symbols.\nDo you want the debugger to load and search the remaining symbols?\n\nYes performs the search immediately.\nNo returns to the UI while the search proceeds.\nCancel exits the operation.")
RES_STR(STR_Engine_Still_Busy,            1432, "The debugger is still working and cannot stop.  Answer Yes to continue to wait or No to exit.")
RES_STR(STR_Auto_Arrange_Is_Enabled,      1433, "Automatic window arrangement is enabled and may move or resize your windows.\n\nThe Window.Auto Arrange menu item can be used to disable automatic arrangement.")
RES_STR(ERR_No_Debuggee_Info,             1434, "Cannot query debuggee as it is running or has exited or shut down")
RES_STR(ERR_Create_File_Failed,           1435, "Unable to create file '%s', %s\n\n%s")
RES_STR(ERR_Write_Text_File_Failed,       1436, "Unable to write window text to file '%s', %s\n\n%s")
RES_STR(STR_Create_New_Workspace,         1437, "Workspace not found.  Create it?")
RES_STR(ERR_Too_Many_Dump_Files,          1438, "Too many dump files specified, %s ignored")
RES_STR(ERR_Cant_Secure,                  1439, "Unable to secure operation")


//
// System Strings
//

RES_STR(SYS_Main_wTitle,                    2000,"WinDbg:" VER_PRODUCTVERSION_STR " " )
RES_STR(SYS_Main_wClass,                    2001,"WindbgMainClass")
RES_STR(SYS_CommonWin_wClass,               2002,"CommonWinClass")
RES_STR(SYS_Clear,                          2003,"")
RES_STR(SYS_NewEdit_wClass,                 2006,"NewEditClass")
RES_STR(SYS_Help_File,                      2015,"debugger.chm")
RES_STR(SYS_CpuWin_Title,                   2025,"Registers")
RES_STR(SYS_WatchWin_Title,                 2026,"Watch")
RES_STR(SYS_LocalsWin_Title,                2027,"Locals")
RES_STR(SYS_DisasmWin_Title,                2028,"Disassembly")
RES_STR(SYS_CmdWin_Title,                   2029,"Command")
RES_STR(SYS_MemoryWin_Title,                2031,"Memory")
RES_STR(SYS_DocWin_Title,                   2032,"Document")
RES_STR(SYS_QuickWatchWin_Title,            2033,"Document")
RES_STR(SYS_CallsWin_Title,                 2062,"Calls")
RES_STR(SYS_Scratch_Pad_Title,              2063,"Scratch Pad")
RES_STR(SYS_Process_Thread_Title,           2064,"Processes and Threads")


//
// File-box title strings
//

RES_STR(DLG_Open_Filebox_Title,           3200,"Open Source File")
//RES_STR(DLG_SaveAs_Filebox_Title,         3201,"Save As")
//RES_STR(DLG_Merge_Filebox_Title,          3202,"Merge")
RES_STR(DLG_Browse_Filebox_Title,         3203,"Browse For File ")
RES_STR(DLG_Browse_DbugDll_Title,         3204,"Browse For DLL ")
RES_STR(DLG_Browse_For_Symbols_Title,     3205,"Open Symbol File For ")
RES_STR(DLG_Browse_LogFile_Title,         3206,"Browse For Log File")
RES_STR(DLG_Browse_Executable_Title,      3207,"Open Executable")
RES_STR(DLG_Browse_CrashDump_Title,       3208,"Open Crash Dump")
RES_STR(DLG_Browse_Symbol_Path_Title,     3209,"Add Symbol Path Directory")
RES_STR(DLG_Browse_Source_Path_Title,     3210,"Add Source Path Directory")
RES_STR(DLG_Browse_Image_Path_Title,      3211,"Add Image Path Directory")
RES_STR(DLG_Write_Text_File_Title,        3212,"Write Window Text to File")
RES_STR(DLG_Open_Workspace_File_Title,    3213,"Open Workspace in File")
RES_STR(DLG_Save_Workspace_File_Title,    3214,"Save Workspace to File")



//
// Definitions for status line messages
//
// The '\t' is used to center the text in the status bar rectangle

RES_STR(STS_MESSAGE_OVERTYPE,             10201,"\tOVR")
RES_STR(STS_MESSAGE_CAPSLOCK,             10203,"\tCAPS")
RES_STR(STS_MESSAGE_NUMLOCK,              10204,"\tNUM")
RES_STR(STS_MESSAGE_LINE,                 10205,"\tLn")
RES_STR(STS_MESSAGE_COLUMN,               10206,"Col")
// RES_STR(STS_MESSAGE_SRC,                  10207,"\tSRC")
RES_STR(STS_MESSAGE_CURPROCID,            10208,"\tProc")
RES_STR(STS_MESSAGE_CURTHRDID,            10209,"\tThrd")
RES_STR(STS_MESSAGE_ASM,                  10210,"\tASM")
RES_STR(STS_MESSAGE_CURSYS,               10211,"\tSys")


RES_STR(TYP_File_SOURCE,                  11011,"C/C++ Source Files")
RES_STR(TYP_File_INCLUDE,                 11012,"C/C++ Include Files")
RES_STR(TYP_File_ASMSRC,                  11013,"Assembly Source Files")
RES_STR(TYP_File_INC,                     11014,"Assembly Include Files")
RES_STR(TYP_File_RC,                      11015,"Resource Files")
RES_STR(TYP_File_DLG,                     11016,"Dialog Files")
RES_STR(TYP_File_DEF,                     11017,"Definition Files")
RES_STR(TYP_File_MAK,                     11018,"Project Files")
RES_STR(TYP_File_EXE,                     11019,"Executable Files")
RES_STR(TYP_File_LOG,                     11020,"Log Files")
RES_STR(TYP_File_DUMP,                    11021,"Crash Dump Files")
RES_STR(TYP_File_DLL,                     11022,"DLL Files")
RES_STR(TYP_File_ALL,                     11023,"All Files")
RES_STR(TYP_File_Symbols,                 11024,"Symbol Files")
RES_STR(TYP_File_TXT,                     11025,"Text Files")
RES_STR(TYP_File_Workspace,               11026,"Workspace Files")

RES_STR(DEF_Ext_SOURCE,                   11051,"*.C;*.CPP;*.CXX")
RES_STR(DEF_Ext_INCLUDE,                  11052,"*.H;*.HPP;*.HXX")
RES_STR(DEF_Ext_ASMSRC,                   11053,"*.ASM;*.S")
RES_STR(DEF_Ext_INC,                      11054,"*.INC")
RES_STR(DEF_Ext_EXE,                      11055,"*.EXE")
RES_STR(DEF_Ext_LOG,                      11056,"*.LOG")
RES_STR(DEF_Ext_DUMP,                     11057,"*.DMP;*.MDMP;*.CAB")
RES_STR(DEF_Ext_RC,                       11058,"*.RC")
RES_STR(DEF_Ext_DLG,                      11059,"*.DLG")
RES_STR(DEF_Ext_DEF,                      11060,"*.DEF")
RES_STR(DEF_Ext_MAK,                      11061,"*.MAK")
RES_STR(DEF_Ext_DLL,                      11062,"*.DLL")
RES_STR(DEF_Ext_ALL,                      11063,"*.*")
RES_STR(DEF_Ext_Symbols,                  11064,"*.PDB;*.DBG;*.SYM")
RES_STR(DEF_Ext_TXT,                      11065,"*.TXT")
RES_STR(DEF_Ext_Workspace,                11066,"*.WEW")

RES_STR(DEF_Dump_File,                    11090,"MEMORY.DMP")


// Toolbar strings
RES_STR(TBR_FILE_OPEN,                    12000,"Open source file (Ctrl+O)")

RES_STR(TBR_EDIT_CUT,                     12002,"Cut (Ctrl+X)")
RES_STR(TBR_EDIT_COPY,                    12003,"Copy (Ctrl+C)")
RES_STR(TBR_EDIT_PASTE,                   12004,"Paste (Ctrl+V)")

RES_STR(TBR_DEBUG_GO,                     12005,"Go (F5)")
RES_STR(TBR_DEBUG_RESTART,                12006,"Restart (Ctrl+Shift+F5)")
RES_STR(TBR_DEBUG_STOPDEBUGGING,          12007,"Stop debugging (Shift+F5)")
RES_STR(TBR_DEBUG_BREAK,                  12008,"Break (Ctrl+Break)")

RES_STR(TBR_DEBUG_STEPINTO,               12009,"Step into (F11 or F8)")
RES_STR(TBR_DEBUG_STEPOVER,               12010,"Step over (F10)")
RES_STR(TBR_DEBUG_RUNTOCURSOR,            12011,"Run to cursor (Ctrl+F10 or F7)")

RES_STR(TBR_EDIT_BREAKPOINTS,             12012,"Insert or remove breakpoint (F9)")
RES_STR(TBR_DEBUG_QUICKWATCH,             12013,"Quick watch (Shift+F9)")

RES_STR(TBR_VIEW_COMMAND,                 12014,"Command (Alt+1)")
RES_STR(TBR_VIEW_WATCH,                   12015,"Watch (Alt+2)")
RES_STR(TBR_VIEW_LOCALS,                  12018,"Locals (Alt+3)")
RES_STR(TBR_VIEW_REGISTERS,               12019,"Registers (Alt+4)")
RES_STR(TBR_VIEW_MEMORY,                  12017,"Memory window (Alt+5)")
RES_STR(TBR_VIEW_CALLSTACK,               12016,"Call stack (Alt+6)")
RES_STR(TBR_VIEW_DISASM,                  12020,"Disassembly (Alt+7)")
RES_STR(TBR_VIEW_SCRATCH,                 12021,"Scratch Pad (Alt+8)")

RES_STR(TBR_DEBUG_SOURCE_MODE_ON,         12022,"Source mode on")
RES_STR(TBR_DEBUG_SOURCE_MODE_OFF,        12023,"Source mode off")

RES_STR(TBR_VIEW_FONT,                    12024,"Font")

RES_STR(TBR_EDIT_PROPERTIES,              12025,"Properties")

RES_STR(TBR_VIEW_OPTIONS,                 12026,"Options")

RES_STR(TBR_DEBUG_STEPOUT,                12027,"Step out (Shift+F11)")

RES_STR(TBR_WINDOW_ARRANGE,               12028,"Arrange windows")


#ifdef RESOURCES
    //
    // Menu Items Status bar help
    //

    IDM_FILE,                           "File operations"
    IDM_FILE_OPEN,                      "Open a source file"
    IDM_FILE_CLOSE,                     "Close active window"

    IDM_FILE_OPEN_EXECUTABLE,           "Open an executable to debug"
    IDM_FILE_ATTACH,                    "Attach to a running process"
    IDM_FILE_OPEN_CRASH_DUMP,           "Open a crash dump to debug"
    IDM_FILE_CONNECT_TO_REMOTE,         "Connect to a remote session"
    IDM_FILE_KERNEL_DEBUG,              "Start kernel debugging"
    IDM_FILE_SYMBOL_PATH,               "Set the symbol search path"
    IDM_FILE_SOURCE_PATH,               "Set the source search path"
    IDM_FILE_IMAGE_PATH,                "Set the image search path"

    IDM_FILE_OPEN_WORKSPACE,            "Open a saved workspace"
    IDM_FILE_SAVE_WORKSPACE,            "Save the current workspace"
    IDM_FILE_SAVE_WORKSPACE_AS,         "Save the current workspace with a new name"
    IDM_FILE_CLEAR_WORKSPACE,           "Remove entries from the current workspace"
    IDM_FILE_DELETE_WORKSPACES,         "Delete workspaces from the system"

    IDM_FILE_OPEN_WORKSPACE_FILE,       "Open a workspace saved in a file"
    IDM_FILE_SAVE_WORKSPACE_FILE,       "Save the current workspace to a file"
    IDM_FILE_MAP_NET_DRIVE,             "Map a remote drive"
    IDM_FILE_DISCONN_NET_DRIVE,         "Disconnect a mapped remote drive"

    IDM_FILE_EXIT,                      "Exit WinDbg"

    //
    // Edit
    //
    IDM_EDIT,                           "Edit operations"
    IDM_EDIT_CUT,                       "Move the selected text to the clipboard"
    IDM_EDIT_COPY,                      "Copy the selected text to the clipboard"
    IDM_EDIT_PASTE,                     "Paste the clipboard text at the insertion point"
    IDM_EDIT_SELECT_ALL,                "Select all of the text in the active window"
    IDM_EDIT_WRITE_TEXT_TO_FILE,        "Write a textual representation of the window contents to a file"
    IDM_EDIT_ADD_TO_COMMAND_HISTORY,    "Add a line to the command history text"
    IDM_EDIT_CLEAR_COMMAND_HISTORY,     "Clear the command history text"
    IDM_EDIT_FIND,                      "Find some text"
    IDM_EDIT_FIND_NEXT,                 "Repeat the last find"
    IDM_EDIT_GOTO_LINE,                 "Move to a specified line number"
    IDM_EDIT_GOTO_ADDRESS,              "Move to the specified address"
    IDM_EDIT_GOTO_CURRENT_IP,           "Move to the currently executing code"
    IDM_EDIT_BREAKPOINTS,               "Edit program breakpoints"
    IDM_EDIT_LOG_FILE,                  "Open or close a log file"
    IDM_EDIT_PROPERTIES,                "Edit properties for Memory, Watch, Locals, and Call Stack windows"

    //
    // View
    //
    IDM_VIEW,                           "File navigation, status and toolbars"
    
    IDM_VIEW_COMMAND,                   "Open the command window"
    IDM_VIEW_WATCH,                     "Open the watch window"
    IDM_VIEW_CALLSTACK,                 "Open the call stack window"
    IDM_VIEW_MEMORY,                    "Open a memory window"
    IDM_VIEW_LOCALS,                    "Open the locals window"
    IDM_VIEW_REGISTERS,                 "Open the registers window"
    IDM_VIEW_DISASM,                    "Open the disassembly window"
    IDM_VIEW_SCRATCH,                   "Open the scratch pad window"
    IDM_VIEW_PROCESS_THREAD,            "Open the process and thread window"
    IDM_VIEW_TOGGLE_VERBOSE,            "Toggle the verbose output setting"
    IDM_VIEW_SHOW_VERSION,              "Display debugger and debuggee version information"
    IDM_VIEW_TOOLBAR,                   "Toggle the toolbar on or off"
    IDM_VIEW_STATUS,                    "Toggle the status bar on or off"
    IDM_VIEW_FONT,                      "View or edit the font for the current window"
    IDM_VIEW_OPTIONS,                   "View program options"

    //
    // Debug
    //
    IDM_DEBUG,                          "Debug operations"
    IDM_DEBUG_GO,                       "Run the Program"
    IDM_DEBUG_GO_UNHANDLED,             "Do not handle the exception, but continue running"
    IDM_DEBUG_GO_HANDLED,               "Handle the exception and continue running"
    IDM_DEBUG_RESTART,                  "Restart the Program"
    IDM_DEBUG_STOPDEBUGGING,            "Stop debugging the current program"
    IDM_DEBUG_BREAK,                    "Halt the current program"
    IDM_DEBUG_STEPINTO,                 "Trace into the next statement"
    IDM_DEBUG_STEPOVER,                 "Step over the next statement"
    IDM_DEBUG_STEPOUT,                  "Step out of the current function"
    IDM_DEBUG_RUNTOCURSOR,              "Run the program to the line containing the cursor"
    IDM_DEBUG_SOURCE_MODE,              "Display source when possible"
    IDM_DEBUG_EVENT_FILTERS,            "Manage event filters"
    IDM_DEBUG_MODULES,                  "View the module list"
    IDM_KDEBUG,                         "Kernel debugging control"
    IDM_KDEBUG_TOGGLE_BAUDRATE,         "Cycle through the available baud rate settings"
    IDM_KDEBUG_TOGGLE_INITBREAK,        "Cycle through the possible initial break settings"
    IDM_KDEBUG_RECONNECT,               "Request that the debugger resynchronize with the debuggee"

    //
    // Window
    //
    IDM_WINDOW,                         "Window arrangement and selection"
    IDM_WINDOW_CASCADE,                 "Arrange the windows in a cascaded view"
    IDM_WINDOW_TILE_HORZ,               "Tiles the windows so that they are wide rather than tall"
    IDM_WINDOW_TILE_VERT,               "Tiles the windows so that they are tall rather than wide"
    IDM_WINDOW_ARRANGE,                 "Arrange windows"
    IDM_WINDOW_ARRANGE_ICONS,           "Arrange icons"
    IDM_WINDOW_CLOSE_ALL_DOCWIN         "Close all source windows"
    IDM_WINDOW_AUTO_ARRANGE,            "Automatically arrange all windows"
    IDM_WINDOW_ARRANGE_ALL,             "Arrange all child windows, including sources and disassembly windows"
    IDM_WINDOW_OVERLAY_SOURCE,          "Overlay source windows"
    IDM_WINDOW_AUTO_DISASM,             "Automatically open a disassembly window when source is not available"

    //
    // Help
    //
    IDM_HELP,                           "Help contents and searches"
    IDM_HELP_CONTENTS,                  "Open the help table of contents"
    IDM_HELP_INDEX,                     "Open the help index"
    IDM_HELP_SEARCH,                    "Open the help search dialog"
    IDM_HELP_ABOUT,                     "About WinDbg"



#endif

#ifdef RESOURCES
END
#else
};
#endif


#endif // _RES_STR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\status.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    status.cpp

--*/


#include "precomp.hxx"
#pragma hdrstop



// Adjust the size as necessary.
// Obviously, if an assert that checks for mem overwrites goes off,
// don't remove the assert, increase the char array size.
//           |
//          \|/
#define MAX_TEMP_TXT 100



//Status Bar : Structure definition
typedef struct _STATUS
{
    HWND    hwndStatusBar;

    // The actual text to be displayed for each item
    PTSTR   rgszItemText[nMAX_IDX_STATUSBAR];

    // The line column text is in the following format: Ln 000, Col 000
    // Where "Ln" & "Col" are loaded from the resource and since they could be
    // language dependent. This is why we have to clutter the structure with
    // these 2 additional references.
    PTSTR   lpszLinePrefix;
    PTSTR   lpszColumnPrefix;

    // Prefix help the user figure out which is the process & thread displays
    // Sys 000:xxx
    // Proc 000:000
    // Thrd 000:000
    PTSTR   lpszSystemPrefix;
    PTSTR   lpszProcessPrefix;
    PTSTR   lpszThreadPrefix;

    // Indicates whether the text should be grayed out when displayed.
    // TRUE - grayed out
    // FALSE - normal color
    BOOL    rgbGrayItemText[nMAX_IDX_STATUSBAR];

    // Indicates which ones are OWNER_DRAW. This is done
    //      so we can gray things out.
    // TRUE - Owner draw
    // FALSE - Normal, status bar takes care of the drawing.
    int     rgbOwnerDrawItem[nMAX_IDX_STATUSBAR];


    // TRUE - we are in src code mode
    // FALSE - we are in assembly mode
    BOOL    bSrcMode;

    BOOL    bOverType;                               // Overtype status
    BOOL    bCapsLock;                               // CapsLock status
    BOOL    bNumLock;                                // NumLock status
} STATUS, * LPSTATUS;

static STATUS status;

BOOL g_ShowStatusBar;

///////////////////////////////////////////////////////////
// protos
void RecalcItemWidths_StatusBar(void);
void Internal_SetItemText_StatusBar(nIDX_STATUSBAR_ITEMS nId,
                                    PTSTR lpszNewText);

///////////////////////////////////////////////////////////
// Init/term functions
//
BOOL
CreateStatusBar(HWND hwndParent)
/*++
Routine Description:
    Creates and initializes the status bar.

Arguments:
    hwndParent - Hwnd to the owner of the status bar
--*/
{
    TCHAR sz[MAX_MSG_TXT];

    status.hwndStatusBar = CreateStatusWindow(
        WS_CHILD | WS_BORDER
        | WS_VISIBLE | CCS_BOTTOM,  // style
        _T(""),                     // initial text
        hwndParent,                 // parent
        IDC_STATUS_BAR);            // id
    if (status.hwndStatusBar == NULL)
    {
        return FALSE;
    }

    //
    // We recalc the sizes even though we know they are 0, because,
    // the status bar needs to know how many parts there will be.
    //
    RecalcItemWidths_StatusBar();

    //
    // These are the owner draw items.
    //
    status.rgbOwnerDrawItem[nSRCASM_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nOVRTYPE_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nCAPSLCK_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nNUMLCK_IDX_STATUSBAR] = TRUE;

    //
    // Load the static stuff.
    //
    Dbg(LoadString(g_hInst, STS_MESSAGE_ASM, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nSRCASM_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_OVERTYPE, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nOVRTYPE_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_CAPSLOCK, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nCAPSLCK_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_NUMLOCK, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nNUMLCK_IDX_STATUSBAR, sz);

    //
    // Preload prefixes
    //
    Dbg(LoadString(g_hInst, STS_MESSAGE_CURSYS, sz, _tsizeof(sz)));
    status.lpszSystemPrefix = _tcsdup(sz);
    if (!status.lpszSystemPrefix)
    {
        return FALSE;
    }

    Dbg(LoadString(g_hInst, STS_MESSAGE_CURPROCID, sz, _tsizeof(sz)));
    status.lpszProcessPrefix = _tcsdup(sz);
    if (!status.lpszProcessPrefix)
    {
        return FALSE;
    }

    Dbg(LoadString(g_hInst, STS_MESSAGE_CURTHRDID, sz, _tsizeof(sz)));
    status.lpszThreadPrefix = _tcsdup(sz);
    if (!status.lpszThreadPrefix)
    {
        return FALSE;
    }

    Dbg(LoadString(g_hInst, STS_MESSAGE_LINE, sz, _tsizeof(sz)));
    status.lpszLinePrefix = _tcsdup(sz);
    if (!status.lpszLinePrefix)
    {
        return FALSE;
    }

    Dbg(LoadString(g_hInst, STS_MESSAGE_COLUMN, sz, _tsizeof(sz)));
    status.lpszColumnPrefix = _tcsdup(sz);
    if (!status.lpszColumnPrefix)
    {
        return FALSE;
    }

    SetLineColumn_StatusBar(0, 0);
    SetSysPidTid_StatusBar(0, "<None>", 0, 0, 0, 0);
    SetCapsLock_StatusBar(GetKeyState(VK_CAPITAL) & 0x0001);
    SetNumLock_StatusBar(GetKeyState(VK_NUMLOCK) & 0x0001);
    SetOverType_StatusBar(FALSE);

    g_ShowStatusBar = TRUE;
    
    return TRUE;
}


void
TerminateStatusBar()
/*++
Routine Description:
    Just frees allocated resources.
--*/
{
    int i;

    for (i = 0; i < nMAX_IDX_STATUSBAR -1; i++)
    {
        if (status.rgszItemText[i])
        {
            free(status.rgszItemText[i]);
            status.rgszItemText[i] = NULL;
        }
    }

    if (status.lpszLinePrefix)
    {
        free(status.lpszLinePrefix);
        status.lpszLinePrefix = NULL;
    }

    if (status.lpszColumnPrefix)
    {
        free(status.lpszColumnPrefix);
        status.lpszColumnPrefix = NULL;
    }

    if (status.lpszSystemPrefix)
    {
        free(status.lpszSystemPrefix);
        status.lpszSystemPrefix = NULL;
    }

    if (status.lpszProcessPrefix)
    {
        free(status.lpszProcessPrefix);
        status.lpszProcessPrefix = NULL;
    }

    if (status.lpszThreadPrefix)
    {
        free(status.lpszThreadPrefix);
        status.lpszThreadPrefix = NULL;
    }
}



///////////////////////////////////////////////////////////
// Operations that affect the entire status bar.
//
void
Show_StatusBar(
               BOOL bShow
               )
/*++
Routine Description:
    Show/Hide the status bar. Automatically resizes/updates the MDI client.

Arguments:
    bShow -     TRUE - Show status bar
                FALSE - Hide status bar
--*/
{
    RECT rect;

    // Show/Hide the toolbar
    g_ShowStatusBar = bShow;
    ShowWindow(status.hwndStatusBar, bShow ? SW_SHOW : SW_HIDE);

    //Ask the frame to resize, so that everything will be correctly positioned.
    GetWindowRect(g_hwndFrame, &rect);

    SendMessage(g_hwndFrame, WM_SIZE, SIZE_RESTORED,
        MAKELPARAM(rect.right - rect.left, rect.bottom - rect.top));

    // Ask the MDIClient to redraw itself and its children.
    // This is  done in order to fix a redraw problem where some of the
    // MDIChild window are not correctly redrawn.
    Dbg(RedrawWindow(g_hwndMDIClient, NULL, NULL,
        RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_FRAME));
}                                       // UpdateToolbar()


void
WM_SIZE_StatusBar(
                  WPARAM wParam,
                  LPARAM lParam
                  )
/*++
Routine Description:
    Causes the status bar to be resized. This function is meant to be
    called from the parent window, whenever a parent window receives a
    WM_SIZE message, ie:

    // parent window proc
    switch (uMsg)
    {
    case WM_SIZE:
        WM_SIZE_StatusBar(wParam, lParam);
        return TRUE;
        ...
        ...
        ...
    }

Arguments:
    wParam & lParam - See docs for a desciption of the WM_SIZE message.

--*/
{
    // make the status bar resize.
    SendMessage(status.hwndStatusBar, WM_SIZE, wParam, lParam);

    // Since it was resized, the widths the text items need to be recalculated.
    // The is because  of the way that status bar positions the elements on the
    // screen. See the docs for SB_SETPARTS, for more detail. The SB_SETPARTS
    // docs will enlighten you.
    RecalcItemWidths_StatusBar();
}


HWND
GetHwnd_StatusBar()
{
    return status.hwndStatusBar;
}



///////////////////////////////////////////////////////////
// Main text display functions
//
void
RecalcItemWidths_StatusBar(void)
/*++
Routine description:
    The function will recalculate the width of the text items.
    The calculations don't have to be exact. Status bar is very
    forgiving and pretty much needs a rough estimate.
--*/
{
    int rgnItemWidths[nMAX_IDX_STATUSBAR];
    int i, nWidth;
    HDC hdc;

    hdc = GetDC(status.hwndStatusBar);
    Dbg(hdc);

    // Get the width of the status bar's client area.
    {
        RECT rcClient;
        GetClientRect(status.hwndStatusBar, &rcClient);
        nWidth = rcClient.right;
    }

    // Calculate the right edge coordinate for each part, and
    // copy the coordinates to the array.
    for (i = nMAX_IDX_STATUSBAR -1; i >= 0; i--)
    {
        rgnItemWidths[i] = nWidth;

        if (NULL == status.rgszItemText[i])
        {
            // We don't have any text, but we need a position anyways.
            nWidth -= 10; // Just any old number
        }
        else
        {
            PTSTR lpsz = status.rgszItemText[i];
            SIZE size;

            // Skip over tabs.
            // 1 tab is centered, 2 is right aligned.
            // See status bar docs for more info.
            if (_T('\t') == *lpsz)
            {
                lpsz++;
                if (_T('\t') == *lpsz)
                {
                    lpsz++;
                }
            }

            Dbg(GetTextExtentPoint32(hdc, lpsz, _tcslen(lpsz), &size));

            nWidth -= size.cx;
        }
    }

    Dbg(ReleaseDC(status.hwndStatusBar, hdc));

    // Tell the status window to create the window parts.
    Dbg(SendMessage(status.hwndStatusBar, SB_SETPARTS,
        (WPARAM) nMAX_IDX_STATUSBAR, (LPARAM) rgnItemWidths));

    // The status bar invalidates the parts that changed. So it is
    // automatically updated.
}


void
Internal_SetItemText_StatusBar(
                    nIDX_STATUSBAR_ITEMS nId,
                    PTSTR lpszNewText
                    )
/*++
Routine Description:
    Set the text for a specified item.
--*/
{
    // Leave these sanity checks in here.
    // If they go off, someone did something wrong
    // or changed some important code
    Dbg((0 <= nId));
    Dbg((nId < nMAX_IDX_STATUSBAR));
    Dbg((lpszNewText));

    // Free any previous text
    if (status.rgszItemText[nId])
    {
        free(status.rgszItemText[nId]);
    }

    // duplicate the text
    status.rgszItemText[nId] = _tcsdup(lpszNewText);

    // Make sure it was allocated
    Assert(status.rgszItemText[nId]);

    // Do we have any text to set?
    if (status.rgszItemText[nId])
    {
        int nFormat = nId;

        // Make it owner draw???
        if (status.rgbOwnerDrawItem[nId])
        {
            nFormat |= SBT_OWNERDRAW;
        }

        // Set the text
        Dbg(SendMessage(status.hwndStatusBar, SB_SETTEXT,
            (WPARAM) nFormat, (LPARAM) status.rgszItemText[nId]));
    }
}


void
InvalidateItem_Statusbar(nIDX_STATUSBAR_ITEMS nIdx)
/*++
Routine description:
    Invalidates the item's rect on the status bar, so that an update
    to that region will take place.

Arguments:
    nIdx - The status bar item that is to be updated.
--*/
{
    RECT rc;

    Dbg((0 <= nIdx));
    Dbg((nIdx < nMAX_IDX_STATUSBAR));

    SendMessage(status.hwndStatusBar, SB_GETRECT,
                (WPARAM) nIdx, (LPARAM) &rc);

    InvalidateRect(status.hwndStatusBar, &rc, FALSE);
}


void
OwnerDrawItem_StatusBar(
                        LPDRAWITEMSTRUCT lpDrawItem
                        )
/*++
Routine Description:
    Called from the parent window for owner draw text items.
    Draws an actual status bar item onto the status bar.
    Depending the the flags set, it will draw the item grayed out.

Arguments:
    See docs for WM_DRAWITEM, and Status bar -> owner draw items.
--*/
{
    PTSTR lpszItemText = (PTSTR) lpDrawItem->itemData;
    COLORREF crefOldTextColor = CLR_INVALID;
    COLORREF crefOldBkColor = CLR_INVALID;

    if (NULL == lpszItemText)
    {
        // nothing to do
        return;
    }

    // Set background color and save the old color.
    crefOldBkColor = SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_3DFACE));
    Assert(CLR_INVALID != crefOldBkColor);

    // should the item be grayed out?
    if (status.rgbGrayItemText[lpDrawItem->itemID])
    {
        crefOldTextColor = SetTextColor(lpDrawItem->hDC,
                                        GetSysColor(COLOR_GRAYTEXT));
        Assert(CLR_INVALID != crefOldTextColor);
    }

    // draw the color coded text to the screen
    {
        UINT uFormat = DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE;

        // "\t" is used to center
        // '\t\t" is used to right align.
        // No, I did not make this up, this is the way the status bar works.
        if (_T('\t') == *lpszItemText)
        {
            lpszItemText++;
            if (_T('\t') == *lpszItemText)
            {
                // 2 tabs found
                lpszItemText++;
                uFormat |= DT_RIGHT;
            }
            else
            {
                // 1 tab found
                uFormat |= DT_CENTER;
            }
        }
        DrawText(lpDrawItem->hDC, lpszItemText, _tcslen(lpszItemText),
            &lpDrawItem->rcItem, uFormat);
    }

    // Reset the the hDC back to its old state.
    if (CLR_INVALID != crefOldTextColor)
    {
        Dbg((CLR_INVALID != SetTextColor(lpDrawItem->hDC, crefOldTextColor)));
    }

    if (CLR_INVALID != crefOldBkColor)
    {
        Dbg((CLR_INVALID != SetBkColor(lpDrawItem->hDC, crefOldBkColor)));
    }
}


void
SetItemText_StatusBar(
                    nIDX_STATUSBAR_ITEMS nId,
                    PTSTR lpszNewText
                    )
/*++
Routine Description:

Arguments:
    nId         -
    lpszNewText
--*/
{
    Internal_SetItemText_StatusBar(nId, lpszNewText);
    // If nId is 0, the we don't have to recalc the widths, because this
    // is the only one that doesn't affect the rest.
    if (nId > 0)
    {
        RecalcItemWidths_StatusBar();
    }
}



///////////////////////////////////////////////////////////
// Set/get specialized items on the status bar.
//
// All of the Get????_StatusBar retrieve the current value.
//
// All of the Set????_StatusBar set the new value and return the
//   previous value.
//      TRUE - Item is enabled.
//      FALSE - Item is disabled.

//
// Src/Asm mode
BOOL
GetSrcMode_StatusBar()
{
    return status.bSrcMode;
}

BOOL
SetSrcMode_StatusBar(
                     BOOL bNewValue
                     )
{
    BOOL b = status.bSrcMode;

    status.bSrcMode = bNewValue;
    status.rgbGrayItemText[nSRCASM_IDX_STATUSBAR] = bNewValue;

    InvalidateItem_Statusbar(nSRCASM_IDX_STATUSBAR);

    // Reflect the change to the menu
    InitializeMenu(GetMenu(g_hwndFrame));

    /*
    // Old code that was move in here.
    if ( (FALSE == bNewValue) && (NULL == GetDisasmHwnd()) ) {
        OpenDebugWindow(DISASM_WINDOW, TRUE); // User activated
    }
    */

    return b;
}


//
// Insert/Overtype mode
BOOL
GetOverType_StatusBar()
{
    return status.bOverType;
}


BOOL
SetOverType_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bOverType;

    status.bOverType = bNewValue;
    status.rgbGrayItemText[nOVRTYPE_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nOVRTYPE_IDX_STATUSBAR);

    return b;
}


//
// Num lock mode
BOOL
GetNumLock_StatusBar()
{
    return status.bNumLock;
}

BOOL
SetNumLock_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bNumLock;

    status.bNumLock = bNewValue;
    status.rgbGrayItemText[nNUMLCK_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nNUMLCK_IDX_STATUSBAR);

    return b;
}


//
// Caps mode
BOOL
GetCapsLock_StatusBar()
{
    return status.bCapsLock;
}

BOOL
SetCapsLock_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bCapsLock;

    status.bCapsLock = bNewValue;
    status.rgbGrayItemText[nCAPSLCK_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nCAPSLCK_IDX_STATUSBAR);

    return b;
}


///////////////////////////////////////////////////////////
// Specialized text display functions

void
SetMessageText_StatusBar(UINT StringId)
{
    TCHAR Str[MAX_TEMP_TXT];

    // load format string from resource file
    if (LoadString(g_hInst, StringId, Str, sizeof(Str)) == 0)
    {
        Str[0] = 0;
    }
    SetItemText_StatusBar(nMESSAGE_IDX_STATUSBAR, Str);
}

void
SetLineColumn_StatusBar(
                        int nNewLine,
                        int nNewColumn
                        )
/*++
Routine Description:
    Used to display the line and column values in text edit controls.
    Loads the prefixs "Ln" & "Col" from the string resource section.

Arguments:
    nNewLine - Line number in edit controls.
    nNewColumn - Column number in edit controls.
--*/
{
    TCHAR sz[MAX_TEMP_TXT];

    _stprintf(sz, _T("%s %d, %s %d"), status.lpszLinePrefix, nNewLine,
        status.lpszColumnPrefix, nNewColumn);

    Dbg((_tcslen(sz) < _tsizeof(sz)));

    SetItemText_StatusBar(nSRCLIN_IDX_STATUSBAR, sz);
}


void
SetSysPidTid_StatusBar(
    ULONG SystemId,
    PSTR SystemName,
    ULONG ProcessId,
    ULONG ProcessSysId,
    ULONG ThreadId,
    ULONG ThreadSysId
    )
{
    TCHAR sz[MAX_TEMP_TXT];

    _stprintf(sz, _T("%s %d:%s"), status.lpszSystemPrefix,
              SystemId, SystemName);
    
    // Sanity check, should never occur.
    // Mem overwrite?
    Assert(_tcslen(sz) < _tsizeof(sz));

    SetItemText_StatusBar(nCURSYS_IDX_STATUSBAR, sz);

    _stprintf(sz, _T("%s %03d:%x"), status.lpszProcessPrefix,
              ProcessId, ProcessSysId);

    // Sanity check, should never occur.
    // Mem overwrite?
    Assert(_tcslen(sz) < _tsizeof(sz));

    SetItemText_StatusBar(nPROCID_IDX_STATUSBAR, sz);

    _stprintf(sz, _T("%s %03d:%x"), status.lpszThreadPrefix,
              ThreadId, ThreadSysId);

    // Sanity check, should never occur.
    // Mem overwrite?
    Assert(_tcslen(sz) < _tsizeof(sz));

    SetItemText_StatusBar(nTHRDID_IDX_STATUSBAR, sz);
}



///////////////////////////////////////////////////////////
// Misc helper routines
//
/****************************************************************************

         FUNCTION: KeyboardHook

         PURPOSE: Check if keyboard hit is NUMLOCK, CAPSLOCK or INSERT

****************************************************************************/
LRESULT
KeyboardHook( 
    int iCode, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    if (iCode == HC_ACTION)
    {
        if (wParam == VK_NUMLOCK
            && HIWORD(lParam) & 0x8000 // Key up
            && GetKeyState(VK_CONTROL) >= 0)
        {
            //No Ctrl
            // CAPSLOCK has been hit, refresh status
            SetNumLock_StatusBar(GetKeyState(VK_NUMLOCK) & 0x0001);
        }
        else if (wParam == VK_CAPITAL
                 && HIWORD(lParam) & 0x8000 //Key up
                 && GetKeyState(VK_CONTROL) >= 0)
        {
            //No Ctrl
            // CAPSLOCK has been hit, refresh status
            SetCapsLock_StatusBar(GetKeyState(VK_CAPITAL) & 0x0001);
        }
        else if (wParam == VK_INSERT
                 && ((HIWORD(lParam) & 0xE000) == 0x0000) //Key down was up before and No Alt
                 && GetKeyState(VK_SHIFT) >= 0   //No Shift
                 && GetKeyState(VK_CONTROL) >= 0)
        {
            //No Ctrl
            // INSERT has been hit and refresh status if so
            // We can't use the up down state, since there is no indicator
            // light as a referene to the user. We simple have to toggle it.
            SetOverType_StatusBar(!GetOverType_StatusBar());
        }
    }

    return CallNextHookEx( hKeyHook, iCode, wParam, lParam );
}                                       /* KeyboardHook() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\status.h ===
/*++ 

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    status.h

Environment:

    Win32, User Mode

---*/



// Used as indexes into the rgnItemWidth & rgszItemText
// arrays. These are in order from left to right.

typedef enum
{
    nMESSAGE_IDX_STATUSBAR,         // Generic txt message such as menu help,
                                    // or error messages, etc.
    nSRCLIN_IDX_STATUSBAR,          // Line num. & coloumn num. in src file
    nCURSYS_IDX_STATUSBAR,          // Current system
    nPROCID_IDX_STATUSBAR,          // Process ID
    nTHRDID_IDX_STATUSBAR,          // Thread ID
    nSRCASM_IDX_STATUSBAR,          // Src/Asm mode idicator      
    nOVRTYPE_IDX_STATUSBAR,         // Insert/Overtype indicator
    nCAPSLCK_IDX_STATUSBAR,         // Caps lock indicator
    nNUMLCK_IDX_STATUSBAR,          // Num lock indicator
    nMAX_IDX_STATUSBAR,             // Max num items in enum
} nIDX_STATUSBAR_ITEMS;

extern BOOL g_ShowStatusBar;

// Init/Term functions
BOOL CreateStatusBar(HWND hwndParent);
void TerminateStatusBar();

void Show_StatusBar(BOOL bShow);

void WM_SIZE_StatusBar(WPARAM wParam, LPARAM lParam); 

HWND GetHwnd_StatusBar();

// Some of the items are owner draw.
void OwnerDrawItem_StatusBar(LPDRAWITEMSTRUCT lpDrawItem);

//
// Status bar operations
//

void SetMessageText_StatusBar(UINT StringId);

void SetLineColumn_StatusBar(int newLine, int newColumn);

void SetSysPidTid_StatusBar(ULONG SysId, PSTR SysName,
                            ULONG ProcessId, ULONG ProcessSysId,
                            ULONG ThreadId, ULONG ThreadSysId);

// TRUE - considered on, and the text is displayed in black
// FALSE - considered off, and the text is displayed in dark gray
//
BOOL GetNumLock_StatusBar();
BOOL SetNumLock_StatusBar(BOOL newValue);

BOOL GetCapsLock_StatusBar();
BOOL SetCapsLock_StatusBar(BOOL newValue);

BOOL GetSrcMode_StatusBar();
BOOL SetSrcMode_StatusBar(BOOL bSrcMode);

BOOL GetOverType_StatusBar();
BOOL SetOverType_StatusBar(BOOL bOverType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\statebuf.h ===
//----------------------------------------------------------------------------
//
// Debuggee state buffers.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __STATEBUF_H__
#define __STATEBUF_H__

// Different WU_UPDATE qualifiers, sent in WPARAM.
enum UpdateType
{
    UPDATE_BUFFER,
    UPDATE_BP,
    UPDATE_EXEC,
    UPDATE_INPUT_REQUIRED,
    UPDATE_START_SESSION,
    UPDATE_END_SESSION,
    UPDATE_PROMPT_TEXT,
    UPDATE_EXIT,
    UPDATE_REFRESH_MODULES,
    UPDATE_REG_NAMES,
};

typedef enum
{
    MINVAL_WINDOW = 0,
    DOC_WINDOW,
    WATCH_WINDOW,
    LOCALS_WINDOW,
    CPU_WINDOW,
    DISASM_WINDOW,
    CMD_WINDOW,
    SCRATCH_PAD_WINDOW,
    MEM_WINDOW,
    QUICKW_WINDOW,
    CALLS_WINDOW,
    PROCESS_THREAD_WINDOW,
    MAXVAL_WINDOW,
    // Artificial values so there are well-defined bit
    // positions for state which is not tied to a specific window.
    EVENT_BIT,
    BP_BIT,
    BP_CMDS_BIT,
    FILTER_BIT,
    MODULE_BIT,
    ALIAS_BIT
} WIN_TYPES, * PWIN_TYPES;

#define FIRST_WINDOW ((WIN_TYPES)(MINVAL_WINDOW + 1))
#define LAST_WINDOW ((WIN_TYPES)(MAXVAL_WINDOW - 1))

#define ALL_WINDOWS 0xffffffff

//----------------------------------------------------------------------------
//
// StateBuffer.
//
// A state buffer is a dynamic container for data passed from
// the engine thread to the UI thread.  It may be used for
// holding window content, in which case it will have an HWND
// associated with it, or it can be an internal buffer for non-UI
// purposes.
//
// A list of current window-associated state buffers is kept for
// the engine to traverse when it is updating state for the UI.
// The UI thread is the only thread that can add to this list.
// The engine thread is the only thread that can remove a buffer
// from the list.  This is necessary for proper lifetime management
// of dynamically-created buffers.
//
//----------------------------------------------------------------------------

class StateBuffer : public LIST_ENTRY
{
public:
    DBG_CRITICAL_SECTION m_Lock;
    WIN_TYPES m_enumType;
    HWND m_Win;
    ULONG m_UpdateTypes;
    UpdateType m_UpdateType;
    
    StateBuffer(ULONG ChangeBy);
    virtual ~StateBuffer(void);

    PVOID AddData(ULONG Len);
    BOOL AddString(PCSTR Str, BOOL SoftTerminate);
    void RemoveHead(ULONG Len);
    void RemoveMiddle(ULONG Start, ULONG Len);
    void RemoveTail(ULONG Len);
    HRESULT Resize(ULONG Len);
    void Free(void);
    
    void Empty(void)
    {
        m_DataUsed = 0;
    }
    HRESULT GetStatus(void)
    {
        return m_Status;
    }
    void SetStatus(HRESULT Status)
    {
        m_Status = Status;
    }
    ULONG GetReadRequest(void)
    {
        return m_ReadRequest;
    }
    ULONG GetReadDone(void)
    {
        return m_ReadDone;
    }
    void RequestRead(void)
    {
        InterlockedIncrement((LONG *)&m_ReadRequest);
    }
    void SetReadDone(ULONG Done)
    {
        m_ReadDone = Done;
    }
    PVOID GetDataBuffer(void)
    {
        return m_Data;
    }
    ULONG GetDataLen(void)
    {
        return m_DataUsed;
    }

    HRESULT Update(void);
    
    void UiRequestRead(void);
    HRESULT UiLockForRead(void);
    
    // Base implementation just returns S_OK for
    // buffers maintained in other ways.
    // ReadState should only be called in the engine thread.
    virtual HRESULT ReadState(void);
    
protected:
    void SetNoData(void)
    {
        m_Data = NULL;
        m_DataLen = 0;
        Empty();
    }

    ULONG m_ChangeBy;

    UINT m_UpdateMessage;
    HRESULT m_Status;
    ULONG m_ReadRequest;
    ULONG m_ReadDone;
    
    PBYTE m_Data;
    ULONG m_DataLen;
    ULONG m_DataUsed;
};

//----------------------------------------------------------------------------
//
// OutputToStateBuffer.
//
//----------------------------------------------------------------------------

class OutputToStateBuffer : public DefOutputCallbacks
{
public:
    OutputToStateBuffer(void)
    {
        m_Buffer = NULL;
    }

    void SetBuffer(StateBuffer* Buffer)
    {
        m_Buffer = Buffer;
    }

    HRESULT Start(BOOL Empty);
    HRESULT End(BOOL RemoveLastNewLine);

    ULONG GetLineCount(void)
    {
        return m_NewLineCount + m_PartialLine;
    }
    ULONG RecountLines(void)
    {
        m_NewLineCount = 0;
        AddLines((PSTR)m_Buffer->GetDataBuffer() + m_DataStart);
        return GetLineCount();
    }

    void ReplaceChar(char From, char To);
    
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );

private:
    void AddLines(PCSTR Start);

    StateBuffer* m_Buffer;
    ULONG m_DataStart;
    HRESULT m_Status;
    ULONG m_NewLineCount;
    ULONG m_PartialLine;
};

extern OutputToStateBuffer g_OutStateBuf;
extern OutputToStateBuffer g_UiOutStateBuf;

//----------------------------------------------------------------------------
//
// Dynamic state buffers.
//
//----------------------------------------------------------------------------

extern LIST_ENTRY g_StateList;

// Global lock for short operations where it doesn't matter
// if the threads block on each other briefly.  This lock should
// not be held longer than a fraction of a second.
// Used for protecting:
//   State buffer list.
//   g_Event values.
extern DBG_CRITICAL_SECTION g_QuickLock;

#define LockStateBuffer(Buffer) Dbg_EnterCriticalSection(&(Buffer)->m_Lock)
#define UnlockStateBuffer(Buffer) Dbg_LeaveCriticalSection(&(Buffer)->m_Lock)

#define AssertStateBufferLocked(Buffer) \
    Assert(Dbg_CriticalSectionOwned(&(Buffer)->m_Lock))

extern ULONG64 g_CodeIp;
// If g_CodeFileFound[0] == 0 no source file was found.
extern char g_CodeFileFound[];
// If g_CodeSymFile[0] == 0 no source symbol information was found.
extern char g_CodeSymFile[];
extern char g_CodePathComponent[];
extern ULONG g_CodeLine;
extern BOOL g_CodeUserActivated;
extern ULONG g_CodeBufferSequence;

extern ULONG64 g_EventIp;
extern ULONG g_CurSystemId;
extern char g_CurSystemName[];
extern ULONG g_CurProcessId, g_CurProcessSysId;
extern ULONG g_CurThreadId, g_CurThreadSysId;

enum BpStateType
{
    BP_ENABLED,
    BP_DISABLED,
    BP_NONE,
    BP_UNKNOWN
};

struct BpBufferData
{
    ULONG64 Offset;
    ULONG Id;
    ULONG Flags;
    ULONG Thread;
    ULONG Sequence;
    ULONG FileOffset;
};
extern ULONG g_BpCount;
extern StateBuffer* g_BpBuffer;
extern ULONG g_BpTextOffset;

extern StateBuffer* g_BpCmdsBuffer;

extern StateBuffer* g_FilterTextBuffer;

extern StateBuffer* g_FilterBuffer;
extern ULONG g_FilterArgsOffset;
extern ULONG g_FilterCmdsOffset;
extern ULONG g_FilterWspCmdsOffset;
extern ULONG g_NumSpecEvents, g_NumSpecEx, g_NumArbEx;

extern StateBuffer* g_ModuleBuffer;
extern ULONG g_NumModules;

extern StateBuffer* g_AliasBuffer;

void FillCodeBuffer(ULONG64 Ip, BOOL UserActivated);
void FillEventBuffer(void);

void ReadStateBuffers(void);

#define BUFFERS_ALL 0xffffffff

void InvalidateStateBuffers(ULONG Types);

void UpdateBufferWindows(ULONG Types, UpdateType Type);

//----------------------------------------------------------------------------
//
// Static state buffers.
//
//----------------------------------------------------------------------------

#define REGCUST_CHANGED_FIRST 0x00000001
#define REGCUST_NO_SUBREG     0x00000002

class RegisterNamesStateBuffer : public StateBuffer
{
public:
    RegisterNamesStateBuffer(void)
        : StateBuffer(128)
    {
        m_UpdateTypes = (1 << CPU_WINDOW);
        m_UpdateType = UPDATE_REG_NAMES;
        m_ProcType = IMAGE_FILE_MACHINE_UNKNOWN;
        m_NumRegisters = 0;
        m_RegisterMap = NULL;
        m_RegisterMapEntries = 0;
        m_Flags = 0;
        m_NamesOffset = 0;
    }

    virtual HRESULT ReadState(void);

    void GetRegisterMapText(HWND Edit);
    void ScanRegisterMapText(HWND Edit);
    void SetRegisterMap(ULONG Count, PUSHORT Data);

    USHORT MapUserToEngine(ULONG User)
    {
        return m_RegisterMap != NULL && User < m_RegisterMapEntries ?
            m_RegisterMap[User] : (USHORT)User;
    }
    USHORT MapEngineToUser(ULONG Eng);
        
    ULONG m_ProcType;
    ULONG m_NumRegisters;
    PUSHORT m_RegisterMap;
    ULONG m_RegisterMapEntries;
    ULONG m_Flags;
    ULONG m_NamesOffset;
};

RegisterNamesStateBuffer* GetRegisterNames(ULONG ProcType);

//----------------------------------------------------------------------------
//
// UI thread state buffer.
//
// The UI thread has simple needs and so one state buffer for
// output capture is sufficient.
//
//----------------------------------------------------------------------------

extern StateBuffer g_UiOutputCapture;

#endif // #ifndef __STATEBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\toolbar.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    Toolbar.h

Abstract:

    This module contains the support code for toolbar

--*/

#define TEXT_TB_BTN(Id, Text, Flags) \
    { I_IMAGENONE, Id, TBSTATE_ENABLED, \
      BTNS_AUTOSIZE | BTNS_SHOWTEXT | (Flags), \
      {0}, 0, (INT_PTR)(Text) }

#define SEP_TB_BTN() \
    { 8, 8, 0, BTNS_SEP, {0}, 0, 0 }

extern BOOL g_ShowToolbar;

HWND GetHwnd_Toolbar();
PTSTR GetToolTipTextFor_Toolbar(UINT uToolbarId);
BOOL CreateToolbar(HWND hwndParent);

//Update toolbar
void Show_Toolbar(BOOL bShow);

void EnableToolbarControls();

void ToolbarIdEnabled(UINT, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\toolbar.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    Toolbar.cpp

Abstract:

    This module contains the support code for toolbar

--*/


#include "precomp.hxx"
#pragma hdrstop

BOOL g_ShowToolbar;

// Handle to main toolbar window
HWND g_Toolbar;

// See docs for TBBUTTON
TBBUTTON g_TbButtons[] =
{
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 0,    IDM_FILE_OPEN,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 2,    IDM_EDIT_CUT,               TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 3,    IDM_EDIT_COPY,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 4,    IDM_EDIT_PASTE,             TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 5,    IDM_DEBUG_GO,               TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 6,    IDM_DEBUG_RESTART,          TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 7,    IDM_DEBUG_STOPDEBUGGING,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 8,    IDM_DEBUG_BREAK,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 9,    IDM_DEBUG_STEPINTO,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 10,   IDM_DEBUG_STEPOVER,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 11,   IDM_DEBUG_STEPOUT,          TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 12,   IDM_DEBUG_RUNTOCURSOR,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 13,   IDM_EDIT_TOGGLEBREAKPOINT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 15,   IDM_VIEW_COMMAND,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 16,   IDM_VIEW_WATCH,             TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 17,   IDM_VIEW_LOCALS,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 18,   IDM_VIEW_REGISTERS,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 19,   IDM_VIEW_MEMORY,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 20,   IDM_VIEW_CALLSTACK,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 21,   IDM_VIEW_DISASM,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 22,   IDM_VIEW_SCRATCH,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 23,   IDM_DEBUG_SOURCE_MODE_ON,   TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0},
    { 24,   IDM_DEBUG_SOURCE_MODE_OFF,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 25,   IDM_EDIT_PROPERTIES,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 26,   IDM_VIEW_FONT,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 27,   IDM_VIEW_OPTIONS,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 28,   IDM_WINDOW_ARRANGE,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
};

// Toolbar constants.
#define NUM_BMPS_IN_TOOLBAR  ( sizeof(g_TbButtons) / sizeof(g_TbButtons[0]) )

// Used to retrieve the tooltip text
typedef struct
{
    UINT    uCmdId;     // TBBUTTON command
    int     nStrId;     // String resource ID
} TB_STR_MAP;

// Map the command id to resource string identifier.
TB_STR_MAP g_TbStrMap[] =
{
    { IDM_FILE_OPEN,                TBR_FILE_OPEN },
    { IDM_EDIT_CUT,                 TBR_EDIT_CUT },
    { IDM_EDIT_COPY,                TBR_EDIT_COPY },
    { IDM_EDIT_PASTE,               TBR_EDIT_PASTE },
    { IDM_DEBUG_GO,                 TBR_DEBUG_GO },
    { IDM_DEBUG_RESTART,            TBR_DEBUG_RESTART },
    { IDM_DEBUG_STOPDEBUGGING,      TBR_DEBUG_STOPDEBUGGING },
    { IDM_DEBUG_BREAK,              TBR_DEBUG_BREAK },
    { IDM_DEBUG_STEPINTO,           TBR_DEBUG_STEPINTO },
    { IDM_DEBUG_STEPOVER,           TBR_DEBUG_STEPOVER },
    { IDM_DEBUG_STEPOUT,            TBR_DEBUG_STEPOUT },
    { IDM_DEBUG_RUNTOCURSOR,        TBR_DEBUG_RUNTOCURSOR },
    { IDM_EDIT_TOGGLEBREAKPOINT,    TBR_EDIT_BREAKPOINTS },
    { IDM_VIEW_COMMAND,             TBR_VIEW_COMMAND },
    { IDM_VIEW_WATCH,               TBR_VIEW_WATCH },
    { IDM_VIEW_LOCALS,              TBR_VIEW_LOCALS },
    { IDM_VIEW_REGISTERS,           TBR_VIEW_REGISTERS },
    { IDM_VIEW_MEMORY,              TBR_VIEW_MEMORY },
    { IDM_VIEW_CALLSTACK,           TBR_VIEW_CALLSTACK },
    { IDM_VIEW_DISASM,              TBR_VIEW_DISASM },
    { IDM_VIEW_SCRATCH,             TBR_VIEW_SCRATCH },
    { IDM_DEBUG_SOURCE_MODE_ON,     TBR_DEBUG_SOURCE_MODE_ON },
    { IDM_DEBUG_SOURCE_MODE_OFF,    TBR_DEBUG_SOURCE_MODE_OFF },
    { IDM_EDIT_PROPERTIES,          TBR_EDIT_PROPERTIES },
    { IDM_VIEW_FONT,                TBR_VIEW_FONT },
    { IDM_VIEW_OPTIONS,             TBR_VIEW_OPTIONS },
    { IDM_WINDOW_ARRANGE,           TBR_WINDOW_ARRANGE },
};

#define NUM_TOOLBAR_BUTTONS (sizeof(g_TbButtons) / sizeof(TBBUTTON))
#define NUM_TOOLBAR_STRINGS (sizeof(g_TbStrMap) / sizeof(TB_STR_MAP))


PTSTR
GetToolTipTextFor_Toolbar(UINT uToolbarId)
/*++
Routine Description:
    Given the id of the toolbar button, we retrieve the
    corresponding tooltip text from the resources.

Arguments:
    uToolbarId - The command id for the toolbar button. This is the
        value contained in the WM_COMMAND msg.

Returns:
    Returns a pointer to a static buffer that contains the tooltip text.
--*/
{
    // Display tool tip text.
    static TCHAR sz[MAX_MSG_TXT];
    int nStrId = 0, i;
    
    // Get the str id given the cmd id
    for (i = 0; i < NUM_TOOLBAR_STRINGS; i++)
    {
        if (g_TbStrMap[i].uCmdId == uToolbarId)
        {
            nStrId = g_TbStrMap[i].nStrId;
            break;
        }
    }
    Assert(nStrId);
    
    // Now that we have the string id ....
    Dbg(LoadString(g_hInst, nStrId, sz, _tsizeof(sz) ));

    return sz;
}


BOOL
CreateToolbar(HWND hwndParent)
/*++
Routine Description:
    Creates the toolbar.

Arguments:
    hwndParent - The parent window of the toolbar.
--*/
{
    g_Toolbar = CreateToolbarEx(hwndParent,                 // parent
                                WS_CHILD | WS_BORDER 
                                | WS_VISIBLE 
                                | TBSTYLE_TOOLTIPS 
                                | TBSTYLE_WRAPABLE
                                | CCS_TOP,                  // style
                                ID_TOOLBAR,                 // toolbar id
                                NUM_BMPS_IN_TOOLBAR,        // number of bitmaps
                                g_hInst,                    // mod instance
                                IDB_BMP_TOOLBAR,            // resource id for the bitmap
                                g_TbButtons,                // address of buttons
                                NUM_TOOLBAR_BUTTONS,        // number of buttons
                                16,15,                      // width & height of the buttons
                                16,15,                      // width & height of the bitmaps
                                sizeof(TBBUTTON)            // structure size
                                );
    g_ShowToolbar = g_Toolbar != NULL;
    return g_Toolbar != NULL;
}


void
Show_Toolbar(BOOL bShow)
/*++
Routine Description:
    Shows/hides the toolbar.

Arguments:
    bShow - TRUE - Show the toolbar.
            FALSE - Hide the toolbar.

            Autmatically resizes the MDI Client
--*/
{
    RECT rect;
    
    // Show/Hide the toolbar
    g_ShowToolbar = bShow;
    ShowWindow(g_Toolbar, bShow ? SW_SHOW : SW_HIDE);
    
    //Ask the frame to resize, so that everything will be correctly positioned.
    GetWindowRect(g_hwndFrame, &rect);
    
    EnableToolbarControls();
    
    SendMessage(g_hwndFrame, 
                WM_SIZE, 
                SIZE_RESTORED,
                MAKELPARAM(rect.right - rect.left, rect.bottom - rect.top)
                );
    
    // Ask the MDIClient to redraw itself and its children.
    // This is  done in order to fix a redraw problem where some of the
    // MDIChild window are not correctly redrawn.
    RedrawWindow(g_hwndMDIClient, 
                 NULL, 
                 NULL, 
                 RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_FRAME
                 );
}                                       /* UpdateToolbar() */


HWND
GetHwnd_Toolbar()
{
    return g_Toolbar;
}




/***    EnableToolbarControls
**
**  Description:
**      Enables/disables the controls in the toolbar according
**      to the current state of the system.
**
*/

void
EnableToolbarControls()
{
    int i;

    for (i = 0; i < NUM_TOOLBAR_BUTTONS; i++)
    {
        // This will enable disable the toolbar
        if (g_TbButtons[i].idCommand)
        {
            CommandIdEnabled(g_TbButtons[i].idCommand);
        }
    }
}


void
ToolbarIdEnabled(
    IN UINT uMenuID,
    IN BOOL fEnabled
    )
/*++

Routine Description:

    Enables/disables a ToolBar item based.

Arguments:

    uMenuID - Supplies a menu id whose state is to be determined.
    
    fEnabled - enable or disable a toolbar item.

Return Value:

    None

--*/
{
    switch (uMenuID)
    {
    case IDM_FILE_OPEN:
    case IDM_EDIT_CUT:
    case IDM_EDIT_COPY:
    case IDM_EDIT_PASTE:
    case IDM_DEBUG_GO:
    case IDM_DEBUG_RESTART:
    case IDM_DEBUG_STOPDEBUGGING:
    case IDM_DEBUG_BREAK:
    case IDM_DEBUG_STEPINTO:
    case IDM_DEBUG_STEPOVER:
    case IDM_DEBUG_STEPOUT:
    case IDM_DEBUG_RUNTOCURSOR:
    case IDM_EDIT_TOGGLEBREAKPOINT:
    case IDM_VIEW_COMMAND:
    case IDM_VIEW_WATCH:
    case IDM_VIEW_LOCALS:
    case IDM_VIEW_REGISTERS:
    case IDM_VIEW_MEMORY:
    case IDM_VIEW_CALLSTACK:
    case IDM_VIEW_DISASM:
    case IDM_EDIT_PROPERTIES:
        // Nothing special to do here, except change the state
        SendMessage(GetHwnd_Toolbar(), 
                    TB_ENABLEBUTTON, 
                    uMenuID, 
                    MAKELONG(fEnabled, 0));
        break;

    case IDM_DEBUG_SOURCE_MODE_ON:
    case IDM_DEBUG_SOURCE_MODE_OFF:
        // Toggle the state between the two items
        SendMessage(GetHwnd_Toolbar(), 
                    TB_CHECKBUTTON,
                    IDM_DEBUG_SOURCE_MODE_ON, 
                    MAKELONG(GetSrcMode_StatusBar(), 0));
        SendMessage(GetHwnd_Toolbar(), 
                    TB_CHECKBUTTON,
                    IDM_DEBUG_SOURCE_MODE_OFF, 
                    MAKELONG(!GetSrcMode_StatusBar(), 0));
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\util.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    util.cpp

--*/


#include "precomp.hxx"
#pragma hdrstop

//Current Help Id for Open, Merge, Save and Open project dialog box
WORD g_CurHelpId;

// Number of dialog/message boxes currently open
int  g_nBoxCount;

BOOL g_fNoPopups;


HWND 
MDIGetActive(
    HWND    hwndParent,
    BOOL   *lpbMaximized
    )
/*++
Routine Description:

  Create the command window.

Arguments:

    hwndParent - The parent window to the command window. In an MDI document,
        this is usually the handle to the MDI client window: g_hwndMDIClient

Return Value:

    The return value is the handle to the active MDI child window.

    NULL if no MDI window has been created.

--*/
{
    Assert(IsWindow(hwndParent));
    return (HWND)SendMessage(hwndParent, 
                             WM_MDIGETACTIVE, 
                             0, 
                             (LPARAM)lpbMaximized
                             );
}


/***    hGetBoxParent
**
**  Synopsis:
**      hwnd = hGetBoxParent()
**
**  Entry:
**      none
**
**  Returns:
**
**  Description:
**      Gets a suitable parent window handle for an
**      invocation of a message or dialog box.
**      Helper function to util.c functions so declared
**      near.
**
*/

HWND
hGetBoxParent()
{
    HWND hCurWnd;
    int i = 0;

    hCurWnd = GetFocus();
    if (hCurWnd)
    {
        while (GetWindowLong(hCurWnd, GWL_STYLE) & WS_CHILD)
        {
            hCurWnd = GetParent(hCurWnd);
            Dbg((++i < 100));
        }
    }
    else
    {
        hCurWnd = g_hwndFrame;
    }

    return hCurWnd;
}

/****************************************************************************

        FUNCTION:   MsgBox

        PURPOSE:    General purpose message box routine which takes
                    a pointer to the message text.  Provides
                    program title as caption.

****************************************************************************/

int
MsgBox(
    HWND hwndParent,
    PTSTR szText,
    UINT wType
    )
/*++

Routine Description:

    Generial purpose message box routine which takes a pointer to a message
    text and prvoides the program title for the caption of the message box.

Arguments:

    hwndParament - Supplies the parent window handle for the message box
    szText      - Supplies a pointer to the message box text.
    wType       - Supplies the message box type (to specify buttons)

Return Value:

    Returns the message box return code

--*/

{
    int MsgBoxRet = IDOK;

    if (g_fNoPopups)
    {
        //
        // log the string to the command win in case testing
        // or when the remote server is running
        //
        CmdLogFmt (_T("%s\r\n"), szText);
    }
    else
    {
        // If windbg is minimized we need to restore
        // it so that the message box shows up.
        if (hwndParent == g_hwndFrame && IsIconic(hwndParent))
        {
            ShowWindow(hwndParent, SW_RESTORE);
        }
        
        g_nBoxCount++;
        MsgBoxRet = MessageBox(hwndParent, szText,
                               g_MainTitleText, wType);
        g_nBoxCount--;
    }

    return MsgBoxRet;
}                               /* MsgBox() */

/***    ErrorBox
**
**  Returns:
**      FALSE
**
**  Description:
**      Display an error message box with an "Error" title, an OK
**      button and a Exclamation Icon. First parameter is a
**      reference string in the ressource file.  The string
**      can contain printf formatting chars, the arguments
**      follow from the second parameter onwards.
**
*/

BOOL
ErrorBox(
    HWND hwnd,
    UINT type,
    int wErrorFormat,
    ...
    )
{
    TCHAR szErrorFormat[MAX_MSG_TXT];
    TCHAR szErrorText[MAX_VAR_MSG_TXT];  // size is as big as considered necessary
    va_list vargs;

    // load format string from resource file
    Dbg(LoadString(g_hInst, wErrorFormat, (PTSTR)szErrorFormat, MAX_MSG_TXT));

    va_start(vargs, wErrorFormat);
    _vstprintf(szErrorText, szErrorFormat, vargs);
    va_end(vargs);

    if (hwnd == NULL)
    {
        hwnd = g_hwndFrame;
    }

    if (type == 0)
    {
        type = MB_TASKMODAL;
    }

    MsgBox(g_hwndFrame, (PTSTR)szErrorText, type | MB_OK | MB_ICONINFORMATION);
    return FALSE;   //Keep it always FALSE please
}


/***    InformationBox
**
**  Description:
**      Display an information message box with an "Information"
**      title, an OK button and an Information Icon.
**
*/

void
InformationBox(
    WORD wDescript
    ...
    )
{
    TCHAR szFormat[MAX_MSG_TXT];
    TCHAR szText[MAX_VAR_MSG_TXT];       // size is as big as considered necessary
    va_list vargs;

    // load format string from resource file
    Dbg(LoadString(g_hInst, wDescript, (PTSTR)szFormat, MAX_MSG_TXT));

    // set up szText from passed parameters
    va_start(vargs, wDescript);
    _vstprintf(szText, szFormat, vargs);
    va_end(vargs);

    MsgBox(g_hwndFrame, (PTSTR)szText, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);

    return;
}

/***    QuestionBox
**
**  Synopsis:
**      int = QuestionBox(wCaptionId, wMsgFormat, wType, ...)
**
**  Entry:
**
**  Returns:
**      The result of the message box call
**
**  Description:
**      Display an query box with combination of YES, NO and
**      CANCEL buttons and a question mark Icon.
**      See ErrorBox for discussion.
**
*/

int
CDECL
QuestionBox(
    WORD wMsgFormat,
    UINT wType,
    ...
    )
{
    TCHAR szMsgFormat[MAX_MSG_TXT];
    TCHAR szMsgText[MAX_VAR_MSG_TXT];
    va_list vargs;

    //Load format string from resource file
    Dbg(LoadString(g_hInst, wMsgFormat, (PTSTR)szMsgFormat, MAX_MSG_TXT));

    //Set up szMsgText from passed parameters
    va_start(vargs, wType);
    _vstprintf(szMsgText, szMsgFormat, vargs);
    va_end(vargs);

    return MsgBox(g_hwndFrame, szMsgText,
        wType | MB_ICONEXCLAMATION | MB_TASKMODAL);
}                                       /* QuestionBox() */

/****************************************************************************

        FUNCTION:   QuestionBox2

        PURPOSE:    Display an query box with combination of YES, NO and
                                        CANCEL buttons and a question mark Icon. The type and
                                        the parent window are adjustable.

        RETURNS:                MessageBox result

****************************************************************************/
int
CDECL
QuestionBox2(
    HWND hwnd,
    WORD wMsgFormat,
    UINT wType,
    ...
    )
{
    TCHAR szMsgFormat[MAX_MSG_TXT];
    TCHAR szMsgText[MAX_VAR_MSG_TXT];
    va_list vargs;

    //Load format string from resource file
    Dbg(LoadString(g_hInst, wMsgFormat, (PTSTR)szMsgFormat, MAX_MSG_TXT));

    //Set up szMsgText from passed parameters
    va_start(vargs, wType);
    _vstprintf(szMsgText, szMsgFormat, vargs);
    va_end(vargs);

    return MsgBox(hwnd, szMsgText, wType | MB_ICONEXCLAMATION);
}                                       /* QuestionBox2() */


/***    ShowAssert
**
**  Synopsis:
**      void = ShowAssert(szCond, iLine, szFile)
**
**  Entry:
**      szCond  - tokenized form of the failed condition
**      iLine   - Line number for the assertion
**      szFile  - File for the assertion
**
**  Returns:
**      void
**
**  Description:
**      Prepare and display a Message Box with szCondition, iLine and
**      szFile as fields.
**
*/
void
ShowAssert(
    PTSTR condition,
    UINT line,
    PTSTR file
    )
{
    TCHAR text[MAX_VAR_MSG_TXT];

    //Build line, show assertion and exit program

    _stprintf(text, _T("- Line:%u, File:%Fs, Condition:%Fs"),
        (WPARAM) line, file, condition);

    PTSTR szAssertFile = _T("assert.wbg");
    HANDLE hFile = NULL;

    hFile = CreateFile(szAssertFile, 
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       CREATE_ALWAYS, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL
                       );
    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Write the text out to the file
        DWORD dwBytesWritten = 0;
        
        Assert(WriteFile(hFile, text, _tcslen(text), &dwBytesWritten, NULL));
        Assert(_tcslen(text) == dwBytesWritten);
        CloseHandle(hFile);
    }

    int Action =
        MessageBox(GetDesktopWindow(), text, "Assertion Failure",
                   MB_ABORTRETRYIGNORE);
    if (Action == IDABORT)
    {
        exit(3);
    }
    else if (Action == IDRETRY)
    {
        DebugBreak();
    }
}                                       // ShowAssert()


/***    StartDialog
**
**  Synopsis:
**      int = StartDialog(rcDlgNb, dlgProc, lParam)
**
**  Entry:
**      rcDlgNb - Resource number of dialog to be openned
**      dlgProc - Filter procedure for the dialog
**      lParam  - Data passed into the dlg proc via LPARAM
**
**  Returns:
**      Result of the dialog box call
**
**  Description:
**      Loads and execute the dialog box 'rcDlgNb' (resource
**      file string number) associated with the dialog
**      function 'dlgProc'
**
*/

int
StartDialog(
    int rcDlgNb,
    DLGPROC dlgProc,
    LPARAM lParam
    )
{
    LRESULT result;

    //
    //Execute Dialog Box
    //

    g_nBoxCount++;
    result = DialogBoxParam(g_hInst,
                            MAKEINTRESOURCE(rcDlgNb),
                            hGetBoxParent(),
                            dlgProc,
                            lParam
                            );
    Assert(result != (LRESULT)-1);
    g_nBoxCount--;

    return (int)result;
}


void
ProcessNonDlgMessage(LPMSG Msg)
{
#if 0
    {
        DebugPrint("NonDlg msg %X for %p, args %X %X\n",
                   Msg->message, Msg->hwnd, Msg->wParam, Msg->lParam);
    }
#endif
    
    // If a keyboard message is for the MDI , let the MDI client
    // take care of it.  Otherwise, check to see if it's a normal
    // accelerator key (like F3 = find next).  Otherwise, just handle
    // the message as usual.
    if (!TranslateMDISysAccel(g_hwndMDIClient, Msg) &&
        !TranslateAccelerator(g_hwndFrame, g_hMainAccTable, Msg))
    {
        //
        // If this is a right-button-down over a child window,
        // automatically activate the window's contex menu.
        //
        if (Msg->message == WM_RBUTTONDOWN &&
            IsChild(g_hwndMDIClient, Msg->hwnd))
        {
            HMENU Menu;
            PCOMMONWIN_DATA CmnWin;
            POINT ScreenPt;
            
            POINT Pt = {LOWORD(Msg->lParam), HIWORD(Msg->lParam)};
            ClientToScreen(Msg->hwnd, &Pt);
            ScreenPt = Pt;
            ScreenToClient(g_hwndMDIClient, &Pt);
            
            HWND Win = ChildWindowFromPointEx(g_hwndMDIClient, Pt,
                                              CWP_SKIPINVISIBLE);
            if (Win != NULL &&
                (CmnWin = GetCommonWinData(Win)) != NULL &&
                (Menu = CmnWin->GetContextMenu()) != NULL)
            {
                UINT Item = TrackPopupMenu(Menu, TPM_LEFTALIGN | TPM_TOPALIGN |
                                           TPM_NONOTIFY | TPM_RETURNCMD |
                                           TPM_RIGHTBUTTON,
                                           ScreenPt.x, ScreenPt.y,
                                           0, Msg->hwnd, NULL);
                if (Item)
                {
                    CmnWin->OnContextMenuSelection(Item);
                }
                return;
            }
        }
        
        TranslateMessage(Msg);
        DispatchMessage(Msg);
    }
}

void
ProcessPendingMessages(void)
{
    MSG Msg;
    
    // Process all available messages.
    while (PeekMessage(&Msg, NULL, 0, 0, PM_NOREMOVE))
    {
        if (!GetMessage(&Msg, NULL, 0, 0))
        {
            g_Exit = TRUE;
            break;
        }

        if (g_FindDialog == NULL ||
            !IsDialogMessage(g_FindDialog, &Msg))
        {
            ProcessNonDlgMessage(&Msg);
        }
    }
}


/****************************************************************************

    FUNCTION:   InfoBox

    PURPOSE:    Opens a Dialog box with a title and accepting
                a printf style for text. It's for DEBUGGING USE ONLY

****************************************************************************/
int
InfoBox(
        PTSTR text,
        ...
        )
{
    TCHAR buffer[MAX_MSG_TXT];
    va_list vargs;

    va_start(vargs, text);
    _vstprintf(buffer, text, vargs);
    va_end(vargs);
    return MsgBox(GetActiveWindow(), buffer, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);
}


void
ExitDebugger(PDEBUG_CLIENT Client, ULONG Code)
{
    if (Client != NULL)
    {
        if (g_RemoteClient)
        {
            // Disconnect from server.
            Client->EndSession(DEBUG_END_DISCONNECT);
        }
        else
        {
            Client->EndSession(DEBUG_END_PASSIVE);
            // Force servers to get cleaned up.
            Client->EndSession(DEBUG_END_REENTRANT);
        }
    }

    ExitProcess(Code);
}

// XXX drewb - Is this functionality present in other utilities?
// FatalErrorBox is close.  Probably can combine something here.
void
ErrorExit(PDEBUG_CLIENT Client, PCSTR Format, ...)
{
    char Message[1024];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Message, sizeof(Message), Format, Args);
    va_end(Args);

    // XXX drewb - Could put up message box.
    OutputDebugString(Message);

    ExitDebugger(Client, E_FAIL);
}

#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR strings[MAX_FORMAT_STRINGS][20];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if (g_Ptr64) {
        sprintf(string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    } else {
        sprintf(string, "%08x", (ULONG)addr);
    }
    return string;
}


static BOOL     FAddToSearchPath = FALSE;
static BOOL     FAddToRootMap = FALSE;

/*
**  AppendFilter
**
**  Description:
**      Append a filter to an existing filters string.
**
*/

BOOL
AppendFilter(
    WORD filterTextId,
    int filterExtId,
    PTSTR filterString,
    int *len,
    int maxLen
    )
{
    int size;
    TCHAR Tmp[MAX_MSG_TXT];

    //
    // Append filter text
    //

    Dbg(LoadString(g_hInst, filterTextId, Tmp, MAX_MSG_TXT));
    size = _tcslen(Tmp) + 1;
    if (*len + size > maxLen)
    {
        return FALSE;
    }
    memmove(filterString + *len, Tmp, size);
    *len += size;

    //
    // Append filter extension
    //

    Dbg(LoadString(g_hInst, filterExtId, Tmp, MAX_MSG_TXT));
    size = _tcslen(Tmp) + 1;
    if (*len + size > maxLen)
    {
        return FALSE;
    }
    memmove(filterString + *len, Tmp, size);
    *len += size;

    return TRUE;
}

/*
**  InitFilterString
**
**  Description:
**      Initialize file filters for file dialog boxes.
*/

void
InitFilterString(
    WORD titleId,
    PTSTR filter,
    int maxLen
    )
{
    int len = 0;

    switch (titleId)
    {
    case DLG_Browse_CrashDump_Title:
        AppendFilter(TYP_File_DUMP, DEF_Ext_DUMP, filter, &len, maxLen);
        break;

    case DLG_Browse_Executable_Title:
        AppendFilter(TYP_File_EXE, DEF_Ext_EXE, filter, &len, maxLen);
        break;

    case DLG_Browse_LogFile_Title:
        AppendFilter(TYP_File_LOG, DEF_Ext_LOG, filter, &len, maxLen);
        break;

    case DLG_Open_Filebox_Title:
    case DLG_Browse_Filebox_Title:
    case DLG_Browse_Source_Path_Title:
        AppendFilter(TYP_File_SOURCE, DEF_Ext_SOURCE, filter, &len, maxLen);
        AppendFilter(TYP_File_INCLUDE, DEF_Ext_INCLUDE, filter, &len, maxLen);
        AppendFilter(TYP_File_ASMSRC, DEF_Ext_ASMSRC, filter, &len, maxLen);
        AppendFilter(TYP_File_INC, DEF_Ext_INC, filter, &len, maxLen);
        AppendFilter(TYP_File_RC, DEF_Ext_RC, filter, &len, maxLen);
        AppendFilter(TYP_File_DLG, DEF_Ext_DLG, filter, &len, maxLen);
        AppendFilter(TYP_File_DEF, DEF_Ext_DEF, filter, &len, maxLen);
        AppendFilter(TYP_File_MAK, DEF_Ext_MAK, filter, &len, maxLen);
        break;

    case DLG_Browse_DbugDll_Title:
        AppendFilter(TYP_File_DLL, DEF_Ext_DLL, filter, &len, maxLen);
        break;

    case DLG_Browse_Symbol_Path_Title:
        AppendFilter(TYP_File_Symbols, DEF_Ext_Symbols, filter, &len, maxLen);
        AppendFilter(TYP_File_EXE, DEF_Ext_EXE, filter, &len, maxLen);
        AppendFilter(TYP_File_DLL, DEF_Ext_DLL, filter, &len, maxLen);
        break;
        
    case DLG_Browse_Image_Path_Title:
        AppendFilter(TYP_File_EXE, DEF_Ext_EXE, filter, &len, maxLen);
        AppendFilter(TYP_File_DLL, DEF_Ext_DLL, filter, &len, maxLen);
        break;
        
    case DLG_Write_Text_File_Title:
        AppendFilter(TYP_File_TXT, DEF_Ext_TXT, filter, &len, maxLen);
        break;

    case DLG_Open_Workspace_File_Title:
    case DLG_Save_Workspace_File_Title:
        AppendFilter(TYP_File_Workspace, DEF_Ext_Workspace,
                     filter, &len, maxLen);
        break;

    default:
        Assert(FALSE);
        break;
    }

    AppendFilter(TYP_File_ALL, DEF_Ext_ALL, filter, &len, maxLen);
    filter[len] = _T('\0');
}

BOOL
StartFileDlg(
    HWND hwnd,
    int titleId,
    int defExtId,
    int helpId,
    int templateId,
    PTSTR InitialDir,
    PTSTR fileName,
    DWORD* pFlags,
    LPOFNHOOKPROC lpfnHook
    )

/*++

Routine Description:

    This function is used by windbg to open the set of common file handling
    dialog boxes.

Arguments:

    hwnd        - Supplies the wnd to hook the dialog box to

    titleId     - Supplies the string resource of the title

    defExtId    - Supplies The default extension resource string

    helpId      - Supplies the help number for the dialog box

    templateId  - Supplies the dialog resource number if non-zero

    fileName    - Supplies the default file name

    pFiles      - Supplies a pointer to flags

    lpfnHook    - Supplies the address of a hook procedure for the dialog

Return Value:

    The result of the dialog box call (usually TRUE for OK and FALSE for
    cancel)

--*/

{
#define filtersMaxSize 350

    OPENFILENAME_NT4    OpenFileName = {0};
    TCHAR               title[MAX_MSG_TXT];
    TCHAR               defExt[MAX_MSG_TXT];
    BOOL                result;
    TCHAR               filters[filtersMaxSize];
    LPOFNHOOKPROC       lpDlgHook = NULL;
    HCURSOR             hSaveCursor;
    TCHAR               files[_MAX_PATH + 8];
    TCHAR               szExt[_MAX_EXT + 8];
    TCHAR               szBase[_MAX_PATH + 8];
    int                 indx;
    TCHAR               fname[_MAX_FNAME];
    TCHAR               ext[_MAX_EXT];
    PTSTR               LocalInitialDir = NULL;

    *pFlags |= (OFN_EXPLORER | OFN_NOCHANGEDIR);

    if (InitialDir == NULL || !InitialDir[0])
    {
        DWORD retval = GetCurrentDirectory(NULL, NULL);
        InitialDir = (PTSTR)calloc(retval, sizeof(TCHAR) );
        if (InitialDir == NULL)
        {
            return FALSE;
        }
        
        GetCurrentDirectory(retval, InitialDir);
        LocalInitialDir = InitialDir;
    }

    if (DLG_Browse_Filebox_Title == titleId)
    {
        _tsplitpath( fileName, NULL, NULL, fname, ext );
        _tmakepath( files, NULL, NULL, fname, ext );
    }
    else
    {
        _tcscpy(files, fileName);
    }

    //
    // Set the Hour glass cursor
    //

    hSaveCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    InitFilterString((WORD)titleId, (PTSTR)filters, (int)filtersMaxSize);
    Dbg(LoadString(g_hInst, titleId, (PTSTR)title, MAX_MSG_TXT));
    Dbg(LoadString(g_hInst, defExtId, (PTSTR)defExt, MAX_MSG_TXT));
    if (templateId)
    {
        //
        // Build dialog box Name
        //

        *pFlags |= OFN_ENABLETEMPLATE;
        OpenFileName.lpTemplateName = MAKEINTRESOURCE(templateId);
    }
    else
    {
        *pFlags |= OFN_EXPLORER;
    }

    //
    // Make instance for _T('dlgProc')
    //

    if (lpfnHook)
    {
        lpDlgHook = lpfnHook;

        *pFlags |= OFN_ENABLEHOOK;
    }

    g_CurHelpId = (WORD) helpId;
    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = hwnd;
    OpenFileName.hInstance = g_hInst;
    OpenFileName.lpstrFilter = (PTSTR)filters;
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = 1;
    OpenFileName.lpstrFile = files;
    OpenFileName.nMaxFile = _MAX_PATH;
    OpenFileName.lpstrFileTitle = NULL;
    OpenFileName.lpstrInitialDir = InitialDir;
    OpenFileName.lpstrTitle = (PTSTR)title;
    OpenFileName.Flags = *pFlags;
    OpenFileName.lpstrDefExt = (PTSTR)NULL;
    OpenFileName.lCustData = 0L;
    OpenFileName.lpfnHook = lpDlgHook;

    g_nBoxCount++;

    switch (titleId)
    {
    case DLG_Open_Filebox_Title:
        _tcscat(OpenFileName.lpstrFile, defExt);
        // fall thru
    case DLG_Browse_Executable_Title:
    case DLG_Browse_CrashDump_Title:
    case DLG_Browse_Symbol_Path_Title:
    case DLG_Browse_Source_Path_Title:
    case DLG_Browse_Image_Path_Title:
    case DLG_Open_Workspace_File_Title:
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName);
        break;

    case DLG_Browse_LogFile_Title:
        if (fileName)
        {
            _tcscpy(OpenFileName.lpstrFile, fileName);
        }
        else
        {
            *OpenFileName.lpstrFile = 0;
        }
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName);
        break;

    case DLG_Browse_DbugDll_Title:
        *(OpenFileName.lpstrFile) = _T('\0');
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName);
        break;

    case DLG_Browse_Filebox_Title:
        _tsplitpath (files, (PTSTR)NULL, (PTSTR)NULL, (PTSTR)szBase, szExt);
        indx = matchExt (szExt, filters);

        if (indx != -1)
        {
            OpenFileName.nFilterIndex = indx;
        }

        _tcscat(title, szBase);
        if (*szExt)
        {
            _tcscat(title, szExt);
        }

        FAddToSearchPath = FALSE;
        FAddToRootMap = FALSE;

        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName);

        //
        // Check to see if the use said to add a file to the browse path.
        //     If so then add it to the front of the path
        //

        /*if (FAddToSearchPath)
        {
            AddToSearchPath(OpenFileName.lpstrFile);
        }
        else if (FAddToRootMap)
        {
            RootSetMapped(fileName, OpenFileName.lpstrFile);
        }*/
        break;

    case DLG_Write_Text_File_Title:
    case DLG_Save_Workspace_File_Title:
        OpenFileName.lpstrDefExt = defExt;
        *(OpenFileName.lpstrFile) = _T('\0');
        _tcscat(OpenFileName.lpstrFile, defExt);
        result = GetSaveFileName((LPOPENFILENAME)&OpenFileName);
        break;
        
    default:
        Assert(FALSE);
        free(LocalInitialDir);
        return FALSE;
    }

    g_nBoxCount--;

    if (result && titleId == DLG_Open_Filebox_Title)
    {
        KNOWN_EXT ExtType = RecognizeExtension(OpenFileName.lpstrFile);
        if (ExtType != KNOWN_EXT_COUNT)
        {
            if (QuestionBox(STR_May_Not_Be_Source, MB_YESNO) != IDYES)
            {
                result = 0;
            }
        }
    }
    
    if (result)
    {
        _tcscpy(fileName, OpenFileName.lpstrFile);
        switch(titleId)
        {
        case DLG_Open_Filebox_Title:
            AddFileToMru(FILE_USE_SOURCE, fileName);
            break;
        case DLG_Browse_Symbol_Path_Title:
        case DLG_Browse_Source_Path_Title:
        case DLG_Browse_Image_Path_Title:
            // Return only the path.
            if (OpenFileName.nFileOffset > 0)
            {
                fileName[OpenFileName.nFileOffset - 1] = 0;
            }
            break;
        }

        //
        // Get the output of flags
        //

        *pFlags = OpenFileName.Flags;
    }

    //
    //Restore cursor
    //

    SetCursor(hSaveCursor);

    free(LocalInitialDir);
    return result;
}                                       /* StartFileDlg() */

/***    matchExt
**
**  Synopsis:
**      int = matchExt (queryExtension, sourceList)
**
**  Entry:
**
**  Returns: 1-based index of pairwise substring for which the second
**           element (i.e., the extension list), contains the target
**           extension.  If there is no match, we return -1.
**
**  Description:
**      Searches extension lists for the Open/Save/Browse common
**      dialogs to try to match a filter to the input filename's
**      extension.
**      (Open File, Save File, Merge File and Open Project)
**
**  Implementation note:  Our thinking looks like this:
**
**     We are given a sequence of null-terminated strings which
**     are text/extension pairs.  We return the pairwise 1-based
**     index of the first pair for which the second element has an
**     exact match for the target extension.  (Everything, by the
**     way, is compared without case sensitivity.)  We picture the
**     source sequence, then, to be an array whose elements are pairs
**     of strings (we will call the pairs 'left' and 'right').
**
**     Just to complicate things, we allow the '.right' pair elements to
**     be strings like "*.c;*.cpp;*.cxx", where we our query might be
**     any one of the three (minus the leading asterisk).  Fortunately,
**     _tcstok() will break things apart for us (see the 'delims[]' array
**     in the code for the delimiters we have chosen).
**
**     Assuming there is a match in there somewhere, our invariant
**     for locating the first one will be:
**
**     Exists(k):
**                   ForAll(i) : 0 <= i < k
**                             : queryExtension \not IS_IN source[i].right
**               \and
**                   queryExtension IS_IN source[k].right
**
**     where we define IS_IN to be a membership predicate (using _tcstok()
**     and _tcsicmp() in the implementation, eh?):
**
**        x IS_IN y
**     <=>
**        Exists (t:token) : (t \in y) \and (x == t).
**
**     The guard for our main loop, then, comes from the search for the
**     queryExtension within the tokens inside successive '.right' elements.
**     We choose to continue as long as there is no current token in the
**     pair's right side that contains the query.
**
**     (We have the pragmatic concern that the value may not be there, so we
**     augment the loop guard with the condition that we have not yet
**     exhausted the source.  This is straightforward to add to the
**     invariant, but it causes a lot of clutter that does help our
**     comprehension at all, so we just stick it in the guard without
**     formal justification.)
*/

int 
matchExt(
    PTSTR queryExtension, 
    PTSTR sourceList
    )
{
    int   answer;
    int   idxPair    = 1;        // a 1-based index!
    PTSTR tokenMatch = 0;

    TCHAR  delims[]   = _T("*,; ") ;  // Given a typical string: "*.c;*.cpp;*.cxx",
    // _tcstok() would produce three tokens:
    // ".c", ".cpp", and ".cxx".

    while (*sourceList != 0  &&  tokenMatch == 0)
    {
        while (*sourceList != _T('\0'))
        { sourceList++; }          // skip first string of pair
        sourceList++;                 // and increment beyond NULL

        if (*sourceList != _T('\0'))
        {
            PTSTR work = _tcsdup (sourceList);  // copy to poke holes in

            tokenMatch = _tcstok (work, delims);

            while (tokenMatch  &&  _tcsicmp (tokenMatch, queryExtension))
            {
                tokenMatch = _tcstok (0, delims);
            }

            free (work);
        }

        if (tokenMatch == 0)             // no match:  need to move to next pair
        {
            while (*sourceList != _T('\0'))
            { sourceList++; }          // skip second string of pair
            sourceList++;                 // and increment beyond NULL

            idxPair++;
        }
    }

    answer = (tokenMatch != 0) ? idxPair : (-1);

    return (answer);
}





/***    DlgFile
**
**  Synopsis:
**      bool = DlgFile(hDlg, message, wParam, lParam)
**
**  Entry:
**
**  Returns:
**
**  Description:
**      Processes messages for file dialog boxes
**      Those dialogs are not called directly but are called
**      by the DlgFile function which contains all basic
**      elements for Dialogs Files Operations Handling.
**      (Open File, Save File, Merge File and Open Project)
**
**      See OFNHookProc
*/

UINT_PTR
APIENTRY
DlgFile(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

{
    switch (uMsg)
    {
    case WM_NOTIFY:
        {
            LPOFNOTIFY lpon = (LPOFNOTIFY) lParam;

            //
            // Determine what happened/why we are being notified
            //
            switch (lpon->hdr.code)
            {
            case CDN_HELP:
                // Help button pushed
                Dbg(HtmlHelp(hDlg,g_HelpFileName, HH_HELP_CONTEXT,
                             g_CurHelpId));
                break;
            }
        }
        break;
    }
    return FALSE;
}                                       /* DlgFile() */


UINT_PTR
APIENTRY
GetOpenFileNameHookProc(
                        HWND    hDlg,
                        UINT    msg,
                        WPARAM  wParam,
                        LPARAM  lParam
                        )

/*++

Routine Description:

    This routine is handle the Add Directory To radio buttons in the
    browser source file dialog box.

Arguments:

    hDlg        - Supplies the handle to current dialog
    msg         - Supplies the message to be processed
    wParam      - Supplies info about the message
    lParam      - Supplies info about the message

Return Value:

    TRUE if we replaced default processing of the message, FALSE otherwise

--*/
{
    /*

    switch( msg ) {
    case  WM_INITDIALOG:
        return TRUE;

    case WM_NOTIFY:
        {
            LPOFNOTIFY lpon = (LPOFNOTIFY) lParam;

            switch(lpon->hdr.code) {
            case CDN_FILEOK:
                FAddToSearchPath = (IsDlgButtonChecked( hDlg, IDC_CHECK_ADD_SRC_ROOT_MAPPING) == BST_CHECKED);
                return 0;
            }
        }
    }
    return DlgFile(hDlg, msg, wParam, lParam);
    */
    return 0;
}                               /* GetOpenFileNameHookProc() */


void
Internal_Activate(
    HWND hwndPrev,
    HWND hwndCur,
    HWND hwndNew,
    int nPosition
    )
/*++

Routine Description:

    Places a window in the specified Z order position.

Arguments:

    hwndPrev - Window prior to hwndCur.  Can be NULL.
    
    hwndCur - Currently active window, topmost in Z order. Can be NULL.

    hwndNew - The window to be placed in the new Z order.

    nPosition - Where the window is to be place in the Z order.
        1 - topmost
        2 - 2nd place (behind topmost)
        3 - 3rd place, etc....

Return Value: 

    None

--*/
{
    // Sanity check. Make sure the programmer
    // specified a 1, 2, or 3. We are strict in order to
    // keep it readable.
    Assert(1 <= nPosition && nPosition <= 3);
    Assert(hwndNew);

    switch (nPosition)
    {
    case 1:
        // Make it topmost
        SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        break;

    case 2:
        // Try to place it 2nd in Z order
        if (NULL == hwndCur)
        {
            // We don't have a topmost window,
            // so make this one the topmost window
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        }
        else
        {
            // Place it in 2nd
            SetWindowPos(hwndNew, hwndCur, 0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            // Give the topmost most focus again and activate UI visual clues.
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndCur, 0);
        }
        break;

    case 3:
        // Try to place it 3rd in Z order
        if (NULL == hwndCur)
        {
            // We don't have a topmost window,
            // so make this one the topmost window
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        }
        else
        {
            // Is there a window 2nd in the Z order?
            if (NULL == hwndPrev)
            {
                // No window 2nd in Z order. Then simply place it after the
                // topmost window.
                hwndPrev = hwndCur;
            }

            // Place it
            SetWindowPos(hwndNew, hwndPrev, 0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            // Give the topmost most focus again and activate UI visual clues.
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndCur, 0);
        }
        break;

    default:
        // Sanity check, the programmer missed a case
        Assert(0);
    }
}

void
ReorderChildren(
    HWND hwndPrev,
    HWND hwndCur,
    HWND hwndNew,
    BOOL bUserActivated
    )
{
    PCOMMONWIN_DATA pCur_WinData = NULL;
    PCOMMONWIN_DATA pNew_WinData = NULL;
    PCOMMONWIN_DATA pPrev_WinData = NULL;

    if (hwndCur)
    {
        pCur_WinData = GetCommonWinData(hwndCur);
    }

    pNew_WinData = GetCommonWinData(hwndNew);
    Assert(pNew_WinData);
    if (!pNew_WinData)
    {
        return;
    }

    if (hwndPrev)
    {
        pPrev_WinData = GetCommonWinData(hwndPrev);
    }

    //
    // Handle the case where the window activation
    // was requested by the debugger itself and not the
    // user.
    //

    switch (pNew_WinData->m_enumType)
    {
    default:
        Internal_Activate(hwndPrev, hwndCur, hwndNew, bUserActivated ? 2 : 1);
        break;

    case DISASM_WINDOW:
    case DOC_WINDOW:
        if (GetSrcMode_StatusBar())
        {
            // Src mode

            if (pCur_WinData != NULL &&
                (DISASM_WINDOW == pCur_WinData->m_enumType ||
                 DOC_WINDOW == pCur_WinData->m_enumType))
            {
                // We can take the place of another doc/asm wind
                // Place 1st in z-order
                Internal_Activate(hwndPrev, hwndCur, hwndNew, 1);
            }
            else
            {
                if (pPrev_WinData != NULL &&
                    (DOC_WINDOW == pPrev_WinData->m_enumType ||
                     DISASM_WINDOW == pPrev_WinData->m_enumType))
                {
                    // Don't have a window in 2nd place, or if we do it
                    // is a src or asm window, and we can hide it.
                    // Place 2nd in Z-order
                    Internal_Activate(hwndPrev, hwndCur, hwndNew, 2);
                }
                else
                {
                    // Place 3rd in Z-order
                    Internal_Activate(hwndPrev, hwndCur, hwndNew, 3);
                }
            }
        }
        else
        {
            WIN_TYPES Type = pCur_WinData != NULL ?
                pCur_WinData->m_enumType : MINVAL_WINDOW;
            
            // Asm mode

            // Which is currently the topmost window.
            switch (Type)
            {
            case DOC_WINDOW:
                // Place 1st in z-order
                Internal_Activate(hwndPrev, hwndCur, hwndNew, 1);
                break;

            case DISASM_WINDOW:
                if (DOC_WINDOW == pNew_WinData->m_enumType)
                {
                    if (pPrev_WinData == NULL ||
                        DOC_WINDOW != pPrev_WinData->m_enumType)
                    {
                        // We have a window in second place that isn't a doc
                        // window (locals, watch, ...).
                        Internal_Activate(hwndPrev, hwndCur, hwndNew, 3);
                    }
                    else
                    {
                        // Either don't have any windows in second place, or
                        // we have a window in second place that is a doc
                        // window. We can take its place.
                        //
                        // Place 2nd in z-order
                        Internal_Activate(hwndPrev, hwndCur, hwndNew, 2);
                    }
                }
                else
                {
                    // Should never happen. The case of disasm being activated
                    // when it is currently active should ahve already been
                    // taken care of.
                    Dbg(0);
                }
                break;

            default:
                if ((pPrev_WinData != NULL &&
                     DISASM_WINDOW == pPrev_WinData->m_enumType) &&
                    DOC_WINDOW == pNew_WinData->m_enumType)
                {
                    // window (locals, watch, ...).
                    Internal_Activate(hwndPrev, hwndCur, hwndNew, 3);
                }
                else
                {
                    // Place 2nd in z-order
                    Internal_Activate(hwndPrev, hwndCur, hwndNew, 2);
                }
                break;
            }
        }
        break;
    }
}

void
ActivateMDIChild(
    HWND hwndNew,
    BOOL bUserActivated
    )
/*++
Routine Description:
    Used to activate a specified window. Automatically uses the hwndActive
    variable to determine the currently active window.

Arguments:
    hwndNew - The window to be placed in the new Z order.
    bUserActivated - Indicates whether this action was initiated by the
                user or by windbg. The value is to determine the Z order of
                any windows that are opened.
--*/
{
    if (hwndNew == NULL)
    {
        Assert(hwndNew);
        return;
    }

    HWND hwndPrev = NULL;

    HWND hwndCur = MDIGetActive(g_hwndMDIClient, NULL);

    if (!hwndCur || bUserActivated || hwndCur == hwndNew)
    {
        // Nothing else was open. So we make this one the
        // topmost window.
        //
        // Or the user requested that this window be made
        // the topmost window, and we obey.
        //
        // Or we are re-activating the current window.
        Internal_Activate(NULL, hwndCur, hwndNew, 1);
        return;
    }

    // See is we have 3 or more windows open
    hwndPrev = GetNextWindow(hwndCur, GW_HWNDNEXT);

    ReorderChildren(hwndPrev, hwndCur, hwndNew, bUserActivated);
}


void
AppendTextToAnEditControl(
    HWND hwnd,
    PTSTR pszNewText
    )
{
    Assert(hwnd);
    Assert(pszNewText);

    CHARRANGE chrrgCurrent = {0};
    CHARRANGE chrrgAppend = {0};

    // Get the current selection
    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM) &chrrgCurrent);

    // Set the selection to the very end of the edit control
    chrrgAppend.cpMin = chrrgAppend.cpMax = GetWindowTextLength(hwnd);
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM) &chrrgCurrent);
    // Append the text
    SendMessage(hwnd, EM_REPLACESEL, FALSE, (LPARAM) pszNewText);

    // Restore previous selection
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM) &chrrgCurrent);
}


VOID
CopyToClipboard(
    PSTR str,
    BOOL ExpandLf
    )
{
    if (!str)
    {
        return;
    }

    ULONG Len = strlen(str) + 1;

    if (ExpandLf)
    {
        // Rather than bother to count the actual number
        // of linefeeds that need to be expanded, just
        // allocate twice as much memory as necessary.  There's
        // only one thing on the clipboard at a time and
        // the things copied here are relatively small so this
        // isn't a problem.
        Len *= 2;
    }
    
    HANDLE Mem = GlobalAlloc(GMEM_MOVEABLE, Len);
    if (Mem == NULL)
    {
        return;
    }

    PSTR Text = (PSTR)GlobalLock(Mem);
    if (Text == NULL)
    {
        GlobalFree(Mem);
        return;
    }

    if (ExpandLf)
    {
        PSTR Rd, Wr;

        Rd = str;
        Wr = Text;
        while (*Rd)
        {
            if (*Rd == '\n')
            {
                *Wr++ = '\r';
            }
            *Wr++ = *Rd++;
        }
        *Wr = 0;
    }
    else
    {
        strcpy(Text, str);
    }

    GlobalUnlock(Mem);

    if (OpenClipboard(NULL))
    {
        EmptyClipboard();
        if (SetClipboardData(CF_TEXT, Mem) == NULL)
        {
            GlobalFree(Mem);
        }

        CloseClipboard();
    }
}

void
SetAllocString(PSTR* Str, PSTR New)
{
    if (*Str != NULL)
    {
        free(*Str);
    }
    *Str = New;
}

BOOL
DupAllocString(PSTR* Str, PSTR New)
{
    PSTR NewStr = (PSTR)malloc(strlen(New) + 1);
    if (NewStr == NULL)
    {
        return FALSE;
    }

    strcpy(NewStr, New);
    SetAllocString(Str, NewStr);
    return TRUE;
}

BOOL
PrintAllocString(PSTR* Str, int Len, PCSTR Format, ...)
{
    PSTR NewStr = (PSTR)malloc(Len);
    if (NewStr == NULL)
    {
        return FALSE;
    }
    
    va_list Args;

    va_start(Args, Format);
    if (_vsnprintf(NewStr, Len, Format, Args) < 1)
    {
        NewStr[Len - 1] = 0;
    }
    va_end(Args);

    SetAllocString(Str, NewStr);
    return TRUE;
}

HMENU
CreateContextMenuFromToolbarButtons(ULONG NumButtons,
                                    TBBUTTON* Buttons,
                                    ULONG IdBias)
{
    ULONG i;
    HMENU Menu;

    Menu = CreatePopupMenu();
    if (Menu == NULL)
    {
        return Menu;
    }

    for (i = 0; i < NumButtons; i++)
    {
        MENUITEMINFO Item;

        ZeroMemory(&Item, sizeof(Item));
        Item.cbSize = sizeof(Item);
        Item.fMask = MIIM_TYPE;
        if (Buttons->fsStyle & BTNS_SEP)
        {
            Item.fType = MFT_SEPARATOR;
        }
        else
        {
            Item.fMask |= MIIM_ID;
            Item.fType = MFT_STRING;
            Item.wID = (WORD)(Buttons->idCommand + IdBias);
            Item.dwTypeData = (LPSTR)Buttons->iString;
        }
        
        if (!InsertMenuItem(Menu, i, TRUE, &Item))
        {
            DestroyMenu(Menu);
            return NULL;
        }

        Buttons++;
    }

    DrawMenuBar(g_hwndFrame);
    return Menu;
}

HWND
AddButtonBand(HWND Bar, PTSTR Text, PTSTR SizingText, UINT Id)
{
    HWND Button;
    HDC Dc;
    RECT Rect;
    
    Button = CreateWindowEx(0, "BUTTON", Text, WS_VISIBLE | WS_CHILD,
                            0, 0, 0, 0,
                            Bar, (HMENU)(UINT_PTR)Id, g_hInst, NULL);
    if (Button == NULL)
    {
        return NULL;
    }

    Rect.left = 0;
    Rect.top = 0;
        
    SendMessage(Button, WM_SETFONT, (WPARAM)g_Fonts[FONT_VARIABLE].Font, 0);
    Dc = GetDC(Button);
    if (Dc != NULL)
    {
        SIZE Size;
        
        GetTextExtentPoint32(Dc, SizingText, strlen(SizingText), &Size);
        Rect.right = Size.cx;
        Rect.bottom = Size.cy;
        ReleaseDC(Button, Dc);
    }
    else
    {
        Rect.right = strlen(Text) * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
        Rect.bottom = g_Fonts[FONT_FIXED].Metrics.tmHeight;
    }

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_STYLE | RBBIM_CHILD | RBBIM_CHILDSIZE;
    BandInfo.fStyle = RBBS_FIXEDSIZE;
    BandInfo.hwndChild = Button;
    BandInfo.cxMinChild = Rect.right - Rect.left +
        4 * GetSystemMetrics(SM_CXEDGE);
    BandInfo.cyMinChild = Rect.bottom - Rect.top +
        2 * GetSystemMetrics(SM_CYEDGE);
    SendMessage(Bar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    return Button;
}

KNOWN_EXT
RecognizeExtension(PTSTR Path)
{
    PSTR Scan;

    //
    // Find the extension.
    //
    
    Scan = Path + strlen(Path);
    for (;;)
    {
        if (Scan == Path)
        {
            return KNOWN_EXT_COUNT;
        }

        if (*--Scan == '.')
        {
            Scan++;
            break;
        }
    }

    if (!_stricmp(Scan, "dmp") ||
        !_stricmp(Scan, "mdmp"))
    {
        return EXT_DUMP;
    }
    else if (!_stricmp(Scan, "exe"))
    {
        return EXT_EXE;
    }

    return KNOWN_EXT_COUNT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\util.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    util.h

--*/

/****************************************************************************

    PROTOTYPES DECLARATION FOR UTIL MODULE

****************************************************************************/

#define InternalError(Code, Location) \
    InformationBox(ERR_Internal_Error, FormatStatusCode(Code), \
                   Location, FormatStatus(Code))

//Current Help Id for Open, Merge, Save and Open project dialog box
extern WORD g_CurHelpId;

// Number of dialog/message boxes currently open
extern int g_nBoxCount;

// Opens a standard error Dialog Box (Parent is hwnd)

BOOL ErrorBox(HWND hwnd, UINT type, int wErrorFormat, ...);
void InformationBox(WORD wDescript, ...);

// Opens a message box with the QCWin title
int MsgBox(HWND hwndParent, PTSTR szText, UINT wType);


// Loads and execute dialog box 'rcDlgNb' with 'dlgProc' function
int StartDialog(int rcDlgNb, DLGPROC dlgProc, LPARAM);


// Loads a resource string from resource file
void LoadResourceString(
    WORD wStrId,
    PTSTR lpszStrBuffer);

//Opens a standard question box containing combination
//of : Yes, No, Cancel
int CDECL QuestionBox(
    WORD wMsgFormat,
    UINT wType,
    ...);

//Opens a standard question box containing combination
//of : Yes, No, Cancel
int CDECL QuestionBox2(HWND hwnd, WORD wMsgFormat, UINT wType, ...);


// Drain the thread message queue.
void ProcessPendingMessages(void);


//Initialize files filters for dialog boxes using commonfile DLL
void InitFilterString(WORD id, PTSTR filter, int maxLen);


//Check if keyboard hit is NUMLOCK, CAPSLOCK or INSERT
LRESULT KeyboardHook( int iCode, WPARAM wParam, LPARAM lParam );




//Opens a Dialog box with a title and accepting a printf style for text
int InfoBox(
    PTSTR text,
    ...);



UINT_PTR
APIENTRY
DlgFile(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL StartFileDlg(HWND hwnd, int titleId, int defExtId,
                  int helpId, int templateId,
                  PTSTR InitialDir, PTSTR fileName,
                  DWORD *pFlags, LPOFNHOOKPROC lpfnHook);

void DECLSPEC_NORETURN ExitDebugger(PDEBUG_CLIENT Client, ULONG Code);
void DECLSPEC_NORETURN ErrorExit(PDEBUG_CLIENT Client, PCSTR Format, ...);

HWND 
MDIGetActive(
    HWND    hwndParent,
    BOOL   *lpbMaximized
    );

LPSTR
FormatAddr64(
    ULONG64 addr
    );

int matchExt (PTSTR pTargExt, PTSTR pSrcList);

void ReorderChildren(
    HWND hwndPrev,
    HWND hwndCur,
    HWND hwndNew,
    BOOL bUserActivated);

void ActivateMDIChild(
    HWND hwndNew,
    BOOL bUserActivated);

void SetProgramArguments(
    PTSTR lpszTmp);

void
AppendTextToAnEditControl(
    HWND hwnd,
    PTSTR pszNewText);

VOID
CopyToClipboard(
    PSTR str,
    BOOL ExpandLf);

void SetAllocString(PSTR* Str, PSTR New);
BOOL DupAllocString(PSTR* Str, PSTR New);
BOOL PrintAllocString(PSTR* Str, int Len, PCSTR Format, ...);

HMENU CreateContextMenuFromToolbarButtons(ULONG NumButtons,
                                          TBBUTTON* Buttons,
                                          ULONG IdBias);

HWND AddButtonBand(HWND Bar, PTSTR Text, PTSTR SizingText, UINT Id);

enum KNOWN_EXT
{
    EXT_DUMP,
    EXT_EXE,

    KNOWN_EXT_COUNT
};

KNOWN_EXT RecognizeExtension(PTSTR Path);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\wrkspace.h ===
//----------------------------------------------------------------------------
//
// Workspace support.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __WRKSPACE_H__
#define __WRKSPACE_H__

//----------------------------------------------------------------------------
//
// A workspace tag is a two-deep tag hierarchy.  The group portion
// of the tag allows related items to be collected into a single group.
//
//----------------------------------------------------------------------------

typedef ULONG WSP_TAG;

// Sixteen bits for the group.
#define WSP_GROUP_MASK  0xffff0000
#define WSP_GROUP_SHIFT 16
#define WSP_GROUP_BITS  16
// Sixteen bits for the item.
#define WSP_ITEM_MASK   0x0000ffff
#define WSP_ITEM_SHIFT  0
#define WSP_ITEM_BITS   16

#define WSP_TAG_MASK (WSP_GROUP_MASK | WSP_ITEM_MASK)

#define DEF_WSP_GROUP_TAG(Tag, Group) \
    ((Group) << WSP_GROUP_SHIFT)
#define ADD_WSP_ITEM_TAG(Tag, Item) \
    ((Tag) | (Item))
    
#define DEF_WSP_TAG(Group, Item) \
    (((Group) << WSP_GROUP_SHIFT) | (Item))

#define WSP_TAG_GROUP(Tag) \
    (((Tag) & WSP_GROUP_MASK) >> WSP_GROUP_SHIFT)

#define WSP_TAG_ITEM(Tag) \
    (((Tag) & WSP_ITEM_MASK) >> WSP_ITEM_SHIFT)

// Groups.
enum
{
    WSP_GROUP_GLOBAL,
    WSP_GROUP_WINDOW,
    WSP_GROUP_COLORS,
};

// Global group items.
enum
{
    WSP_ITEM_SYMBOL_PATH,
    WSP_ITEM_IMAGE_PATH,
    WSP_ITEM_SOURCE_PATH,
    WSP_ITEM_WINDOW_OPTIONS,
    WSP_ITEM_REGISTER_MAP,
    WSP_ITEM_BREAKPOINTS,
    WSP_ITEM_LOG_FILE,
    WSP_ITEM_LOCAL_SOURCE_PATH,
    WSP_ITEM_FILTERS,
    WSP_ITEM_FIXED_LOGFONT,
    WSP_ITEM_TAB_WIDTH,
    WSP_ITEM_MRU_LIST,
    WSP_ITEM_REPEAT_COMMANDS,
    WSP_ITEM_COM_SETTINGS,
    WSP_ITEM_1394_SETTINGS,
    WSP_ITEM_DISASM_ACTIVATE_SOURCE,
    WSP_ITEM_VIEW_TOOL_BAR,
    WSP_ITEM_VIEW_STATUS_BAR,
    WSP_ITEM_AUTO_CMD_SCROLL,
    WSP_ITEM_SRC_FILE_PATH,
    WSP_ITEM_EXE_COMMAND_LINE,
    WSP_ITEM_EXE_CREATE_FLAGS,
    WSP_ITEM_DUMP_FILE_NAME,
    WSP_ITEM_ATTACH_KERNEL_FLAGS,
    WSP_ITEM_TYPE_OPTIONS,
    WSP_ITEM_DUMP_FILE_PATH,
    WSP_ITEM_EXE_FILE_PATH,
    WSP_ITEM_PROC_REGISTER_MAP,
    WSP_ITEM_ASSEMBLY_OPTIONS,
    WSP_ITEM_EXPRESSION_SYNTAX,
    WSP_ITEM_ALIASES,
    WSP_ITEM_PROCESS_START_DIR,
    WSP_ITEM_PROC_FLAGS_REGISTER_MAP,
    WSP_GLOBAL_COUNT
};

// Window group items.
// The commonwin items exist largely to allow versioning of the window
// information blob.  The actual content is determined
// by the implementation of COMMONWIN_DATA::SetWorkspace.
enum
{
    WSP_ITEM_COMMONWIN_1,
    WSP_ITEM_FRAME_PLACEMENT,
    WSP_ITEM_FRAME_TITLE,
    WSP_WINDOW_COUNT
};

// Color group items use the color index as the item value.

//
// Specific tags.
//

#define WSP_GLOBAL_SYMBOL_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SYMBOL_PATH)
#define WSP_GLOBAL_IMAGE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_IMAGE_PATH)
#define WSP_GLOBAL_SOURCE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SOURCE_PATH)
#define WSP_GLOBAL_WINDOW_OPTIONS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_WINDOW_OPTIONS)
#define WSP_GLOBAL_REGISTER_MAP \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_REGISTER_MAP)
#define WSP_GLOBAL_BREAKPOINTS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_BREAKPOINTS)
#define WSP_GLOBAL_LOG_FILE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_LOG_FILE)
#define WSP_GLOBAL_LOCAL_SOURCE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_LOCAL_SOURCE_PATH)
#define WSP_GLOBAL_FILTERS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_FILTERS)
#define WSP_GLOBAL_FIXED_LOGFONT \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_FIXED_LOGFONT)
#define WSP_GLOBAL_TAB_WIDTH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_TAB_WIDTH)
#define WSP_GLOBAL_MRU_LIST \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_MRU_LIST)
#define WSP_GLOBAL_REPEAT_COMMANDS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_REPEAT_COMMANDS)
#define WSP_GLOBAL_COM_SETTINGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_COM_SETTINGS)
#define WSP_GLOBAL_1394_SETTINGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_1394_SETTINGS)
#define WSP_GLOBAL_DISASM_ACTIVATE_SOURCE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DISASM_ACTIVATE_SOURCE)
#define WSP_GLOBAL_VIEW_TOOL_BAR \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_VIEW_TOOL_BAR)
#define WSP_GLOBAL_VIEW_STATUS_BAR \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_VIEW_STATUS_BAR)
#define WSP_GLOBAL_AUTO_CMD_SCROLL \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_AUTO_CMD_SCROLL)
#define WSP_GLOBAL_SRC_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SRC_FILE_PATH)
#define WSP_GLOBAL_EXE_COMMAND_LINE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_COMMAND_LINE)
#define WSP_GLOBAL_EXE_CREATE_FLAGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_CREATE_FLAGS)
#define WSP_GLOBAL_DUMP_FILE_NAME \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DUMP_FILE_NAME)
#define WSP_GLOBAL_ATTACH_KERNEL_FLAGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_ATTACH_KERNEL_FLAGS)
#define WSP_GLOBAL_TYPE_OPTIONS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_TYPE_OPTIONS)
#define WSP_GLOBAL_DUMP_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DUMP_FILE_PATH)
#define WSP_GLOBAL_EXE_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_FILE_PATH)
#define WSP_GLOBAL_PROC_REGISTER_MAP \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_PROC_REGISTER_MAP)
#define WSP_GLOBAL_ASSEMBLY_OPTIONS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_ASSEMBLY_OPTIONS)
#define WSP_GLOBAL_EXPRESSION_SYNTAX \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXPRESSION_SYNTAX)
#define WSP_GLOBAL_ALIASES \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_ALIASES)
#define WSP_GLOBAL_PROCESS_START_DIR \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_PROCESS_START_DIR)
#define WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_PROC_FLAGS_REGISTER_MAP)

#define WSP_WINDOW_COMMONWIN_1 \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_COMMONWIN_1)
#define WSP_WINDOW_FRAME_PLACEMENT \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_FRAME_PLACEMENT)
#define WSP_WINDOW_FRAME_TITLE \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_FRAME_TITLE)

// Workspace header for window entries.
struct WSP_COMMONWIN_HEADER
{
    WIN_TYPES Type;
    ULONG Reserved;
};

//----------------------------------------------------------------------------
//
// A workspace is a dynamic buffer of tagged blobs.  Values
// are accessed through the Get/Set methods.
//
// Entries are always eight-byte aligned.
//
// Workspaces can be saved and restored from the registry under
// the windbg workspace key.
//
//----------------------------------------------------------------------------

#define WSP_REG_KEY "Software\\Microsoft\\Windbg\\Workspaces"

enum
{
    // Registry names must come first.
    WSP_NAME_BASE,
    WSP_NAME_KERNEL,
    WSP_NAME_USER,
    WSP_NAME_DUMP,
    WSP_NAME_REMOTE,
    WSP_NAME_EXPLICIT,
    WSP_NAME_FILE,
    WSP_NAME_COUNT
};

#define WSP_REG_NAME_COUNT (WSP_NAME_EXPLICIT + 1)

#define MAX_WSP_NAME 256

#define WSP_SIGNATURE 'SWDW'
#define WSP_VERSION   1

struct WSP_HEADER
{
    ULONG Signature;
    ULONG Version;
};

struct WSP_ENTRY
{
    WSP_TAG Tag;
    USHORT FullSize;
    USHORT DataSize;
};

#define WSP_ENTRY_DATA(Type, Entry) ((Type)((Entry) + 1))

#define WSPF_DIRTY_WRITE       0x00000001
#define WSPF_DIRTY_WINDOWS     0x00000002
#define WSPF_DIRTY_BREAKPOINTS 0x00000004
#define WSPF_DIRTY_LOG_FILE    0x00000008
#define WSPF_DIRTY_PATHS       0x00000010
#define WSPF_DIRTY_FILTERS     0x00000020
#define WSPF_DIRTY_MRU_LIST    0x00000040
#define WSPF_DIRTY_ALIASES     0x00000080
#define WSPF_DIRTY_ALL         0x000000ff

#define WSP_APPLY_DEFAULT  0x00000000
#define WSP_APPLY_EXPLICIT 0x00000001
#define WSP_APPLY_AGAIN    0x00000002

enum WSP_CREATE_OPTION
{
    WSP_OPEN_EXISTING,
    WSP_CREATE_QUERY,
    WSP_CREATE_ALWAYS,
};

class Workspace
{
public:
    Workspace(void);
    ~Workspace(void);
    
    WSP_ENTRY* Get(WSP_TAG Tag);
    WSP_ENTRY* GetNext(WSP_ENTRY* Entry, WSP_TAG Tag, WSP_TAG TagMask);
    WSP_ENTRY* GetString(WSP_TAG Tag, PSTR Str, ULONG MaxSize);
    WSP_ENTRY* GetAllocString(WSP_TAG Tag, PSTR* Str);
    WSP_ENTRY* GetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size);
    WSP_ENTRY* GetUlong(WSP_TAG Tag, PULONG Value)
    {
        return GetBuffer(Tag, Value, sizeof(*Value));
    }
    
    WSP_ENTRY* Set(WSP_TAG Tag, ULONG Size);
    WSP_ENTRY* SetString(WSP_TAG Tag, PCSTR Str);
    WSP_ENTRY* SetStrings(WSP_TAG Tag, ULONG Count, PCSTR* Strs);
    WSP_ENTRY* SetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size);
    WSP_ENTRY* SetUlong(WSP_TAG Tag, ULONG Value)
    {
        WSP_ENTRY* Entry = SetBuffer(Tag, &Value, sizeof(Value));
        return Entry;
    }

    WSP_ENTRY* Add(WSP_TAG Tag, ULONG Size);
    
    void DeleteEntry(WSP_ENTRY* Entry);
    ULONG Delete(WSP_TAG Tag, WSP_TAG TagMask);
    void Empty(void);
    BOOL IsEmpty(void)
    {
        return m_DataUsed == sizeof(WSP_HEADER);
    }
    
    WSP_HEADER* GetHeader(void)
    {
        return (WSP_HEADER*)m_Data;
    }
    BOOL ValidEntry(WSP_ENTRY* Entry)
    {
        return (PUCHAR)Entry >= m_Data &&
            (ULONG)((PUCHAR)Entry - m_Data) < m_DataUsed;
    }
    WSP_ENTRY* NextEntry(WSP_ENTRY* Entry)
    {
        if (Entry == NULL)
        {
            Entry = (WSP_ENTRY*)(m_Data + sizeof(WSP_HEADER));
        }
        else
        {
            Entry = (WSP_ENTRY*)((PUCHAR)Entry + Entry->FullSize);
        }
        
        if (ValidEntry(Entry))
        {
            return Entry;
        }
        else
        {
            return NULL;
        }
    }

    ULONG GetFlags(void)
    {
        return m_Flags;
    }
    void SetFlags(ULONG Flags, ULONG Mask)
    {
        m_Flags = (m_Flags & ~Mask) | (Flags & Mask);
    }
    
    void AddDirty(ULONG Flags)
    {
        m_Flags |= Flags;
    }
    void ClearDirty(void)
    {
        m_Flags &= ~WSPF_DIRTY_ALL;
    }

    ULONG GetKey(void)
    {
        return m_Key;
    }
    PTSTR GetValue(void)
    {
        return m_Value;
    }

    PTSTR GetName(BOOL Verbose);
    HRESULT ReadFromReg(void);
    HRESULT ReadFromFile(void);
    static HRESULT Create(ULONG Key, PTSTR Value,
                          Workspace** NewWsp);
    static HRESULT Read(ULONG Key, PTSTR Value,
                        Workspace** NewWsp);
    HRESULT ChangeName(ULONG Key, PTSTR Value, BOOL Force);
    HRESULT Flush(BOOL ForceSave, BOOL Cancellable);

    void UpdateBreakpointInformation(void);
    void UpdateWindowInformation(void);
    void UpdateLogFileInformation(void);
    void UpdatePathInformation(void);
    void UpdateFilterInformation(void);
    void UpdateMruListInformation(void);
    void UpdateAliasInformation(void);
    HRESULT WriteToReg(void);
    HRESULT WriteToFile(void);
    void DeleteReg(BOOL Primary);
    static void DeleteRegKey(BOOL Primary, ULONG Key, PTSTR Value);
    
    int Apply(ULONG Flags);
    
private:
    ULONG m_Flags;
    
    PUCHAR m_Data;
    ULONG m_DataLen;
    ULONG m_DataUsed;
    
    ULONG m_Key;
    PTSTR m_Value;

    void PackData(PUCHAR Dst, ULONG Len)
    {
        PUCHAR Src = Dst + Len;
        memmove(Dst, Src, m_DataUsed - (ULONG)(Src - m_Data));
        m_DataUsed -= Len;
    }
    WSP_ENTRY* AllocateEntry(ULONG FullSize);
    static void GetKeyName(ULONG Key, PSTR KeyName);
    static HKEY OpenKey(BOOL Primary, ULONG Key, BOOL Create);
};

// The current workspace.
extern Workspace* g_Workspace;
extern BOOL g_ExplicitWorkspace;
extern char* g_WorkspaceKeyNames[];
extern char* g_WorkspaceDefaultName;
extern char* g_WorkspaceKeyDescriptions[];

HRESULT UiSwitchWorkspace(ULONG Key, PTSTR Value, WSP_CREATE_OPTION Create,
                          ULONG Flags, int* SessionStarts);
void UiSwitchToExplicitWorkspace(ULONG Key, PTSTR Value);
void UiSaveWorkspaceAs(ULONG Key, PTSTR Value);

HRESULT UiDelayedSwitchWorkspace(void);
void EngSwitchWorkspace(ULONG Key, PTSTR Value);

PSTR GetWspTagName(WSP_TAG Tag);

#endif // #ifndef __WRKSPACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\delnode\delnode.c ===
/*
 * History
 *      17-SEP-90   w-barry     Ported to Cruiser
 */

#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <string.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

#define BS    0x08
#define CTRLC 0x03
#define ENTER 0x0d

// Define external function calls..
extern flagType delnode( char * );

void
Usage (
      void
      )
{
    fputs("Usage:  delnode [/q] nodes\n"
          "                /q quiet, no confirm\n",
          stderr);
    exit (1);
}

flagType
fConfirm (
         char *psz
         )
{
    int ch, chLast;

    chLast = 0;
    printf ("\nDELNODE: Delete node \"%s\" and all its subdirectories? [yn] ", psz);
    while ( TRUE ) {

        ch = _getch();
        ch = tolower( ch );

        if (ch == 0x03) {
            printf( "^C Aborted\n" );
            exit( 1 );
        }
        if (ch == ENTER && (chLast == 'y' || chLast == 'n')) {
            putchar('\n');
            return (flagType)(chLast == 'y');
        }

        if (ch != 0) {
            if (ch == 'y' || ch == 'n') {
                putchar(ch);
                putchar('\b');
            }
        }
        chLast = ch;
    }

}

int
__cdecl
main(
    int c,
    char *v[]
    )
{
    char sz[MAX_PATH];
    flagType fAsk = TRUE;

    ConvertAppToOem( c, v );
    SHIFT (c, v);
    while (c && fSwitChr (**v)) {
        if (!strcmp (*v+1, "q"))
            fAsk = FALSE;
        else
            Usage ();
        SHIFT (c, v);
    }
    if (c == 0)
        Usage ();

    while (c) {
        if (strlen( *v ) == 0) {
            printf( "DELNODE: invalid null argument\n" );
        } else if (!fAsk || fConfirm (*v)) {
            if (!fileext (*v, sz)) {
                upd ("*.*", *v, sz);
            } else {
                strcpy (sz, *v);
                if (!strcmp ("..", sz) || !strcmp (".", sz)) {
                    pathcat (sz, "*.*");
                }
            }
            if (fAsk) {
                printf( "DELNODE: deleting ... \n", sz );
            }
            delnode (sz);
        } else if (fAsk) {
            printf("DELNODE: ** nothing ** deleted\n");
        }
        SHIFT (c, v);
    }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\windbg.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    windbg.cpp

Abstract:

    This module contains the main program, main window proc and MDICLIENT
    window proc for Windbg.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

ULONG g_CodeDisplaySequence;

PTSTR g_ProgramName;
ULONG g_CommandLineStart;
PSTR g_RemoteOptions;

QUIET_MODES g_QuietMode = QMODE_DISABLED;
QUIET_MODES g_QuietSourceMode = QMODE_DISABLED;

ULONG g_DefPriority;

char g_TitleServerText[MAX_PATH];
char g_TitleExtraText[MAX_PATH];
BOOL g_ExplicitTitle;

PFN_FlashWindowEx g_FlashWindowEx;

BOOL g_AllowJournaling;

BOOL g_Exit;

// Handle to main window
HWND g_hwndFrame = NULL;

// Handle to MDI client
HWND g_hwndMDIClient = NULL;

// Width and height of MDI client.
ULONG g_MdiWidth, g_MdiHeight;

//Handle to instance data
HINSTANCE g_hInst;

//Handle to accelerator table
HACCEL g_hMainAccTable;

//Keyboard Hooks functions
HHOOK   hKeyHook;

// WinDBG title text
TCHAR g_MainTitleText[MAX_MSG_TXT];

// menu that belongs to g_hwndFrame
HMENU g_hmenuMain;
HMENU g_hmenuMainSave;

// Window submenu
HMENU g_hmenuWindowSub;

#ifdef DBG
// Used to define debugger output
DWORD dwVerboseLevel = MIN_VERBOSITY_LEVEL;
#endif

INDEXED_COLOR g_Colors[COL_COUNT] =
{
    // Set from GetSysColor(COLOR_WINDOW).
    "Background", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_WINDOWTEXT).
    "Text", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHT).
    "Current line background", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Current line text", 0, 0, NULL,
    
    // Purple.
    "Breakpoint current line background", 0, RGB(255, 0, 255), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Breakpoint current line text", 0, 0, NULL,
    
    // Red.
    "Enabled breakpoint background", 0, RGB(255, 0, 0), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Enabled breakpoint text", 0, 0, NULL,
    
    // Yellow.
    "Disabled breakpoint background", 0, RGB(255, 255, 0), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Disabled breakpoint text", 0, 0, NULL,

    // Red.
    "Changed data text", 0, RGB(255, 0, 0), NULL,

    // Set from GetSysColor(COLOR_3DFACE).
    "Disabled window", 0, 0, NULL,
};

// There is a foreground and background color for each
// possible bit in the output mask.  The default foreground
// color is normal window text and the background is
// the normal window background.
//
// There are also some extra colors for user-added output.
//
// Some mask bits have no assigned meaning right now and
// are given NULL names to mark them as skip entries.  Their
// indices are allocated now for future use.
INDEXED_COLOR g_OutMaskColors[OUT_MASK_COL_COUNT] =
{
    // 0x00000001 - 0x00000008.
    "Normal level command window text", 0, 0, NULL,
    "Normal level command window text background", 0, 0, NULL,
    "Error level command window text", 0, 0, NULL,
    "Error level command window text background", 0, 0, NULL,
    "Warning level command window text", 0, 0, NULL,
    "Warning level command window text background", 0, 0, NULL,
    "Verbose level command window text", 0, 0, NULL,
    "Verbose level command window text background", 0, 0, NULL,
    // 0x00000010 - 0x00000080.
    "Prompt level command window text", 0, 0, NULL,
    "Prompt level command window text background", 0, 0, NULL,
    "Prompt registers level command window text", 0, 0, NULL,
    "Prompt registers level command window text background", 0, 0, NULL,
    "Extension warning level command window text", 0, 0, NULL,
    "Extension warning level command window text background", 0, 0, NULL,
    "Debuggee level command window text", 0, 0, NULL,
    "Debuggee level command window text background", 0, 0, NULL,
    // 0x00000100 - 0x00000800.
    "Debuggee prompt level command window text", 0, 0, NULL,
    "Debuggee prompt level command window text background", 0, 0, NULL,
    "Symbol message level command window text", 0, 0, NULL,
    "Symbol message level command window text background", 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00001000 - 0x00008000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00010000 - 0x00080000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00100000 - 0x00800000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x01000000 - 0x08000000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x10000000 - 0x80000000.
    "Internal event level command window text", 0, 0, NULL,
    "Internal event level command window text background", 0, 0, NULL,
    "Internal breakpoint level command window text", 0, 0, NULL,
    "Internal breakpoint level command window text background", 0, 0, NULL,
    "Internal remoting level command window text", 0, 0, NULL,
    "Internal remoting level command window text background", 0, 0, NULL,
    "Internal KD protocol level command window text", 0, 0, NULL,
    "Internal KD protocol level command window text background", 0, 0, NULL,
    // User-added text.
    "User-added command window text", 0, 0, NULL,
    "User-added command window text background", 0, 0, NULL,
};

COLORREF g_CustomColors[CUSTCOL_COUNT];

void
UpdateFrameTitle(void)
{
    char Title[MAX_MSG_TXT + 2 * MAX_PATH + 32];

    Title[0] = 0;

    if (g_ExplicitTitle)
    {
        CatString(Title, g_TitleExtraText, DIMA(Title));
        CatString(Title, " - ", DIMA(Title));
    }
    else
    {
        if (g_TitleServerText[0])
        {
            CatString(Title, g_TitleServerText, DIMA(Title));
            CatString(Title, " - ", DIMA(Title));
        }

        if (g_TitleExtraText[0])
        {
            CatString(Title, g_TitleExtraText, DIMA(Title));
            CatString(Title, " - ", DIMA(Title));
        }
    }

    CatString(Title, g_MainTitleText, DIMA(Title));
    
    SetWindowText(g_hwndFrame, Title);
}

void
SetTitleServerText(PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    _vsnprintf(g_TitleServerText, sizeof(g_TitleServerText), Format, Args);
    g_TitleServerText[sizeof(g_TitleServerText) - 1] = 0;
    va_end(Args);
    UpdateFrameTitle();
}

void
SetTitleSessionText(PCSTR Format, ...)
{
    // Don't override an explicit title.
    if (g_ExplicitTitle)
    {
        return;
    }

    if (Format == NULL)
    {
        g_TitleExtraText[0] = 0;
    }
    else
    {
        va_list Args;
        va_start(Args, Format);
        _vsnprintf(g_TitleExtraText, sizeof(g_TitleExtraText), Format, Args);
        g_TitleExtraText[sizeof(g_TitleExtraText) - 1] = 0;
        va_end(Args);
    }
    
    UpdateFrameTitle();
}

void
SetTitleExplicitText(PCSTR Text)
{
    CopyString(g_TitleExtraText, Text, DIMA(g_TitleExtraText));
    g_ExplicitTitle = TRUE;
    UpdateFrameTitle();

    if (g_ExplicitWorkspace && g_Workspace != NULL)
    {
        g_Workspace->SetString(WSP_WINDOW_FRAME_TITLE, Text);
    }
}

void
UpdateTitleSessionText(void)
{
    if (!g_RemoteClient)
    {
        char ProcServer[MAX_CMDLINE_TXT];

        if (g_ProcessServer != NULL)
        {
            PrintString(ProcServer, DIMA(ProcServer),
                        "[%s] ", g_ProcessServer);
        }
        else
        {
            ProcServer[0] = 0;
        }
        
        if (g_NumDumpFiles)
        {
            SetTitleSessionText("Dump %s", g_DumpFiles[0]);
        }
        else if (g_DebugCommandLine != NULL)
        {
            SetTitleSessionText("%s%s", ProcServer, g_DebugCommandLine);
        }
        else if (g_PidToDebug != 0)
        {
            SetTitleSessionText("%sPid %d", ProcServer, g_PidToDebug);
        }
        else if (g_ProcNameToDebug != NULL)
        {
            SetTitleSessionText("%sProcess %s", ProcServer, g_ProcNameToDebug);
        }
        else if (g_AttachKernelFlags == DEBUG_ATTACH_LOCAL_KERNEL)
        {
            SetTitleSessionText("Local kernel");
        }
        else if (g_AttachKernelFlags == DEBUG_ATTACH_EXDI_DRIVER)
        {
            SetTitleSessionText("eXDI '%s'",
                                g_KernelConnectOptions);
        }
        else
        {
            SetTitleSessionText("Kernel '%s'",
                                g_KernelConnectOptions);
        }
    }
    else
    {
        SetTitleSessionText("Remote '%s'", g_RemoteOptions);
    }
}

BOOL
CreateUiInterfaces(
    BOOL   Remote,
    LPTSTR CreateOptions
    )
{
    HRESULT Status;

    //
    // Destroy the old interfaces if they existed.
    //

    ReleaseUiInterfaces();

    //
    // Create the new debugger interfaces the UI will use.
    //

    if (Remote)
    {
        if ((Status = DebugConnect(CreateOptions, IID_IDebugClient,
                                   (void **)&g_pUiClient)) != S_OK)
        {
            if (Status == E_INVALIDARG)
            {
                InformationBox(ERR_Invalid_Remote_Param);
            }
            else if (Status == RPC_E_VERSION_MISMATCH)
            {
                InformationBox(ERR_Remoting_Version_Mismatch);
            }
            else if (Status == RPC_E_SERVER_DIED ||
                     Status == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
                     Status == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH))
            {
                InformationBox(ERR_No_Remote_Server, CreateOptions);
            }
            else
            {
                InformationBox(ERR_Unable_To_Connect, CreateOptions,
                               FormatStatusCode(Status), FormatStatus(Status));
            }
            return FALSE;
        }

        g_RemoteClient = TRUE;
        g_RemoteOptions = _tcsdup(CreateOptions);
    }
    else
    {
        if ((Status = DebugCreate(IID_IDebugClient,
                             (void **)&g_pUiClient)) != S_OK)
        {
            InternalError(Status, "UI DebugCreate");
            return FALSE;
        }

        if (CreateOptions != NULL &&
            (Status = g_pUiClient->StartServer(CreateOptions)) != S_OK)
        {
            if (Status == E_INVALIDARG)
            {
                InformationBox(ERR_Invalid_Server_Param);
            }
            else if (Status == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||
                     Status == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                InformationBox(ERR_Connection_In_Use);
            }
            else
            {
                InternalError(Status, "UI StartServer");
            }
            return FALSE;
        }
    }

    if ((Status = g_pUiClient->QueryInterface(IID_IDebugControl,
                                              (void **)&g_pUiControl)) != S_OK)
    {
        if (Status == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InternalError(Status, "UI QueryControl");
        }
        return FALSE;
    }

    if ((Status = g_pUiClient->QueryInterface(IID_IDebugSymbols,
                                          (void **)&g_pUiSymbols)) != S_OK)
    {
        if (Status == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InternalError(Status, "UI QuerySymbols");
        }
        return FALSE;
    }

    if ((Status = g_pUiClient->QueryInterface(IID_IDebugSystemObjects,
                                          (void **)&g_pUiSystem)) != S_OK)
    {
        if (Status == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InternalError(Status, "UI QuerySystem");
        }
        return FALSE;
    }

    //
    // Optional interfaces.
    //

    if ((Status = g_pUiClient->
         QueryInterface(IID_IDebugSymbols2, (void **)&g_pUiSymbols2)) != S_OK)
    {
        g_pUiSymbols2 = NULL;
    }

    if ((Status = g_pUiClient->
         QueryInterface(IID_IDebugControl3, (void **)&g_pUiControl3)) != S_OK)
    {
        g_pUiControl3 = NULL;
    }

    if (g_RemoteClient)
    {
        // Create a local client to do local source file lookups.
        if ((Status = DebugCreate(IID_IDebugClient,
                              (void **)&g_pUiLocClient)) != S_OK ||
            (Status = g_pUiLocClient->
             QueryInterface(IID_IDebugControl,
                            (void **)&g_pUiLocControl)) != S_OK ||
            (Status = g_pUiLocClient->
             QueryInterface(IID_IDebugSymbols,
                            (void **)&g_pUiLocSymbols)) != S_OK)
        {
            InternalError(Status, "UI local symbol object");
            return FALSE;
        }
    }
    else
    {
        g_pUiLocClient = g_pUiClient;
        g_pUiLocClient->AddRef();
        g_pUiLocControl = g_pUiControl;
        g_pUiLocControl->AddRef();
        g_pUiLocSymbols = g_pUiSymbols;
        g_pUiLocSymbols->AddRef();
    }
    
    return TRUE;
}

void
ReleaseUiInterfaces(void)
{
    RELEASE(g_pUiClient);
    RELEASE(g_pUiControl);
    RELEASE(g_pUiControl3);
    RELEASE(g_pUiSymbols);
    RELEASE(g_pUiSymbols2);
    RELEASE(g_pUiSystem);
    RELEASE(g_pUiLocClient);
    RELEASE(g_pUiLocControl);
    RELEASE(g_pUiLocSymbols);
}

PTSTR
GetArg(
    PTSTR *lpp
    )
{
    static PTSTR pszBuffer = NULL;
    int r;
    PTSTR p1 = *lpp;

    while (*p1 == _T(' ') || *p1 == _T('\t'))
    {
        p1++;
    }

    if (pszBuffer)
    {
        free(pszBuffer);
    }
    pszBuffer = (PTSTR) calloc(_tcslen(p1) + 1, sizeof(TCHAR));
    if (pszBuffer == NULL)
    {
        ErrorExit(NULL, "Unable to allocate command line argument\n");
    }

    r = CPCopyString(&p1, pszBuffer, 0, (*p1 == _T('\'') || *p1 == _T('"') ));
    if (r >= 0)
    {
        *lpp = p1;
    }
    return pszBuffer;
}


BOOL
ParseCommandLine(BOOL FirstParse)
{
    PTSTR   lp1 = GetCommandLine();
    PTSTR   lp2 = NULL;
    int Starts;
    HRESULT Status;

    g_CommandLineStart = 0;
    g_EngOptModified = 0;
    
    // skip whitespace
    while (*lp1 == _T(' ') || *lp1 == _T('\t'))
    {
        lp1++;
    }

    // skip over our program name
    if (_T('"') != *lp1)
    {
        lp1 += _tcslen(g_ProgramName);
    }
    else
    {
        // The program name is quoted.  This is a tough thing
        // to parse through as the system allows a lot of weird
        // quote placement and no trailing quote is required.
        // Once we skip ahead by the program name we continue
        // to whitespace on the theory that the program
        // name and the first argument must be separated by whitespace
        // at some point.
        lp1 += _tcslen(g_ProgramName) + 1;
        while (*lp1 && *lp1 != _T(' ') && *lp1 != _T('\t'))
        {
            lp1++;
        }
    }

    while (*lp1)
    {
        if (*lp1 == _T(' ') || *lp1 == _T('\t'))
        {
            lp1++;
            continue;
        }

        if (*lp1 == _T('-') || *lp1 == _T('/'))
        {
            ++lp1;

            switch (*lp1++)
            {
            case _T('?'):
            usage:
                SpawnHelp(HELP_TOPIC_COMMAND_LINE_WINDBG);
                exit(1);

            case _T(' '):
            case _T('\t'):
                break;

            case 'a':
                ULONG64 ExtHandle;

                lp2 = GetArg(&lp1);
                g_pUiControl->AddExtension(lp2, DEBUG_EXTENSION_AT_ENGINE,
                                           &ExtHandle);
                break;

            case _T('b'):
                g_pUiControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
                if (g_RemoteClient)
                {
                    // The engine may already be waiting so just ask
                    // for a breakin immediately.
                    g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
                }
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_BREAK;
                break;

            case _T('c'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 5 &&
                    !memcmp(lp1, "lines", 5))
                {
                    lp1 = lp2;
                    g_HistoryLines = atoi(GetArg(&lp1));
                }
                else
                {
                    g_InitialCommand = _tcsdup(GetArg(&lp1));
                }
                break;
                    
            case _T('d'):
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_INITIAL_MODULE_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                break;

            case _T('e'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 1 &&
                    *lp1 == _T('e'))
                {
                    if (!g_pUiControl3)
                    {
                        goto usage;
                    }
                
                    lp1 = lp2;
                    if (g_pUiControl3->
                        SetExpressionSyntaxByName(GetArg(&lp1)) != S_OK)
                    {
                        goto usage;
                    }
                }
                else
                {
                    // Signal an event after process is attached.
                    g_pUiControl->SetNotifyEventHandle(_atoi64(GetArg(&lp1)));
                }
                break;

            case _T('f'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 != lp1 + 6 ||
                    memcmp(lp1, "ailinc", 6))
                {
                    goto usage;
                }
                
                lp1 = lp2;
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION);
                g_pUiSymbols->
                    AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
                break;
                
            case _T('g'):
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_BREAK;
                break;

            case _T('G'):
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_FINAL_BREAK;
                break;

            case _T('h'):
                if (*lp1 == _T('d'))
                {
                    lp1++;
                    g_DebugCreateFlags |=
                        DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
                }
                else
                {
                    goto usage;
                }
                break;
                    
            case _T('i'):
                g_pUiSymbols->SetImagePath(GetArg(&lp1));
                break;

            case _T('I'):
                if (!InstallAsAeDebug(NULL))
                {
                    InformationBox(ERR_Fail_Inst_Postmortem_Dbg);
                }
                else
                {
                    InformationBox(ERR_Success_Inst_Postmortem_Dbg);
                    exit(1);
                }
                break;

                // XXX AndreVa - This needs to be checked before we start
                // the GUI.
            case _T('J'):
            case _T('j'):
                g_AllowJournaling = TRUE;
                break;
        
            case _T('k'):
                if (*lp1 == _T('l'))
                {
                    g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
                    lp1++;
                }
                else if (*lp1 == _T('x'))
                {
                    g_AttachKernelFlags = DEBUG_ATTACH_EXDI_DRIVER;
                    lp1++;
                    g_KernelConnectOptions = _tcsdup(GetArg(&lp1));
                }
                else
                {
                    g_KernelConnectOptions = _tcsdup(GetArg(&lp1));
                }
                g_CommandLineStart++;
                break;

            case _T('l'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 3 &&
                    (!memcmp(lp1, "oga", 3) ||
                     !memcmp(lp1, "ogo", 3)))
                {
                    lp1 = lp2;
                    g_pUiControl->OpenLogFile(GetArg(&lp1), *(lp2 - 1) == 'a');
                    break;
                }
                else
                {
                    goto usage;
                }
                break;
                
            case _T('n'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 6 &&
                    !memcmp(lp1, "oshell", 6))
                {
                    lp1 = lp2;
                    g_pUiControl->AddEngineOptions
                        (DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS);
                    break;
                }
                else
                {
                    g_pUiSymbols->AddSymbolOptions(SYMOPT_DEBUG);
                }
                break;

            case _T('o'):
                if (g_RemoteClient)
                {
                    goto usage;
                }

                g_DebugCreateFlags |= DEBUG_PROCESS;
                g_DebugCreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
                break;

            case _T('p'):
                // attach to an active process
                // p specifies a process id
                // pn specifies a process by name
                // ie: -p 360 
                //     -pn _T("foo bar")
                
                if (!isspace(*lp1) && !isdigit(*lp1))
                {
                    // They may have specified a -p flag with
                    // a tail such as -premote.
                    lp2 = lp1;
                    while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                    {
                        lp2++;
                    }
                    if (lp2 == lp1 + 6 &&
                        !memcmp(lp1, "remote", 6))
                    {
                        lp1 = lp2;
                        g_ProcessServer = _tcsdup(GetArg(&lp1));
                        break;
                    }
                    else if (_T('b') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags |=
                            DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK;
                        break;
                    }
                    else if (_T('d') == *lp1)
                    {
                        lp1++;
                        g_DetachOnExit = TRUE;
                        break;
                    }
                    else if (_T('e') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags = DEBUG_ATTACH_EXISTING;
                        break;
                    }
                    else if (_T('r') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags |=
                            DEBUG_ATTACH_INVASIVE_RESUME_PROCESS;
                        break;
                    }
                    else if (_T('t') == *lp1)
                    {
                        lp1++;
                        g_pUiControl->
                            SetInterruptTimeout(atoi(GetArg(&lp1)));
                        break;
                    }
                    else if (_T('v') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags = DEBUG_ATTACH_NONINVASIVE;
                        if (_T('r') == *lp1)
                        {
                            lp1++;
                            g_AttachProcessFlags |=
                                DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND;
                        }
                        break;
                    }
                    else if (_T('n') != *lp1)
                    {
                        goto usage;
                    }
                    else
                    {
                        // Skip the _T('n')
                        lp1++;
                        g_ProcNameToDebug = _tcsdup(GetArg(&lp1));
                    }
                }
                else
                {
                    // They specified -p 360
                    g_PidToDebug = strtoul(GetArg(&lp1), NULL, 0);
                    
                    if (g_PidToDebug <= 0)
                    {
                        g_PidToDebug = -2;
                        ErrorBox(NULL, 0, ERR_Invalid_Process_Id,
                                 g_PidToDebug);
                    }
                }
                g_CommandLineStart++;
                break;

            case _T('Q'):
                if (*lp1 == 'S')
                {
                    lp1++;
                    if (*lp1 == 'Y')
                    {
                        lp1++;
                        g_QuietSourceMode = QMODE_ALWAYS_YES;
                    }
                    else if (!*lp1 || isspace(*lp1))
                    {
                        g_QuietSourceMode = QMODE_ALWAYS_NO;
                    }
                    else
                    {
                        goto usage;
                    }
                }
                else if (*lp1 == 'Y')
                {
                    lp1++;
                    g_QuietMode = QMODE_ALWAYS_YES;
                }
                else if (!*lp1 || isspace(*lp1))
                {
                    g_QuietMode = QMODE_ALWAYS_NO;
                }
                else
                {
                    goto usage;
                }
                break;
                    
            case _T('r'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 3 &&
                    !memcmp(lp1, "obp", 3))
                {
                    lp1 = lp2;
                    g_pUiControl->AddEngineOptions
                        (DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS);
                    break;
                }
                else if (lp2 != lp1 + 5 ||
                         memcmp(lp1, "emote", 5))
                {
                    goto usage;
                }
                    
                lp1 = lp2;
                lp2 = GetArg(&lp1);
                if (!CreateUiInterfaces(TRUE, lp2))
                {
                    return FALSE;
                }

                g_CommandLineStart++;
                break;

            case _T('s'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 5 &&
                    !memcmp(lp1, "erver", 5))
                {
                    lp1 = lp2;
                    lp2 = GetArg(&lp1);
                    if (!CreateUiInterfaces(FALSE, lp2))
                    {
                        return FALSE;
                    }
                    
                    SetTitleServerText("Server '%s'", lp2);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "dce", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        RemoveSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
                }
                else if (lp2 == lp1 + 5 &&
                         !memcmp(lp1, "ecure", 5))
                {
                    lp1 = lp2;
                    if (g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_SECURE) != S_OK)
                    {
                        ErrorBox(NULL, 0, ERR_Cant_Secure);
                        return FALSE;
                    }
                }
                else if (lp2 == lp1 + 2 &&
                         !memcmp(lp1, "es", 2))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "fce", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
                }
                else if (lp2 == lp1 + 5 &&
                         !memcmp(lp1, "flags", 5))
                {
                    lp1 = lp2;
                    lp2 = GetArg(&lp1);
                    g_pUiSymbols->
                        SetSymbolOptions(strtoul(lp2, NULL, 0));
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "icv", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->AddSymbolOptions(SYMOPT_IGNORE_CVREC);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "ins", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->AddSymbolOptions(SYMOPT_IGNORE_NT_SYMPATH);
                }
                else if (lp2 == lp1 + 2 &&
                         !memcmp(lp1, "nc", 2))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_NO_CPP);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "nul", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_NO_UNQUALIFIED_LOADS);
                }
                else if (lp2 == lp1 + 2 &&
                         !memcmp(lp1, "up", 2))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        RemoveSymbolOptions(SYMOPT_AUTO_PUBLICS |
                                            SYMOPT_NO_PUBLICS);
                }
                else if (lp2 == lp1 + 6 &&
                         !memcmp(lp1, "rcpath", 6))
                {
                    lp1 = lp2;
                    g_pUiSymbols->SetSourcePath(GetArg(&lp1));
                }
                else
                {
                    goto usage;
                }
                break;
                    
            case _T('T'):
                lp2 = GetArg(&lp1);
                SetTitleExplicitText(lp2);
                break;

            case _T('v'):
                g_Verbose = TRUE;
                break;

            case _T('w'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 3 &&
                    !memcmp(lp1, "ake", 3))
                {
                    ULONG Pid;
                    
                    lp1 = lp2;
                    Pid = strtoul(GetArg(&lp1), NULL, 0);
                    if (!SetPidEvent(Pid, OPEN_EXISTING))
                    {
                        InformationBox(ERR_Wake_Failed, Pid);
                        ErrorExit(NULL,
                                  "Process %d is not a sleeping debugger\n",
                                  Pid);
                    }
                    else
                    {
                        ExitDebugger(NULL, 0);
                    }
                }
                break;
                
            case _T('W'):
                if (*lp1 == _T('F'))
                {
                    lp1++;
                    lp2 = GetArg(&lp1);
                    if ((Status =
                         UiSwitchWorkspace(WSP_NAME_FILE, lp2,
                                           WSP_CREATE_QUERY,
                                           WSP_APPLY_EXPLICIT,
                                           &Starts)) != S_OK)
                    {
                        InformationBox(ERR_Cant_Open_Workspace,
                                       FormatStatusCode(Status),
                                       FormatStatus(Status));
                        ExitDebugger(NULL, 0);
                    }

                    g_CommandLineStart += Starts;
                }
                else if (*lp1 != _T('X'))
                {
                    lp2 = GetArg(&lp1);
                    if ((Status =
                         UiSwitchWorkspace(WSP_NAME_EXPLICIT, lp2,
                                           WSP_CREATE_QUERY,
                                           WSP_APPLY_EXPLICIT,
                                           &Starts)) != S_OK)
                    {
                        InformationBox(ERR_Cant_Open_Workspace,
                                       FormatStatusCode(Status),
                                       FormatStatus(Status));
                        ExitDebugger(NULL, 0);
                    }

                    g_CommandLineStart += Starts;
                }
                else
                {
                    // Skip X.
                    lp1++;
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->Flush(FALSE, FALSE);
                        delete g_Workspace;
                    }
                    g_Workspace = NULL;
                }
                g_ExplicitWorkspace = TRUE;
                break;
                
            case _T('y'):
                g_pUiSymbols->SetSymbolPath(GetArg(&lp1));
                break;

            case _T('z'):
                if (*lp1 == _T('p'))
                {
                    lp1++;
                    lp2 = GetArg(&lp1);
                    if (g_NumDumpInfoFiles == MAX_DUMP_FILES)
                    {
                        InformationBox(ERR_Too_Many_Dump_Files, lp2);
                    }
                    else
                    {
                        g_DumpInfoFiles[g_NumDumpInfoFiles] = _tcsdup(lp2);
                        g_DumpInfoTypes[g_NumDumpInfoFiles] =
                            DEBUG_DUMP_FILE_PAGE_FILE_DUMP;
                        g_NumDumpInfoFiles++;
                    }
                }
                else if (*lp1 && *lp1 != _T(' ') && *lp1 != _T('\t'))
                {
                    goto usage;
                }
                else
                {
                    lp2 = GetArg(&lp1);
                    if (g_NumDumpFiles == MAX_DUMP_FILES)
                    {
                        InformationBox(ERR_Too_Many_Dump_Files, lp2);
                    }
                    else
                    {
                        g_DumpFiles[g_NumDumpFiles] = _tcsdup(lp2);
                        if (++g_NumDumpFiles == 1)
                        {
                            g_CommandLineStart++;
                        }
                    }
                }
                break;

            default:
                --lp1;
                goto usage;
            }
        }
        else
        {
            // pick up file args.  If it is a program name,
            // keep the tail of the cmd line intact.
            g_DebugCommandLine = _tcsdup(lp1);
            g_CommandLineStart++;
            break;
        }
    }

    //
    // If a command line start option was set, we can just start the engine
    // right away.  Otherwise, we have to wait for user input.
    //
    // If multiple command line option were set, print an error.
    //

    if (g_CommandLineStart == 1)
    {
        PostMessage(g_hwndFrame, WU_START_ENGINE, 0, 0);
    }
    else if (g_CommandLineStart > 1)
    {
        ErrorBox(NULL, 0,  ERR_Invalid_Command_Line);
        return FALSE;
    }
    return TRUE;
}

void
StopDebugging(BOOL UserRequest)
{
    // Flush the current workspace first so
    // the engine thread doesn't.
    if (g_Workspace != NULL &&
        g_Workspace->Flush(FALSE, FALSE) == S_FALSE)
    {
        // User cancelled things so don't terminate.  We
        // don't offer that option right now so this
        // should never happen.
        return;
    }
                
    if (g_EngineThreadId)
    {
        DWORD WaitStatus;

        if (UserRequest)
        {
            if (!g_RemoteClient)
            {
                // Try to get the current engine operation stopped.
                g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_EXIT);
            }
        
            // If this stop is coming from the UI thread
            // clean up the current session.
            AddEnumCommand(UIC_END_SESSION);
        }

        for (;;)
        {
            // Wait for the engine thread to finish.
            WaitStatus = WaitForSingleObject(g_EngineThread, 30000);
            if (WaitStatus != WAIT_TIMEOUT)
            {
                break;
            }
            else
            {
                // Engine is still busy.  If the user requested
                // the stop, ask the user whether they want to keep
                // waiting.  If they don't they'll have to exit
                // windbg as the engine must be available in
                // order to restart anything.  If this is a stop
                // from the engine thread itself it should have
                // finished up by now, so something is wrong.
                // For now give the user the same option but
                // in the future we might want to have special
                // behavior.
                if (QuestionBox(STR_Engine_Still_Busy, MB_YESNO) == IDNO)
                {
                    ExitDebugger(g_pUiClient, 0);
                }

                if (UserRequest)
                {
                    // Try again to get the engine to stop.
                    g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_EXIT);
                }
            }
        }
    }

    if (g_EngineThread != NULL)
    {
        CloseHandle(g_EngineThread);
        g_EngineThread = NULL;
    }
    
    CloseAllWindows(ALL_WINDOWS);
    if (!CreateUiInterfaces(FALSE, NULL))
    {
        InternalError(E_OUTOFMEMORY, "CreateUiInterfaces");
        ErrorExit(NULL, "Unable to recreate UI interfaces\n");
    }

    ClearDebuggingParams();
    SetTitleSessionText(NULL);
                
    // Any changes caused by shutting things down
    // are not user changes and can be ignored.
    if (g_Workspace != NULL)
    {
        g_Workspace->ClearDirty();
    }
    if (!g_ExplicitWorkspace)
    {
        UiSwitchWorkspace(WSP_NAME_BASE, g_WorkspaceDefaultName,
                          WSP_CREATE_ALWAYS, WSP_APPLY_DEFAULT, NULL);
    }

    SetLineColumn_StatusBar(0, 0);
    SetSysPidTid_StatusBar(0, "<None>", 0, 0, 0, 0);
    EnableToolbarControls();
}

void
ClearDebuggingParams(void)
{
    ULONG i;
    
    //
    // Reset all session starting values.
    //
    // Do not clear the process server value here
    // as the UI doesn't offer any way to set it
    // so just let the command line setting persist
    // for the entire run of the process.
    //
    
    g_AttachKernelFlags = 0;
    free(g_KernelConnectOptions);
    g_KernelConnectOptions = NULL;
    g_PidToDebug = 0;
    free(g_ProcNameToDebug);
    g_ProcNameToDebug = NULL;
    for (i = 0; i < g_NumDumpFiles; i++)
    {
        free(g_DumpFiles[i]);
        g_DumpFiles[i] = NULL;
    }
    g_NumDumpFiles = 0;
    for (i = 0; i < g_NumDumpInfoFiles; i++)
    {
        free(g_DumpInfoFiles[i]);
        g_DumpInfoFiles[i] = NULL;
    }
    g_NumDumpInfoFiles = 0;
    free(g_DebugCommandLine);
    g_DebugCommandLine = NULL;
    free(g_ProcessStartDir);
    g_ProcessStartDir = NULL;
    g_DebugCreateFlags = DEBUG_ONLY_THIS_PROCESS;
    g_RemoteClient = FALSE;
    free(g_RemoteOptions);
    g_RemoteOptions = NULL;
    g_DetachOnExit = FALSE;
    g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;
}


void 
InitDefaults(
    void
    )
{
    SetSrcMode_StatusBar(TRUE);
}


INDEXED_COLOR*
GetIndexedColor(ULONG Index)
{
    if (Index < OUT_MASK_COL_BASE)
    {
        if (Index >= COL_COUNT)
        {
            return NULL;
        }
        
        return g_Colors + Index;
    }
    else
    {
        Index -= OUT_MASK_COL_BASE;
        if (Index >= OUT_MASK_COL_COUNT ||
            g_OutMaskColors[Index].Name == NULL)
        {
            return NULL;
        }

        return g_OutMaskColors + Index;
    }
}

BOOL
SetColor(ULONG Index, COLORREF Color)
{
    INDEXED_COLOR* IdxCol = GetIndexedColor(Index);
    if (IdxCol == NULL)
    {
        return FALSE;
    }
    
    if (IdxCol->Brush != NULL)
    {
        DeleteObject(IdxCol->Brush);
    }
        
    IdxCol->Color = Color;
    IdxCol->Brush = CreateSolidBrush(IdxCol->Color);

    // A UI color selection changing means the UI needs to refresh.
    // Out mask color changes only apply to new text and do
    // not need a refresh.
    return Index < COL_COUNT ? TRUE : FALSE;
}

BOOL
GetOutMaskColors(ULONG Mask, COLORREF* Fg, COLORREF* Bg)
{
    if (Mask == 0)
    {
        return FALSE;
    }
    
    ULONG Idx = 0;

    while ((Mask & 1) == 0)
    {
        Idx++;
        Mask >>= 1;
    }

    Idx *= 2;
    if (g_OutMaskColors[Idx].Name == NULL)
    {
        return FALSE;
    }
    
    *Fg = g_OutMaskColors[Idx].Color;
    *Bg = g_OutMaskColors[Idx + 1].Color;

    return TRUE;
}

void
InitColors(void)
{
    g_Colors[COL_PLAIN].Default =
        GetSysColor(COLOR_WINDOW);
    g_Colors[COL_PLAIN_TEXT].Default =
        GetSysColor(COLOR_WINDOWTEXT);
    g_Colors[COL_CURRENT_LINE].Default =
        GetSysColor(COLOR_HIGHLIGHT);
    g_Colors[COL_CURRENT_LINE_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_BP_CURRENT_LINE_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_ENABLED_BP_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_DISABLED_BP_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_DISABLED_WINDOW].Default =
        GetSysColor(COLOR_3DFACE);

    ULONG i;

    for (i = 0; i < COL_COUNT; i++)
    {
        SetColor(i, g_Colors[i].Default);
    }
    for (i = 0; i < OUT_MASK_COL_COUNT; i++)
    {
        if (g_OutMaskColors[i].Name != NULL)
        {
            g_OutMaskColors[i].Default =
                GetSysColor((i & 1) ? COLOR_WINDOW : COLOR_WINDOWTEXT);
            SetColor(i + OUT_MASK_COL_BASE, g_OutMaskColors[i].Default);
        }
    }

    for (i = 0; i < CUSTCOL_COUNT; i++)
    {
        g_CustomColors[i] = GetSysColor(i + 1);
    }
}

BOOL
InitGUI(
    VOID
    )
/*++

Routine Description:

    Initialize the GUI components of WinDBG so we can bring up
    the parent MDI window with the top level menus.

Arguments:

Return Value:

    TRUE if everything is OK, FALSE if something fails

--*/
{
    WNDCLASSEX wcex = {0};
    TCHAR szClassName[MAX_MSG_TXT];
    INITCOMMONCONTROLSEX InitCtrls =
    {
        sizeof(InitCtrls), ICC_WIN95_CLASSES | ICC_COOL_CLASSES |
        ICC_USEREX_CLASSES
    };


    // Journaling is a feature that applications, such as Visual Test, can
    // enable to synchronize all message queues.
    // In order to allow WinDBG to debug an app such as Visual Test, we
    // provide the option to disable journaling, which ensures WinDBG
    // has its own message queue at all times.
    //
    // Should journaling be allowed or disabled?
    //
    if (g_AllowJournaling == FALSE)
    {
        #define RST_DONTJOURNALATTACH 0x00000002
        typedef VOID (WINAPI * RST)(DWORD,DWORD);

        RST Rst = (RST) GetProcAddress( GetModuleHandle( _T("user32.dll") ),
                                        "RegisterSystemThread" );
        if (Rst)
        {
            (Rst) (RST_DONTJOURNALATTACH, 0);
        }
    }

    // Load the richedit 2.0 dll so that it can register the window class.
    // We require RichEdit 2 and cannot use RichEdit 1.
    // Since we intentionally need this library the entire duration, we
    // simply load it and lose the handle to it. We are in win32 and running
    // separate address spaces, and don't have to worry about freeing the
    // library.
    if (!LoadLibrary(_T("RICHED20.DLL")))
    {
        return FALSE;
    }

    if ( !InitCommonControlsEx( &InitCtrls ))
    {
        return FALSE;
    }

    //We use tmp strings as edit buffers
    Assert(MAX_LINE_SIZE < TMP_STRING_SIZE);


    Dbg(LoadString(g_hInst, SYS_Main_wTitle,
                   g_MainTitleText, _tsizeof(g_MainTitleText)));
    Dbg(LoadString(g_hInst, SYS_Main_wClass,
                   szClassName, _tsizeof(szClassName) ));
    
    //Register the main window szClassName

    wcex.cbSize         = sizeof(wcex);
    wcex.style          = 0;
    wcex.lpfnWndProc    = MainWndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = LoadIcon(g_hInst, MAKEINTRESOURCE(WINDBGICON) );
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wcex.lpszMenuName   = MAKEINTRESOURCE(MAIN_MENU);
    wcex.lpszClassName  = szClassName;
    wcex.hIconSm        = LoadIcon(g_hInst, MAKEINTRESOURCE(WINDBGICON) );

    if (!RegisterClassEx (&wcex) )
    {
        return FALSE;
    }


    //
    // Generic MDI child window.  Channels all processing
    // through the COMMONWIN abstraction.
    //
    Dbg(LoadString(g_hInst, SYS_CommonWin_wClass,
                   szClassName, _tsizeof(szClassName)));

    wcex.cbSize         = sizeof(wcex);
    wcex.style          = 0;
    wcex.lpfnWndProc    = COMMONWIN_DATA::WindowProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = NULL;
    // The cursor is set to SIZENS so that the proper
    // cursor appears in the command window splitter area.
    // All other areas are covered by child windows with
    // their own cursors.
    wcex.hCursor        = LoadCursor(NULL, IDC_SIZENS);
    wcex.hbrBackground  = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = szClassName;
    wcex.hIconSm        = NULL;

    if (!RegisterClassEx(&wcex))
    {
        return FALSE ;
    }

    HDC Dc = GetDC(NULL);
    if (Dc == NULL)
    {
        return FALSE;
    }

    g_Fonts[FONT_FIXED].Font = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    g_Fonts[FONT_VARIABLE].Font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    
    for (ULONG FontIndex = 0; FontIndex < FONT_COUNT; FontIndex++)
    {
        SelectObject(Dc, g_Fonts[FontIndex].Font);
        if (!GetTextMetrics(Dc, &g_Fonts[FontIndex].Metrics))
        {
            return FALSE;
        }
    }

    ReleaseDC(NULL, Dc);

    InitColors();

    // Register message for FINDMSGSTRING.
    g_FindMsgString = RegisterWindowMessage(FINDMSGSTRING);

    // Look up FindWindowEx.
    HMODULE User32 = GetModuleHandle("user32.dll");
    if (User32 != NULL)
    {
        g_FlashWindowEx = (PFN_FlashWindowEx)
            GetProcAddress(User32, "FlashWindowEx");
    }
    
    //
    // Initialize window lists
    //
    InitializeListHead(&g_ActiveWin);

    Dbg(g_hMainAccTable = LoadAccelerators(g_hInst, MAKEINTRESOURCE(MAIN_ACC)));
    Dbg(LoadString(g_hInst, SYS_Main_wClass, szClassName, MAX_MSG_TXT));

    InitializeListHead(&g_StateList);

    __try
    {
        Dbg_InitializeCriticalSection( &g_QuickLock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    RECT WorkRect;
    RECT FrameRect;

    //
    // Try and create an initial window that's ready to work
    // without resizing.  Our goal here is to grab enough
    // screen space to given plenty of room for MDI windows
    // but not so much we might as well be maximized.
    //
    
    Dbg(SystemParametersInfo(SPI_GETWORKAREA, 0, &WorkRect, FALSE));

    // We don't want to take up more than 80% of either dimension.
    FrameRect.right = (WorkRect.right - WorkRect.left) * 4 / 5;
    FrameRect.bottom = (WorkRect.bottom - WorkRect.top) * 4 / 5;

    // We want width for an 80-character window plus space for
    // another narrow window like the CPU window.  We want
    // height for a forty row window plus space for a short
    // window like the stack.
    // If we can't get that much room just let the system
    // take charge.
    if (FrameRect.right < (CMD_WIDTH + CPU_WIDTH_32) ||
        FrameRect.bottom < (CMD_HEIGHT + CALLS_HEIGHT))
    {
        SetRect(&FrameRect, CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT);
    }
    else
    {
        // Hug the bottom left corner of the screen to
        // try and keep out of the way as much as possible
        // while still allowing the first bits of the
        // window to be seen.
        FrameRect.left = WorkRect.left;
        FrameRect.top = (WorkRect.bottom - WorkRect.top) - FrameRect.bottom;
    }
    
    //
    //  Create the frame
    //
    g_hwndFrame = CreateWindow(szClassName, 
                               g_MainTitleText,
                               WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN
                               | WS_VISIBLE,
                               FrameRect.left,
                               FrameRect.top,
                               FrameRect.right,
                               FrameRect.bottom,
                               NULL, 
                               NULL, 
                               g_hInst,
                               NULL
                               );

    //
    // Initialize the debugger
    //
    if ( !g_hwndFrame || !g_hwndMDIClient )
    {
        return FALSE;
    }

    //
    //  Get handle to main menu, window submenu, MRU submenu
    //
    Dbg( g_hmenuMain = GetMenu(g_hwndFrame) );
    g_hmenuMainSave = g_hmenuMain;

    Dbg( g_hmenuWindowSub = GetSubMenu(g_hmenuMain, WINDOWMENU) );

    Dbg( g_MruMenu = GetSubMenu(g_hmenuMain, FILEMENU) );
    Dbg( g_MruMenu = GetSubMenu(g_MruMenu,
                                IDM_FILE_MRU_FILE1 - IDM_FILE - 1) );

    //
    //  Init Items Colors ,Environment and RunDebug params to their default
    //  values 'They will later be overrided by the values in .INI file
    //  but we ensure to have something coherent even if we can't load
    //  the .INI file
    //
    InitDefaults();
    SymSetParentWindow(g_hwndFrame);

    //
    //  Initialize Keyboard Hook
    //
    hKeyHook = SetWindowsHookEx(WH_KEYBOARD, 
                                KeyboardHook,
                                g_hInst,
                                GetCurrentThreadId()    
                                );

    return TRUE;
}


int
WINAPIV
main(
    int argc,
    PTSTR argv[ ],
    PTSTR envp[]
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argc - Supplies the count of arguments on command line.

    argv - Supplies a pointer to an array of string pointers.

Return Value:

    int - Returns the wParam from the WM_QUIT message.
    None.

--*/

{
    HRESULT Status;
    CHAR helpfile[MAX_PATH];

    g_ProgramName = argv[0];
    g_hInst = GetModuleHandle(NULL);
    g_DefPriority = GetPriorityClass(GetCurrentProcess());

    GetEditorCommandDefaults();
    
    Dbg(LoadString(g_hInst, SYS_Help_File, helpfile, sizeof(helpfile)));
    MakeHelpFileName(helpfile);

    // We need to initialize COM so that we can use SHBrowseForFolder.
    if (FAILED(Status = CoInitializeEx(NULL, COM_THREAD_MODEL)))
    {
        InternalError(Status, "CoInitializeEx");
        return FALSE;
    }

    // Initialize enough of the GUI to bring up the top level window
    // so the menus can be activated.

    if (!InitGUI())
    {
        InternalError(E_OUTOFMEMORY, "InitGUI");
        return FALSE;
    }

    if (!CreateUiInterfaces(FALSE, NULL))
    {
        InternalError(E_OUTOFMEMORY, "CreateUiInterfaces");
        return FALSE;
    }

    // Select the default workspace.
    if ((Status = UiSwitchWorkspace(WSP_NAME_BASE, g_WorkspaceDefaultName,
                                    WSP_CREATE_ALWAYS, WSP_APPLY_DEFAULT,
                                    NULL)) != S_OK)
    {
        //InternalError(Status, "DefaultWorkspace");
    }
    
    // Parse the command line.
    // We need to do this before any GUI window is created to support the
    // journaling option.

    if (!ParseCommandLine(TRUE))
    {
        return FALSE;
    }

    // Enter main message loop.
    for (;;)
    {
        WaitMessage();
        ProcessPendingMessages();

        if (g_Exit)
        {
            break;
        }

        //
        // Check for any engine work that needs to be done.
        //

        ULONG EventSeq = g_CodeBufferSequence;
        if (EventSeq != g_CodeDisplaySequence)
        {
            // We don't want to stall the engine during
            // file loading so capture the state and then
            // release the lock.

            Dbg_EnterCriticalSection(&g_QuickLock);

            ULONG64 Ip = g_CodeIp;
            char FoundFile[MAX_SOURCE_PATH];
            char SymFile[MAX_SOURCE_PATH];
            char PathComp[MAX_SOURCE_PATH];
            strcpy(FoundFile, g_CodeFileFound);
            strcpy(SymFile, g_CodeSymFile);
            strcpy(PathComp, g_CodePathComponent);
            ULONG Line = g_CodeLine;
            BOOL UserActivated = g_CodeUserActivated;

            Dbg_LeaveCriticalSection(&g_QuickLock);

            UpdateCodeDisplay(Ip, FoundFile[0] ? FoundFile : NULL,
                              SymFile, PathComp[0] ? PathComp : NULL,
                              Line, UserActivated);
            g_CodeDisplaySequence = EventSeq;
        }

        LockUiBuffer(&g_UiOutputBuffer);

        if (g_UiOutputBuffer.GetDataLen() > 0 &&
            (!g_HoldWaitOutput || !g_WaitingForEvent))
        {
            PSTR Text, End;
            COLORREF Fg, Bg;

            Text = (PSTR)g_UiOutputBuffer.GetDataBuffer();
            End = Text + g_UiOutputBuffer.GetDataLen();
            while (Text < End)
            {
                GetOutMaskColors(*(ULONG UNALIGNED *)Text, &Fg, &Bg);
                Text += sizeof(ULONG);
                CmdOutput(Text, Fg, Bg);
                Text += strlen(Text) + 1;
            }
            
            g_UiOutputBuffer.Empty();
        }

        UnlockUiBuffer(&g_UiOutputBuffer);
    }

    TerminateApplication(FALSE);
    
    // Keep the C++ compiler from whining
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\delrp\delrp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    delrp.c

    This module contains a simple program to blatantly delete a reparse point
    of any kind.

Author:

    Felipe Cabrera   (Cabrera)   11-Jul-1997

Revision History:


--*/
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>          //  exit
#include <io.h>              //  _get_osfhandle

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <locale.h>         //  setlocale

//
//
//  Functions forward referenced.
//

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    );

void
ScanArgs (
    int argc,
    char **argv
    );

void
__cdecl
printmessage (
    DWORD messageID,
    ...
    );

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    );

int
FileIsConsole (
    int fh
    );

//
//  I/O stream  handles and variables.
//

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

//
// Core control state vars
//

BOOLEAN     NeedHelp;

#include "delrpmsg.h"

TCHAR Buf[1024];                            // for displaying stuff

//
//  Main
//

void
__cdecl
main(
    int  argc,
    char **argv
    )
/*++

Routine Description:

    Main procedure for pentnt.

    First, we call a series of routines that build a state vector
    in some booleans.

    We'll then act on these control variables:

        NeedHelp -  User has asked for help, or made a command error

Arguments:

    argc - count of arguments, including the name of our proggram

    argv - argument list - see command line syntax above

Return Value:

    Exit(0) - the file was deleted

    Exit(1) - a problem ocurred.

--*/

{
    CHAR    lBuf[16];
    DWORD   dwCodePage;
    LANGID  LangId;

    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    UNICODE_STRING UnicodeName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    FILE_DISPOSITION_INFORMATION Disposition = {TRUE};
    WCHAR WFileName[MAX_PATH];

    //
    // Build up state vector in global booleans.
    //

    ScanArgs(argc, argv);

    //
    // printf( "argc = %d NeedHelp = %d\n", argc, NeedHelp );
    //

    //
    // Since FormatMessage checks the current TEB's locale, and the Locale for
    // CHCP is initialized when the message class is initialized, the TEB has to
    // be updated after the code page is changed successfully.

    // Why are we doing this, you ask.  Well, the FE guys have plans to add
    // more than one set of language resources to this module, but not all
    // the possible resources.  So this limited set is what they plan for.
    // If FormatMessage can't find the right language, it falls back to
    // something hopefully useful.
    //

    dwCodePage = GetConsoleOutputCP();

    sprintf(lBuf, ".%d", dwCodePage);

    switch( dwCodePage )
    {
    case 437:
        LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
        break;
    case 932:
        LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
        break;
    case 949:
        LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
        break;
    case 936:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
        break;
    case 950:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
        break;
    default:
        LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
        lBuf[0] = '\0';
        break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    setlocale(LC_ALL, lBuf);

    //
    //  Set the appropriate handles.
    //

    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);

    //
    // OK, we know the state of the command, do work
    //

    //
    // If they asked for help, or did something that indicates they don't
    // understand how the program works, print help and exit.
    //

    if (NeedHelp) {
        printmessage( MSG_DELRP_HELP );
        exit(1);
    }

    //
    //  Change the string to Unicode and pass down to open the file.
    //

    SzToWsz( WFileName, argv[1] );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                             WFileName,
                             &UnicodeName,
                             NULL,
                             NULL
                             );

    if (!TranslationStatus) {
        printmessage( MSG_DELRP_WRONG_NAME );
        exit(1);
    }

    FreeBuffer = UnicodeName.Buffer;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // printf( "Transformed unicode str is %Z\n", &UnicodeName );
    //

    //
    // Open the file for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    // This will get a handle to the entity whether the appropriate filter is or not in place.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if (!NT_SUCCESS(Status)) {

        SzToWsz( WFileName, argv[1] );
        swprintf(&Buf[0], TEXT("%s"), WFileName);
        DisplayMsg(MSG_DELRP_OPEN_FAILED_NL, Buf);

        // printmessage( MSG_DELRP_OPEN_FAILED );

        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
        exit(1);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        printmessage( MSG_DELRP_DELETE_FAILED );
        exit(1);
    }

    exit(0);
}  // main



VOID
ScanArgs(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    ScanArgs - parse command line arguments, and set control flags
                to reflect what we find.

    Sets NeedHelp.

Arguments:

    argc - count of command line args

    argv - argument vector

Return Value:

--*/
{
    int i;

    NeedHelp = FALSE;

    if ((argc == 1) ||
        (argc > 3)) {
        NeedHelp = TRUE;
        goto done;
    }

    //
    //  At this point argc == 2
    //

    if ((argv[1][0] == '/') &&
        (argv[1][1] == '?') &&
        (strlen(argv[1]) == 2)) {
        NeedHelp = TRUE;
        goto done;
    }

done:
    return;
} // ScanArgs


//
//  Changing a file name to wide characters.
//

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
    return;
} // SzToWsz


//
// Call FormatMessage and dump the result.  All messages to Stdout
//
void
__cdecl
printmessage (
    DWORD messageID,
    ...
    )
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    wprintf(messagebuffer);

    va_end(ap);
}  // printmessage


TCHAR DisplayBuffer[4096];
CHAR DisplayBuffer2[4096];

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0,
        DisplayBuffer, 4096, &ap);

    if (ConsoleOutput) {
        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len,
                 &bytes_written, NULL);
    }

    if (!success || bytes_written != len) {
        status = GetLastError();
    }

    va_end(ap);
} // DisplayMsg


int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

} // FileIsConsole
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\windbg.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Windbg.h

Abstract:

    Main header file for the Windbg debugger.

--*/

#if ! defined( _WINDBG_ )
#define _WINDBG_

//----------------------------------------------------------------------------
//
// Global limit constants.
//
//----------------------------------------------------------------------------

#define MAX_MSG_TXT         4096    //Max text width in message boxes

#define TMP_STRING_SIZE     8192    //All purpose strings

#define MAX_CMDLINE_TXT     8192    //Max size for command line
#define MAX_VAR_MSG_TXT     8192    //Max size of a message built at run-time

#define MAX_LINE_SIZE       512     //Max inside length of editor line
#define MAX_USER_LINE       MAX_LINE_SIZE //Max length of user line

//----------------------------------------------------------------------------
//
// UI constants.
//
//----------------------------------------------------------------------------

//
//  Private window messages
//

#define WU_UPDATE               (WM_USER + 0)
#define WU_INVALIDATE           (WM_USER + 1)
#define WU_START_ENGINE         (WM_USER + 2)
#define WU_ENGINE_STARTED       (WM_USER + 3)
#define WU_SWITCH_WORKSPACE     (WM_USER + 4)
#define WU_ENGINE_IDLE          (WM_USER + 5)
#define WU_RECONFIGURE          (WM_USER + 6)

// Position of window menu.
#define WINDOWMENU              4

// Position of file menu.
#define FILEMENU                0

// Toolbar control identifier.
#define ID_TOOLBAR              100

// Generic customize button ID.
#define ID_CUSTOMIZE            29876
// Generic show/hide toolbar button ID.
#define ID_SHOW_TOOLBAR         29877

// For MDI default menu handling.
#define IDM_FIRSTCHILD      30000

/*
**  Include the defines which are used have numbers for string
**      resources.
*/

#include "res_str.h"

//----------------------------------------------------------------------------
//
// Variables.
//
//----------------------------------------------------------------------------

// Set when the debugger is exiting.
extern BOOL g_Exit;

extern ULONG g_CommandLineStart;
extern ULONG g_DefPriority;

enum QUIET_MODES
{
    QMODE_DISABLED,
    QMODE_ALWAYS_NO,
    QMODE_ALWAYS_YES,
};

extern QUIET_MODES g_QuietMode;
extern QUIET_MODES g_QuietSourceMode;

typedef BOOL (WINAPI* PFN_FlashWindowEx)(PFLASHWINFO pfwi);

extern PFN_FlashWindowEx g_FlashWindowEx;

//Handle to instance data
extern HINSTANCE g_hInst;

//Main window frame
extern HWND g_hwndFrame;

// Handle to MDI client
extern HWND g_hwndMDIClient;

// Width and height of MDI client.
extern ULONG g_MdiWidth, g_MdiHeight;

//Handle to accelerator table
extern HACCEL g_hMainAccTable;

//Keyboard Hooks functions
extern HHOOK hKeyHook;

// menu that belongs to g_hwndFrame
extern HMENU g_hmenuMain;
extern HMENU g_hmenuMainSave;

//Window submenu
extern HMENU g_hmenuWindowSub;

// WinDBG title text
extern TCHAR g_MainTitleText[MAX_MSG_TXT];

extern TCHAR g_ExeFilePath[MAX_PATH];
extern TCHAR g_DumpFilePath[MAX_PATH];
extern TCHAR g_SrcFilePath[MAX_PATH];

enum
{
    COL_PLAIN,
    COL_PLAIN_TEXT,
    COL_CURRENT_LINE,
    COL_CURRENT_LINE_TEXT,
    COL_BP_CURRENT_LINE,
    COL_BP_CURRENT_LINE_TEXT,
    COL_ENABLED_BP,
    COL_ENABLED_BP_TEXT,
    COL_DISABLED_BP,
    COL_DISABLED_BP_TEXT,
    COL_CHANGED_DATA_TEXT,
    COL_DISABLED_WINDOW,
    
    COL_COUNT
};

#define OUT_MASK_COL_BASE  0xff00
#define OUT_MASK_COL_COUNT 66

#define USER_OUT_MASK_COL 64

struct INDEXED_COLOR
{
    PSTR Name;
    COLORREF Color;
    COLORREF Default;
    HBRUSH Brush;
};

extern INDEXED_COLOR g_Colors[];
extern INDEXED_COLOR g_OutMaskColors[];

#define CUSTCOL_COUNT 16

extern COLORREF g_CustomColors[];

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);

void UpdateFrameTitle(void);
void SetTitleServerText(PCSTR Format, ...);
void SetTitleSessionText(PCSTR Format, ...);
void SetTitleExplicitText(PCSTR Text);
void UpdateTitleSessionText(void);

BOOL CreateUiInterfaces(BOOL Remote, LPTSTR CreateOptions);
void ReleaseUiInterfaces(void);
BOOL ParseCommandLine(BOOL FirstParse);

#define StartDebugging() \
    PostMessage(g_hwndFrame, WU_START_ENGINE, 0, 0)
void StopDebugging(BOOL UserRequest);
void ClearDebuggingParams(void);
void TerminateApplication(BOOL Cancellable);

INDEXED_COLOR* GetIndexedColor(ULONG Index);
BOOL SetColor(ULONG Index, COLORREF Color);
BOOL GetOutMaskColors(ULONG Mask, COLORREF* Fg, COLORREF* Bg);

//----------------------------------------------------------------------------
//
// Macros.
//
//----------------------------------------------------------------------------

// Dbg have to be used for every assertion during Debugging time.
// If false Dbg Opens a fatal error message Box and Stops program

// Standard function to prompt an Assertion False
void ShowAssert(PTSTR condition, UINT line, PTSTR file);


// First, a sanity check
#ifdef Dbg
#undef Dbg
#endif


// Assert are assertions that will stay in final Release.
// If false Assert Opens a fatal error message Box and Stops program
#define RAssert(condition)  \
    {                               \
        if (!(condition))    \
        {                    \
            ShowAssert( _T(#condition), __LINE__, _T(__FILE__) );  \
        }                           \
    }


#ifdef DBG

#define Assert          RAssert
#define Dbg             RAssert

#else // !DBG

//#pragma warning(disable: 4553)      // disable warnings for pure expressions
//#pragma warning(disable: 4552)      // disable level 4 warnings
#define Assert(x)       ((void)0)
#define Dbg(condition)  condition

#endif

#endif // _WINDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\wrkspace.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    wrkspace.cpp

Abstract:

    This module contains the workspace implementation.

--*/

#include "precomp.hxx"
#pragma hdrstop

// #define DBG_WSP

#define WSP_ALIGN(Size) (((Size) + 7) & ~7)
#define WSP_GROW_BY 1024

#if DBG
#define SCORCH_ENTRY(Entry) \
    memset((Entry) + 1, 0xdb, (Entry)->FullSize - sizeof(*(Entry)))
#else
#define SCORCH_ENTRY(Entry)
#endif

ULONG g_WspSwitchKey;
TCHAR g_WspSwitchValue[MAX_PATH];
BOOL g_WspSwitchBufferAvailable = TRUE;

Workspace* g_Workspace;
BOOL g_ExplicitWorkspace;

char* g_WorkspaceKeyNames[] =
{
    "",
    "Kernel",
    "User",
    "Dump",
    "Remote",
    "Explicit",
    "File",
};
char* g_WorkspaceDefaultName = "Default";

char* g_WorkspaceKeyDescriptions[] =
{
    "Base workspace",
    "Kernel mode workspaces",
    "User mode workspaces",
    "Dump file workspaces",
    "Remote client workspaces",
    "User-saved workspaces",
    "Workspaces in files",
};

Workspace::Workspace(void)
{
    m_Flags = 0;
    
    m_Data = NULL;
    m_DataLen = 0;
    m_DataUsed = 0;

    m_Key = WSP_NAME_BASE;
    m_Value = NULL;
}

Workspace::~Workspace(void)
{
    free(m_Data);
    free(m_Value);
}
    
WSP_ENTRY*
Workspace::Get(WSP_TAG Tag)
{
    WSP_ENTRY* Entry = NULL;
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if (Entry->Tag == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

WSP_ENTRY*
Workspace::GetNext(WSP_ENTRY* Entry, WSP_TAG Tag, WSP_TAG TagMask)
{
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

WSP_ENTRY*
Workspace::GetString(WSP_TAG Tag, PSTR Str, ULONG MaxSize)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        if (Entry->DataSize > MaxSize)
        {
            return NULL;
        }

        strcpy(Str, WSP_ENTRY_DATA(PSTR, Entry));
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::GetAllocString(WSP_TAG Tag, PSTR* Str)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        *Str = (PSTR)malloc(Entry->DataSize);
        if (*Str == NULL)
        {
            return NULL;
        }

        strcpy(*Str, WSP_ENTRY_DATA(PSTR, Entry));
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::GetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        if (Entry->DataSize != Size)
        {
            return NULL;
        }

        memcpy(Buf, WSP_ENTRY_DATA(PUCHAR, Entry), Size);
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::Set(WSP_TAG Tag, ULONG Size)
{
    WSP_ENTRY* Entry;
    ULONG FullSize;

    // Compute full rounded size.
    FullSize = sizeof(WSP_ENTRY) + WSP_ALIGN(Size);
    
    // Check and see if there's already an entry.
    Entry = Get(Tag);
    if (Entry != NULL)
    {
        // If it's already large enough use it and
        // pack in remaining data.
        if (Entry->FullSize >= FullSize)
        {
            ULONG Pack = Entry->FullSize - FullSize;
            if (Pack > 0)
            {
                PackData((PUCHAR)Entry + FullSize, Pack);
                Entry->FullSize = (USHORT)FullSize;
            }

            Entry->DataSize = (USHORT)Size;
            SCORCH_ENTRY(Entry);
            m_Flags |= WSPF_DIRTY_WRITE;
            return Entry;
        }

        // Entry is too small so remove it.
        PackData((PUCHAR)Entry, Entry->FullSize);
    }

    return Add(Tag, Size);
}

WSP_ENTRY*
Workspace::SetString(WSP_TAG Tag, PCSTR Str)
{
    ULONG Size = strlen(Str) + 1;
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(WSP_ENTRY_DATA(PSTR, Entry), Str, Size);
    }

    return Entry;
}

WSP_ENTRY*
Workspace::SetStrings(WSP_TAG Tag, ULONG Count, PCSTR* Strs)
{
    ULONG i;
    ULONG Size = 0;

    for (i = 0; i < Count; i++)
    {
        Size += strlen(Strs[i]) + 1;
    }
    // Put a double terminator at the very end.
    Size++;
    
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        PSTR Data = WSP_ENTRY_DATA(PSTR, Entry);
        
        for (i = 0; i < Count; i++)
        {
            Size = strlen(Strs[i]) + 1;
            memcpy(Data, Strs[i], Size);
            Data += Size;
        }
        *Data = 0;
    }

    return Entry;
}

WSP_ENTRY*
Workspace::SetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size)
{
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(WSP_ENTRY_DATA(PUCHAR, Entry), Buf, Size);
    }

    return Entry;
}

WSP_ENTRY*
Workspace::Add(WSP_TAG Tag, ULONG Size)
{
    // Compute full rounded size.
    ULONG FullSize = sizeof(WSP_ENTRY) + WSP_ALIGN(Size);
    
    WSP_ENTRY* Entry = AllocateEntry(FullSize);
    if (Entry != NULL)
    {
        Entry->Tag = Tag;
        Entry->FullSize = (USHORT)FullSize;
        Entry->DataSize = (USHORT)Size;
        SCORCH_ENTRY(Entry);
        m_Flags |= WSPF_DIRTY_WRITE;
    }

    return Entry;
}

void
Workspace::DeleteEntry(WSP_ENTRY* Entry)
{
    if (ValidEntry(Entry))
    {
        PackData((PUCHAR)Entry, Entry->FullSize);
    }
}

ULONG
Workspace::Delete(WSP_TAG Tag, WSP_TAG TagMask)
{
    ULONG Deleted = 0;
    WSP_ENTRY* Entry = NextEntry(NULL);

    while (Entry != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            DeleteEntry(Entry);
            Deleted++;
            m_Flags |= WSPF_DIRTY_WRITE;

            // Check and see if we packed away the last entry.
            if (!ValidEntry(Entry))
            {
                break;
            }
        }
        else
        {
            Entry = NextEntry(Entry);
        }
    }
    
    return Deleted;
}

void
Workspace::Empty(void)
{
    // Reset used to just the header.
    m_DataUsed = sizeof(WSP_HEADER);
    
    // Nothing is dirty now except the write of emptiness.
    m_Flags = (m_Flags & ~WSPF_DIRTY_ALL) | WSPF_DIRTY_WRITE;
}

PTSTR
Workspace::GetName(BOOL Verbose)
{
    static TCHAR s_Buffer[MAX_PATH];

    s_Buffer[0] = 0;
    
    if (Verbose)
    {
        PSTR Type;

        switch(m_Key)
        {
        case WSP_NAME_FILE:
            Type = "File: ";
            break;
        case WSP_NAME_EXPLICIT:
            Type = "Explicit: ";
            break;
        default:
            Type = "Implicit: ";
            break;
        }
        
        CatString(s_Buffer, Type, DIMA(s_Buffer));
    }
        
    if (m_Key != WSP_NAME_FILE && !strcmp(m_Value, g_WorkspaceDefaultName))
    {
        if (m_Key == WSP_NAME_BASE)
        {
            CatString(s_Buffer, "base", DIMA(s_Buffer));
        }
        else
        {
            CatString(s_Buffer, g_WorkspaceKeyNames[m_Key], DIMA(s_Buffer));
            CatString(s_Buffer, " default", DIMA(s_Buffer));
        }
    }
    else
    {
        CatString(s_Buffer, m_Value, DIMA(s_Buffer));
    }

    return s_Buffer;
}

HRESULT
Workspace::Create(ULONG Key, PTSTR Value,
                  Workspace** NewWsp)
{
    Workspace* Wsp = new Workspace;
    if (Wsp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Wsp->m_Key = Key;
    if (Value != NULL)
    {
        Wsp->m_Value = _tcsdup(Value);
        if (Wsp->m_Value == NULL)
        {
            delete Wsp;
            return E_OUTOFMEMORY;
        }
    }

    WSP_ENTRY* Entry;
    WSP_HEADER* Header;

    // Allocate intial space for the header and eight
    // small entries.  The workspace grows by large amounts
    // so this will immediately allocate a reasonable chunk.
    Entry = Wsp->AllocateEntry(sizeof(WSP_HEADER) +
                               8 * (sizeof(WSP_ENTRY) + 2 * sizeof(ULONG64)));
    if (Entry == NULL)
    {
        delete Wsp;
        return E_OUTOFMEMORY;
    }
    
    Header = (WSP_HEADER*)Entry;
    Header->Signature = WSP_SIGNATURE;
    Header->Version = WSP_VERSION;
    
    // Reset used to just the header.
    Wsp->m_DataUsed = sizeof(*Header);

    // Start out dirty so the workspace will be written
    // out and therefore can be opened later.
    Wsp->m_Flags |= WSPF_DIRTY_WRITE;

    *NewWsp = Wsp;
    return S_OK;
}

HRESULT
Workspace::ReadFromReg(void)
{
    HRESULT Status;
    HKEY RegKey;
    LONG RegStatus;
    BOOL InPrimary;

    //
    // First check and see if the value exists under the
    // primary key.  If not, check the secondary key.
    //
    
    RegKey = OpenKey(TRUE, m_Key, FALSE);
    if (RegKey)
    {
        RegStatus = RegQueryValueEx(RegKey, m_Value, NULL, NULL, NULL, NULL);
        if (RegStatus != ERROR_SUCCESS && RegStatus != ERROR_MORE_DATA)
        {
            RegCloseKey(RegKey);
            RegKey = NULL;
        }
    }
    if (RegKey == NULL)
    {
        RegKey = OpenKey(FALSE, m_Key, FALSE);
        if (RegKey == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
        
        InPrimary = FALSE;
    }
    else
    {
        InPrimary = TRUE;
    }
    
    DWORD Type;
    DWORD Size;

    Size = 0;
    RegStatus = RegQueryValueEx(RegKey, m_Value, NULL, &Type, NULL, &Size);
    if (RegStatus != ERROR_SUCCESS && RegStatus != ERROR_MORE_DATA)
    {
        Status = HRESULT_FROM_WIN32(RegStatus);
        goto EH_Key;
    }
    if (Type != REG_BINARY ||
        WSP_ALIGN(Size) != Size)
    {
        Status = E_INVALIDARG;
        goto EH_Key;
    }

    WSP_ENTRY* Entry;
    WSP_HEADER* Header;

    Entry = AllocateEntry(Size);
    if (Entry == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Key;
    }
    Header = (WSP_HEADER*)Entry;

    if (RegQueryValueEx(RegKey, m_Value, NULL, &Type, (LPBYTE)Header, &Size) !=
        ERROR_SUCCESS ||
        Header->Signature != WSP_SIGNATURE ||
        Header->Version != WSP_VERSION)
    {
        Status = E_INVALIDARG;
        goto EH_Key;
    }

    RegCloseKey(RegKey);

    //
    // If the workspace was read from the secondary key
    // migrate it to the primary and remove the secondary
    // entry.
    //

    if (!InPrimary)
    {
        if (WriteToReg() == S_OK)
        {
            DeleteReg(FALSE);
        }
    }
    
    return S_OK;
    
 EH_Key:
    RegCloseKey(RegKey);
    return Status;
}

HRESULT
Workspace::ReadFromFile(void)
{
    HRESULT Status;
    HANDLE File;

    File = CreateFile(m_Value, GENERIC_READ, FILE_SHARE_READ,
                      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!File || File == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }
    
    DWORD Size = GetFileSize(File, NULL);
    if (Size == INVALID_FILE_SIZE ||
        WSP_ALIGN(Size) != Size)
    {
        Status = E_INVALIDARG;
        goto EH_File;
    }

    WSP_ENTRY* Entry;
    WSP_HEADER* Header;

    Entry = AllocateEntry(Size);
    if (Entry == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_File;
    }
    Header = (WSP_HEADER*)Entry;

    DWORD Done;
    
    if (!ReadFile(File, Header, Size, &Done, NULL) ||
        Done != Size ||
        Header->Signature != WSP_SIGNATURE ||
        Header->Version != WSP_VERSION)
    {
        Status = E_INVALIDARG;
        goto EH_File;
    }

    CloseHandle(File);
    return S_OK;
    
 EH_File:
    CloseHandle(File);
    return Status;
}

HRESULT
Workspace::Read(ULONG Key, PTSTR Value,
                Workspace** NewWsp)
{
    // Make sure basic structures preserve alignment.
    C_ASSERT(sizeof(WSP_HEADER) == WSP_ALIGN(sizeof(WSP_HEADER)));
    C_ASSERT(sizeof(WSP_ENTRY) == WSP_ALIGN(sizeof(WSP_ENTRY)));
    C_ASSERT(sizeof(WSP_COMMONWIN_HEADER) ==
             WSP_ALIGN(sizeof(WSP_COMMONWIN_HEADER)));

    HRESULT Status;
    
    Workspace* Wsp = new Workspace;
    if (Wsp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Wsp->m_Key = Key;
    if (Value != NULL)
    {
        Wsp->m_Value = _tcsdup(Value);
        if (Wsp->m_Value == NULL)
        {
            delete Wsp;
            return E_OUTOFMEMORY;
        }
    }

    if (Key == WSP_NAME_FILE)
    {
        Status = Wsp->ReadFromFile();
    }
    else
    {
        Status = Wsp->ReadFromReg();
    }
    if (Status != S_OK)
    {
        delete Wsp;
    }
    else
    {
        *NewWsp = Wsp;
    }
    return Status;
}

HRESULT
Workspace::ChangeName(ULONG Key, PTSTR Value, BOOL Force)
{
    if (!Force)
    {
        if (Key == WSP_NAME_FILE)
        {
            if (GetFileAttributes(Value) != -1)
            {
                return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            }
        }
        else
        {
            HKEY RegKey;

            //
            // Check and see if a workspace entry already
            // exists under the given name.  We only need
            // to check the primary key as we're only concerned
            // with overwriting and writing always occurs
            // to the primary key.
            //
    
            RegKey = OpenKey(TRUE, Key, FALSE);
            if (RegKey != NULL)
            {
                LONG RegStatus;

                RegStatus = RegQueryValueEx(RegKey, Value, NULL, NULL,
                                            NULL, NULL);

                RegCloseKey(RegKey);
            
                if (RegStatus == ERROR_SUCCESS || RegStatus == ERROR_MORE_DATA)
                {
                    return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                }
            }
        }
    }

    //
    // Swap the workspace name.
    //

    PTSTR NewValue;
    
    if (Value != NULL)
    {
        NewValue = _tcsdup(Value);
        if (NewValue == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        NewValue = NULL;
    }

    delete m_Value;
    m_Key = Key;
    m_Value = NewValue;
    // Need to write data out to the new location.
    m_Flags |= WSPF_DIRTY_WRITE;

    return S_OK;
}

void
Workspace::UpdateBreakpointInformation(void)
{
    HRESULT Status;
    
    Status = g_BpCmdsBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        // Clear old information.
        Delete(WSP_GLOBAL_BREAKPOINTS, WSP_TAG_MASK);

        // Only save an entry if there are breakpoints.
        // Minimum output is a newline and terminator so
        // don't count those.
        if (g_BpCmdsBuffer->GetDataLen() > 2)
        {
            PSTR Cmds = (PSTR)g_BpCmdsBuffer->GetDataBuffer();
            SetString(WSP_GLOBAL_BREAKPOINTS, Cmds);
        }
        
        UnlockStateBuffer(g_BpCmdsBuffer);
    }
}

void
Workspace::UpdateWindowInformation(void)
{
    // Clear old information.
    Delete(DEF_WSP_TAG(WSP_GROUP_WINDOW, 0), WSP_GROUP_MASK);

    //
    // Record the frame window state.
    //

    WINDOWPLACEMENT Place;

    Place.length = sizeof(Place);
    GetWindowPlacement(g_hwndFrame, &Place);
    SetBuffer(WSP_WINDOW_FRAME_PLACEMENT, &Place, sizeof(Place));
    
    //
    // Persist windows from the bottom of the Z order up
    // so that when they're recreated in the same order
    // the Z order is also recreated.
    //
    
    HWND Win = MDIGetActive(g_hwndMDIClient, NULL);
    if (Win == NULL ||
        (Win = GetWindow(Win, GW_HWNDLAST)) == NULL)
    {
        // No windows.
        return;
    }

    while (Win != NULL)
    {
        PCOMMONWIN_DATA WinData = GetCommonWinData(Win);
        if (WinData != NULL)
        {
            WSP_ENTRY* Entry;
            ULONG Size;

            Size = WinData->GetWorkspaceSize();
            Entry = Add(WSP_WINDOW_COMMONWIN_1,
                        Size + sizeof(WSP_COMMONWIN_HEADER));
            if (Entry != NULL)
            {
                WSP_COMMONWIN_HEADER* Hdr =
                    WSP_ENTRY_DATA(WSP_COMMONWIN_HEADER*, Entry);
                Hdr->Type = WinData->m_enumType;
                Hdr->Reserved = 0;

                if (Size > 0)
                {
                    WinData->SetWorkspace((PUCHAR)(Hdr + 1));
                }
            }
        }

        Win = GetWindow(Win, GW_HWNDPREV);
    }
}

void
Workspace::UpdateLogFileInformation(void)
{
    HRESULT Status;
    char LogFile[MAX_PATH];
    BOOL Append;
    ULONG FileLen;

    Status = g_pUiControl->GetLogFile(LogFile, sizeof(LogFile), NULL,
                                      &Append);
    if (Status != S_OK && Status != E_NOINTERFACE)
    {
        return;
    }

    // Clear old information.
    Delete(WSP_GLOBAL_LOG_FILE, WSP_TAG_MASK);

    if (Status == E_NOINTERFACE)
    {
        // No log is open.
        return;
    }
    
    FileLen = strlen(LogFile) + 1;
    
    WSP_ENTRY* Entry = Set(WSP_GLOBAL_LOG_FILE, sizeof(BOOL) + FileLen);
    if (Entry != NULL)
    {
        PSTR Data = WSP_ENTRY_DATA(PSTR, Entry);
        *(PBOOL)Data = Append;
        strcpy(Data + sizeof(Append), LogFile);
    }
}

void
Workspace::UpdatePathInformation(void)
{
    HRESULT Status;
    char Path[MAX_ENGINE_PATH];

    Status = g_pUiSymbols->GetSymbolPath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_SYMBOL_PATH, Path);
    }
    Status = g_pUiSymbols->GetImagePath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_IMAGE_PATH, Path);
    }
    Status = g_pUiSymbols->GetSourcePath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_SOURCE_PATH, Path);
    }

    // Local source path is only set explicitly.
}

void
Workspace::UpdateFilterInformation(void)
{
    HRESULT Status;
    
    Status = g_FilterBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        // Clear old information.
        Delete(WSP_GLOBAL_FILTERS, WSP_TAG_MASK);

        // Only save an entry if there are changes.
        // Minimum output is a newline and terminator so
        // don't count those.
        if (g_FilterWspCmdsOffset < g_FilterBuffer->GetDataLen() - 2)
        {
            PSTR Cmds = (PSTR)g_FilterBuffer->GetDataBuffer() +
                g_FilterWspCmdsOffset;
            SetString(WSP_GLOBAL_FILTERS, Cmds);
        }
        
        UnlockStateBuffer(g_FilterBuffer);
    }
}

void
Workspace::UpdateMruListInformation(void)
{
    ULONG Size;
    WSP_ENTRY* Entry;
    
    // Clear old information.
    Delete(WSP_GLOBAL_MRU_LIST, WSP_TAG_MASK);

    Size = GetMruSize();
    Entry = Set(WSP_GLOBAL_MRU_LIST, Size);
    if (Entry != NULL)
    {
        WriteMru(WSP_ENTRY_DATA(PUCHAR, Entry));
    }
}

void
Workspace::UpdateAliasInformation(void)
{
    HRESULT Status;
    
    Status = g_AliasBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        // Clear old information.
        Delete(WSP_GLOBAL_ALIASES, WSP_TAG_MASK);

        // Only save an entry if there are changes.
        // Minimum output is a newline and terminator so
        // don't count those.
        if (g_AliasBuffer->GetDataLen() > 2)
        {
            SetString(WSP_GLOBAL_ALIASES,
                      (PSTR)g_AliasBuffer->GetDataBuffer());
        }
        
        UnlockStateBuffer(g_AliasBuffer);
    }
}

HRESULT
Workspace::WriteToReg(void)
{
    // Writing always occurs to the primary key.
    HKEY RegKey = OpenKey(TRUE, m_Key, TRUE);
    if (RegKey == NULL)
    {
        return E_FAIL;
    }
    
    LONG Status = RegSetValueEx(RegKey, m_Value, 0, REG_BINARY,
                                m_Data, m_DataUsed);

    RegCloseKey(RegKey);

    if (Status != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(Status);
    }
    else
    {
        m_Flags &= ~WSPF_DIRTY_ALL;
        return S_OK;
    }
}

HRESULT
Workspace::WriteToFile(void)
{
    HRESULT Status;
    HANDLE File;

    File = CreateFile(m_Value, GENERIC_WRITE, 0,
                      NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!File || File == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }
    
    DWORD Done;
    
    if (!WriteFile(File, m_Data, m_DataUsed, &Done, NULL) ||
        Done != m_DataUsed)
    {
        Status = WIN32_LAST_STATUS();
    }
    else
    {
        m_Flags &= ~WSPF_DIRTY_ALL;
        Status = S_OK;
    }

    CloseHandle(File);
    return Status;
}

void
Workspace::DeleteReg(BOOL Primary)
{
    DeleteRegKey(Primary, m_Key, m_Value);

    // We don't want to leave any dirty bits
    // on because the workspace would just be written
    // out again at the next flush.
    m_Flags &= ~WSPF_DIRTY_ALL;
}

void
Workspace::DeleteRegKey(BOOL Primary, ULONG Key, PTSTR Value)
{
    HKEY RegKey = OpenKey(Primary, Key, FALSE);
    if (RegKey != NULL)
    {
        RegDeleteValue(RegKey, Value);
        RegCloseKey(RegKey);
    }
}

HRESULT
Workspace::Flush(BOOL ForceSave, BOOL Cancellable)
{
    if (getenv("WINDBG_NO_WORKSPACE_WINDOWS") != NULL)
    {
        // Window layout saving is suppressed so don't
        // consider them dirty.
        m_Flags &= ~WSPF_DIRTY_WINDOWS;
    }
    
    if ((m_Flags & WSPF_DIRTY_ALL) == 0 ||
        (g_QuietMode == QMODE_ALWAYS_NO && !ForceSave))
    {
        return S_OK;
    }

#ifdef DBG_WSP
    DebugPrint("Workspace dirty flags %X\n", m_Flags & WSPF_DIRTY_ALL);
#endif
    
    int Answer;

    if (g_QuietMode == QMODE_ALWAYS_YES || ForceSave)
    {
        Answer = IDOK;
    }
    else
    {
        Answer = QuestionBox(STR_Save_Workspace,
                             Cancellable ? MB_YESNOCANCEL : MB_YESNO,
                             GetName(FALSE));
    }
    
    if (Answer == IDNO)
    {
        return S_OK;
    }
    else if (Answer == IDCANCEL)
    {
        Assert(Cancellable);
        return S_FALSE;
    }

    if (m_Flags & WSPF_DIRTY_BREAKPOINTS)
    {
        UpdateBreakpointInformation();
    }
    if (m_Flags & WSPF_DIRTY_WINDOWS)
    {
        UpdateWindowInformation();
    }
    if (m_Flags & WSPF_DIRTY_LOG_FILE)
    {
        UpdateLogFileInformation();
    }
    if (m_Flags & WSPF_DIRTY_PATHS)
    {
        UpdatePathInformation();
    }
    if (m_Flags & WSPF_DIRTY_FILTERS)
    {
        UpdateFilterInformation();
    }
    if (m_Flags & WSPF_DIRTY_MRU_LIST)
    {
        UpdateMruListInformation();
    }
    if (m_Flags & WSPF_DIRTY_ALIASES)
    {
        UpdateAliasInformation();
    }

    if (m_Key == WSP_NAME_FILE)
    {
        return WriteToFile();
    }
    else
    {
        return WriteToReg();
    }
}

WSP_ENTRY*
Workspace::AllocateEntry(ULONG FullSize)
{
    // Sizes must fit in USHORTs.  This shouldn't be
    // a big problem since workspaces shouldn't have
    // huge data items in them.
    if (FullSize > 0xffff)
    {
        return NULL;
    }
    
    if (m_DataUsed + FullSize > m_DataLen)
    {
        ULONG NewLen = m_DataLen;
        do
        {
            NewLen += WSP_GROW_BY;
        }
        while (m_DataUsed + FullSize > NewLen);
    
        PUCHAR NewData = (PUCHAR)realloc(m_Data, NewLen);
        if (NewData == NULL)
        {
            return NULL;
        }

        m_Data = NewData;
        m_DataLen = NewLen;
    }

    WSP_ENTRY* Entry = (WSP_ENTRY*)(m_Data + m_DataUsed);
    m_DataUsed += FullSize;
    return Entry;
}

void
Workspace::GetKeyName(ULONG Key, PSTR KeyName)
{
    _tcscpy(KeyName, WSP_REG_KEY);
    if (Key > WSP_NAME_BASE)
    {
        _tcscat(KeyName, "\\");
        _tcscat(KeyName, g_WorkspaceKeyNames[Key]);
    }
}
    
HKEY
Workspace::OpenKey(BOOL Primary, ULONG Key, BOOL Create)
{
    TCHAR KeyName[MAX_PATH];
    HKEY RegKey;
    HKEY Base = Primary ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    GetKeyName(Key, KeyName);
    if (Create)
    {
        if (RegCreateKeyEx(Base, KeyName, 0, NULL, 0,
                           KEY_ALL_ACCESS, NULL, &RegKey,
                           NULL) == ERROR_SUCCESS)
        {
            return RegKey;
        }
    }
    else if (RegOpenKeyEx(Base, KeyName, 0, KEY_ALL_ACCESS,
                          &RegKey) == ERROR_SUCCESS)
    {
        return RegKey;
    }

    return NULL;
}

int
Workspace::Apply(ULONG Flags)
{
    WSP_ENTRY* Entry;
    PUCHAR Data;
    BOOL UpdateColors = FALSE;
    int SessionStarts;
    ULONG MemWins = 0;
    RegisterNamesStateBuffer* NameBuf;

#ifdef DBG_WSP
    DebugPrint("Applying workspace %s%s%s with:\n",
               m_Key == NULL ? "" : m_Key,
               m_Key == NULL ? "" : "\\",
               m_Value);
#endif

    //
    // Scan for explicit session start entries first.
    // If any are present and a session is active
    // fail the apply before anything actually happens.
    //

    if ((Flags & (WSP_APPLY_AGAIN |
                  WSP_APPLY_EXPLICIT)) == WSP_APPLY_EXPLICIT &&
        g_EngineThreadId)
    {
        Entry = NULL;
        while ((Entry = NextEntry(Entry)) != NULL)
        {
            switch(Entry->Tag)
            {
            case WSP_GLOBAL_EXE_COMMAND_LINE:
            case WSP_GLOBAL_DUMP_FILE_NAME:
            case WSP_GLOBAL_ATTACH_KERNEL_FLAGS:
                return -1;
            }
        }
    }
    
    SessionStarts = 0;
    Entry = NULL;
    while ((Entry = NextEntry(Entry)) != NULL)
    {
#ifdef DBG_WSP
        DebugPrint("  %04X: Tag: %08X Size %X:%X\n",
                   (PUCHAR)Entry - m_Data, Entry->Tag,
                   Entry->DataSize, Entry->FullSize);
#endif

        // If this is a reapply only a subset of the
        // workspace is applied to prevent duplication
        // and problems.
        if ((Flags & WSP_APPLY_AGAIN) &&
            Entry->Tag != WSP_GLOBAL_BREAKPOINTS &&
            Entry->Tag != WSP_GLOBAL_REGISTER_MAP)
        {
            continue;
        }
        
        if (WSP_TAG_GROUP(Entry->Tag) == WSP_GROUP_COLORS)
        {
            if (SetColor(WSP_TAG_ITEM(Entry->Tag),
                         *WSP_ENTRY_DATA(COLORREF*, Entry)))
            {
                UpdateColors = TRUE;
            }
            continue;
        }
        
        switch(Entry->Tag)
        {
        case WSP_GLOBAL_SYMBOL_PATH:
            g_pUiSymbols->SetSymbolPath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_IMAGE_PATH:
            g_pUiSymbols->SetImagePath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_SOURCE_PATH:
            g_pUiSymbols->SetSourcePath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_WINDOW_OPTIONS:
            g_WinOptions = *WSP_ENTRY_DATA(PULONG, Entry);
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                Arrange();
            }
            break;
        case WSP_GLOBAL_REGISTER_MAP:
            NameBuf = GetRegisterNames(g_ActualProcType);
            if (NameBuf)
            {
                NameBuf->SetRegisterMap(Entry->DataSize / sizeof(USHORT),
                                        WSP_ENTRY_DATA(PUSHORT, Entry));
            }
            break;
        case WSP_GLOBAL_PROC_REGISTER_MAP:
            NameBuf = GetRegisterNames(*WSP_ENTRY_DATA(PULONG, Entry));
            if (NameBuf)
            {
                NameBuf->SetRegisterMap((Entry->DataSize - sizeof(ULONG)) /
                                        sizeof(USHORT),
                                        (PUSHORT)(WSP_ENTRY_DATA(PULONG,
                                                                 Entry) + 1));
            }
            break;
        case WSP_GLOBAL_PROC_FLAGS_REGISTER_MAP:
            NameBuf = GetRegisterNames(*WSP_ENTRY_DATA(PULONG, Entry));
            if (NameBuf)
            {
                NameBuf->m_Flags = *(WSP_ENTRY_DATA(PULONG, Entry) + 1);
                NameBuf->SetRegisterMap((Entry->DataSize - sizeof(ULONG)) /
                                        sizeof(USHORT),
                                        (PUSHORT)(WSP_ENTRY_DATA(PULONG,
                                                                 Entry) + 2));
            }
            break;
        case WSP_GLOBAL_BREAKPOINTS:
            Assert(Entry->DataSize > 1);
            AddStringMultiCommand(UIC_INVISIBLE_EXECUTE,
                                  WSP_ENTRY_DATA(PSTR, Entry), FALSE);
            break;
        case WSP_GLOBAL_LOG_FILE:
            Data = WSP_ENTRY_DATA(PUCHAR, Entry);
            g_pUiControl->OpenLogFile((PSTR)Data + sizeof(BOOL), *(PBOOL)Data);
            break;
        case WSP_GLOBAL_LOCAL_SOURCE_PATH:
            if (g_RemoteClient)
            {
                g_pUiLocSymbols->SetSourcePath(WSP_ENTRY_DATA(PSTR, Entry));
            }
            break;
        case WSP_GLOBAL_FILTERS:
            Assert(Entry->DataSize > 1);
            AddStringMultiCommand(UIC_INVISIBLE_EXECUTE,
                                  WSP_ENTRY_DATA(PSTR, Entry), FALSE);
            break;
        case WSP_GLOBAL_FIXED_LOGFONT:
            g_Fonts[FONT_FIXED].LogFont = *WSP_ENTRY_DATA(LPLOGFONT, Entry);
            CreateIndexedFont(FONT_FIXED, TRUE);
            break;
        case WSP_GLOBAL_TAB_WIDTH:
            SetTabWidth(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_MRU_LIST:
            Data = WSP_ENTRY_DATA(PUCHAR, Entry);
            ReadMru(Data, Data + Entry->DataSize);
            break;
        case WSP_GLOBAL_REPEAT_COMMANDS:
            if (*WSP_ENTRY_DATA(PULONG, Entry))
            {
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
            }
            else
            {
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
            }
            break;
        case WSP_GLOBAL_COM_SETTINGS:
            if (Entry->DataSize <= sizeof(g_ComSettings))
            {
                memcpy(g_ComSettings, WSP_ENTRY_DATA(PSTR, Entry),
                       Entry->DataSize);
                PrintAllocString(&g_KernelConnectOptions, 256,
                                 "com:port=%s,baud=%s", g_ComSettings,
                                 g_ComSettings + strlen(g_ComSettings) + 1);
            }
            break;
        case WSP_GLOBAL_1394_SETTINGS:
            if (Entry->DataSize <= sizeof(g_1394Settings))
            {
                memcpy(g_1394Settings, WSP_ENTRY_DATA(PSTR, Entry),
                       Entry->DataSize);
                PrintAllocString(&g_KernelConnectOptions, 256,
                                 "1394:channel=%s", g_1394Settings);
            }
            break;
        case WSP_GLOBAL_DISASM_ACTIVATE_SOURCE:
            g_DisasmActivateSource = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_VIEW_TOOL_BAR:
            CheckMenuItem(g_hmenuMain, IDM_VIEW_TOOLBAR,
                          *WSP_ENTRY_DATA(PULONG, Entry) ?
                          MF_CHECKED : MF_UNCHECKED);
            Show_Toolbar(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_VIEW_STATUS_BAR:
            CheckMenuItem(g_hmenuMain, IDM_VIEW_STATUS,
                          *WSP_ENTRY_DATA(PULONG, Entry) ?
                          MF_CHECKED : MF_UNCHECKED);
            Show_StatusBar(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_AUTO_CMD_SCROLL:
            g_AutoCmdScroll = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_SRC_FILE_PATH:
            CopyString(g_SrcFilePath, WSP_ENTRY_DATA(PSTR, Entry),
                       DIMA(g_SrcFilePath));
            break;
        case WSP_GLOBAL_EXE_COMMAND_LINE:
            if ((Flags & WSP_APPLY_EXPLICIT) &&
                DupAllocString(&g_DebugCommandLine,
                               WSP_ENTRY_DATA(PSTR, Entry)))
            {
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_EXE_CREATE_FLAGS:
            g_DebugCreateFlags = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_DUMP_FILE_NAME:
            if ((Flags & WSP_APPLY_EXPLICIT) &&
                DupAllocString(&g_DumpFiles[0],
                               WSP_ENTRY_DATA(PSTR, Entry)))
            {
                g_NumDumpFiles = 1;
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_ATTACH_KERNEL_FLAGS:
            if ((Flags & WSP_APPLY_EXPLICIT))
            {
                g_AttachKernelFlags = *WSP_ENTRY_DATA(PULONG, Entry);
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_TYPE_OPTIONS:
            {
                g_TypeOptions = *WSP_ENTRY_DATA(PULONG, Entry);
		if (g_pUiSymbols2 != NULL) 
		{
		    g_pUiSymbols2->SetTypeOptions(g_TypeOptions);
		}
            }
            break;
        case WSP_GLOBAL_DUMP_FILE_PATH:
            CopyString(g_DumpFilePath, WSP_ENTRY_DATA(PSTR, Entry),
                       DIMA(g_DumpFilePath));
            break;
        case WSP_GLOBAL_EXE_FILE_PATH:
            CopyString(g_ExeFilePath, WSP_ENTRY_DATA(PSTR, Entry),
                       DIMA(g_ExeFilePath));
            break;
        case WSP_GLOBAL_ASSEMBLY_OPTIONS:
            if (g_pUiControl3) 
            {
                g_pUiControl3->
                    SetAssemblyOptions(*WSP_ENTRY_DATA(PULONG, Entry));
            }
            break;
        case WSP_GLOBAL_EXPRESSION_SYNTAX:
            if (g_pUiControl3) 
            {
                g_pUiControl3->
                    SetExpressionSyntax(*WSP_ENTRY_DATA(PULONG, Entry));
            }
            break;
        case WSP_GLOBAL_ALIASES:
            Assert(Entry->DataSize > 1);
            AddStringMultiCommand(UIC_INVISIBLE_EXECUTE,
                                  WSP_ENTRY_DATA(PSTR, Entry), TRUE);
            break;
        case WSP_GLOBAL_PROCESS_START_DIR:
            if (Flags & WSP_APPLY_EXPLICIT)
            {
                DupAllocString(&g_ProcessStartDir,
                               WSP_ENTRY_DATA(PSTR, Entry));
            }
            break;
            
        case WSP_WINDOW_COMMONWIN_1:
            WSP_COMMONWIN_HEADER* Hdr;
            HWND Win;
            PCOMMONWIN_DATA WinData;

            Hdr = WSP_ENTRY_DATA(WSP_COMMONWIN_HEADER*, Entry);
            Win = New_OpenDebugWindow(Hdr->Type, TRUE, MemWins);
            if (Win != NULL &&
                (WinData = GetCommonWinData(Win)) != NULL &&
                Entry->DataSize > sizeof(WSP_COMMONWIN_HEADER))
            {
                Data = (PUCHAR)(Hdr + 1);
                WinData->m_InAutoOp++;
                WinData->ApplyWorkspace1(Data, Data +
                                         (Entry->DataSize -
                                          sizeof(WSP_COMMONWIN_HEADER)));
                WinData->m_InAutoOp--;
            }

            // A user can have as many open memory windows as
            // they like, which makes things a little tricky
            // for workspaces as applying stacked workspaces
            // could result in memory windows multiplying out
            // of control if the same set of memory windows
            // is saved in each workspace level.  To avoid
            // this and to function more like the other windows
            // we reuse memory windows from any that are
            // already in existence.
            if (Hdr->Type == MEM_WINDOW)
            {
                MemWins++;
            }
            break;
        case WSP_WINDOW_FRAME_PLACEMENT:
            LPWINDOWPLACEMENT Place;

            Place = WSP_ENTRY_DATA(LPWINDOWPLACEMENT, Entry);
            SetWindowPlacement(g_hwndFrame, Place);
            break;
        case WSP_WINDOW_FRAME_TITLE:
            SetTitleExplicitText(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        }
    }

    if (UpdateColors)
    {
        UpdateAllColors();
    }

    return SessionStarts;
}

HRESULT
UiSwitchWorkspace(ULONG Key, PTSTR Value, WSP_CREATE_OPTION Create,
                  ULONG Flags, int* SessionStarts)
{
    if (getenv("WINDBG_NO_WORKSPACE") != NULL)
    {
        return E_NOTIMPL;
    }
    
    HRESULT Status;
    Workspace* OldWsp;
    Workspace* NewWsp;
    int Starts = 0;

    Status = Workspace::Read(Key, Value, &NewWsp);
    if (Status != S_OK)
    {
        if (Status == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
            Create != WSP_OPEN_EXISTING)
        {
            if (Create == WSP_CREATE_QUERY)
            {
                if (QuestionBox(STR_Create_New_Workspace, MB_OKCANCEL) != IDOK)
                {
                    return Status;
                }
            }
            
            // Workspace does not exist so create a new one.
            Status = Workspace::Create(Key, Value, &NewWsp);
        }
        
        if (Status != S_OK)
        {
            return Status;
        }
    }

    // We have a new workspace ready to go so flush the old one.
    OldWsp = g_Workspace;
    if (OldWsp != NULL)
    {
        OldWsp->Flush(FALSE, FALSE);
    }

    // Apply the new workspace with no global workspace to
    // avoid writing changes into the workspace as we apply it.
    g_Workspace = NULL;
    if (NewWsp != NULL)
    {
        Starts = NewWsp->Apply(Flags);
        
        // Clear any window messages queued during the workspace
        // application so that they're processed with no
        // active workspace.
        ProcessPendingMessages();
    }

    if (SessionStarts != NULL)
    {
        *SessionStarts = Starts;
    }

    if (Starts < 0)
    {
        // Apply failed so put the old workspace back.
        g_Workspace = OldWsp;
        return E_FAIL;
    }
    else
    {
        // Apply succeeded to replace the old workspace.
        g_Workspace = NewWsp;
        delete OldWsp;
        return S_OK;
    }
}

void
UiSwitchToExplicitWorkspace(ULONG Key, PTSTR Value)
{
    HRESULT Status;
    int Starts = 0;
                
    if ((Status = UiSwitchWorkspace(Key, Value, WSP_OPEN_EXISTING,
                                    WSP_APPLY_EXPLICIT, &Starts)) != S_OK)
    {
        if (Starts < 0)
        {
            InformationBox(ERR_Workspace_Session_Conflict);
        }
        else
        {
            InformationBox(ERR_Cant_Open_Workspace,
                           FormatStatusCode(Status),
                           FormatStatus(Status));
        }
    }
    else
    {
        g_ExplicitWorkspace = TRUE;
        if (Starts == 1)
        {
            StartDebugging();
        }
    }
}

void
UiSaveWorkspaceAs(ULONG Key, PTSTR Value)
{
    HRESULT Status;
    
    Status = g_Workspace->ChangeName(Key, Value, FALSE);
    if (Status == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
    {
        if (QuestionBox(ERR_Workspace_Already_Exists, MB_YESNO, Value) == IDNO)
        {
            return;
        }
                
        Status = g_Workspace->ChangeName(Key, Value, TRUE);
    }

    if (Status != S_OK)
    {
        InformationBox(ERR_Cant_Save_Workspace,
                       FormatStatusCode(Status), FormatStatus(Status));
        return;
    }

    g_Workspace->Flush(TRUE, FALSE);
    g_ExplicitWorkspace = TRUE;
}

HRESULT
UiDelayedSwitchWorkspace(void)
{
    Assert(!g_WspSwitchBufferAvailable);
    
    HRESULT Status = UiSwitchWorkspace(g_WspSwitchKey, g_WspSwitchValue,
                                       WSP_CREATE_ALWAYS, WSP_APPLY_DEFAULT,
                                       NULL);

    // Mark the delayed switch buffer as available and
    // wait for acknowledgement.
    g_WspSwitchBufferAvailable = TRUE;
    while (g_WspSwitchValue[0])
    {
        Sleep(10);
    }        

    return Status;
}

void
EngSwitchWorkspace(ULONG Key, PTSTR Value)
{
    // If the user explicitly selected a workspace
    // don't override it due to engine activity.
    if (g_ExplicitWorkspace ||
        g_Exit)
    {
        return;
    }
    
    // We can't switch workspaces on the engine thread
    // because of the UI work involved.  Send the
    // switch over to the UI thread and wait for
    // it to be processed.

    Assert(g_WspSwitchBufferAvailable);
    g_WspSwitchBufferAvailable = FALSE;

    g_WspSwitchKey = Key;
    CopyString(g_WspSwitchValue, Value, DIMA(g_WspSwitchValue));
    PostMessage(g_hwndFrame, WU_SWITCH_WORKSPACE, 0, 0);

    if (g_pDbgClient != NULL)
    {
        // Temporarily disable event callbacks to keep
        // activity at a minimum while we're in this halfway state.
        g_pDbgClient->SetEventCallbacks(NULL);
    
        while (!g_WspSwitchBufferAvailable)
        {
            if (FAILED(g_pDbgClient->DispatchCallbacks(10)))
            {
                Sleep(10);
            }
        }

        g_pDbgClient->SetEventCallbacks(&g_EventCb);
    }
    else
    {
        while (!g_WspSwitchBufferAvailable)
        {
            Sleep(10);
        }
    }

    // We know that at this point the new workspace cannot be dirty
    // so just clear the dirty flags.

    if (g_Workspace)
    {
        g_Workspace->ClearDirty();
    }

    // Let the UI thread continue.
    g_WspSwitchKey = WSP_NAME_BASE;
    g_WspSwitchValue[0] = 0;
    Sleep(50);

    //
    // Warn the user is the workspace was not be created properly.
    //

    if (!g_Workspace)
    {
        InformationBox(ERR_NULL_Workspace, NULL);
        return;
    }
}

PSTR g_WspGlobalNames[] =
{
    "Symbol path", "Image path", "Source path", "Window menu checks",
    "Register customization", "Breakpoints", "Log file settings",
    "Local source path", "Event filter settings", "Fixed-width font",
    "Tab width", "MRU list", "Repeat commands setting", "COM port settings",
    "1394 settings", "Activate source windows in disassembly mode",
    "Show tool bar", "Show status bar", "Automatically scroll command window",
    "Source open dialog path", "Executable command line",
    "Executable create flags", "Dump file name", "Kernel attach flags",
    "Type options", "Dump open dialog path", "Executable open dialog path",
    "Per-processor register customization", "Assembly/disassembly options",
    "Expression evaluator syntax", "Command window text aliases",
    "Executable start directory", "Per-processor register customization",
};

PSTR g_WspWindowNames[] =
{
    "Child window settings", "WinDBG window settings", "WinDBG window title",
};

PSTR
GetWspTagName(WSP_TAG Tag)
{
    ULONG Item = WSP_TAG_ITEM(Tag);
    static char Buffer[128];
    
    switch(WSP_TAG_GROUP(Tag))
    {
    case WSP_GROUP_GLOBAL:
        if (Item < WSP_GLOBAL_COUNT)
        {
            C_ASSERT(DIMA(g_WspGlobalNames) == WSP_GLOBAL_COUNT);
            return g_WspGlobalNames[Item];
        }
        break;
    case WSP_GROUP_WINDOW:
        if (Item < WSP_WINDOW_COUNT)
        {
            C_ASSERT(DIMA(g_WspWindowNames) == WSP_WINDOW_COUNT);
            return g_WspWindowNames[Item];
        }
        break;
    case WSP_GROUP_COLORS:
        INDEXED_COLOR* IdxCol = GetIndexedColor(Item);
        if (IdxCol != NULL)
        {
            sprintf(Buffer, "%s color", IdxCol->Name);
            return Buffer;
        }
        break;
    }

    return "Unknown tag";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\delrp\makefile.inc ===
delrpmsg.rc: msg00001.bin

delrpmsg.h msg00001.bin: delrpmsg.mc
    mc -v -h .\ delrpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\dll\depends.cpp ===
//******************************************************************************
//
// File:        DEPENDS.CPP
//
// Description: Implementation file for DEPENDS.DLL
//
// Comments:    The code in this module should be kept small and simple since
//              it is going to be injected into another process. We would like
//              to minimize the effect our code has in the host process. To
//              help achieve this goal, all dependencies except for KERNEL32
//              have been removed.  KERNEL32 is ok since it is guaranteed to
//              already be loaded since it is needed as part of the injection
//              routine that gets our DLL into the address space to begin with.
//              We have also removed all C runtime dependencies except for some
//              exception handling code. Even that code, we get from the static
//              C runtime library so we don't drag in an extra DLL.
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
// 04/02/02  stevemil  Security review
//
//******************************************************************************


#include <windows.h>


//******************************************************************************
//***** Constants and Macros
//******************************************************************************

#define countof(a)   (sizeof(a)/sizeof(*(a)))

#define BUFFER_SIZE  2048
#define PSZ_COUNT    (sizeof(szBuffer) - (DWORD)(psz - szBuffer))


//******************************************************************************
//***** Types and Structures
//******************************************************************************

typedef struct _HOOK_FUNCTION
{
    LPCSTR  pszFunction;
    DWORD   dwOrdinal;
    FARPROC fpOldAddress;
    FARPROC fpNewAddress;
} HOOK_FUNCTION, *PHOOK_FUNCTION;


//******************************************************************************
//***** Function Prototypes
//******************************************************************************

// Hook Functions
HMODULE WINAPI WSInjectLoadLibraryA(
    LPCSTR pszLibFileName
);

HMODULE WINAPI WSInjectLoadLibraryW(
    LPCWSTR pszLibFileName
);

HMODULE WINAPI WSInjectLoadLibraryExA(
    LPCSTR pszLibFileName,
    HANDLE hFile,
    DWORD  dwFlags
);

HMODULE WINAPI WSInjectLoadLibraryExW(
    LPCWSTR pszLibFileName,
    HANDLE  hFile,
    DWORD   dwFlags
);

FARPROC WINAPI WSInjectGetProcAddress(
    HMODULE hModule,
    LPCSTR  pszProcName
);

// Helper Functions
void  Initialize(LPSTR pszBuffer, DWORD dwCount);
void  GetKernel32OrdinalsAndAddresses();
bool  StrEqual(LPCSTR psz1, LPCSTR psz2);
LPSTR StrCpyStrA(LPSTR pszDst, DWORD dwCount, LPCSTR pszSrc);
LPSTR StrCpyStrW(LPSTR pszDst, DWORD dwCount, LPCWSTR pwszSrc);
LPSTR StrCpyVal(LPSTR pszDst, DWORD dwCount, DWORD_PTR dwpValue);


//******************************************************************************
//***** Global Variables
//******************************************************************************

static bool g_fInitialized = false;

static HOOK_FUNCTION g_HookFunctions[] =
{
    { "LoadLibraryA",   0xFFFFFFFF, (FARPROC)-1, (FARPROC)WSInjectLoadLibraryA },
    { "LoadLibraryW",   0xFFFFFFFF, (FARPROC)-1, (FARPROC)WSInjectLoadLibraryW },
    { "LoadLibraryExA", 0xFFFFFFFF, (FARPROC)-1, (FARPROC)WSInjectLoadLibraryExA },
    { "LoadLibraryExW", 0xFFFFFFFF, (FARPROC)-1, (FARPROC)WSInjectLoadLibraryExW },
    { "GetProcAddress", 0xFFFFFFFF, (FARPROC)-1, (FARPROC)WSInjectGetProcAddress }
};


//******************************************************************************
//***** Entry Point
//******************************************************************************

#ifdef _DEBUG
void main() {}
#endif

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Tell the OS that we don't wish to receive DLL_THREAD_ATTACH and
        // DLL_THREAD_DETACH messages.
        DisableThreadLibraryCalls(hInstance);

        // Make sure we are initialized.
        CHAR szBuffer[BUFFER_SIZE];
        Initialize(szBuffer, sizeof(szBuffer));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // Let our main application know that we are exiting.
        OutputDebugStringA("09");
    }

    return TRUE;
}

//******************************************************************************
// A typical DLL would have its entrypoint called with a DLL_PROCESS_ATTACH
// message before any other code in it would be executed.  Due to the way we
// hook modules, our hook functions might actually get called before or DllMain
// gets called.  This occurs when other modules initialize before us and call
// some function we hook in their DLL_PROCESS_ATTACH handler.  This is not a
// problem, but we must never assume the order in which our code gets called.
// For this reason, we call Initialize in our DllMain and in every hook
// function.

// One other note: We want to be as least intrusive as possible to the process
// we are injected in.  This includes keeping our stack down in size as much
// as possible.  We do need a couple KB to store text strings in.  Since this
// needs to be a thread safe buffer, we can't use a global buffer unless we
// want to wrap it in critical sections, which in turn may throw off thread
// timing and synchronization.  Another option is to dynamically allocate the
// buffer, but we really don't want to touch the heap.  So, we go for the stack.
// To help preserve some stack space, we pass the buffer from the parent
// function to this function.  This way we don't have two functions on the
// stack, each with a couple KB of stack used.

void Initialize(LPSTR pszBuffer, DWORD dwCount)
{
    // If we are already initialized, then just return.
    if (g_fInitialized)
    {
        return;
    }

    // Get ordinal and address values from kernel32.dll for the functions we are hooking.
    GetKernel32OrdinalsAndAddresses();

    // Build and send a debug string containing our command line.
    LPSTR psz = StrCpyStrA(pszBuffer, dwCount, "02:");
    StrCpyStrA(psz, dwCount - (DWORD)(psz - pszBuffer), GetCommandLineA());
    OutputDebugStringA(pszBuffer);

    // Build and send a debug string containing the current directory.
    psz = StrCpyStrA(pszBuffer, dwCount, "03:");
    GetCurrentDirectoryA(dwCount - (DWORD)(psz - pszBuffer), psz);
    pszBuffer[dwCount - 1] = '\0';
    OutputDebugStringA(pszBuffer);

    // Build and send a debug string containing our path.
    psz = StrCpyStrA(pszBuffer, dwCount, "04:");
    GetEnvironmentVariableA("PATH", psz, dwCount - (DWORD)(psz - pszBuffer));
    pszBuffer[dwCount - 1] = '\0';
    OutputDebugStringA(pszBuffer);

    // Build and send a debug string containing the module path.  We need to do
    // this to work around a problem on NT where the image name field for the
    // CREATE_PROCESS_DEBUG_EVENT event is not filled in, and therefore we
    // do not know the name or path of the process.
    psz = StrCpyStrA(pszBuffer, dwCount, "07:");
    GetModuleFileNameA(NULL, psz, dwCount - (DWORD)(psz - pszBuffer));
    pszBuffer[dwCount - 1] = '\0';
    OutputDebugStringA(pszBuffer);

    // Flag ourself as initialized.
    g_fInitialized = true;
}


//******************************************************************************
//***** Hook Functions
//******************************************************************************

// Set up an intrinsic function that will give us caller's return address from
// within a hook function.
extern "C" void* _ReturnAddress();
#pragma intrinsic ("_ReturnAddress")


//******************************************************************************
// LPEXCEPTION_POINTERS GetExceptionInformation();
int ExceptionFilter(LPCSTR pszLog)
{
    OutputDebugStringA(pszLog);
    return EXCEPTION_CONTINUE_SEARCH;
}

//******************************************************************************
HMODULE WINAPI WSInjectLoadLibraryA(
    LPCSTR pszLibFileName
)
{
    // Call our intrinsic function to obtain the caller's return address.
    DWORD_PTR dwpCaller = (DWORD_PTR)_ReturnAddress();

    // Ensure that we are initialized.
    CHAR szBuffer[BUFFER_SIZE];
    Initialize(szBuffer, sizeof(szBuffer));

    // Build our pre-call debug string. We wrap the file name copy in exception
    // handling in case the string pointer passed to us is bad.
    LPSTR psz, pszException;
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "10:");
    psz = StrCpyVal(psz, PSZ_COUNT, dwpCaller);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)pszLibFileName);
    if (pszLibFileName)
    {
        psz = StrCpyStrA(psz, PSZ_COUNT, ",");
        __try
        {
            StrCpyStrA(psz, PSZ_COUNT, pszLibFileName);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            *pszException = '\0';
        }
    }

    // Send the pre-call message to our main app to let it know that we are about
    // to call LoadLibraryA.
    OutputDebugStringA(szBuffer);

    // Do the call and the store the error value.
    HMODULE hmResult = NULL;
    __try
    {
        hmResult = LoadLibraryA(pszLibFileName); // inspected
    }
    __except(ExceptionFilter("12:"))
    {
    }

    DWORD dwGLE = GetLastError();

    // Build our post-call debug string.
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "11:");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hmResult);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, dwGLE);

    // Send the post-call message to our main app to let it know that the call
    // completed and what the result was.
    OutputDebugStringA(szBuffer);

    // Re-set the error value to be safe and return to the caller.
    SetLastError(dwGLE);
    return hmResult;
}

//******************************************************************************
HMODULE WINAPI WSInjectLoadLibraryW(
    LPCWSTR pwszLibFileName
)
{
    // Call our intrinsic function to obtain the caller's return address.
    DWORD_PTR dwpCaller = (DWORD_PTR)_ReturnAddress();

    // Ensure that we are initialized.
    CHAR szBuffer[BUFFER_SIZE];
    Initialize(szBuffer, sizeof(szBuffer));

    // Build our pre-call debug string. We wrap the file name copy in exception
    // handling in case the string pointer passed to us is bad.
    LPSTR psz, pszException;
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "20:");
    psz = StrCpyVal(psz, PSZ_COUNT, dwpCaller);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)pwszLibFileName);
    if (pwszLibFileName)
    {
        psz = StrCpyStrA(psz, PSZ_COUNT, ",");
        __try
        {
            StrCpyStrW(psz, PSZ_COUNT, pwszLibFileName);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            *pszException = '\0';
        }
    }

    // Send the pre-call message to our main app to let it know that we are about
    // to call LoadLibraryW.
    OutputDebugStringA(szBuffer);

    // Do the call and the store the error value.
    HMODULE hmResult = NULL;
    __try
    {
        hmResult = LoadLibraryW(pwszLibFileName); // inspected
    }
    __except(ExceptionFilter("22:"))
    {
    }
    DWORD dwGLE = GetLastError();

    // Build our post-call debug string.
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "21:");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hmResult);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, dwGLE);

    // Send the post-call message to our main app to let it know that the call
    // completed and what the result was.
    OutputDebugStringA(szBuffer);

    // Re-set the error value to be safe and return to the caller.
    SetLastError(dwGLE);
    return hmResult;
}

//******************************************************************************
HMODULE WINAPI WSInjectLoadLibraryExA(
    LPCSTR pszLibFileName,
    HANDLE hFile,
    DWORD  dwFlags
)
{
    // Call our intrinsic function to obtain the caller's return address.
    DWORD_PTR dwpCaller = (DWORD_PTR)_ReturnAddress();

    // Ensure that we are initialized.
    CHAR szBuffer[BUFFER_SIZE];
    Initialize(szBuffer, sizeof(szBuffer));

    // Build our pre-call debug string. We wrap the file name copy in exception
    // handling in case the string pointer passed to us is bad.
    LPSTR psz, pszException;
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "30:");
    psz = StrCpyVal(psz, PSZ_COUNT, dwpCaller);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)pszLibFileName);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hFile);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, dwFlags);
    if (pszLibFileName)
    {
        psz = StrCpyStrA(psz, PSZ_COUNT, ",");

        __try
        {
            // Check to see if the module is being loaded as a data file.
            if (dwFlags & LOAD_LIBRARY_AS_DATAFILE)
            {
                // Look to see if there some form of a path (full or partial) specified.
                for (LPCSTR pch = pszLibFileName; *pch; pch++)
                {
                    if (*pch == '\\')
                    {
                        // If a path is found, then attempt to build a fully qualified path to the file.
                        DWORD dwCount = GetFullPathNameA(pszLibFileName, PSZ_COUNT, psz, NULL);
                        szBuffer[sizeof(szBuffer) - 1] = '\0';

                        // If it fails, then give up on the full path.
                        if (!dwCount || (dwCount >= PSZ_COUNT))
                        {
                            *psz = '\0';
                        }
                        break;
                    }
                }
            }

            // If we did not build a full path, then just copy the file name over directly.
            if (!*psz)
            {
                StrCpyStrA(psz, PSZ_COUNT, pszLibFileName);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            *pszException = '\0';
        }
    }

    // Send the pre-call message to our main app to let it know that we are about
    // to call LoadLibraryExA.
    OutputDebugStringA(szBuffer);

    // Do the call and the store the error value.
    HMODULE hmResult = NULL;
    __try
    {
        hmResult = LoadLibraryExA(pszLibFileName, hFile, dwFlags); // inspected
    }
    __except(ExceptionFilter("32:"))
    {
    }
    DWORD dwGLE = GetLastError();

    // Build our post-call debug string.
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "31:");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hmResult);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, dwGLE);

    // Send the post-call message to our main app to let it know that the call
    // completed and what the result was.
    OutputDebugStringA(szBuffer);

    // Re-set the error value to be safe and return to the caller.
    SetLastError(dwGLE);
    return hmResult;
}

//******************************************************************************
HMODULE WINAPI WSInjectLoadLibraryExW(
    LPCWSTR pwszLibFileName,
    HANDLE  hFile,
    DWORD   dwFlags
)
{
    // Call our intrinsic function to obtain the caller's return address.
    DWORD_PTR dwpCaller = (DWORD_PTR)_ReturnAddress();

    // Ensure that we are initialized.
    CHAR szBuffer[BUFFER_SIZE];
    Initialize(szBuffer, sizeof(szBuffer));

    // Build our pre-call debug string. We wrap the file name copy in exception
    // handling in case the string pointer passed to us is bad.
    LPSTR psz, pszException;
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "40:");
    psz = StrCpyVal(psz, PSZ_COUNT, dwpCaller);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)pwszLibFileName);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hFile);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, dwFlags);
    if (pwszLibFileName)
    {
        psz = StrCpyStrA(psz, PSZ_COUNT, ",");

        __try
        {
            // Check to see if the module is being loaded as a data file.
            if (dwFlags & LOAD_LIBRARY_AS_DATAFILE)
            {
                // Look to see if there some form of a path (full or partial) specified.
                for (LPCWSTR pch = pwszLibFileName; *pch; pch++)
                {
                    if (*pch == L'\\')
                    {
                        // If a path is found, then attempt to build a fully qualified path to the file.
                        // First, we need to convert the unicode string to an ANSI string.
                        CHAR szPath[BUFFER_SIZE];
                        StrCpyStrW(szPath, sizeof(szPath), pwszLibFileName);
                        DWORD dwCount = GetFullPathNameA(szPath, PSZ_COUNT, psz, NULL);
                        szBuffer[sizeof(szBuffer) - 1] = '\0';

                        // If it fails, then give up on the full path.
                        if (!dwCount || (dwCount >= PSZ_COUNT))
                        {
                            *psz = '\0';
                        }
                        break;
                    }
                }
            }

            // If we did not build a full path, then just copy the file name over directly.
            if (!*psz)
            {
                StrCpyStrW(psz, PSZ_COUNT, pwszLibFileName);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            *pszException = '\0';
        }
    }

    // Send the pre-call message to our main app to let it know that we are about
    // to call LoadLibraryExW.
    OutputDebugStringA(szBuffer);

    // Do the call and the store the error value.
    HMODULE hmResult = NULL;
    __try
    {
        hmResult = LoadLibraryExW(pwszLibFileName, hFile, dwFlags); // inspected
    }
    __except(ExceptionFilter("42:"))
    {
    }
    DWORD dwGLE = GetLastError();

    // Build our post-call debug string.
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "41:");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hmResult);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, dwGLE);

    // Send the post-call message to our main app to let it know that the call
    // completed and what the result was.
    OutputDebugStringA(szBuffer);

    // Re-set the error value to be safe and return to the caller.
    SetLastError(dwGLE);
    return hmResult;
}

//******************************************************************************
FARPROC WINAPI WSInjectGetProcAddress(
    HMODULE hModule,
    LPCSTR  pszProcName
)
{
    // Call our intrinsic function to obtain the caller's return address.
    DWORD_PTR dwpCaller = (DWORD_PTR)_ReturnAddress();

    // Ensure that we are initialized.
    CHAR szBuffer[BUFFER_SIZE];
    Initialize(szBuffer, sizeof(szBuffer));

    // We want to intercept calls to GetProcAddress() for two reasons.  First,
    // we want to know what modules are calling in other modules.  Second, we
    // don't want any modules ever calling directly to the LoadLibrary functions.
    // We do a good job hooking those modules, but modules are still free to
    // call GetProcAddress() on one of the LoadLibrary calls and then call the
    // function using that address. We detect this case, and return the hooked
    // address instead.

    // We have two methods detecting a hooked function. We first check to see if
    // the module being queried is kernel32.  If so, we check to see if the
    // function being queried matches one of our functions by either ordinal or
    // name. If that does not find a match, then we go ahead and make the call
    // to GetProcAddress and check the return value. If the return value matches
    // a function the we are hooking, we change it to our hooked function. This
    // method works great on NT and catches forwarded functions, but it does not
    // work on Windows 9x since the return address from GetProcAddress is a fake
    // address since we are running under Dependency Walker, a debugger. This is
    // a feature on Win9x to allow debuggers to set breakpoints on kernel32
    // functions without breaking other apps since kernel32 lives in shared
    // memory. Between our two techniques, we should catch all calls.

    FARPROC fpResult = NULL;
    DWORD   dwGLE = 0;
    int     hook;
    DWORD   dw;

    // Get the module name for this module handle.
    __try
    {
        dw = GetModuleFileNameA(hModule, szBuffer, sizeof(szBuffer));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dw = 0;
    }

    // Check for valid result.
    if ((dw > 0) && (dw < BUFFER_SIZE))
    {
        // Ensure the string is NULL terminated (it should already be).
        szBuffer[dw] = '\0';

        // Go to end of string and walk backwards looking for a wack.  Along the
        // way, we are converting any lowercase characters to uppercase.
        for (LPSTR psz = szBuffer + dw - 1; (psz >= szBuffer) && (*psz != '\\'); psz--)
        {
            if ((*psz >= 'a') && (*psz <= 'z'))
            {
                *psz -= ((int)'a' - (int)'A');
            }
        }
        psz++;

        // Check to see if the module is kernel32.
        if (StrEqual(psz, "KERNEL32.DLL"))
        {
            // First check to see if pszProcName is really an ordinal value for
            // one of the functions we hook.  If so, just return the address for
            // our hooked version instead of the real function.
            for (hook = 0; hook < countof(g_HookFunctions); hook++)
            {
                if ((DWORD_PTR)pszProcName == (DWORD_PTR)g_HookFunctions[hook].dwOrdinal)
                {
                    fpResult = g_HookFunctions[hook].fpNewAddress;
                    break;
                }
            }

            // If the ordinal check did not find a match, then check to see if
            // pszProcName is a string pointer to a function name that we hook.
            // We need to wrap this in exception handling since the pszProcName
            // may be invalid. If we find a match, then we return the address
            // of our hooked version instead of the real function.
            if (!fpResult && ((DWORD_PTR)pszProcName > 0xFFFF))
            {
                __try
                {
                    for (hook = 0; hook < countof(g_HookFunctions); hook++)
                    {
                        if (StrEqual(pszProcName, g_HookFunctions[hook].pszFunction))
                        {
                            fpResult = g_HookFunctions[hook].fpNewAddress;
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }
        }
    }

    // Build our pre-call debug string. We wrap the proc name copy in exception
    // handling in case the string pointer passed to us is bad.
    LPSTR psz, pszException;
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "80:");
    psz = StrCpyVal(psz, PSZ_COUNT, dwpCaller);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)hModule);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)pszProcName);
    if ((DWORD_PTR)pszProcName > 0xFFFF)
    {
        psz = StrCpyStrA(psz, PSZ_COUNT, ",");
        __try
        {
            StrCpyStrA(psz, PSZ_COUNT, pszProcName);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            *pszException = '\0';
        }
    }

    // Send the pre-call message to our main app to let it know that we are about
    // to call GetProcAddress.
    OutputDebugStringA(szBuffer);

    // Make sure we did not find a match in the above code.
    if (!fpResult)
    {
        // Make the call just as the user intended.
        __try
        {
            fpResult = GetProcAddress(hModule, pszProcName);
        }
        __except(ExceptionFilter("82:"))
        {
        }
        dwGLE = GetLastError();

        // If the address returned matches one of the functions that we hook, then
        // change the address to our hooked version.
        for (hook = 0; hook < countof(g_HookFunctions); hook++)
        {
            if (fpResult == g_HookFunctions[hook].fpOldAddress)
            {
                fpResult = g_HookFunctions[hook].fpNewAddress;
                break;
            }
        }
    }

    // Build our post-call debug string.
    psz = StrCpyStrA(szBuffer, sizeof(szBuffer), "81:");
    psz = StrCpyVal(psz, PSZ_COUNT, (DWORD_PTR)fpResult);
    psz = StrCpyStrA(psz, PSZ_COUNT, ",");
    psz = pszException = StrCpyVal(psz, PSZ_COUNT, dwGLE);

    // Send the post-call message to our main app to let it know that the call
    // completed and what the result was.
    OutputDebugStringA(szBuffer);

    // Re-set the error value to be safe and return to the caller.
    SetLastError(dwGLE);
    return fpResult;
}


//******************************************************************************
//***** Helper Functions
//******************************************************************************

void GetKernel32OrdinalsAndAddresses()
{
    // Get the base address of kernel32.
    DWORD_PTR dwpBase = (DWORD_PTR)LoadLibraryA("KERNEL32.DLL"); // inspected
    if (!dwpBase)
    {
        return;
    }

    __try
    {
        // Map an IMAGE_DOS_HEADER structure onto our kernel32 image.
        PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)dwpBase;

        // Map an IMAGE_NT_HEADERS structure onto our kernel32 image.
        PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)(dwpBase + pIDH->e_lfanew);

        // Locate the start of the export table.
        PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)(dwpBase +
            pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

        // Make sure we were able to locate the image directory.
        if (!pIED)
        {
            FreeLibrary((HMODULE)dwpBase);
            return;
        }

        // Get pointers to the beginning of the address, name, and ordinal lists.
        DWORD *pdwAddresses = (DWORD*)(dwpBase + (DWORD_PTR)pIED->AddressOfFunctions);
        DWORD *pdwNames     = (DWORD*)(dwpBase + (DWORD_PTR)pIED->AddressOfNames);
        WORD  *pwOrdinals   = (WORD* )(dwpBase + (DWORD_PTR)pIED->AddressOfNameOrdinals);

        // Loop through all the "exported by name" functions.
        for (int hint = 0; hint < (int)pIED->NumberOfNames; hint++)
        {
            // Loop through each of our hook function structures looking for a match.
            for (int hook = 0; hook < countof(g_HookFunctions); hook++)
            {
                // Compare this export to this hook function.
                if (StrEqual((LPCSTR)(dwpBase + pdwNames[hint]),
                             g_HookFunctions[hook].pszFunction))
                {
                    // A match was found. Store this functions address and ordinal.
                    g_HookFunctions[hook].fpOldAddress = (FARPROC)(dwpBase + *(pdwAddresses + (DWORD_PTR)pwOrdinals[hint]));
                    g_HookFunctions[hook].dwOrdinal    = (DWORD)pIED->Base + (DWORD)pwOrdinals[hint];
                    break;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Dec the reference count on kernel32 since we loaded it to get its address.
    FreeLibrary((HMODULE)dwpBase);
}

//******************************************************************************
bool StrEqual(LPCSTR psz1, LPCSTR psz2)
{
    while (*psz1 || *psz2)
    {
        if (*(psz1++) != *(psz2++))
        {
            return false;
        }
    }
    return true;
}

//******************************************************************************
LPSTR StrCpyStrA(LPSTR pszDst, DWORD dwCount, LPCSTR pszSrc)
{
    if (!dwCount)
    {
        return pszDst;
    }

    while (*pszSrc && --dwCount)
    {
        *(pszDst++) = *(pszSrc++);
    }
    *pszDst = '\0';
    return pszDst;
}

//******************************************************************************
LPSTR StrCpyStrW(LPSTR pszDst, DWORD dwCount, LPCWSTR pwszSrc)
{
    if (!dwCount)
    {
        return pszDst;
    }

    while (*pwszSrc && --dwCount)
    {
        *(pszDst++) = (CHAR)*(pwszSrc++);
    }
    *pszDst = '\0';
    return pszDst;
}

//******************************************************************************
LPSTR StrCpyVal(LPSTR pszDst, DWORD dwCount, DWORD_PTR dwpValue)
{
    if (!dwCount)
    {
        return pszDst;
    }

    static LPCSTR pszHex = "0123456789ABCDEF";
    bool fSig = false;
    DWORD_PTR dwp;

    if (--dwCount)
    {
        *(pszDst++) = '0';

        if (--dwCount)
        {
            *(pszDst++) = 'x';

            for (int i = (sizeof(dwpValue) * 8) - 4; (i >= 0) && dwCount; i -= 4)
            {
                dwp = (dwpValue >> i) & 0xF;
                if (dwp || fSig || !i)
                {
                    if (--dwCount)
                    {
                        *(pszDst++) = pszHex[dwp];
                        fSig = true;
                    }
                }
            }
        }
    }
    *pszDst = '\0';
    return pszDst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\childfrm.h ===
//******************************************************************************
//
// File:        CHILDFRM.H
//
// Description: Definition file for the Child Frame window.
//
// Classes:     CChildFrame
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __CHILDFRM_H__
#define __CHILDFRM_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CChildFrame
//******************************************************************************

class CChildFrame : public CMDIChildWnd
{
protected:
    static int    ms_cChildFrames;
    static LPCSTR ms_szChildFrameClass;

// Internal variables
protected:
    CDocDepends    *m_pDoc;
    bool            m_fActivated;
    CSmartSplitter  m_SplitterH;
    CSmartSplitter  m_SplitterV;
    CSmartSplitter  m_SplitterH2;
//  CSmartSplitterFunctions m_SplitterH2;
    CSmartSplitter  m_SplitterH3;

// Constructor/Destructor (serialization only)
protected:
    CChildFrame();
    virtual ~CChildFrame();
    DECLARE_DYNCREATE(CChildFrame)

public:
//  BOOL CreateFunctionsView();
//  BOOL CreateDetailView();

// Overridden functions
public:
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual void ActivateFrame(int nCmdShow = -1);
    virtual BOOL DestroyWindow();
    protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext *pContext);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CChildFrame)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __CHILDFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\childfrm.cpp ===
//******************************************************************************
//
// File:        CHILDFRM.CPP
//
// Description: Implementation file for the Child Frame window.
//
// Classes:     CChildFrame
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "document.h"
#include "splitter.h"
#include "listview.h"
#include "modtview.h"
#include "modlview.h"
#include "funcview.h"
#include "profview.h"
#include "childfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CChildFrame
//******************************************************************************

/*static*/ int    CChildFrame::ms_cChildFrames      = 0;
/*static*/ LPCSTR CChildFrame::ms_szChildFrameClass = NULL;

//******************************************************************************
IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)
BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CChildFrame :: Constructor/Destructor
//******************************************************************************

CChildFrame::CChildFrame() :
    m_pDoc(g_theApp.m_pNewDoc),
    m_fActivated(false)
//  m_SplitterH2(g_theApp.m_pNewDoc)
{
    ms_cChildFrames++;
    m_pDoc->m_pChildFrame = this;
}

//******************************************************************************
CChildFrame::~CChildFrame()
{
    ms_cChildFrames--;
}

//******************************************************************************
// CChildFrame :: Overridden functions
//******************************************************************************

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // Create a class for our child frame to use that does not have the
    // CS_VREDRAW or CS_HREDRAW flags.  This prevents flicker.
    if (!ms_szChildFrameClass)
    {
        ms_szChildFrameClass = AfxRegisterWndClass(0);
    }

    // Use our flicker-free class instead of the default class.
    cs.lpszClass = ms_szChildFrameClass;
    return CMDIChildWnd::PreCreateWindow(cs);
}

//******************************************************************************
BOOL CChildFrame::OnCreateClient(LPCREATESTRUCT, CCreateContext *pContext)
{
    //              V = H-0 (#2)
    // +------------+------------+
    // |            |  H2-0 (#5) |
    // |  V-0 (#3)  +------------+ H2 = V-1 (#4)
    // |            |  H2-1 (#6) |
    // +------------+------------+ H (#1)
    // |          H3-0 (#8)      |
    // +-------------------------+ H3 = H-2 (#7)
    // |          H3-1 (#9)      |
    // +-------------------------+

    // (#1) Create our main horizontal splitter.
    if (!m_SplitterH.CreateStatic(this, 2, 1, 5000))
    {
        return FALSE;
    }

    // (#2) Create our vertical splitter in pane 0 of our main horizontal splitter.
    if (!m_SplitterV.CreateStatic(&m_SplitterH, 1, 2, 3333, WS_CHILD | WS_VISIBLE,
                                  m_SplitterH.IdFromRowCol(0, 0)))
    {
        return FALSE;
    }

    // (#3) Create the module tree view in pane 0 of our vertical splitter.
    if (!m_SplitterV.CreateView(0, 0, RUNTIME_CLASS(CTreeViewModules),
                                CSize(0, 0), pContext))
    {
        return FALSE;
    }
    m_pDoc->m_pTreeViewModules = (CTreeViewModules*)m_SplitterV.GetPane(0, 0);

    // (#4) Create our 2nd horizontal splitter in pane 1 of our vertical splitter.
    if (!m_SplitterH2.CreateStatic(&m_SplitterV, 2, 1, 5000, WS_CHILD | WS_VISIBLE,
                                   m_SplitterV.IdFromRowCol(0, 1)))
    {
        return FALSE;
    }

    // (#5) Create the import function list view in pane 0 of our 2nd horizontal splitter.
    if (!m_SplitterH2.CreateView(0, 0, RUNTIME_CLASS(CListViewImports),
                                 CSize(0, 0), pContext))
    {
        return FALSE;
    }
    m_pDoc->m_pListViewImports = (CListViewImports*)m_SplitterH2.GetPane(0, 0);

    // (#6) Create the export function list view in pane 0 of our 2nd horizontal splitter.
    if (!m_SplitterH2.CreateView(1, 0, RUNTIME_CLASS(CListViewExports),
                                 CSize(0, 0), pContext))
    {
        return FALSE;
    }
    m_pDoc->m_pListViewExports = (CListViewExports*)m_SplitterH2.GetPane(1, 0);

#if 0 //{{AFX

    // (#6.5) Create our richedit detail view which is a sibling to #4
    if (!(m_pDoc->m_pRichViewDetails = new CRichViewDetails()))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    if (!m_pDoc->m_pRichViewDetails->Create(
                                           NULL, NULL, AFX_WS_DEFAULT_VIEW & ~WS_BORDER, CRect(0, 0, 0, 0),
                                           &m_SplitterV, 999, pContext))
    {
        return FALSE;
    }
#endif //}}AFX

    // (#7) Create our 3nd horizontal splitter in pane 1 of our main horizontal splitter.
    if (!m_SplitterH3.CreateStatic(&m_SplitterH, 2, 1, 5000, WS_CHILD | WS_VISIBLE,
                                   m_SplitterH.IdFromRowCol(1, 0)))
    {
        return FALSE;
    }

    // (#8) Create the module list view in pane 0 of our 3nd horizontal splitter.
    if (!m_SplitterH3.CreateView(0, 0, RUNTIME_CLASS(CListViewModules),
                                 CSize(0, 0), pContext))
    {
        return FALSE;
    }
    m_pDoc->m_pListViewModules = (CListViewModules*)m_SplitterH3.GetPane(0, 0);

    // (#9) Create the runtime profiler log view pane 1 of our 3nd horizontal splitter.
    if (!m_SplitterH3.CreateView(1, 0, RUNTIME_CLASS(CRichViewProfile),
                                 CSize(0, 0), pContext))
    {
        return FALSE;
    }
    m_pDoc->m_pRichViewProfile = (CRichViewProfile*)m_SplitterH3.GetPane(1, 0);

#if 0 //{{AFX

    // Set our edit control's font to the same font as our list control.
    m_pDoc->m_pRichViewDetails->SetFont(m_pDoc->m_pListViewModules->GetFont(), FALSE);
#endif //}}AFX


    // Set our edit control's font to the same font as our list control.
    m_pDoc->m_pRichViewProfile->SetFont(m_pDoc->m_pListViewModules->GetFont(), FALSE);

    return TRUE;
}

//******************************************************************************
void CChildFrame::ActivateFrame(int nCmdShow)
{
    // If no particular show flag is specified (-1) and this is our first frame,
    // we create the frame maximized since that is most likely what the would
    // prefer.
    if (!m_fActivated && (nCmdShow == -1) && (ms_cChildFrames == 1))
    {
        nCmdShow = SW_SHOWMAXIMIZED;
    }

    // Tell our document to do the things it wants to do just before becoming 
    // visible, such as populated our views.
    if (!m_fActivated && m_pDoc)
    {
        m_pDoc->BeforeVisible();
    }

    // Call the base class to continue displaying the frame.  After this call
    // returns, our frame and views will be visible (assuming our main frame is
    // visible).
    CMDIChildWnd::ActivateFrame(nCmdShow);

    // Tell our document to do the things it wants to do just after becoming 
    // visible, such as displaying any errors it may have.  The only time we
    // will not be visible at this point is when a user opens a file from the
    // command line, since the main frame is not visible yet.  In that case,
    // we will call AfterVisible at the end of InitInstanceWrapped, since the
    // main frame will be visible then.
    if (!m_fActivated && g_theApp.m_fVisible && m_pDoc)
    {
        m_pDoc->AfterVisible();
    }

    // Set our activated flag in case we ever get called again (not sure if we ever do).
    m_fActivated = true;
}

//******************************************************************************
BOOL CChildFrame::DestroyWindow() 
{
    m_pDoc->m_pTreeViewModules = NULL;
    m_pDoc->m_pListViewImports = NULL;
    m_pDoc->m_pListViewExports = NULL;
    m_pDoc->m_pListViewModules = NULL;
    m_pDoc->m_pRichViewProfile = NULL;
    m_pDoc->m_pChildFrame      = NULL;

    return CMDIChildWnd::DestroyWindow();
}

//******************************************************************************
#if 0 //{{AFX
BOOL CChildFrame::CreateFunctionsView()
{
    m_SplitterH2.ShowWindow(SW_SHOWNOACTIVATE);
    m_pDoc->m_pRichViewDetails->ShowWindow(SW_HIDE);

    return TRUE;
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
BOOL CChildFrame::CreateDetailView()
{
    m_pDoc->m_pRichViewDetails->ShowWindow(SW_SHOWNOACTIVATE);
    m_SplitterH2.ShowWindow(SW_HIDE);

    return TRUE;
}
#endif //}}AFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\dbgthread.h ===
//******************************************************************************
//
// File:        DBGTHREAD.H
//
// Description: Definition file for for the debugging thread and related objects.
//              These objects are used to perform a runtime profile on an app. 
//
// Classes:     CDebuggerThread
//              CProcess
//              CUnknown
//              CThread
//              CLoadedModule
//              CEvent
//              CEventCreateProcess
//              CEventExitProcess
//              CEventCreateThread
//              CEventExitThread
//              CEventLoadDll
//              CEventUnloadDll
//              CEventDebugString
//              CEventException
//              CEventRip
//              CEventDllMainCall
//              CEventDllMainReturn
//              CEventFunctionCall
//              CEventLoadLibraryCall
//              CEventGetProcAddressCall
//              CEventFunctionReturn
//              CEventMessage
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/24/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __DBGTHREAD_H__
#define __DBGTHREAD_H__


//******************************************************************************
//****** Forward Declarations
//******************************************************************************

class CDebuggerThread;
class CEventDllMainCall;
class CEventFunctionCall;
class CEventFunctionReturn;


//******************************************************************************
//****** Constants
//******************************************************************************

#define EXCEPTION_DLL_NOT_FOUND     0xC0000135
#define EXCEPTION_DLL_NOT_FOUND2    0xC0000139
#define EXCEPTION_DLL_INIT_FAILED   0xC0000142

#define EXCEPTION_MS_DELAYLOAD_MOD  VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND)  // 0xC06D007E
#define EXCEPTION_MS_DELAYLOAD_PROC VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND) // 0xC06D007F
#define EXCEPTION_MS_CPP_EXCEPTION  VcppException(0xE0000000, 0x7363)                         // 0xE06D7363
#define EXCEPTION_MS_THREAD_NAME    VcppException(ERROR_SEVERITY_INFORMATIONAL, 5000)         // 0x406D1388

#define THREADNAME_TYPE             0x00001000


// VC 6.0 has a 9 character limit for thread names, but this is supposed to
// change in the future, so we handle 63 characters to allow for some growth.
#define MAX_THREAD_NAME_LENGTH      63

#define DLLMAIN_CALL_EVENT          100
#define DLLMAIN_RETURN_EVENT        101
#define LOADLIBRARY_CALL_EVENT      102
#define LOADLIBRARY_RETURN_EVENT    103
#define GETPROCADDRESS_CALL_EVENT   104
#define GETPROCADDRESS_RETURN_EVENT 105
#define MESSAGE_EVENT               106


// Define where we will put our breakpoint that is hit a module returns from its
// DllMain function.  We use 32 since it is a nice even number and replaces the
// last 4 byes of IMAGE_DOS_HEADER.e_res since e_res fills byte offsets 28-35.
#define BREAKPOINT_OFFSET           32


//******************************************************************************
//****** Types and Structures
//******************************************************************************

// This structure contains the return address and args of a DllMain call.
// On x86, we read it directly from the stack, so it needs to be 4-byte packed.
// On everything else, we fill it in by hand, so packing does not matter.
#if defined(_X86_)
#pragma pack (push, 4)
#endif
typedef struct _DLLMAIN_ARGS
{
    LPVOID    lpvReturnAddress;
    HINSTANCE hInstance;
    DWORD     dwReason;
    LPVOID    lpvReserved;
} DLLMAIN_ARGS, *PDLLMAIN_ARGS;
#if defined(_X86_)
#pragma pack (pop)
#endif

typedef struct _HOOK_FUNCTION
{
    LPCSTR    szFunction;
    DWORD     dwOrdinal;
    DWORD_PTR dwpOldAddress;
    DWORD_PTR dwpNewAddress;
} HOOK_FUNCTION, *PHOOK_FUNCTION;

typedef enum _HOOKSTATUS
{
    HS_NOT_HOOKED,
    HS_ERROR,
    HS_DATA,
    HS_SHARED,
    HS_HOOKED,
    HS_INJECTION_DLL
} HOOKSTATUS, *PHOOKSTATUS;

typedef enum _DLLMSG
{
    DLLMSG_UNKNOWN                  =  0,
    DLLMSG_COMMAND_LINE             =  2, // Sent during Initialize
    DLLMSG_INITIAL_DIRECTORY        =  3, // Sent during Initialize
    DLLMSG_SEARCH_PATH              =  4, // Sent during Initialize
    DLLMSG_MODULE_PATH              =  7, // Sent during Initialize
    DLLMSG_DETACH                   =  9, // Sent during DLL_PROCESS_DETACH
    DLLMSG_LOADLIBRARYA_CALL        = 10, // Sent before LoadLibraryA() is called.
    DLLMSG_LOADLIBRARYA_RETURN      = 11, // Sent after LoadLibraryA() is called.
    DLLMSG_LOADLIBRARYA_EXCEPTION   = 12, // Sent if LoadLibraryA() causes an exception.
    DLLMSG_LOADLIBRARYW_CALL        = 20, // Sent before LoadLibraryW() is called.
    DLLMSG_LOADLIBRARYW_RETURN      = 21, // Sent after LoadLibraryW() is called.
    DLLMSG_LOADLIBRARYW_EXCEPTION   = 22, // Sent if LoadLibraryW() causes an exception.
    DLLMSG_LOADLIBRARYEXA_CALL      = 30, // Sent before LoadLibraryExA() is called.
    DLLMSG_LOADLIBRARYEXA_RETURN    = 31, // Sent after LoadLibraryExA() is called.
    DLLMSG_LOADLIBRARYEXA_EXCEPTION = 32, // Sent if LoadLibraryExA() causes an exception.
    DLLMSG_LOADLIBRARYEXW_CALL      = 40, // Sent before LoadLibraryExW() is called.
    DLLMSG_LOADLIBRARYEXW_RETURN    = 41, // Sent after LoadLibraryExW() is called.
    DLLMSG_LOADLIBRARYEXW_EXCEPTION = 42, // Sent if LoadLibraryExW() causes an exception.
    DLLMSG_GETPROCADDRESS_CALL      = 80, // Sent before GetProcAddress() is called.
    DLLMSG_GETPROCADDRESS_RETURN    = 81, // Sent after GetProcAddress() is called.
    DLLMSG_GETPROCADDRESS_EXCEPTION = 82, // Sent if GetProcAddress() causes an exception.
} DLLMSG, *PDWINJECTMSG;

// VC 6.0 introduced thread naming. An application may throw us this structure
// to name a thread via a call to RaiseException(0x406D1388, ...).
typedef struct tagTHREADNAME_INFO
{
    DWORD  dwType;      // Must be 0x00001000
    LPCSTR pszName;     // ANSI string pointer in process being debugged.
    DWORD  dwThreadId;  // Thread Id, or -1 for current thread.
//  DWORD  dwFlags;     // Reserved, must be zero.
} THREADNAME_INFO, *PTHREADNAME_INFO;

// We pack all code related structures to 1 byte boundaries since they need to be exactly as specified.
#pragma pack(push, 1)

#if defined(_IA64_)

// Some tidbits about the IA64 architecture:
//    There are 6 categories (a.k.a. Units) of instructions: A, I, M, F, B, L+X
//    All instructions are 41-bit, except for L+X which uses two 41-bit slots.
//    Instructions must be grouped together in sets of 3, which is called a bundle.
//    Each bundle is combined with a 5-bit template, resulting in 128-bits total per bundle.
//    The template identifies what category of each instruction that is in the bundle.
//    Bundles must be aligned on a 128-bit boundary.
//
// The layout of a bundle is as follows:
//
//    41-bits "Slot 2", 41-bits "Slot 1", 41-bits "Slot 0", 5-bits "Template"
//
//---------------------------------------------------------------------------
//
// Instruction: alloc r32=0,1,1,0
//
// M Unit: opcode - x3  -  sor  sol     sof     r1      qp
//         0001   0 110 00 0000 0000001 0000010 0100000 000000
//         ----   - --- -- ---- ------- ------- ------- ------
//         4333   3 333 33 3222 2222222 1111111 1110000 000000
//         0987   6 543 21 0987 6543210 9876543 2109876 543210
//
// r1=ar.pfs,i,l,o,r
//
// sol = "size of locals", which is all input and local registers.
// sof = "size of frame", which is sol plus the output registers.
// sor = "size of rotating"
//
// opcode =  1
// x3     =  6
// sor    =  r >> 3 = 0
// sol    =  i + l = 1
// sof    =  i + l + o = 2
// r1     = 32
// qp     =  0
//
// static registers: r0 - r31
// input registers:  none
// local registers:  r32 (contains ar.pfs)
// outout registers: r33
//
//---------------------------------------------------------------------------
//
// Instruction: flushrs
//
// M Unit: opcode - x3  x2 x4   -                     qp
//         0000   0 000 00 0001 000000000000000000000 000000
//         ----   - --- -- ---- --------------------- ------
//         4333   3 333 33 3222 222222211111111110000 000000
//         0987   6 543 21 0987 654321098765432109876 543210
//
// opcode = 0
// imm21  = (i << 20) | imm20a
// x3     = 0
// x2     = 0
// x4     = C (C = flushrs, A = loadrs)
// qp     = 0
//
//---------------------------------------------------------------------------
//
// Instruction: nop.m 0 (also used for break.m)
//
// M Unit: opcode i x3  x2 x4   - imm20a               qp
//         0000   0 000 00 0001 0 00000000000000000000 000000
//         ----   - --- -- ---- - -------------------- ------
//         4333   3 333 33 3222 2 22222211111111110000 000000
//         0987   6 543 21 0987 6 54321098765432109876 543210
//
// opcode = 0
// imm21  = (i << 20) | imm20a
// x3     = 0
// x2     = 0
// x4     = 1 (0 = break.m, 1 = nop.m)
// qp     = 0
//
//---------------------------------------------------------------------------
//
// Instruction: break.i 0x80016 (also used for nop.i)
//
// I Unit: opcode i x3  x6     - imm20a               qp
//         0000   0 000 000000 0 10000000000000010110 000000
//         ----   - --- ------ - -------------------- ------
//         4333   3 333 333222 2 22222211111111110000 000000
//         0987   6 543 210987 6 54321098765432109876 543210
//
// opcode = 0
// imm21  = (i << 20) | imm20a = 0x80016
// x3     = 0
// x6     = 0 (0 = break.m, 1 = nop.m)
// qp     = 0
//
//---------------------------------------------------------------------------
//
// Instruction: movl r31=0x0123456789ABCDEF
//
// L Unit: imm41
//         00000010010001101000101011001111000100110
//         -----------------------------------------
//         43333333333222222222211111111110000000000
//         09876543210987654321098765432109876543210
//
// X Unit: opcode i imm9d     imm5c ic vc imm7b   r1      qp
//         0110   0 110011011 01011 1  0  1101111 0011111 000000
//         ----   - --------- ----- -  -  ------- ------- ------
//         4333   3 333333222 22222 2  2  1111111 1110000 000000
//         0987   6 543210987 65432 1  0  9876543 2109876 543210
//
//
// i                     imm41                        ic imm5c    imm9d    imm7b
// ||-------------------------------------------------|||----| |---------||------|
// 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
//
// opcode = 6
// imm64  = (i << 63) | (imm41 << 22) | (ic << 21) | (imm5c << 16) | (imm9d << 7) | imm7b
// vc     = 0
// r1     = 31
// qp     = 0
//
//---------------------------------------------------------------------------
//
// Instruction: mov b6=r31
//
// I Unit: opcode - x3  -          x -  r2      -    b1  qp
//         0000   0 111 0000000000 0 01 0011111 0000 110 000000
//         ----   - --- ---------- - -- ------- ---- --- ------
//         4333   3 333 3332222222 2 22 1111111 1110 000 000000
//         0987   6 543 2109876543 2 10 9876543 2109 876 543210
//
// opcode = 0
// x3     = 7
// x      = 0 (0 = mov, 1 = mov.ret)
// r2     = 31
// b1     = 6
// qp     = 0
//
//---------------------------------------------------------------------------
//
// Instruction: br.call.sptk.few b0=b6
//
// B Unit: opcode - d wh  -                b2  p -   b1  qp
//         0001   0 0 001 0000000000000000 110 0 000 000 000000
//         ----   - - --- ---------------- --- - --- --- ------
//         4333   3 3 333 3322222222221111 111 1 110 000 000000
//         0987   6 5 432 1098765432109876 543 2 109 876 543210
//
// opcode = 1
// d      = 0 (0 = none, 1 = .clr)
// wh     = 1 (1 = .sptk, 3 = .spnt, 5 = .dptk, 7 = .dpnt)
// b2     = 6
// p      = 0 (0 = .few, 1 = .many)
// b1     = 0
// qp     = 0
//
//---------------------------------------------------------------------------

#ifndef IA64_PSR_RI
#define IA64_PSR_RI 41
#endif

typedef struct _IA64_BUNDLE
{
    DWORDLONG dwll;
    DWORDLONG dwlh;
} IA64_BUNDLE, *PIA64_BUNDLE;

// The following code simply calls LoadLibaryA, then calls GetLastError, then
// breaks.  IA64 doesn't used the stack for most functions calls - everything
// is done with registers.  Registers r0 through r31 are known as static
// registers.  Starting with r32, a function can reserve 0 or more registers
// as input registers.  For example, if a function takes 4 parameters, then it
// will want to reserve at 4 registers as input registers.  This will map r32,
// r33, r34, r35 to the four parameters.  Following the input registers, a 
// function can reserve 0 or more local registers.  After the local registers
// a function can reserve 0 or more output registers.  Output registers are
// where the outgoing parameters are stored when making calls out of this
// function.  All this mapping magic is done by the alloc instruction.
//
// Our injection code only needs one output parameter (so we can pass the DLL
// name to LoadLibraryA).  We would like to start our code off with a...
//
//    alloc r32=0,1,1,0
//
// so that we know r33 is our output register, but Get/SetThreadContext don't
// seem to correctly preserve the current register mappings.  So, when we
// restore the original code and resume execution, the process usually
// crashes since its registers are not mapped as it expects.
//
// There is a couple solutions.  We can do the alloc, then do another alloc
// when done to restore the mappings back to what it used to be.  Or we can
// just examine the mappings before we inject our code and just determine
// what is the current output register.  Currently, this is what we do.  From
// observation, I have found that bits 0-6 of StIFS is the frame size (sof)
// and bits 7-13 are the locals size (sol).  Assuming sof is greater than sol,
// We know the first output register is at 32 + sol.
//
typedef struct _INJECTION_CODE
{
    // Store the DLL path in our first output register (to be determined at runtime)
    //
    //    nop.m 0
    //    movl rXX=szDataDllPath
    //
    IA64_BUNDLE b1;

    // Store the address of LoadLibraryA in a static register
    //
    //    nop.m 0
    //    movl r31=LoadLibraryA
    //
    IA64_BUNDLE b2;

    // Copy the function address to a branch register and make the call.
    //
    //    nop.m 0
    //    mov b6=r31
    //    br.call.sptk.few b0=b6
    //
    IA64_BUNDLE b3;

    // Store the address of GetLastError in a static register
    //
    //    nop.m 0
    //    movl r31=GetLastError
    //
    IA64_BUNDLE b4;

    // Copy the function address to a branch register and make the call.
    //
    //    nop.m 0
    //    mov b6=r31
    //    br.call.sptk.few b0=b6
    //
    IA64_BUNDLE b5;

    // Breakpoint
    //
    //    flushrs
    //    nop.m 0
    //    break.i 0x80016
    //
    IA64_BUNDLE b6;

    // The DLL path buffer.
    CHAR szDataDllPath[1]; // DEPENDS.DLL path string.

} INJECTION_CODE, *PINJECTION_CODE;

//******************************************************************************
#elif defined(_X86_)

typedef struct _INJECTION_CODE
{
    // Reserve 4K of stack
    WORD  wInstructionSUB;   // 00: 0xEC81 [sub esp,1000h]
    DWORD dwOperandSUB;      // 02: 0x00001000

    // Push the DEPENDS.DLL path string
    BYTE  bInstructionPUSH;  // 06: 0x68   [push szDataDllPath]
    DWORD dwOperandPUSH;     // 07: address of szDataDllPath

    // Call LoadLibaryA
    BYTE  bInstructionCALL;  // 11: 0xE8   [call LoadLibraryA]
    DWORD dwOperandCALL;     // 12: address of LoadLibraryA

    // Call GetLastError
    BYTE  bInstructionCALL2; // 16: 0xE8   [call GetLastError]
    DWORD dwOperandCALL2;    // 17: address of GetLastError

    // Breakpoint
    BYTE  bInstructionINT3;  // 21: 0xCC   [int 3]

    BYTE  bPadding1;         // 22:
    BYTE  bPadding2;         // 23:

    CHAR  szDataDllPath[1];  // 24: DEPENDS.DLL path string.

} INJECTION_CODE, *PINJECTION_CODE;

//******************************************************************************
#elif defined(_AMD64_)

typedef struct _INJECTION_CODE
{
    // Load ptr to DEPENDS.DLL as parm 1
    WORD    MovRcx1;               // 0xB948            mov rcx, immed64
    ULONG64 OperandMovRcx1;        // address of szDataDllPath

    // Call LoadLibraryA
    WORD    MovRax1;               // 0xB848            mov rax, immed64
    ULONG64 OperandMovRax1;        // address of LoadLibraryA
    WORD    CallRax1;              // 0xD0FF            call rax

    // Call GetLastError
    WORD    MovRax2;               // 0xB848            mov rax, immed64
    ULONG64 OperandMovRax2;        // address of GetLastError
    WORD    CallRax2;              // 0xD0FF            call rax

    // Breakpoint
    BYTE    Int3;                  // 0xCC
    BYTE    Pad1;
    BYTE    Pad2;
    CHAR    szDataDllPath[1];
} INJECTION_CODE, *PINJECTION_CODE;

//******************************************************************************
#elif defined(_ALPHA_) || defined(_ALPHA64_)

// The following code depends upon context being set correctly. Also, this code
// has no procedure descriptor, so exceptions and unwinds cannot be propagated
// beyond this call.  The x86 implementation also has this restriction, but
// while the x86 implementation will only rarely fail to propagate exceptions
// and unwinds, the alpha implementation will always fail to propagate
// exceptions and unwinds.

/*
70:   LoadLibrary("foo");
004130F4   ldah          t2,0x68        68 00 7F 24
004130F8   ldl           v0,0xF7F0(t2)  F0 F7 03 A0
004130FC   ldah          a0,0x63        63 00 1F 26
00413100   lda           a0,0xDFC0(a0)  C0 DF 10 22
00413104   jsr           ra,(v0),8      02 40 40 6B
71:   GetLastError();
00413108   ldah          v0,0x68        68 00 1F 24
0041310C   ldl           v0,0xF7C4(v0)  C4 F7 00 A0
00413110   jsr           ra,(v0),0xC    03 40 40 6B

004130F4  68 00 7F 24
          F0 F7 03 A0
          63 00 1F 26
          C0 DF 10 22
          02 40 40 6B
          68 00 1F 24
          C4 F7 00 A0
          03 40 40 6B
          FF FF 1F 20
          00 00 FF 63
          50 00 1E B0
          60 00 1E A0
          00 00 5E A7
*/
typedef struct _INJECTION_CODE
{
    DWORD dwInstructionBp;
    char  szDataDllPath[1];
} INJECTION_CODE, *PINJECTION_CODE;

#else
#error("Unknown Target Machine");
#endif

// Restore packing.
#pragma pack(pop)


//******************************************************************************
//****** CContext
//******************************************************************************

// This class is mostly for IA64, but can't hurt on other platforms.  It just
// guarentees that the CONTEXT structure is always 16-byte aligned in memory.
// This is required for IA64 or else Get/SetThreadContext will fail.

class CContext {
protected:
    BYTE m_bBuffer[sizeof(CONTEXT) + 16];

public:
    CContext(DWORD dwFlags = 0)
    {
        ZeroMemory(m_bBuffer, sizeof(m_bBuffer)); // inspected
        Get()->ContextFlags = dwFlags;
    }
    CContext(CContext &context)
    {
        CopyMemory(Get(), context.Get(), sizeof(CONTEXT)); // inspected
    }

    // I thought about just adding a pointer member and setting it in the 
    // constructor rather than computing it each time, but if we copy this
    // object to another object, then that pointer would get copied as well,
    // which we don't want.  A copy constructor could fix this, but it
    // isn't that big of a deal to compute it a few times.
#ifdef WIN64
    inline PCONTEXT Get() { return (PCONTEXT)(((DWORD_PTR)m_bBuffer + 15) & ~0xFui64); }
#else
    inline PCONTEXT Get() { return (PCONTEXT)(((DWORD_PTR)m_bBuffer + 15) & ~0xF    ); }
#endif
};


//******************************************************************************
//****** CUnknown
//******************************************************************************

class CUnknown
{
protected:
    LONG m_lRefCount;

    CUnknown() : m_lRefCount(1)
    {
    }
    virtual ~CUnknown()
    {
    };

public:
    DWORD AddRef()
    {
        return ++m_lRefCount;
    }
    DWORD Release()
    {
        if (--m_lRefCount <= 0)
        {
            delete this;
            return 0;
        }
        return m_lRefCount;
    }
};

//******************************************************************************
//****** CThread
//******************************************************************************

class CThread : public CUnknown
{
public:
    CThread              *m_pNext;
    DWORD                 m_dwThreadId;
    HANDLE                m_hThread;
    DWORD                 m_dwThreadNumber;
    LPCSTR                m_pszThreadName;
    CEventFunctionCall   *m_pEventFunctionCallHead;
    CEventFunctionCall   *m_pEventFunctionCallCur;

    CThread(DWORD dwThreadId, HANDLE hThread, DWORD dwThreadNumber, CThread *pNext) :
        m_pNext(pNext),
        m_dwThreadId(dwThreadId),
        m_hThread(hThread),
        m_dwThreadNumber(dwThreadNumber),
        m_pszThreadName(NULL),
        m_pEventFunctionCallHead(NULL),
        m_pEventFunctionCallCur(NULL)
    {
    }

protected:
    // Make protected since nobody should ever call delete on us.
    virtual ~CThread()
    {
        MemFree((LPVOID&)m_pszThreadName);
    }
};


//******************************************************************************
//****** CLoadedModule
//******************************************************************************

class CLoadedModule : public CUnknown
{
public:
    CLoadedModule     *m_pNext;
    PIMAGE_NT_HEADERS  m_pINTH;
    DWORD_PTR          m_dwpImageBase;
    DWORD              m_dwVirtualSize;
    DWORD              m_dwDirectories;
    DWORD_PTR          m_dwpReturnAddress;
    HOOKSTATUS         m_hookStatus;
    bool               m_fReHook;
    CEventDllMainCall *m_pEventDllMainCall;
    bool               m_fEntryPointBreak;
    DWORD_PTR          m_dwpEntryPointAddress;
#if defined(_IA64_)
    IA64_BUNDLE        m_entryPointData;
#else
    DWORD              m_entryPointData;
#endif

protected:
    LPCSTR             m_pszPath;
    LPCSTR             m_pszFile;

public:
    CLoadedModule(CLoadedModule *pNext, DWORD_PTR dwpImageBase, LPCSTR pszPath) :
        m_pNext(pNext),
        m_pINTH(NULL),
        m_dwpImageBase(dwpImageBase),
        m_dwVirtualSize(0),
        m_dwDirectories(IMAGE_NUMBEROF_DIRECTORY_ENTRIES),
        m_dwpReturnAddress(0),
        m_hookStatus(HS_NOT_HOOKED),
        m_fReHook(false),
        m_pEventDllMainCall(NULL),
        m_fEntryPointBreak(false),
        m_dwpEntryPointAddress(0),
        m_pszPath(NULL),
        m_pszFile(NULL)
    {
        ZeroMemory(&m_entryPointData, sizeof(m_entryPointData)); // inspected
        SetPath(pszPath);
    }

    void SetPath(LPCSTR pszPath)
    {
        // Sometimes we call SetPath with our existing path.
        if (!pszPath || (pszPath != m_pszPath))
        {
            MemFree((LPVOID&)m_pszPath);
            m_pszPath = StrAlloc(pszPath ? pszPath : "");
            m_pszFile = GetFileNameFromPath(m_pszPath);
            _strlwr((LPSTR)m_pszPath);
            _strupr((LPSTR)m_pszFile);
        }
    }

    inline LPCSTR GetName(bool fPath) { return fPath ? m_pszPath : m_pszFile; }

protected:
    // Make protected since nobody should ever call delete on us.
    virtual ~CLoadedModule();
};


//******************************************************************************
//****** CEvent
//******************************************************************************

class CEvent : public CUnknown
{
public:
    CEvent        *m_pNext;
    CThread       *m_pThread;
    CLoadedModule *m_pModule;
    DWORD          m_dwTickCount;

protected:
    CEvent(CThread *pThread, CLoadedModule *pModule) :
        m_pNext(NULL),
        m_pThread(pThread),
        m_pModule(pModule),
        m_dwTickCount(GetTickCount())
    {
        if (m_pThread)
        {
            m_pThread->AddRef();
        }
        if (m_pModule)
        {
            m_pModule->AddRef();
        }
    }

    virtual ~CEvent()
    {
        if (m_pThread)
        {
            m_pThread->Release();
        }
        if (m_pModule)
        {
            m_pModule->Release();
        }
    }

public:
    virtual DWORD GetType() = 0;
};


//******************************************************************************
//****** CEventCreateProcess
//******************************************************************************

class CEventCreateProcess : public CEvent
{
public:
    CEventCreateProcess(CThread *pThread, CLoadedModule *pModule) :
        CEvent(pThread, pModule)
    {
    }

    virtual DWORD GetType()
    {
        return CREATE_PROCESS_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventExitProcess
//******************************************************************************

class CEventExitProcess : public CEvent
{
public:
    DWORD m_dwExitCode;

    CEventExitProcess(CThread *pThread, CLoadedModule *pModule, EXIT_PROCESS_DEBUG_INFO *pde) :
        CEvent(pThread, pModule),
        m_dwExitCode(pde->dwExitCode)
    {
    }

    virtual DWORD GetType()
    {
        return EXIT_PROCESS_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventCreateThread
//******************************************************************************

class CEventCreateThread : public CEvent
{
public:
    DWORD_PTR m_dwpStartAddress;

    CEventCreateThread(CThread *pThread, CLoadedModule *pModule, CREATE_THREAD_DEBUG_INFO *pde) :
        CEvent(pThread, pModule),
        m_dwpStartAddress((DWORD_PTR)pde->lpStartAddress)
    {
    }

    virtual DWORD GetType()
    {
        return CREATE_THREAD_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventExitThread
//******************************************************************************

class CEventExitThread : public CEvent
{
public:
    DWORD m_dwExitCode;

    CEventExitThread(CThread *pThread, EXIT_THREAD_DEBUG_INFO *pde) :
        CEvent(pThread, NULL),
        m_dwExitCode(pde->dwExitCode)
    {
    }

    virtual DWORD GetType()
    {
        return EXIT_THREAD_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventLoadDll
//******************************************************************************

class CEventLoadDll : public CEvent
{
public:
    CEventLoadDll *m_pNextDllInFunctionCall;
    bool           m_fLoadedByFunctionCall;

    CEventLoadDll(CThread *pThread, CLoadedModule *pModule, bool fLoadedByFunctionCall) :
        CEvent(pThread, pModule),
        m_pNextDllInFunctionCall(NULL),
        m_fLoadedByFunctionCall(fLoadedByFunctionCall)
    {
    }

    virtual DWORD GetType()
    {
        return LOAD_DLL_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventUnloadDll
//******************************************************************************

class CEventUnloadDll : public CEvent
{
public:
    DWORD_PTR m_dwpImageBase;

    CEventUnloadDll(CThread *pThread, CLoadedModule *pModule, UNLOAD_DLL_DEBUG_INFO *pde) :
        CEvent(pThread, pModule),
        m_dwpImageBase((DWORD_PTR)pde->lpBaseOfDll)
    {
    }

    virtual DWORD GetType()
    {
        return UNLOAD_DLL_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventDebugString
//******************************************************************************

class CEventDebugString : public CEvent
{
public:
    LPCSTR m_pszBuffer;
    BOOL   m_fAllocatedBuffer;

    CEventDebugString(CThread *pThread, CLoadedModule *pModule, LPCSTR pszBuffer, BOOL fAllocateBuffer) :
        CEvent(pThread, pModule),
        m_pszBuffer(fAllocateBuffer ? StrAlloc(pszBuffer) : pszBuffer),
        m_fAllocatedBuffer(fAllocateBuffer)
    {
    }

    virtual ~CEventDebugString()
    {
        if (m_fAllocatedBuffer)
        {
            MemFree((LPVOID&)m_pszBuffer);
        }
    }

    virtual DWORD GetType()
    {
        return OUTPUT_DEBUG_STRING_EVENT;
    }
};


//******************************************************************************
//****** CEventException
//******************************************************************************

class CEventException : public CEvent
{
public:
    DWORD     m_dwCode;
    DWORD_PTR m_dwpAddress;
    BOOL      m_fFirstChance;

    CEventException(CThread *pThread, CLoadedModule *pModule, EXCEPTION_DEBUG_INFO *pde) :
        CEvent(pThread, pModule),
        m_dwCode(pde->ExceptionRecord.ExceptionCode),
        m_dwpAddress((DWORD_PTR)pde->ExceptionRecord.ExceptionAddress),
        m_fFirstChance(pde->dwFirstChance != 0)
    {
    }

    virtual DWORD GetType()
    {
        return EXCEPTION_DEBUG_EVENT;
    }
};


//******************************************************************************
//****** CEventRip
//******************************************************************************

class CEventRip : public CEvent
{
public:
    DWORD m_dwError;
    DWORD m_dwType;

    CEventRip(CThread *pThread, RIP_INFO *pde) :
        CEvent(pThread, NULL),
        m_dwError(pde->dwError),
        m_dwType(pde->dwType)
    {
    }

    virtual DWORD GetType()
    {
        return RIP_EVENT;
    }
};


//******************************************************************************
//****** CEventDllMainCall
//******************************************************************************

class CEventDllMainCall : public CEvent
{
public:
    HINSTANCE m_hInstance;
    DWORD     m_dwReason;
    LPVOID    m_lpvReserved;

    CEventDllMainCall(CThread *pThread, CLoadedModule *pModule, DLLMAIN_ARGS *pDMA) :
        CEvent(pThread, pModule),
        m_hInstance(pDMA->hInstance),
        m_dwReason(pDMA->dwReason),
        m_lpvReserved(pDMA->lpvReserved)
    {
    }

    virtual DWORD GetType()
    {
        return DLLMAIN_CALL_EVENT;
    }
};


//******************************************************************************
//****** CEventDllMainReturn
//******************************************************************************

class CEventDllMainReturn : public CEvent
{
public:
    CEventDllMainCall *m_pEventDllMainCall;
    BOOL               m_fResult;

    CEventDllMainReturn(CThread *pThread, CLoadedModule *pModule, BOOL fResult) :
        CEvent(pThread, pModule),
        m_pEventDllMainCall(pModule->m_pEventDllMainCall),
        m_fResult(fResult)
    {
        pModule->m_pEventDllMainCall = NULL;
    }

    virtual ~CEventDllMainReturn()
    {
        if (m_pEventDllMainCall)
        {
            m_pEventDllMainCall->Release();
        }
    }

    virtual DWORD GetType()
    {
        return DLLMAIN_RETURN_EVENT;
    }
};


//******************************************************************************
//****** CEventFunction
//******************************************************************************

// Some explanation is due here.  The CEventFunction object is created when a
// LoadLibrary call or GetProcAddress call is made in the remote process.  We
// create this object so we can track all DLLs loaded while inside the function.
// In running some tests on various windows platforms, I have found that it is
// possible to have nested LoadLibrary/GetProcAddress calls - like when a
// dynamically loaded module calls LoadLibrary from its DllMain.  Because of
// this, we actually build a hierarchy of CEventFunction objects. We keep
// building this hierarchy until the initial call to LoadLibray/GetProcAddress
// that started the hierarchy returns.  At that point we flush out the entire
// hierarchy to our session object and start clean again.
//
// We do this hierarchy thing since modules don't always load in a way that
// makes them easy to add to our tree. For example, a module might LoadLibary
// module A, which depends on module B. We might actually see B load first and
// we have no place to put it in our tree until module A loads.  So, we just keep
// track of all the modules that load while in a function call, then once the
// function returns, we try to make sense of everything that loaded.
//
// The hierarchy does not effect our output log. We still send chronological
// events to our session telling it about every function call, but the session
// knows not to do anything substantial with those events (besides just logging
// them) since we will send it over a final result once the call completes.
// Because of this, the user may see a block of log telling them that modules
// are loading, but the modules don't show up in the tree or list views until
// all calls for a given thread complete.
//
// Each thread maintains its own CEventFunction hierarchy since multiple threads
// could be calling LoadLibrary or GetProcAddres at the same time.  This way,
// we won't confuse which modules go with which function call.
//
// At first, I was just tracking LoadLibrary calls, but then I found cases where
// GetProcAddress caused modules to get loaded.  This can happen when you
// GetProcAddress a function that is actually forwarded to a module that is not
// currently loaded.  In this case, GetProcAddress acts sort of like a LoadLibrary
// followed by a GetProcAddress. We treat it basically the same as a LoadLibrary
// call here, but the session handles them differently.
//

class CEventFunctionCall : public CEvent
{
public:
    CEventFunctionCall   *m_pParent;
    CEventFunctionCall   *m_pNext;
    CEventFunctionCall   *m_pChildren;
    CEventFunctionReturn *m_pReturn;
    CEventLoadDll        *m_pDllHead;
    DLLMSG                m_dllMsg;
    DWORD_PTR             m_dwpAddress;
    bool                  m_fFlush;

    CEventFunctionCall(CThread *pThread, CLoadedModule *pModule, CEventFunctionCall *pParent,
                       DLLMSG dllMsg, DWORD_PTR dwpAddress) :
        CEvent(pThread, pModule),
        m_pParent(pParent),
        m_pNext(NULL),
        m_pChildren(NULL),
        m_pReturn(NULL),
        m_pDllHead(NULL),
        m_dllMsg(dllMsg),
        m_dwpAddress(dwpAddress),
        m_fFlush(false)
    {
    }
};


//******************************************************************************
//****** CEventLoadLibraryCall
//******************************************************************************

class CEventLoadLibraryCall : public CEventFunctionCall
{
public:
    DWORD_PTR m_dwpPath;
    LPCSTR    m_pszPath;
    DWORD_PTR m_dwpFile;
    DWORD     m_dwFlags;

    CEventLoadLibraryCall(CThread *pThread, CLoadedModule *pModule, CEventFunctionCall *pParent,
                          DLLMSG dllMsg, DWORD_PTR dwpAddress, DWORD_PTR dwpPath,
                          LPCSTR pszPath, DWORD_PTR dwpFile, DWORD dwFlags) :
        CEventFunctionCall(pThread, pModule, pParent, dllMsg, dwpAddress),
        m_dwpPath(dwpPath),
        m_pszPath(StrAlloc(pszPath)),
        m_dwpFile(dwpFile),
        m_dwFlags(dwFlags)
    {
    }

    virtual ~CEventLoadLibraryCall()
    {
        MemFree((LPVOID&)m_pszPath);
    }

    virtual DWORD GetType()
    {
        return LOADLIBRARY_CALL_EVENT;
    }
};


//******************************************************************************
//****** CEventGetProcAddressCall
//******************************************************************************

class CEventGetProcAddressCall : public CEventFunctionCall
{
public:
    CLoadedModule *m_pModuleArg;
    DWORD_PTR      m_dwpModule;
    DWORD_PTR      m_dwpProcName;
    LPCSTR         m_pszProcName;

    CEventGetProcAddressCall(CThread *pThread, CLoadedModule *pModule, CEventFunctionCall *pParent,
                             DLLMSG dllMsg, DWORD_PTR dwpAddress, CLoadedModule *pModuleArg,
                             DWORD_PTR dwpModule, DWORD_PTR dwpProcName, LPCSTR pszProcName) :
        CEventFunctionCall(pThread, pModule, pParent, dllMsg, dwpAddress),
        m_pModuleArg(pModuleArg),
        m_dwpModule(dwpModule),
        m_dwpProcName(dwpProcName),
        m_pszProcName(StrAlloc(pszProcName))
    {
        if (m_pModuleArg)
        {
            m_pModuleArg->AddRef();
        }
    }

    virtual ~CEventGetProcAddressCall()
    {
        MemFree((LPVOID&)m_pszProcName);
        if (m_pModuleArg)
        {
            m_pModuleArg->Release();
        }
    }

    virtual DWORD GetType()
    {
        return GETPROCADDRESS_CALL_EVENT;
    }
};


//******************************************************************************
//****** CEventFunctionReturn
//******************************************************************************

class CEventFunctionReturn : public CEvent
{
public:
    CEventFunctionCall *m_pCall;
    DWORD_PTR           m_dwpResult;
    DWORD               m_dwError;
    bool                m_fException;

    CEventFunctionReturn(CEventFunctionCall *m_pCall) :
        CEvent(m_pCall->m_pThread, m_pCall->m_pModule),
        m_pCall(m_pCall),
        m_dwpResult(0),
        m_dwError(0),
        m_fException(false)
    {
        m_pCall->AddRef();
        m_pCall->m_pReturn = this;
    }

    virtual ~CEventFunctionReturn()
    {
        m_pCall->Release();
    }

    virtual DWORD GetType()
    {
        return (m_pCall->m_dllMsg == DLLMSG_GETPROCADDRESS_CALL) ?
               GETPROCADDRESS_RETURN_EVENT : LOADLIBRARY_RETURN_EVENT;
    }
};


//******************************************************************************
//****** CEventMessage
//******************************************************************************

class CEventMessage : public CEvent
{
public:
    DWORD  m_dwError;
    LPCSTR m_pszMessage;
    BOOL   m_fAllocatedBuffer;

    CEventMessage(DWORD dwError, LPCSTR pszMessage, BOOL fAllocateBuffer) :
        CEvent(NULL, NULL),
        m_dwError(dwError),
        m_pszMessage(fAllocateBuffer ? StrAlloc(pszMessage) : pszMessage),
        m_fAllocatedBuffer(fAllocateBuffer)
    {
    }

    virtual ~CEventMessage()
    {
        if (m_fAllocatedBuffer)
        {
            MemFree((LPVOID&)m_pszMessage);
        }
    }

    virtual DWORD GetType()
    {
        return MESSAGE_EVENT;
    }
};


//******************************************************************************
//****** CProcess
//******************************************************************************

class CProcess
{
friend CDebuggerThread;

protected:
    CProcess        *m_pNext;             // We are part of a linked list.
    CDebuggerThread *m_pDebuggerThread;   // A pointer to our parent debugger thread.
    CThread         *m_pThreadHead;       // A list of the running threads in the process.
    CLoadedModule   *m_pModuleHead;       // A list of loaded modules in the process
    CEvent          *m_pEventHead;        // A list of queued events to send to the session.
    CSession        *m_pSession;          // A pointer to the session for this process.
    CThread         *m_pThread;           // The main thread for the process.
    CLoadedModule   *m_pModule;           // The main module for the process.
    CContext         m_contextOriginal;   // Saved context while we inject code.
    DWORD            m_dwStartingTickCount;
    bool             m_fProfileError;
    DWORD            m_dwFlags;
    bool             m_fTerminate;
    bool             m_fDidHookForThisEvent;
    bool             m_fInitialBreakpoint;
    BYTE            *m_pbOriginalPage;
    DWORD_PTR        m_dwpPageAddress;
    DWORD            m_dwPageSize;
    DWORD_PTR        m_dwpKernel32Base;
    bool             m_fKernel32Initialized;
    DWORD_PTR        m_dwpDWInjectBase;
    HOOK_FUNCTION    m_HookFunctions[5];
    DWORD            m_dwThreadNumber;
    DWORD            m_dwProcessId;
    HANDLE           m_hProcess;

public:
    LPCSTR           m_pszArguments;
    LPCSTR           m_pszDirectory;
    LPCSTR           m_pszSearchPath;

protected:
    CProcess(CSession *pSession, CDebuggerThread *pDebuggerThread, DWORD dwFlags, CLoadedModule *pModule);
    ~CProcess();

    // We are caching if there is no session, or we are hooking and the
    // hook is not complete yet (DEPENDS.DLL not injected yet or main module
    // has not been restored yet).
    inline BOOL IsCaching() { return (!m_fTerminate && (!m_pSession || ((m_dwFlags & PF_HOOK_PROCESS) && (!m_dwpDWInjectBase || m_pbOriginalPage)))); }

    void           SetProfileError();
    DWORD          HandleEvent(DEBUG_EVENT *pde);
    DWORD          EventCreateProcess(CREATE_PROCESS_DEBUG_INFO *pde, DWORD dwThreadId);
    DWORD          EventExitProcess(EXIT_PROCESS_DEBUG_INFO *pde, CThread *pThread);
    DWORD          EventCreateThread(CREATE_THREAD_DEBUG_INFO *pde, DWORD dwThreadId);
    DWORD          EventExitThread(EXIT_THREAD_DEBUG_INFO *pde, CThread *pThread);
    DWORD          EventLoadDll(LOAD_DLL_DEBUG_INFO *pde, CThread *pThread);
    DWORD          ProcessLoadDll(CThread *pThread, CLoadedModule *pModule);
    DWORD          EventUnloadDll(UNLOAD_DLL_DEBUG_INFO *pde, CThread *pThread);
    DWORD          EventDebugString(OUTPUT_DEBUG_STRING_INFO *pde, CThread *pThread);
    DWORD          EventException(EXCEPTION_DEBUG_INFO *pde, CThread *pThread);
    DWORD          EventExceptionThreadName(EXCEPTION_DEBUG_INFO *pde, CThread *pThread);
    DWORD          EventRip(RIP_INFO *pde, CThread *pThread);
    CThread*       AddThread(DWORD dwThreadId, HANDLE hThread);
    void           RemoveThread(CThread *pThread);
    CThread*       FindThread(DWORD dwThreadId);
    CLoadedModule* AddModule(DWORD_PTR dwpImageBase, LPCSTR pszImageName);
    void           RemoveModule(CLoadedModule *pModule);
    CLoadedModule* FindModule(DWORD_PTR dwpAddress);
    void           AddEvent(CEvent *pEvent);
    void           ProcessDllMsgMessage(CThread *pThread, LPSTR pszMsg);
    void           ProcessDllMsgCommandLine(LPCSTR pszMsg);
    void           ProcessDllMsgInitialDirectory(LPSTR pszMsg);
    void           ProcessDllMsgSearchPath(LPCSTR pszMsg);
    void           ProcessDllMsgModulePath(LPCSTR pszMsg);
    void           ProcessDllMsgDetach(LPCSTR);
    void           ProcessDllMsgLoadLibraryCall(CThread *pThread, LPCSTR pszMsg, DLLMSG dllMsg);
    void           ProcessDllMsgGetProcAddressCall(CThread *pThread, LPCSTR pszMsg, DLLMSG dllMsg);
    void           ProcessDllMsgFunctionReturn(CThread *pThread, LPCSTR pszMsg, DLLMSG);
    void           UserMessage(LPCSTR pszMessage, DWORD dwError, CLoadedModule *pModule);
    void           HookLoadedModules();
    void           AddFunctionEvent(CEventFunctionCall *pEvent);
    void           FlushEvents(bool fForce = false);
    void           FlushFunctionCalls(CThread *pThread);
    void           FlushFunctionCalls(CEventFunctionCall *pFC);
    BOOL           ReadKernelExports(CLoadedModule *pModule);
    BOOL           ReadDWInjectExports(CLoadedModule *pModule);
    BOOL           HookImports(CLoadedModule *pModule);
    BOOL           GetVirtualSize(CLoadedModule *pModule);
    BOOL           SetEntryBreakpoint(CLoadedModule *pModule);
    BOOL           EnterEntryPoint(CThread *pThread, CLoadedModule *pModule);
    BOOL           ExitEntryPoint(CThread *pThread, CLoadedModule *pModule);
    BOOL           InjectDll();
    DWORD_PTR      FindUsablePage(DWORD dwSize);
    BOOL           ReplaceOriginalPageAndContext();
    void           GetSessionModuleName();
    bool           GetModuleName(DWORD_PTR dwpImageBase, LPSTR pszPath, DWORD dwSize);

public:
    inline DWORD GetStartingTime()   { return m_dwStartingTickCount; }
    inline DWORD GetFlags()          { return m_dwFlags; }
    inline DWORD GetProcessId()      { return m_dwProcessId; }
    inline void  DetachFromSession() { m_pSession = NULL; }

    void           Terminate();
};


//******************************************************************************
//****** CDebuggerThread
//******************************************************************************

class CDebuggerThread
{
protected:
    static bool             ms_fInitialized;
    static CRITICAL_SECTION ms_cs;
    static CDebuggerThread *ms_pDebuggerThreadHead;
    static HWND             ms_hWndShutdown;

protected:
    CDebuggerThread *m_pDebuggerThreadNext;
    bool             m_fTerminate;
    DWORD            m_dwFlags;
    LPSTR            m_pszCmdLine;
    LPCSTR           m_pszDirectory;
    HANDLE           m_hevaCreateProcessComplete;
    CWinThread      *m_pWinThread;
    BOOL             m_fCreateProcess;
    DWORD            m_dwError;
    CProcess        *m_pProcessHead;
    DEBUG_EVENT      m_de;
    DWORD            m_dwContinue;

public:
    CDebuggerThread();
    ~CDebuggerThread();

public:
    inline static bool IsShutdown() { return ms_pDebuggerThreadHead == NULL; }
    inline static void SetShutdownWindow(HWND hWnd) { ms_hWndShutdown = hWnd; }

    static void Shutdown();

public:
    CProcess* BeginProcess(CSession *pSession, LPCSTR pszPath, LPCSTR pszArgs, LPCSTR pszDirectory, DWORD dwFlags);
    BOOL      RemoveProcess(CProcess *pProcess);

    inline BOOL DidCreateProcess() { return m_fCreateProcess; }

protected:
    CProcess* FindProcess(DWORD dwProcessId);
    void      AddProcess(CProcess *pProcess);
    CProcess* EventCreateProcess();

    DWORD Thread();
    static UINT AFX_CDECL StaticThread(LPVOID lpvThis)
    {
        __try
        {
            return ((CDebuggerThread*)lpvThis)->Thread();
        }
        __except (ExceptionFilter(_exception_code(), false))
        {
        }
        return 0;
    }

    void MainThreadCallback();
    static void WINAPI StaticMainThreadCallback(LPARAM lParam)
    {
        ((CDebuggerThread*)lParam)->MainThreadCallback();
    }
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __DBGTHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\dbgthread.cpp ===
//******************************************************************************
//
// File:        DBGTHREAD.CPP
//
// Description: Implementation file for for the debugging thread and related
//              objects.  These objects are used to perform a runtime profile
//              on an app. 
//
// Classes:     CDebuggerThread
//              CProcess
//              CUnknown
//              CThread
//              CLoadedModule
//              CEvent
//              CEventCreateProcess
//              CEventExitProcess
//              CEventCreateThread
//              CEventExitThread
//              CEventLoadDll
//              CEventUnloadDll
//              CEventDebugString
//              CEventException
//              CEventRip
//              CEventDllMainCall
//              CEventDllMainReturn
//              CEventFunctionCall
//              CEventLoadLibraryCall
//              CEventGetProcAddressCall
//              CEventFunctionReturn
//              CEventMessage
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//
// The Win32 debug APIs requires a thread to block on a call WaitForDebugEvent
// until an debug event arrives. Since we don't want our main thread to block,
// we create a worker thread for each process we launch. WaitForDebugEvent will
// only catch events for processes that were launched with CreateProcess by the
// thread calling WaitForDebugEvent. This thread is wrapped by the CDebuggerThread
// class and each process is wrapped by a CProcess class. It is possible to have
// more than one CProcess attached to a single CDebuggerThread. This can occur
// when the process we are debugging launches a child process. The child process
// will belong to the same CDebuggerThread as its parent process.
//
// We don't really keep track of the CDebuggerThread objects. They are
// automatically freed when all the processes being debugged by a CDebuggerThread
// terminate. When the user requests to stop debugging a process, we simply call
// TerminateProcess(). This should close the process, which in turn will destroy
// the CProcess, which in turn will destroy the CDebuggerThread if this was the
// last CProcess is was debugging. If the user closes a session window while it
// is being debugged, we first detach the UI from the CProcess, then do the
// TerminateProcess(). So, after the UI window is gone, this process and thread
// cleanup happen asynchronously in the background.
//
// The only time we need to really wait for everything to clean up is when the
// user closes the main application while we are profiling one or more apps.
// In this case, as each child frame closes, it starts the termination of the
// process associated with that session. Since process and thread termination
// happen asynchronously, we need to do one final wait on all processes and
// threads before our app exits.
//
// As each window closes, it terminates the process associated with it. This
// hopefully causes the debug thread for that process to wake up with a
// EXIT_PROCESS_DEBUG_EVENT event. For every event the debug thread gets, it
// passes control to our main thread by doing a PostMessage and WaitForSingleObject.
// As a result, during shutdown, most of our threads all block trying to send
// their final message to our main thread before they exit. Because of this, we
// need to keep our message pump going during shutdown. We do this by simply
// displaying a modal dialog during shutdown.  At first, I made this dialog tell
// the user we are shutting down, but it appeared and disappeared so fast that
// it was confusing.  So, now I just put up a hidden dialog.  This lets all
// threads clean up and terminate naturally. This should all happen in less
// than a second, but if a thread does not die, our dialog will exit after a
// timeout, and we will just kill off the threads and free any objects
// associated with them.

//******************************************************************************
//****** HexToDWP helper function
//******************************************************************************

#ifdef WIN64

DWORD_PTR HexToDWP(LPCSTR pszMsg)
{
    DWORD_PTR dwp = 0;
    if ((pszMsg[0] == '0') && ((pszMsg[1] == 'x') || (pszMsg[1] == 'X')))
    {
        for (pszMsg += 2; *pszMsg; pszMsg++)
        {
            if ((*pszMsg >= '0') &&  (*pszMsg <= '9'))
            {
                dwp = (dwp * 0x10) + (*pszMsg - '0');
            }
            else if ((*pszMsg >= 'A') &&  (*pszMsg <= 'F'))
            {
                dwp = (dwp * 0x10) + 0xA + (*pszMsg - 'A');
            }
            else if ((*pszMsg >= 'a') &&  (*pszMsg <= 'f'))
            {
                dwp = (dwp * 0x10) + 0xA + (*pszMsg - 'a');
            }
            else
            {
                break;
            }
        }
    }
    return dwp;
}

#else
#define HexToDWP(pszMsg) ((DWORD)strtoul(pszMsg, NULL, 0))
#endif

//******************************************************************************
//****** CLoadedModule
//******************************************************************************

// We can't do this in our header file due to circular dependencies of classes.
CLoadedModule::~CLoadedModule()
{
    MemFree((LPVOID&)m_pszPath);

    // The only time we ever point to a m_pEventDllMainCall object is while
    // this module is inside a call to its DllMain.  If the module crashes
    // while in the DllMain, it is possible that our object will be terminated
    // while our m_pEventDllMainCall is still pointing to an object. In a case
    // like this, we need to free the object ourself.
    if (m_pEventDllMainCall)
    {
        m_pEventDllMainCall->Release();
        m_pEventDllMainCall = NULL;
    }
}


//******************************************************************************
//****** CDebuggerThread
//******************************************************************************

/*static*/ bool             CDebuggerThread::ms_fInitialized = false;
/*static*/ CRITICAL_SECTION CDebuggerThread::ms_cs;
/*static*/ CDebuggerThread* CDebuggerThread::ms_pDebuggerThreadHead = NULL;
/*static*/ HWND             CDebuggerThread::ms_hWndShutdown = NULL;

//******************************************************************************
CDebuggerThread::CDebuggerThread() :
    m_pDebuggerThreadNext(NULL),
    m_fTerminate(false),
    m_dwFlags(0),
    m_pszCmdLine(NULL),
    m_pszDirectory(NULL),
    m_hevaCreateProcessComplete(NULL),
    m_pWinThread(NULL),
    m_fCreateProcess(FALSE),
    m_dwError(0),
    m_pProcessHead(NULL),
    m_dwContinue(0)
{
    ZeroMemory(&m_de, sizeof(m_de)); // inspected

    // Initialize ourself if this is our first instance ever.
    if (!ms_fInitialized)
    {
        InitializeCriticalSection(&ms_cs); // inspected
        ms_fInitialized = true;
    }

    // Insert this instance into our linked list of thread objects.
    EnterCriticalSection(&ms_cs); // inspected
    m_pDebuggerThreadNext  = ms_pDebuggerThreadHead;
    ms_pDebuggerThreadHead = this;
    LeaveCriticalSection(&ms_cs);
}

//******************************************************************************
CDebuggerThread::~CDebuggerThread()
{
    // Remove ourself from our static thread list.
    EnterCriticalSection(&ms_cs); // inspected

    // Search for this thread object in our thread list.
    for (CDebuggerThread *pThreadPrev = NULL, *pThreadCur = ms_pDebuggerThreadHead;
        pThreadCur; pThreadPrev = pThreadCur, pThreadCur = pThreadCur->m_pDebuggerThreadNext)
    {
        // Check for a match.
        if (pThreadCur == this)
        {
            // Remove the object from our list.
            if (pThreadPrev)
            {
                pThreadPrev->m_pDebuggerThreadNext = pThreadCur->m_pDebuggerThreadNext;
            }
            else
            {
                ms_pDebuggerThreadHead = pThreadCur->m_pDebuggerThreadNext;
            }

            // Bail out.
            break;
        }
    }

    // Close any processes that may still be open.
    while (m_pProcessHead)
    {
        if (m_pProcessHead->m_hProcess)
        {
            // Remote process should already be dead.  This is a last resort.
            m_pProcessHead->m_fTerminate = true;
            TerminateProcess(m_pProcessHead->m_hProcess, 0xDEAD); // inspected.
        }
        RemoveProcess(m_pProcessHead);
    }

    // Check to see if we have an open thread.
    if (m_pWinThread)
    {
        // Make sure we are not trying to delete the thread from the thread itself.
        if (GetCurrentThreadId() != m_pWinThread->m_nThreadID)
        {
            // Make sure the thread is gone.  This shouldn't happen, but
            // as a last resort, we terminate the thread.
            TerminateThread(m_pWinThread->m_hThread, 0xDEAD); // inspected

            // Delete our thread object (destructor closes thread handle).
            delete m_pWinThread;
        }
        else
        {
            // We can't delete our thread object just yet, so tell it to delete itself.
            m_pWinThread->m_bAutoDelete = TRUE;
        }

        // This thread is gone or will be real soon.
        m_pWinThread = NULL;
    }

    // If our list is empty and we have a shutdown window up, then wake it
    // up so it knows to close.
    if (!ms_pDebuggerThreadHead && ms_hWndShutdown)
    {
        PostMessage(ms_hWndShutdown, WM_TIMER, 0, 0);
    }

    LeaveCriticalSection(&ms_cs);
}

//******************************************************************************
/*static*/ void CDebuggerThread::Shutdown()
{
    if (ms_fInitialized)
    {
        // Delete all thread objects.
        EnterCriticalSection(&ms_cs); // inspected
        while (ms_pDebuggerThreadHead)
        {
            delete ms_pDebuggerThreadHead;
        }
        LeaveCriticalSection(&ms_cs);

        DeleteCriticalSection(&ms_cs);
    }

    ms_fInitialized = false;
}

//******************************************************************************
//!! caller should display generic error.
CProcess* CDebuggerThread::BeginProcess(CSession *pSession, LPCSTR pszPath, LPCSTR pszArgs, LPCSTR pszDirectory, DWORD dwFlags)
{
    // Create a big buffer to build the path to create process.  We could do this
    // in the thread, but we then we would be grow the stack for every thread we
    // created.  We would rather just use the main thread's stack.
    CHAR szCmdLine[(2 * DW_MAX_PATH) + 4];

    // Check to see if we have spaces in our path.
    if (strchr(pszPath, ' '))
    {
        // If so, then we need to quote the path.
        *szCmdLine = '\"';
        StrCCpy(szCmdLine + 1, pszPath, sizeof(szCmdLine) - 1);
        StrCCat(szCmdLine, "\"", sizeof(szCmdLine));
    }

    // Otherwise, just string copy the path into our command line.
    else
    {
        StrCCpy(szCmdLine, pszPath, sizeof(szCmdLine));
    }

    // If we have args, then tack them onto the end of the command line.
    if (pszArgs && *pszArgs)
    {
        StrCCat(szCmdLine, " ", sizeof(szCmdLine));
        StrCCat(szCmdLine, pszArgs, sizeof(szCmdLine));
    }

    // Create a module object so the process object has something to point to.
    CLoadedModule *pModule = new CLoadedModule(NULL, 0, pszPath);
    if (!pModule)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Create our initial process node. We need to cache events if we don't have
    // a session or we are hooking.
    if (!(m_pProcessHead = new CProcess(pSession, this, dwFlags, pModule)))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // When running in console mode, we don't return to the caller until after
    // we are all done profiling.  Because of this, we need to set the session's
    // process pointer so that we can call back into it.
    pSession->m_pProcess = m_pProcessHead;

    // Store our startup strings so our thread can get to them.
    // These are only temporary within this function's scope, so it is ok that
    // we are pointing to a local variable.
    m_pszCmdLine   = szCmdLine;
    m_pszDirectory = pszDirectory;

    // Store the flags so we know how to initialize new sessions if this process
    // decides to start child processes.
    m_dwFlags = dwFlags;

    // If we are running in console mode, then we don't create a thread. Instead, we
    // just call the thread routine directly.
    if (g_theApp.m_cmdInfo.m_fConsoleMode)
    {
        Thread();
    }
    else
    {
        // Create an event that our thread will signal once it has created the remote
        // process.
        if (!(m_hevaCreateProcessComplete = CreateEvent(NULL, FALSE, FALSE, NULL))) // inspected. nameless event.
        {
            TRACE("CreateEvent() failed [%u].\n", GetLastError());
            return NULL;
        }

        // Create an MFC thread. We create it suspended since it is possible for
        // the thread to start executing before AfxBeginThread returns.
        if (!(m_pWinThread = AfxBeginThread(StaticThread, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED)))
        {
            TRACE("AfxBeginThread() failed [%u].\n", GetLastError());
            return NULL;
        }

        // Tell MFC not to auto-delete us when the thread completes.
        m_pWinThread->m_bAutoDelete = FALSE;

        // Now that we have returned from AfxBeginThread and set auto-delete, we resume the thread.
        m_pWinThread->ResumeThread();

        // Wait for our thread to start the process.
        WaitForSingleObject(m_hevaCreateProcessComplete, INFINITE);

        // We are done with our thread event.
        CloseHandle(m_hevaCreateProcessComplete);
        m_hevaCreateProcessComplete = NULL;
    }

    if (!m_fCreateProcess)
    {
        m_pProcessHead->UserMessage("Failure starting the process.", m_dwError, NULL);
    }

    // Set any CreateProcess() error that may have occurred.
    SetLastError(m_dwError);

    // Return success if we have a process node.
    return m_fCreateProcess ? m_pProcessHead : NULL;
}

//******************************************************************************
CProcess* CDebuggerThread::FindProcess(DWORD dwProcessId)
{
    for (CProcess *pCur = m_pProcessHead; pCur; pCur = pCur->m_pNext)
    {
        if (pCur->m_dwProcessId == dwProcessId)
        {
            return pCur;
        }
    }
    return NULL;
}

//******************************************************************************
void CDebuggerThread::AddProcess(CProcess *pProcess)
{
    // Add this process node to the end of our process list.
    if (m_pProcessHead)
    {
        for (CProcess *pProcessLast = m_pProcessHead; pProcessLast->m_pNext;
            pProcessLast = pProcessLast->m_pNext)
        {
        }
        pProcessLast->m_pNext = pProcess;
    }
    else
    {
        m_pProcessHead = pProcess;
    }
}

//******************************************************************************
BOOL CDebuggerThread::RemoveProcess(CProcess *pProcess)
{
    // Loop through our process list.
    for (CProcess *pPrev = NULL, *pCur = m_pProcessHead; pCur;
        pPrev = pCur, pCur = pCur->m_pNext)
    {
        // Check for match.
        if (pCur == pProcess)
        {
            // Remove this process from the list.
            if (pPrev)
            {
                pPrev->m_pNext = pCur->m_pNext;
            }
            else
            {
                m_pProcessHead = pCur->m_pNext;
            }

            // Delete the process object and return success.
            delete pProcess;

            return TRUE;
        }
    }
    return FALSE;
}

//******************************************************************************
DWORD CDebuggerThread::Thread()
{
    NameThread(m_pProcessHead->m_pModuleHead->GetName(false));

    // Tell the OS that we want all errors and warnings, no matter how minor they are.
    SetDebugErrorLevel(SLE_WARNING);

    STARTUPINFO si;
    ZeroMemory(&si, sizeof(si)); // inspected
    si.cb = sizeof(si);

    // The default ShowWindow flag is SW_SHOWDEFAULT which is what NT's CMD.EXE
    // uses.  However, everything else uses SW_SHOWNORMAL, such as the shell,
    // task manager, VC's debugger, and 9x's COMMAND.COM. Since SW_SHOWNORMAL
    // is more common, that is what we want to simulate.
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWNORMAL;

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi)); // inspected

    // Tech note Q175986: We need to set lpApplicationName to NULL and stuff
    // both the path and arguments into the lpCommandLine buffer so that the
    // remote application receives the correct command line.
    // 
    // Up to version 2.0 beta 5, I always passed DEBUG_PROCESS and optionally passed
    // DEBUG_ONLY_THIS_PROCESS to CreateProcess.  The docs are a bit confusing on
    // these flags, but it appears on Win2K, using DEBUG_PROCESS overrides
    // DEBUG_ONLY_THIS_PROCESS, resulting in child processes being debugged.  From
    // some tests, I found that just specifying DEBUG_ONLY_THIS_PROCESS alone is the
    // right thing to do when we don't want child processes.

    m_fCreateProcess = CreateProcess( // inspected. uses full path.
        NULL, m_pszCmdLine, NULL, NULL, FALSE,
        CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS |
        ((m_dwFlags & PF_PROFILE_CHILDREN) ? DEBUG_PROCESS : DEBUG_ONLY_THIS_PROCESS),
        NULL, (m_pszDirectory && *m_pszDirectory) ? m_pszDirectory : NULL, &si, &pi);

    // Store any error that may have occurred.
    m_dwError = GetLastError();

    // Wake our main thread in our BeginProcess() function.
    SetEvent(m_hevaCreateProcessComplete);

    // Bail now if we failed to create the process.
    if (!m_fCreateProcess)
    {
        return 0;
    }

    // Close the thread and process handles since we won't be needing them.
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    // We store the process ID in this module's object so we can identify it later.
    m_pProcessHead->m_dwProcessId = pi.dwProcessId;

    // Loop on debug events.
    do
    {

#if 0 // #ifdef _IA64_ //!! hack for NTBUG 175269 - bug has been fixed
        
        // On IA64, we only receive the EXIT_PROCESS_DEBUG_EVENT event when the debuggee
        // peacefully self-terminates.  It it crashes or we call TerminateProcess on it,
        // then we do not receive the event.  So, until the OS fixes this, we have a work
        // around that just polls for a debug event, then checks to see if any debuggees
        // have exited.  If one exits, then we simulate a EXIT_PROCESS_DEBUG_EVENT event.
        bool fProcessExited = false;
        while (!fProcessExited && !WaitForDebugEvent(&m_de, 1000))
        {
            for (CProcess *pProcess, *pProcessNext = m_pProcessHead; pProcess = pProcessNext;
                 pProcessNext = pProcess->m_pNext)
            { 
                if (WaitForSingleObject(pProcess->m_hProcess, 0) == WAIT_OBJECT_0)
                {
                    // If the process exited, then fake a EXIT_PROCESS_DEBUG_EVENT event.
                    m_de.dwDebugEventCode         = EXIT_PROCESS_DEBUG_EVENT;
                    m_de.dwProcessId              = pProcess->m_dwProcessId;
                    m_de.dwThreadId               = pProcess->m_pThreadHead ? pProcess->m_pThreadHead->m_dwThreadId : 0;
                    m_de.u.ExitProcess.dwExitCode = 0xDEAD;
                    fProcessExited = true;
                    break;
                }
            }
        }

#else

        // Wait for the next debug event.
        if (!WaitForDebugEvent(&m_de, INFINITE))
        {
            TRACE("WaitForDebugEvent() failed [%u]\n", GetLastError());

            g_dwReturnFlags |= DWRF_PROFILE_ERROR;

            //!! We need a thread safe error message to user here.
            break;
        }
#endif

        // Our default is to continue execution for all debug events.
        m_dwContinue = DBG_CONTINUE;

        // If we are running in console mode, then we don't actually create any
        // threads.  Therefore, we don't need to change to our main thread's
        // context since we are already running on our main thread.
        if (g_theApp.m_cmdInfo.m_fConsoleMode)
        {
            MainThreadCallback();
        }
        else
        {
            // Jump to the main thread's context and continue processing this debug
            // event.  That code might change m_dwContinue.
            g_pMainFrame->CallMeBackFromTheMainThreadPlease(StaticMainThreadCallback, (LPARAM)this);
        }

        // Done processing event so let the process resume execution.
        ContinueDebugEvent(m_de.dwProcessId, m_de.dwThreadId, m_dwContinue);

        // Loop while we still have processes in our process list.
    } while (m_pProcessHead);

    // Looks like we are all done. If we are not in console mode, then delete ourself.
    if (!g_theApp.m_cmdInfo.m_fConsoleMode)
    {
        EnterCriticalSection(&ms_cs); // inspected
        delete this;
        LeaveCriticalSection(&ms_cs);
    }

    return 0;
}

//******************************************************************************
void CDebuggerThread::MainThreadCallback()
{
    CProcess *pProcess;

    // If this is a new process, then create a new process node for it.
    if (m_de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
    {
        pProcess = EventCreateProcess();
    }

    // Otherwise, attempt to look this process up in our process list.
    else
    {
        pProcess = FindProcess(m_de.dwProcessId);
    }

    // If we failed to find or create a process node, then bail now.
    if (!pProcess)
    {
        g_dwReturnFlags |= DWRF_PROFILE_ERROR;
        TRACE("Event %u received but no matching process was found.", m_de.dwDebugEventCode);
        return;
    }

    // Send the message to the appropriate process.
    m_dwContinue = pProcess->HandleEvent(&m_de);
}

//******************************************************************************
CProcess* CDebuggerThread::EventCreateProcess()
{
    // Attempt to get the image name from the debug event.
    CHAR szModule[DW_MAX_PATH];
    *szModule = '\0';

    // We need to close the file handle or else we hold the file open.
    CloseHandle(m_de.u.CreateProcessInfo.hFile);

    // Make sure a valid name pointer was passed to us.
    if (m_de.u.CreateProcessInfo.lpImageName)
    {
        // The pointer we are passed is actually a pointer to a string pointer.
        // We need to get the actual string pointer from the remote process.
        LPVOID lpvAddress = NULL;
        if (ReadRemoteMemory(m_de.u.CreateProcessInfo.hProcess,
                             m_de.u.CreateProcessInfo.lpImageName,
                             &lpvAddress, sizeof(lpvAddress)) && lpvAddress)
        {
            // Now we retrieve the string itself.
            ReadRemoteString(m_de.u.CreateProcessInfo.hProcess,
                             szModule, sizeof(szModule),
                             lpvAddress, m_de.u.CreateProcessInfo.fUnicode);
        }
    }

    CProcess *pProcess = NULL;

    // Check to see if this is our main module.  Our main module already has a
    // CProcess object, so we don't need to create a new one.
    if (m_pProcessHead && (m_pProcessHead->m_dwProcessId == m_de.dwProcessId))
    {
        // Yep, this is our main process.
        pProcess = m_pProcessHead;

        // If we got an image name from the debug event, then update our module's
        // object to use this new name.
        if (*szModule)
        {
            pProcess->m_pModule->SetPath(szModule);
        }

        // The CProcess object set this value when it was created, but that might
        // have been a few hundred milliseconds ago, so we re-set it here.
        pProcess->m_dwStartingTickCount = GetTickCount();
    }

    // Otherwise, this is a child process and we need to create a new process node.
    else
    {
        // Create a module object so the process object has something to point to.
        CLoadedModule *pModule = new CLoadedModule(NULL, 0, *szModule ? szModule : NULL);
        if (!pModule)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // Create a new process node.  On Windows NT, the create process debug
        // event never points to an image name, so szModule will be empty.  For the
        // main process, this is Ok since we created the CProcess for that
        // process back when we knew the image name (we needed it to call
        // CreateProcess with).  However, for child processes, we are screwed since
        // they are launched by the remote process and we have no idea what there
        // image name is.  For this case, we let our injection DLL send us the name
        // during initialization, and we then fill in the image name member.
        if (!(pProcess = new CProcess(NULL, this, m_dwFlags & ~(PF_LOG_CLEAR | PF_SIMULATE_SHELLEXECUTE), pModule)))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // Set our process id.
        pProcess->m_dwProcessId = m_de.dwProcessId;

        // Add the process node to the end of our process list.
        AddProcess(pProcess);
    }

    // If we don't have a session for this module yet, we have a module name,
    // and we are not hooking, then create a session for it now.  If we are hooking
    // then we need to wait until our DLL gets injected so that we can get the
    // path, args, and starting directory strings.
    if (!pProcess->m_pSession && *szModule && !(m_dwFlags & PF_HOOK_PROCESS) && !m_fTerminate)
    {
        if (!(pProcess->m_pSession = g_theApp.CreateNewSession(pProcess->m_pModule->GetName(true), pProcess)))
        {
            g_dwReturnFlags |= DWRF_PROFILE_ERROR;
        }
    }

    return pProcess;
}


//******************************************************************************
//***** CProcess
//******************************************************************************

CProcess::CProcess(CSession *pSession, CDebuggerThread *pDebuggerThread, DWORD dwFlags, CLoadedModule *pModule) :
    m_pNext(NULL),
    m_pDebuggerThread(pDebuggerThread),
    m_pThreadHead(NULL),
    m_pModuleHead(pModule),
    m_pEventHead(NULL),
    m_pSession(pSession),
    m_pThread(NULL),
    m_pModule(pModule),
    m_contextOriginal(CONTEXT_FULL),
    m_dwStartingTickCount(GetTickCount()),
    m_fProfileError(false),
    m_dwFlags(dwFlags),
    m_fTerminate(false),
    m_fDidHookForThisEvent(false),
    m_fInitialBreakpoint(false),
    m_pbOriginalPage(NULL),
    m_dwpPageAddress(0),
    m_dwPageSize(0),
    m_dwpKernel32Base(0),
    m_fKernel32Initialized(false),
    m_dwpDWInjectBase(0),
    m_dwThreadNumber(0),
    m_dwProcessId(0),
    m_hProcess(NULL),
    m_pszArguments(NULL),
    m_pszDirectory(NULL),
    m_pszSearchPath(NULL)
{
    ZeroMemory(m_HookFunctions, sizeof(m_HookFunctions)); // inspected
    m_HookFunctions[0].szFunction = "LoadLibraryA";
    m_HookFunctions[1].szFunction = "LoadLibraryW";
    m_HookFunctions[2].szFunction = "LoadLibraryExA";
    m_HookFunctions[3].szFunction = "LoadLibraryExW";
    m_HookFunctions[4].szFunction = "GetProcAddress";

    // Initialize the function addresses with the default. We are going to
    // step on these later, but they are better than NULL for now.
    m_HookFunctions[0].dwpOldAddress = (DWORD_PTR)LoadLibraryA;   // inspected. not actually a call.
    m_HookFunctions[1].dwpOldAddress = (DWORD_PTR)LoadLibraryW;   // inspected. not actually a call.
    m_HookFunctions[2].dwpOldAddress = (DWORD_PTR)LoadLibraryExA; // inspected. not actually a call.
    m_HookFunctions[3].dwpOldAddress = (DWORD_PTR)LoadLibraryExW; // inspected. not actually a call.
    m_HookFunctions[4].dwpOldAddress = (DWORD_PTR)GetProcAddress;
}

//******************************************************************************
CProcess::~CProcess()
{
    // We used to close m_hProcess here, but we are not supposed to do that.
    // ContinueDebugEvent() does this for us when the process closes.  On XP, 
    // we were getting a EXCEPTION_INVALID_HANDLE thrown in ContinueDebugEvent.
    m_hProcess = NULL;

    // Flush everything, even if we are caching.
    FlushEvents(true);

    // Delete all thread objects
    while (m_pThreadHead)
    {
        RemoveThread(m_pThreadHead);
    }

    // Delete all module objects
    while (m_pModuleHead)
    {
        RemoveModule(m_pModuleHead);
    }

    // Our session should clear it's pointer to us when it receives the
    // end process event, but just in case we failed to send it that event,
    // we will clear it for it.
    if (m_pSession)
    {
        m_pSession->m_pProcess = NULL;
        m_pSession = NULL;
    }

    // If we still have a page allocated, free it now.
    if (m_pbOriginalPage)
    {
        MemFree((LPVOID&)m_pbOriginalPage);
    }

    MemFree((LPVOID&)m_pszArguments);
    MemFree((LPVOID&)m_pszDirectory);
    MemFree((LPVOID&)m_pszSearchPath);
}

//******************************************************************************
void CProcess::SetProfileError()
{
    m_fProfileError = true;
    if (m_pSession)
    {
        m_pSession->m_dwReturnFlags |= DWRF_PROFILE_ERROR;
    }
    g_dwReturnFlags |= DWRF_PROFILE_ERROR;
}

//******************************************************************************
DWORD CProcess::HandleEvent(DEBUG_EVENT *pde)
{
    DWORD dwResult = DBG_CONTINUE;

    // We only want to hook once per event, so we clear this flag now and set
    // it when HookLoadedModules is called.
    m_fDidHookForThisEvent = false;

    // Decide what type of event we have just received.
    switch (pde->dwDebugEventCode)
    {
        case CREATE_PROCESS_DEBUG_EVENT: dwResult = EventCreateProcess(&pde->u.CreateProcessInfo, pde->dwThreadId);             break;
        case EXIT_PROCESS_DEBUG_EVENT:   dwResult = EventExitProcess(  &pde->u.ExitProcess,       FindThread(pde->dwThreadId)); break;
        case CREATE_THREAD_DEBUG_EVENT:  dwResult = EventCreateThread( &pde->u.CreateThread,      pde->dwThreadId);             break;
        case EXIT_THREAD_DEBUG_EVENT:    dwResult = EventExitThread(   &pde->u.ExitThread,        FindThread(pde->dwThreadId)); break;
        case LOAD_DLL_DEBUG_EVENT:       dwResult = EventLoadDll(      &pde->u.LoadDll,           FindThread(pde->dwThreadId)); break;
        case UNLOAD_DLL_DEBUG_EVENT:     dwResult = EventUnloadDll(    &pde->u.UnloadDll,         FindThread(pde->dwThreadId)); break;
        case OUTPUT_DEBUG_STRING_EVENT:  dwResult = EventDebugString(  &pde->u.DebugString,       FindThread(pde->dwThreadId)); break;
        case EXCEPTION_DEBUG_EVENT:      dwResult = EventException(    &pde->u.Exception,         FindThread(pde->dwThreadId)); break;
        case RIP_EVENT:                  dwResult = EventRip(          &pde->u.RipInfo,           FindThread(pde->dwThreadId)); break;
        default:                         TRACE("Unknown debug event (%u) was received.", pde->dwDebugEventCode);                break;
    }

    // After each event, we attempt to hook any modules that need to be hooked
    // for the first time, or rehook any that may have failed to hook earlier.
    // We don't do this for EXIT_PROCESS_DEBUG_EVENT since EventExitProcess
    // may delete our process object.
    if (EXIT_PROCESS_DEBUG_EVENT != pde->dwDebugEventCode)
    {
        HookLoadedModules();
    }

    return dwResult;
}

//******************************************************************************
DWORD CProcess::EventCreateProcess(CREATE_PROCESS_DEBUG_INFO *pde, DWORD dwThreadId)
{
    // Add the process' main thread to our active thread list and point our process to it.
    m_pThread = AddThread(dwThreadId, pde->hThread);

#if 0 // #ifdef _IA64_ //!! hack for NTBUG 175269 - bug has been fixed

    // As part of our WaitForDebugEvent hack in our Thread function, we need to ensure
    // the process handle we receive from this debug event has SYNCHRONIZE access so
    // we can call WaitForSingleObject on it.  By default it does not, so we make a
    // duplicate of the handle that has PROCESS_ALL_ACCESS and close the original.
    if (DuplicateHandle(GetCurrentProcess(), pde->hProcess, GetCurrentProcess(), &m_hProcess, PROCESS_ALL_ACCESS, FALSE, 0))
    {
        // If we succeed, then close the original.
        CloseHandle(pde->hProcess);
    }
    else
    {
        // If we failed, then just use the original.
        m_hProcess = pde->hProcess;
    }

#else

    // Store the process handle.
    m_hProcess = pde->hProcess;

#endif

    // Store the image base.
    m_pModule->m_dwpImageBase = (DWORD_PTR)pde->lpBaseOfImage;

    // Read the virtual size of this module from its PE header.
    if (!GetVirtualSize(m_pModule))
    {
        // Errors displayed by GetVirtualSize.
        SetProfileError();
    }

    // Do a flush to be safe, but we really shouldn't ever have any cached
    // events at this point.
    FlushEvents();

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventCreateProcess *pEvent = new CEventCreateProcess(m_pThread, m_pModule);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventCreateProcess event(m_pThread, m_pModule);
        m_pSession->EventCreateProcess(&event);
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CProcess::EventExitProcess(EXIT_PROCESS_DEBUG_INFO *pde, CThread *pThread)
{
    DWORD dwResult = DBG_CONTINUE;

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventExitProcess *pEvent = new CEventExitProcess(pThread, m_pModule, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventExitProcess event(pThread, m_pModule, pde);
        dwResult = m_pSession->EventExitProcess(&event);
    }

    // Remove the thread from our active thread list.
    RemoveThread(pThread);

    // Remove the module from our active module list.
    RemoveModule(m_pModule);

    // Remove the process from our process list.
    m_pDebuggerThread->RemoveProcess(this);

    return dwResult;
}

//******************************************************************************
DWORD CProcess::EventCreateThread(CREATE_THREAD_DEBUG_INFO *pde, DWORD dwThreadId)
{
    // Add the thread to our active thread list.
    CThread *pThread = AddThread(dwThreadId, pde->hThread);

    // Attempt to locate the module that this thread is starting in.
    CLoadedModule *pModule = FindModule((DWORD_PTR)pde->lpStartAddress);

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventCreateThread *pEvent = new CEventCreateThread(pThread, pModule, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventCreateThread event(pThread, pModule, pde);
        return m_pSession->EventCreateThread(&event);
    }
    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CProcess::EventExitThread(EXIT_THREAD_DEBUG_INFO *pde, CThread *pThread)
{
    DWORD dwResult = DBG_CONTINUE;

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventExitThread *pEvent = new CEventExitThread(pThread, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventExitThread event(pThread, pde);
        dwResult = m_pSession->EventExitThread(&event);
    }

    // Remove the thread from our active thread list.
    RemoveThread(pThread);

    return dwResult;
}

//******************************************************************************
DWORD CProcess::EventLoadDll(LOAD_DLL_DEBUG_INFO *pde, CThread *pThread)
{
    // Attempt to get the image name from the debug event.
    CHAR szModule[DW_MAX_PATH];
    *szModule = '\0';

    // We need to close the file handle or else we hold the file open.
    CloseHandle(pde->hFile);

    // Make sure a valid name pointer was passed to us.
    LPVOID lpvAddress = NULL;
    if (pde->lpImageName)
    {
        // The pointer we are passed is actually a pointer to a string pointer.
        // We need to get the actual string pointer from the remote process.
        if (ReadRemoteMemory(m_hProcess, pde->lpImageName, &lpvAddress, sizeof(lpvAddress)) && lpvAddress)
        {
            // Now we retrieve the string itself.
            ReadRemoteString(m_hProcess, szModule, sizeof(szModule), lpvAddress, pde->fUnicode);
        }
        else
        {
            lpvAddress = NULL;
        }
    }

    // Because of the way Windows NT loads processes, the process name and the
    // the first DLL name are not set in the debug structure.  The first DLL
    // should always be NTDLL.DLL.  Here we check to see if we failed to obtain
    // a module name string, and if so, we check to see if the module is really
    // NTDLL.DLL.  Update: Somewhere around beta 1 of Whistler, we actually get
    // the string "ntdll.dll" back, but with no path.  This was sending our 
    // CSession::ChangeModulePath() into an infinite loop as it does not like
    // pathless files.  Now, we special case any files with no name or no path.
    if (szModule == GetFileNameFromPath(szModule))
    {
        // Load NTDLL.DLL if not already loaded - it will be freed later.
        if (!g_theApp.m_hNTDLL)
        {
            g_theApp.m_hNTDLL = LoadLibrary("ntdll.dll"); // inspected
        }

        // Check to see if it matches this module.
        *szModule = '\0';
        if (g_theApp.m_hNTDLL && ((DWORD_PTR)g_theApp.m_hNTDLL == (DWORD_PTR)pde->lpBaseOfDll))
        {
            GetModuleFileName(g_theApp.m_hNTDLL, szModule, sizeof(szModule));
        }

        // If we still don't know the name, try using a PSAPI call.
        if (!*szModule)
        {
            GetModuleName((DWORD_PTR)pde->lpBaseOfDll, szModule, sizeof(szModule));
        }

        // If we still don't know the name, go back to what we originally had.
        if (!*szModule && lpvAddress)
        {
            ReadRemoteString(m_hProcess, szModule, sizeof(szModule), lpvAddress, pde->fUnicode);
        }
    }

    // Create a new module object for this module and insert it into our list.
    CLoadedModule *pModule = AddModule((DWORD_PTR)pde->lpBaseOfDll, *szModule ? szModule : NULL);

    // Get the session module name if we don't have one already.
    GetSessionModuleName();

    // Check to see if we are supposed to inject our DLL.
    if (m_dwFlags & PF_HOOK_PROCESS)
    {
        // Check to see if this module is KERNEL32.DLL and that we haven't already
        // processed it.  We really should not ever see KERNEL32.DLL loading more
        // than once.
        if (!_stricmp(pModule->GetName(false), "kernel32.dll") && !m_dwpKernel32Base)
        {
            // Make note that KERNEL32.DLL loaded.  Kernerl32 must be loaded before
            // we can inject our DEPENDS.DLL module.
            m_dwpKernel32Base = (DWORD_PTR)pde->lpBaseOfDll;

            // Read in the ordinal values from KERNEL32 that will be later needed by
            // HookImports() in order to hook modules that link to KERNEL32 functions
            // by ordinal.
            if (!ReadKernelExports(pModule))
            {
                SetProfileError();
                UserMessage("Error reading KERNEL32.DLL's export table.  Function call tracking may not work properly.", GetLastError(), NULL);
            }
        }

        // Check to see if this module is DEPENDS.DLL and that we are in the middle of loading it.
        else if (!_stricmp(pModule->GetName(false), "depends.dll") && m_pbOriginalPage)
        {
            // Make note that DEPENDS.DLL loaded.
            m_dwpDWInjectBase = (DWORD_PTR)pde->lpBaseOfDll;

            // Flag this DLL as the injection DLL.
            pModule->m_hookStatus = HS_INJECTION_DLL;

            // We used to walk the exports of DEPENDS.DLL right here, but this fails on WOW64
            // since the module is not properly mapped into virtual memory yet.  Instead, we
            // wait until the LoadLibrary call returns.
        }

        // Usually we just let HandleEvent() call HookLoadedModules after each event
        // is processed.  However, since we just loaded a new module, we need to hook
        // this module before calling ProcessLoadDll, otherwise, ProcessLoadDll
        // would tell our session that module has not been hooked.
        HookLoadedModules();
    }

    return ProcessLoadDll(pThread, pModule);
}

//******************************************************************************
DWORD CProcess::ProcessLoadDll(CThread *pThread, CLoadedModule *pModule)
{
    // Now it is time to create the DLL event object and decide what to do with it.
    CEventLoadDll *pDll = NULL;

    // Check to see if we are in a function call.
    if (pThread && pThread->m_pEventFunctionCallCur)
    {
        // If we are, then we know we have to allocate an event, so do so now.
        if (!(pDll = new CEventLoadDll(pThread, pModule, true)))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // Check to see if we already have one or more DLLs for this function object.
        if (pThread->m_pEventFunctionCallCur->m_pDllHead)
        {
            // Walk to end of DLL list.
            for (CEventLoadDll *pLast = pThread->m_pEventFunctionCallCur->m_pDllHead;
                pLast->m_pNextDllInFunctionCall; pLast = pLast->m_pNextDllInFunctionCall)
            {
            }

            // Add our new node at end of the list.
            pLast->m_pNextDllInFunctionCall = pDll;
        }

        // Otherwise, add the node to the root of the DLL list.
        else
        {
            pThread->m_pEventFunctionCallCur->m_pDllHead = pDll;
        }
    }

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // If we already have a dll event, then add another reference to it.
        if (pDll)
        {
            pDll->AddRef();
        }

        // Otherwise, create a new dll event.
        else
        {
            if (!(pDll = new CEventLoadDll(pThread, pModule, false)))
            {
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            }
        }

        // We cache this event until we do have a session.
        AddEvent(pDll);
    }
    else if (m_pSession)
    {
        // If we created a dynamic dll event, then just pass it to our session.
        if (pDll)
        {
            return m_pSession->EventLoadDll(pDll);
        }

        // Otherwise, create a temporary event object on our stack and pass it to our session.
        else
        {
            CEventLoadDll event(pThread, pModule, false);
            return m_pSession->EventLoadDll(&event);
        }
    }
    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CProcess::EventUnloadDll(UNLOAD_DLL_DEBUG_INFO *pde, CThread *pThread)
{
    DWORD dwResult = DBG_CONTINUE;

    // Attempt to locate this module.
    CLoadedModule *pModule = FindModule((DWORD_PTR)pde->lpBaseOfDll);

    if (pModule) {
        // If we are currently caching, then just store this event away for later.
        if (IsCaching())
        {
        // Allocate a new event object for this event and add it to our event list.
        CEventUnloadDll *pEvent = new CEventUnloadDll(pThread, pModule, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
        }
        else if (m_pSession)
        {
        // Create a temporary event object on our stack and pass it to our session.
        CEventUnloadDll event(pThread, pModule, pde);
        dwResult = m_pSession->EventUnloadDll(&event);
        }

        // Remove the module from our active module list.  If we have cached events
        // pointing at this module, then it will not be freed until those events
        // have been flushed and destroyed.
        RemoveModule(pModule);
    }

    return dwResult;
}

//******************************************************************************
DWORD CProcess::EventDebugString(OUTPUT_DEBUG_STRING_INFO *pde, CThread *pThread)
{
    // We need to process debug messages if we are injecting or the user wants to see them.
    if ((m_dwFlags & (PF_HOOK_PROCESS | PF_LOG_DEBUG_OUTPUT)) && pde->lpDebugStringData)
    {
        // Attempt to read the string from the remote process.
        CHAR szText[DW_MAX_PATH];
        *szText = '\0';
        ReadRemoteString(m_hProcess, szText, sizeof(szText), pde->lpDebugStringData, pde->fUnicode);

        // Check for a private message from our DEPENDS.DLL module
        if (!strncmp(szText, "", 3))
        {
            ProcessDllMsgMessage(pThread, szText);
        }

        // Otherwise, just forward the fixed-up event to our session.
        else if (*szText && (m_dwFlags & PF_LOG_DEBUG_OUTPUT))
        {
            // Attempt to locate this module that generated this text.
            CLoadedModule *pModule = FindModule((DWORD_PTR)pde->lpDebugStringData);

            // If we are currently caching, then just store this event away for later.
            if (IsCaching())
            {
                // Allocate a new event object for this event and add it to our event list.
                CEventDebugString *pEvent = new CEventDebugString(pThread, pModule, szText, TRUE);
                if (!pEvent)
                {
                    RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
                }
                AddEvent(pEvent);
            }
            else if (m_pSession)
            {
                // Create a temporary event object on our stack and pass it to our session.
                CEventDebugString event(pThread, pModule, szText, FALSE);
                return m_pSession->EventDebugString(&event);
            }
        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CProcess::EventException(EXCEPTION_DEBUG_INFO *pde, CThread *pThread)
{

#if 0 //#ifdef _IA64_ //!! testing
    TRACE("EXCEPTION - CODE: 0x%08X, ADDRESS: " HEX_FORMAT ", FIRST: %u, FLAGS: 0x%08X\n", pde->ExceptionRecord.ExceptionCode, pde->ExceptionRecord.ExceptionAddress, pde->dwFirstChance, pde->ExceptionRecord.ExceptionFlags);
    BYTE b[112], *pb = b;
    ZeroMemory(b, sizeof(b)); // inspected
    DWORD_PTR dwp = ((DWORD_PTR)pde->ExceptionRecord.ExceptionAddress & ~0xFui64) - 48;
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwp, b, sizeof(b)))
    {
        TRACE("ReadRemoteMemory("HEX_FORMAT") failed [%u]\n", dwp, GetLastError());
        dwp += 48;
        if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwp, b, sizeof(b)))
        {
            TRACE("ReadRemoteMemory("HEX_FORMAT") failed [%u]\n", dwp, GetLastError());
        }
    }
    for (int i = 0; i < sizeof(b) / 16; i++)
    {
        TRACE("   " HEX_FORMAT ": ", dwp);
        for (int j = 15; j >= 0; j--, dwp++)
        {
            TRACE(j ? "%02X " : "%02X\n", pb[j]);
        }
        pb += 16;
    }
#endif

    DWORD_PTR dwpExceptionAddress = (DWORD_PTR)pde->ExceptionRecord.ExceptionAddress;

#if defined(_IA64_)

    // We need to special case breakpoints on IA64 machines.  Unlike x86, on
    // an IA64 machine, we need to move the instruction pointer over the
    // breakpoint or else we will just hit it again when we resume.  The IA64
    // uses two registers to identify the current instruction. The StIIP register
    // points to bundle the caused the exception.  Bits 41 and 42 of StIPSR
    // indicate what slot the actual instruction lives in.  So, for slots 0
    // and 1, we just increment the slot number and resume.  If we are in slot 2,
    // then we reset to slot 0 and increment to the next bundle.

    if (pThread && (pde->ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT))
    {
        CContext context(CONTEXT_CONTROL); // only need StIIP and StIPSR

        if (GetThreadContext(pThread->m_hThread, context.Get()))
        {
            ULONGLONG ullPsrRi = ((context.Get()->StIPSR >> IA64_PSR_RI) & 3ui64) + 1;
            if (ullPsrRi > 2)
            {
                ullPsrRi = 0;
                context.Get()->StIIP += 0x10ui64;
            }
            context.Get()->StIPSR &= ~(3ui64 << IA64_PSR_RI);
            context.Get()->StIPSR |= (ullPsrRi << IA64_PSR_RI);
            SetThreadContext(pThread->m_hThread, context.Get());
        }
    }

    // Round the address down to the nearest bundle.
    dwpExceptionAddress &= ~0xFui64;

#elif defined(_ALPHA_) || defined(_ALPHA64_)

    // We need to special case breakpoints on Alpha machines.  Unlike x86, on
    // an Alpha machine, we need to move the instruction pointer over the
    // breakpoint or else we will just hit it again when we resume.

    if (pThread && (pde->ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT))
    {
        CContext context(CONTEXT_CONTROL); // only need Fir

        if (GetThreadContext(pThread->m_hThread, context.Get()))
        {
            context.Get()->Fir += 4;
            SetThreadContext(pThread->m_hThread, context.Get());
        }
    }
#endif

    // Attempt to locate the module that the exception occurred in.
    CLoadedModule *pModule = FindModule((DWORD_PTR)pde->ExceptionRecord.ExceptionAddress);

    // We special case breakpoints.
    if (pde->ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT)
    {
        // After we inject, we should get a breakpoint from our magic code page in
        // the remote process, unless the application is doing really gross things
        // on NT like do LoadLibrary() calls in DllMains which contain hard coded
        // breakpoints in their DllMains.  To be safe, we make sure the breakpoint
        // is coming from the page of memory we replaced.
        if (m_pbOriginalPage &&
            ((DWORD_PTR)pde->ExceptionRecord.ExceptionAddress >= m_dwpPageAddress) &&
            ((DWORD_PTR)pde->ExceptionRecord.ExceptionAddress < (m_dwpPageAddress + (DWORD_PTR)m_dwPageSize)))
        {
            // If our injection DLL failed to load, then we just continue without it.
            if (!m_dwpDWInjectBase)
            {
                // Get the error value from the remote process.
                CContext context(CONTEXT_INTEGER); // only need IntV0 (IA64) and Eax (x86)
                DWORD dwError = 0;
                if (pThread && GetThreadContext(pThread->m_hThread, context.Get()))
                {

#if defined(_IA64_)

                    dwError = (DWORD)context.Get()->IntV0; // IntV0 is really r8/ret0.

#elif defined(_X86_)

                    dwError = (DWORD)context.Get()->Eax;

#elif defined(_ALPHA_) || defined(_ALPHA64_)

                    // We currently don't call GetLastError in the alpha asm we inject.
                    // If we did, then context.IntV0 would contain the return value.
                    // It is on my todo list, but alpha as a platform is dead for now.
                    dwError = 0; //!! (DWORD)context.IntV0

#elif defined(_AMD64_)

                    dwError = (DWORD)context.Get()->Rax;

#else
#error("Unknown Target Machine");
#endif

                }
                UserMessage("The hooking code was successfully injected, but DEPENDS.DLL failed to load.", dwError, NULL);
                m_dwFlags &= ~PF_HOOK_PROCESS;
                SetProfileError();
                GetSessionModuleName();
            }

            // Restore the code page we stepped on earlier.
            if (!ReplaceOriginalPageAndContext())
            {
                // Errors will be displayed by ReplaceOriginalPageAndContext.
                SetProfileError();
            }

            // Read in the DEPENDS.DLL functions so we know where to redirect function
            // calls that we hook.
            if (m_dwpDWInjectBase && !ReadDWInjectExports(FindModule(m_dwpDWInjectBase)))
            {
                SetProfileError();
                UserMessage("Error reading DEPENDS.DLL's export table.  Function call tracking may not work properly.", GetLastError(), NULL);
            }

            // Now that our injection module is loaded, attempt to hook all previously
            // loaded modules.  Errors will be handled by HookLoadedModules.
            HookLoadedModules();

            // All modules loaded so far should be hooked and we should have a session.
            // Time to flush all the events to session and start running "live".
            FlushEvents();

            return DBG_CONTINUE;
        }

        // Check to see if this breakpoint is at the entrypoint to the module and that it is not our main module.
        else if (dwpExceptionAddress && pModule && (pModule != m_pModule) &&
                 (dwpExceptionAddress == pModule->m_dwpEntryPointAddress))
        {
            if (!EnterEntryPoint(pThread, pModule))
            {
                // Errors will be displayed by EnterEntryPoint.
                SetProfileError();
            }
            return DBG_CONTINUE;
        }

        // Check to see if this breakpoint is at our fake return address from the entrypoint.
        else if (dwpExceptionAddress && pModule && (pModule != m_pModule) &&
                 (dwpExceptionAddress == (pModule->m_dwpImageBase + BREAKPOINT_OFFSET)))
        {
            // Check to see if this was kernel32.dll
            if (pModule->m_dwpImageBase == m_dwpKernel32Base)
            {
                m_fKernel32Initialized = true;
            }

            if (!ExitEntryPoint(pThread, pModule))
            {
                // Errors will be displayed by ExitEntryPoint.
                SetProfileError();
            }

            // If we want to hook the process, are on NT, have loaded kernel32,
            // and have not loaded DEPENDS.DLL, then hook now.
            if ((m_dwFlags & PF_HOOK_PROCESS) && g_fWindowsNT &&
                m_dwpKernel32Base && m_fKernel32Initialized && !m_dwpDWInjectBase)
            {
                if (!InjectDll())
                {
                    // Error will be displayed by InjectDll.
                    m_dwFlags &= ~PF_HOOK_PROCESS;
                    SetProfileError();
                    GetSessionModuleName();
                    FlushEvents();
                }
            }

            return DBG_CONTINUE;
        }

        // Check to see if this is our initial breakpoint - the entrypoint.
        else if ((m_dwFlags & PF_HOOK_PROCESS) && !m_fInitialBreakpoint)
        {
            // Get the session module name if we don't have one already.
            GetSessionModuleName();

            // Add this exception to our cache so that the session will know when we hit
            // the initial breakpoint.
            CEventException *pEvent = new CEventException(pThread, pModule, pde);
            if (!pEvent)
            {
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            }
            AddEvent(pEvent);

            // Make a note that we hit the initial breakpoint.
            m_fInitialBreakpoint = true;

            // If kernel32 is loaded and we are on Windows 9x, then inject our DEPENDS.DLL module.
            if (!g_fWindowsNT)
            {
                if (m_dwpKernel32Base)
                {
                    if (!InjectDll())
                    {
                        // Error will be displayed by InjectDll.
                        m_dwFlags &= ~PF_HOOK_PROCESS;
                        SetProfileError();
                        GetSessionModuleName();
                        FlushEvents();
                    }
                }
                else
                {
                    UserMessage("The process cannot be hooked since KERNEL32.DLL is not loaded.", 0, NULL);
                    m_dwFlags &= ~PF_HOOK_PROCESS;
                    SetProfileError();
                    GetSessionModuleName();
                    FlushEvents();
                }
            }
            return DBG_CONTINUE;
        }
    }

    // We also special case the Visual C++ thread naming exception.
    else if (pde->ExceptionRecord.ExceptionCode == EXCEPTION_MS_THREAD_NAME)
    {
        EventExceptionThreadName(pde, pThread);
    }

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventException *pEvent = new CEventException(pThread, pModule, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventException event(pThread, pModule, pde);
        return m_pSession->EventException(&event);
    }
    // We return "continue" for breakpoints and thread naming, and "not handled" for everything else.
    return ((pde->ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) ||
            (pde->ExceptionRecord.ExceptionCode == EXCEPTION_MS_THREAD_NAME)) ?
           DBG_CONTINUE : DBG_EXCEPTION_NOT_HANDLED;
}

//******************************************************************************
DWORD CProcess::EventExceptionThreadName(EXCEPTION_DEBUG_INFO *pde, CThread *pThread)
{
    // Make sure we have the minimum number of args. We allow for more args
    // in case the VC group decides to expand the structure in the future.
    if (pde->ExceptionRecord.NumberParameters >= sizeof(THREADNAME_INFO)/sizeof(DWORD))
    {
        // Map our structure onto the exception args.
        PTHREADNAME_INFO pInfo = (PTHREADNAME_INFO)pde->ExceptionRecord.ExceptionInformation;

        // Make sure the type signature is correct.
        if (pInfo->dwType == THREADNAME_TYPE)
        {
            // If the user did not pass in the current thread ID, then look it up.
            if ((pInfo->dwThreadId != -1) && (pInfo->dwThreadId != pThread->m_dwThreadId))
            {
                pThread = FindThread(pInfo->dwThreadId);
            }

            if (pThread)
            {
                // Attempt to read in the remote string.
                CHAR szName[MAX_THREAD_NAME_LENGTH + 1];
                *szName = '\0';
                if (ReadRemoteString(m_hProcess, szName, sizeof(szName),
                                     pInfo->pszName, FALSE) && *szName)
                {
                    // If the thread already has a name, then delete it.
                    MemFree((LPVOID&)pThread->m_pszThreadName);

                    // Store the new thread name.
                    pThread->m_pszThreadName = StrAlloc(szName);
                }
            }
        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CProcess::EventRip(RIP_INFO *pde, CThread *pThread)
{
    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventRip *pEvent = new CEventRip(pThread, pde);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventRip event(pThread, pde);
        return m_pSession->EventRip(&event);
    }
    return DBG_CONTINUE;
}

//******************************************************************************
CThread* CProcess::AddThread(DWORD dwThreadId, HANDLE hThread)
{
    if (!(m_pThreadHead = new CThread(dwThreadId, hThread, ++m_dwThreadNumber, m_pThreadHead)))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    return m_pThreadHead;
}

//******************************************************************************
void CProcess::RemoveThread(CThread *pThread)
{
    // Loop through all our thread objects.
    for (CThread *pPrev = NULL, *pCur = m_pThreadHead;
        pCur; pPrev = pCur, pCur = pCur->m_pNext)
    {
        // Look for match.
        if (pCur == pThread)
        {
            // Remove the thread from our list.
            if (pPrev)
            {
                pPrev->m_pNext = pCur->m_pNext;
            }
            else
            {
                m_pThreadHead = pCur->m_pNext;
            }

            // Force a flush to free any objects under us.
            FlushFunctionCalls(pCur);

            // Free our reference count on this thread object. If we are the last
            // one using this thread, it will delete itself.
            pCur->Release();

            return;
        }
    }
}

//******************************************************************************
CThread* CProcess::FindThread(DWORD dwThreadId)
{
    for (CThread *pCur = m_pThreadHead; pCur; pCur = pCur->m_pNext)
    {
        if (pCur->m_dwThreadId == dwThreadId)
        {
            return pCur;
        }
    }
    return NULL;
}

//******************************************************************************
CLoadedModule* CProcess::AddModule(DWORD_PTR dwpImageBase, LPCSTR pszImageName)
{
    if (!(m_pModuleHead = new CLoadedModule(m_pModuleHead, dwpImageBase, pszImageName)))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    if (!GetVirtualSize(m_pModuleHead))
    {
        // Errors will be displayed by GetVirtualSize
        SetProfileError();
    }

    if (!SetEntryBreakpoint(m_pModuleHead))
    {
        // Errors will be displayed by SetEntryBreakpoint
        SetProfileError();
    }
    return m_pModuleHead;
}

//******************************************************************************
void CProcess::RemoveModule(CLoadedModule *pModule)
{
    // Loop through all our module objects.
    for (CLoadedModule *pPrev = NULL, *pCur = m_pModuleHead;
        pCur; pPrev = pCur, pCur = pCur->m_pNext)
    {
        // Look for match.
        if (pCur == pModule)
        {
            // Remove the module from our list.
            if (pPrev)
            {
                pPrev->m_pNext = pCur->m_pNext;
            }
            else
            {
                m_pModuleHead = pCur->m_pNext;
            }

            // If we entered a DLL call, but never came out of it, we may be left
            // with a CEventDllMainCall lingering - free it now.
            if (pCur->m_pEventDllMainCall)
            {
                pCur->m_pEventDllMainCall->Release();
                pCur->m_pEventDllMainCall = NULL;
            }

            // Free our reference count on this module object. If we are the last
            // one using this module, it will delete itself.
            pCur->Release();

            return;
        }
    }
}

//******************************************************************************
CLoadedModule* CProcess::FindModule(DWORD_PTR dwpAddress)
{
    for (CLoadedModule *pCur = m_pModuleHead; pCur; pCur = pCur->m_pNext)
    {
        if ((dwpAddress >= pCur->m_dwpImageBase) &&
            (dwpAddress < (pCur->m_dwpImageBase + (DWORD_PTR)pCur->m_dwVirtualSize)))
        {
            return pCur;
        }
    }
    return NULL;
}

//******************************************************************************
void CProcess::AddEvent(CEvent *pEvent)
{
    // Add this process node to the end of our process list.
    if (m_pEventHead)
    {
        for (CEvent *pEventLast = m_pEventHead; pEventLast->m_pNext;
            pEventLast = pEventLast->m_pNext)
        {
        }
        pEventLast->m_pNext = pEvent;
    }
    else
    {
        m_pEventHead = pEvent;
    }
}

//******************************************************************************
void CProcess::ProcessDllMsgMessage(CThread *pThread, LPSTR pszMsg)
{
    // Get the message value and walk over the message header.
    DLLMSG dllMsg = (DLLMSG)strtoul(pszMsg + 3, NULL, 10);
    pszMsg += 6;

    switch (dllMsg)
    {
        case DLLMSG_COMMAND_LINE:        // Sent during Initialize
            ProcessDllMsgCommandLine(pszMsg);
            break;

        case DLLMSG_INITIAL_DIRECTORY:   // Sent during Initialize
            ProcessDllMsgInitialDirectory(pszMsg);
            break;

        case DLLMSG_SEARCH_PATH:         // Sent during Initialize
            ProcessDllMsgSearchPath(pszMsg);
            break;

        case DLLMSG_MODULE_PATH:         // Sent during Initialize
            ProcessDllMsgModulePath(pszMsg);
            break;

        case DLLMSG_DETACH:              // Sent during DLL_PROCESS_DETACH
            ProcessDllMsgDetach(pszMsg);
            break;

        case DLLMSG_LOADLIBRARYA_CALL:    // Sent before LoadLibraryA() is called.
        case DLLMSG_LOADLIBRARYW_CALL:    // Sent before LoadLibraryW() is called.
        case DLLMSG_LOADLIBRARYEXA_CALL:  // Sent before LoadLibraryExA() is called.
        case DLLMSG_LOADLIBRARYEXW_CALL:  // Sent before LoadLibraryExW() is called.
            ProcessDllMsgLoadLibraryCall(pThread, pszMsg, dllMsg);
            break;

        case DLLMSG_GETPROCADDRESS_CALL:  // Sent before GetProcAddress() is called.
            ProcessDllMsgGetProcAddressCall(pThread, pszMsg, dllMsg);
            break;

        case DLLMSG_LOADLIBRARYA_RETURN:      // Sent after LoadLibraryA() is called.
        case DLLMSG_LOADLIBRARYA_EXCEPTION:   // Sent if LoadLibraryA() causes an exception.
        case DLLMSG_LOADLIBRARYW_RETURN:      // Sent after LoadLibraryW() is called.
        case DLLMSG_LOADLIBRARYW_EXCEPTION:   // Sent if LoadLibraryW() causes an exception.
        case DLLMSG_LOADLIBRARYEXA_RETURN:    // Sent after LoadLibraryExA() is called.
        case DLLMSG_LOADLIBRARYEXA_EXCEPTION: // Sent if LoadLibraryExA() causes an exception.
        case DLLMSG_LOADLIBRARYEXW_RETURN:    // Sent after LoadLibraryExW() is called.
        case DLLMSG_LOADLIBRARYEXW_EXCEPTION: // Sent if LoadLibraryExW() causes an exception.
        case DLLMSG_GETPROCADDRESS_RETURN:    // Sent after GetProcAddress() is called.
        case DLLMSG_GETPROCADDRESS_EXCEPTION: // Sent if GetProcAddress() causes an exception.
            ProcessDllMsgFunctionReturn(pThread, pszMsg, dllMsg);
            break;

        default:
            TRACE("Unknown DLLMSG message received - %u\n", dllMsg);
    }
}

//******************************************************************************
void CProcess::ProcessDllMsgCommandLine(LPCSTR pszMsg)
{
    // Walk over leading whitespace.
    while (isspace(*pszMsg))
    {
        pszMsg++;
    }

    // If the path starts with a quote, then walk to next quote.
    if (*pszMsg == '\"')
    {
        pszMsg++;
        while (*pszMsg && (*pszMsg != '\"'))
        {
            pszMsg++;
        }
        pszMsg++;
    }

    // Otherwise, walk to first whitespace.
    else
    {
        while (*pszMsg && !isspace(*pszMsg))
        {
            pszMsg++;
        }
    }

    // Walk over any spaces until we reach the first argument.
    while (isspace(*pszMsg))
    {
        pszMsg++;
    }

    // If we have a session, then tell the document what the arguments are.
    if ((m_pSession) && (m_pSession->m_pfnProfileUpdate))
    {
        m_pSession->m_pfnProfileUpdate(m_pSession->m_dwpProfileUpdateCookie, DWPU_ARGUMENTS, (DWORD_PTR)pszMsg, 0);
    }

    // Otherwise, just store the arguments for later.
    else
    {
        m_pszArguments = StrAlloc(pszMsg);
    }
}

//******************************************************************************
void CProcess::ProcessDllMsgInitialDirectory(LPSTR pszMsg)
{
    // Add a trailing wack to the path for cosmetic reasons.
    AddTrailingWack(pszMsg, DW_MAX_PATH);

    // If we have a session, then tell the document what the directory is.
    if ((m_pSession) && (m_pSession->m_pfnProfileUpdate))
    {
        m_pSession->m_pfnProfileUpdate(m_pSession->m_dwpProfileUpdateCookie, DWPU_DIRECTORY, (DWORD_PTR)pszMsg, 0);
    }

    // Otherwise, just store the directory for later.
    else
    {
        m_pszDirectory = StrAlloc(pszMsg);
    }
}

//******************************************************************************
void CProcess::ProcessDllMsgSearchPath(LPCSTR pszMsg)
{
    // If we have a session, then tell the document what the path is.
    if ((m_pSession) && (m_pSession->m_pfnProfileUpdate))
    {
        m_pSession->m_pfnProfileUpdate(m_pSession->m_dwpProfileUpdateCookie, DWPU_SEARCH_PATH, (DWORD_PTR)pszMsg, 0);
    }

    // Otherwise, just store the path for later.
    else
    {
        m_pszSearchPath = StrAlloc(pszMsg);
    }
}

//******************************************************************************
void CProcess::ProcessDllMsgModulePath(LPCSTR pszMsg)
{
    // Store this new name as the process name.
    m_pModule->SetPath(pszMsg);

    // If we don't have a session for this module yet, then create one now.
    if (!m_pSession && !m_fTerminate)
    {
        // Create the session.
        if (m_pSession = g_theApp.CreateNewSession(m_pModule->GetName(true), this))
        {
            // If we have already encountered a profile error, then flag this in the session.
            if (m_fProfileError)
            {
                m_pSession->m_dwReturnFlags |= DWRF_PROFILE_ERROR;
            }
        }
        else
        {
            //!! BAD
            return;
        }
    }

    // Now that we have a session, attempt to flush all cached events. Chances
    // are, the events will not get flushed since we still need to restore the
    // code page before we caching is turned off. We will call FlushEvents() then
    // as well to be safe.
    FlushEvents();
}

//******************************************************************************
void CProcess::ProcessDllMsgDetach(LPCSTR)
{
    // We really have nothing to do here.
}

//******************************************************************************
void CProcess::ProcessDllMsgLoadLibraryCall(CThread *pThread, LPCSTR pszMsg, DLLMSG dllMsg)
{
    // LoadLibraryA   - 06:dwpCaller,dwpLibStr,szLibStr
    // LoadLibraryW   - 08:dwpCaller,dwpLibStr,szLibStr
    // LoadLibraryExA - 10:dwpCaller,dwpLibStr,hFile,dwFlags,szLibStr
    // LoadLibraryExW - 12:dwpCaller,dwpLibStr,hFile,dwFlags,szLibStr

    DWORD_PTR dwpAddress = 0, dwpPath = 0, dwpFile = 0;
    DWORD     dwFlags = 0;
    LPCSTR    szPath = NULL;

    // Get the caller address.
    dwpAddress = HexToDWP(pszMsg);

    // Walk past the caller address value and comma.
    if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
    {
        // Get the path name address.
        dwpPath = HexToDWP(pszMsg);

        // Walk past the name value and comma.
        if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
        {
            // Check to see if this is one of the Ex functions.
            if ((dllMsg == DLLMSG_LOADLIBRARYEXA_CALL) || (dllMsg == DLLMSG_LOADLIBRARYEXW_CALL))
            {
                // Get the file handle.
                dwpFile = HexToDWP(pszMsg);

                // Walk past the file handle and comma.
                if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
                {
                    // Get the flags value.
                    dwFlags = (DWORD)strtoul(pszMsg, NULL, 0);

                    // Walk past the flags value and comma.
                    if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
                    {
                        szPath = pszMsg;
                    }
                }
            }
            else
            {
                szPath = pszMsg;
            }
        }
    }

    // Create a new CEventLoadLibrary object.
    CEventLoadLibraryCall *pEvent = new CEventLoadLibraryCall(
        pThread, FindModule(dwpAddress), pThread->m_pEventFunctionCallCur, dllMsg,
        dwpAddress, dwpPath, szPath, dwpFile, dwFlags);

    if (!pEvent)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Add this function to our function hierarchy and event list.
    AddFunctionEvent(pEvent);
}

//******************************************************************************
void CProcess::ProcessDllMsgGetProcAddressCall(CThread *pThread, LPCSTR pszMsg, DLLMSG dllMsg)
{
    DWORD_PTR dwpAddress = 0, dwpModule = 0, dwpProcName = 0;
    LPCSTR    szProcName = NULL;

    // Get the caller address.
    dwpAddress = HexToDWP(pszMsg);

    // Walk past the caller address value and comma.
    if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
    {
        // Get the module address.
        dwpModule = HexToDWP(pszMsg);

        // Walk past the module value and comma.
        if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
        {
            // Get the proc name value.
            dwpProcName = HexToDWP(pszMsg);

            // Walk past the proc name value and comma.
            if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
            {
                // Get the proc name string.
                szProcName = pszMsg;
            }
        }
    }

    // Create a new CEventGetProcAddress object.
    CEventGetProcAddressCall *pEvent = new CEventGetProcAddressCall(
        pThread, FindModule(dwpAddress), pThread->m_pEventFunctionCallCur, dllMsg,
        dwpAddress, FindModule(dwpModule), dwpModule, dwpProcName, szProcName);

    if (!pEvent)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Add this function to our function hierarchy and event list.
    AddFunctionEvent(pEvent);
}

//******************************************************************************
void CProcess::ProcessDllMsgFunctionReturn(CThread *pThread, LPCSTR pszMsg, DLLMSG dllMsg)
{
    // We should always have a thread and a current function object.
    if (pThread && pThread->m_pEventFunctionCallCur)
    {
        // Create a new CEventFunctionReturn.
        pThread->m_pEventFunctionCallCur->m_pReturn =
            new CEventFunctionReturn(pThread->m_pEventFunctionCallCur);

        if (!pThread->m_pEventFunctionCallCur->m_pReturn)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // First, check to see if this function caused an exception.
        if ((dllMsg == DLLMSG_LOADLIBRARYA_EXCEPTION)   ||
            (dllMsg == DLLMSG_LOADLIBRARYW_EXCEPTION)   ||
            (dllMsg == DLLMSG_LOADLIBRARYEXA_EXCEPTION) ||
            (dllMsg == DLLMSG_LOADLIBRARYEXW_EXCEPTION) ||
            (dllMsg == DLLMSG_GETPROCADDRESS_EXCEPTION))
        {
            pThread->m_pEventFunctionCallCur->m_pReturn->m_fException = true;
        }

        // Otherwise, it is just a normal post-function message.
        else
        {
            // Get the result value.
            pThread->m_pEventFunctionCallCur->m_pReturn->m_dwpResult = HexToDWP(pszMsg);

            // Walk past the result value and comma.
            if ((DWORD_PTR)(pszMsg = (strchr(pszMsg, ',') + 1)) != 1)
            {
                // Get the error value.
                pThread->m_pEventFunctionCallCur->m_pReturn->m_dwError = (DWORD)strtoul(pszMsg, NULL, 0);
            }

            // Check to see if we just successfully returned from a LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE) call.
            if (pThread->m_pEventFunctionCallCur->m_pReturn->m_dwpResult &&
                ((dllMsg == DLLMSG_LOADLIBRARYEXA_RETURN) || (dllMsg == DLLMSG_LOADLIBRARYEXW_RETURN)) &&
                (((CEventLoadLibraryCall*)pThread->m_pEventFunctionCallCur)->m_dwFlags & LOAD_LIBRARY_AS_DATAFILE))
            {
                // Create a new module object.  We don't call AddModule, since we don't want this module
                // to be hooked or added to our module list since it is merely a data mapping into memory.
                CLoadedModule *pModule =  new CLoadedModule(
                   NULL, pThread->m_pEventFunctionCallCur->m_pReturn->m_dwpResult,
                   ((CEventLoadLibraryCall*)pThread->m_pEventFunctionCallCur)->m_pszPath);

                if (!pModule)
                {
                    RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
                }

                // Flag this module as a data module.
                pModule->m_hookStatus = HS_DATA;

                // Before we process the LoadLibraryEx return, first generate a fake module load event.
                ProcessLoadDll(pThread, pModule);

                // Release our initial reference so that the object will free itself once no longer needed.
                // This normally happens when the module is removed from our module list, but we don't
                // add this module to the list to begin with.
                pModule->Release();
            }
        }

        // If we are currently caching, then just store this event away for later.
        if (IsCaching())
        {
            pThread->m_pEventFunctionCallCur->m_pReturn->AddRef();
            AddEvent(pThread->m_pEventFunctionCallCur->m_pReturn);
        }

        // Otherwise, tell the session about it right now.
        else if (m_pSession)
        {
            m_pSession->HandleEvent(pThread->m_pEventFunctionCallCur->m_pReturn);
        }

        // Move the current pointer to the parent, and check to see if we have
        // completely backed out of the hierarchy and reached the root.
        if (!(pThread->m_pEventFunctionCallCur = pThread->m_pEventFunctionCallCur->m_pParent))
        {
            // If we have reached the root, then send all our LoadLibraryCall objects
            // to the session and then delete them.
            FlushFunctionCalls(pThread);
        }
    }
}

//******************************************************************************
void CProcess::UserMessage(LPCSTR pszMessage, DWORD dwError, CLoadedModule *pModule)
{
    CHAR szAddress[64], szBuffer[DW_MAX_PATH + 128];

    // Check to see if we have a module.
    if (pModule)
    {
        // Attempt to get the module's name.
        LPCSTR pszModule = pModule->GetName((m_dwFlags & PF_USE_FULL_PATHS) != 0);

        // If we could not get a name, then make up a string that describes the module.
        if (!pszModule)
        {
            SCPrintf(szAddress, sizeof(szAddress), "module at " HEX_FORMAT, pModule->m_dwpImageBase);
            pszModule = szAddress;
        }

        // Build the formatted string.
        SCPrintf(szBuffer, sizeof(szBuffer), pszMessage, pszModule);
        pszMessage = szBuffer;
    }

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        // we only allocate the string if we had formatting.
        CEventMessage *pEvent = new CEventMessage(dwError, pszMessage, pModule != NULL);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventMessage event(dwError, pszMessage, FALSE);
        m_pSession->EventMessage(&event);
    }
}

//******************************************************************************
void CProcess::Terminate()
{
    // Terminate the process by the user's request. Once closed, it will kill our CProcess.
    if (m_hProcess)
    {
        m_fTerminate = true;
        FlushEvents();
        TerminateProcess(m_hProcess, 0xDEAD); // inspected
    }
    else
    {
        m_pDebuggerThread->RemoveProcess(this);
    }
}

//******************************************************************************
void CProcess::HookLoadedModules()
{
    // We only attempt to hook modules once per event since nothing can change
    // in the remote process while we are handling a sinlge debug event.
    // We also want to bail if we have not fully injected our injection DLL.
    if (m_fDidHookForThisEvent || !m_dwpDWInjectBase || m_pbOriginalPage)
    {
        return;
    }

    for (CLoadedModule *pModule = m_pModuleHead; pModule; pModule = pModule->m_pNext)
    {
        // Make sure the module isn't already hooked.
        if ((pModule->m_hookStatus == HS_NOT_HOOKED) || (pModule->m_hookStatus == HS_ERROR) || pModule->m_fReHook)
        {
            // Hook this process module and store the result.
            if (!HookImports(pModule))
            {
                // Error will be logged in the form of a "Failed to hook" module load.
                SetProfileError();
            }
        }
    }

    // Make a note that we have tried to hook all modules for this debug event.
    m_fDidHookForThisEvent = true;
}

//******************************************************************************
void CProcess::AddFunctionEvent(CEventFunctionCall *pEvent)
{
    // Check to see if we have a current item.
    if (pEvent->m_pThread->m_pEventFunctionCallCur)
    {
        // If we do have a current item, then we need to add this new item as a
        // child of it, so we walk to the end of the child list and add it.

        if (pEvent->m_pThread->m_pEventFunctionCallCur->m_pChildren)
        {
            // We have children - walk to end of list and add new node.
            for (CEventFunctionCall *pLast = pEvent->m_pThread->m_pEventFunctionCallCur->m_pChildren;
                pLast->m_pNext; pLast = pLast->m_pNext)
            {
            }
            pLast->m_pNext = pEvent;
        }

        // Otherwise, we have no children - just add node as the first child.
        else
        {
            pEvent->m_pThread->m_pEventFunctionCallCur->m_pChildren = pEvent;
        }
    }

    // Otherwise, we start a new hierarchy with this node as the root.
    else
    {
        pEvent->m_pThread->m_pEventFunctionCallHead = pEvent;
    }

    // Set the current pointer to our new node so we know who to assign new modules to.
    pEvent->m_pThread->m_pEventFunctionCallCur = pEvent;

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        pEvent->AddRef();
        AddEvent(pEvent);
    }

    // Otherwise, tell the session about it right now.
    else if (m_pSession)
    {
        m_pSession->HandleEvent(pEvent);
    }
}

//******************************************************************************
void CProcess::FlushEvents(bool fForce /*false*/)
{
    // If we are caching then we bail now and try again later.
    if (!fForce && IsCaching())
    {
        return;
    }

    // Loop through all event objects.
    while (m_pEventHead)
    {
        // If we had a session, then send this event to the session.
        if (m_pSession)
        {
            m_pSession->HandleEvent(m_pEventHead);
        }

        // Check to see if this is a function call event.
        if ((m_pEventHead->GetType() == LOADLIBRARY_CALL_EVENT) ||
            (m_pEventHead->GetType() == GETPROCADDRESS_CALL_EVENT))
        {
            // If so, check to see if we need to flush out the
            // function call hierarchy.
            if (((CEventFunctionCall*)m_pEventHead)->m_fFlush)
            {
                FlushFunctionCalls((CEventFunctionCall*)m_pEventHead);
            }
        }

        // Release this event object.
        CEvent *pNext = m_pEventHead->m_pNext;
        m_pEventHead->m_pNext = NULL;
        m_pEventHead->Release();
        m_pEventHead = pNext;
    }
}

//******************************************************************************
void CProcess::FlushFunctionCalls(CThread *pThread)
{
    // Make sure we have at least one function call.
    if (pThread->m_pEventFunctionCallHead)
    {
        // If we are caching, then we can't do the flush just yet since there is
        // no session to flush it to. However, we need to remove the function call
        // tree from our thread so it can have a clean start before the next
        // function call is made. Since this function call event is also in our event
        // list, we can flag it as the root of a hierarchy that is ready to flush.
        // When we later have a session to flush to, we will flush all our events.
        // When we come across this event when flushing the event list, we will also
        // flush out this tree.
        if (IsCaching())
        {
            pThread->m_pEventFunctionCallHead->m_fFlush = true;
        }

        // If we are not caching, then we can just flush it out now.
        else
        {
            FlushFunctionCalls(pThread->m_pEventFunctionCallHead);
        }

        // Either way, we need to clear our thread pointers.
        pThread->m_pEventFunctionCallHead = NULL;
        pThread->m_pEventFunctionCallCur  = NULL;
    }
}

//******************************************************************************
void CProcess::FlushFunctionCalls(CEventFunctionCall *pFC)
{
    if (pFC)
    {
        // Let the session know about this CEventLoadLibrary object.
        if (m_pSession)
        {
            if (pFC->m_dllMsg == DLLMSG_GETPROCADDRESS_CALL)
            {
                m_pSession->ProcessGetProcAddress((CEventGetProcAddressCall*)pFC);
            }
            else
            {
                m_pSession->ProcessLoadLibrary((CEventLoadLibraryCall*)pFC);
            }
        }

        // Recurse into our children and then on to our next sibling.
        FlushFunctionCalls(pFC->m_pChildren);
        FlushFunctionCalls(pFC->m_pNext);

        // Free the DLL list for this CEventFunction object.
        for (CEventLoadDll *pDll = pFC->m_pDllHead; pDll; )
        {
            CEventLoadDll *pNext = pDll->m_pNextDllInFunctionCall;
            pDll->m_pNextDllInFunctionCall = NULL;
            pDll->Release();
            pDll = pNext;
        }

        // Set this function flush flag to false just to be safe.  This will
        // ensure it doesn't get flush again somehow.
        pFC->m_fFlush = false;

        // Release this CEventFunctionCall and CEventFunctionReturn set.
        if (pFC->m_pReturn)
        {
            pFC->m_pReturn->Release();
        }
        pFC->Release();
    }
}

//******************************************************************************
// Errors displayed and handled by caller.
BOOL CProcess::ReadKernelExports(CLoadedModule *pModule)
{
    // Bail if this module has no export directory.
    if (pModule->m_dwDirectories <= IMAGE_DIRECTORY_ENTRY_EXPORT)
    {
        TRACE("Kernel32.dll only has %u directories. Cannot process its Export Directory.",
              pModule->m_dwDirectories);
        return FALSE;
    }

    // Locate the start of the export table.
    DWORD_PTR dwpIED = 0;
    if (!ReadRemoteMemory(m_hProcess,
        &pModule->m_pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
        &dwpIED, sizeof(DWORD)))
    {
        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
        return FALSE;
    }

    // Make sure we were able to locate the image directory.
    if (!dwpIED)
    {
        TRACE("Could not find the section that owns kernel32.dll's Export Directory.");
        SetLastError(0);
        return FALSE;
    }

    // Convert the address from RVA to absolute.
    dwpIED += pModule->m_dwpImageBase;

    // Now read in the actual structure.
    IMAGE_EXPORT_DIRECTORY IED;
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwpIED, &IED, sizeof(IED)))
    {
        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
        return FALSE;
    }

    DWORD *pdwAddresses = (DWORD*)(pModule->m_dwpImageBase + (DWORD_PTR)IED.AddressOfFunctions);
    DWORD *pdwNames     = (DWORD*)(pModule->m_dwpImageBase + (DWORD_PTR)IED.AddressOfNames);
    WORD  *pwOrdinals   = (WORD* )(pModule->m_dwpImageBase + (DWORD_PTR)IED.AddressOfNameOrdinals);
    char   szFunction[1024];
    int    cFound = 0;

    // Loop through all the "exported by name" functions.
    for (int hint = 0; hint < (int)IED.NumberOfNames; hint++)
    {
        // Get this function's name location.
        DWORD dwName = 0; // this is a 32-bit RVA, right?  and not a 64-bit pointer?
        if (!ReadRemoteMemory(m_hProcess, pdwNames + hint, &dwName, sizeof(dwName)))
        {
            TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
            return FALSE;
        }

        // Read in the actual function name.
        *szFunction = '\0';
        if (ReadRemoteString(m_hProcess, szFunction, sizeof(szFunction),
                             (LPCVOID)(pModule->m_dwpImageBase + (DWORD_PTR)dwName), FALSE))
        {
            // Loop through our hook functions looking for a match.
            for (int i = 0; i < countof(m_HookFunctions); i++)
            {
                // Do a string compare to see if we care about this function.
                if (!strcmp(szFunction, m_HookFunctions[i].szFunction))
                {
                    // Get the ordinal of this function.
                    WORD wOrdinal;
                    if (!ReadRemoteMemory(m_hProcess, pwOrdinals + hint,
                                          &wOrdinal, sizeof(wOrdinal)))
                    {
                        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
                        return FALSE;
                    }

                    // Store the ordinal for this function.
                    m_HookFunctions[i].dwOrdinal = IED.Base + (DWORD)wOrdinal;

                    // Get the address of this function
                    DWORD dwAddress;
                    if (!ReadRemoteMemory(m_hProcess, pdwAddresses + (DWORD_PTR)wOrdinal,
                                          &dwAddress, sizeof(dwAddress)))
                    {
                        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
                        return FALSE;
                    }

                    // Store the address for this function.
                    m_HookFunctions[i].dwpOldAddress = pModule->m_dwpImageBase + (DWORD_PTR)dwAddress;

                    // If we have found all our functions, then bail now to save time.
                    if (++cFound >= countof(m_HookFunctions))
                    {
                        return TRUE;
                    }

                    // Bail out of our for loop since we found the match.
                    break;
                }
            }
        }
    }

    // If we make it here, then we are done parsing the functions, but did not
    // find all the ordinals.
    SetLastError(0);
    return FALSE;
}

//******************************************************************************
// Errors displayed and handled by caller.
BOOL CProcess::ReadDWInjectExports(CLoadedModule *pModule)
{
    if (!pModule)
    {
        return FALSE;
    }

    // Bail if this module has no export directory.
    if (pModule->m_dwDirectories <= IMAGE_DIRECTORY_ENTRY_EXPORT)
    {
        TRACE("DEPENDS.DLL only has %u directories. Cannot process its Export Directory.",
              pModule->m_dwDirectories);
        return FALSE;
    }

    // Locate the start of the export table.
    DWORD_PTR dwpIED = 0;
    if (!ReadRemoteMemory(m_hProcess,
        &pModule->m_pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
        &dwpIED, sizeof(DWORD)))
    {
        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
        return FALSE;
    }

    // Make sure we were able to locate the image directory.
    if (!dwpIED)
    {
        TRACE("Could not find the section that owns the Export Directory.");
        SetLastError(0);
        return FALSE;
    }

    // Convert the address from RVA to absolute.
    dwpIED += pModule->m_dwpImageBase;

    // Now read in the actual structure.
    IMAGE_EXPORT_DIRECTORY IED;
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwpIED, &IED, sizeof(IED)))
    {
        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
        return FALSE;
    }

    DWORD *pdwAddresses = (DWORD*)(pModule->m_dwpImageBase + (DWORD_PTR)IED.AddressOfFunctions);

    for (DWORD dwOrdinal = IED.Base; dwOrdinal < (IED.NumberOfFunctions + IED.Base); dwOrdinal++)
    {
        // Get this function's entrypoint address.
        DWORD dwAddress = 0;
        if (!ReadRemoteMemory(m_hProcess, pdwAddresses + (dwOrdinal - IED.Base),
                              &dwAddress, sizeof(dwAddress)))
        {
            TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
            return FALSE;
        }

        // Make sure this ordinal is used (non-zero entrypoint address), and that
        // the ordinal value is between 1 and 5.
        if (dwAddress && (dwOrdinal >= 1) && (dwOrdinal <= 5))
        {
            // Store the address of this function in our hook table.
            m_HookFunctions[dwOrdinal - 1].dwpNewAddress = pModule->m_dwpImageBase + (DWORD_PTR)dwAddress;
        }
    }

    // Make sure we found all the ordinals.
    for (dwOrdinal = 0; dwOrdinal < countof(m_HookFunctions); dwOrdinal++)
    {
        if (!m_HookFunctions[dwOrdinal].dwpNewAddress)
        {
            SetLastError(0);
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
// Errors handled by the caller.  They will also show up in the log as "Failed to hook" loaded modules.
BOOL CProcess::HookImports(CLoadedModule *pModule)
{
    // If this is a shared module on Windows 9x, we don't hook it.
    if (!g_fWindowsNT && (pModule->m_dwpImageBase >= 0x80000000))
    {
        pModule->m_hookStatus = HS_SHARED;
        return TRUE;
    }

    // Don't hook if we are not ready to hook or are not supposed to hook.
    if (!m_dwpDWInjectBase || m_pbOriginalPage || !(m_dwFlags & PF_HOOK_PROCESS))
    {
        pModule->m_hookStatus = HS_NOT_HOOKED;
        return TRUE;
    }

    // Don't ever hook our injection DLL or data DLLs.
    if ((pModule->m_hookStatus == HS_INJECTION_DLL) || (pModule->m_hookStatus == HS_DATA))
    {
        return TRUE;
    }

    // Bail if this module has no import directory.
    if (pModule->m_dwDirectories <= IMAGE_DIRECTORY_ENTRY_IMPORT)
    {
        return TRUE;
    }

    TRACE("HOOKING: \"%s\", m_hookStatus: %u, m_fReHook: %u\n", pModule->GetName(true), pModule->m_hookStatus, pModule->m_fReHook); //!! remove

    pModule->m_hookStatus = HS_HOOKED;
    pModule->m_fReHook = false;

    // Locate the start of the import table.
    DWORD_PTR dwpIID = 0;
    if (!ReadRemoteMemory(m_hProcess,
                          &pModule->m_pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
                          &dwpIID, sizeof(DWORD)))
    {
        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
        pModule->m_hookStatus = HS_ERROR;
        goto LEAVE;
    }

    // If dwpIID is 0, then this module has no imports - NTDLL.DLL is like this.
    else if (!dwpIID)
    {
        pModule->m_hookStatus = HS_HOOKED;
        return TRUE;
    }

    // Convert the address from RVA to absolute.
    dwpIID += pModule->m_dwpImageBase;

    // Loop through all the Image Import Descriptors in the array.
    while (true) // outer while
    {
        // Read in the next import descriptor.
        IMAGE_IMPORT_DESCRIPTOR IID;
        if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwpIID, &IID, sizeof(IID)))
        {
            TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
            pModule->m_hookStatus = HS_ERROR;
            break; // leave outer while
        }

        // On WOW64, we often get bogus IIDs since WOW64 has not properly mapped
        // the sections into memory yet.  If we get a bad pointer, we just mark
        // this module as bad and retry later.
        if (IID.FirstThunk >= pModule->m_dwVirtualSize)
        {
            TRACE("IID.FirstThunk is invalid.\n", __LINE__, GetLastError());
            pModule->m_hookStatus = HS_ERROR;
            break; // leave outer while
        }
        if (!IID.FirstThunk)
        {
            break; // leave outer while
        }
        
        // Read in the module name.
        LPCSTR pszModule = (LPCSTR)(pModule->m_dwpImageBase + (DWORD_PTR)IID.Name);
        char szBuffer[1024];
        *szBuffer = '\0';
        ReadRemoteString(m_hProcess, szBuffer, sizeof(szBuffer), pszModule, FALSE);
        szBuffer[1023] = '\0';

        TRACE("   Import: \"%s\"\n", szBuffer); //!! remove

        // We used to skip all imported modules except for kernel32.dll, but this
        // can miss modules that have forwarded functions to the kernel calls we
        // want to hook. If a module has a forwarded call to a function we want to
        // hook, then the address we find in the this module should still equal
        // the one we want to hook, since that is how forwarded functions work.

        // At compile time, both the FirstThunk field and OriginalFirstThunk field
        // point to arrays of names and/or ordinals. At load time, the FirstThunk
        // array is overwritten with bound addresses. That is usually how the arrays
        // arrive to us. Borland modules don't use OriginalFirstThunk array, so we
        // have no way to perform function name compares since the only copy of name
        // pointers was in the FirstThunk array and that has been overwritten by
        // the loader.

        // One last thing... We are doing two different types of checks to see if
        // we should hook a function. First, we check to see if the address the
        // module is calling matches one of the addresses we hook. This only works
        // on NT since Windows 9x generates fake addresses for all the functions in
        // kernel32 when the process is being ran under the debugger. Since
        // Dependency Walker is a debugger itself, the addresses we see in the
        // import tables for kernel32 are fake and never match the real addresses.
        // This is a feature on Win9x to allow debuggers to set breakpoints on
        // kernel32 functions without breaking other apps since kernel32 lives in
        // shared memory.  After the address compare, we do a function compare.
        // This code checks the function's ordinal or name to see if it matches a
        // function we want to hook.  This is the code that works on Win9x and
        // occasionally catches a few on NT.  On NT, if a function is found by
        // name or ordinal, then we have a problem - this means that the address
        // in the import table did not match the real address of the kernel32
        // function, and yet the function is one we want to hook.  What this
        // usually means is that the module has not been bound to kernel32 by the
        // loader yet.  The result is that no matter what we do to the import
        // table, the loader will just come along and step on it during the bind
        // phase.  I'm not sure why only some modules exhibit the behavior - most
        // modules come to us already bound.
        IMAGE_THUNK_DATA ITDA, *pITDA = (PIMAGE_THUNK_DATA)(pModule->m_dwpImageBase + (DWORD_PTR)IID.FirstThunk);
        IMAGE_THUNK_DATA ITDN = { 0 }, *pITDN = (IID.OriginalFirstThunk && !_stricmp(szBuffer, "kernel32.dll")) ?
                                                (PIMAGE_THUNK_DATA)(pModule->m_dwpImageBase + (DWORD_PTR)IID.OriginalFirstThunk) : NULL;

        // Loop through all the Image Thunk Data structures in the function array.
        while (true) // inner while
        {
            // Read in the next address thunk data and bail if we reach the last one.
            if (!ReadRemoteMemory(m_hProcess, pITDA, &ITDA, sizeof(ITDA)))
            {
                TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
                pModule->m_hookStatus = HS_ERROR;
                break; // leave inner while
            }
            if (!ITDA.u1.Ordinal)
            {
                break; // leave inner while
            }

            // Read in the next name thunk data if we have one.
            if (pITDN)
            {
                if (!ReadRemoteMemory(m_hProcess, pITDN, &ITDN, sizeof(ITDN)))
                {
                    TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
                    pModule->m_hookStatus = HS_ERROR;
                    break; // leave inner while
                }
                if (!ITDN.u1.Ordinal)
                {
                    pITDN = NULL;
                }
            }

            // Check the address against our known addresses to see if we need to hook this function.
            for (int hook = 0; hook < countof(m_HookFunctions); hook++)
            {
                if (m_HookFunctions[hook].dwpNewAddress &&
                    ((DWORD_PTR)ITDA.u1.Function == m_HookFunctions[hook].dwpOldAddress))
                {
                    break; // leave for
                }
            }

            // If we have a name thunk data and didn't already find a match, then
            // check to see if this function matches by name or ordinal.
            if (pITDN && (hook >= countof(m_HookFunctions)))
            {
                // Check to see if the function is imported by ordinal.
                if (IMAGE_SNAP_BY_ORDINAL(ITDN.u1.Ordinal))
                {
                    // Look to see if we need to hook this function.
                    for (hook = 0; hook < countof(m_HookFunctions); hook++)
                    {
                        if (m_HookFunctions[hook].dwpNewAddress &&
                            (m_HookFunctions[hook].dwOrdinal == (DWORD)IMAGE_ORDINAL(ITDN.u1.Ordinal)))
                        {
                            break; // leave for
                        }
                    }
                }

                // If not by ordinal, then the import must be by name.
                else
                {
                    // Get the Image Import by Name structure for this import.
                    PIMAGE_IMPORT_BY_NAME pIIBN = (PIMAGE_IMPORT_BY_NAME)(pModule->m_dwpImageBase + (DWORD_PTR)ITDN.u1.AddressOfData);

                    IMAGE_IMPORT_BY_NAME IIBN;
                    if (!ReadRemoteMemory(m_hProcess, pIIBN, &IIBN, sizeof(IIBN)))
                    {
                        TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
                        pModule->m_hookStatus = HS_ERROR;
                        break; // leave inner while
                    }

                    // Get the function name.
                    LPCSTR pszFunction = (LPCSTR)pIIBN->Name;
                    ReadRemoteString(m_hProcess, szBuffer, sizeof(szBuffer), pszFunction, FALSE);

                    // Look to see if we need to hook this function.
                    for (hook = 0; hook < countof(m_HookFunctions); hook++)
                    {
                        if (m_HookFunctions[hook].dwpNewAddress && !strcmp(m_HookFunctions[hook].szFunction, szBuffer))
                        {
                            break; // leave for
                        }
                    }
                }
            }

            // Did we find a match?
            if (hook < countof(m_HookFunctions))
            {
                // Sometimes we get a module before the loader has fixed-up the import table.
                // I've seen this happen for modules load with LoadLibrary on NT.  Somewhere
                // between the time we receive the LOAD_DLL_DEBUG_EVENT message and the time
                // the module's entrypoint is called, the loader fixes up the import table.
                // We know the module has not been fixed up if the address for this function
                // we want to hook is still an RVA and does not point to the real function.
                // If we see this, we make a note of it and try to rehook at a later time.
                //
                // Also, Windows 9x does a little trick to modules that are running under a
                // debugger (which is what DW is).  Instead of finding the real address for
                // one of the functions we want to hook, we end up finding the address of a
                // stub that calls the real function.  Since Windows 9x does not support
                // copy-on-write, it is impossible to set a breakpoint at the entrypoint to
                // a KERNEL32.DLL function without having every process on the OS hitting it.
                // So, I beleive this stub code is done so that a breakpoints can be set at
                // the entrypoiunt.  The stub code is unique to our process being debugged.
                // In fact, every module in our remote process might have a different stub
                // address for a given function, like LoadLibraryA.  The only thing I've
                // noticed about stub addresses is that they are always above 0x80000000,
                // which should never be mistaken for an RVA.  So, if on Windows 9x and the
                // address is above 0x80000000, we consider it valid and don't set the 
                // rehook flag.
                
                if (((DWORD_PTR)ITDA.u1.Function != m_HookFunctions[hook].dwpOldAddress) &&
                     (g_fWindowsNT || ((DWORD_PTR)ITDA.u1.Function < 0x80000000)))
                {
                    pModule->m_fReHook = true;
                }

                TRACE("      FOUND: \"%s\" - Expected:" HEX_FORMAT ", Found:" HEX_FORMAT ", New:" HEX_FORMAT ", ReHook: %u\n",
                      m_HookFunctions[hook].szFunction,
                      m_HookFunctions[hook].dwpOldAddress,
                      (DWORD_PTR)ITDA.u1.Function,
                      m_HookFunctions[hook].dwpNewAddress,
                      pModule->m_fReHook);  //!! remove

                // Attempt to hook the import.
                if (!WriteRemoteMemory(m_hProcess, &pITDA->u1.Function, &m_HookFunctions[hook].dwpNewAddress, sizeof(DWORD_PTR), false))
                {
                    TRACE("Failed to hook import\n");
                    pModule->m_hookStatus = HS_ERROR;
                }
            }

            // Increment to the next address and name.
            pITDA++;
            if (pITDN)
            {
                pITDN++;
            }
        }

        // Increment to the next import module
        dwpIID += sizeof(IID);
    }

LEAVE:
    // If we encountered an error, we will try to rehook this module again later.
    // It probably won't do us any good, but it can't hurt to try again.
    if (pModule->m_hookStatus == HS_ERROR)
    {
        pModule->m_fReHook = true;
    }

    // If we would like to hook this module at a later time, then ensure there
    // is a breakpoint at its entrypoint.
    if (pModule->m_fReHook)
    {
        SetEntryBreakpoint(pModule);
    }

    return (pModule->m_hookStatus != HS_ERROR);
}

//******************************************************************************
// Errors displayed by us, but handled by caller.
BOOL CProcess::GetVirtualSize(CLoadedModule *pModule)
{
    // Map an IMAGE_DOS_HEADER structure onto the remote image.
    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)pModule->m_dwpImageBase;

    LONG e_lfanew;
    if (!ReadRemoteMemory(m_hProcess, &pIDH->e_lfanew, &e_lfanew, sizeof(e_lfanew)))
    {
        UserMessage("Error reading the DOS header of \"%s\".  Virtual size of module cannot be determined.", GetLastError(), pModule);
        return FALSE;
    }

    // Map an IMAGE_NT_HEADERS structure onto the remote image.
    pModule->m_pINTH = (PIMAGE_NT_HEADERS)(pModule->m_dwpImageBase + (DWORD_PTR)e_lfanew);

    // Read in the virtual size of this module so we can ignore exceptions that occur in it.
    if (!ReadRemoteMemory(m_hProcess, &pModule->m_pINTH->OptionalHeader.SizeOfImage,
                          &pModule->m_dwVirtualSize, sizeof(pModule->m_dwVirtualSize)))
    {
        UserMessage("Error reading the PE headers of \"%s\".  Virtual size of module cannot be determined.", GetLastError(), pModule);
        return FALSE;
    }

    // Read in the number of directories for this module.
    if (!ReadRemoteMemory(m_hProcess, &pModule->m_pINTH->OptionalHeader.NumberOfRvaAndSizes,
                          &pModule->m_dwDirectories, sizeof(pModule->m_dwDirectories)))
    {
        // This should not fail, but if it does, just assume that the module has
        // the default number of directories.
        pModule->m_dwDirectories = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
    }

    return TRUE;
}

//******************************************************************************
#if defined(_IA64_)

#if 0 // Currently, we don't use the alloc instruction
void IA64BuildAllocBundle(PIA64_BUNDLE pIA64B)
{
    // This function creates a code bundle that arranges the registers so that
    // we have no inputs, one local at r32 (to hold ar.pfs), and one output at
    // r33 (to hold the DLL name in the call to LoadLibraryA).
    //
    //    alloc r32=0,1,1,0
    //    nop.i 0
    //    nop.i 0
    //

    DWORDLONG dwlTemplate = 0x00;    // Template: M,I,I
    DWORDLONG dwlM0 = 0x02C00104800; // M: alloc r32=0,1,1,0    1 local, 2 total
    DWORDLONG dwlI1 = 0x00008000000; // I: nop.i 0
    DWORDLONG dwlI2 = 0x00008000000; // I: nop.i 0

    pIA64B->dwll = dwlTemplate | (dwlM0 << 5) | ((dwlI1 & 0x3FFFF) << 46); // template + slot 0 + low 18 bits of slot 1 = 64-bits
    pIA64B->dwlh = ((dwlI1 >> 18) & 0x7FFFFF) | (dwlI2 << 23);             // upper 23 bits of slot 1 + slot 2 = 64-bits
}
#endif

//******************************************************************************
void IA64BuildMovLBundle(PIA64_BUNDLE pIA64B, DWORD r, DWORDLONG dwl)
{
    // This function just creates a code bundle that moves a 64-bit value into a
    // register. The code produced looks as follows:
    //
    //    nop.m 0
    //    movl r=dwl
    //

    DWORDLONG dwlTemplate = 0x04;                      // Template: M,L+X
    DWORDLONG dwlM0 = 0x00008000000;                   // M: nop.m 0
    DWORDLONG dwlL1 = (dwl >> 22) & 0x1FFFFFFFFFF;     // L: imm41 - bits 22-62
    DWORDLONG dwlX2 = (((DWORDLONG)6        ) << 37) | // X: opcode
                      (((dwl >> 63)  & 0x001) << 36) | // X: i     - bit  63
                      (((dwl >>  7)  & 0x1FF) << 27) | // X: imm9d - bits 7-15
                      (((dwl >> 16)  & 0x01F) << 22) | // X: imm5c - bits 16-20
                      (((dwl >> 21)  & 0x001) << 21) | // X: ic    - bit  21
                      (((dwl      )  & 0x07F) << 13) | // X: imm7b - bits 0-6
                      (((DWORDLONG)r & 0x07F) <<  6);  // X: r1

    pIA64B->dwll = dwlTemplate | (dwlM0 << 5) | ((dwlL1 & 0x3FFFF) << 46); // template + M Unit + low 18 bits of L Unit = 64-bits
    pIA64B->dwlh = ((dwlL1 >> 18) & 0x7FFFFF) | (dwlX2 << 23);             // upper 23 bits of L Unit + X Unit = 64-bits
}

//******************************************************************************
void IA64BuildCallBundle(PIA64_BUNDLE pIA64B)
{
    // This function just creates a code bundle that moves the function address
    // in r31 into b6, then calls the function using b0. The code produced looks
    // as follows:
    //
    //    nop.m 0
    //    mov b6=r31
    //    br.call.sptk.few b0=b6
    //

    DWORDLONG dwlTemplate = 0x11;    // Template: M,I,B
    DWORDLONG dwlM0 = 0x00008000000; // M: nop.m 0
    DWORDLONG dwlI1 = 0x00E0013E180; // I: mov b6=r31
    DWORDLONG dwlB2 = 0x0210000C000; // B: br.call.sptk.few b0=b6

    pIA64B->dwll = dwlTemplate | (dwlM0 << 5) | ((dwlI1 & 0x3FFFF) << 46); // template + M Unit + low 18 bits of I Unit = 64-bits
    pIA64B->dwlh = ((dwlI1 >> 18) & 0x7FFFFF) | (dwlB2 << 23);             // upper 23 bits of I Unit + B Unit = 64-bits
}

//******************************************************************************
void IA64BuildBreakBundle(PIA64_BUNDLE pIA64B)
{
    // This function just creates a code bundle with that flushes the register
    // stack and then breaks. This bundle is similar to the initial breakpoint
    // hit when an application is done initializing.
    //
    //    flushrs
    //    nop.m 0
    //    break.i 0x80016
    //
    // I must be misunderstanding something here.  In looking at notepad's initial
    // breakpoint, I see the above code.  The break.i is supposed to be layed out
    // as follows...
    //
    // Instruction: break.i 0x80016
    //
    // I Unit: opcode i x3  x6     - imm20a               qp
    //         0000   0 000 000000 0 10000000000000010110 000000
    //         ----   - --- ------ - -------------------- ------
    //         4333   3 333 333222 2 22222211111111110000 000000
    //         0987   6 543 210987 6 54321098765432109876 543210
    //
    // opcode = 0
    // imm21  = (i << 20) | imm20a = 0x80016
    // x3     = 0
    // x6     = 0 (0 = break.m, 1 = nop.m)
    // qp     = 0
    //
    // Basically, the entire slot is 0's except for imm21, which I thought was
    // an optional value.  I'm finding that if I set imm21 to 0, I get an
    // Invalid Instruction exception (0xC000001D).  If I set it to 1, I get an
    // Integer Divide By Zero (0xC0000094).  If I set it to 0x80000,  I get an
    // Invalid Instruction exception (0xC000001D).  So, right now I use 0x80016
    // and it works fine.  This makes me think I have the bit layout wrong.
    //
    // I just found that if I stick this breakpoint (with 0x80016) immediately
    // following a type 0 (MII) bundle containing an alloc, nop.i, nop.i, then
    // it also fails with an Invalid Instruction exception (0xC000001D).
    //
    DWORDLONG dwlTemplate = 0x0A;    // Template: M,M,I
    DWORDLONG dwlM0 = 0x00060000000; // M: flushrs
    DWORDLONG dwlM1 = 0x00008000000; // M: nop.m 0
//  DWORDLONG dwlI2 = 0x00000000000; // I: break.i 0       - this causes an Invalid Instruction exception    (0xC000001D)
//  DWORDLONG dwlI2 = 0x00000000040; // I: break.i 0x40    - this causes an Integer Divide By Zero exception (0xC0000094)
//  DWORDLONG dwlI2 = 0x00002000000; // I: break.i 0x80000 - this causes an Invalid Instruction exception    (0xC000001D)
    DWORDLONG dwlI2 = 0x00002000580; // I: break.i 0x80016 - this value came from notepad's initial breakpoint on build 2257.

    pIA64B->dwll = dwlTemplate | (dwlM0 << 5) | ((dwlM1 & 0x3FFFF) << 46); // template + slot 0 + low 18 bits of slot 1 = 64-bits
    pIA64B->dwlh = ((dwlM1 >> 18) & 0x7FFFFF) | (dwlI2 << 23);             // upper 23 bits of slot 1 + slot 2 = 64-bits
}
#endif

//******************************************************************************
// Errors displayed by us, but handled by caller.
BOOL CProcess::SetEntryBreakpoint(CLoadedModule *pModule)
{
    // If we have already set an entrypoint breakpoint for this module, then don't
    // do it again.
    if (pModule->m_fEntryPointBreak)
    {
        return TRUE;
    }

    // We don't ever want to set a breakpoint in our main EXE's entrypoint.
    if (pModule == m_pModule)
    {
        return TRUE;
    }

    // If this is a shared module on Windows 9x, we don't set breakpoints in it.
    if (!g_fWindowsNT && (pModule->m_dwpImageBase >= 0x80000000))
    {
        return TRUE;
    }

    // We only need to hook a module's entrypoint for certain reasons. We check
    // for the following three conditions and bail out if none of them are satisfied.
    if (!(

         // If the user wants to track DllMain calls, then we need to continue.
         (m_dwFlags & (PF_LOG_DLLMAIN_PROCESS_MSGS | PF_LOG_DLLMAIN_OTHER_MSGS))

         // OR, this module has been flagged as needing to be hooked again since it was
         // not properly fixed up by the loader at load time, then we need to continue.
         || pModule->m_fReHook

         // OR, If we are on NT and the user wants to hook, and this is kernel32.dll,
         // and we have not already hooked, then we need to continue
         || (g_fWindowsNT && (m_dwFlags & PF_HOOK_PROCESS) &&
             !_stricmp(pModule->GetName(false), "kernel32.dll") && !m_dwpDWInjectBase)))
    {
        return TRUE;
    }

    // Get the entrypoint for this module.
    DWORD dwEntryPointRVA;
    if (!ReadRemoteMemory(m_hProcess, &pModule->m_pINTH->OptionalHeader.AddressOfEntryPoint,
                          &dwEntryPointRVA, sizeof(dwEntryPointRVA)))
    {
        UserMessage("Error reading the PE headers of \"%s\".  Entrypoint address cannot be determined.", GetLastError(), pModule);
        return FALSE;
    }

    // Make sure we have an entrypoint.
    if (dwEntryPointRVA)
    {
        // Convert the RVA to and absolute address.
        DWORD_PTR dwpEntryPointAddress = pModule->m_dwpImageBase + (DWORD_PTR)dwEntryPointRVA;

        // Get the appropriate code for a breakpoint.
#if defined(_IA64_)

        IA64_BUNDLE entryPointData;
        ZeroMemory(&entryPointData, sizeof(entryPointData)); // inspected

        IA64_BUNDLE breakpoint;
        IA64BuildBreakBundle(&breakpoint);

        // On IA64, then entrypoint seems to actually be a location where the real entrypoint address is stored.
        DWORD_PTR dwpEntryPointPointer = dwpEntryPointAddress;
        if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwpEntryPointPointer, &dwpEntryPointAddress, sizeof(dwpEntryPointAddress)))
        {
            UserMessage("Error reading the entrypoint address of \"%s\".  Entrypoint cannot be hooked.", GetLastError(), pModule);
            return FALSE;
        }

        // Round the entrypoint down to the nearest bundle.
        // It should already be at the start of a bundle.
        dwpEntryPointAddress &= ~0xFui64;

#elif defined(_X86_) || defined(_AMD64_)

        DWORD entryPointData = 0;
        BYTE  breakpoint = 0xCC;

#elif defined(_ALPHA_) || defined(_ALPHA64_)

        DWORD entryPointData = 0;
        DWORD breakpoint = 0x00000080;

#else
#error("Unknown Target Machine");
#endif

        // Store away the data at the location of the entrypoint code so we can replace it.
        if (!ReadRemoteMemory(m_hProcess, (LPVOID)dwpEntryPointAddress, &entryPointData, sizeof(entryPointData)))
        {
            UserMessage("Error reading data at the entrypoint of \"%s\".  Entrypoint cannot be hooked.", GetLastError(), pModule);
            return FALSE;
        }

        // Write a breakpoint to an unused portion of the module so we can tell DllMain return to it.
        DWORD_PTR dwpAddress = pModule->m_dwpImageBase + BREAKPOINT_OFFSET;
        if (!WriteRemoteMemory(m_hProcess, (LPVOID)dwpAddress, &breakpoint, sizeof(breakpoint), true))
        {
            UserMessage("Error writing a breakpoint at the entrypoint return of \"%s\".  Entrypoint cannot be hooked.", GetLastError(), pModule);
            return FALSE;
        }

        // Write the breakpoint at the location of the entrypoint.
        if (!WriteRemoteMemory(m_hProcess, (LPVOID)dwpEntryPointAddress, &breakpoint, sizeof(breakpoint), true))
        {
            UserMessage("Error writing a breakpoint at the entrypoint of \"%s\".  Entrypoint cannot be hooked.", GetLastError(), pModule);
            return FALSE;
        }

        // Store the information in the module object.
        pModule->m_dwpEntryPointAddress = dwpEntryPointAddress;
        pModule->m_entryPointData       = entryPointData;
        pModule->m_fEntryPointBreak     = true;
    }

    return TRUE;
}

//******************************************************************************
// Errors will be displayed by us, but handled by caller.
BOOL CProcess::EnterEntryPoint(CThread *pThread, CLoadedModule *pModule)
{
    // We want to hook the loaded modules before we remove the entrypoint breakpoint.
    // If we were to call HookImports on this module after removing the breakpoint
    // and HookImports encountered an error, it would re-insert the breakpoint.
    // This can put us in an infinite loop since we will just immediately hit that
    // breakpoint since our IP is at the entrypoint address.
    HookLoadedModules();

    // Restore the data that was at this location before we wrote the breakpoint.
    WriteRemoteMemory(m_hProcess, (LPVOID)pModule->m_dwpEntryPointAddress, &pModule->m_entryPointData, sizeof(pModule->m_entryPointData), true);

    // Clear the entrypoint flag to signify that we have removed the initial breakpoint.
    pModule->m_fEntryPointBreak = false;

    // Get the context of the thread.
    // IA64  needs CONTEXT_CONTROL (RsBSP, StIIP, StIPSR) and CONTEXT_INTEGER (BrRp)
    // x86   needs CONTEXT_CONTROL (Esp, Eip)
    // alpha needs CONTEXT_CONTROL (Fir) and CONTEXT_INTEGER (IntRa, IntA0, IntA1, IntA2)
    CContext context(CONTEXT_CONTROL | CONTEXT_INTEGER);
    if (!GetThreadContext(pThread->m_hThread, context.Get()))
    {
        UserMessage("Error reading a thread's context during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    DLLMAIN_ARGS dma;

#if defined(_IA64_)

    DWORDLONG dwl[3];
    ZeroMemory(dwl, sizeof(dwl)); // inspected

    // The arguments to DllMain are stored in the first 3 local registers (r32, r33, and r34).
    // Registers r32 through r53 are stored in memory at the location stored in RsBSP.
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)context.Get()->RsBSP, (LPVOID)dwl, sizeof(dwl)))
    {
        UserMessage("Error reading the return address during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    // Store the arguments for this call to DllMain.
    dma.hInstance   = (HINSTANCE)dwl[0];
    dma.dwReason    = (DWORD)    dwl[1];
    dma.lpvReserved = (LPVOID)   dwl[2];

    // Get the return address for this call to DllMain.
    pModule->m_dwpReturnAddress = context.Get()->BrRp;

    // Change the return address of DllMain so we can catch it with our magic breakpoint.
    context.Get()->BrRp = pModule->m_dwpImageBase + BREAKPOINT_OFFSET;

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    // When we stored the entrypoint, we rounded it down to the nearest bundle.  Here,
    // we are assuming the entry point is always at the beginning of a bundle so we
    // clear the two RI bits to set us to slot 0.
    context.Get()->StIIP = pModule->m_dwpEntryPointAddress;
    context.Get()->StIPSR &= ~(3ui64 << IA64_PSR_RI);

#elif defined(_X86_)

    // Get the return address and args for this call to DllMain.
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)(DWORD_PTR)context.Get()->Esp, (LPVOID)&dma, sizeof(dma)))
    {
        UserMessage("Error reading the return address during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }
    pModule->m_dwpReturnAddress = (DWORD_PTR)dma.lpvReturnAddress;

    // Change the return address of DllMain so we can catch it with our magic breakpoint.
    DWORD_PTR dwpAddress = pModule->m_dwpImageBase + BREAKPOINT_OFFSET;
    if (!WriteRemoteMemory(m_hProcess, (LPVOID)(DWORD_PTR)context.Get()->Esp, (LPVOID)&dwpAddress, sizeof(dwpAddress), false))
    {
        UserMessage("Error writing the return address during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->Eip = (DWORD)pModule->m_dwpEntryPointAddress;

#elif defined(_ALPHA_) || defined(_ALPHA64_)

    // Get the args for this call to DllMain.
    dma.hInstance   = (HINSTANCE)context.Get()->IntA0;
    dma.dwReason    = (DWORD)    context.Get()->IntA1;
    dma.lpvReserved = (LPVOID)   context.Get()->IntA2;

    // Get the return address for this call to DllMain.
    pModule->m_dwpReturnAddress = (DWORD_PTR)context.Get()->IntRa;

    // Change the return address of DllMain so we can catch it with our magic breakpoint.
    context.Get()->IntRa = pModule->m_dwpImageBase + BREAKPOINT_OFFSET;

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->Fir = pModule->m_dwpEntryPointAddress;

#elif defined(_AMD64_)

    // Get the args for this call to DllMain.
    dma.hInstance = (HINSTANCE)context.Get()->Rcx;
    dma.dwReason  = (DWORD)    context.Get()->Rdx;
    dma.lpvReserved = (LPVOID) context.Get()->R8;

    // Get the return address for this call to DllMain.
    if (!ReadRemoteMemory(m_hProcess, (LPVOID)context.Get()->Rsp, (LPVOID)&dma, sizeof(dma)))
    {
        UserMessage("Error reading the return address during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }
    pModule->m_dwpReturnAddress = (DWORD_PTR)dma.lpvReturnAddress;

    // Change the return address of DllMain so we can catch it with our magic breakpoint.
    ULONG64 dwpAddress = pModule->m_dwpImageBase + BREAKPOINT_OFFSET;
    if (!WriteRemoteMemory(m_hProcess, (LPVOID)context.Get()->Rsp, (LPVOID)&dwpAddress, sizeof(dwpAddress), false))
    {
        UserMessage("Error writing the return address during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->Rip = pModule->m_dwpEntryPointAddress;

#else
#error("Unknown Target Machine");
#endif

    // Commit the context changes.
    if (!SetThreadContext(pThread->m_hThread, context.Get()))
    {
        UserMessage("Error setting a thread's context during a call to the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    // Allocate a new event object for this event and add it to our event list.
    if (!(pModule->m_pEventDllMainCall = new CEventDllMainCall(pThread, pModule, &dma)))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Add a reference to the event so that it doesn't get freed if a flush occurs.
        // The object will get freed when we return from this module's entrypoint.
        pModule->m_pEventDllMainCall->AddRef();
        AddEvent(pModule->m_pEventDllMainCall);
    }

    // Otherwise, we send it to the session now.
    else if (m_pSession)
    {
        m_pSession->EventDllMainCall(pModule->m_pEventDllMainCall);
    }

    return TRUE;
}

//******************************************************************************
// Errors will be displayed by us, but handled by caller.
BOOL CProcess::ExitEntryPoint(CThread *pThread, CLoadedModule *pModule)
{
    // Get the session module name if we don't have one already.
    GetSessionModuleName();

    // Get the context of the thread.
    // IA64  needs CONTEXT_CONTROL (StIIP, StIPSR) and CONTEXT_INTEGER (IntV0)
    // x86   needs CONTEXT_CONTROL (Eip) and CONTEXT_INTEGER (Eax)
    // alpha needs CONTEXT_CONTROL (Fir) and CONTEXT_INTEGER (IntV0)
    CContext context(CONTEXT_CONTROL | CONTEXT_INTEGER);
    if (!GetThreadContext(pThread->m_hThread, context.Get()))
    {
        UserMessage("Error reading a thread's context during the return from the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

#if defined(_IA64_)

    // Get the return value
    BOOL fResult = (BOOL)context.Get()->IntV0; // IntV0 is really r8/ret0.

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->StIIP = pModule->m_dwpReturnAddress;
    context.Get()->StIPSR &= ~(3ui64 << IA64_PSR_RI);

#elif defined(_X86_)


    // Get the return value
    BOOL fResult = (BOOL)context.Get()->Eax;

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->Eip = (DWORD)pModule->m_dwpReturnAddress;

#elif defined(_ALPHA_) || defined(_ALPHA64_)


    // Get the return value
    BOOL fResult = (BOOL)context.Get()->IntV0;

    // Set this thread's IP back to the entrypoint so we can run without the breakpoint.
    context.Get()->Fir = pModule->m_dwpReturnAddress;

#elif defined(_AMD64_)

    // Get the return value
    BOOL fResult = (BOOL)context.Get()->Rax;
    context.Get()->Rip = pModule->m_dwpReturnAddress;

#else
#error("Unknown Target Machine");
#endif

    // Commit the context changes.
    if (!SetThreadContext(pThread->m_hThread, context.Get()))
    {
        UserMessage("Error setting a thread's context during the return from the entrypoint of \"%s\".", GetLastError(), pModule);
        return FALSE;
    }

    // Set the entry breakpoint again so we can catch future calls to this module.
    if (!SetEntryBreakpoint(pModule))
    {
        // SetEntryBreakpoint will display any errors encountered.
        return FALSE;
    }

    // If we are currently caching, then just store this event away for later.
    if (IsCaching())
    {
        // Allocate a new event object for this event and add it to our event list.
        CEventDllMainReturn *pEvent = new CEventDllMainReturn(pThread, pModule, fResult);
        if (!pEvent)
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        AddEvent(pEvent);
    }
    else if (m_pSession)
    {
        // Create a temporary event object on our stack and pass it to our session.
        CEventDllMainReturn event(pThread, pModule, fResult);
        m_pSession->EventDllMainReturn(&event);
    }

    return TRUE;
}

//******************************************************************************
// Errors displayed by us, but handled by caller.
BOOL CProcess::InjectDll()
{
    // Safeguard: Don't inject if we are not supposed to hook.
    if (!(m_dwFlags & PF_HOOK_PROCESS))
    {
        return FALSE;
    }

    // Get the context of the remote process so that we can restore it after we
    // inject DEPENDS.DLL.
    m_contextOriginal.Get()->ContextFlags = CONTEXT_FULL;

    if (!GetThreadContext(m_pThread->m_hThread, m_contextOriginal.Get()))
    {
        UserMessage("The process cannot be hooked due to an error obtaining a thread's context.", GetLastError(), NULL);
        return FALSE;
    }

    // Create a page size block on our stack that we can fill in.
    BYTE bInjectionPage[sizeof(INJECTION_CODE) + DW_MAX_PATH];
    PINJECTION_CODE pInjectionCode = (PINJECTION_CODE)bInjectionPage;

    // Store the DLL path for the module we want to inject.
    StrCCpy(pInjectionCode->szDataDllPath, g_pszDWInjectPath, DW_MAX_PATH);

    // Compute how big our page is.
    m_dwPageSize = sizeof(INJECTION_CODE) + (DWORD)strlen(pInjectionCode->szDataDllPath);

    // Allocate a buffer to hold the original page of memory before we overwrite
    // it with our fake page.
    m_pbOriginalPage = (LPBYTE)MemAlloc(m_dwPageSize);

    // Find a page in the remote process that we can swap in our fake page with.
    m_dwpPageAddress = FindUsablePage(m_dwPageSize);

    // The FindUsablePage function attempts to locate the smartest location within
    // the remote module to overwrite with out fake page.  If for some reason, it
    // grabs a block of memory that is invalid (could probably happen if someone has
    // been screwing with the section headers or run some bad strip program on the
    // module), then we try again just using the module base as the overwrite point.
    RETRY_AT_BASE_ADDRESS:

#if defined(_IA64_)

    // Get the size of the frame and locals.  These are stored in the lower 14 bits of StIFS.
    DWORD dwSOF = (DWORD)((m_contextOriginal.Get()->StIFS     ) & 0x7Fui64);
    DWORD dwSOL = (DWORD)((m_contextOriginal.Get()->StIFS >> 7) & 0x7Fui64);
    
    // We need one output register, so we require that the frame is bigger than the locals.
    ASSERT(dwSOF > dwSOL);

    // Store the DLL path in our first output register.  Static registers are
    // r0 through r31, which are followed by local registers (dwSOL), which are
    // followed by our output registers.  Out first output register should be
    // 32 + dwSOL.
    IA64BuildMovLBundle(&pInjectionCode->b1, 32 + dwSOL, m_dwpPageAddress + offsetof(INJECTION_CODE, szDataDllPath));

    // Store the address of LoadLibraryA in a static register.  IA64 adds one
    // more level of indirection.  So, the address we have in dwpOldAddress is
    // really a location where the real address is stored.  Not sure why this is.
    DWORDLONG dwl = 0;
    ReadRemoteMemory(m_hProcess, (LPCVOID)m_HookFunctions[0].dwpOldAddress, &dwl, sizeof(dwl));
    IA64BuildMovLBundle(&pInjectionCode->b2, 31, dwl);

    // Copy the function address to a branch register and make the call.
    IA64BuildCallBundle(&pInjectionCode->b3);

    // Store the address of GetLastError in a static register
    ReadRemoteMemory(m_hProcess, (LPCVOID)GetLastError, &(dwl = 0), sizeof(dwl));
    IA64BuildMovLBundle(&pInjectionCode->b4, 31, dwl);

    // Copy the function address to a branch register and make the call.
    IA64BuildCallBundle(&pInjectionCode->b5);

    // Breakpoint.
    IA64BuildBreakBundle(&pInjectionCode->b6);

#elif defined(_X86_)

    // Manually fill in the local page with x86 asm code.
    pInjectionCode->wInstructionSUB  = 0xEC81;
    pInjectionCode->dwOperandSUB     = 0x00001000;

    pInjectionCode->bInstructionPUSH = 0x68;
    pInjectionCode->dwOperandPUSH = (DWORD)(m_dwpPageAddress + offsetof(INJECTION_CODE, szDataDllPath));

    pInjectionCode->bInstructionCALL = 0xE8;
    pInjectionCode->dwOperandCALL = (DWORD)(m_HookFunctions[0].dwpOldAddress - m_dwpPageAddress - offsetof(INJECTION_CODE, bInstructionCALL) - 5);

    pInjectionCode->bInstructionCALL2 = 0xE8;
    pInjectionCode->dwOperandCALL2 = (DWORD)((DWORD_PTR)GetLastError - m_dwpPageAddress - offsetof(INJECTION_CODE, bInstructionCALL2) - 5);

    pInjectionCode->bInstructionINT3 = 0xCC;

#elif defined(_AMD64_)

    // Manually fill in the local page with x86 asm code.
    pInjectionCode->MovRcx1 = 0xB948;   // mov rcx, immed64
    pInjectionCode->OperandMovRcx1 = m_dwpPageAddress + offsetof(INJECTION_CODE, szDataDllPath);

    pInjectionCode->MovRax1 = 0xB848;   // mov rax, immed64
    pInjectionCode->OperandMovRax1 = m_HookFunctions[0].dwpOldAddress;
    pInjectionCode->CallRax1 = 0xD0FF;  // call rax

    pInjectionCode->MovRax2 = 0xB848;   // mov rax, immed64
    pInjectionCode->OperandMovRax2 = (ULONG64)GetLastError;
    pInjectionCode->CallRax2 = 0xD0FF;  // call rax

    pInjectionCode->Int3 = 0xCC;        // int 3

#elif defined(_ALPHA_) || defined(_ALPHA64_)

    // Manually fill in the local page with alpha asm code. Note the code only
    // provides a breakpoint to end the call.  All of the magic to call
    // LoadLibraryA is done by setting the context. The initial halt instruction
    // flags this code sequence as magic in case it is ever inspected.
    pInjectionCode->dwInstructionBp = 0x00000080;

#else
#error("Unknown Target Machine");
#endif

    // Save off the original code page.
    if (!ReadRemoteMemory(m_hProcess, (LPCVOID)m_dwpPageAddress, m_pbOriginalPage, m_dwPageSize))
    {
        // Only display an error if this is our second pass through.
        if (m_dwpPageAddress == m_pModule->m_dwpImageBase)
        {
            UserMessage("The process cannot be hooked due to an error reading a page of memory.", GetLastError(), NULL);
            MemFree((LPVOID&)m_pbOriginalPage);
            return FALSE;
        }

        // Try again, this time use our module's base address.
        TRACE("InjectDll: ReadRemoteMemory() failed at " HEX_FORMAT " for 0x%08X bytes [%u].  Trying again at base address.\n",
              m_dwpPageAddress, m_dwPageSize, GetLastError());
        m_dwpPageAddress = m_pModule->m_dwpImageBase;
        goto RETRY_AT_BASE_ADDRESS;
    }

    // Write out the new code page to the remote process.
    if (!WriteRemoteMemory(m_hProcess, (LPVOID)m_dwpPageAddress, bInjectionPage, m_dwPageSize, true))
    {
        // Only display an error if this is our second pass through.
        if (m_dwpPageAddress == m_pModule->m_dwpImageBase)
        {
            UserMessage("The process cannot be hooked due to an error writing the hooking code to memory.", GetLastError(), NULL);
            MemFree((LPVOID&)m_pbOriginalPage);
            return FALSE;
        }

        // Try again, this time use our module's base address.
        TRACE("InjectDll: ReadRemoteMemory() failed at " HEX_FORMAT " for 0x%08X bytes [%u].  Trying again at base address.\n",
              m_dwpPageAddress, m_dwPageSize, GetLastError());
        m_dwpPageAddress = m_pModule->m_dwpImageBase;
        goto RETRY_AT_BASE_ADDRESS;
    }

    // Prepare our injection context by starting with the current context.
    CContext contextInjection(m_contextOriginal);

#if defined(_IA64_)

    // Set the instruction pointer so that it points to the beginning of our
    // injected code page.
    contextInjection.Get()->StIIP = m_dwpPageAddress;
    contextInjection.Get()->StIPSR &= ~(3ui64 << IA64_PSR_RI);

#elif defined(_X86_)

    // Set the instruction pointer so that it points to the beginning of our
    // injected code page.
    contextInjection.Get()->Eip = (DWORD)m_dwpPageAddress;

#elif defined(_ALPHA_) || defined(_ALPHA64_)


    // Set the Arg0 register so that it contains the address of the image to load.
    contextInjection.Get()->IntA0 =
    m_dwpPageAddress + offsetof(INJECTION_CODE, szDataDllPath);

    // Set the instruction pointer so that it contains the address of LoadLibraryA.
    contextInjection.Get()->Fir = (DWORD_PTR)m_HookFunctions[0].dwpOldAddress;

    // Set the return address so that it points to the breakpoint in the injected code page.
    contextInjection.Get()->IntRa = m_dwpPageAddress + offsetof(INJECTION_CODE, dwInstructionBp);

#elif defined(_AMD64_)

    // Set the instruction pointer so that it points to the beginning of our
    // injected code page
    contextInjection.Get()->Rip = m_dwpPageAddress;

#else
#error("Unknown Target Machine");
#endif

    // Set the remote process' context so that our injection page will run
    // once the process is resumed.
    if (!SetThreadContext(m_pThread->m_hThread, contextInjection.Get()))
    {
        MemFree((LPVOID&)m_pbOriginalPage);
        UserMessage("Failure setting the thread's context after injecting the hooking code.", GetLastError(), NULL);
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
// Errors displayed by us, but handled by caller.
DWORD_PTR CProcess::FindUsablePage(DWORD dwSize)
{
    // Map an IMAGE_NT_HEADERS structure onto the remote image.
    IMAGE_NT_HEADERS INTH;

    // Read in the PIMAGE_NT_HEADERS.
    if (!ReadRemoteMemory(m_hProcess, m_pModule->m_pINTH, &INTH, sizeof(INTH)))
    {
        UserMessage("Error reading the main module's PE headers.  Unable to determine a place to inject the hooking code.", GetLastError(), NULL);
        return m_pModule->m_dwpImageBase;
    }

    // Get a pointer to the first section.
    IMAGE_SECTION_HEADER ISH, *pISH = (PIMAGE_SECTION_HEADER)((DWORD_PTR)m_pModule->m_pINTH +
                                                              (DWORD_PTR)FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
                                                              (DWORD_PTR)INTH.FileHeader.SizeOfOptionalHeader);

    DWORD_PTR dwpReadOnlySection = 0;
    DWORD     dw;

// Some debugging stuff to help us identify the module makeup.
#ifdef DEBUG

    // Just a table of directory names and descriptions.
    LPCSTR pszDirNames[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
    {
        "IMAGE_DIRECTORY_ENTRY_EXPORT         Export Directory",
        "IMAGE_DIRECTORY_ENTRY_IMPORT         Import Directory",
        "IMAGE_DIRECTORY_ENTRY_RESOURCE       Resource Directory",
        "IMAGE_DIRECTORY_ENTRY_EXCEPTION      Exception Directory",
        "IMAGE_DIRECTORY_ENTRY_SECURITY       Security Directory",
        "IMAGE_DIRECTORY_ENTRY_BASERELOC      Base Relocation Table",
        "IMAGE_DIRECTORY_ENTRY_DEBUG          Debug Directory",
        "IMAGE_DIRECTORY_ENTRY_ARCHITECTURE   Architecture Specific Data",
        "IMAGE_DIRECTORY_ENTRY_GLOBALPTR      RVA of GP",
        "IMAGE_DIRECTORY_ENTRY_TLS            TLS Directory",
        "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    Load Configuration Directory",
        "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   Bound Import Directory in headers",
        "IMAGE_DIRECTORY_ENTRY_IAT            Import Address Table",
        "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   Delay Load Import Descriptors",
        "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR COM Runtime descriptor",
        "N/A"
    };

    // Dump out the number of directories.
    TRACE("NumberOfRvaAndSizes:0x%08X\n", INTH.OptionalHeader.NumberOfRvaAndSizes);

    // Dump out the directories.
    for (int z = 0; z < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; z++)
    {
        TRACE("DIR:%2u, VA:0x%08X, SIZE:0x%08X, NAME:%s\n", z,
              INTH.OptionalHeader.DataDirectory[z].VirtualAddress,
              INTH.OptionalHeader.DataDirectory[z].Size,
              pszDirNames[z]);
    }

    // Dump out the sections.
    IMAGE_SECTION_HEADER *pISH2 = pISH;
    for (dw = 0; dw < INTH.FileHeader.NumberOfSections; dw++)
    {
        if (!ReadRemoteMemory(m_hProcess, pISH2, &ISH, sizeof(ISH)))
        {
            TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
            break;
        }
        ASSERT(!(ISH.VirtualAddress & 0xF)); // Make sure this page is 128-bit aligned.
        TRACE("SECTION:%s, VA:0x%08X, SIZE:0x%08X, NEEDED:0x%08X, WRITE:%u, EXEC:%u\n", ISH.Name, ISH.VirtualAddress, ISH.SizeOfRawData, dwSize, (ISH.Characteristics & IMAGE_SCN_MEM_WRITE) != 0, (ISH.Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0);
        pISH2++;
    }

    // Dump out some other useful stuff.
    TRACE("BaseOfCode:0x%08X\n", INTH.OptionalHeader.BaseOfCode);
    TRACE("SizeOfCode:0x%08X\n", INTH.OptionalHeader.SizeOfCode);
//  TRACE("BaseOfData:0x%08X\n", INTH.OptionalHeader.BaseOfData);

#endif // DEBUG

    // Loop through all the sections looking for a writable one that is big
    // enough to hold our injection page.
    for (dw = 0; dw < INTH.FileHeader.NumberOfSections; dw++)
    {
        // Read in the IMAGE_SECTION_HEADER for this section.
        if (!ReadRemoteMemory(m_hProcess, pISH, &ISH, sizeof(ISH)))
        {
            TRACE("ReadRemoteMemory() failed at line %u [%u]\n", __LINE__, GetLastError());
            break;
        }

        // Check to see if it is big enough.
        if (ISH.SizeOfRawData >= dwSize)
        {
            // Check to see if this section is writable.
            if (ISH.Characteristics & IMAGE_SCN_MEM_WRITE)
            {
                // If it is writable, then return it.
                TRACE("FindUsablePage is returning RW page at " HEX_FORMAT "\n", m_pModule->m_dwpImageBase + (DWORD_PTR)ISH.VirtualAddress);
                return m_pModule->m_dwpImageBase + (DWORD_PTR)ISH.VirtualAddress;
            }

            // We would prefer a writable section, but we will remember this
            // read-only section just in case we can't find one.
            else if (!dwpReadOnlySection)
            {
                dwpReadOnlySection = m_pModule->m_dwpImageBase + (DWORD_PTR)ISH.VirtualAddress;
            }
        }

        pISH++; // Advance to the next section.
    }

    // We didn't find a writable section - did we find at least a read-only section?
    if (dwpReadOnlySection)
    {
        TRACE("FindUsablePage is returning RO page at " HEX_FORMAT "\n", dwpReadOnlySection);
        return dwpReadOnlySection;
    }

    // If that failed, then check to see if we use the code base, if that leaves
    // enough room to fit the page in, even if we write over several sections.
    if ((INTH.OptionalHeader.SizeOfImage - INTH.OptionalHeader.BaseOfCode) >= dwSize)
    {
        TRACE("FindUsablePage is returning base of code at " HEX_FORMAT "\n", m_pModule->m_dwpImageBase + (DWORD_PTR)INTH.OptionalHeader.BaseOfCode);
        return (m_pModule->m_dwpImageBase + (DWORD_PTR)INTH.OptionalHeader.BaseOfCode);
    }

    // If all else fails, we return the module's image base.
    return m_pModule->m_dwpImageBase;
}

//******************************************************************************
// Errors displayed by us, but handled by caller.
BOOL CProcess::ReplaceOriginalPageAndContext()
{
    BOOL fResult = TRUE;

    // Make sure we have a page to restore.
    if (!m_pbOriginalPage)
    {
        return FALSE;
    }

    // Restore the original page to the remote process.
    if (!WriteRemoteMemory(m_hProcess, (LPVOID)m_dwpPageAddress, m_pbOriginalPage, m_dwPageSize, true))
    {
        fResult = FALSE;
        UserMessage("Failure restoring the original code page after hooking the process.", GetLastError(), NULL);
    }

    // Free our original page buffer.
    MemFree((LPVOID&)m_pbOriginalPage);

    // Restore the original context of the remote process.
    if (!SetThreadContext(m_pThread->m_hThread, m_contextOriginal.Get()))
    {
        fResult = FALSE;
        UserMessage("Failure restoring the original thread's context after hooking the process.", GetLastError(), NULL);
    }

    return fResult;
}


//******************************************************************************
// On Windows NT, we don't get a module name or path when receiving the
// CREATE_PROCESS_DEBUG_EVENT event or the first LOAD_DLL_DEBUG_EVENT. For the
// LOAD_DLL_DEBUG_EVENT event, it seems to always be NTDLL.DLL.  A simple base
// address check verifies this and we know the path for NTDLL.DLL, so we can
// just use it.  This has always worked perfectly.
//
// For the CREATE_PROCESS_DEBUG_EVENT missing path, it is only a problem for
// child processes.  Since we launch the primary process, we already know its
// path.  However, we have no clue what a child process' name is since the remote
// process launches it.  If we hook the remote process, we send the name back
// to us once our injection DLL is in, but if we are not hooking, then we are
// sort of screwed.  This is where this function helps out.
//
// This function will load PSAPI.DLL which is capable of telling us the module
// name.  The PSAPI calls do not work on a module as soon as it loads.  It looks
// like NTDLL.DLL has to completely load in the process before PSAPI can query
// names from it. For this reason, we just keep calling this function at various
// times and eventually it gets a name.

void CProcess::GetSessionModuleName()
{
    // Bail if we already have a session, do not have a main module, or are
    // hooking. If we are hooking, then we will get the module name when our
    // injection DLL reports it back to us.
    if (m_pSession || !m_pModule || (m_dwFlags & PF_HOOK_PROCESS))
    {
        return;
    }

    // If we already have a path, then just use it.  We usually only enter
    // this if statement when on Windows 9x when debugging a child process.
    // On 9x, we get a path name right from the start with child processes,
    // but we don't create a session until the injection DLL has been injected
    // and given us the path, args, and current directory.  However, if our
    // hooking fails for some reason, this is our backup plan for creating
    // the session.
    if (m_pModule->GetName(true) && *m_pModule->GetName(true))
    {
        // ProcessDllMsgModulePath will create a session for us.
        ProcessDllMsgModulePath(m_pModule->GetName(true));
    }

    // Otherwise, attempt to query the path and use that,  This is the normal
    // path for child processes on Windows NT.
    else
    {
        CHAR szPath[DW_MAX_PATH];
        if (GetModuleName(m_pModule->m_dwpImageBase, szPath, sizeof(szPath)))
        {
            // We just call ProcessDllMsgModulePath to do our work since it does
            // everything we want to do once we have obtained our path name.
            ProcessDllMsgModulePath(szPath);
        }
    }
}

//******************************************************************************
bool CProcess::GetModuleName(DWORD_PTR dwpImageBase, LPSTR pszPath, DWORD dwSize)
{
    // Make sure path is nulled-out.
    *pszPath = '\0';

    // Bail if we are not on NT (since PSAPI.DLL only exists on NT).
    if (!g_fWindowsNT)
    {
        return false;
    }

    // Make sure we have a pointer to GetModuleFileNameExA.
    if (!g_theApp.m_pfnGetModuleFileNameExA)
    {
        // Load PSAPI.DLL if not already loaded - it will be freed later.
        if (!g_theApp.m_hPSAPI)
        {
            if (!(g_theApp.m_hPSAPI = LoadLibrary("psapi.dll"))) // inspected
            {
                TRACE("LoadLibrary(\"psapi.dll\") failed [%u].\n", GetLastError());
                return false;
            }
        }

        // Get the function pointer.
        if (!(g_theApp.m_pfnGetModuleFileNameExA =
              (PFN_GetModuleFileNameExA)GetProcAddress(g_theApp.m_hPSAPI, "GetModuleFileNameExA")))
        {
            TRACE("GetProcAddress(\"psapi.dll\", \"GetModuleFileNameExA\") failed [%u].\n", GetLastError());
            return false;
        }
    }

    // Attempt to get the module path
    DWORD dwLength = g_theApp.m_pfnGetModuleFileNameExA(m_hProcess, (HINSTANCE)dwpImageBase, pszPath, dwSize);

    // If we got a valid path, then return true.
    if (dwLength && (dwLength < dwSize) && *pszPath)
    {
        return true;
    }

    // Otherwise, make sure path is nulled-out and return false.
    *pszPath = '\0';
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\depends.cpp ===
//******************************************************************************
//
// File:        DEPENDS.CPP
//
// Description: Implementation file for the main application, command line
//              parsing classes, and global utility functions.
//             
// Classes:     CMainApp
//              CCommandLineInfoEx
//              CCmdLineProfileData
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"

#define __DEPENDS_CPP__
#include "depends.h"

#include "search.h"
#include "dbgthread.h"
#include "session.h"
#include "msdnhelp.h"
#include "document.h"
#include "mainfrm.h"
#include "splitter.h"
#include "childfrm.h"
#include "listview.h"
#include "funcview.h"
#include "profview.h"
#include "modlview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CMainApp
//******************************************************************************

BEGIN_MESSAGE_MAP(CMainApp, CWinApp)
    //{{AFX_MSG_MAP(CMainApp)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    ON_UPDATE_COMMAND_UI(IDM_AUTO_EXPAND, OnUpdateAutoExpand)
    ON_COMMAND(IDM_AUTO_EXPAND, OnAutoExpand)
    ON_UPDATE_COMMAND_UI(IDM_VIEW_FULL_PATHS, OnUpdateViewFullPaths)
    ON_COMMAND(IDM_VIEW_FULL_PATHS, OnViewFullPaths)
    ON_UPDATE_COMMAND_UI(IDM_VIEW_UNDECORATED, OnUpdateViewUndecorated)
    ON_COMMAND(IDM_VIEW_UNDECORATED, OnViewUndecorated)
    ON_COMMAND(IDM_VIEW_SYS_INFO, OnViewSysInfo)
    ON_COMMAND(IDM_CONFIGURE_VIEWER, OnConfigureExternalViewer)
    ON_COMMAND(IDM_HANDLED_FILE_EXTS, OnHandledFileExts)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(IDM_CONFIGURE_SEARCH_ORDER, OnConfigureSearchOrder)
    ON_COMMAND(IDM_CONFIGURE_EXTERNAL_HELP, OnConfigureExternalHelp)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
//  ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
//  Standard print setup command
//  ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()


//******************************************************************************
// CMainApp :: Constructor/Destructor
//******************************************************************************

CMainApp::CMainApp() :
    m_fVisible(false),
    m_pNewDoc(NULL),
    m_pProcess(NULL),
    m_hNTDLL(NULL),
    m_hKERNEL32(NULL),
    m_pfnCreateActCtxA(NULL),
    m_pfnActivateActCtx(NULL),
    m_pfnDeactivateActCtx(NULL),
    m_pfnReleaseActCtx(NULL),
    m_hIMAGEHLP(NULL),
    m_pfnUnDecorateSymbolName(NULL),
    m_hPSAPI(NULL),
    m_pfnGetModuleFileNameExA(NULL),
    m_hOLE32(NULL),
    m_pfnCoInitialize(NULL),
    m_pfnCoUninitialize(NULL),
    m_pfnCoCreateInstance(NULL),
    m_hOLEAUT32(NULL),
    m_pfnSysAllocStringLen(NULL),
    m_pfnSysFreeString(NULL),
    m_psgDefault(NULL),
    m_pMsdnHelp(NULL),
    m_nShortDateFormat(LOCALE_DATE_MDY),
    m_nLongDateFormat(LOCALE_DATE_MDY),
    m_f24HourTime(false),
    m_fHourLeadingZero(false),
    m_cDateSeparator('/'),
    m_cTimeSeparator(':'),
    m_cThousandSeparator(','),
    m_fNoDelayLoad(false),
    m_fNeverDenyProfile(false),
    m_pDocTemplate(NULL)
{
    NameThread("Main");

    // Determine what OS we are running on.
    DetermineOS();
}

//******************************************************************************
CMainApp::~CMainApp()
{
    CSearchGroup::DeleteSearchOrder(m_psgDefault);
}


//******************************************************************************
// CMainApp :: Overridden functions
//******************************************************************************

BOOL CMainApp::InitInstance()
{
    __try
    {
        return InitInstanceWrapped();
    }
    __except (ExceptionFilter(_exception_code(), false))
    {
    }
    return FALSE;
}

//******************************************************************************
BOOL CMainApp::InitInstanceWrapped()
{
    // Store our settings under HKEY_CURRENT_USER\Software\Microsoft\Dependency Walker
    SetRegistryKey("Microsoft");

    // Figure our how dates, times, and values should be displayed.
    QueryLocaleInfo();

    // Parse command line for standard shell commands, DDE, file open
    ParseCommandLine(m_cmdInfo);

    // Dynamically load KERNEL32.DLL and get the Side-by-Side versioning APIs.
    // These functions were added in Whistler and may show up on previous OSes
    // with some service pack or .NET update.
    if (m_hKERNEL32 = LoadLibrary("KERNEL32.DLL")) // inspected
    {
        if (!(m_pfnCreateActCtxA    = (PFN_CreateActCtxA)   GetProcAddress(m_hKERNEL32, "CreateActCtxA"))    ||
            !(m_pfnActivateActCtx   = (PFN_ActivateActCtx)  GetProcAddress(m_hKERNEL32, "ActivateActCtx"))   ||
            !(m_pfnDeactivateActCtx = (PFN_DeactivateActCtx)GetProcAddress(m_hKERNEL32, "DeactivateActCtx")) ||
            !(m_pfnReleaseActCtx    = (PFN_ReleaseActCtx)   GetProcAddress(m_hKERNEL32, "ReleaseActCtx")))
        {
            m_pfnCreateActCtxA    = NULL;
            m_pfnActivateActCtx   = NULL;
            m_pfnDeactivateActCtx = NULL;
            m_pfnReleaseActCtx    = NULL;
        }
    }

    // Dynamically load IMAGEHLP.DLL and get the UnDecorateSymbolName function
    // address.  This module is not present on Win95 golden, but many apps
    // install it so it will most likely be present.  NT 4.0 and Win98 both
    // have this module by default.
    if (m_hIMAGEHLP = LoadLibrary("IMAGEHLP.DLL")) // inspected
    {
        m_pfnUnDecorateSymbolName = (PFN_UnDecorateSymbolName)GetProcAddress(m_hIMAGEHLP, "UnDecorateSymbolName");
    }

    // Private setting to disable the processes of delay-load modules.  This is
    // currently undocumented and there is no way to set it from the UI.
    m_fNoDelayLoad = g_theApp.GetProfileInt(g_pszSettings, "NoDelayLoad", false) ? true : false; // inspected. MFC function

    // Private setting that disables our valid module check before doing a profile.
    // This override just allows us to profile anything, even if we think it is
    // not valid.  I put this in in case I accidently block something that is valid.
    m_fNeverDenyProfile = g_theApp.GetProfileInt(g_pszSettings, "NeverDenyProfile", false) ? true : false; // inspected. MFC function

    // Create the onject that manages our help lookups for functions.
    m_pMsdnHelp = new CMsdnHelp();

    // Initialize to use rich edit controls - needs to be called before ProcessCommandLineInfo.
    AfxInitRichEdit();

    // Verify our command line options and bail now if we should not
    // continue to display our UI.
    if (!ProcessCommandLineInfo())
    {
        return FALSE;
    }

#if (_MFC_VER < 0x0700)
#ifdef _AFXDLL
    // Call this when using MFC in a shared DLL.
    Enable3dControls();
#else
    // Call this when linking to MFC statically.
    Enable3dControlsStatic();
#endif
#endif

    // Load standard INI file options (including MRU).
    LoadStdProfileSettings(8);

    // Create our global Image Lists that all views will share.
    m_ilTreeModules.Create(IDB_TREE_MODULES, 26, 0, RGB(255, 0, 255));
    m_ilListModules.Create(IDB_LIST_MODULES, 26, 0, RGB(255, 0, 255));
    m_ilFunctions.Create  (IDB_FUNCTIONS,    30, 0, RGB(255, 0, 255));
    m_ilSearch.Create     (IDB_SEARCH,       18, 0, RGB(255, 0, 255));

    // Register the application's document templates.
    if (!(m_pDocTemplate = new CMultiDocTemplate(IDR_DEPENDTYPE,
                                                 RUNTIME_CLASS(CDocDepends),
                                                 RUNTIME_CLASS(CChildFrame),
                                                 RUNTIME_CLASS(CView))))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    AddDocTemplate(m_pDocTemplate);

    // Create our main MDI Frame window.
    CMainFrame *pMainFrame = new CMainFrame;
    if (!pMainFrame)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
    {
        return FALSE;
    }

    // Store our main frame window.
    m_pMainWnd = pMainFrame;

    // Enable drag/drop file open.
    m_pMainWnd->DragAcceptFiles();

    // Enable DDE Execute open
    EnableShellOpen();

    // In DW 1.0 we created these keys to tell the shell to display the "View Dependencies"
    // for any file that has a PE signature.  In DW 2.0, we are trying to be less evasive
    // by letting the user decide what file extensions we should handle.  There has also
    // been a couple reports of Dependency Walker launching without warning every time an EXE
    // is clicked on in explorer.  I've never been able to reproduce this, but I'm wondering
    // if these keys are to blame.  Anyway, in version 2.0 we make sure they are gone.
    RegDeleteKeyRecursive(HKEY_CLASSES_ROOT, "FileType\\{A324EA60-2156-11D0-826F-00A0C9044E61}");
    RegDeleteKeyRecursive(HKEY_CLASSES_ROOT, "CLSID\\{A324EA60-2156-11D0-826F-00A0C9044E61}");

    // Instead of calling the standard MFC RegisterShellFileTypes(), we call our
    // own custom routine that configures the shell's context menus for the given
    // file extensions that we support. We do this by first scanning the registry
    // to see what extensions we currently handle. Then we pass this list to
    // RegisterExtensions which re-registers us to handle those extensions. This
    // is just a safeguard to make sure all the registry settings are correct and
    // not corrupted. This also helps if the user moves our binary since the new
    // path will be written each time DW starts.
    RegisterDwiDwpExtensions();
    CString strExts;
    GetRegisteredExtensions(strExts);
    RegisterExtensions(strExts);

    // Initialize our external viewer dialog.
    m_dlgViewer.Initialize();

    // Don't display a new MDI child window during startup
    if (m_cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
    {
        m_cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;
    }

    // Dispatch any commands specified on the command line.
    if (!ProcessShellCommand(m_cmdInfo))
    {
        return FALSE;
    }

    // The main window has been initialized, so show it and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    // We are now visible.
    m_fVisible = true;

    // If we opened a file from the command line, then save the results to any
    // output files that were specified on the command line.  The only exception
    // is if we are profiling. In that case, we will save the file after the
    // profiling is complete.
    if (m_pNewDoc && m_pNewDoc->m_pSession && !m_pNewDoc->m_fCommandLineProfile)
    {
        SaveCommandLineFile(m_pNewDoc->m_pSession, &m_pNewDoc->m_pRichViewProfile->GetRichEditCtrl());
    }

    // Tell this document it is safe to display error dialogs and start profiling.
    if (m_pNewDoc)
    {
        m_pNewDoc->AfterVisible();
    }

    return TRUE;
}

//******************************************************************************
int CMainApp::ExitInstance()
{
    __try
    {
        // Call the base class.
        CWinApp::ExitInstance();

        // Free our DEPENDS.DLL path string if we allocated one.
        MemFree((LPVOID&)g_pszDWInjectPath);

        // Free our CMsdnHelp object.
        if (m_pMsdnHelp)
        {
            delete m_pMsdnHelp;
            m_pMsdnHelp = NULL;
        }

        // Free NTDLL.DLL if we loaded it.
        if (m_hNTDLL)
        {
            FreeLibrary(m_hNTDLL);
            m_hNTDLL = NULL;
        }

        // Free KERNEL32.DLL if we loaded it.
        if (m_hKERNEL32)
        {
            FreeLibrary(m_hKERNEL32);
            m_hKERNEL32 = NULL;
        }

        // Free IMAGEHLP.DLL if we loaded it.
        if (m_hIMAGEHLP)
        {
            m_pfnUnDecorateSymbolName = NULL;
            FreeLibrary(m_hIMAGEHLP);
            m_hIMAGEHLP = NULL;
        }

        // Free PSAPI.DLL if we loaded it.
        if (m_hPSAPI)
        {
            m_pfnGetModuleFileNameExA = NULL;
            FreeLibrary(m_hPSAPI);
            m_hPSAPI = NULL;
        }

        // Free OLE32.DLL if we loaded it.
        if (m_hOLE32)
        {
            m_pfnCoInitialize     = NULL;
            m_pfnCoUninitialize   = NULL;
            m_pfnCoCreateInstance = NULL;
            FreeLibrary(m_hOLE32);
            m_hOLE32 = NULL;
        }

        // Free OLEAUT32.DLL if we loaded it.
        if (m_hOLEAUT32)
        {
            m_pfnSysAllocStringLen = NULL;
            m_pfnSysFreeString = NULL;
            FreeLibrary(m_hOLEAUT32);
            m_hOLEAUT32 = NULL;
        }
    }
    __except (ExceptionFilter(_exception_code(), false))
    {
    }

    return (int)g_dwReturnFlags;
}

//******************************************************************************
int CMainApp::Run()
{
    // This wraps our main thread in exception handling so we can exit gracefully
    // if a crash occurs.
    __try
    {
        return CWinApp::Run();
    }
    __except (ExceptionFilter(_exception_code(), false))
    {
    }
    return 0;
}

//******************************************************************************
CDocument* CMainApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
    CDocDepends *pDoc = (CDocDepends*)CWinApp::OpenDocumentFile(lpszFileName);
    if (pDoc && pDoc->IsError())
    {
        RemoveFromRecentFileList(pDoc->GetPathName());
    }
    return pDoc;
}

//******************************************************************************
void CMainApp::QueryLocaleInfo()
{
    char szValue[16];
    int  value;

    // Get the short date format.
    m_nShortDateFormat = LOCALE_DATE_MDY;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDATE, szValue, sizeof(szValue)))
    {
        value = strtoul(szValue, NULL, 0);
        if ((value == LOCALE_DATE_DMY) || (value == LOCALE_DATE_YMD))
        {
            m_nShortDateFormat = value;
        }
    }

    // Get the long date format.
    m_nLongDateFormat = LOCALE_DATE_MDY;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILDATE, szValue, sizeof(szValue)))
    {
        value = strtoul(szValue, NULL, 0);
        if ((value == LOCALE_DATE_DMY) || (value == LOCALE_DATE_YMD))
        {
            m_nLongDateFormat = value;
        }
    }

    // Get the time format.
    m_f24HourTime = false;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITIME, szValue, sizeof(szValue)) &&
        (strtoul(szValue, NULL, 0) == 1))
    {
        m_f24HourTime = true;
    }

    // Check to see if we need a leading zero when displaying hours.
    m_fHourLeadingZero = false;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITLZERO, szValue, sizeof(szValue)) &&
        (strtoul(szValue, NULL, 0) == 1))
    {
        m_fHourLeadingZero = true;
    }

    // Get the date separator character.
    m_cDateSeparator = '/';
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDATE, szValue, sizeof(szValue)) == 2)
    {
        m_cDateSeparator = *szValue;
    }

    // Get the date separator character.
    m_cTimeSeparator = ':';
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szValue, sizeof(szValue)) == 2)
    {
        m_cTimeSeparator = *szValue;
    }

    // Get the date separator character.
    m_cThousandSeparator = ',';
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szValue, sizeof(szValue)) == 2)
    {
        m_cThousandSeparator = *szValue;
    }
}

//******************************************************************************
void CMainApp::DoSettingChange()
{
    // Update our date/time format values.
    QueryLocaleInfo();

    if (m_pDocTemplate)
    {
        // Loop through all our documents.
        POSITION posDoc = m_pDocTemplate->GetFirstDocPosition();
        while (posDoc)
        {
            CDocDepends *pDoc = (CDocDepends*)m_pDocTemplate->GetNextDoc(posDoc);
            if (pDoc)
            {
                // Notify this document about the setting change.
                pDoc->DoSettingChange();
            }
        }
    }
}

//******************************************************************************
CSession* CMainApp::CreateNewSession(LPCSTR pszPath, CProcess *pProcess)
{
    if (!m_pDocTemplate)
    {
        return NULL;
    }

    // Create a new document for this new module.
    m_pProcess = pProcess;
    CDocDepends *pDoc = (CDocDepends*)m_pDocTemplate->OpenDocumentFile(pszPath);
    m_pProcess = NULL;

    return pDoc ? pDoc->m_pSession : NULL;
}

//******************************************************************************
void CMainApp::RemoveFromRecentFileList(LPCSTR pszPath)
{
    if (m_pRecentFileList)
    {
        for (int i = m_pRecentFileList->GetSize() - 1; i >= 0; i--)
        {
            if (!_stricmp(pszPath, (*m_pRecentFileList)[i]))
            {
                m_pRecentFileList->Remove(i);
            }
        }
    }
}

//******************************************************************************
void CMainApp::SaveCommandLineSettings()
{
    // For each option, we save it to the registry if the user implicitly set it
    // from the command line, otherwise, we read the value from the registry.

    if (m_cmdInfo.m_autoExpand >= 0)
    {
        CDocDepends::WriteAutoExpandSetting(m_cmdInfo.m_autoExpand > 0);
    }
    else
    {
        m_cmdInfo.m_autoExpand = CDocDepends::ReadAutoExpandSetting();
    }

    if (m_cmdInfo.m_fullPaths >= 0)
    {
        CDocDepends::WriteFullPathsSetting(m_cmdInfo.m_fullPaths > 0);
    }
    else
    {
        m_cmdInfo.m_fullPaths = CDocDepends::ReadFullPathsSetting();
    }

    if (m_cmdInfo.m_undecorate >= 0)
    {
        CDocDepends::WriteUndecorateSetting(m_cmdInfo.m_undecorate > 0);
    }
    else
    {
        m_cmdInfo.m_undecorate = CDocDepends::ReadUndecorateSetting();
    }

    if (m_cmdInfo.m_sortColumnModules >= 0)
    {
        CListViewModules::WriteSortColumn(m_cmdInfo.m_sortColumnModules);
    }
    else
    {
        m_cmdInfo.m_sortColumnModules = CListViewModules::ReadSortColumn();
    }

    if (m_cmdInfo.m_sortColumnImports >= 0)
    {
        CListViewFunction::WriteSortColumn(false, m_cmdInfo.m_sortColumnImports);
    }
    else
    {
        m_cmdInfo.m_sortColumnImports = CListViewFunction::ReadSortColumn(false);
    }

    if (m_cmdInfo.m_sortColumnExports >= 0)
    {
        CListViewFunction::WriteSortColumn(true, m_cmdInfo.m_sortColumnExports);
    }
    else
    {
        m_cmdInfo.m_sortColumnExports = CListViewFunction::ReadSortColumn(true);
    }

    if (m_cmdInfo.m_profileSimulateShellExecute >= 0)
    {
        CRichViewProfile::WriteSimulateShellExecute(m_cmdInfo.m_profileSimulateShellExecute != 0);
    }
    else
    {
        m_cmdInfo.m_profileSimulateShellExecute = CRichViewProfile::ReadSimulateShellExecute();
    }

    if (m_cmdInfo.m_profileLogDllMainProcessMsgs >= 0)
    {
        CRichViewProfile::WriteLogDllMainProcessMsgs(m_cmdInfo.m_profileLogDllMainProcessMsgs != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogDllMainProcessMsgs = CRichViewProfile::ReadLogDllMainProcessMsgs();
    }

    if (m_cmdInfo.m_profileLogDllMainOtherMsgs >= 0)
    {
        CRichViewProfile::WriteLogDllMainOtherMsgs(m_cmdInfo.m_profileLogDllMainOtherMsgs != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogDllMainOtherMsgs = CRichViewProfile::ReadLogDllMainOtherMsgs();
    }

    if (m_cmdInfo.m_profileHookProcess >= 0)
    {
        CRichViewProfile::WriteHookProcess(m_cmdInfo.m_profileHookProcess != 0);
    }
    else
    {
        m_cmdInfo.m_profileHookProcess = CRichViewProfile::ReadHookProcess();
    }

    if (m_cmdInfo.m_profileLogLoadLibraryCalls >= 0)
    {
        CRichViewProfile::WriteLogLoadLibraryCalls(m_cmdInfo.m_profileLogLoadLibraryCalls != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogLoadLibraryCalls = CRichViewProfile::ReadLogLoadLibraryCalls();
    }

    if (m_cmdInfo.m_profileLogGetProcAddressCalls >= 0)
    {
        CRichViewProfile::WriteLogGetProcAddressCalls(m_cmdInfo.m_profileLogGetProcAddressCalls != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogGetProcAddressCalls = CRichViewProfile::ReadLogGetProcAddressCalls();
    }

    if (m_cmdInfo.m_profileLogThreads >= 0)
    {
        CRichViewProfile::WriteLogThreads(m_cmdInfo.m_profileLogThreads != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogThreads = CRichViewProfile::ReadLogThreads();
    }

    if (m_cmdInfo.m_profileUseThreadIndexes >= 0)
    {
        CRichViewProfile::WriteUseThreadIndexes(m_cmdInfo.m_profileUseThreadIndexes != 0);
    }
    else
    {
        m_cmdInfo.m_profileUseThreadIndexes = CRichViewProfile::ReadUseThreadIndexes();
    }

    if (m_cmdInfo.m_profileLogExceptions >= 0)
    {
        CRichViewProfile::WriteLogExceptions(m_cmdInfo.m_profileLogExceptions != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogExceptions = CRichViewProfile::ReadLogExceptions();
    }

    if (m_cmdInfo.m_profileLogDebugOutput >= 0)
    {
        CRichViewProfile::WriteLogDebugOutput(m_cmdInfo.m_profileLogDebugOutput != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogDebugOutput = CRichViewProfile::ReadLogDebugOutput();
    }

    if (m_cmdInfo.m_profileUseFullPaths >= 0)
    {
        CRichViewProfile::WriteUseFullPaths(m_cmdInfo.m_profileUseFullPaths != 0);
    }
    else
    {
        m_cmdInfo.m_profileUseFullPaths = CRichViewProfile::ReadUseFullPaths();
    }

    if (m_cmdInfo.m_profileLogTimeStamps >= 0)
    {
        CRichViewProfile::WriteLogTimeStamps(m_cmdInfo.m_profileLogTimeStamps != 0);
    }
    else
    {
        m_cmdInfo.m_profileLogTimeStamps = CRichViewProfile::ReadLogTimeStamps();
    }

    if (m_cmdInfo.m_profileChildren >= 0)
    {
        CRichViewProfile::WriteChildren(m_cmdInfo.m_profileChildren != 0);
    }
    else
    {
        m_cmdInfo.m_profileChildren = CRichViewProfile::ReadChildren();
    }
}

//******************************************************************************
void CMainApp::SaveCommandLineFile(CSession *pSession, CRichEditCtrl *pre)
{
    // Save the results to whatever formats the user requested.
    if (m_cmdInfo.m_pszDWI)
    {
        if (!CDocDepends::SaveSession(m_cmdInfo.m_pszDWI, ST_DWI, pSession, m_cmdInfo.m_fullPaths != 0,
                                      m_cmdInfo.m_undecorate != 0, m_cmdInfo.m_sortColumnModules,
                                      m_cmdInfo.m_sortColumnImports, m_cmdInfo.m_sortColumnExports, pre))
        {
            g_dwReturnFlags |= DWRF_WRITE_ERROR;
        }
        m_cmdInfo.m_pszDWI = NULL;
    }
    if (m_cmdInfo.m_pszTXT)
    {
        if (!CDocDepends::SaveSession(m_cmdInfo.m_pszTXT, ST_TXT, pSession, m_cmdInfo.m_fullPaths != 0,
                                      m_cmdInfo.m_undecorate != 0, m_cmdInfo.m_sortColumnModules,
                                      m_cmdInfo.m_sortColumnImports, m_cmdInfo.m_sortColumnExports, pre))
        {
            g_dwReturnFlags |= DWRF_WRITE_ERROR;
        }
        m_cmdInfo.m_pszTXT = NULL;
    }
    if (m_cmdInfo.m_pszTXT_IE)
    {
        if (!CDocDepends::SaveSession(m_cmdInfo.m_pszTXT_IE, ST_TXT_IE, pSession, m_cmdInfo.m_fullPaths != 0,
                                      m_cmdInfo.m_undecorate != 0, m_cmdInfo.m_sortColumnModules,
                                      m_cmdInfo.m_sortColumnImports, m_cmdInfo.m_sortColumnExports, pre))
        {
            g_dwReturnFlags |= DWRF_WRITE_ERROR;
        }
        m_cmdInfo.m_pszTXT_IE = NULL;
    }
    if (m_cmdInfo.m_pszCSV)
    {
        if (!CDocDepends::SaveSession(m_cmdInfo.m_pszCSV, ST_CSV, pSession, m_cmdInfo.m_fullPaths != 0,
                                      m_cmdInfo.m_undecorate != 0, m_cmdInfo.m_sortColumnModules,
                                      m_cmdInfo.m_sortColumnImports, m_cmdInfo.m_sortColumnExports, pre))
        {
            g_dwReturnFlags |= DWRF_WRITE_ERROR;
        }
        m_cmdInfo.m_pszCSV = NULL;
    }
}

//******************************************************************************
BOOL CMainApp::ProcessCommandLineInfo()
{
    // If we are in DDE mode, then just initialize our search order and bail.
    if (m_cmdInfo.m_nShellCommand == CCommandLineInfoEx::FileDDE)
    {
        m_psgDefault = CSearchGroup::CreateDefaultSearchOrder();
        return TRUE;
    }

    // If they specified a save file, make sure they specified an open file.
    if (m_cmdInfo.m_strError.IsEmpty() && m_cmdInfo.m_strFileName.IsEmpty() &&
        (m_cmdInfo.m_fConsoleMode || m_cmdInfo.m_pszDWI || m_cmdInfo.m_pszTXT || m_cmdInfo.m_pszTXT_IE || m_cmdInfo.m_pszCSV))
    {
        m_cmdInfo.m_strError = "You must specify a file to open when using the \"/c\", \"/od\", \"/ot\", \"/of\", and \"/oc\" options.";
    }

    // If they specified a save file, make sure they specified an open file.
    if (m_cmdInfo.m_strError.IsEmpty() && m_cmdInfo.m_strFileName.IsEmpty() &&
        (m_cmdInfo.m_fProfile || m_cmdInfo.m_pszProfileDirectory))
    {
        m_cmdInfo.m_strError = "You must specify a module to open when using the \"/pd\" and \"/pb\" options.";
    }

DISPLAY_ERROR:

    // Check for a command line error message.  If one exists, tell the user and
    // ask them if they wish to see help.
    if (!m_cmdInfo.m_strError.IsEmpty() && !m_cmdInfo.m_fHelp)
    {
        g_dwReturnFlags |= DWRF_COMMAND_LINE_ERROR;
        m_cmdInfo.m_strError += "\r\n\r\nWould you like to view help on the command line options?";
        if (MessageBox(NULL, m_cmdInfo.m_strError, "Dependency Walker Command Line Error",
                       MB_YESNO | MB_ICONERROR) != IDYES)
        {
            return FALSE;
        }
        m_cmdInfo.m_fHelp = true;
    }

    // Check to see if the user requested help.
    if (m_cmdInfo.m_fHelp)
    {
        g_dwReturnFlags |= DWRF_COMMAND_LINE_ERROR;

        // Make sure we have help files and that our help file path is correct.
        EnsureHelpFilesExists();

        // Since we do not have a main window, we call ::WinHelp directly and pass
        // it NULL as a parent.  This allows us to exit, but keeps help up.
        if (!::WinHelp(NULL, m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + IDR_COMMAND_LINE_HELP))
        {
            AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
        }
        return FALSE;
    }

    // Check to see if a search path file was specified.
    if (m_cmdInfo.m_pszDWP)
    {
        // Load this file.  LoadSearchOrder will display any errors that occur.
        if (!CSearchGroup::LoadSearchOrder(m_cmdInfo.m_pszDWP, m_psgDefault))
        {
            g_dwReturnFlags |= DWRF_COMMAND_LINE_ERROR;
            return FALSE;
        }
    }

    // Otherwise, we just create the default search order.
    else
    {
        m_psgDefault = CSearchGroup::CreateDefaultSearchOrder();
    }

    // Save any command line settings to the registry.
    SaveCommandLineSettings();

    // Check to see if we are running in console only mode.
    if (m_cmdInfo.m_fConsoleMode)
    {
        // Create a temporary Rich Edit control that we can use as a buffer.
        CCmdLineProfileData clpd;
         
        // Starting with VS/MFC 7.0 (_MFC_VER >= 0x0700) the rich edit control
        // overloads CreateEx and screws it up for us.  The code refuses to
        // allow a parentless rich edit control to be created.  So, we make
        // sure we call down to the CWnd base class.
        ((CWnd*)&clpd.m_re)->CreateEx(0, "RICHEDIT", "", ES_READONLY | ES_LEFT | ES_MULTILINE, CRect(0,0,100,100), NULL, 0);
        clpd.m_re.SendMessage(WM_SETFONT, (WPARAM)::GetStockObject(DEFAULT_GUI_FONT), 0);

        // Don't limit our rich edit view.  The docs for EM_EXLIMITTEXT say the
        // default size of a rich edit control is limited to 32,767 characters.
        // Dependency Walker 2.0 seemed to have no limitations at all, but DW 2.1
        // will truncate the profile logs of loaded DWIs to 32,767 characters.
        // However, we have no problems writing more than 32K characters to the
        // log with DW 2.1 during a live profile.  The docs for EM_EXLIMITTEXT
        // also say that it has no effect on the EM_STREAMIN functionality.  This
        // must be wrong, since when we call LimitText with something higher than
        // 32K, we can stream more characters in.
        clpd.m_re.SendMessage(EM_EXLIMITTEXT, 0, 0x7FFFFFFE);

        // Create a local session.
        CSession session(StaticProfileUpdate, (DWORD_PTR)&clpd);

        // Open the file for read.
        HANDLE hFile = CreateFile(m_cmdInfo.m_strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, // inspected
                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        DWORD         dwSignature = 0;
        CSearchGroup *psgSession = NULL;

        // Read the first DWORD of the file and see if it matches our DWI signature.
        if ((hFile != INVALID_HANDLE_VALUE) &&
            ReadBlock(hFile, &dwSignature, sizeof(dwSignature)) && (dwSignature == DWI_SIGNATURE))
        {
            if (m_cmdInfo.m_fProfile)
            {
                m_cmdInfo.m_strError = "The \"/pb\" option cannot be used when opening a Dependency Walker Image (DWI) file.";
                CloseHandle(hFile);
                goto DISPLAY_ERROR;
            }

            // Open the saved module session image.
            if (!session.ReadDwi(hFile, m_cmdInfo.m_strFileName))
            {
                CloseHandle(hFile);
                return FALSE;
            }

            // Store a pointer to our search group list so we can delete it later.
            psgSession = session.m_psgHead;

            // Read in the log contents
            CRichViewProfile::ReadFromFile(&clpd.m_re, hFile);

            // Close the file.
            CloseHandle(hFile);

            // Save the results to whatever output files were specified.
            SaveCommandLineFile(&session, &clpd.m_re);

            // If the file failed to open or is not a DWI file, then try to scan it.  All file errors
            // will be handled by the session, so we don't need to do anything here.
        }
        else
        {
            // Close the file if we opened it.,
            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);
            }

            // Create a search order for the command line module.
            psgSession = CSearchGroup::CopySearchOrder(m_psgDefault, m_cmdInfo.m_strFileName);

            // Do our passive scan.
            session.DoPassiveScan(m_cmdInfo.m_strFileName, psgSession);

            // If the user requested us to profile, then do that now.
            if (m_cmdInfo.m_fProfile)
            {
                // Build the flags based off of a mixture of command line args and registry settings.
                // For console mode, we don't ever set the ClearLog flag since the log is already clear,
                // or the ProfileChildren flag since it is useless to profile children since only
                // one session can be saved when running in console mode.
                DWORD dwFlags =
                (m_cmdInfo.m_profileSimulateShellExecute   ? PF_SIMULATE_SHELLEXECUTE    : 0) |
                (m_cmdInfo.m_profileLogDllMainProcessMsgs  ? PF_LOG_DLLMAIN_PROCESS_MSGS : 0) |
                (m_cmdInfo.m_profileLogDllMainOtherMsgs    ? PF_LOG_DLLMAIN_OTHER_MSGS   : 0) |
                (m_cmdInfo.m_profileHookProcess            ? PF_HOOK_PROCESS             : 0) |
                (m_cmdInfo.m_profileLogLoadLibraryCalls    ? PF_LOG_LOADLIBRARY_CALLS    : 0) |
                (m_cmdInfo.m_profileLogGetProcAddressCalls ? PF_LOG_GETPROCADDRESS_CALLS : 0) |
                (m_cmdInfo.m_profileLogThreads             ? PF_LOG_THREADS              : 0) |
                (m_cmdInfo.m_profileUseThreadIndexes       ? PF_USE_THREAD_INDEXES       : 0) |
                (m_cmdInfo.m_profileLogExceptions          ? PF_LOG_EXCEPTIONS           : 0) |
                (m_cmdInfo.m_profileLogDebugOutput         ? PF_LOG_DEBUG_OUTPUT         : 0) |
                (m_cmdInfo.m_profileUseFullPaths           ? PF_USE_FULL_PATHS           : 0) |
                (m_cmdInfo.m_profileLogTimeStamps          ? PF_LOG_TIME_STAMPS          : 0);

                // Profile the module.
                session.StartRuntimeProfile(m_cmdInfo.m_pszProfileArguments, m_cmdInfo.m_pszProfileDirectory, dwFlags);
            }

            // Save the results to whatever output files were specified.
            SaveCommandLineFile(&session, &clpd.m_re);
        }

        // Free any search order we created for this session.
        CSearchGroup::DeleteSearchOrder(psgSession);
        session.m_psgHead = NULL;

        // Return FALSE to prevent our UI from coming up.
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
/*static*/ void CMainApp::StaticProfileUpdate(DWORD_PTR dwpCookie, DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2)
{
    // We only care about log callbacks - bail out for anything else.
    if ((dwType != DWPU_LOG) || !dwpCookie || !dwpParam1)
    {
        return;
    }

    // Add the text to our rich edit control.
    CRichViewProfile::AddTextToRichEdit(
        &((CCmdLineProfileData*)dwpCookie)->m_re,
        (LPCSTR)dwpParam1, ((PDWPU_LOG_STRUCT)dwpParam2)->dwFlags,
        g_theApp.m_cmdInfo.m_profileLogTimeStamps != 0,
        &((CCmdLineProfileData*)dwpCookie)->m_fNewLine,
        &((CCmdLineProfileData*)dwpCookie)->m_cPrev,
        ((PDWPU_LOG_STRUCT)dwpParam2)->dwElapsed);
}

//******************************************************************************
void CMainApp::EnsureHelpFilesExists()
{
    // Make sure we have a depends.hlp file.
    CHAR szPath[DW_MAX_PATH];
    StrCCpy(szPath, m_pszHelpFilePath, sizeof(szPath));
    _strlwr(szPath);
    if (ExtractResourceFile(IDR_DEPENDS_HLP, "depends.hlp", szPath, countof(szPath)))
    {
        // For some reason, MFC does not use a CString for the help path, so if we
        // need to change the string, we need to free and reallocate a buffer.
        if (_stricmp(m_pszHelpFilePath, szPath))
        {
            BOOL bEnable = AfxEnableMemoryTracking(FALSE);
            free((void*)m_pszHelpFilePath);
            if (!(m_pszHelpFilePath = _tcsdup(szPath)))
            {
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            }
            AfxEnableMemoryTracking(bEnable);
        }
    }
    else
    {
        *szPath = '\0';
    }

    // Make sure we have a depends.cnt file in the same directory as depends.hlp.
    // ExtractResourceFile knows to strip the file name off path and append the
    // file name we specify.
    ExtractResourceFile(IDR_DEPENDS_CNT, "depends.cnt", szPath, countof(szPath));
}

//******************************************************************************
void CMainApp::WinHelp(DWORD_PTR dwData, UINT nCmd)
{
    // Make sure we have help files and that our help file path is correct.
    EnsureHelpFilesExists();

    // Regardless of the result above, we call our base WinHelp routine.
    // If all else fails, WinHelp will prompt the user for a path to the file.
    CWinApp::WinHelp(dwData, nCmd);
}


//******************************************************************************
// CMainApp :: Event handler functions
//******************************************************************************

void CMainApp::OnFileOpen()
{
    // We handle our own file open dialog because we want to use multiple file
    // extension filters and MFC currently only allows one filter per document
    // template.

    // Create the dialog.
    CNewFileDialog dlgFile(TRUE);

    dlgFile.GetOFN().nFilterIndex = 2;

    CHAR szPath[DW_MAX_PATH], szFilter[4096], *psz = szFilter;
    CString strExts, strFilter;
    *szPath = *szFilter = '\0';

    // Get the handled binary extensions.
    GetRegisteredExtensions(strExts);
    strExts.MakeLower();

    // Make sure we have at least one handled file type.
    if (strExts.GetLength() > 2)
    {
        dlgFile.GetOFN().nFilterIndex = 1;

        // Add the filter name.
        StrCCpy(psz, "Handled File Extensions", sizeof(szFilter) - (int)(psz - szFilter));
        psz += strlen(psz) + 1;

        bool fSC = false;

        // Even though we specify "exe" as our default extension, it appears that
        // if the user types in a file name without an extension, the dialog defaults
        // to checking for the first extension in our extension filter list.  So, if
        // exe is one of the extensions we are handling, then we make sure it is
        // first in the list since we would like to default to using it.
        if (strstr(strExts, ":exe:"))
        {
            StrCCpy(psz, "*.exe", sizeof(szFilter) - (int)(psz - szFilter));
            psz += strlen(psz);
            fSC = true;
        }

        // Loop through each of the file extensions.
        for (LPSTR pszExt = (LPSTR)(LPCSTR)strExts; pszExt[0] == ':'; )
        {
            // Locate the colon after the extension name.
            for (LPSTR pszEnd = pszExt + 1; *pszEnd && (*pszEnd != ':'); pszEnd++)
            {
            }
            if (!*pszEnd)
            {
                break;
            }

            // NULL out the second colon so we can isolate the extension.
            *pszEnd = '\0';

            // Add this extension to our list as long as it is not exe. If it is
            // exe, then we already added it.
            if (strcmp(pszExt + 1, "exe"))
            {
                // Copy the filespec to our filter.
                psz += SCPrintf(psz, sizeof(szFilter) - (int)(psz - szFilter), "%s*.%s", fSC ? ";" : "", pszExt + 1);
                fSC = true;
            }

            // Restore the colon.
            *pszEnd = ':';

            // Move pointer to next extension in our list.
            pszExt = pszEnd;
        }

        // Tack on the final null after the file specs.
        *psz++ = '\0';
    }

    // Add the "Dependency Walker Image" type to our filter.
    StrCCpy(psz, "Dependency Walker Image (*.dwi)", sizeof(szFilter) - (int)(psz - szFilter));
    psz += strlen(psz) + 1;
    StrCCpy(psz, "*.dwi", sizeof(szFilter) - (int)(psz - szFilter));
    psz += strlen(psz) + 1;

    // Add the "All Files" type to our filter.
    StrCCpy(psz, "All Files (*.*)", sizeof(szFilter) - (int)(psz - szFilter));
    psz += strlen(psz) + 1;
    StrCCpy(psz, "*", sizeof(szFilter) - (int)(psz - szFilter));
    psz += strlen(psz) + 1;
    *psz++ = '\0';

    // Initialize the dialog's members.
    dlgFile.GetOFN().lpstrFilter = szFilter;
    dlgFile.GetOFN().lpstrFile = szPath;
    dlgFile.GetOFN().nMaxFile = sizeof(szPath);
    dlgFile.GetOFN().lpstrDefExt = "exe";

    // Note: Don't use OFN_EXPLORER as it breaks us on NT 3.51
    dlgFile.GetOFN().Flags |= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_ENABLESIZING |
                              OFN_FORCESHOWHIDDEN | OFN_SHOWHELP | OFN_FILEMUSTEXIST | OFN_READONLY | OFN_DONTADDTORECENT;

    // Display the dialog and continue opening the file if dialog returns success.
    if (dlgFile.DoModal() == IDOK)
    {
        AfxGetApp()->OpenDocumentFile(szPath);
    }
}

//******************************************************************************
void CMainApp::OnConfigureSearchOrder()
{
    // Display the configure search order dialog.
    CDlgSearchOrder dlg(m_psgDefault);
    if (dlg.DoModal() == IDOK)
    {
        m_psgDefault = dlg.GetHead();
    }
}

//******************************************************************************
void CMainApp::OnUpdateAutoExpand(CCmdUI* pCmdUI)
{
    if (m_cmdInfo.m_autoExpand < 0)
    {
        m_cmdInfo.m_autoExpand = CDocDepends::ReadAutoExpandSetting();
    }
    pCmdUI->SetCheck(m_cmdInfo.m_autoExpand);
}

//******************************************************************************
void CMainApp::OnAutoExpand()
{
    CDocDepends::WriteAutoExpandSetting(m_cmdInfo.m_autoExpand = !m_cmdInfo.m_autoExpand);
}

//******************************************************************************
void CMainApp::OnUpdateViewFullPaths(CCmdUI* pCmdUI)
{
    if (m_cmdInfo.m_fullPaths < 0)
    {
        m_cmdInfo.m_fullPaths = CDocDepends::ReadFullPathsSetting();
    }
    pCmdUI->SetCheck(m_cmdInfo.m_fullPaths);
}

//******************************************************************************
void CMainApp::OnViewFullPaths()
{
    CDocDepends::WriteFullPathsSetting(m_cmdInfo.m_fullPaths = !m_cmdInfo.m_fullPaths);
}

//******************************************************************************
void CMainApp::OnUpdateViewUndecorated(CCmdUI* pCmdUI)
{
    if (m_cmdInfo.m_undecorate < 0)
    {
        m_cmdInfo.m_undecorate = CDocDepends::ReadUndecorateSetting();
    }

    // Enable the undecorated option is we were able to find the
    // UnDecorateSymbolName function in IMAGEHLP.DLL.
    pCmdUI->Enable(g_theApp.m_pfnUnDecorateSymbolName != NULL);

    // If the view undecorated option is enabled, then display a check mark next to
    // the menu item and show the toolbar button as depressed.
    pCmdUI->SetCheck(m_cmdInfo.m_undecorate && g_theApp.m_pfnUnDecorateSymbolName);
}

//******************************************************************************
void CMainApp::OnViewUndecorated()
{
    CDocDepends::WriteUndecorateSetting(m_cmdInfo.m_undecorate = !m_cmdInfo.m_undecorate);
}

//******************************************************************************
void CMainApp::OnViewSysInfo()
{
    CDlgSysInfo dlgSysInfo;
    dlgSysInfo.DoModal();
}

//******************************************************************************
void CMainApp::OnConfigureExternalViewer()
{
    // Display the configure external viewer dialog.
    m_dlgViewer.DoModal();
}

//******************************************************************************
void CMainApp::OnConfigureExternalHelp() 
{
    // Make sure we have a CMsdnHelp object - we always should.
    if (m_pMsdnHelp)
    {
        // Display the configure help collections dialog.
        CDlgExternalHelp dlgExternalHelp;
        dlgExternalHelp.DoModal();
    }
}

//******************************************************************************
void CMainApp::OnHandledFileExts()
{
    CDlgExtensions dlgExtensions;
    dlgExtensions.DoModal();
}

//******************************************************************************
void CMainApp::OnAppAbout()
{
    // Display the about dialog.
    CDlgAbout aboutDlg;
    aboutDlg.DoModal();
}


//******************************************************************************
//***** CCommandLineInfoEx
//******************************************************************************

CCommandLineInfoEx::CCommandLineInfoEx() :
    CCommandLineInfo(),
    m_expecting(OPEN_FILE),
    m_cFlag('/'),
    m_pszFlag(NULL),
    m_maxColumn(0),
    m_fHelp(false),
    m_autoExpand(-1),
    m_fullPaths(-1),
    m_undecorate(-1),
    m_sortColumnModules(-1),
    m_sortColumnImports(-1),
    m_sortColumnExports(-1),
    m_fConsoleMode(false),
    m_fProfile(false),
    m_profileSimulateShellExecute(-1),
    m_profileLogDllMainProcessMsgs(-1),
    m_profileLogDllMainOtherMsgs(-1),
    m_profileHookProcess(-1),
    m_profileLogLoadLibraryCalls(-1),
    m_profileLogGetProcAddressCalls(-1),
    m_profileLogThreads(-1),
    m_profileUseThreadIndexes(-1),
    m_profileLogExceptions(-1),
    m_profileLogDebugOutput(-1),
    m_profileUseFullPaths(-1),
    m_profileLogTimeStamps(-1),
    m_profileChildren(-1),
    m_pszProfileArguments(NULL),
    m_pszProfileDirectory(NULL),
    m_pszDWI(NULL),
    m_pszTXT(NULL),
    m_pszTXT_IE(NULL),
    m_pszCSV(NULL),
    m_pszDWP(NULL)
{
}

//******************************************************************************
void CCommandLineInfoEx::ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast)
{
    // Arguments
    //    /?              help
    //    /c              console mode only - no gui
    //    /f:0  or /f:1   full paths
    //    /u:0  or /u:1   undecorate
    //    /ps:0 or /ps:1  Simulate ShellExecute by inserting any App Paths directories into the PATH environment variable.
    //    /pp:0 or /pp:1  Log DllMain calls for process attach and process detach messages.
    //    /po:0 or /po:1  Log DllMain calls for all other messages, including thread attach and thread detach.
    //    /ph:0 or /ph:1  Hook the process to gather more detailed dependency information.
    //    /pl:0 or /pl:1  Log LoadLibrary function calls.
    //    /pg:0 or /pg:1  Log GetProcAddress function calls.
    //    /pt:0 or /pt:1  Log thread information.
    //    /pn:0 or /pn:1  Use simple thread numbers instead of actual thread IDs.
    //    /pe:0 or /pe:1  Log first chance exceptions.
    //    /pm:0 or /pm:1  Log debug output messages.
    //    /pf:0 or /pf:1  Use full paths when logging file names.
    //    /pc:0 or /pc:1  Automatically open and profile child processes. Ignored when running in console mode.
    //    /pa:0 or /pa:1  Set all profile options.
    //    /pb             Begin profiling after module is loaded.
    //    /pd:directory   Starting directory for profiling.
    //    /sm:1           module list sort column
    //    /si:1           import function list sort column
    //    /se:1           export function list sort column
    //    /sf:1           import/export function list sort column
    //    /od:foo.dwi     DWI file to save to
    //    /ot:foo.txt     TXT file to save to (without import/export functions)
    //    /of:foo.txt     TXT file to save to (with import/export functions)
    //    /oc:foo.csv     CSV file to save to
    //    /d:foo.dwp      Search Path file to load and use.
    //    /dde            For DDE - cannot be used with any other args.

    if (m_expecting == PROFILE_ARGS)
    {
        if (!m_pszProfileArguments)
        {
            m_pszProfileArguments = GetRemainder(bFlag ? (pszParam - 1) : pszParam);
        }
        return;
    }

    // If we see a question mark anywhere in this option, set the help flag to true.
    if (bFlag && pszParam && strchr(pszParam, '?'))
    {
        m_fHelp = true;
    }

    // We stop parsing if help is requested or an error has occurred.
    if (m_fHelp || !m_strError.IsEmpty())
    {
        return;
    }

    if (bFlag)
    {
        // Store the flag character the user used so we can use it in error messages.
        if (pszParam)
        {
            m_cFlag = *(pszParam - 1);
        }

        // Make sure we are not expecting something other than a flag or a file name
        switch (m_expecting)
        {
            case AUTO_EXPAND:
            case FULL_PATH:
            case UNDECORATE:
                m_strError.Format("You must specify \"%c%c:0\" or \"%c%c:1\" when using the \"%c%c\" option.",
                                  m_cFlag, *m_pszFlag, m_cFlag, *m_pszFlag, m_cFlag, *m_pszFlag);
                return;

            case PA_VALUE:
            case PC_VALUE:
            case PE_VALUE:
            case PF_VALUE:
            case PG_VALUE:
            case PH_VALUE:
            case PI_VALUE:
            case PL_VALUE:
            case PM_VALUE:
            case PN_VALUE:
            case PO_VALUE:
            case PP_VALUE:
            case PS_VALUE:
            case PT_VALUE:
                m_strError.Format("You must specify \"%c%.2s:0\" or \"%c%.2s:1\" when using the \"%c%.2s\" option.",
                                  m_cFlag, m_pszFlag, m_cFlag, m_pszFlag, m_cFlag, m_pszFlag);
                return;

            case PD_VALUE:
                m_strError.Format("You must specify a directory with the \"%c%.2s\" profiling option.", m_cFlag, m_pszFlag);
                return;

            case MODULE_COLUMN:
            case IMPORT_COLUMN:
            case EXPORT_COLUMN:
            case FUNCTION_COLUMN:
                m_strError.Format("You must specify a value between 1 and %u when using the \"%c%.2s\" option.", m_maxColumn, m_cFlag, m_pszFlag);
                return;

            case DWI_FILE:
            case TXT_FILE:
            case TXT_IE_FILE:
            case CSV_FILE:
                m_strError.Format("You must specify an output file with the \"%c%.2s\" option.", m_cFlag, m_pszFlag);
                return;

            case DWP_FILE:
                m_strError.Format("You must specify a search path file (DWP) with the \"%c%c\" option.", m_cFlag, *m_pszFlag);
                return;
        }

        // Out of all the built in MFC flags, we only allow the dde flag to be processed.
        if (strcmp(pszParam, "dde") == 0)
        {
            ParseParamFlag(pszParam);
            return;
        }

        while (*pszParam)
        {
            // Make note of where this flag starts.
            m_pszFlag = pszParam;

            // Check for help flag.
            if (*pszParam == '?')
            {
                m_fHelp = true;
                pszParam++;
            }

            // Check for console mode flag.
            else if ((*pszParam == 'c') || (*pszParam == 'C'))
            {
                m_fConsoleMode = true;
                pszParam++;
            }

            // Check for auto-expand flag.
            else if ((*pszParam == 'a') || (*pszParam == 'A'))
            {
                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                m_expecting = AUTO_EXPAND;
                break;
            }

            // Check for full path flag.
            else if ((*pszParam == 'f') || (*pszParam == 'F'))
            {
                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                m_expecting = FULL_PATH;
                break;

            }

            // Check for undecorate flag.
            else if ((*pszParam == 'u') || (*pszParam == 'U'))
            {
                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                m_expecting = UNDECORATE;
                break;

            }

            // Check for one of the sort column flags.
            else if ((*pszParam == 's') || (*pszParam == 'S'))
            {
                pszParam++;

                if (!*pszParam)
                {
                    m_strError.Format("You must specify a 'm', 'i', 'e', or 'f' along with the \"%c%c\" option.", m_cFlag, *m_pszFlag);
                    return;
                }

                // Check for the module sort column flag.
                else if ((*pszParam == 'm') || (*pszParam == 'M'))
                {
                    m_maxColumn = LVMC_COUNT;
                    m_expecting = MODULE_COLUMN;
                }

                // Check for the import sort column flag.
                else if ((*pszParam == 'i') || (*pszParam == 'I'))
                {
                    m_maxColumn = LVFC_COUNT;
                    m_expecting = IMPORT_COLUMN;
                }

                // Check for the export sort column flag.
                else if ((*pszParam == 'e') || (*pszParam == 'E'))
                {
                    m_maxColumn = LVFC_COUNT;
                    m_expecting = EXPORT_COLUMN;
                }

                // Check for the function (import and export) sort column flag.
                else if ((*pszParam == 'f') || (*pszParam == 'F'))
                {
                    m_maxColumn = LVFC_COUNT;
                    m_expecting = FUNCTION_COLUMN;
                }

                // Unknown sort column flag
                else
                {
                    m_strError.Format("Unknown sort column option \"%c%.2s\".", m_cFlag, m_pszFlag);
                    return;
                }

                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                break;
            }

            // Check for one of the output flags.
            else if ((*pszParam == 'o') || (*pszParam == 'O'))
            {
                pszParam++;

                if (!*pszParam)
                {
                    m_strError.Format("You must specify a 'd', 't', 'f', or 'c' along with the \"%c%c\" option.", m_cFlag, *m_pszFlag);
                    return;
                }

                // Check for the DWI output flag.
                else if ((*pszParam == 'd') || (*pszParam == 'D'))
                {
                    if (m_pszDWI)
                    {
                        m_strError.Format("Duplicate option \"%c%.2s\". You may only specify this option once.", m_cFlag, m_pszFlag);
                        return;
                    }
                    m_expecting = DWI_FILE;
                }

                // Check for the TXT output flag.
                else if ((*pszParam == 't') || (*pszParam == 'T'))
                {
                    if (m_pszTXT)
                    {
                        m_strError.Format("Duplicate option \"%c%.2s\". You may only specify this option once.", m_cFlag, m_pszFlag);
                        return;
                    }
                    m_expecting = TXT_FILE;
                }

                // Check for the TXT_IE output flag.
                else if ((*pszParam == 'f') || (*pszParam == 'F'))
                {
                    if (m_pszTXT_IE)
                    {
                        m_strError.Format("Duplicate option \"%c%.2s\". You may only specify this option once.", m_cFlag, m_pszFlag);
                        return;
                    }
                    m_expecting = TXT_IE_FILE;
                }

                // Check for the CSV output flag.
                else if ((*pszParam == 'c') || (*pszParam == 'C'))
                {
                    if (m_pszCSV)
                    {
                        m_strError.Format("Duplicate option \"%c%.2s\". You may only specify this option once.", m_cFlag, m_pszFlag);
                        return;
                    }
                    m_expecting = CSV_FILE;
                }

                // Unknown output flag
                else
                {
                    m_strError.Format("Unknown output file option \"%c%.2s\".", m_cFlag, m_pszFlag);
                    return;
                }

                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                break;
            }

            // Check for one of the profile flags.
            else if ((*pszParam == 'p') || (*pszParam == 'P'))
            {
                pszParam++;

                // we special case the "/pb" option.
                if ((*pszParam == 'b') || (*pszParam == 'B'))
                {
                    m_fProfile = true;
                    pszParam++;
                }
                else
                {
                    switch (*pszParam)
                    {
                        case 'a': case 'A': m_expecting = PA_VALUE; break;
                        case 'c': case 'C': m_expecting = PC_VALUE; break;
                        case 'd': case 'D': m_expecting = PD_VALUE; break;
                        case 'e': case 'E': m_expecting = PE_VALUE; break;
                        case 'f': case 'F': m_expecting = PF_VALUE; break;
                        case 'g': case 'G': m_expecting = PG_VALUE; break;
                        case 'h': case 'H': m_expecting = PH_VALUE; break;
                        case 'i': case 'I': m_expecting = PI_VALUE; break;
                        case 'l': case 'L': m_expecting = PL_VALUE; break;
                        case 'm': case 'M': m_expecting = PM_VALUE; break;
                        case 'n': case 'N': m_expecting = PN_VALUE; break;
                        case 'o': case 'O': m_expecting = PO_VALUE; break;
                        case 'p': case 'P': m_expecting = PP_VALUE; break;
                        case 's': case 'S': m_expecting = PS_VALUE; break;
                        case 't': case 'T': m_expecting = PT_VALUE; break;

                        // Make sure a character follows the 'p'.
                        case '\0':
                            m_strError.Format("You must specify an 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'l', 'm', 'n', 'o', 'p', 'r', 's', or 't' along with the \"%c%c\" option.", m_cFlag, *m_pszFlag);
                            return;

                        // Unknown output flag
                        default:
                            m_strError.Format("Unknown profile option \"%c%.2s\".", m_cFlag, m_pszFlag);
                            return;
                    }

                    // Skip over an optional column
                    if (*(++pszParam) == ':')
                    {
                        pszParam++;
                    }

                    // Bail from loop.
                    break;
                }
            }

            // Check for a DWP file flag.
            else if ((*pszParam == 'd') || (*pszParam == 'D'))
            {
                // Skip over an optional column
                if (*(++pszParam) == ':')
                {
                    pszParam++;
                }

                // Bail from loop.
                m_expecting = DWP_FILE;
                break;
            }

            // That's all the args we know how to handle, so this must be a bad arg.
            else
            {
                m_strError.Format("Unknown option \"%c%.1s\".", m_cFlag, m_pszFlag);
                return;
            }
        }
    }

    // Make sure we have some text to parse.
    if (!*pszParam)
    {
        // If we reached the end, but were still expecting another arg, then
        // call ourself again to generate an error message.
        if ((bLast) && (m_expecting != OPEN_FILE))
        {
            ParseParam(NULL, TRUE, TRUE);
        }
        return;
    }

    switch (m_expecting)
    {
        case OPEN_FILE:
            
            // We should never have a file name already.
            if (!m_strFileName.IsEmpty())
            {
                m_strError.Format("Invalid argument \"%s\". Only one file to be opened can be specified.", pszParam);
                return;
            }

            // Expand the file name to a full path and store it.
            DWORD dwLength;
            LPSTR pszFile;
            dwLength = GetFullPathName(pszParam, DW_MAX_PATH, m_strFileName.GetBuffer(DW_MAX_PATH), &pszFile);
            m_strFileName.ReleaseBuffer();
            if (!dwLength || (dwLength > DW_MAX_PATH))
            {
                m_strFileName = pszParam;
            }

            if ((m_nShellCommand == FileNothing) || (m_nShellCommand == FileNew))
            {
                m_nShellCommand = FileOpen;
            }

            // Everything after the file name is command line args.
            m_expecting = PROFILE_ARGS;
            return;

        case AUTO_EXPAND:
        case FULL_PATH:
        case UNDECORATE:
        case PA_VALUE:
        case PC_VALUE:
        case PE_VALUE:
        case PF_VALUE:
        case PG_VALUE:
        case PH_VALUE:
        case PI_VALUE:
        case PL_VALUE:
        case PM_VALUE:
        case PN_VALUE:
        case PO_VALUE:
        case PP_VALUE:
        case PS_VALUE:
        case PT_VALUE:
        {
            // Make sure the character is a 0 or 1.
            if ((*pszParam != '0') && (*pszParam != '1'))
            {
                // This will generate an error message.
                ParseParam(NULL, TRUE, TRUE);
                return;
            }

            int result = (*pszParam == '1');

            switch (m_expecting)
            {
                case AUTO_EXPAND:
                    m_autoExpand = result;
                    break;

                case FULL_PATH:
                    m_fullPaths = result;
                    break;

                case UNDECORATE:
                    m_undecorate = result;
                    break;

                case PS_VALUE:
                    m_profileSimulateShellExecute = result;
                    break;

                case PP_VALUE:
                    m_profileLogDllMainProcessMsgs = result;
                    break;

                case PO_VALUE:
                    m_profileLogDllMainOtherMsgs = result;
                    break;

                case PH_VALUE:
                    m_profileHookProcess = result;
                    break;

                case PL_VALUE:
                    if (m_profileLogLoadLibraryCalls = result)
                    {
                        m_profileHookProcess = 1;
                    }
                    break;

                case PG_VALUE:
                    if (m_profileLogGetProcAddressCalls = result)
                    {
                        m_profileHookProcess = 1;
                    }
                    break;

                case PT_VALUE:
                    m_profileLogThreads = result;
                    break;

                case PN_VALUE:
                    if (m_profileUseThreadIndexes = result)
                    {
                        m_profileLogThreads = 1;
                    }
                    break;

                case PE_VALUE:
                    m_profileLogExceptions = result;
                    break;

                case PM_VALUE:
                    m_profileLogDebugOutput = result;
                    break;

                case PF_VALUE:
                    m_profileUseFullPaths = result;
                    break;

                case PI_VALUE:
                    m_profileLogTimeStamps = result;
                    break;

                case PC_VALUE:
                    m_profileChildren = result;
                    break;

                case PA_VALUE:
                    m_profileSimulateShellExecute   = result;
                    m_profileLogDllMainProcessMsgs  = result;
                    m_profileLogDllMainOtherMsgs    = result;
                    m_profileHookProcess            = result;
                    m_profileLogLoadLibraryCalls    = result;
                    m_profileLogGetProcAddressCalls = result;
                    m_profileLogThreads             = result;
                    m_profileUseThreadIndexes       = result;
                    m_profileLogExceptions          = result;
                    m_profileLogDebugOutput         = result;
                    m_profileUseFullPaths           = result;
                    m_profileLogTimeStamps          = result;
                    m_profileChildren               = result;
                    break;
            }

            // If we have characters after the value, parse them as flags.
            if (*(++pszParam))
            {
                m_expecting = OPEN_FILE;
                *((char*)pszParam - 1) = m_cFlag;
                ParseParam(pszParam, TRUE, bLast);
                return;
            }
            break;
        }

        case PD_VALUE:
            m_pszProfileDirectory = pszParam;
            break;

        case MODULE_COLUMN:
        case IMPORT_COLUMN:
        case EXPORT_COLUMN:
        case FUNCTION_COLUMN:
        {
            // Make sure the first character is a digit.
            if (!isdigit(*pszParam))
            {
                // This will generate an error message.
                ParseParam(NULL, TRUE, TRUE);
                return;
            }

            // Get the number.
            LPSTR pEnd = NULL;
            ULONG ul = strtoul(pszParam, &pEnd, 0);

            // Check for errors.
            if ((ul < 1) || (ul > (ULONG)m_maxColumn))
            {
                // This will generate an error message.
                ParseParam(NULL, TRUE, TRUE);
                return;
            }

            // Store the value.
            if (m_expecting == MODULE_COLUMN)
            {
                m_sortColumnModules = (int)ul - 1;
            }
            else if (m_expecting == IMPORT_COLUMN)
            {
                m_sortColumnImports = (int)ul - 1;
            }
            else if (m_expecting == EXPORT_COLUMN)
            {
                m_sortColumnExports = (int)ul - 1;
            }
            else
            {
                m_sortColumnImports = (int)ul - 1;
                m_sortColumnExports = (int)ul - 1;
            }

            // If we have characters after the value, parse them as flags.
            if (pEnd && *pEnd)
            {
                m_expecting = OPEN_FILE;
                *(pEnd - 1) = m_cFlag;
                ParseParam(pEnd, TRUE, bLast);
                return;
            }
            break;
        }

        case DWI_FILE:
            m_pszDWI = pszParam;
            break;

        case TXT_FILE:
            m_pszTXT = pszParam;
            break;

        case TXT_IE_FILE:
            m_pszTXT_IE = pszParam;
            break;

        case CSV_FILE:
            m_pszCSV = pszParam;
            break;

        case DWP_FILE:
            m_pszDWP = pszParam;
            break;
    }

    m_expecting = OPEN_FILE;
}

//******************************************************************************
LPCSTR CCommandLineInfoEx::GetRemainder(LPCSTR pszCurArgv)
{
    // Look for this argument in our argument list.
    for (int i = 1; (i < __argc) && (pszCurArgv != __targv[i]); i++)
    {
    }

    // Make sure we found an argument and have a command line.
    LPCSTR pszCmdLine;
    if ((i > __argc) || !(pszCmdLine = GetCommandLine()))
    {
        return NULL;
    }

    // Locate the end of the raw command line string.
    LPCSTR pszCur = pszCmdLine + strlen(pszCmdLine);

    // Walk backwards through the our argv list searching for each in the
    // in the raw command line string.
    for (int j = __argc - 1; j >= i; j--)
    {
        // Since the argc/argv parser in the C runtime converts backslash-quote
        // combos in to just a quote, we need to convert them back before
        // searching the raw command line string.
        CString strArg = __argv[j];
        strArg.Replace("\"", "\\\"");

        // Locate the last occurance of this string in our raw command line string.
        LPCSTR pszFind = pszCmdLine, pszLast = NULL;
        while ((pszFind = strstr(pszFind + 1, strArg)) && (pszFind < pszCur))
        {
            pszLast = pszFind;
        }

        // Make sure we found a match.
        if (!pszLast)
        {
            return NULL;
        }

        // Walk back to the beginning of the arg (in case there is a quote before it)
        pszCur = pszLast;
        while ((pszCur > pszCmdLine) && !isspace(*(pszCur - 1)))
        {
            pszCur--;
        }
    }

    return pszCur;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\dialogs.h ===
//******************************************************************************
//
// File:        DIALOGS.H
//
// Description: Definition file for all our CDialog and CFileDialog derived
//              classes.
//
// Classes:     CSizer
//              CNewFileDialog
//              CSaveDialog
//              CDlgViewer
//              CDlgExternalHelp
//              CDlgProfile
//              CDlgSysInfo
//              CDlgExtensions
//              CDlgFileSearch
//              CDlgSearchOrder
//              CDlgAbout
//              CDlgShutdown
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __DIALOGS_H__
#define __DIALOGS_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//****** Forward Declarations
//******************************************************************************

class CDocDepends;


//******************************************************************************
//****** CSizer
//******************************************************************************

class CSizer : public CScrollBar
{
public:
    BOOL Create(CWnd *pParent);
    void Update();

public:
    //{{AFX_VIRTUAL(CSizer)
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CSizer)
    afx_msg UINT OnNcHitTest(CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CNewFileDialog
//******************************************************************************

#ifdef USE_CNewFileDialog
class CNewFileDialog : public CFileDialog
{
public:
    bool m_fNewStyle;
    OPENFILENAME *m_pofn;

    CNewFileDialog(BOOL bOpenFileDialog,
                   LPCTSTR lpszDefExt = NULL,
                   LPCTSTR lpszFileName = NULL,
                   DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
                   LPCTSTR lpszFilter = NULL,
                   CWnd* pParentWnd = NULL) :
        CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, pParentWnd),
        m_fNewStyle(false),
        m_pofn((OPENFILENAME*)&m_ofn) // Razzle cast
    {
    }
    inline OPENFILENAME& GetOFN() { return *m_pofn; }
    virtual INT_PTR DoModal();
};
#else
#define CNewFileDialog CFileDialog
#define m_fNewStyle true
#endif


//******************************************************************************
//****** CSaveDialog
//******************************************************************************

class CSaveDialog : public CNewFileDialog
{
    DECLARE_DYNAMIC(CSaveDialog)

public:
    CSaveDialog();

protected:
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

protected:
    //{{AFX_MSG(CSaveDialog)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgViewer
//******************************************************************************

class CDlgViewer : public CDialog
{
// Public variables
public:
    //{{AFX_DATA(CDlgViewer)
    enum { IDD = IDD_CONFIGURE_VIEWER };
    CString m_strCommand;
    CString m_strArguments;
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgViewer(CWnd* pParent = NULL);

// Public functions
public:
    void Initialize();
    BOOL LaunchExternalViewer(LPCSTR pszPath);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgViewer)
    protected:
    virtual void DoDataExchange(CDataExchange *pDX);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgViewer)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgExternalHelp
//******************************************************************************

class CDlgExternalHelp : public CDialog
{
// Public variables
public:
    //{{AFX_DATA(CDlgExternalHelp)
    enum { IDD = IDD_CONFIGURE_EXTERNAL_HELP };
    CButton m_butOK;
    CListCtrl   m_listCollections;
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgExternalHelp(CWnd* pParent = NULL);   // standard constructor

// Protected functions
protected:
    void PopulateCollectionList();

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgExternalHelp)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgExternalHelp)
    virtual BOOL OnInitDialog();
    afx_msg void OnMsdn();
    afx_msg void OnOnline();
    afx_msg void OnItemChangedCollections(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeUrl();
    afx_msg void OnRefresh();
    afx_msg void OnDefaultUrl();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgProfile
//******************************************************************************

class CDlgProfile : public CDialog
{
// Public variables
public:
    //{{AFX_DATA(CDlgProfile)
    enum { IDD = IDD_PROFILE };
    //}}AFX_DATA
    CDocDepends *m_pDocDepends;

// Constructor/Destructor
public:
    CDlgProfile(CDocDepends *pDocDepends, CWnd* pParent = NULL);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgProfile)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgProfile)
    virtual BOOL OnInitDialog();
    afx_msg void OnHookProcess();
    afx_msg void OnLogThreads();
    virtual void OnOK();
    afx_msg void OnDefault();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgSysInfo
//******************************************************************************

class CDlgSysInfo : public CDialog
{
// Private variables
protected:
    SYSINFO   *m_pSI;
    LPCSTR     m_pszTitle;
    bool       m_fInitialized;
    CSize      m_sPadding;
    CSize      m_sButton;
    int        m_cyButtonPadding;
    CPoint     m_ptMinTrackSize;
    CSizer     m_Sizer;

// Public variables
public:
    //{{AFX_DATA(CDlgSysInfo)
    enum { IDD = IDD_SYS_INFO };
    CRichEditCtrl m_reInfo;
    CButton       m_butOk;
    CButton       m_butRefresh;
    CButton       m_butSelectAll;
    CButton       m_butCopy;
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgSysInfo(SYSINFO *pSI = NULL, LPCSTR pszDWI = NULL);

protected:
    bool SysInfoCallback(LPCSTR pszField, LPCSTR pszValue);
    static bool CALLBACK StaticSysInfoCallback(LPARAM lParam, LPCSTR pszField, LPCSTR pszValue)
    {
        return ((CDlgSysInfo*)lParam)->SysInfoCallback(pszField, pszValue);
    }

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgSysInfo)
protected:
    virtual void DoDataExchange(CDataExchange *pDX);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgSysInfo)
    virtual BOOL OnInitDialog();
    afx_msg void OnInitMenu(CMenu* pMenu);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnRefresh();
    afx_msg void OnSelectAll();
    afx_msg void OnCopy();
    afx_msg void OnSelChangeRichEdit(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgExtensions
//******************************************************************************

class CDlgExtensions : public CDialog
{
// Private variables
protected:

// Public variables
public:
    //{{AFX_DATA(CDlgExtensions)
    enum { IDD = IDD_EXTENSIONS };
    CListBox m_listExts;
    CEdit    m_editExt;
    CButton  m_butAdd;
    CButton  m_butRemove;
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgExtensions(CWnd* pParent = NULL);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgExtensions)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgExtensions)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelChangeExts();
    afx_msg void OnUpdateExt();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    afx_msg void OnSearch();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgFileSearch
//******************************************************************************

class CDlgFileSearch : public CDialog
{
// Public variables
public:
    CString          m_strExts;

// Private variables
protected:
    BOOL             m_fAbort;
    int              m_result;
    CWinThread      *m_pWinThread;
    DWORD            m_dwDrives;
    CHAR             m_szPath[DW_MAX_PATH];
    WIN32_FIND_DATA  m_w32fd;

// Public variables
public:
    //{{AFX_DATA(CDlgFileSearch)
    enum { IDD = IDD_FILE_SEARCH };
    CListBox m_listExts;
    CListBox m_listDrives;
    CButton  m_butStop;
    CButton  m_butSearch;
    CAnimateCtrl   m_animate;
    CButton  m_butOk;
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgFileSearch(CWnd* pParent = NULL);

protected:
    DWORD Thread();
    static UINT AFX_CDECL StaticThread(LPVOID lpvThis)
    {
        __try
        {
            return ((CDlgFileSearch*)lpvThis)->Thread();
        }
        __except (ExceptionFilter(_exception_code(), false))
        {
        }
        return 0;
    }

    void RecurseDirectory();
    void ProcessFile();

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgFileSearch)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgFileSearch)
    afx_msg LONG OnMainThreadCallback(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnInitDialog();
    afx_msg void OnSelChangeDrives();
    afx_msg void OnSelChangeExts();
    afx_msg void OnSearch();
    afx_msg void OnStop();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgSearchOrder
//******************************************************************************

class CDlgSearchOrder : public CDialog
{
protected:
    bool          m_fInitialized;
    bool          m_fReadOnly;
    bool          m_fExpanded;
    bool          m_fInOnExpand;
    LPCSTR        m_pszApp;
    LPCSTR        m_pszTitle;
    CSearchGroup *m_psgHead;
    CSize         m_sPadding;
    CSize         m_sButton;
    int           m_cyStatic;
    int           m_cyButtonPadding;
    int           m_cxAddRemove;
    int           m_cxAddDirectory;
    CPoint        m_ptMinTrackSize;
    CSizer        m_Sizer;

public:
    CDlgSearchOrder(CSearchGroup *psgHead, bool fReadOnly = false, LPCSTR pszApp = NULL, LPCSTR pszTitle = NULL);
    ~CDlgSearchOrder();
    inline CSearchGroup* GetHead() { return m_psgHead; }

protected:
    HTREEITEM AddSearchGroup(CTreeCtrl *pTC, CSearchGroup *pSG, HTREEITEM htiPrev = TVI_LAST);
    HTREEITEM GetSelectedGroup(CTreeCtrl *pTC);
    HTREEITEM MoveGroup(CTreeCtrl *ptcSrc, CTreeCtrl *ptcDst, HTREEITEM hti = NULL, HTREEITEM htiPrev = TVI_LAST);
    void      Reorder(CSearchGroup *psgHead);

    //{{AFX_DATA(CDlgSearchOrder)
    enum { IDD = IDD_SEARCH_ORDER };
    CStatic   m_staticAvailable;
    CTreeCtrl m_treeAvailable;
    CButton   m_butAdd;
    CButton   m_butRemove;
    CStatic   m_staticCurrent;
    CTreeCtrl m_treeCurrent;
    CButton   m_butAddDirectory;
    CEdit     m_editDirectory;
    CButton   m_butBrowse;
    CButton   m_butOk;
    CButton   m_butCancel;
    CButton   m_butExpand;
    CButton   m_butMoveUp;
    CButton   m_butMoveDown;
    CButton   m_butLoad;
    CButton   m_butSave;
    CButton   m_butDefault;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CDlgSearchOrder)
public:
    virtual BOOL DestroyWindow();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CDlgSearchOrder)
    virtual BOOL OnInitDialog();
    afx_msg void OnInitMenu(CMenu* pMenu);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    afx_msg void OnMoveUp();
    afx_msg void OnMoveDown();
    afx_msg void OnBrowse();
    afx_msg void OnAddDirectory();
    afx_msg void OnDefault();
    virtual void OnOK();
    afx_msg void OnChangeDirectory();
    afx_msg void OnSelChangedAvailable(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelChangedCurrent(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnExpand();
    afx_msg void OnLoad();
    afx_msg void OnSave();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgAbout
//******************************************************************************

class CDlgAbout : public CDialog
{
// Public variables
public:
    //{{AFX_DATA(CDlgAbout)
    enum { IDD = IDD_ABOUT };
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgAbout(CWnd* pParent = NULL);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgAbout)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgAbout)
    virtual BOOL OnInitDialog();
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//****** CDlgShutdown
//******************************************************************************

class CDlgShutdown : public CDialog
{
// Private variables
protected:
    int m_cTimerMessages;

// Public variables
public:
    //{{AFX_DATA(CDlgShutdown)
    enum { IDD = IDD_SHUTDOWN };
    //}}AFX_DATA

// Constructor/Destructor
public:
    CDlgShutdown(CWnd* pParent = NULL);   // standard constructor

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDlgShutdown)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDlgShutdown)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnClose();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __DIALOGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\dialogs.cpp ===
//******************************************************************************
//
// File:        DIALOGS.CPP
//
// Description: Implementation file for all our CDialog and CFileDialog derived
//              classes.
//
// Classes:     CSizer
//              CNewFileDialog
//              CSaveDialog
//              CDlgViewer
//              CDlgExternalHelp
//              CDlgProfile
//              CDlgSysInfo
//              CDlgExtensions
//              CDlgFileSearch
//              CDlgSearchOrder
//              CDlgAbout
//              CDlgShutdown
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "search.h"
#include "dbgthread.h"
#include "session.h"
#include "msdnhelp.h"
#include "document.h"
#include "profview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//****** Constants
//******************************************************************************

// File Search Flags
#define FSF_START_DRIVE  1
#define FSF_STOP_DRIVE   2
#define FSF_ADD_EXT      3
#define FSF_SEARCH_DONE  4

#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

#ifdef USE_CNewFileDialog
#ifndef OPENFILENAME_SIZE_VERSION_400
#define OPENFILENAME_SIZE_VERSION_400  CDSIZEOF_STRUCT(OPENFILENAME_NEW,lpTemplateName)
#endif
#endif


//******************************************************************************
//***** Types and Structures
//******************************************************************************

#ifdef USE_CNewFileDialog
typedef struct _OPENFILENAME_NEW
{
    DWORD         lStructSize;
    HWND          hwndOwner;
    HINSTANCE     hInstance;
    LPCSTR        lpstrFilter;
    LPSTR         lpstrCustomFilter;
    DWORD         nMaxCustFilter;
    DWORD         nFilterIndex;
    LPSTR         lpstrFile;
    DWORD         nMaxFile;
    LPSTR         lpstrFileTitle;
    DWORD         nMaxFileTitle;
    LPCSTR        lpstrInitialDir;
    LPCSTR        lpstrTitle;
    DWORD         Flags;
    WORD          nFileOffset;
    WORD          nFileExtension;
    LPCSTR        lpstrDefExt;
    LPARAM        lCustData;
    LPOFNHOOKPROC lpfnHook;
    LPCSTR        lpTemplateName;
    void *        pvReserved;
    DWORD         dwReserved;
    DWORD         FlagsEx;
} OPENFILENAME_NEW, *LPOPENFILENAME_NEW;
#endif

//******************************************************************************
//****** CSizer
//******************************************************************************

BEGIN_MESSAGE_MAP(CSizer, CScrollBar)
    //{{AFX_MSG_MAP(CSizer)
    ON_WM_NCHITTEST()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
UINT CSizer::OnNcHitTest(CPoint point)
{
    return HTBOTTOMRIGHT;
}

//******************************************************************************
BOOL CSizer::Create(CWnd *pParent)
{
    // SBS_SIZEGRIP is ignored on NT 3.51 and we are left with a mini horizontal
    // scroll bar.  Added SBS_SIZEBOX to get rid of scroll bar on 3.51, but it 
    // still doesn't work.
    return CScrollBar::Create(WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBS_SIZEGRIP | SBS_SIZEBOXBOTTOMRIGHTALIGN | SBS_SIZEBOX,
                              CRect(0, 0, 0, 0), pParent, (UINT)-1);
}

//******************************************************************************
void CSizer::Update()
{
    CRect rc;

    // Get the parent window.
    HWND hWndParent = ::GetParent(GetSafeHwnd());

    // If our window is maximized, then just hide ourself.
    if (::IsZoomed(hWndParent))
    {
        ShowWindow(SW_HIDE);
    }

    // Otherwise, move ourself and make us visible.
    else
    {
        ::GetClientRect(hWndParent, rc);
        rc.left = rc.right  - GetSystemMetrics(SM_CXHTHUMB);
        rc.top  = rc.bottom - GetSystemMetrics(SM_CYVTHUMB);
        MoveWindow(rc, TRUE);
        ShowWindow(SW_SHOWNOACTIVATE);
    }
}


//******************************************************************************
//****** CNewFileDialog
//******************************************************************************

// Taken directly from CFileDialog and then modified to handle the new OPENFILENAME structure.
#ifdef USE_CNewFileDialog
INT_PTR CNewFileDialog::DoModal()
{
    ASSERT_VALID(this);
    ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
    ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

    // zero out the file buffer for consistent parsing later
    ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
    DWORD nOffset = (DWORD)strlen(m_ofn.lpstrFile)+1;
    ASSERT(nOffset <= m_ofn.nMaxFile);
    memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

    // WINBUG: This is a special case for the file open/save dialog,
    //  which sometimes pumps while it is coming up but before it has
    //  disabled the main window.
    HWND hWndFocus = ::GetFocus();
    BOOL bEnableParent = FALSE;
    m_ofn.hwndOwner = PreModal();
    AfxUnhookWindowCreate();
    if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
    {
        bEnableParent = TRUE;
        ::EnableWindow(m_ofn.hwndOwner, FALSE);
    }

    _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
    ASSERT(pThreadState->m_pAlternateWndInit == NULL);

    if (m_ofn.Flags & OFN_EXPLORER)
        pThreadState->m_pAlternateWndInit = this;
    else
        AfxHookWindowCreate(this);

    int nResult;

    // BEGIN of modified code
    OPENFILENAME_NEW ofnNew;
    ZeroMemory(&ofnNew, sizeof(ofnNew)); // inspected
    memcpy(&ofnNew, &m_ofn, sizeof(m_ofn));
    ofnNew.lStructSize = sizeof(ofnNew);
    m_fNewStyle = true;
    m_pofn = (OPENFILENAME*)&ofnNew;
    if (m_bOpenFileDialog)
        nResult = ::GetOpenFileName(m_pofn);
    else
        nResult = ::GetSaveFileName(m_pofn);
    m_pofn = (OPENFILENAME*)&m_ofn; // Razzle cast

    if (!nResult && (CommDlgExtendedError() == CDERR_STRUCTSIZE))
    {
        m_fNewStyle = false;
        // Added (OPENFILENAME*) because newer MFC headers declare m_ofn as OPENFILENAME_NT4
        if (m_bOpenFileDialog)                                  // from CFileDialog::DoModal()
            nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofn); // from CFileDialog::DoModal()
        else                                                    // from CFileDialog::DoModal()
            nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofn); // from CFileDialog::DoModal()
    }
    else
    {
        memcpy(&m_ofn, &ofnNew, sizeof(m_ofn));
        m_ofn.lStructSize = sizeof(m_ofn);
    }
    if (!nResult)
    {
        TRACE("%s failed [%u]\n", m_bOpenFileDialog ? "GetOpenFileName" : "GetSaveFileName", CommDlgExtendedError());
    }
    // END of modified code.

    if (nResult)
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
    pThreadState->m_pAlternateWndInit = NULL;

    // WINBUG: Second part of special case for file open/save dialog.
    if (bEnableParent)
        ::EnableWindow(m_ofn.hwndOwner, TRUE);
    if (::IsWindow(hWndFocus))
        ::SetFocus(hWndFocus);

    PostModal();
    return nResult ? nResult : IDCANCEL;
}
#endif


//******************************************************************************
//****** CSaveDialog
//******************************************************************************

IMPLEMENT_DYNAMIC(CSaveDialog, CFileDialog)
BEGIN_MESSAGE_MAP(CSaveDialog, CFileDialog)
    //{{AFX_MSG_MAP(CSaveDialog)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
CSaveDialog::CSaveDialog() :
    CNewFileDialog(FALSE)
{
}

//******************************************************************************
BOOL CSaveDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
    *pResult = 0;

    // Extract the OFNOTIFY message.
    OFNOTIFY* pNotify = (OFNOTIFY*)lParam;

    // Check to see if the type changed,
    if (pNotify->hdr.code == CDN_TYPECHANGE)
    {
        // Get the filename text (editbox on Win9x / NT 4.0, combobox on Win2K)
        HWND hWnd = ::GetDlgItem(pNotify->hdr.hwndFrom, m_fNewStyle ? cmb13 : edt1);

        // Get the text from the edit/combo box.
        int len = ::GetWindowTextLength(hWnd);
        CString strName;
        ::GetWindowText(hWnd, strName.GetBufferSetLength(len), len + 1);
        strName.ReleaseBuffer();

        // Locate the file extension.
        int wack = strName.ReverseFind('\\');
        int dot  = strName.ReverseFind('.');

        // Remove the extension (if any).
        if ((dot != -1) && (dot > wack))
        {
            strName = strName.Left(dot);
        }

        // Locate the extension for this type from our filter.
        LPCSTR psz = GetOFN().lpstrFilter + strlen(GetOFN().lpstrFilter) + 1;
        for (DWORD dw = 1; dw < GetOFN().nFilterIndex; dw++)
        {
            psz += strlen(psz) + 1;
            psz += strlen(psz) + 1;
        }

        // Append this extension to our string and write back to the edit box.
        strName += (psz + 1);
        ::SetWindowText(hWnd, strName);

        // Set this extension as our default extension.
        SetDefExt(psz + 2);

        return TRUE;

    }
    CNewFileDialog::OnNotify(wParam, lParam, pResult);
    return FALSE;
}


//******************************************************************************
//****** CDlgViewer
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgViewer, CDialog)
    //{{AFX_MSG_MAP(CDlgViewer)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDlgViewer :: Constructor/Destructor
//******************************************************************************

CDlgViewer::CDlgViewer(CWnd *pParent /*=NULL*/) :
    CDialog(CDlgViewer::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDlgViewer)
    //}}AFX_DATA_INIT
}


//******************************************************************************
// CDlgViewer :: Public functions
//******************************************************************************

void CDlgViewer::Initialize()
{
    // Retrieve our external viewer settings from the registry.
    m_strCommand   = g_theApp.GetProfileString("External Viewer", "Command"); // inspected
    m_strArguments = g_theApp.GetProfileString("External Viewer", "Arguments"); // inspected

    // If there was no viewer settings, then use to default viewer settings.
    if (m_strCommand.IsEmpty())
    {
        // Build a path string to Quick View (QUIKVIEW.EXE)
        GetSystemDirectory(m_strCommand.GetBuffer(_MAX_PATH + 1), _MAX_PATH + 1);
        m_strCommand.ReleaseBuffer();
        m_strCommand += "\\viewers\\quikview.exe";

        // Make sure QUIKVIEW.EXE exists - it was removed in Win2K.
        DWORD dwAttrib = GetFileAttributes(m_strCommand);
        if ((dwAttrib == 0xFFFFFFFF) || (dwAttrib == FILE_ATTRIBUTE_DIRECTORY))
        {
            // If that failed, then just build a path to ourself.
            GetModuleFileName(NULL, m_strCommand.GetBuffer(DW_MAX_PATH), DW_MAX_PATH);
            m_strCommand.ReleaseBuffer();
        }

        // Set our arguments to just the module path token.
        m_strArguments = "\"%1\"";
    }
}

//******************************************************************************
BOOL CDlgViewer::LaunchExternalViewer(LPCSTR pszPath)
{
    // Create our args strings by replacing all %1 tokens with the module path.
    CString strArguments(m_strArguments);
    strArguments.Replace("%1", pszPath);

    CString strFile, strParameters;
    int size1, size2;

    // Detokenize our app filename.  We first call ExpandEnvironmentStrings with
    // a zero size to determine the size needed.  Win95 requires a valid
    // destination string pointer pointer, even when we are passing in a size
    // of 0.  Otherwise, we get an error 87 - invalid paraemter.
    CHAR sz[4];
    if (size1 = ExpandEnvironmentStrings(m_strCommand, sz, 0))
    {
        size2 = ExpandEnvironmentStrings(m_strCommand, strFile.GetBuffer(size1), size1);
        strFile.ReleaseBuffer();
        if (!size2 || (size2 > size1))
        {
            strFile.Empty();
        }
    }
    if (strFile.IsEmpty())
    {
        strFile = m_strCommand;
    }

    // Detokenize our command line.
    if (size1 = ExpandEnvironmentStrings(strArguments, sz, 0))
    {
        size2 = ExpandEnvironmentStrings(strArguments, strParameters.GetBuffer(size1), size1);
        strParameters.ReleaseBuffer();
        if (!size2 || (size2 > size1))
        {
            strParameters.Empty();
        }
    }
    if (strParameters.IsEmpty())
    {
        strParameters = strArguments;
    }

    // Start the app.  We used to use ShellExecuteEx, but that fails on NT 3.51.
    DWORD dwError = (DWORD)(DWORD_PTR)ShellExecute(NULL, "open", strFile, strParameters, NULL, SW_SHOWNORMAL); // inspected.  uses full path
    if (dwError <= 32)
    {
        // Display an error message if ShellExecute() failed.
        CString strError("Error executing \"");
        strError += strFile;
        strError += "\" ";
        strError += strParameters;
        strError += "\n\n";

        LPSTR pszError = BuildErrorMessage(dwError, strError);
        MessageBox(pszError, "Dependency Walker External Viewer Error", MB_ICONEXCLAMATION | MB_OK);
        MemFree((LPVOID&)pszError);

        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
// CDlgViewer :: Overridden functions
//******************************************************************************

void CDlgViewer::DoDataExchange(CDataExchange *pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgViewer)
    DDX_Text(pDX, IDC_COMMAND, m_strCommand);
    DDV_MaxChars(pDX, m_strCommand, _MAX_PATH);
    DDX_Text(pDX, IDC_ARGUMENTS, m_strArguments);
    DDV_MaxChars(pDX, m_strArguments, _MAX_PATH);
    //}}AFX_DATA_MAP

    // Write the new settings to the registry is the user pressed OK.
    if (pDX->m_bSaveAndValidate)
    {
        g_theApp.WriteProfileString("External Viewer", "Command",   m_strCommand);
        g_theApp.WriteProfileString("External Viewer", "Arguments", m_strArguments);
    }
}

//******************************************************************************
// CDlgViewer :: Event handler functions
//******************************************************************************

BOOL CDlgViewer::OnInitDialog()
{
    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

    // Center our dialog over the parent.
    CenterWindow();

    return TRUE;
}

//******************************************************************************
void CDlgViewer::OnBrowse()
{
    // Copy the current dialog path to our path buffer.
    // Note: Don't use OFN_EXPLORER as it breaks us on NT 3.51
    CNewFileDialog dlgFile(TRUE, "exe", NULL,
                           OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN |
                           OFN_FILEMUSTEXIST | OFN_READONLY | OFN_NOCHANGEDIR | OFN_DONTADDTORECENT,
                           "Executable (*.exe)|*.exe|All Files (*.*)|*||", this);

    // Copy the current dialog path to our path buffer.
    CHAR szPath[DW_MAX_PATH];
    GetDlgItemText(IDC_COMMAND, szPath, sizeof(szPath));

    // Override a few things.
    dlgFile.GetOFN().lpstrTitle = "Browse for Program";
    dlgFile.GetOFN().lpstrFile = szPath;
    dlgFile.GetOFN().nMaxFile = sizeof(szPath);

    // Display the file dialog and continue and update our dialog path on success.
    if (dlgFile.DoModal() == IDOK)
    {
        SetDlgItemText(IDC_COMMAND, szPath);
    }
}


//******************************************************************************
//****** CDlgExternalHelp
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgExternalHelp, CDialog)
    //{{AFX_MSG_MAP(CDlgExternalHelp)
    ON_BN_CLICKED(IDC_MSDN, OnMsdn)
    ON_BN_CLICKED(IDC_ONLINE, OnOnline)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_COLLECTIONS, OnItemChangedCollections)
    ON_EN_CHANGE(IDC_URL, OnChangeUrl)
    ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
    ON_BN_CLICKED(IDC_DEFAULT_URL, OnDefaultUrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDlgExternalHelp :: Constructor/Destructor
//******************************************************************************

CDlgExternalHelp::CDlgExternalHelp(CWnd* pParent /*=NULL*/)
    : CDialog(CDlgExternalHelp::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDlgExternalHelp)
    //}}AFX_DATA_INIT
}

//******************************************************************************
// CDlgExternalHelp :: Overridden functions
//******************************************************************************

void CDlgExternalHelp::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgExternalHelp)
    DDX_Control(pDX, IDOK, m_butOK);
    DDX_Control(pDX, IDC_COLLECTIONS, m_listCollections);
    //}}AFX_DATA_MAP
}

//******************************************************************************
BOOL CDlgExternalHelp::OnInitDialog() 
{
    CDialog::OnInitDialog();

    // Turn on full row select.
    m_listCollections.SetExtendedStyle(m_listCollections.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

    // Add all our columns.
    m_listCollections.InsertColumn(0, "Type");
    m_listCollections.InsertColumn(1, "Collection");
    m_listCollections.InsertColumn(2, "Path");

    // Populate the list control.
    PopulateCollectionList();

    // Set the URL.
    SetDlgItemText(IDC_URL, g_theApp.m_pMsdnHelp->GetUrl());

    // Check the correct radio button.
    CMsdnCollection *pColActive = g_theApp.m_pMsdnHelp->GetActiveCollection();
    CheckDlgButton(IDC_MSDN,   pColActive ? BST_CHECKED   : BST_UNCHECKED);
    CheckDlgButton(IDC_ONLINE, pColActive ? BST_UNCHECKED : BST_CHECKED);

    // Fake an update so that our Ok button will get properly enabled/disabled.
    if (pColActive)
    {
        OnMsdn();
    }
    else
    {
        OnOnline();
    }
    
    return TRUE;
}

//******************************************************************************
void CDlgExternalHelp::OnMsdn() 
{
    // If the MSDN radio button is selected, then enable/disable the ok button
    // depending on if something is selected in out list box.
    m_butOK.EnableWindow(m_listCollections.GetSelectedCount() == 1);
}

//******************************************************************************
void CDlgExternalHelp::OnOnline() 
{
    // If the Online radio button is selected, then enable/disable the ok button
    // depending on if there is text in our edit box.
    m_butOK.EnableWindow(SendDlgItemMessage(IDC_URL, WM_GETTEXTLENGTH) > 0);
}

//******************************************************************************
void CDlgExternalHelp::OnItemChangedCollections(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // If the MSDN radio button is selected, then enable/disable the ok button
    // depending on if something is selected in out list box.
    if (IsDlgButtonChecked(IDC_MSDN))
    {
        OnMsdn();
    }
    
    *pResult = 0;
}

//******************************************************************************
void CDlgExternalHelp::OnChangeUrl() 
{
    // If the Online radio button is selected, then enable/disable the ok button
    // depending on if there is text in our edit box.
    if (IsDlgButtonChecked(IDC_ONLINE))
    {
        OnOnline();
    }
}

//******************************************************************************
void CDlgExternalHelp::OnRefresh() 
{
    // Refresh the list.
    g_theApp.m_pMsdnHelp->RefreshCollectionList();

    // Repopulate the list control.
    m_listCollections.DeleteAllItems();
    PopulateCollectionList();
}

//******************************************************************************
void CDlgExternalHelp::OnDefaultUrl() 
{
    SetDlgItemText(IDC_URL, g_theApp.m_pMsdnHelp->GetDefaultUrl());
}

//******************************************************************************
void CDlgExternalHelp::OnOK() 
{
    // Get the URL from our UI and set it in the CMsdnHelp object.
    CString strUrl;
    if (GetDlgItemText(IDC_URL, strUrl))
    {
        g_theApp.m_pMsdnHelp->SetUrl(strUrl);
    }

    // Get the active collection from our UI and set it in the CMsdnHelp object.
    CMsdnCollection *pColActive = NULL;
    if (IsDlgButtonChecked(IDC_MSDN))
    {
        int item = m_listCollections.GetNextItem(-1, LVNI_SELECTED);
        if (item >= 0)
        {
            pColActive = (CMsdnCollection*)m_listCollections.GetItemData(item);
        }
    }
    g_theApp.m_pMsdnHelp->SetActiveCollection(pColActive);

    // Call the base class to allow the dialog to close.
    CDialog::OnOK();
}

//******************************************************************************
void CDlgExternalHelp::PopulateCollectionList()
{
    // Populate the list control.
    CMsdnCollection *pCol       = g_theApp.m_pMsdnHelp->GetCollectionList();
    CMsdnCollection *pColActive = g_theApp.m_pMsdnHelp->GetActiveCollection();

    for (int item, count = 0; pCol; pCol = pCol->m_pNext)
    {
        item = m_listCollections.InsertItem(LVIF_TEXT | LVIF_STATE | LVIF_PARAM,
            count++, (LPSTR)((pCol->m_dwFlags & MCF_1_MASK) ? "MSDN 1.x" : "MSDN 2.x"),
            (pCol ==  pColActive) ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, (LPARAM)pCol);

        m_listCollections.SetItemText(item, 1, (LPSTR)(LPCSTR)pCol->m_strDescription);
        m_listCollections.SetItemText(item, 2, (LPSTR)(LPCSTR)pCol->m_strPath);
    }

    // Resize our columns
    for (int col = 0; col < 3; col++)
    {
        m_listCollections.SetColumnWidth(col, LVSCW_AUTOSIZE_USEHEADER);
    }
}


//******************************************************************************
//****** CDlgProfile
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgProfile, CDialog)
    //{{AFX_MSG_MAP(CDlgProfile)
    ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_HOOK_PROCESS, OnHookProcess)
    ON_BN_CLICKED(IDC_LOG_THREADS, OnLogThreads)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//******************************************************************************
// CDlgProfile :: Constructor/Destructor
//******************************************************************************

CDlgProfile::CDlgProfile(CDocDepends *pDoc, CWnd* pParent /*=NULL*/) :
    CDialog(CDlgProfile::IDD, pParent),
    m_pDocDepends(pDoc)
{
    //{{AFX_DATA_INIT(CDlgProfile)
    //}}AFX_DATA_INIT
}

//******************************************************************************
// CDlgProfile :: Event handler functions
//******************************************************************************

BOOL CDlgProfile::OnInitDialog()
{
    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

#if defined(_IA64_)

    // do nothing

#elif defined(_ALPHA64_)

    // do nothing

#elif defined(_X86_) || defined(_ALPHA_)

    if (g_f64BitOS)
    {
        CString str;
        GetDlgItemText(IDC_LOG_DLLMAIN_PROCESS_MSGS, str);
        SetDlgItemText(IDC_LOG_DLLMAIN_PROCESS_MSGS, str + " (*** May fail on WOW64 ***)");
        GetDlgItemText(IDC_LOG_DLLMAIN_OTHER_MSGS, str);
        SetDlgItemText(IDC_LOG_DLLMAIN_OTHER_MSGS, str + " (*** May fail on WOW64 ***)");
        GetDlgItemText(IDC_HOOK_PROCESS, str);
        SetDlgItemText(IDC_HOOK_PROCESS, str + " (*** May fail on WOW64 ***)");
    }

#endif

    // Set our profile arguments and starting directory strings.
    SetDlgItemText(IDC_ARGUMENTS, m_pDocDepends->m_strProfileArguments);
    SetDlgItemText(IDC_DIRECTORY, m_pDocDepends->m_strProfileDirectory);

    // Set the check boxes according to our flags.
    CheckDlgButton(IDC_LOG_CLEAR, (m_pDocDepends->m_dwProfileFlags & PF_LOG_CLEAR) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_SIMULATE_SHELLEXECUTE, (m_pDocDepends->m_dwProfileFlags & PF_SIMULATE_SHELLEXECUTE) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_DLLMAIN_PROCESS_MSGS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_DLLMAIN_OTHER_MSGS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_HOOK_PROCESS, (m_pDocDepends->m_dwProfileFlags & PF_HOOK_PROCESS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_LOADLIBRARY_CALLS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_LOADLIBRARY_CALLS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_GETPROCADDRESS_CALLS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_GETPROCADDRESS_CALLS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_THREADS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_THREADS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_USE_THREAD_INDEXES, (m_pDocDepends->m_dwProfileFlags & PF_USE_THREAD_INDEXES) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_EXCEPTIONS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_EXCEPTIONS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_DEBUG_OUTPUT, (m_pDocDepends->m_dwProfileFlags & PF_LOG_DEBUG_OUTPUT) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_USE_FULL_PATHS, (m_pDocDepends->m_dwProfileFlags & PF_USE_FULL_PATHS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_LOG_TIME_STAMPS, (m_pDocDepends->m_dwProfileFlags & PF_LOG_TIME_STAMPS) ?
                   BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(IDC_PROFILE_CHILDREN, (m_pDocDepends->m_dwProfileFlags & PF_PROFILE_CHILDREN) ?
                   BST_CHECKED : BST_UNCHECKED);

    // Enable or disable check boxes that are dependent on the Hook Process option.
    OnHookProcess();

    // Enable or disable check boxes that are dependent on the Show Threads option.
    OnLogThreads();

    // Center our dialog over the parent.
    CenterWindow();

    return TRUE;
}

//******************************************************************************
// CDlgProfile :: Overridden functions
//******************************************************************************

void CDlgProfile::OnHookProcess()
{
    BOOL fEnabled = IsDlgButtonChecked(IDC_HOOK_PROCESS);
    GetDlgItem(IDC_LOG_LOADLIBRARY_CALLS)->EnableWindow(fEnabled);
    GetDlgItem(IDC_LOG_GETPROCADDRESS_CALLS)->EnableWindow(fEnabled);
}

//******************************************************************************
void CDlgProfile::OnLogThreads()
{
    GetDlgItem(IDC_USE_THREAD_INDEXES)->EnableWindow(IsDlgButtonChecked(IDC_LOG_THREADS));
}

//******************************************************************************
void CDlgProfile::OnDefault()
{
    SetDlgItemText(IDC_DIRECTORY, m_pDocDepends->m_strDefaultDirectory);
}

//******************************************************************************
void CDlgProfile::OnBrowse()
{
    // Get the text from the directory edit box.
    CHAR szDirectory[DW_MAX_PATH];
    GetDlgItemText(IDC_DIRECTORY, szDirectory, sizeof(szDirectory));

    // Display our directory chooser dialog.
    LPSTR psz = TrimWhitespace(szDirectory);
    if (DirectoryChooser(psz, sizeof(szDirectory) - (int)(psz - szDirectory), "Choose the starting directory:", this))
    {
        // Update the directory name.
        SetDlgItemText(IDC_DIRECTORY, psz);
    }
}

//******************************************************************************
void CDlgProfile::OnOK()
{
    // Get the directory name.
    CHAR szBuffer[DW_MAX_PATH];
    GetDlgItemText(IDC_DIRECTORY, szBuffer, sizeof(szBuffer));

    // Add the trailing wack.
    AddTrailingWack(szBuffer, sizeof(szBuffer));

    // Make sure the directory path is valid.
    DWORD dwAttribs = GetFileAttributes(szBuffer);
    if ((dwAttribs == 0xFFFFFFFF) || !(dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
        // In case we added a wack, update the text since the dialog is going to
        // stay up due to the error.
        SetDlgItemText(IDC_DIRECTORY, szBuffer);

        // Display an error and abort the closing of the dialog.
        CString strError("\"");
        strError += szBuffer;
        strError += "\" is not a valid directory.";
        MessageBox(strError, "Dependency Walker Error", MB_ICONERROR | MB_OK);
        return;
    }

    // Store the directory.
    m_pDocDepends->m_strProfileDirectory = szBuffer;

    // Store the arguments.
    GetDlgItemText(IDC_ARGUMENTS, szBuffer, sizeof(szBuffer));
    m_pDocDepends->m_strProfileArguments = szBuffer;

    // Store the flags.
    m_pDocDepends->m_dwProfileFlags =
    (IsDlgButtonChecked(IDC_LOG_CLEAR)                ? PF_LOG_CLEAR                : 0) |
    (IsDlgButtonChecked(IDC_SIMULATE_SHELLEXECUTE)    ? PF_SIMULATE_SHELLEXECUTE    : 0) |
    (IsDlgButtonChecked(IDC_LOG_DLLMAIN_PROCESS_MSGS) ? PF_LOG_DLLMAIN_PROCESS_MSGS : 0) |
    (IsDlgButtonChecked(IDC_LOG_DLLMAIN_OTHER_MSGS)   ? PF_LOG_DLLMAIN_OTHER_MSGS   : 0) |
    (IsDlgButtonChecked(IDC_HOOK_PROCESS)             ? PF_HOOK_PROCESS             : 0) |
    (IsDlgButtonChecked(IDC_LOG_LOADLIBRARY_CALLS)    ? PF_LOG_LOADLIBRARY_CALLS    : 0) |
    (IsDlgButtonChecked(IDC_LOG_GETPROCADDRESS_CALLS) ? PF_LOG_GETPROCADDRESS_CALLS : 0) |
    (IsDlgButtonChecked(IDC_LOG_THREADS)              ? PF_LOG_THREADS              : 0) |
    (IsDlgButtonChecked(IDC_USE_THREAD_INDEXES)       ? PF_USE_THREAD_INDEXES       : 0) |
    (IsDlgButtonChecked(IDC_LOG_EXCEPTIONS)           ? PF_LOG_EXCEPTIONS           : 0) |
    (IsDlgButtonChecked(IDC_LOG_DEBUG_OUTPUT)         ? PF_LOG_DEBUG_OUTPUT         : 0) |
    (IsDlgButtonChecked(IDC_USE_FULL_PATHS)           ? PF_USE_FULL_PATHS           : 0) |
    (IsDlgButtonChecked(IDC_LOG_TIME_STAMPS)          ? PF_LOG_TIME_STAMPS          : 0) |
    (IsDlgButtonChecked(IDC_PROFILE_CHILDREN)         ? PF_PROFILE_CHILDREN         : 0);

    // These settings are persistent, so store them to the registry.
    CRichViewProfile::WriteLogClearSetting(       (m_pDocDepends->m_dwProfileFlags & PF_LOG_CLEAR)                ? 1 : 0);
    CRichViewProfile::WriteSimulateShellExecute(  (m_pDocDepends->m_dwProfileFlags & PF_SIMULATE_SHELLEXECUTE)    ? 1 : 0);
    CRichViewProfile::WriteLogDllMainProcessMsgs( (m_pDocDepends->m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS) ? 1 : 0);
    CRichViewProfile::WriteLogDllMainOtherMsgs(   (m_pDocDepends->m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS)   ? 1 : 0);
    CRichViewProfile::WriteHookProcess(           (m_pDocDepends->m_dwProfileFlags & PF_HOOK_PROCESS)             ? 1 : 0);
    CRichViewProfile::WriteLogLoadLibraryCalls(   (m_pDocDepends->m_dwProfileFlags & PF_LOG_LOADLIBRARY_CALLS)    ? 1 : 0);
    CRichViewProfile::WriteLogGetProcAddressCalls((m_pDocDepends->m_dwProfileFlags & PF_LOG_GETPROCADDRESS_CALLS) ? 1 : 0);
    CRichViewProfile::WriteLogThreads(            (m_pDocDepends->m_dwProfileFlags & PF_LOG_THREADS)              ? 1 : 0);
    CRichViewProfile::WriteUseThreadIndexes(      (m_pDocDepends->m_dwProfileFlags & PF_USE_THREAD_INDEXES)       ? 1 : 0);
    CRichViewProfile::WriteLogExceptions(         (m_pDocDepends->m_dwProfileFlags & PF_LOG_EXCEPTIONS)           ? 1 : 0);
    CRichViewProfile::WriteLogDebugOutput(        (m_pDocDepends->m_dwProfileFlags & PF_LOG_DEBUG_OUTPUT)         ? 1 : 0);
    CRichViewProfile::WriteUseFullPaths(          (m_pDocDepends->m_dwProfileFlags & PF_USE_FULL_PATHS)           ? 1 : 0);
    CRichViewProfile::WriteLogTimeStamps(         (m_pDocDepends->m_dwProfileFlags & PF_LOG_TIME_STAMPS)          ? 1 : 0);
    CRichViewProfile::WriteChildren(              (m_pDocDepends->m_dwProfileFlags & PF_PROFILE_CHILDREN)         ? 1 : 0);

    CDialog::OnOK();
}


//******************************************************************************
//****** CDlgSysInfo
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgSysInfo, CDialog)
    //{{AFX_MSG_MAP(CDlgSysInfo)
    ON_WM_INITMENU()
    ON_WM_GETMINMAXINFO()
    ON_WM_SIZE()
    ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
    ON_BN_CLICKED(IDC_SELECT_ALL, OnSelectAll)
    ON_BN_CLICKED(IDC_COPY, OnCopy)
    ON_NOTIFY(EN_SELCHANGE, IDC_RICHEDIT, OnSelChangeRichEdit)
    ON_WM_NCHITTEST()
    ON_WM_SETTINGCHANGE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDlgSysInfo :: Constructor/Destructor
//******************************************************************************

CDlgSysInfo::CDlgSysInfo(SYSINFO *pSI /*=NULL*/, LPCSTR pszTitle /*=NULL*/) :
    CDialog(CDlgSysInfo::IDD, NULL),
    m_pSI(pSI),
    m_pszTitle(pszTitle),
    m_fInitialized(false),
    m_sPadding(0, 0),
    m_sButton(0, 0),
    m_cyButtonPadding(0),
    m_ptMinTrackSize(0, 0)
{
    //{{AFX_DATA_INIT(CDlgSysInfo)
    //}}AFX_DATA_INIT
}

//******************************************************************************
// CDlgSysInfo :: Overridden functions
//******************************************************************************

void CDlgSysInfo::DoDataExchange(CDataExchange *pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgSysInfo)
    DDX_Control(pDX, IDC_RICHEDIT, m_reInfo);
    DDX_Control(pDX, IDOK, m_butOk);
    DDX_Control(pDX, IDC_REFRESH, m_butRefresh);
    DDX_Control(pDX, IDC_SELECT_ALL, m_butSelectAll);
    DDX_Control(pDX, IDC_COPY, m_butCopy);
    //}}AFX_DATA_MAP
}

//******************************************************************************
// CDlgSysInfo :: Event handler functions
//******************************************************************************

BOOL CDlgSysInfo::OnInitDialog()
{
    // Make sure our dialog resource has the following styles...
    // STYLE DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
    // The resource editor will strip off the WS_THICKFRAME every time we edit it.
    ASSERT((GetStyle() & (DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME)) ==
           (DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME));

    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

    // Modify our title to reflect what the user is seeing.
    if (m_pSI)
    {
        CHAR szCaption[1024];
        SCPrintf(szCaption, sizeof(szCaption), "System Information (%s)",
                 m_pszTitle ? m_pszTitle : "Snapshot from DWI file");
        SetWindowText(szCaption);
    }
    else
    {
        SetWindowText("System Information (Local)");
    }

    // Make sure all our children know to clip each other since we allow resizing.
    m_reInfo.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butOk.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butRefresh.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butSelectAll.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butCopy.ModifyStyle(0, WS_CLIPSIBLINGS);

    // Create our size gripper.
    m_Sizer.Create(this);

    m_butRefresh.EnableWindow(!m_pSI);

    // Compute our buffer size around controls.
    CRect rc, rc2;
    m_reInfo.GetWindowRect(&rc);
    ScreenToClient(&rc.TopLeft());
    m_sPadding = CSize(rc.left, rc.top);

    // Get our button size.
    m_butOk.GetWindowRect(&rc);
    m_sButton = rc.Size();

    // Get the buffer distance between buttons.
    m_butRefresh.GetWindowRect(&rc2);
    m_cyButtonPadding = rc2.top - (rc.top + rc.Height());

    // Determine our minimum size window.
    m_ptMinTrackSize.x = (2 * GetSystemMetrics(SM_CXSIZEFRAME)) +
                         (3 * m_sPadding.cx) + (2 * m_sButton.cx);
    m_ptMinTrackSize.y = (2 * GetSystemMetrics(SM_CYSIZEFRAME)) + GetSystemMetrics(SM_CYCAPTION) +
                         (2 * m_sPadding.cy) + (4 * m_sButton.cy) + (3 * m_cyButtonPadding);

    m_fInitialized = true;

    // Fill in our rich edit control.
    OnRefresh();

    // Compute the height of a given line.
    CPoint pt1 = m_reInfo.GetCharPos(m_reInfo.LineIndex(0));
    CPoint pt2 = m_reInfo.GetCharPos(m_reInfo.LineIndex(1));

    // Compute the height of the window.
    int count = m_reInfo.GetLineCount();
    int cx = 0;
    int cy = (2 * GetSystemMetrics(SM_CYSIZEFRAME)) + GetSystemMetrics(SM_CYCAPTION) +
             (2 * GetSystemMetrics(SM_CYBORDER)) + (2 * m_sPadding.cy) +
             (count * (pt2.y - pt1.y)) + GetSystemMetrics(SM_CYHSCROLL) + 10;

    // Compute the width of the longest line.
    for (int i = 0; i < count; i++)
    {
        int chr = m_reInfo.LineIndex(i);
        pt1 = m_reInfo.GetCharPos(chr + m_reInfo.LineLength(chr));
        if (cx < pt1.x)
        {
            cx = pt1.x;
        }
    }

    // Compute the width of the window.
    cx += (2 * GetSystemMetrics(SM_CXSIZEFRAME)) + (2 * GetSystemMetrics(SM_CXBORDER)) +
          (3 * m_sPadding.cx) + m_sButton.cx + GetSystemMetrics(SM_CXVSCROLL) + 10;

    // Compute the max size window we can handle.  We first check to see if
    // GetSystemMetrics(SM_CXMAXIMIZED) returns a value.  If so, we use it.
    // If it returns 0, then we are probably running NT 3.51 and we just use
    // GetSystemMetrics(SM_CXSCREEN).
    int cxMax = GetSystemMetrics(SM_CXMAXIMIZED) ?
               (GetSystemMetrics(SM_CXMAXIMIZED) - (2 * GetSystemMetrics(SM_CXSIZEFRAME))) :
                GetSystemMetrics(SM_CXSCREEN);
    int cyMax = GetSystemMetrics(SM_CYMAXIMIZED) ?
               (GetSystemMetrics(SM_CYMAXIMIZED) - (2 * GetSystemMetrics(SM_CYSIZEFRAME))) :
                GetSystemMetrics(SM_CYSCREEN);

    // Make sure this window will fit on our screen
    if (cx > cxMax)
    {
        cx = cxMax;
    }
    if (cy > cyMax)
    {
        cy = cyMax;
    }

    // Set our window position.
    SetWindowPos(NULL, 0, 0, cx, cy, SWP_NOMOVE | SWP_NOZORDER);
    CenterWindow();

    return TRUE;
}

//******************************************************************************
void CDlgSysInfo::OnInitMenu(CMenu* pMenu)
{
    // Call base class.
    CDialog::OnInitMenu(pMenu);

    // Remove the "Minimize" item from our system menu.
    pMenu->RemoveMenu(SC_MINIMIZE, MF_BYCOMMAND);

    // Adjust the "Maximize" and "Restore" items depending on in we are maximized.
    // We need to do this based on different behavior on different OSs.  NT 4 seems
    // to enable everything.  NT 5 seems to disable everything.
    BOOL fMaximized  = IsZoomed();
    pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | (fMaximized ? MF_GRAYED  : MF_ENABLED));
    pMenu->EnableMenuItem(SC_RESTORE,  MF_BYCOMMAND | (fMaximized ? MF_ENABLED : MF_GRAYED ));
}

//******************************************************************************
void CDlgSysInfo::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
    if (m_fInitialized)
    {
        lpMMI->ptMinTrackSize = m_ptMinTrackSize;
    }
    CDialog::OnGetMinMaxInfo(lpMMI);
}

//******************************************************************************
void CDlgSysInfo::OnSize(UINT nType, int cx, int cy)
{
    CDialog::OnSize(nType, cx, cy);

    if (!m_fInitialized)
    {
        return;
    }

    int cxRich = cx - (3 * m_sPadding.cx) - m_sButton.cx;
    int cyRich = cy - (2 * m_sPadding.cy);

    // Move our rich edit control
    CRect rc(m_sPadding.cx, m_sPadding.cy, m_sPadding.cx + cxRich, m_sPadding.cy + cyRich);
    m_reInfo.MoveWindow(&rc, TRUE);

    // Move ok button
    rc.left   = rc.right + m_sPadding.cx;
    rc.right  = rc.left + m_sButton.cx;
    rc.bottom = rc.top + m_sButton.cy;
    m_butOk.MoveWindow(&rc, TRUE);

    // Move refresh button
    rc.top    = rc.bottom + m_cyButtonPadding;
    rc.bottom = rc.top + m_sButton.cy;
    m_butRefresh.MoveWindow(&rc, TRUE);

    // Move select all button
    rc.top    = rc.bottom + m_cyButtonPadding;
    rc.bottom = rc.top + m_sButton.cy;
    m_butSelectAll.MoveWindow(&rc, TRUE);

    // Move copy button
    rc.top    = rc.bottom + m_cyButtonPadding;
    rc.bottom = rc.top + m_sButton.cy;
    m_butCopy.MoveWindow(&rc, TRUE);

    // Move our size gripper.
    m_Sizer.Update();
}

//******************************************************************************
void CDlgSysInfo::OnRefresh()
{
    SYSINFO si, *pSI = m_pSI;
    if (!pSI)
    {
        BuildSysInfo(pSI = &si);
    }

    // Turn off events while we update the control.
    m_reInfo.SetEventMask(0);

    m_reInfo.SetRedraw(FALSE);
    m_reInfo.SetWindowText("");

    // Set our tab stops
    PARAFORMAT pf;
    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_TABSTOPS;
    pf.cTabCount = 1;
    pf.rgxTabs[0] = 2500;
    m_reInfo.SetParaFormat(pf);

    // Send the text to the control.
    BuildSysInfo(pSI, StaticSysInfoCallback, (LPARAM)this);

    m_reInfo.SetRedraw(TRUE);
    m_reInfo.InvalidateRect(NULL, TRUE);

    // Turn on SELCHANGE event so we can receive it.
    m_reInfo.SetEventMask(ENM_SELCHANGE);
    m_reInfo.SetSel(0, 0);
}

//******************************************************************************
void CDlgSysInfo::OnSelectAll()
{
    m_reInfo.SetSel(0, -1);
}

//******************************************************************************
void CDlgSysInfo::OnCopy()
{
    m_reInfo.Copy();
}

//******************************************************************************
void CDlgSysInfo::OnSelChangeRichEdit(NMHDR* pNMHDR, LRESULT* pResult)
{
    SELCHANGE *pSelChange = reinterpret_cast<SELCHANGE *>(pNMHDR);
    m_butCopy.EnableWindow(pSelChange->chrg.cpMax > pSelChange->chrg.cpMin);
    *pResult = 0;
}

//******************************************************************************
void CDlgSysInfo::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    // Call our base class.
    CDialog::OnSettingChange(uFlags, lpszSection);

    // Update our date/time format values.
    g_theApp.QueryLocaleInfo();

    // Force a refresh in case the time/date format changed.
    OnRefresh();
}

//******************************************************************************
bool CDlgSysInfo::SysInfoCallback(LPCSTR pszField, LPCSTR pszValue)
{
    // Set the selection to the end and then get the location.
    LONG lStart, lEnd;
    m_reInfo.SetSel(0x7FFFFFFF, 0x7FFFFFFF);
    m_reInfo.GetSel(lStart, lEnd);

    // Set the current input position to non-bold text.
    CHARFORMAT cf;
    cf.dwMask = CFM_BOLD;
    cf.dwEffects = 0;
    m_reInfo.SetSelectionCharFormat(cf);

    // Add the text.
    if (lStart)
    {
        m_reInfo.ReplaceSel("\r\n", FALSE);
        lStart += 2;
    }
    m_reInfo.ReplaceSel(pszField, FALSE);
    m_reInfo.ReplaceSel(":\t", FALSE);
    m_reInfo.ReplaceSel(pszValue, FALSE);

    // Set the field text to bold.
    cf.dwEffects = CFE_BOLD;
    m_reInfo.SetSel(lStart, lStart + (long)strlen(pszField) + 1);
    m_reInfo.SetSelectionCharFormat(cf);

    return true;
}


//******************************************************************************
//****** CDlgExtensions
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgExtensions, CDialog)
    //{{AFX_MSG_MAP(CDlgExtensions)
    ON_LBN_SELCHANGE(IDC_EXTS, OnSelChangeExts)
    ON_EN_UPDATE(IDC_EXT, OnUpdateExt)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_SEARCH, OnSearch)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//******************************************************************************
// CDlgExtensions :: Constructor/Destructor
//******************************************************************************

CDlgExtensions::CDlgExtensions(CWnd* pParent) :
    CDialog(CDlgExtensions::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDlgExtensions)
    //}}AFX_DATA_INIT
}


//******************************************************************************
// CDlgExtensions :: Overridden functions
//******************************************************************************

void CDlgExtensions::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgExtensions)
    DDX_Control(pDX, IDC_EXTS, m_listExts);
    DDX_Control(pDX, IDC_EXT, m_editExt);
    DDX_Control(pDX, IDC_ADD, m_butAdd);
    DDX_Control(pDX, IDC_REMOVE, m_butRemove);
    //}}AFX_DATA_MAP
}


//******************************************************************************
// CDlgExtensions :: Event handler functions
//******************************************************************************

BOOL CDlgExtensions::OnInitDialog()
{
    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

    // Get a list of our handled extensions.
    CString strExts;
    GetRegisteredExtensions(strExts);

    // Loop through each type of file extensions that we want to add.
    for (LPSTR pszExt = (LPSTR)(LPCSTR)strExts; pszExt[0] == ':'; )
    {
        // Locate the colon after the extension name.
        for (LPSTR pszEnd = pszExt + 1; *pszEnd && (*pszEnd != ':'); pszEnd++)
        {
        }
        if (!*pszEnd)
        {
            break;
        }

        // NULL out the second colon, add the string, then restore the colon.
        *pszEnd = '\0';
        m_listExts.AddString(pszExt + 1);
        *pszEnd = ':';

        // Move pointer to next extension in our list.
        pszExt = pszEnd;
    }

    // Update our controls.
    m_editExt.LimitText(DW_MAX_PATH - 3);
    OnSelChangeExts();
    OnUpdateExt();

    return TRUE;
}

//******************************************************************************
void CDlgExtensions::OnSelChangeExts()
{
    m_butRemove.EnableWindow(m_listExts.GetSelCount() > 0);
}

//******************************************************************************
void CDlgExtensions::OnUpdateExt()
{
    // Get the current text.
    CHAR szBuf[DW_MAX_PATH];
    BOOL fError = FALSE;
    int error, length = GetDlgItemText(IDC_EXT, szBuf, sizeof(szBuf));

    // Get the current selection.
    int nStartChar, nEndChar;
    m_editExt.GetSel(nStartChar, nEndChar);

    // Look for bad characters.
    while ((error = (int)strcspn(szBuf, ".\\/:*?\"<>|")) < length)
    {
        // Flag the error.
        fError = TRUE;

        // Move the cursor back if the error occurs before the cursor.
        if (nStartChar > length)
        {
            nStartChar--;
        }
        if (nEndChar > length)
        {
            nEndChar--;
        }

        // Remove the bad character.
        memmove(szBuf + error, szBuf + error + 1, length - error); // inspected
        length--;
    }

    // Check to see if we had one or more errors.
    if (fError)
    {
        // Set the new text and cursor position, and then beep.
        SetDlgItemText(IDC_EXT, szBuf);
        m_editExt.SetSel(nStartChar - 1, nEndChar - 1);
        MessageBeep(0);
    }

    // Enable the add button if necessary.
    m_butAdd.EnableWindow((length > 0) && (m_listExts.FindStringExact(0, szBuf) == LB_ERR));
}

//******************************************************************************
void CDlgExtensions::OnAdd()
{
    CHAR szBuf[DW_MAX_PATH];
    GetDlgItemText(IDC_EXT, szBuf, sizeof(szBuf));
    _strupr(szBuf);
    m_listExts.AddString(szBuf);
    SetDlgItemText(IDC_EXT, "");
    m_butAdd.EnableWindow(FALSE);
}

//******************************************************************************
void CDlgExtensions::OnRemove()
{
    // Remove all selected items in the list, and remember the last item we removed.
    for (int i = 0, j = -1, count = m_listExts.GetCount(); i < count; )
    {
        if (m_listExts.GetSel(i))
        {
            m_listExts.DeleteString(i);
            count--;
            j = i;
        }
        else
        {
            i++;
        }
    }

    // If we removed the last item, them move our last item index up one.
    if (j >= count)
    {
        j = count - 1;
    }

    // If we still have an items in the list, then highlight the last item.
    if (j >= 0)
    {
        m_listExts.SetSel(j);
    }

    // Otherwise, nothing should be highlighted, so disable the remove button.
    else
    {
        m_butRemove.EnableWindow(FALSE);
    }

    // Check our add button to see its status has changed.
    OnUpdateExt();
}

//******************************************************************************
void CDlgExtensions::OnSearch()
{
    // Create and display the search dialog.
    CDlgFileSearch dlgFileSearch(this);
    if (dlgFileSearch.DoModal() != IDOK)
    {
        return;
    }

    // Loop through each type of file extensions that we want to add.
    for (LPSTR pszExt = (LPSTR)(LPCSTR)dlgFileSearch.m_strExts; pszExt[0] == ':'; )
    {
        // Locate the colon after the extension name.
        for (LPSTR pszEnd = pszExt + 1; *pszEnd && (*pszEnd != ':'); pszEnd++)
        {
        }
        if (!*pszEnd)
        {
            break;
        }

        // NULL out the second colon so we can isolate the extension.
        *pszEnd = '\0';

        // Make sure we don't already have this extension.
        if (m_listExts.FindStringExact(0, pszExt + 1) == LB_ERR)
        {
            // Add the string.
            m_listExts.AddString(pszExt + 1);
        }

        // Restore the colon.
        *pszEnd = ':';

        // Move pointer to next extension in our list.
        pszExt = pszEnd;
    }
    OnUpdateExt();
}

//******************************************************************************
void CDlgExtensions::OnOK()
{
    // Get a list of our currently handled extensions.
    CString strExts;
    GetRegisteredExtensions(strExts);

    // Unregister all these extensions.
    UnRegisterExtensions(strExts);

    // Build a list of the new extensions.
    CHAR szBuf[DW_MAX_PATH];
    strExts = ":";
    for (int i = 0, count = m_listExts.GetCount(); i < count; i++)
    {
        m_listExts.GetText(i, szBuf); //!! does not take a length
        StrCCat(szBuf, ":", sizeof(szBuf));
        strExts += szBuf;
    }

    // Register all these extensions.
    if (!RegisterExtensions(strExts))
    {
        MessageBox(
            "There was an error while trying to save the list of extensions to the registry.  "
            "Your current user account might not have permission to modify the registry.",
            "Dependency Walker Error", MB_ICONERROR | MB_OK);
        return;
    }

    // Close.
    CDialog::OnOK();
}

//******************************************************************************
//****** CDlgFileSearch
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgFileSearch, CDialog)
    //{{AFX_MSG_MAP(CDlgFileSearch)
    ON_MESSAGE(WM_MAIN_THREAD_CALLBACK, OnMainThreadCallback)
    ON_LBN_SELCHANGE(IDC_DRIVES, OnSelChangeDrives)
    ON_LBN_SELCHANGE(IDC_EXTS, OnSelChangeExts)
    ON_BN_CLICKED(IDC_SEARCH, OnSearch)
    ON_BN_CLICKED(IDC_STOP, OnStop)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//******************************************************************************
// CDlgFileSearch :: Constructor/Destructor
//******************************************************************************

CDlgFileSearch::CDlgFileSearch(CWnd *pParent /*=NULL*/) :
    CDialog(CDlgFileSearch::IDD, pParent),
    m_fAbort(FALSE),
    m_result(0),
    m_pWinThread(NULL),
    m_dwDrives(0),
    m_strExts(":")
{
    //{{AFX_DATA_INIT(CDlgFileSearch)
    //}}AFX_DATA_INIT
}


//******************************************************************************
// CDlgFileSearch :: Overridden functions
//******************************************************************************

void CDlgFileSearch::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgFileSearch)
    DDX_Control(pDX, IDC_EXTS, m_listExts);
    DDX_Control(pDX, IDC_DRIVES, m_listDrives);
    DDX_Control(pDX, IDC_STOP, m_butStop);
    DDX_Control(pDX, IDC_SEARCH, m_butSearch);
    DDX_Control(pDX, IDC_ANIMATE, m_animate);
    DDX_Control(pDX, IDOK, m_butOk);
    //}}AFX_DATA_MAP
}


//******************************************************************************
// CDlgFileSearch :: Event handler functions
//******************************************************************************

BOOL CDlgFileSearch::OnInitDialog()
{
    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

    // Open our animation.
    m_animate.Open(IDR_SEARCH);

    // Get the bitmask for the drives on this system
    DWORD dwDrives = GetLogicalDrives();

    // Loop through all 26 drives (A:\ through Z:\).
    CHAR szDrive[4] = "X:\\";
    for (int i = 0; i < 26; i++)
    {
        // Check to see if this drive is present.
        if ((1 << i) & dwDrives)
        {
            // Build the drive string.
            szDrive[0] = (CHAR)((int)'A' + i);

            // Add the drive to the list box.
            int index = m_listDrives.AddString(szDrive);

            // Set the value of this item to its drive number.
            m_listDrives.SetItemData(index, i);

            // If it is a local hard drive, then select the drive.
            if (GetDriveType(szDrive) == DRIVE_FIXED)
            {
                m_listDrives.SetSel(index, TRUE);
            }
        }
    }
    m_listDrives.SetTopIndex(0);

    m_butStop.EnableWindow(FALSE);
    m_butOk.EnableWindow(FALSE);
    OnSelChangeDrives();

    return TRUE;
}

//******************************************************************************
LONG CDlgFileSearch::OnMainThreadCallback(WPARAM wParam, LPARAM lParam)
{
    int  i, j, count;
    CHAR szBuffer[32];

    switch (wParam)
    {
        case FSF_START_DRIVE:
        case FSF_STOP_DRIVE:

            // Search for the item that is changing.
            for (i = 0, count = m_listDrives.GetCount(); i < count; i++)
            {
                // See if we got a match.
                if (m_listDrives.GetItemData(i) == (DWORD)lParam)
                {
                    // Build the new text.
                    SCPrintf(szBuffer, sizeof(szBuffer), (wParam == FSF_START_DRIVE) ? "%c:\\ - Searching" : "%c:\\",
                             (CHAR)((int)'A' + lParam));

                    // Remove the old string.
                    m_listDrives.DeleteString(i);

                    // Add the new string.
                    j = m_listDrives.AddString(szBuffer);
                    m_listDrives.SetItemData(j, lParam);
                    m_listDrives.SetSel(j, TRUE);
                    break;
                }
            }
            break;

        case FSF_ADD_EXT:
            // Add the new extension and select it.
            m_listExts.SetSel(m_listExts.AddString((LPCSTR)lParam));
            m_listExts.SetTopIndex(0);
            break;

        case FSF_SEARCH_DONE:

            // Set our thread to null so we know it is closed.
            m_pWinThread = NULL;

            // Update our window states.
            m_listDrives.EnableWindow(TRUE);
            m_listExts.EnableWindow(TRUE);
            m_butStop.EnableWindow(FALSE);
            OnSelChangeDrives();
            OnSelChangeExts();

            // Stop our animation and reset it to the first frame.
            m_animate.Stop();
            m_animate.Seek(0);

            // If we are supposed to close, then do so know.
            if (m_result)
            {
                PostMessage(WM_COMMAND, m_result);
            }
            break;
    }

    return 0;
}

//******************************************************************************
void CDlgFileSearch::OnSelChangeDrives()
{
    m_butSearch.EnableWindow(!m_pWinThread && m_listDrives.GetSelCount() > 0);
}

//******************************************************************************
void CDlgFileSearch::OnSelChangeExts()
{
    m_butOk.EnableWindow(!m_pWinThread && m_listExts.GetSelCount() > 0);
}

//******************************************************************************
void CDlgFileSearch::OnSearch()
{
    // Build a drive mask of all the selected drives.
    m_dwDrives = 0;
    for (int i = 0, count = m_listDrives.GetCount(); i < count; i++)
    {
        if (m_listDrives.GetSel(i))
        {
            m_dwDrives |= (1 << m_listDrives.GetItemData(i));
        }
    }

    // Make sure we have at least one drive.
    if (!m_dwDrives)
    {
        return;
    }

    // Start our animation.
    m_animate.Play(0, (UINT)-1, (UINT)-1);

    // Update our window states.
    m_listDrives.EnableWindow(FALSE);
    m_listExts.EnableWindow(FALSE);
    m_butSearch.EnableWindow(FALSE);
    m_butStop.EnableWindow(TRUE);
    m_butOk.EnableWindow(FALSE);

    // Clear our abort flag.
    m_fAbort = FALSE;

    // Create an MFC thread - we create it 1 point below normal since it can take
    // some time to process all the drives and the user will probably want to go
    // do something productive while waiting.
    if (!(m_pWinThread = AfxBeginThread(StaticThread, this, THREAD_PRIORITY_BELOW_NORMAL, 0, CREATE_SUSPENDED)))
    {
        OnMainThreadCallback(FSF_SEARCH_DONE, 0);
        return;
    }

    // Tell MFC to auto-delete us when the thread completes.
    m_pWinThread->m_bAutoDelete = TRUE;

    // Now that we have returned from AfxBeginThread and set auto-delete, we resume the thread.
    m_pWinThread->ResumeThread();
}

//******************************************************************************
void CDlgFileSearch::OnStop()
{
    m_fAbort = TRUE;
}

//******************************************************************************
void CDlgFileSearch::OnOK()
{
    if (m_pWinThread)
    {
        m_result = IDOK;
        m_fAbort = TRUE;
    }
    else
    {
        m_strExts = ":";
        for (int i = 0, count = m_listExts.GetCount(); i < count; i++)
        {
            if (m_listExts.GetSel(i))
            {
                m_listExts.GetText(i, m_szPath);
                StrCCat(m_szPath, ":", sizeof(m_szPath));
                m_strExts += m_szPath;
            }
        }
        CDialog::OnOK();
    }
}

//******************************************************************************
void CDlgFileSearch::OnCancel()
{
    if (m_pWinThread)
    {
        m_result = IDCANCEL;
        m_fAbort = TRUE;
    }
    else
    {
        CDialog::OnCancel();
    }
}


//******************************************************************************
// CDlgFileSearch :: Private functions
//******************************************************************************

DWORD CDlgFileSearch::Thread()
{
    // Loop through all 26 drives (A:\ through Z:\).
    for (int i = 0; (i < 26) && !m_fAbort; i++)
    {
        // Check to see if this drive is selected.
        if ((1 << i) & m_dwDrives)
        {
            // Build the drive string and start processing it.
            SCPrintf(m_szPath, sizeof(m_szPath), "%c:\\", (CHAR)((int)'A' + i));
            SendMessage(WM_MAIN_THREAD_CALLBACK, FSF_START_DRIVE, i);
            RecurseDirectory();
            SendMessage(WM_MAIN_THREAD_CALLBACK, FSF_STOP_DRIVE, i);
        }
    }

    SendMessage(WM_MAIN_THREAD_CALLBACK, FSF_SEARCH_DONE);

    return 0;
}

//******************************************************************************
VOID CDlgFileSearch::RecurseDirectory()
{
    HANDLE hFind;

    // Remember where the end of our path is.
    LPSTR pszPathEnd = m_szPath + strlen(m_szPath);

    // Append the search spec to our path.
    StrCCpy(pszPathEnd, "*", sizeof(m_szPath) - (int)(pszPathEnd - m_szPath));

    // Start the search.
    if ((hFind = FindFirstFile(m_szPath, &m_w32fd)) != INVALID_HANDLE_VALUE)
    {
        // Process each file/directory.
        do
        {
            // Check to see if it is a directory.
            if (m_w32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // Make sure it is not the "." or ".." directories.
                if (strcmp(m_w32fd.cFileName, TEXT(".")) && strcmp(m_w32fd.cFileName, TEXT("..")))
                {
                    // Build the full path to the new directory and recurse into it.
                    StrCCat(StrCCpy(pszPathEnd, m_w32fd.cFileName, sizeof(m_szPath) - (int)(pszPathEnd - m_szPath)),
                            TEXT("\\"), sizeof(m_szPath) - (int)(pszPathEnd - m_szPath));
                    RecurseDirectory();
                }
            }

            // Otherwise, it must be a file.
            else
            {
                // Build the full path to the file and process it.
                StrCCpy(pszPathEnd, m_w32fd.cFileName, sizeof(m_szPath) - (int)(pszPathEnd - m_szPath));
                ProcessFile();
            }

            // Get the next file or directory.
        } while (!m_fAbort && FindNextFile(hFind, &m_w32fd));

        // Close the search.
        FindClose(hFind);
    }
}

//******************************************************************************
VOID CDlgFileSearch::ProcessFile()
{
    // Bail out now if the file size is too small to be an executable.
    if ((m_w32fd.nFileSizeHigh == 0) &&
        (m_w32fd.nFileSizeLow < (sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS))))
    {
        return;
    }

    // Locate the extension - bail out if we have no extension.
    LPSTR pszExt = strrchr(m_w32fd.cFileName, '.') + 1;
    if ((pszExt == (LPSTR)1) || !*pszExt)
    {
        return;
    }

    // Check to see if we have already found this extension type.
    CHAR szBuf[countof(m_w32fd.cFileName) + 2];
    SCPrintf(szBuf, sizeof(szBuf), ":%s:", pszExt);
    _strupr(szBuf);
    if (m_strExts.Find(szBuf) >= 0)
    {
        return;
    }

    HANDLE hFile = CreateFile(m_szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, // inspected. full paths only.
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    // Read an IMAGE_DOS_HEADER structure and check for the DOS signature ("MZ").
    IMAGE_DOS_HEADER idh;
    if (!ReadBlock(hFile, &idh, sizeof(idh)) || (idh.e_magic != IMAGE_DOS_SIGNATURE))
    {
        CloseHandle(hFile);
        return;
    }

    // Set the file position to the signature field.
    if (!SetFilePointer(hFile, idh.e_lfanew, 0, FILE_BEGIN))
    {
        CloseHandle(hFile);
        return;
    }

    // Read the signature and check for the NT/PE signature ("PE\0\0").
    DWORD dwSignature = 0;
    if (!ReadBlock(hFile, &dwSignature, sizeof(dwSignature)) ||
        (dwSignature != IMAGE_NT_SIGNATURE))
    {
        CloseHandle(hFile);
        return;
    }

    // Close the file.
    CloseHandle(hFile);

    // Remember this extension.
    m_strExts += (szBuf + 1);

    // Update our UI.
    szBuf[strlen(szBuf) - 1] = '\0';
    SendMessage(WM_MAIN_THREAD_CALLBACK, FSF_ADD_EXT, (LPARAM)(szBuf + 1));
}


//******************************************************************************
//****** CDlgSearchOrder
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgSearchOrder, CDialog)
    //{{AFX_MSG_MAP(CDlgSearchOrder)
    ON_WM_INITMENU()
    ON_WM_GETMINMAXINFO()
    ON_WM_SIZE()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
    ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_ADD_DIRECTORY, OnAddDirectory)
    ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
    ON_EN_CHANGE(IDC_DIRECTORY, OnChangeDirectory)
    ON_NOTIFY(TVN_SELCHANGED, IDC_AVAILABLE_SEARCHES, OnSelChangedAvailable)
    ON_NOTIFY(TVN_SELCHANGED, IDC_CURRENT_ORDER, OnSelChangedCurrent)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_AVAILABLE_SEARCHES, OnItemExpanding)
    ON_BN_CLICKED(IDC_EXPAND, OnExpand)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_CURRENT_ORDER, OnItemExpanding)
    ON_BN_CLICKED(IDC_LOAD, OnLoad)
    ON_BN_CLICKED(IDC_SAVE, OnSave)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
CDlgSearchOrder::CDlgSearchOrder(CSearchGroup *psgHead, bool fReadOnly /*=false*/,
                                 LPCSTR pszApp /*=NULL*/, LPCSTR pszTitle /*=NULL*/) :
    CDialog(CDlgSearchOrder::IDD, NULL),
    m_fInitialized(false),
    m_fReadOnly(fReadOnly),
    m_fExpanded(true),
    m_fInOnExpand(false),
    m_pszApp(pszApp),
    m_pszTitle(pszTitle),
    m_psgHead(psgHead),
    m_sPadding(0, 0),
    m_sButton(0, 0),
    m_cyStatic(0),
    m_cyButtonPadding(0),
    m_cxAddRemove(0),
    m_cxAddDirectory(0),
    m_ptMinTrackSize(0, 0)
{
    //{{AFX_DATA_INIT(CDlgSearchOrder)
    //}}AFX_DATA_INIT
}

//******************************************************************************
CDlgSearchOrder::~CDlgSearchOrder()
{
}

//******************************************************************************
void CDlgSearchOrder::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgSearchOrder)
    DDX_Control(pDX, IDC_AVAILABLE_SEARCHES_TEXT, m_staticAvailable);
    DDX_Control(pDX, IDC_AVAILABLE_SEARCHES, m_treeAvailable);
    DDX_Control(pDX, IDC_ADD, m_butAdd);
    DDX_Control(pDX, IDC_REMOVE, m_butRemove);
    DDX_Control(pDX, IDC_CURRENT_ORDER_TEXT, m_staticCurrent);
    DDX_Control(pDX, IDC_CURRENT_ORDER, m_treeCurrent);
    DDX_Control(pDX, IDC_ADD_DIRECTORY, m_butAddDirectory);
    DDX_Control(pDX, IDC_DIRECTORY, m_editDirectory);
    DDX_Control(pDX, IDC_BROWSE, m_butBrowse);
    DDX_Control(pDX, IDOK, m_butOk);
    DDX_Control(pDX, IDCANCEL, m_butCancel);
    DDX_Control(pDX, IDC_EXPAND, m_butExpand);
    DDX_Control(pDX, IDC_MOVE_UP, m_butMoveUp);
    DDX_Control(pDX, IDC_MOVE_DOWN, m_butMoveDown);
    DDX_Control(pDX, IDC_LOAD, m_butLoad);
    DDX_Control(pDX, IDC_SAVE, m_butSave);
    DDX_Control(pDX, IDC_DEFAULT, m_butDefault);
    //}}AFX_DATA_MAP
}

//******************************************************************************
BOOL CDlgSearchOrder::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Make sure our dialog resource has the following styles...
    // STYLE DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
    // The resource editor will strip off the WS_THICKFRAME every time we edit it.
    ASSERT((GetStyle() & (DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME)) ==
           (DS_MODALFRAME | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME));

    // Modify our title to reflect what the user is seeing.
    if (m_fReadOnly)
    {
        CHAR szCaption[1024];
        SCPrintf(szCaption, sizeof(szCaption), "Module Search Order (%s)",
                 m_pszTitle ? m_pszTitle : "Snapshot from DWI file");
        SetWindowText(szCaption);
    }
    else
    {
        SetWindowText("Module Search Order (Local)");
    }

    BOOL fGroupAdded[SG_COUNT];
    ZeroMemory(fGroupAdded, sizeof(fGroupAdded)); // inspected

    // Make sure all our children know to clip each other since we allow resizing.
    m_staticCurrent.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_treeCurrent.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butOk.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butExpand.ModifyStyle(0, WS_CLIPSIBLINGS);
    m_butExpand.SetCheck(1);
    m_butSave.ModifyStyle(0, WS_CLIPSIBLINGS);

    if (m_fReadOnly)
    {
        m_butOk.SetWindowText("&Close");
        m_staticAvailable.ShowWindow(SW_HIDE);
        m_treeAvailable.ShowWindow(SW_HIDE);
        m_butAdd.ShowWindow(SW_HIDE);
        m_butRemove.ShowWindow(SW_HIDE);
        m_butAddDirectory.ShowWindow(SW_HIDE);
        m_editDirectory.ShowWindow(SW_HIDE);
        m_butBrowse.ShowWindow(SW_HIDE);
        m_butCancel.ShowWindow(SW_HIDE);
        m_butMoveUp.ShowWindow(SW_HIDE);
        m_butMoveDown.ShowWindow(SW_HIDE);
        m_butLoad.ShowWindow(SW_HIDE);
        m_butDefault.ShowWindow(SW_HIDE);
    }
    else
    {
        m_staticAvailable.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_treeAvailable.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butAdd.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butRemove.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butAddDirectory.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_editDirectory.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butBrowse.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butCancel.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butMoveUp.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butMoveDown.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butLoad.ModifyStyle(0, WS_CLIPSIBLINGS);
        m_butDefault.ModifyStyle(0, WS_CLIPSIBLINGS);
    }

    // Limit the length of our edit box.
    m_editDirectory.LimitText(DW_MAX_PATH - 1);

    // Create our size gripper.
    m_Sizer.Create(this);

    // Attach our global image list to the tree controls.
    m_treeCurrent.SetImageList(&g_theApp.m_ilSearch, TVSIL_NORMAL);
    m_treeAvailable.SetImageList(&g_theApp.m_ilSearch, TVSIL_NORMAL);

    // Temporarily select the tree control's font into our DC.
    HDC hDC = ::GetDC(GetSafeHwnd());
    HFONT hFontTree = (HFONT)m_treeAvailable.SendMessage(WM_GETFONT);
    HFONT hFontStock = (HFONT)::SelectObject(hDC, hFontTree);
    CSize sTemp, sTree(0, 0);

    // Add all the current search groups to the "Current" list.
    for (CSearchGroup *psgCur = m_psgHead; psgCur; psgCur = psgCur->GetNext())
    {
        AddSearchGroup(&m_treeCurrent, psgCur);

        // Check to see if this is a new widest entry.
        ::GetTextExtentPoint(hDC, psgCur->GetName(), (int)strlen(psgCur->GetName()), &sTemp);
        if (sTree.cx < sTemp.cx)
        {
            sTree.cx = sTemp.cx;
        }

        fGroupAdded[psgCur->GetType()] = TRUE;
    }

    // Add all the remaining search groups to the "Available" list if we are not read only.
    if (!m_fReadOnly)
    {
        for (int type = 1; type < SG_COUNT; type++)
        {
            if (!fGroupAdded[type])
            {
                psgCur = new CSearchGroup((SEARCH_GROUP_TYPE)type, SGF_NOT_LINKED, m_pszApp);
                if (!psgCur)
                {
                    RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
                }
                AddSearchGroup(&m_treeAvailable, psgCur);

                // Check to see if this is a new widest entry.
                ::GetTextExtentPoint(hDC, psgCur->GetName(), (int)strlen(psgCur->GetName()), &sTemp);
                if (sTree.cx < sTemp.cx)
                {
                    sTree.cx = sTemp.cx;
                }
            }
        }
    }

    // Restore our DC.
    ::SelectObject(hDC, hFontStock);
    ::ReleaseDC(GetSafeHwnd(), hDC);

    // Add the borders and scroll bar widths to our widest text line.
    sTree.cx += (2 * GetSystemMetrics(SM_CXBORDER)) + GetSystemMetrics(SM_CXVSCROLL) + 28;

    // Compute our buffer size around controls.
    CRect rc, rc2;
    m_staticAvailable.GetWindowRect(&rc);
    ScreenToClient(&rc.TopLeft());
    m_sPadding = CSize(rc.left, rc.top);

    // Get our text height.
    m_staticAvailable.GetWindowRect(&rc);
    m_cyStatic = rc.Height();

    // Get our button size.
    m_butOk.GetWindowRect(&rc);
    m_sButton = rc.Size();

    int cx;

    if (m_fReadOnly)
    {
        // Determine our minimum size window.
        m_ptMinTrackSize.x = (2 * GetSystemMetrics(SM_CXSIZEFRAME)) +
                             (3 * m_sPadding.cx) + (2 * m_sButton.cx);
        m_ptMinTrackSize.y = (2 * GetSystemMetrics(SM_CYSIZEFRAME)) + GetSystemMetrics(SM_CYCAPTION) +
                             (2 * m_sPadding.cy) + m_cyStatic + (5 * m_sButton.cy) + (2 * m_cyButtonPadding);

        // Get the desired width of our window.
        cx = (2 * GetSystemMetrics(SM_CXSIZEFRAME)) +
             (3 * m_sPadding.cx) + sTree.cx + m_sButton.cx;
    }
    else
    {
        // Get the buffer distance between buttons.
        m_butCancel.GetWindowRect(&rc2);
        m_cyButtonPadding = rc2.top - (rc.top + rc.Height());

        // Get our add/remove button widths.
        m_butAdd.GetWindowRect(&rc);
        m_cxAddRemove = rc.Width();

        // Get our add directory button width.
        m_butAddDirectory.GetWindowRect(&rc);
        m_cxAddDirectory = rc.Width();

        // Determine our minimum size window.
        m_ptMinTrackSize.x = (2 * GetSystemMetrics(SM_CXSIZEFRAME)) +
                             (4 * m_sPadding.cx) + (2 * m_cxAddDirectory) + m_sButton.cx;
        m_ptMinTrackSize.y = (2 * GetSystemMetrics(SM_CYSIZEFRAME)) + GetSystemMetrics(SM_CYCAPTION) +
                             (3 * m_sPadding.cy) + m_cyStatic + (13 * m_sButton.cy) + (7 * m_cyButtonPadding);

        // Get the desired width of our window.
        cx = (2 * GetSystemMetrics(SM_CXSIZEFRAME)) +
             (5 * m_sPadding.cx) + (2 * sTree.cx) + m_cxAddRemove + m_sButton.cx;
    }

    m_fInitialized = true;

    // Make sure we update any buttons that need updating.
    OnSelChangedCurrent(NULL, NULL);
    OnSelChangedAvailable(NULL, NULL);
    OnChangeDirectory();

    // Compute the max size window we can handle.  We first check to see if
    // GetSystemMetrics(SM_CXMAXIMIZED) returns a value.  If so, we use it.
    // If it returns 0, then we are probably running NT 3.51 and we just use
    // GetSystemMetrics(SM_CXSCREEN).
    int cxMax = GetSystemMetrics(SM_CXMAXIMIZED) ?
               (GetSystemMetrics(SM_CXMAXIMIZED) - (2 * GetSystemMetrics(SM_CXSIZEFRAME))) :
                GetSystemMetrics(SM_CXSCREEN);

    // Make sure this window will fit on our screen
    if (cx > cxMax)
    {
        cx = cxMax;
    }

    // Set our window position.
    SetWindowPos(NULL, 0, 0, cx, 400, SWP_NOMOVE | SWP_NOZORDER);
    CenterWindow();

    return TRUE;
}

//******************************************************************************
void CDlgSearchOrder::OnInitMenu(CMenu* pMenu)
{
    // Call base class.
    CDialog::OnInitMenu(pMenu);

    // Remove the "Minimize" item from our system menu.
    pMenu->RemoveMenu(SC_MINIMIZE, MF_BYCOMMAND);

    // Adjust the "Maximize" and "Restore" items depending on in we are maximized.
    // We need to do this based on different behavior on different OSs.  NT 4 seems
    // to enable everything.  NT 5 seems to disable everything.
    BOOL fMaximized  = IsZoomed();
    pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | (fMaximized ? MF_GRAYED  : MF_ENABLED));
    pMenu->EnableMenuItem(SC_RESTORE,  MF_BYCOMMAND | (fMaximized ? MF_ENABLED : MF_GRAYED ));
}

//******************************************************************************
void CDlgSearchOrder::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
    if (m_fInitialized)
    {
        lpMMI->ptMinTrackSize = m_ptMinTrackSize;
    }
    CDialog::OnGetMinMaxInfo(lpMMI);
}

//******************************************************************************
void CDlgSearchOrder::OnSize(UINT nType, int cx, int cy)
{
    CDialog::OnSize(nType, cx, cy);

    if (!m_fInitialized)
    {
        return;
    }

    if (m_fReadOnly)
    {
        // Move current static text
        CRect rc(m_sPadding.cx, m_sPadding.cy, cx - (2 * m_sPadding.cx) - m_sButton.cx, m_sPadding.cy + m_cyStatic);
        m_staticCurrent.MoveWindow(&rc, TRUE);

        // Move current tree
        rc.top    = rc.bottom;
        rc.bottom = cy - m_sPadding.cy;
        m_treeCurrent.MoveWindow(&rc, TRUE);

        // Move Close button
        rc.left   = cx - m_sPadding.cx - m_sButton.cx;
        rc.top    = m_sPadding.cy + m_cyStatic;
        rc.right  = rc.left + m_sButton.cx;
        rc.bottom = rc.top + m_sButton.cy;
        m_butOk.MoveWindow(&rc, TRUE);

        // Move Expand button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butExpand.MoveWindow(&rc, TRUE);

        // Move Save button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butSave.MoveWindow(&rc, TRUE);
    }
    else
    {
        int cxTree = (cx - (5 * m_sPadding.cx) - m_sButton.cx - m_cxAddRemove) / 2;
        int cyTree = (cy - (3 * m_sPadding.cy) - m_sButton.cy - m_cyStatic);

        // Move available static text
        CRect rc(m_sPadding.cx, m_sPadding.cy, m_sPadding.cx + cxTree, m_sPadding.cy + m_cyStatic);
        m_staticAvailable.MoveWindow(&rc, TRUE);

        // Move available tree
        rc.top    = rc.bottom;
        rc.bottom = rc.top + cyTree;
        m_treeAvailable.MoveWindow(&rc, TRUE);

        // Move the Add button.
        rc.left   = rc.right + m_sPadding.cx;
        rc.top    = m_sPadding.cy + m_cyStatic + ((cyTree - (2 * m_sButton.cy) - m_cyButtonPadding) / 2);
        rc.right  = rc.left + m_cxAddRemove;
        rc.bottom = rc.top + m_sButton.cy;
        m_butAdd.MoveWindow(&rc, TRUE);

        // Move the Remove button.
        rc.top    = rc.bottom + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butRemove.MoveWindow(&rc, TRUE);

        // Move current static text
        rc.left   = rc.right + m_sPadding.cx;
        rc.top    = m_sPadding.cy;
        rc.right  = rc.left + cxTree;
        rc.bottom = rc.top + m_cyStatic;
        m_staticCurrent.MoveWindow(&rc, TRUE);

        // Move current tree
        rc.top    = rc.bottom;
        rc.bottom = rc.top + cyTree;
        m_treeCurrent.MoveWindow(&rc, TRUE);

        // Move Ok button
        rc.left   = cx - m_sPadding.cx - m_sButton.cx;
        rc.top    = m_sPadding.cy + m_cyStatic;
        rc.right  = rc.left + m_sButton.cx;
        rc.bottom = rc.top + m_sButton.cy;
        m_butOk.MoveWindow(&rc, TRUE);

        // Move Cancel button
        rc.top    = rc.bottom + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butCancel.MoveWindow(&rc, TRUE);

        // Move Expand button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butExpand.MoveWindow(&rc, TRUE);

        // Move "Move Up" button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butMoveUp.MoveWindow(&rc, TRUE);

        // Move "Move Down" button
        rc.top    = rc.bottom + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butMoveDown.MoveWindow(&rc, TRUE);

        // Move Load button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butLoad.MoveWindow(&rc, TRUE);

        // Move Save button
        rc.top    = rc.bottom + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butSave.MoveWindow(&rc, TRUE);

        // Move Default button
        rc.top    = rc.bottom + m_sButton.cy + m_cyButtonPadding;
        rc.bottom = rc.top + m_sButton.cy;
        m_butDefault.MoveWindow(&rc, TRUE);

        // Move Add Directory button
        rc.left   = m_sPadding.cx;
        rc.top    = cy - m_sPadding.cy - m_sButton.cy;
        rc.right  = rc.left + m_cxAddDirectory;
        rc.bottom = rc.top + m_sButton.cy;
        m_butAddDirectory.MoveWindow(&rc, TRUE);

        // Move Directory edit box
        rc.left   = rc.right + m_sPadding.cx;
        rc.right  = (3 * m_sPadding.cx) + (2 * cxTree) + m_cxAddRemove;
        m_editDirectory.MoveWindow(&rc, TRUE);

        // Move Browse button
        rc.left   = cx - m_sPadding.cx - m_sButton.cx;
        rc.right  = rc.left + m_sButton.cx;
        m_butBrowse.MoveWindow(&rc, TRUE);
    }

    // Move our size gripper.
    m_Sizer.Update();
}

//******************************************************************************
HTREEITEM CDlgSearchOrder::AddSearchGroup(CTreeCtrl *ptc, CSearchGroup *psg, HTREEITEM htiPrev /*=TVI_LAST*/)
{
    HTREEITEM hti = ptc->InsertItem(
        TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE | TVIF_PARAM,
        psg->GetName(), 0, 0, m_fExpanded ? TVIS_EXPANDED : 0, TVIS_EXPANDED,
        (LPARAM)psg, TVI_ROOT, htiPrev);

    for (CSearchNode *psn = psg->GetFirstNode(); psn; psn = psn->GetNext())
    {
        // Update this node's flags if we are live.
        DWORD dwFlags = psn->UpdateErrorFlag();

        // Get the image based off of the flags.
        int image = ((dwFlags & SNF_FILE) ? 1 : 3) + ((dwFlags & SNF_ERROR) ? 1 : 0);

        // If this node is a named file, then build the string for it.
        if (dwFlags & SNF_NAMED_FILE)
        {
            CHAR szBuffer[DW_MAX_PATH + MAX_PATH + 4];
            SCPrintf(szBuffer, sizeof(szBuffer), "%s = %s", psn->GetName(), psn->GetPath());

            ptc->InsertItem(
                           TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                           szBuffer, image, image, 0, 0, (LPARAM)psn, hti, TVI_LAST);
        }

        // Otherwise, just add the path.
        else
        {
            ptc->InsertItem(
                           TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                           psn->GetPath(), image, image, 0, 0, (LPARAM)psn, hti, TVI_LAST);
        }
    }

    return hti;
}

//******************************************************************************
HTREEITEM CDlgSearchOrder::GetSelectedGroup(CTreeCtrl *ptc)
{
    HTREEITEM htiParent, hti = ptc->GetSelectedItem();
    while (hti && (htiParent = ptc->GetParentItem(hti)))
    {
        hti = htiParent;
    }
    return hti;
}

//******************************************************************************
HTREEITEM CDlgSearchOrder::MoveGroup(CTreeCtrl *ptcSrc, CTreeCtrl *ptcDst,
                                     HTREEITEM hti /*=NULL*/, HTREEITEM htiPrev /*=TVI_LAST*/)
{
    // If no item is passed in, then we get the selected item.
    if (!hti)
    {
        if (!(hti = GetSelectedGroup(ptcSrc)))
        {
            return NULL;
        }
    }

    // Get the search group object associated with this item.
    CSearchGroup *psg = (CSearchGroup*)ptcSrc->GetItemData(hti);
    if (!psg)
    {
        return NULL;
    }

    // Delete this item.
    ptcSrc->DeleteItem(hti);

    // Add this item to it's new location.
    hti = AddSearchGroup(ptcDst, psg, htiPrev);

    // Select the new item and make sure it is visible.
    ptcDst->SelectItem(hti);
    ptcDst->EnsureVisible(hti);

    // If we are moving from one tree to another, our source list selection
    // automatically gets moved to the next item.  Since this item may be
    // offscreen, we need to ensure it gets scrolled into the view.
    if ((ptcDst != ptcSrc) && (htiPrev = ptcSrc->GetSelectedItem()))
    {
        ptcSrc->EnsureVisible(htiPrev);
    }

    // Give the focus to the source tree.
    ptcSrc->SetFocus();

    return hti;
}

//******************************************************************************
void CDlgSearchOrder::Reorder(CSearchGroup *psgHead)
{
    // We used to call m_treeAvailable.SetRedraw(FALSE) and
    // m_treeCurrent.SetRedraw(FALSE) here, but this was causing us paint
    // problems (repro case: just try to load a DWP file with a single AppDir
    // directive in it - we end up with a blank current tree when there is really
    // an item in it).  We then tried SetRedraw in MoveGroup for each individual
    // move.  This fixed some problems, but still caused problems on Win95 golden
    // (even crashes).  Now, we just don't do any SetRedraw() calls.

    HTREEITEM htiPrev = NULL, hti;
    CSearchGroup *psgInCur, *psgInPrev = NULL, *psg;

    // Loop through each item in the list passed to us.
    for (psgInCur = psgHead; psgInCur; psgInPrev = psgInCur, psgInCur = psgInCur ? psgInCur->m_pNext : psgHead)
    {
        // Loop through all the items in our current list starting at the item just
        // past the items that are already in the right order.
        for (hti = htiPrev ? m_treeCurrent.GetNextSiblingItem(htiPrev) : m_treeCurrent.GetRootItem();
             hti; hti = m_treeCurrent.GetNextSiblingItem(hti))
        {
            // Get the search group object for this item.
            psg = (CSearchGroup*)m_treeCurrent.GetItemData(hti);

            // Check to make sure that the types match, and that either the type is not a user directory
            // or that the user directories match,
            if (psg && (psg->GetType() == psgInCur->GetType()) &&
                ((psg->GetType() != SG_USER_DIR) ||
                 (psg->GetFirstNode() && psgInCur->GetFirstNode() &&
                  !_stricmp(psg->GetFirstNode()->GetPath(), psgInCur->GetFirstNode()->GetPath()))))
            {
                // Make sure the item isn't already in the right place.
                if (m_treeCurrent.GetPrevSiblingItem(hti) == htiPrev)
                {
                    htiPrev = hti;
                    break;
                }

                // Otherwise, we move this item to it's correct position.
                htiPrev = MoveGroup(&m_treeCurrent, &m_treeCurrent, hti, htiPrev ? htiPrev : TVI_FIRST);
                break;
            }
        }

        // If we found what we were looking for in the current list, then we continue with the next type.
        if (hti)
        {
            continue;
        }

        // Loop through all the items in our available list.
        for (hti = m_treeAvailable.GetRootItem(); hti; hti = m_treeAvailable.GetNextSiblingItem(hti))
        {
            // Get the search group object for this item.
            psg = (CSearchGroup*)m_treeCurrent.GetItemData(hti);

            // Check to make sure that the types match, and that either the type is not a user directory
            // or that the user directories match,
            if (psg && (psg->GetType() == psgInCur->GetType()) &&
                ((psg->GetType() != SG_USER_DIR) ||
                 (psg->GetFirstNode() && psgInCur->GetFirstNode() &&
                  !_stricmp(psg->GetFirstNode()->GetPath(), psgInCur->GetFirstNode()->GetPath()))))
            {
                // Move this item to its correct position.
                htiPrev = MoveGroup(&m_treeAvailable, &m_treeCurrent, hti, htiPrev ? htiPrev : TVI_FIRST);
                break;
            }
        }

        // If we did not find this item in either tree, then we add it.
        if (!hti)
        {
            // Remove this node from our linked list.
            if (psgInPrev)
            {
                psgInPrev->m_pNext = psgInCur->m_pNext;
            }
            else
            {
                psgHead = psgInCur->m_pNext;
            }

            // Flag this node as not being linked anymore.
            psgInCur->m_pNext = SGF_NOT_LINKED;

            // Add the node to the list.
            htiPrev = AddSearchGroup(&m_treeCurrent, psgInCur, htiPrev ? htiPrev : TVI_FIRST);

            // Move our current pointer back one so our for loop can move it to the correct node.
            psgInCur = psgInPrev;
        }
    }

    // Remove any items from our current list past the default search order groups.
    while (hti = htiPrev ? m_treeCurrent.GetNextSiblingItem(htiPrev) : m_treeCurrent.GetRootItem())
    {
        MoveGroup(&m_treeCurrent, &m_treeAvailable, hti);
    }

    // Delete any nodes that remain in the list passed to us.
    CSearchGroup::DeleteSearchOrder(psgHead);
}

//******************************************************************************
void CDlgSearchOrder::OnAdd()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Move the selected item from available tree to the current tree
    if (MoveGroup(&m_treeAvailable, &m_treeCurrent))
    {
        // Make sure we update any buttons that need updating.
        OnSelChangedCurrent(NULL, NULL);
        OnSelChangedAvailable(NULL, NULL);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnRemove()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Move the selected item from current tree to the available tree
    if (MoveGroup(&m_treeCurrent, &m_treeAvailable))
    {
        // Make sure we update any buttons that need updating.
        OnSelChangedCurrent(NULL, NULL);
        OnSelChangedAvailable(NULL, NULL);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnExpand()
{
    m_fInOnExpand = true;

    // Toggle our expanded flag and update our button.
    m_butExpand.SetCheck(m_fExpanded = !m_fExpanded);

    UINT uCode = m_fExpanded ? TVE_EXPAND : TVE_COLLAPSE;

    // Just like in CDlgSearchOrder::Reorder(), we used to do the SetRedraw()
    // thing around the following two loops, but it causes invisible items to
    // occur on Windows 2000/XP and maybe others.  The repro case on Win2K was
    // to move SxS to the right, uncheck the expand button, then move KnownDlls
    // to the left.  KnownDlls would appear to be gone, even though it is in the
    // left tree.
    
    // Expand or collapse our available tree items.
    for (HTREEITEM hti = m_treeAvailable.GetRootItem(); hti;
        hti = m_treeAvailable.GetNextSiblingItem(hti))
    {
        m_treeAvailable.Expand(hti, uCode);
    }

    // Expand or collapse our current tree items.
    for (hti = m_treeCurrent.GetRootItem(); hti;
        hti = m_treeCurrent.GetNextSiblingItem(hti))
    {
        m_treeCurrent.Expand(hti, uCode);
    }

    m_fInOnExpand = false;
}

//******************************************************************************
void CDlgSearchOrder::OnMoveUp()
{
    if (m_fReadOnly)
    {
        return;
    }

    HTREEITEM hti = GetSelectedGroup(&m_treeCurrent);
    if (!hti)
    {
        return;
    }
    HTREEITEM htiPrev = m_treeCurrent.GetPrevSiblingItem(hti);
    if (!htiPrev)
    {
        return;
    }
    if (!(htiPrev = m_treeCurrent.GetPrevSiblingItem(htiPrev)))
    {
        htiPrev = TVI_FIRST;
    }

    // Move the selected item from current tree to the available tree
    if (MoveGroup(&m_treeCurrent, &m_treeCurrent, hti, htiPrev))
    {
        // Make sure we update any buttons that need updating.
        OnSelChangedCurrent(NULL, NULL);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnMoveDown()
{
    if (m_fReadOnly)
    {
        return;
    }

    HTREEITEM hti = GetSelectedGroup(&m_treeCurrent);
    if (!hti)
    {
        return;
    }
    HTREEITEM htiPrev = m_treeCurrent.GetNextSiblingItem(hti);
    if (!htiPrev)
    {
        return;
    }

    // Move the selected item from current tree to the available tree
    if (MoveGroup(&m_treeCurrent, &m_treeCurrent, hti, htiPrev))
    {
        // Make sure we update any buttons that need updating.
        OnSelChangedCurrent(NULL, NULL);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnLoad()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Create the dialog. Note: Don't use OFN_EXPLORER as it breaks us on NT 3.51
    CNewFileDialog dlgFile(TRUE, "dwp", NULL,
                           OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN |
                           OFN_FILEMUSTEXIST | OFN_READONLY | OFN_NOCHANGEDIR | OFN_DONTADDTORECENT,
                           "Dependency Walker Search Path (*.dwp)|*.dwp|All Files (*.*)|*||", this);

    // Set the initial directory to the "My Documents" folder to meet logo requirements.
    // Actually, logo requirements don't require the open dialog to to default to
    // "My Documents", but since that is where we default the save dialog to, we might as
    // well attempt to open files from there as well.
    CHAR szInitialDir[DW_MAX_PATH];
    dlgFile.GetOFN().lpstrInitialDir = GetMyDocumentsPath(szInitialDir);

    // Display the dialog and bail if they did not hit Ok.
    if (dlgFile.DoModal() != IDOK)
    {
        return;
    }

    // Load the search order from disk.
    CSearchGroup *psgHead = NULL;
    if (CSearchGroup::LoadSearchOrder(dlgFile.GetPathName(), psgHead))
    {
        // Re-order our search groups to match this new search order.
        Reorder(psgHead);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnSave()
{
    // Create the dialog. Note: Don't use OFN_EXPLORER as it breaks us on NT 3.51
    CNewFileDialog dlgFile(FALSE, "dwp", NULL,
                           OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN |
                           OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR | OFN_DONTADDTORECENT,
                           "Dependency Walker Search Path (*.dwp)|*.dwp|All Files (*.*)|*||", this);

    // Set the initial directory to the "My Documents" folder to meet logo requirements.
    CHAR szInitialDir[DW_MAX_PATH];
    dlgFile.GetOFN().lpstrInitialDir = GetMyDocumentsPath(szInitialDir);

    // Display the dialog and bail if they did not hit Ok.
    if (dlgFile.DoModal() != IDOK)
    {
        return;
    }

    CSearchGroup::SaveSearchOrder(dlgFile.GetPathName(), &m_treeCurrent);
}

//******************************************************************************
void CDlgSearchOrder::OnDefault()
{
    if (m_fReadOnly)
    {
        return;
    }

    Reorder(CSearchGroup::CreateDefaultSearchOrder());
}

//******************************************************************************
void CDlgSearchOrder::OnSelChangedAvailable(NMHDR* pNMHDR, LRESULT* pResult)
{
    if (m_fReadOnly)
    {
        return;
    }

    // Only enable the "Add" button when an item is selected in the "Available" list.
    m_butAdd.EnableWindow(m_treeAvailable.GetSelectedItem() != NULL);

    if (pResult)
    {
        *pResult = 0;
    }
}

//******************************************************************************
void CDlgSearchOrder::OnSelChangedCurrent(NMHDR* pNMHDR, LRESULT* pResult)
{
    if (m_fReadOnly)
    {
        return;
    }

    HTREEITEM hti = GetSelectedGroup(&m_treeCurrent);

    // Only enable the "Remove" button when an item is selected in the "Current" list.
    m_butRemove.EnableWindow(hti != NULL);

    // Only enable the "Move Up" button when an item is selected in the "Current"
    // list and it is not the first item.
    m_butMoveUp.EnableWindow(hti && m_treeCurrent.GetPrevSiblingItem(hti));

    // Only enable the "Move Down" button when an item is selected in the "Current"
    // list and it is not the last item.
    m_butMoveDown.EnableWindow(hti && m_treeCurrent.GetNextSiblingItem(hti));

    if (pResult)
    {
        *pResult = 0;
    }
}

//******************************************************************************
void CDlgSearchOrder::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
    // We eat these messages to prevent the user from collapsing our tree items.
    // The only exception is when we are expanding/collapsing ourself.
    *pResult = m_fInOnExpand ? 0 : 1;
}

//******************************************************************************
void CDlgSearchOrder::OnAddDirectory()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Get the text from the directory edit box.
    CHAR szDirectory[DW_MAX_PATH], *pszTrimmedDirectory;
    m_editDirectory.GetWindowText(szDirectory, sizeof(szDirectory) - 1);

    // Trim off any whitespace.
    pszTrimmedDirectory = TrimWhitespace(szDirectory);

    // Add trailing wack if one is not present.
    AddTrailingWack(pszTrimmedDirectory, sizeof(szDirectory) - (int)(pszTrimmedDirectory - szDirectory));

    // Check to see if it is a directory
    DWORD dwAttribs = GetFileAttributes(pszTrimmedDirectory);
    if ((dwAttribs == 0xFFFFFFFF) || !(dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
        // It is a bad path.  Double check that the user really wishes to add it.
        if (AfxMessageBox("The directory you have entered is invalid.\n\n"
                          "Do you wish to add it to the search order anyway?",
                          MB_YESNO | MB_ICONQUESTION) != IDYES)
        {
            return;
        }
    }

    // Create the new group.
    CSearchGroup *psg = new CSearchGroup(SG_USER_DIR, SGF_NOT_LINKED, m_pszApp, pszTrimmedDirectory);
    if (!psg)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Add the group and ensure it is visible and selected.
    HTREEITEM hti = AddSearchGroup(&m_treeCurrent, psg);
    m_treeCurrent.EnsureVisible(m_treeCurrent.GetChildItem(hti));
    m_treeCurrent.EnsureVisible(hti);
    m_treeCurrent.SelectItem(hti);

    // Give focus to the current tree.
    m_treeCurrent.SetFocus();
}

//******************************************************************************
void CDlgSearchOrder::OnBrowse()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Get the text from the directory edit box.
    CHAR szDirectory[DW_MAX_PATH];
    m_editDirectory.GetWindowText(szDirectory, sizeof(szDirectory));

    // Display our directory chooser dialog.
    LPSTR psz = TrimWhitespace(szDirectory);
    if (DirectoryChooser(psz, sizeof(szDirectory) - (int)(psz - szDirectory), "Choose a search path directory:", this))
    {
        // Update the directory name.
        m_editDirectory.SetWindowText(szDirectory);
    }
}

//******************************************************************************
void CDlgSearchOrder::OnChangeDirectory()
{
    if (m_fReadOnly)
    {
        return;
    }

    // Get the text from the directory edit box.
    CHAR szDirectory[DW_MAX_PATH], *pszCur = szDirectory;
    m_editDirectory.GetWindowText(szDirectory, sizeof(szDirectory) - 1);

    // Look for at least one non whitespace character,
    while (isspace(*pszCur))
    {
        pszCur++;
    }

    // Enable the button is the directory edit control contains a character.
    m_butAddDirectory.EnableWindow(*pszCur != '\0');
}

//******************************************************************************
void CDlgSearchOrder::OnOK()
{
    if (m_fReadOnly)
    {
        CDlgSearchOrder::OnCancel();
        return;
    }

    // If the user had the focus in the directory edit box when they hit return,
    // then we add the directory instead of close the dialog.
    if (GetFocus()->GetSafeHwnd() == m_editDirectory.GetSafeHwnd())
    {
        OnAddDirectory();
        return;
    }

    // Unlink all the items in our available list.
    CSearchGroup *psgCur, *psgLast = NULL;
    for (HTREEITEM hti = m_treeAvailable.GetRootItem(); hti;
        hti = m_treeAvailable.GetNextSiblingItem(hti))
    {
        if (psgCur = (CSearchGroup*)m_treeAvailable.GetItemData(hti))
        {
            psgCur->Unlink();
        }
    }

    // Link up all the items in our current list.
    m_psgHead = NULL;
    for (hti = m_treeCurrent.GetRootItem(); hti;
        hti = m_treeCurrent.GetNextSiblingItem(hti))
    {
        if (psgCur = (CSearchGroup*)m_treeCurrent.GetItemData(hti))
        {
            if (psgLast)
            {
                psgLast->m_pNext = psgCur;
            }
            else
            {
                m_psgHead = psgCur;
            }
            psgCur->m_pNext = NULL;
            psgLast = psgCur;
        }
    }

    // Let the dialog close.
    CDialog::OnOK();
}

//******************************************************************************
BOOL CDlgSearchOrder::DestroyWindow()
{
    if (m_fReadOnly)
    {
        return CDialog::DestroyWindow();
    }

    // Delete any unlinked search group objects associated with each item in our
    // available list.
    CSearchGroup *psgCur;
    for (HTREEITEM hti = m_treeAvailable.GetRootItem(); hti;
        hti = m_treeAvailable.GetNextSiblingItem(hti))
    {
        if ((psgCur = (CSearchGroup*)m_treeAvailable.GetItemData(hti)) && !psgCur->IsLinked())
        {
            delete psgCur;
        }
    }

    // Delete any unlinked search group objects associated with each item in our
    // current list.
    for (hti = m_treeCurrent.GetRootItem(); hti;
        hti = m_treeCurrent.GetNextSiblingItem(hti))
    {
        if ((psgCur = (CSearchGroup*)m_treeCurrent.GetItemData(hti)) && !psgCur->IsLinked())
        {
            delete psgCur;
        }
    }

    return CDialog::DestroyWindow();
}


//******************************************************************************
//****** CDlgAbout
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgAbout, CDialog)
    //{{AFX_MSG_MAP(CDlgAbout)
    ON_WM_SETTINGCHANGE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDlgAbout :: Constructor/Destructor
//******************************************************************************

CDlgAbout::CDlgAbout(CWnd* pParent /*=NULL*/) :
    CDialog(CDlgAbout::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDlgAbout)
    //}}AFX_DATA_INIT
}

//******************************************************************************
// CDlgAbout :: Event handler functions
//******************************************************************************

BOOL CDlgAbout::OnInitDialog()
{
    // Call our MFC base class to make sure the dialog initializes correctly.
    CDialog::OnInitDialog();

    CString strVersion("Version ");
    strVersion += VER_VERSION_STR;

    // Build a compile date string.
    CHAR szDate[64] = "Built on ";
    BuildCompileDateString(szDate + 9, sizeof(szDate) - 9);

    // Fill in a few static members and stamp the date into our dialog.
    SetDlgItemText(IDC_PRODUCT_STR,     VER_PRODUCT_STR);
    SetDlgItemText(IDC_FULLPRODUCT_STR, VER_FULLPRODUCT_STR);
    SetDlgItemText(IDC_VERSION_STR,     strVersion);
    SetDlgItemText(IDC_DEVELOPER_STR,   VER_DEVELOPER_STR);
    SetDlgItemText(IDC_COPYRIGHT_STR,   VER_COPYRIGHT_STR);
    SetDlgItemText(IDC_TIME_STAMP,      szDate);

    // Center our dialog over the parent.
    CenterWindow();

    return TRUE;
}

//******************************************************************************
void CDlgAbout::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    // Call our base class.
    CDialog::OnSettingChange(uFlags, lpszSection);

    // Update our date/time format values.
    g_theApp.QueryLocaleInfo();

    // Build a new compile date string and update our dialog.
    CHAR szDate[64] = "Built on ";
    BuildCompileDateString(szDate + 9, sizeof(szDate) - 9);
    SetDlgItemText(IDC_TIME_STAMP, szDate);
}


//******************************************************************************
//****** CDlgShutdown
//******************************************************************************

BEGIN_MESSAGE_MAP(CDlgShutdown, CDialog)
    //{{AFX_MSG_MAP(CDlgShutdown)
    ON_WM_CLOSE()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDlgShutdown :: Constructor/Destructor
//******************************************************************************

CDlgShutdown::CDlgShutdown(CWnd* pParent /*=NULL*/) :
    CDialog(CDlgShutdown::IDD, pParent),
    m_cTimerMessages(0)
{
    //{{AFX_DATA_INIT(CDlgShutdown)
    //}}AFX_DATA_INIT
}

//******************************************************************************
// CDlgShutdown :: Event handler functions
//******************************************************************************

BOOL CDlgShutdown::OnInitDialog()
{
    // Tell our debugger thread object that a shutdown window is up.
    CDebuggerThread::SetShutdownWindow(GetSafeHwnd());

    // Call base class.
    CDialog::OnInitDialog();

    // Center our dialog over the parent.
    CenterWindow();

    // Set a timer for 1/2 second.
    SetTimer(0, 500, NULL);

    return TRUE;
}

//******************************************************************************
void CDlgShutdown::OnTimer(UINT nIDEvent)
{
    // If we shut down or timed out, then bail.
    if ((++m_cTimerMessages == 10) || CDebuggerThread::IsShutdown())
    {
        KillTimer(0);
        EndDialog(0);
    }
}

//******************************************************************************
void CDlgShutdown::OnClose()
{
    // Do nothing to prevent closing.
}

//******************************************************************************
void CDlgShutdown::OnOK()
{
    // Do nothing to prevent closing.
}

//******************************************************************************
void CDlgShutdown::OnCancel()
{
    // Do nothing to prevent closing.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\depends.h ===
//******************************************************************************
//
// File:        DEPENDS.H
//
// Description: Definition file for the main application, command line parsing
//              classes, and global utility functions.
//             
// Classes:     CMainApp
//              CCommandLineInfoEx
//              CCmdLineProfileData
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __DEPENDS_H__
#define __DEPENDS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __AFXWIN_H__
   #error include 'stdafx.h' before including this file for PCH
#endif

// Just about everyone needs helpers.
#include "helpers.h"


//******************************************************************************
//***** Constants and Macros
//******************************************************************************

#define DW_MAX_PATH                2048

#define WM_MAIN_THREAD_CALLBACK (WM_USER + 1234)

// Profile flags
#define PF_LOG_CLEAR                0x00000001
#define PF_SIMULATE_SHELLEXECUTE    0x00000002
#define PF_LOG_DLLMAIN_PROCESS_MSGS 0x00000004
#define PF_LOG_DLLMAIN_OTHER_MSGS   0x00000008
#define PF_HOOK_PROCESS             0x00000010
#define PF_LOG_GETPROCADDRESS_CALLS 0x00000020
#define PF_LOG_LOADLIBRARY_CALLS    0x00000040
#define PF_LOG_THREADS              0x00000080
#define PF_USE_THREAD_INDEXES       0x00000100
#define PF_LOG_EXCEPTIONS           0x00000200
#define PF_LOG_DEBUG_OUTPUT         0x00000400
#define PF_USE_FULL_PATHS           0x00000800
#define PF_LOG_TIME_STAMPS          0x00001000
#define PF_PROFILE_CHILDREN         0x00002000

// List View Module Columns
#define LVMC_IMAGE              0
#define LVMC_MODULE             1
#define LVMC_FILE_TIME_STAMP    2
#define LVMC_LINK_TIME_STAMP    3
#define LVMC_FILE_SIZE          4
#define LVMC_ATTRIBUTES         5
#define LVMC_LINK_CHECKSUM      6
#define LVMC_REAL_CHECKSUM      7
#define LVMC_MACHINE            8
#define LVMC_SUBSYSTEM          9
#define LVMC_SYMBOLS           10
#define LVMC_PREFERRED_BASE    11
#define LVMC_ACTUAL_BASE       12
#define LVMC_VIRTUAL_SIZE      13
#define LVMC_LOAD_ORDER        14
#define LVMC_FILE_VER          15
#define LVMC_PRODUCT_VER       16
#define LVMC_IMAGE_VER         17
#define LVMC_LINKER_VER        18
#define LVMC_OS_VER            19
#define LVMC_SUBSYSTEM_VER     20
#define LVMC_COUNT             21 // the number of columns
#define LVMC_DEFAULT           LVMC_IMAGE

// List View Function Columns
#define LVFC_IMAGE             0
#define LVFC_ORDINAL           1
#define LVFC_HINT              2
#define LVFC_FUNCTION          3
#define LVFC_ENTRYPOINT        4
#define LVFC_COUNT             5 // the number of columns
#define LVFC_DEFAULT           LVFC_ORDINAL

// Locale constants
#define LOCALE_DATE_MDY        0
#define LOCALE_DATE_DMY        1
#define LOCALE_DATE_YMD        2

// SYSINFO flags.
#define SI_64BIT_OS            0x0001
#define SI_64BIT_DW            0x0002

#ifdef WIN64
#define HEX_FORMAT "0x%016I64X"
#else
#define HEX_FORMAT "0x%08X"
#endif

// Dependency Walker Return Flags
//
//    0x000000FF bits are for info flags
//    0x0000FF00 bits are for warning flags
//    0x00FF0000 bits are for fail-to-load flags
//    0x7F000000 bits are for processing error flags
//
#define DWRF_DYNAMIC_NOT_FOUND        0x00000001 // warning
#define DWRF_DELAYLOAD_NOT_FOUND      0x00000002 // warning
#define DWRF_MISSING_DYNAMIC_EXPORT   0x00000004 // warning
#define DWRF_MISSING_DELAYLOAD_EXPORT 0x00000008 // warning
#define DWRF_FORMAT_NOT_RECOGNIZED    0x00000010 // warning - might fail to load
#define DWRF_MODULE_LOAD_FAILURE      0x00000020 // warning
#define DWRF_FORMAT_NOT_PE            0x00000100 // fail to load
#define DWRF_IMPLICIT_NOT_FOUND       0x00000200 // fail to load
#define DWRF_MISSING_IMPLICIT_EXPORT  0x00000400 // fail to load
#define DWRF_MIXED_CPU_TYPES          0x00000800 // fail to load
#define DWRF_CIRCULAR_DEPENDENCY      0x00001000 // fail to load
#define DWRF_SXS_ERROR                0x00002000 // fail to load
#define DWRF_COMMAND_LINE_ERROR       0x00010000 // processing error
#define DWRF_FILE_NOT_FOUND           0x00020000 // processing error
#define DWRF_FILE_OPEN_ERROR          0x00040000 // processing error
#define DWRF_DWI_NOT_RECOGNIZED       0x00080000 // processing error
#define DWRF_PROFILE_ERROR            0x00100000 // processing error
#define DWRF_WRITE_ERROR              0x00200000 // processing error
#define DWRF_OUT_OF_MEMORY            0x00400000 // processing error
#define DWRF_INTERNAL_ERROR           0x00800000 // processing error

#define DWRF_WARNING_MASK         (DWRF_DYNAMIC_NOT_FOUND        | \
                                   DWRF_DELAYLOAD_NOT_FOUND      | \
                                   DWRF_MISSING_DYNAMIC_EXPORT   | \
                                   DWRF_MISSING_DELAYLOAD_EXPORT | \
                                   DWRF_FORMAT_NOT_RECOGNIZED    | \
                                   DWRF_MODULE_LOAD_FAILURE)
#define DWRF_ERROR_MASK           (DWRF_FORMAT_NOT_PE            | \
                                   DWRF_IMPLICIT_NOT_FOUND       | \
                                   DWRF_MISSING_IMPLICIT_EXPORT  | \
                                   DWRF_MIXED_CPU_TYPES          | \
                                   DWRF_CIRCULAR_DEPENDENCY      | \
                                   DWRF_SXS_ERROR)
#define DWRF_PROCESS_ERROR_MASK   (DWRF_COMMAND_LINE_ERROR       | \
                                   DWRF_FILE_NOT_FOUND           | \
                                   DWRF_FILE_OPEN_ERROR          | \
                                   DWRF_DWI_NOT_RECOGNIZED       | \
                                   DWRF_PROFILE_ERROR            | \
                                   DWRF_WRITE_ERROR              | \
                                   DWRF_OUT_OF_MEMORY            | \
                                   DWRF_INTERNAL_ERROR)


//******************************************************************************
//***** Types and Structures
//******************************************************************************

typedef enum _SAVETYPE
{
    ST_UNKNOWN,
    ST_DWI,
    ST_TXT,
    ST_TXT_IE,
    ST_CSV
} SAVETYPE, *PSAVETYPE;

// KERNEL32.DLL exports
typedef BOOL   (WINAPI *PFN_ActivateActCtx)  (HANDLE, ULONG_PTR *);
typedef BOOL   (WINAPI *PFN_DeactivateActCtx)(DWORD, ULONG_PTR);
typedef HANDLE (WINAPI *PFN_CreateActCtxA)   (PCACTCTXA);
typedef VOID   (WINAPI *PFN_ReleaseActCtx)   (HANDLE);

// IMAGEHLP.DLL exports
typedef PIMAGE_NT_HEADERS (WINAPI   *PFN_CheckSumMappedFile)  (LPVOID, DWORD, LPDWORD, LPDWORD);
typedef DWORD             (WINAPI   *PFN_UnDecorateSymbolName)(LPCSTR, LPSTR, DWORD, DWORD);

// PSAPI.DLL exports
typedef DWORD (WINAPI *PFN_GetModuleFileNameExA)(HANDLE, HMODULE, LPTSTR, DWORD);

// OLE32.DLL exports
typedef HRESULT (STDAPICALLTYPE *PFN_CoInitialize)(LPVOID);
typedef HRESULT (STDAPICALLTYPE *PFN_CoUninitialize)(void);
typedef HRESULT (STDAPICALLTYPE *PFN_CoCreateInstance)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID FAR*);

// OLEAUT32.DLL exports
typedef BSTR (STDAPICALLTYPE *PFN_SysAllocStringLen)(const OLECHAR *, UINT);
typedef void (STDAPICALLTYPE *PFN_SysFreeString)(BSTR);


//******************************************************************************
//***** Forward declarations
//******************************************************************************

class CMainFrame;
class CDocDepends;
class CChildFrame;
class CTreeViewModules;
class CListViewModules;
class CListViewImports;
class CListViewExports;
class CRichViewProfile;
class CSession;
class CSearchGroup;
class CProcess;
class CMsdnHelp;

#include "dialogs.h" //!!

//******************************************************************************
//****** CCommandLineInfoEx
//******************************************************************************

class CCommandLineInfoEx : public CCommandLineInfo
{
protected:
    enum
    {
        OPEN_FILE,
        PROFILE_ARGS,
        AUTO_EXPAND,
        FULL_PATH,
        UNDECORATE,
        MODULE_COLUMN,
        IMPORT_COLUMN,
        EXPORT_COLUMN,
        FUNCTION_COLUMN,
        DWI_FILE,
        TXT_FILE,
        TXT_IE_FILE,
        CSV_FILE,
        DWP_FILE,
        PS_VALUE, // Simulate ShellExecute
        PP_VALUE, // Log DllMain calls for process attach and process detach
        PO_VALUE, // Log DllMain calls for all other messages, including thread attach and thread detach
        PH_VALUE, // Hook
        PL_VALUE, // Log LoadLibrary function calls
        PG_VALUE, // Log GetProcAddress function calls
        PT_VALUE, // Log thread information
        PN_VALUE, // Use simple thread numbers
        PE_VALUE, // Log first chance exceptions
        PM_VALUE, // Log debug output messages
        PF_VALUE, // Use full paths
        PI_VALUE, // Log time stamps
        PC_VALUE, // Automatically open and profile child processes
        PA_VALUE, // Turn all profiling options on or off
        PD_VALUE, // Starting directory
                  // B J K Q R U V W X Y Z are still free
    }       m_expecting;
    char    m_cFlag;
    LPCSTR  m_pszFlag;
    int     m_maxColumn;

public:
    CString m_strError;
    bool    m_fHelp;
    int     m_autoExpand;
    int     m_fullPaths;
    int     m_undecorate;
    int     m_sortColumnModules;
    int     m_sortColumnImports;
    int     m_sortColumnExports;
    bool    m_fConsoleMode;
    bool    m_fProfile;
    int     m_profileSimulateShellExecute;
    int     m_profileLogDllMainProcessMsgs;
    int     m_profileLogDllMainOtherMsgs;
    int     m_profileHookProcess;
    int     m_profileLogLoadLibraryCalls;
    int     m_profileLogGetProcAddressCalls;
    int     m_profileLogThreads;
    int     m_profileUseThreadIndexes;
    int     m_profileLogExceptions;
    int     m_profileLogDebugOutput;
    int     m_profileUseFullPaths;
    int     m_profileLogTimeStamps;
    int     m_profileChildren;
    LPCSTR  m_pszProfileArguments;
    LPCSTR  m_pszProfileDirectory;
    LPCSTR  m_pszDWI;
    LPCSTR  m_pszTXT;
    LPCSTR  m_pszTXT_IE;
    LPCSTR  m_pszCSV;
    LPCSTR  m_pszDWP;

public:
    CCommandLineInfoEx();
    virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
    LPCSTR GetRemainder(LPCSTR pszCurArgv);
};


//******************************************************************************
//****** CMainApp
//******************************************************************************

class CMainApp : public CWinApp
{
// Public variables
public:
    CCommandLineInfoEx       m_cmdInfo;
    bool                     m_fVisible;
    CDocDepends             *m_pNewDoc;
    CProcess                *m_pProcess;

    HINSTANCE                m_hNTDLL;

    HINSTANCE                m_hKERNEL32;
    PFN_CreateActCtxA        m_pfnCreateActCtxA;
    PFN_ActivateActCtx       m_pfnActivateActCtx;
    PFN_DeactivateActCtx     m_pfnDeactivateActCtx;
    PFN_ReleaseActCtx        m_pfnReleaseActCtx;

    HINSTANCE                m_hIMAGEHLP;
    PFN_UnDecorateSymbolName m_pfnUnDecorateSymbolName;

    HINSTANCE                m_hPSAPI;
    PFN_GetModuleFileNameExA m_pfnGetModuleFileNameExA;

    HINSTANCE                m_hOLE32;
    PFN_CoInitialize         m_pfnCoInitialize;
    PFN_CoUninitialize       m_pfnCoUninitialize;
    PFN_CoCreateInstance     m_pfnCoCreateInstance;

    HINSTANCE                m_hOLEAUT32;
    PFN_SysAllocStringLen    m_pfnSysAllocStringLen;
    PFN_SysFreeString        m_pfnSysFreeString;

    CImageList               m_ilTreeModules;
    CImageList               m_ilListModules;
    CImageList               m_ilFunctions;
    CImageList               m_ilSearch;
    CDlgViewer               m_dlgViewer;
    CSearchGroup            *m_psgDefault;
    CMsdnHelp               *m_pMsdnHelp;
    int                      m_nShortDateFormat;
    int                      m_nLongDateFormat;
    bool                     m_f24HourTime;
    bool                     m_fHourLeadingZero;
    char                     m_cDateSeparator;
    char                     m_cTimeSeparator;
    char                     m_cThousandSeparator;
    bool                     m_fNoDelayLoad;
    bool                     m_fNeverDenyProfile;

protected:
    CMultiDocTemplate *m_pDocTemplate;

// Constructor/Destructor
public:
    CMainApp();
    virtual ~CMainApp();

// Public functions
public:
    void      QueryLocaleInfo();
    void      DoSettingChange();
    CSession* CreateNewSession(LPCSTR pszPath, CProcess *pProcess);
    void      RemoveFromRecentFileList(LPCSTR pszPath);
    void      SaveCommandLineSettings();
    void      SaveCommandLineFile(CSession *pSession, CRichEditCtrl *pre);

// Private Functions
protected:
    BOOL InitInstanceWrapped();
    BOOL ProcessCommandLineInfo();
    void EnsureHelpFilesExists();

    static void CALLBACK StaticProfileUpdate(DWORD_PTR dwpCookie, DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CMainApp)
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual int Run();
    virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CMainApp)
    afx_msg void OnFileOpen();
    afx_msg void OnUpdateAutoExpand(CCmdUI* pCmdUI);
    afx_msg void OnAutoExpand();
    afx_msg void OnUpdateViewFullPaths(CCmdUI* pCmdUI);
    afx_msg void OnViewFullPaths();
    afx_msg void OnUpdateViewUndecorated(CCmdUI* pCmdUI);
    afx_msg void OnViewUndecorated();
    afx_msg void OnViewSysInfo();
    afx_msg void OnConfigureExternalViewer();
    afx_msg void OnHandledFileExts();
    afx_msg void OnAppAbout();
    afx_msg void OnConfigureSearchOrder();
    afx_msg void OnConfigureExternalHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//***** CCmdLineProfileData
//******************************************************************************

class CCmdLineProfileData
{
public:
    CRichEditCtrl m_re;
    bool          m_fNewLine;
    CHAR          m_cPrev;

    CCmdLineProfileData() :
        m_fNewLine(true),
        m_cPrev('\0')
    {
    }
};


//******************************************************************************
//***** Global Variables
//******************************************************************************

#ifdef __DEPENDS_CPP__
   #define GLOBAL_DECLARE
   #define GLOBAL_INIT(value) =value
#else
   #define GLOBAL_DECLARE extern
   #define GLOBAL_INIT(value)
#endif

GLOBAL_DECLARE CMainApp    g_theApp;
GLOBAL_DECLARE DWORD       g_dwReturnFlags   GLOBAL_INIT(0);
GLOBAL_DECLARE CMainFrame *g_pMainFrame      GLOBAL_INIT(NULL);
GLOBAL_DECLARE bool        g_fWindowsNT      GLOBAL_INIT(false);
GLOBAL_DECLARE bool        g_f64BitOS        GLOBAL_INIT(false);
GLOBAL_DECLARE LPSTR       g_pszDWInjectPath GLOBAL_INIT(NULL);
GLOBAL_DECLARE LPCSTR      g_pszSettings     GLOBAL_INIT("Settings");

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __DEPENDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\helpers.cpp ===
//******************************************************************************
//
// File:        HELPERS.CPP
//
// Description: Global helper functions.
//             
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 06/03/01  stevemil  Moved over from depends.cpp and modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** Global Helper Functions
//******************************************************************************

#ifdef USE_TRACE_TO_FILE
void TRACE_TO_FILE(LPCTSTR pszFormat, ...)
{
    DWORD dwGLE = GetLastError();

    HANDLE hFile = CreateFile("TRACE.TXT", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    SetFilePointer(hFile, 0, NULL, FILE_END);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        va_list pArgs;
        va_start(pArgs, pszFormat);
        CString str;
        _vsntprintf(str.GetBuffer(1024), 1024, pszFormat, pArgs);
        str.ReleaseBuffer();
        va_end(pArgs);

        // Convert all "\n" to "\r\n"
        str.Replace("\n", "\r\n");
        str.Replace("\r\r\n", "\r\n");

        DWORD dwBytes;
        WriteFile(hFile, str, str.GetLength(), &dwBytes, NULL);
        CloseHandle(hFile);
    }

    SetLastError(dwGLE);
}
#endif

//******************************************************************************
#ifdef _DEBUG
void NameThread(LPCSTR pszName, DWORD dwThreadId /*=(DWORD)-1*/)
{
    struct
    {
        DWORD  dwType;      // Must be 0x00001000
        LPCSTR pszName;      // ANSI string pointer to name.
        DWORD  dwThreadId;  // Thread Id, or -1 for current thread.  Only -1 seems to work.
        DWORD  dwFlags;     // Reserved, must be zero.
    } ThreadName = { 0x00001000, pszName, dwThreadId, 0 };
                                    
    // Raise a magic VC exception.  It needs to be handled when not running under VC.
    __try
    {
        RaiseException(0x406D1388, 0, 4, (ULONG_PTR*)&ThreadName);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}
#endif

//******************************************************************************
int ExceptionFilter(unsigned long ulCode, bool fHandle)
{
    static bool fFatalMsg = false;

    // If we are supposed to handle this error and it was not a memory error,
    // then just return EXCEPTION_EXECUTE_HANDLER to eat the error.
    if (fHandle && (ulCode != STATUS_NO_MEMORY))
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // On Windows XP, when we are debugging depends in the VC debugger, we
    // usually get an invalid handle error from ContinueDebugEvent when the
    // app we are debugging exits.  It seems to be harmless.
    // UPDATE: We were closing the process handle and shouldn't have been.
    // This has been fixed, but this code below is still fine to have.
    if (ulCode == STATUS_INVALID_HANDLE)
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // On an ALPHA64 build, this function was getting called more than once by a
    // single thread for a single critical failure.  It was harmless, but caused
    // the error dialog to display twice.  So, now we only display the dialog once.
    if (!fFatalMsg)
    {
        fFatalMsg = true;

        // We don't want strcpy or MessageBox to cause any problems (which has in the past).
        __try
        {
            // Build the appropriate error message.
            CHAR szError[128];
            if (ulCode == STATUS_NO_MEMORY)
            {
                g_dwReturnFlags |= DWRF_OUT_OF_MEMORY;
                StrCCpy(szError, "Dependency Walker has run out of memory and cannot continue to run.", sizeof(szError));
            }
            else
            {
                g_dwReturnFlags |= DWRF_INTERNAL_ERROR;
                SCPrintf(szError, sizeof(szError), "An internal error (0x%08X) has occurred. Dependency Walker cannot continue to run.", ulCode);
            }

            // Display the error if we are not in console mode.
            if (!g_theApp.m_cmdInfo.m_fConsoleMode)
            {
                fFatalMsg = true;
                ::MessageBox(AfxGetMainWnd()->GetSafeHwnd(), szError, "Dependency Walker Fatal Error", MB_OK | MB_ICONERROR);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // Eat this one.
        }
    }

    // On retail builds, we exit.  For debug builds, we let the exception float to the top.
#ifndef _DEBUG

    // Bail out and return our return flags.
    ExitProcess(g_dwReturnFlags);

#endif

    return EXCEPTION_CONTINUE_SEARCH;
}

//******************************************************************************
int Compare(DWORD dw1, DWORD dw2)
{
    return (dw1 < dw2) ? -1 :
           (dw1 > dw2) ?  1 : 0;
}

//******************************************************************************
int Compare(DWORDLONG dwl1, DWORDLONG dwl2)
{
    return (dwl1 < dwl2) ? -1 :
           (dwl1 > dwl2) ?  1 : 0;
}

//******************************************************************************
LPSTR FormatValue(LPSTR pszBuf, int cBuf, DWORD dwValue)
{
    // Loop on each thousand's group.
    DWORD dw = 0, dwGroup[4] = { 0, 0, 0, 0 }; // 4,294,967,295
    while (dwValue)
    {
        dwGroup[dw++] = dwValue % 1000;
        dwValue /= 1000;
    }

    char c = g_theApp.m_cThousandSeparator;

    // Format the output with commas.
    switch (dw)
    {
        case 4:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u%c%03u", dwGroup[3], c, dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 3:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u", dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 2:  SCPrintf(pszBuf, cBuf, "%u%c%03u", dwGroup[1], c, dwGroup[0]); break;
        default: SCPrintf(pszBuf, cBuf, "%u", dwGroup[0]);
    }

    return pszBuf;
}

//******************************************************************************
LPSTR FormatValue(LPSTR pszBuf, int cBuf, DWORDLONG dwlValue)
{
    // Loop on each thousand's group.
    DWORD dw = 0, dwGroup[7] = { 0, 0, 0, 0, 0, 0, 0 }; // 18,446,744,073,709,551,615
    while (dwlValue)
    {
        dwGroup[dw++] = (DWORD)(dwlValue % (DWORDLONG)1000);
        dwlValue /= 1000;
    }

    char c = g_theApp.m_cThousandSeparator;

    // Format the output with commas.
    switch (dw)
    {
        case 7:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u%c%03u%c%03u%c%03u%c%03u", dwGroup[6], c, dwGroup[5], c, dwGroup[4], c, dwGroup[3], c, dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 6:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u%c%03u%c%03u%c%03u", dwGroup[5], c, dwGroup[4], c, dwGroup[3], c, dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 5:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u%c%03u%c%03u", dwGroup[4], c, dwGroup[3], c, dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 4:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u%c%03u", dwGroup[3], c, dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 3:  SCPrintf(pszBuf, cBuf, "%u%c%03u%c%03u", dwGroup[2], c, dwGroup[1], c, dwGroup[0]); break;
        case 2:  SCPrintf(pszBuf, cBuf, "%u%c%03u", dwGroup[1], c, dwGroup[0]); break;
        default: SCPrintf(pszBuf, cBuf, "%u", dwGroup[0]);
    }

    return pszBuf;
}

//******************************************************************************
LPSTR StrAlloc(LPCSTR pszText)
{
    if (pszText)
    {
        return strcpy((LPSTR)MemAlloc((int)strlen(pszText) + 1), pszText); // inspected - will throw exception on error.
    }
    return NULL;
}

//******************************************************************************
LPVOID MemAlloc(DWORD dwSize)
{
    // Make sure a size was passed to us.
    if (dwSize)
    {
        LPVOID pvMem = malloc(dwSize);
        if (pvMem)
        {
            return pvMem;
        }

        // If we fail to allocate memory, then we are hosed.  Throw an exception
        // that will exit display a dialog and exit our application.
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    return NULL;
}

//******************************************************************************
void MemFree(LPVOID &pvMem)
{
    if (pvMem)
    {
        free(pvMem);
        pvMem = NULL;
    }
}

//******************************************************************************
int SCPrintf(LPSTR pszBuf, int count, LPCSTR pszFormat, ...)
{
    va_list pArgs;
    va_start(pArgs, pszFormat);
    int result = _vsnprintf(pszBuf, count, pszFormat, pArgs);
    pszBuf[count - 1] = '\0';
    va_end(pArgs);

    if ((result < 0) || (result >= count))
    {
        result = (int)strlen(pszBuf);
    }

    return result;
}

//******************************************************************************
int SCPrintfCat(LPSTR pszBuf, int count, LPCSTR pszFormat, ...)
{
    int length = (int)strlen(pszBuf);

    va_list pArgs;
    va_start(pArgs, pszFormat);
    int result = _vsnprintf(pszBuf + length, count - length, pszFormat, pArgs);
    pszBuf[count - 1] = '\0';
    va_end(pArgs);

    if ((result < 0) || (result >= count))
    {
        result = (int)strlen(pszBuf);
    }

    return result + length;
}

//******************************************************************************
LPSTR StrCCpy(LPSTR pszDst, LPCSTR pszSrc, int count)
{
    LPSTR pszDstBase = pszDst;
    if (count > 0)
    {
        // Copy the string over.
        while ((--count > 0) && *pszSrc)
        {
            *pszDst++ = *pszSrc++;
        }

        // Always null terminate
        *pszDst = '\0';
    }

    // Return the start of the destination string.
    return pszDstBase;
}

//******************************************************************************
LPSTR StrCCat(LPSTR pszDst, LPCSTR pszSrc, int count)
{
    LPSTR pszDstBase = pszDst;
    if (count > 0)
    {
        // Walk to the end of the source string.
        while ((--count > 0) && *pszDst)
        {
            pszDst++;
        }
        count++;
        
        // Copy the string over.
        while ((--count > 0) && *pszSrc)
        {
            *pszDst++ = *pszSrc++;
        }
        
        // Always null terminate
        *pszDst = '\0';
    }
    
    // Return the start of the destination string.
    return pszDstBase;
}

//******************************************************************************
LPSTR StrCCpyFilter(LPSTR pszDst, LPCSTR pszSrc, int count)
{
    // This function is just like StrCCpy, except it replaces any control
    // characters (character less than 32) with a 0x04, which is the old
    // "end of text" character.  We use this character simply because it shows up
    // as a diamond when using a DOS font and as a box when using a windows font.

    LPSTR pszDstBase = pszDst;
    if (count > 0)
    {
        while ((--count > 0) && *pszSrc)
        {
            *pszDst++ = (*pszSrc < 32) ? '\004' : *pszSrc;
            pszSrc++;
        }
        *pszDst = '\0';
    }
    return pszDstBase;
}

//******************************************************************************
LPSTR TrimWhitespace(LPSTR pszBuffer)
{
    // Move over leading whitespace.
    while (*pszBuffer && isspace(*pszBuffer))
    {
        pszBuffer++;
    }

    // Walk to end of string.
    LPSTR pszEnd = pszBuffer;
    while (*pszEnd)
    {
        pszEnd++;
    }
    pszEnd--;

    // Move back over whitespace while nulling them out.
    while ((pszEnd >= pszBuffer) && isspace(*pszEnd))
    {
        *(pszEnd--) = '\0';
    }

    return pszBuffer;
}

//******************************************************************************
LPSTR AddTrailingWack(LPSTR pszDirectory, int cDirectory)
{
    // Add trailing wack if one is not present.
    int length = (int)strlen(pszDirectory);
    if ((length > 0) && (length < (cDirectory - 1)) && (pszDirectory[length - 1] != TEXT('\\')))
    {
        pszDirectory[length++] = TEXT('\\');
        pszDirectory[length]   = TEXT('\0');
    }
    return pszDirectory;
}

//******************************************************************************
LPSTR RemoveTrailingWack(LPSTR pszDirectory)
{
    // Remove any trailing wack that may be present in this string.
    int length = (int)strlen(pszDirectory);
    if ((length > 0) && (pszDirectory[length - 1] == '\\'))
    {
        pszDirectory[--length] = '\0';
    }

    // If the directory is a root directory, a trailing wack is needed.
    if ((length == 2) && isalpha(pszDirectory[0]) && (pszDirectory[1] == ':'))
    {
        pszDirectory[2] = '\\';
        pszDirectory[3] = '\0';
    }
    return pszDirectory;
}

//******************************************************************************
LPCSTR GetFileNameFromPath(LPCSTR pszPath)
{
    LPCSTR pszWack = strrchr(pszPath, '\\');
    return (pszWack ? (pszWack + 1) : pszPath);
}

//******************************************************************************
void FixFilePathCase(LPSTR pszPath)
{
    // Make the path lowercase and the file uppercase.
    _strlwr(pszPath);
    _strupr((LPSTR)GetFileNameFromPath(pszPath));
}

//******************************************************************************
BOOL ReadBlock(HANDLE hFile, LPVOID lpBuffer, DWORD dwBytesToRead)
{
    DWORD dwBytesRead = 0;
    if (ReadFile(hFile, lpBuffer, dwBytesToRead, &dwBytesRead, NULL))
    {
        if (dwBytesRead == dwBytesToRead)
        {
            return TRUE;
        }
        SetLastError(ERROR_INVALID_DATA);
    }
    return FALSE;
}

//******************************************************************************
bool WriteBlock(HANDLE hFile, LPCVOID lpBuffer, DWORD dwBytesToWrite /*=(DWORD)-1*/)
{
    if (dwBytesToWrite == (DWORD)-1)
    {
        dwBytesToWrite = (DWORD)strlen((LPCSTR)lpBuffer);
    }
    DWORD dwBytesWritten = 0;
    if (WriteFile(hFile, lpBuffer, dwBytesToWrite, &dwBytesWritten, NULL))
    {
        if (dwBytesWritten == dwBytesToWrite)
        {
            return true;
        }
        SetLastError(ERROR_WRITE_FAULT);
    }
    return false;
}

//******************************************************************************
BOOL ReadString(HANDLE hFile, LPSTR &psz)
{
    // Read in the length of the string.
    WORD wLength = 0;
    if (!ReadBlock(hFile, &wLength, sizeof(wLength)))
    {
        return FALSE;
    }

    // Check for a NULL string and return if one is found.
    if (wLength == 0xFFFF)
    {
        psz = NULL;
        return (SetFilePointer(hFile, 2, NULL, SEEK_CUR) != 0xFFFFFFFF);
    }

    // Read in the string and NULL terminate it.
    psz = (LPSTR)MemAlloc((int)wLength + 1);
    if (!ReadBlock(hFile, psz, (DWORD)wLength))
    {
        MemFree((LPVOID&)psz);
        return FALSE;
    }
    psz[(int)wLength] = '\0';

    // Move over any DWORD-aligned padding.
    if ((wLength + 2) & 0x3)
    {
        if (SetFilePointer(hFile, 4 - (((DWORD)wLength + 2) & 0x3), NULL, SEEK_CUR) == 0xFFFFFFFF)
        {
            MemFree((LPVOID&)psz);
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
BOOL WriteString(HANDLE hFile, LPCSTR psz)
{
    // Create and zero out a buffer.
    CHAR szBuffer[DW_MAX_PATH + 8];
    ZeroMemory(szBuffer, sizeof(szBuffer)); // inspected

    // Compute the length of the string - use 0xFFFF for a NULL pointer.
    int length = psz ? (int)strlen(psz) : 0xFFFF;

    // Store this length in the first WORD of the buffer.
    *(WORD*)szBuffer = (WORD)length;

    // Copy the rest of the string to the buffer.
    if (psz)
    {
        StrCCpy(szBuffer + sizeof(WORD), psz, sizeof(szBuffer) - sizeof(WORD));
    }

    // Compute the DWORD aligned length.
    if (psz)
    {
        // Add 2 for the length WORD and 3 to round up to the nearest DWORD, then
        // mask off the bottom 2 bits to DWORD align it.
        length = (length + (2 + 3)) & ~0x3; 
    }
    else
    {
        length = 4;
    }

    return WriteBlock(hFile, szBuffer, length);
}

//******************************************************************************
bool WriteText(HANDLE hFile, LPCSTR pszLine)
{
    return WriteBlock(hFile, pszLine, (DWORD)strlen(pszLine));
}

//******************************************************************************
bool ReadRemoteMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD dwSize)
{
    // First, lets just try to read using the existing access permissions.
    if (!ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, dwSize, NULL))
    {
        // That failed. Query the current permissions.
        MEMORY_BASIC_INFORMATION mbi;
        ZeroMemory(&mbi, sizeof(mbi)); // inspected
        VirtualQueryEx(hProcess, (LPVOID)lpBaseAddress, &mbi, sizeof(mbi));

        // Attempt to add read permission to the current permissions.
        DWORD dwProtect = PAGE_EXECUTE_WRITECOPY, dwOldProtect;
        switch (mbi.Protect)
        {
            case PAGE_NOACCESS:          dwProtect = PAGE_READONLY;          break;
            case PAGE_READONLY:          dwProtect = PAGE_READONLY;          break;
            case PAGE_READWRITE:         dwProtect = PAGE_READWRITE;         break;
            case PAGE_WRITECOPY:         dwProtect = PAGE_WRITECOPY;         break;
            case PAGE_EXECUTE:           dwProtect = PAGE_EXECUTE_READ;      break;
            case PAGE_EXECUTE_READ:      dwProtect = PAGE_EXECUTE_READ;      break;
            case PAGE_EXECUTE_READWRITE: dwProtect = PAGE_EXECUTE_READWRITE; break;
            case PAGE_EXECUTE_WRITECOPY: dwProtect = PAGE_EXECUTE_WRITECOPY; break;
        }
        VirtualProtectEx(hProcess, (LPVOID)lpBaseAddress, dwSize, dwProtect, &dwOldProtect); // inspected

        // Try again, this time with the new permissions.
        if (!ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, dwSize, NULL))
        {
            TRACE("ReadProcessMemory(" HEX_FORMAT ", %u) failed [%u]\n", lpBaseAddress, dwSize, GetLastError());
            return false;
        }
    }
    return true;
}

//******************************************************************************
bool WriteRemoteMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD dwSize, bool fExecute)
{
    ASSERT(g_fWindowsNT || (((DWORD_PTR)lpBaseAddress + (DWORD_PTR)dwSize) <= 0x80000000));

    // Query the current permissions of this memory region.
    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi)); // inspected
    VirtualQueryEx(hProcess, (LPVOID)lpBaseAddress, &mbi, sizeof(mbi));

    DWORD dwProtect = mbi.Protect, dwOldProtect;

    // Check to see if we need to modify the permissions.
    // On NT, we use WRITECOPY, even when the page is already READWRITE.
    if (fExecute)
    {
        dwProtect = g_fWindowsNT ? PAGE_EXECUTE_WRITECOPY : PAGE_EXECUTE_READWRITE;
    }
    else
    {
        switch (mbi.Protect)
        {
            case PAGE_NOACCESS:
            case PAGE_READONLY:
            case PAGE_READWRITE:
                dwProtect = g_fWindowsNT ? PAGE_WRITECOPY : PAGE_READWRITE;
                break;

            case PAGE_EXECUTE:
            case PAGE_EXECUTE_READ:
            case PAGE_EXECUTE_READWRITE:
                dwProtect = g_fWindowsNT ? PAGE_EXECUTE_WRITECOPY : PAGE_EXECUTE_READWRITE;
                break;
        }
    }

    // If we need different permissions, then make the change.
    if (dwProtect != mbi.Protect)
    {
        VirtualProtectEx(hProcess, (LPVOID)lpBaseAddress, dwSize, dwProtect, &dwOldProtect); // inspected
    }

    // Attempt to write to memory.
    if (!WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, dwSize, NULL)) // inspected
    {
        // That failed. Let's try to force the permissions of the entire block to full access.
        VirtualProtectEx(hProcess, (LPVOID)lpBaseAddress, dwSize, // inspected
                         g_fWindowsNT ? PAGE_EXECUTE_WRITECOPY : PAGE_EXECUTE_READWRITE,
                         &dwOldProtect);

        // Try to write one more time...
        if (!WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, dwSize, NULL)) // inspected
        {
            TRACE("WriteProcessMemory() failed [%u]\n", GetLastError());
            return false;
        }
    }

    if (fExecute)
    {
        FlushInstructionCache(hProcess, lpBaseAddress, dwSize);
    }
    return true;
}

//******************************************************************************
bool ReadRemoteString(HANDLE hProcess, LPSTR pszBuffer, int cBuf, LPCVOID lpvAddress, BOOL fUnicode)
{
    if (!pszBuffer || (cBuf <= 0))
    {
        return false;
    }

    *pszBuffer = '\0';

    if (!lpvAddress)
    {
        return false;
    }

    // Check to see if the text we are about to read is UNICODE
    if (fUnicode)
    {
        CHAR  *pLocal = pszBuffer;
        WCHAR *pRemote = (WCHAR*)lpvAddress, pwLocal[2];

        // Read the unicode string one character at a time.
        while ((pLocal < (pszBuffer + cBuf - 2)) &&
               ReadRemoteMemory(hProcess, pRemote, pwLocal, sizeof(WCHAR)) &&
               *pwLocal)
        {
            // Convert the remote unicode char to ansi and store in local buffer.
            pwLocal[1] = L'\0';
            wcstombs(pLocal, pwLocal, 3);

            // Increment local and remote pointers.
            while (*pLocal)
            {
                pLocal++;
            }
            pRemote++;
        }

        // NULL terminate local string.
        *pLocal = '\0';
    }

    // If not UNICODE, then we assume an ANSI file path.
    else
    {
        CHAR *pLocal = pszBuffer, *pRemote = (CHAR*)lpvAddress;

        // Read the string one character at a time.
        while ((pLocal < (pszBuffer + cBuf - 1)) &&
               ReadRemoteMemory(hProcess, pRemote, pLocal, sizeof(CHAR)) &&
               *pLocal)
        {
            // Increment local and remote pointers.
            pLocal++;
            pRemote++;
        }

        // NULL terminate local string.
        *pLocal = '\0';
    }

    return true;
}

//******************************************************************************
LPSTR BuildErrorMessage(DWORD dwError, LPCSTR pszMessage)
{
    // Build the error string,
    CHAR szBuffer[2048];

    // Copy the message into our buffer.
    StrCCpy(szBuffer, pszMessage ? pszMessage : "", sizeof(szBuffer));

    if (dwError)
    {
        // Locate the end of our buffer so we can append to it.
        LPSTR pcBuffer = szBuffer + strlen(szBuffer);

        // Attempt to get an error message from the OS
        LPSTR pszError = NULL;
        DWORD dwLength = FormatMessage( // inspected
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL, dwError, 0, (LPTSTR)&pszError, 0, NULL);

        // Check to see if a valid message came back from FormatMessage
        if (pszError && (dwLength > 1))
        {
            BOOL  fLastCharValid = *szBuffer ? FALSE : TRUE;
            LPSTR pcError = pszError;

            // Copy the error to our buffer one character at a time while stripping
            // out non-printable characters (like CR/LF).
            while (*pcError && ((pcBuffer - szBuffer) < (sizeof(szBuffer) - 2)))
            {
                // Make sure the character is printable.
                // We used to use isprint(), but that can mess up with foreign character sets.
                if ((DWORD)*pcError >= 32)
                {
                    // If one or more of the previous characters was invalid, then
                    // insert a space into our buffer before adding this new valid
                    // character.
                    if (!fLastCharValid)
                    {
                        *(pcBuffer++) = ' ';
                        fLastCharValid = TRUE;
                    }

                    // Copy the valid character into our buffer.
                    *(pcBuffer++) = *(pcError++);
                }
                else
                {
                    // Make note that this character is not valid and move over it.
                    fLastCharValid = FALSE;
                    pcError++;
                }
            }
            // NULL terminate our buffer.
            *pcBuffer = '\0';

            // Walk backwards over whitespace and periods.
            while ((pcBuffer > szBuffer) && (isspace(*(pcBuffer - 1)) || *(pcBuffer - 1) == '.'))
            {
                *(--pcBuffer) = '\0';
            }
        }

        // Free the buffer allocated by FormatMessage()
        if (pszError)
        {
            LocalFree(pszError);
        }

        // If our buffer is still empty somehow (like a NULL szMessage and
        // FormatMessage() failed), then just stuff a generic error message
        // into the buffer.
        if (!*szBuffer)
        {
            StrCCpy(szBuffer, "An unknown error occurred. No error message is available", sizeof(szBuffer));
            pcBuffer += strlen(szBuffer);
        }

        // Now we want to append the error value to the end.  First, make sure
        // error value will fit in the buffer.
        if ((pcBuffer - szBuffer) < (sizeof(szBuffer) - 13))
        {
            // If any of the top 4 bits are set, we will display the error in hex.
            SCPrintf(pcBuffer, sizeof(szBuffer) - (int)(pcBuffer - szBuffer), (dwError & 0xF0000000) ? " (0x%08X)." : " (%u).", dwError);
        }
    }

    // Allocate a string buffer and return it.
    return StrAlloc(szBuffer);
}

//******************************************************************************
LPCSTR GetMyDocumentsPath(LPSTR pszPath)
{
    if (pszPath)
    {
        // Get the IMalloc interface.
        LPMALLOC pMalloc = NULL;
        if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
        {
            // Get the ITEMIDLIST for "My Documents".  We use SHGetSpecialFolderLocation()
            // followed by SHGetPathFromIDList() instead of just SHGetSpecialFolderPath()
            // as it goes back to Win95 gold and NT 3.51.
            LPITEMIDLIST piidl = NULL;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &piidl)) && piidl)
            {
                // Build path string.
                *pszPath = '\0';
                if (!SHGetPathFromIDList(piidl, pszPath) || !*pszPath) //!! there is no way to pass a path length to this!
                {
                    pszPath = NULL;
                }

                // Free the PIDL returned by SHGetSpecialFolderLocation.
                pMalloc->Free(piidl);
                
                return pszPath;
            }
        }
    }
    return NULL;
}

//******************************************************************************
int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    // When the dialog is being initialized, tell it the starting path.
    if (uMsg == BFFM_INITIALIZED)
    {
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
    }
    return 0;
}

//******************************************************************************
bool DirectoryChooser(LPSTR pszDirectory, int cDirectory, LPCSTR pszTitle, CWnd *pParentWnd)
{
    // Before we do anything, get the IMalloc interface.
    LPMALLOC pMalloc = NULL;
    if (!SUCCEEDED(SHGetMalloc(&pMalloc)) || !pMalloc)
    {
        TRACE("SHGetMalloc() failed.\n");
        return false;
    }

    // SHBrowseForFolder() does not like trailing wacks, except for drive roots.
    RemoveTrailingWack(pszDirectory);

    // Set up our BROWSEINFO structure.
    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi)); // inspected
    bi.hwndOwner      = pParentWnd ? pParentWnd->GetSafeHwnd(): AfxGetMainWnd()->GetSafeHwnd();
    bi.pszDisplayName = pszDirectory;
    bi.lpszTitle      = pszTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallbackProc;
    bi.lParam         = (LPARAM)pszDirectory;

    // Prompt user for path.
    LPITEMIDLIST piidl = SHBrowseForFolder(&bi); // inspected.  all callers pass in DW_MAX_PATH pszDirectory.
    if (!piidl)
    {
        return false;
    }

    // Build path string.
    SHGetPathFromIDList(piidl, pszDirectory);

    // Free the PIDL returned by SHBrowseForFolder.
    pMalloc->Free(piidl);

    // Add trailing wack if one is not present.
    AddTrailingWack(pszDirectory, cDirectory);

    return true;
}

//******************************************************************************
bool PropertiesDialog(LPCSTR pszPath)
{
    // Make sure the path is valid.
    if (!pszPath || !*pszPath)
    {
        MessageBeep(MB_ICONERROR);
        return false;
    }

    // Tell the shell to display the properties dialog for this module.
    SHELLEXECUTEINFO sei;
    ZeroMemory(&sei, sizeof(sei)); // inspected
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_INVOKEIDLIST; // this is needed
    sei.lpVerb = "properties";
    sei.lpFile = pszPath;
    sei.nShow = SW_SHOWNORMAL;
    return (ShellExecuteEx(&sei) > 32); // inspected. properties verb used
}

//******************************************************************************
LONG RegSetClassString(LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    return ::RegSetValue(HKEY_CLASSES_ROOT, pszSubKey, REG_SZ, pszValue, (DWORD)strlen(pszValue));
}

//******************************************************************************
void RegisterDwiDwpExtensions()
{
    // Get the full long path to our executable.
    CHAR szPath[DW_MAX_PATH], szBuf[DW_MAX_PATH];
    if (!::GetModuleFileName(AfxGetInstanceHandle(), szBuf, countof(szBuf)))
    {
        return;
    }
    szBuf[sizeof(szBuf) - 1] = '\0';

    // Attempt to convert our long path to a short path.
    if (!::GetShortPathName(szBuf, szPath, countof(szPath)))
    {
        StrCCpy(szPath, szBuf, sizeof(szPath));
    }

    // Add the "/dde" argument to our path.
    StrCCat(szPath, " /dde", sizeof(szPath));

    // Create a ".dwp" key and set it's default value to "dwpfile"
    RegSetClassString(".dwp", "dwpfile");

    // Give our DWP extension a description.
    RegSetClassString("dwpfile", "Dependency Walker Search Path File");

    // Create a ".dwi" key and set it's default value to "dwifile"
    RegSetClassString(".dwi", "dwifile");

    // Give our DWI extension a description.
    RegSetClassString("dwifile", "Dependency Walker Image File");

    // Add our path string as the command for the shell to execute us.
    RegSetClassString("dwifile\\shell\\open\\command", szPath);

    // Add our dde string as the ddeexec argument for the shell to execute us.
    RegSetClassString("dwifile\\shell\\open\\ddeexec", "[open(\"%1\")]");
}

//******************************************************************************
void GetRegisteredExtensions(CString &strExts)
{
    CHAR szExt[DW_MAX_PATH];
    CHAR szValue[DW_MAX_PATH];
    LONG lSize, lResult, i = 0;
    HKEY hKey;

    strExts = ":";

    // Enumerate all the keys under the HKEY_CLASSES_ROOT key.
    while ((lResult = ::RegEnumKey(HKEY_CLASSES_ROOT, i++, szExt, countof(szExt))) != ERROR_NO_MORE_ITEMS)
    {
        szExt[sizeof(szExt) - 1] = '\0';

        // If we found an extension key, then try to get its default value.
        *szValue = '\0';
        if ((lResult == ERROR_SUCCESS) && (szExt[0] == '.') && szExt[1] &&
            !::RegQueryValue(HKEY_CLASSES_ROOT, szExt, szValue, &(lSize = sizeof(szValue))) &&
            *szValue && (lSize < (DW_MAX_PATH - 25)))
        {
            szValue[sizeof(szValue) - 1] = '\0';

            // We append our subkey name to this key and try to open it.
            StrCCat(szValue, "\\shell\\View Dependencies", sizeof(szValue));
            if (!::RegOpenKeyEx(HKEY_CLASSES_ROOT, szValue, 0, KEY_QUERY_VALUE, &hKey))
            {
                // If we successfully opened the key, then close it.
                ::RegCloseKey(hKey);

                // Remember this extension.
                _strupr(szExt + 1);
                strExts += (szExt + 1);
                strExts += ":";
            }
        }
    }
}

//******************************************************************************
BOOL RegDeleteKeyRecursive(HKEY hKey, LPCSTR pszKey)
{
    CHAR szSubKey[256];
    HKEY hSubKey;

    // Open the our current key.
    if (::RegOpenKey(hKey, pszKey, &hSubKey)) // inspected
    {
        return FALSE;
    }

    // Get the first subkey and then recurse into ourself to delete it.
    while (!::RegEnumKey(hSubKey, 0, szSubKey, countof(szSubKey)) &&
           RegDeleteKeyRecursive(hSubKey, szSubKey))
    {
    }

    // Close our key.
    ::RegCloseKey(hSubKey);

    // Delete our key.
    return !::RegDeleteKey(hKey, pszKey);
}

//******************************************************************************
void UnRegisterExtensions(LPCSTR pszExts)
{
    CHAR szBuf[DW_MAX_PATH];
    LONG lSize;
    HKEY hKey;

    // Loop through each type of file extensions that we want to remove.
    for (LPSTR pszExt = (LPSTR)pszExts; pszExt[0] == ':'; )
    {
        // Locate the colon after the extension name.
        for (LPSTR pszEnd = pszExt + 1; *pszEnd && (*pszEnd != ':'); pszEnd++)
        {
        }
        if (!*pszEnd)
        {
            return;
        }

        // Change the first colon to a dot and the second to a NULL.
        *pszExt = '.';
        *pszEnd = '\0';

        // Read the document name for this extension from the registry.
        if (!::RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szBuf, &(lSize = sizeof(szBuf)))) // inspected
        {
            szBuf[sizeof(szBuf) - 1] = '\0';

            StrCCat(szBuf, "\\shell", sizeof(szBuf));
            if (!::RegOpenKey(HKEY_CLASSES_ROOT, szBuf, &hKey)) // inspected
            {
                RegDeleteKeyRecursive(hKey, "View Dependencies");
                RegCloseKey(hKey);
            }
        }

        // Restore the characters we trashed above.
        *pszExt = ':';
        *pszEnd = ':';

        // Move pointer to next extension in our list.
        pszExt = pszEnd;
    }
}

//******************************************************************************
bool RegisterExtensions(LPCSTR pszExts)
{
    // Get the full long path to our executable.
    CHAR szPath[DW_MAX_PATH], szBuf[DW_MAX_PATH];
    if (!::GetModuleFileName(AfxGetInstanceHandle(), szBuf, countof(szBuf)))
    {
        return false;
    }
    szBuf[sizeof(szBuf) - 1] = '\0';

    // Attempt to convert our long path to a short path.
    if (!::GetShortPathName(szBuf, szPath, countof(szPath)))
    {
        StrCCpy(szPath, szBuf, sizeof(szPath));
    }

    // Add the "/dde" argument to our path.
    StrCCat(szPath, " /dde", sizeof(szPath));

    bool fResult = true;

    // Loop through each type of file extensions that we want to add.
    LONG lSize;
    for (LPSTR pszExt = (LPSTR)pszExts; pszExt[0] == ':'; )
    {
        // Locate the colon after the extension name.
        for (LPSTR pszEnd = pszExt + 1; *pszEnd && (*pszEnd != ':'); pszEnd++);

        if (!*pszEnd)
        {
            return fResult;
        }

        // Change the first colon to a dot and the second to a NULL.
        *pszExt = '.';
        *pszEnd = '\0';

        // Read the document name for this extension from the registry.
        if (::RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szBuf, &(lSize = sizeof(szBuf))) || !*szBuf)
        {
            szBuf[sizeof(szBuf) - 1] = '\0';

            // If there is no document type for this extension, then create one and
            // add it to the registry - i.e. "exefile"
            SCPrintf(szBuf, sizeof(szBuf), "%sfile", pszExt + 1);
            _strlwr(szBuf);
            fResult &= (RegSetClassString(pszExt, szBuf) == ERROR_SUCCESS);
        }

        // Build the partial sub key string for our "command" and "ddeexec" keys
        StrCCat(szBuf, "\\shell\\View Dependencies\\", sizeof(szBuf));
        int length = (int)strlen(szBuf);

        // Add our path string as the command for the shell to execute us.
        StrCCpy(szBuf + length, "command", sizeof(szBuf) - length);
        fResult &= (RegSetClassString(szBuf, szPath) == ERROR_SUCCESS);

        // Add our dde string as the ddeexec argument for the shell to execute us.
        StrCCpy(szBuf + length, "ddeexec", sizeof(szBuf) - length);
        fResult &= (RegSetClassString(szBuf, "[open(\"%1\")]") == ERROR_SUCCESS);

        // Restore the characters we trashed above.
        *pszExt = ':';
        *pszEnd = ':';

        // Move pointer to next extension in our list.
        pszExt = pszEnd;
    }

    return fResult;
}

//******************************************************************************
bool ExtractResourceFile(DWORD dwId, LPCSTR pszFile, LPSTR pszPath, int cPath)
{
    // Get our resource handle. We don't care if this fails since NULL should work as well.
    HMODULE hModule = (HMODULE)AfxGetResourceHandle();

    // Load this file from our resource.
    HRSRC   hRsrc;
    LPVOID  lpvFile;
    HGLOBAL hGlobal;
    DWORD   dwFileSize;

    if (!(hRsrc      = FindResource(hModule, MAKEINTRESOURCE(dwId), "FILE")) ||
        !(hGlobal    = LoadResource(hModule, hRsrc)) ||
        !(lpvFile    = LockResource(hGlobal)) ||
        !(dwFileSize = SizeofResource(hModule, hRsrc)))
    {
        // If we cannot find the file to extract, then bail.
        return false;
    }

    // We would like to create this file if it does not already exist, or
    // overwrite the file if it is different then the one we expect.  We make up
    // to 5 passes while trying to create/overwrite the file in case some of
    // the directories are read-only (like if depends.exe is sitting on a
    // read-only share with no help file).  Here is the order we try to create
    // the files:
    //
    // 1) The directory passed to us.
    // 2) The directory depends.exe lives in.
    // 3) The temp directory.
    // 4) The windows directory.
    // 5) The root of the C drive.

    LPSTR pszWack;
    DWORD dwFileLength = (DWORD)strlen(pszFile), dwLength;

    for (int i = 0; i < 5; i++)
    {
        switch (i)
        {
            // The directory passed to us.
            case 0:
                // Check for a valid path.
                if (!*pszPath || !(pszWack = strrchr(pszPath, '\\')))
                {
                    // If the path is not valid, then skip this directory.
                    continue;
                }

                // Null terminate after the final wack.
                *(pszWack + 1) = '\0';
                break;

            // The directory depends.exe lives in.
            case 1:
                // Attempt to get the path of depends.exe
                if (!(dwLength = GetModuleFileName((HMODULE)AfxGetInstanceHandle(), pszPath, cPath - dwFileLength)) ||
                    (dwLength > (cPath - dwFileLength)) ||
                    !(pszWack = strrchr(pszPath, '\\')))
                {
                    // If we did not find a path, then skip this directory.
                    continue;
                }

                // Null terminate after the final wack.
                *(pszWack + 1) = '\0';
                break;

            // The temp directory.
            case 2:
                if (!(dwLength = GetTempPath(cPath - (dwFileLength + 1), pszPath)) ||
                    (dwLength > (cPath - (dwFileLength + 1))))
                {
                    // If we did not find a path, then skip this directory.
                    continue;
                }
                break;

            // The windows directory.
            case 3:
                if (!(dwLength = GetWindowsDirectory(pszPath, cPath - (dwFileLength + 1))) ||
                    (dwLength > (cPath - (dwFileLength + 1))))
                {
                    // If we did not find a path, then skip this directory.
                    continue;
                }
                break;

            // The root of the C drive.
            default:
                StrCCpy(pszPath, "C:\\", cPath);
                break;
        }

        // Check to see if we have a string.
        if (!*pszPath)
        {
            continue;
        }

        // Make sure the directory ends in a wack.
        AddTrailingWack(pszPath, cPath);

        // Append the file name to the path.
        StrCCat(pszPath, pszFile, cPath);

        // Attempt to open this file.
        FILE_MAP fm;
        if (OpenMappedFile(pszPath, &fm))
        {
            // If that succeeded, then check to see if the files are identical.
            bool fEqual = ((fm.dwSize == dwFileSize) && !memcmp(fm.lpvFile, lpvFile, dwFileSize));

            // Close the file map.
            CloseMappedFile(&fm);

            // If we found the file and it is valid, then return success.
            if (fEqual)
            {
                return true;
            }
        }

        // Make sure the file is not read-only.
        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);

        // Attempt to create the file.
        HANDLE hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ, // inspected
                                  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL |
                                  FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        // Check to see if the file was created ok.
        if (hFile != INVALID_HANDLE_VALUE)
        {
            // Write to the file and then close it.
            DWORD dwBytes;
            BOOL fResult = WriteFile(hFile, lpvFile, dwFileSize, &dwBytes, NULL);
            CloseHandle(hFile);

            // If all is well, then bail out now with success.
            if (fResult)
            {
                return true;
            }
        }
    }

    // If we failed all our passes, then give up.
    return false;
}

//******************************************************************************
bool OpenMappedFile(LPCTSTR pszPath, FILE_MAP *pfm)
{
    DWORD dwGLE = ERROR_SUCCESS;
    bool  fSuccess = false;

    // Clear the structure.
    ZeroMemory(pfm, sizeof(FILE_MAP)); // inspected

    __try
    {
        // Open the file for read.
        pfm->hFile = CreateFile(pszPath, GENERIC_READ, FILE_SHARE_READ, NULL, // inspected
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | 
                                FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        // Check for errors.
        if (pfm->hFile == INVALID_HANDLE_VALUE)
        {
            dwGLE = GetLastError();
            __leave;
        }

        // Get the file size.
        pfm->dwSize = GetFileSize(pfm->hFile, &pfm->dwSizeHigh);

        // Check for zero length file.
        if (!pfm->dwSize && !pfm->dwSizeHigh)
        {
            // A zero length file is valid, but can't be mapped.  If the length
            // is 0, then just return success now.
            fSuccess = true;
            __leave;
        }

        // Create a file mapping object for the open module.
        pfm->hMap = CreateFileMapping(pfm->hFile, NULL, PAGE_READONLY, 0, 0, NULL); // inspected

        // Check for errors.
        if (!pfm->hMap)
        {
            dwGLE = GetLastError();
            __leave;
        }     

        // Create a file mapping view for the open module.
        pfm->lpvFile = MapViewOfFile(pfm->hMap, FILE_MAP_READ, 0, 0, 0); // inspected

        // Check for errors.
        if (!pfm->lpvFile)
        {
            dwGLE = GetLastError();
            __leave;
        }

        fSuccess = true;
    }
    __finally
    {
        // If an error occurs, clean up and set the error value
        if (!fSuccess)
        {
            CloseMappedFile(pfm);
            SetLastError(dwGLE);
        }
    }

    return fSuccess;
}

//******************************************************************************
bool CloseMappedFile(FILE_MAP *pfm)
{
    // Close our map view pointer, our map handle, and our file handle.
    if (pfm->lpvFile)
    {
        UnmapViewOfFile(pfm->lpvFile);
        pfm->lpvFile = NULL;
    }

    // Close our map view pointer, our map handle, and our file handle.
    if (pfm->hMap)
    {
        CloseHandle(pfm->hMap);
        pfm->hMap = NULL;
    }

    // Close our map view pointer, our map handle, and our file handle.
    if (pfm->hFile && (pfm->hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(pfm->hFile);
    }
    pfm->hFile = NULL;

    pfm->dwSize     = 0;
    pfm->dwSizeHigh = 0;

    return true;
}

//******************************************************************************
LPSTR BuildCompileDateString(LPSTR pszDate, int cDate)
{
    // The __DATE__ constant should always return the date in "Mmm DD YYYY"
    // format.  This code is a little over cautious in that it is case
    // insensitive and allows for additional whitespace.

    LPCSTR pszSysDate = __DATE__, pszSrc = pszSysDate;
    DWORD  dwDay, dwYear;

    // Walk over any leading whitespace (there shouldn't be any)
    while (isspace(*pszSrc))
    {
        pszSrc++;
    }

    // Decide what month we are in.
    for (int month = 1; (month <= 12) && _strnicmp(pszSrc, GetMonthString(month), 3); month++)
    {
    }

    // If we encounter an error, then just return the system date string.
    if (month > 12)
    {
        return StrCCpy(pszDate, pszSysDate, cDate);
    }

    // Locate first digit of the day field.
    while (*pszSrc && !isdigit(*pszSrc))
    {
        pszSrc++;
    }

    // Store the day value.
    dwDay = strtoul(pszSrc, NULL, 0);
    if (!dwDay || (dwDay > 31))
    {
        return StrCCpy(pszDate, pszSysDate, cDate);
    }

    // Move over the day field.
    while (isdigit(*pszSrc))
    {
        pszSrc++;
    }

    // Locate first digit of the year field.
    while (*pszSrc && !isdigit(*pszSrc))
    {
        pszSrc++;
    }

    // Store the year value.
    dwYear = strtoul(pszSrc, NULL, 0);
    if (!dwYear || (dwYear == ULONG_MAX))
    {
        StrCCpy(pszDate, pszSysDate, cDate);
    }

    // Build the output string.
    if (g_theApp.m_nLongDateFormat == LOCALE_DATE_DMY)
    {
        SCPrintf(pszDate, cDate, "%u %s, %u", dwDay, GetMonthString(month), dwYear);
    }
    else if (g_theApp.m_nLongDateFormat == LOCALE_DATE_YMD)
    {
        SCPrintf(pszDate, cDate, "%u, %s %u", dwYear, GetMonthString(month), dwDay);
    }
    else
    {
        SCPrintf(pszDate, cDate, "%s %u, %u", GetMonthString(month), dwDay, dwYear);
    }

    return pszDate;
}

//******************************************************************************
LPCSTR GetMonthString(int month)
{
    static LPCSTR pszMonths[] =
    {
        "January", "February", "March",     "April",   "May",      "June",
        "July",    "August",   "September", "October", "November", "December"
    };
    return ((month < 1) || (month > countof(pszMonths))) ? "Unknown" : pszMonths[month - 1];
}

//******************************************************************************
LPCSTR GetDayOfWeekString(int dow)
{
    static LPCSTR pszDOW[] =
    {
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    };
    return ((dow < 0) || (dow >= countof(pszDOW))) ? "Unknown" : pszDOW[dow];
}

//******************************************************************************
void DetermineOS()
{
    // Check to see if we are running on Windows NT.
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi)); // inspected
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    g_fWindowsNT = (GetVersionEx(&osvi) && (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT));

    // Check to see if we are running on a 64-bit OS.  If this is the 64-bit
    // version of DW, then it must be running on a 64-bit OS.  If this is the
    // 32-bit version of depends running on NT, then we call
    // NtQueryInformationProcess to see if we are running in WOW64.  If so,
    // then we are on a 64-bit OS.

#ifdef WIN64

    g_f64BitOS = true;

#else

    if (g_fWindowsNT)
    {
        // Load NTDLL.DLL if not already loaded - it will be freed later.
        if (g_theApp.m_hNTDLL || (g_theApp.m_hNTDLL = LoadLibrary("ntdll.dll"))) // inspected.
        {
            // Attempt to locate NtQueryInformationProcess in NTDLL.DLL
            PFN_NtQueryInformationProcess pfnNtQueryInformationProcess =
                (PFN_NtQueryInformationProcess)GetProcAddress(g_theApp.m_hNTDLL, "NtQueryInformationProcess");
            if (pfnNtQueryInformationProcess)
            {
                // Call NtQueryInformationProcess to see if we are running in WOW64.
                LONG_PTR Wow64Info = 0;
                if (NT_SUCCESS(pfnNtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information,
                                                            &Wow64Info, sizeof(Wow64Info), NULL)) && Wow64Info)
                {
                    g_f64BitOS = true;
                }
            }
        }
    }

#endif
}

//******************************************************************************
void BuildSysInfo(SYSINFO *pSI)
{
    DWORD dw;
    ZeroMemory(pSI, sizeof(SYSINFO)); // inspected

    // Store our version info.
    pSI->wMajorVersion = VERSION_MAJOR;
    pSI->wMinorVersion = VERSION_MINOR;
    pSI->wBuildVersion = VERSION_BUILD;
    pSI->wPatchVersion = VERSION_PATCH;
    pSI->wBetaVersion  = VERSION_BETA;

    // GetComputerName()
    if (!GetComputerName(pSI->szComputer, &(dw = countof(pSI->szComputer))))
    {
        StrCCpy(pSI->szComputer, "Unknown", sizeof(pSI->szComputer));
    }

    // GetUserName()
    if (!GetUserName(pSI->szUser, &(dw = countof(pSI->szUser))))
    {
        StrCCpy(pSI->szUser, (GetLastError() == ERROR_NOT_LOGGED_ON) ? "N/A" : "Unknown", sizeof(pSI->szUser));
    }

    // GetVersionEx(OSVERSIONINFOEX)
    OSVERSIONINFOEX osviex;
    ZeroMemory(&osviex, sizeof(osviex)); // inspected
    osviex.dwOSVersionInfoSize = sizeof(osviex);

    // First try to get the full OSVERSIONINFOEX structure.
    // This only works on Windows 98SE and beyond, and Windows 2000 and beyond.
    if (!GetVersionEx((LPOSVERSIONINFO)&osviex))
    {
        // If that fails, then just get the normal OSVERSIONINFO structure.
        ZeroMemory(&osviex, sizeof(osviex)); // inspected
        osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx((LPOSVERSIONINFO)&osviex);
    }

    pSI->dwMajorVersion    = osviex.dwMajorVersion;
    pSI->dwMinorVersion    = osviex.dwMinorVersion;
    pSI->dwBuildNumber     = osviex.dwBuildNumber;
    pSI->dwPlatformId      = osviex.dwPlatformId;
    pSI->wServicePackMajor = osviex.wServicePackMajor;
    pSI->wServicePackMinor = osviex.wServicePackMinor;
    pSI->wSuiteMask        = osviex.wSuiteMask;
    pSI->wProductType      = osviex.wProductType;
    osviex.szCSDVersion[countof(osviex.szCSDVersion) - 1] = '\0';
    StrCCpy(pSI->szCSDVersion, osviex.szCSDVersion, sizeof(pSI->szCSDVersion));

    // Open the CPU description registry key.
    HKEY hKey = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_QUERY_VALUE, &hKey))
    {
        DWORD dwType, dwSize;

        // Attempt to get the Identifier string.  This string should be present on Windows NT and Windows 98 and beyond.
        if (!RegQueryValueEx(hKey, "Identifier", NULL, &(dwType = 0), (LPBYTE)pSI->szCpuIdentifier, // inspected
                            &(dwSize = sizeof(pSI->szCpuIdentifier))) && (REG_SZ == dwType))
        {
            pSI->szCpuIdentifier[sizeof(pSI->szCpuIdentifier) - 1] = '\0';
        }
        else
        {
            *pSI->szCpuIdentifier = '\0';
        }

        // Attempt to get the Vender Identifier string.  For Intel, this should be "GenuineIntel".
        // This string should be present on Windows NT and Windows 95 OSR2 and beyond.
        if (!RegQueryValueEx(hKey, "VendorIdentifier", NULL, &(dwType = 0), (LPBYTE)pSI->szCpuVendorIdentifier, // inspected
                            &(dwSize = sizeof(pSI->szCpuVendorIdentifier))) && (REG_SZ == dwType))
        {
            pSI->szCpuVendorIdentifier[sizeof(pSI->szCpuVendorIdentifier) - 1] = '\0';
        }
        else
        {
            *pSI->szCpuVendorIdentifier = '\0';
        }

        // Attempt to get the CPU speed.  This does not seem to exist on Windows 9x (even Millennium),
        // and only exists on Windows NT starting with NT 4.00.
        if (RegQueryValueEx(hKey, "~MHz", NULL, &(dwType = 0), (LPBYTE)&pSI->dwCpuMHz, &(dwSize = sizeof(pSI->dwCpuMHz))) || // inspected
            (REG_DWORD != dwType))
        {
            pSI->dwCpuMHz = 0;
        }

        RegCloseKey(hKey);
    }

    // GetSystemInfo(SYSTEM_INFO)
    SYSTEM_INFO si;
    ZeroMemory(&si, sizeof(si)); // inspected
    GetSystemInfo(&si);
    pSI->dwProcessorArchitecture      = (DWORD)    si.wProcessorArchitecture;
    pSI->dwPageSize                   =            si.dwPageSize;
    pSI->dwlMinimumApplicationAddress = (DWORDLONG)si.lpMinimumApplicationAddress;
    pSI->dwlMaximumApplicationAddress = (DWORDLONG)si.lpMaximumApplicationAddress;
    pSI->dwlActiveProcessorMask       = (DWORDLONG)si.dwActiveProcessorMask;
    pSI->dwNumberOfProcessors         =            si.dwNumberOfProcessors;
    pSI->dwProcessorType              =            si.dwProcessorType;
    pSI->dwAllocationGranularity      =            si.dwAllocationGranularity;
    pSI->wProcessorLevel              =            si.wProcessorLevel;
    pSI->wProcessorRevision           =            si.wProcessorRevision;

    // Make note if we are on a 64-bit OS.
    if (g_f64BitOS)
    {
        pSI->wFlags |= SI_64BIT_OS;
    }

    // Make note if we are running the 64-bit version of DW.
#ifdef WIN64
    pSI->wFlags |= SI_64BIT_DW;
#endif

    // GlobalMemoryStatus(MEMORYSTATUS)
    MEMORYSTATUS ms;
    ZeroMemory(&ms, sizeof(ms)); // inspected
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus(&ms);
    pSI->dwMemoryLoad     =            ms.dwMemoryLoad;
    pSI->dwlTotalPhys     = (DWORDLONG)ms.dwTotalPhys;
    pSI->dwlAvailPhys     = (DWORDLONG)ms.dwAvailPhys;
    pSI->dwlTotalPageFile = (DWORDLONG)ms.dwTotalPageFile;
    pSI->dwlAvailPageFile = (DWORDLONG)ms.dwAvailPageFile;
    pSI->dwlTotalVirtual  = (DWORDLONG)ms.dwTotalVirtual;
    pSI->dwlAvailVirtual  = (DWORDLONG)ms.dwAvailVirtual;

    //!! We are currently storing local file and link times.  In the future,
    //   we should change this to storing UTC times and converting them on the fly.
    //   This allows us the option of displaying local or utc times in any time
    //   zone, and lets us dynamically update our display when the user changes
    //   a timezone.  To do this, we might need to save more than just a single
    //   Bias.  We might want to save all three bias plus the rules of daylight
    //   savings.  Reminder: take a look at...
    //   http://support.microsoft.com/support/kb/articles/Q128/1/26.asp

    // GetTimeZoneInformation(TIME_ZONE_INFORMATION)
    TIME_ZONE_INFORMATION tzi;
    ZeroMemory(&tzi, sizeof(tzi)); // inspected
    if (GetTimeZoneInformation(&tzi) == TIME_ZONE_ID_DAYLIGHT)
    {
        wcstombs(pSI->szTimeZone, tzi.DaylightName, countof(pSI->szTimeZone));
        pSI->lBias = tzi.Bias + tzi.DaylightBias;
    }
    else
    {
        wcstombs(pSI->szTimeZone, tzi.StandardName, countof(pSI->szTimeZone));
        pSI->lBias = tzi.Bias + tzi.StandardBias;
    }
    pSI->szTimeZone[countof(pSI->szTimeZone) - 1] = '\0';

    // GetSystemTimeAsFileTime() and FileTimeToLocalFileTime()
    FILETIME ftUTC;
    GetSystemTimeAsFileTime(&ftUTC);
    FileTimeToLocalFileTime(&ftUTC, &pSI->ftLocal);

    // GetSystemDefaultLangID()
    pSI->langId = GetSystemDefaultLangID();
}

//******************************************************************************
bool BuildSysInfo(SYSINFO *pSI, PFN_SYSINFOCALLBACK pfnSIC, LPARAM lParam)
{
    bool fResult = true;

    CHAR szBuffer[256], szValue[32], *psz = szBuffer;

    //
    // Build the Dependency Walker version string.
    //
    psz += SCPrintf(szBuffer, sizeof(szBuffer), "%u.%u", (DWORD)pSI->wMajorVersion, (DWORD)pSI->wMinorVersion);
    if (pSI->wBuildVersion)
    {
        psz += SCPrintf(psz, sizeof(szBuffer) - (int)(psz - szBuffer), ".%04u", pSI->wBuildVersion);
    }
    if ((pSI->wPatchVersion > 0) && (pSI->wPatchVersion < 27) && ((psz - szBuffer + 1) < sizeof(szBuffer)))
    {
        *psz++ = (CHAR)((int)'a' - 1 + (int)pSI->wPatchVersion);
        *psz   = '\0';
    }
    if (pSI->wBetaVersion)
    {
        psz += SCPrintf(psz, sizeof(szBuffer) - (int)(psz - szBuffer), " Beta %u", pSI->wBetaVersion);
    }
    StrCCpy(psz, (pSI->wFlags & SI_64BIT_DW) ? " (64-bit)" : " (32-bit)", sizeof(szBuffer) - (int)(psz - szBuffer));

    fResult &= pfnSIC(lParam, "Dependency Walker", szBuffer);

    //
    // Display the OS name string
    //
    fResult &= pfnSIC(lParam, "Operating System", BuildOSNameString(szBuffer, sizeof(szBuffer), pSI));

    //
    // Display the OS version string
    //
    fResult &= pfnSIC(lParam, "OS Version", BuildOSVersionString(szBuffer, sizeof(szBuffer), pSI));

    //
    // Display the CPU description.
    //
    fResult &= pfnSIC(lParam, "Processor", BuildCpuString(szBuffer, sizeof(szBuffer), pSI));

    //
    // Display the number of CPUs and MASK.
    //
    if ((pSI->dwNumberOfProcessors > 1) || (pSI->dwlActiveProcessorMask != 1))
    {
        SCPrintf(szBuffer, sizeof(szBuffer), (pSI->wFlags & SI_64BIT_DW) ? "%s, Mask: 0x%016I64X" : "%s, Mask: 0x%08I64X",
                FormatValue(szValue, sizeof(szValue), pSI->dwNumberOfProcessors), pSI->dwlActiveProcessorMask);
        fResult &= pfnSIC(lParam, "Number of Processors", szBuffer);
    }
    else
    {
        fResult &= pfnSIC(lParam, "Number of Processors", FormatValue(szValue, sizeof(szValue), pSI->dwNumberOfProcessors));
    }

    //
    // Display the Computer Name
    //
    fResult &= pfnSIC(lParam, "Computer Name", pSI->szComputer);

    //
    // Display the User Name
    //
    fResult &= pfnSIC(lParam, "User Name", pSI->szUser);

    //
    // Build the date string according to the user's locale.
    //
    SYSTEMTIME st;
    FileTimeToSystemTime(&pSI->ftLocal, &st);
    if (!GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szBuffer, sizeof(szBuffer)))
    {
        // Fallback to US format if GetDateFormat fails (really shouldn't ever fail)
        SCPrintf(szBuffer, sizeof(szBuffer), "%s, %s %u, %u", GetDayOfWeekString((int)st.wDayOfWeek),
                GetMonthString((int)st.wMonth), (int)st.wDay, (int)st.wYear);
    }
    fResult &= pfnSIC(lParam, "Local Date", szBuffer);

    //
    // Build the time string according to the user's locale.
    //
    if (!GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, szBuffer, sizeof(szBuffer)))
    {
        // Fallback to US format if GetTimeFormat fails (really shouldn't ever fail)
        SCPrintf(szBuffer, sizeof(szBuffer), "%u:%02u %cM", ((DWORD)st.wHour % 12) ? ((DWORD)st.wHour % 12) : 12,
                st.wMinute, (st.wHour < 12) ? _T('A') : _T('P'));
    }
    SCPrintfCat(szBuffer, sizeof(szBuffer), " %s (GMT%c%02d:%02d)",
            pSI->szTimeZone,
            (pSI->lBias <= 0) ? '+' : '-',
            abs(pSI->lBias) / 60,
            abs(pSI->lBias) % 60);

    fResult &= pfnSIC(lParam, "Local Time", szBuffer);

    //
    // Build the language string
    //
    switch (pSI->langId)
    {
        case 0x0000: psz = "Language Neutral";             break;
        case 0x0400: psz = "Process Default Language";     break;
        case 0x0436: psz = "Afrikaans";                    break;
        case 0x041C: psz = "Albanian";                     break;
        case 0x0401: psz = "Arabic (Saudi Arabia)";        break;
        case 0x0801: psz = "Arabic (Iraq)";                break;
        case 0x0C01: psz = "Arabic (Egypt)";               break;
        case 0x1001: psz = "Arabic (Libya)";               break;
        case 0x1401: psz = "Arabic (Algeria)";             break;
        case 0x1801: psz = "Arabic (Morocco)";             break;
        case 0x1C01: psz = "Arabic (Tunisia)";             break;
        case 0x2001: psz = "Arabic (Oman)";                break;
        case 0x2401: psz = "Arabic (Yemen)";               break;
        case 0x2801: psz = "Arabic (Syria)";               break;
        case 0x2C01: psz = "Arabic (Jordan)";              break;
        case 0x3001: psz = "Arabic (Lebanon)";             break;
        case 0x3401: psz = "Arabic (Kuwait)";              break;
        case 0x3801: psz = "Arabic (U.A.E.)";              break;
        case 0x3C01: psz = "Arabic (Bahrain)";             break;
        case 0x4001: psz = "Arabic (Qatar)";               break;
        case 0x042B: psz = "Armenian";                     break;
        case 0x044D: psz = "Assamese";                     break;
        case 0x042C: psz = "Azeri (Latin)";                break;
        case 0x082C: psz = "Azeri (Cyrillic)";             break;
        case 0x042D: psz = "Basque";                       break;
        case 0x0423: psz = "Belarussian";                  break;
        case 0x0445: psz = "Bengali";                      break;
        case 0x0402: psz = "Bulgarian";                    break;
        case 0x0455: psz = "Burmese";                      break;
        case 0x0403: psz = "Catalan";                      break;
        case 0x0404: psz = "Chinese (Taiwan)";             break;
        case 0x0804: psz = "Chinese (PRC)";                break;
        case 0x0C04: psz = "Chinese (Hong Kong SAR, PRC)"; break;
        case 0x1004: psz = "Chinese (Singapore)";          break;
        case 0x1404: psz = "Chinese (Macao SAR)";          break;
        case 0x041A: psz = "Croatian";                     break;
        case 0x0405: psz = "Czech";                        break;
        case 0x0406: psz = "Danish";                       break;
        case 0x0413: psz = "Dutch (Netherlands)";          break;
        case 0x0813: psz = "Dutch (Belgium)";              break;
        case 0x0409: psz = "English (United States)";      break;
        case 0x0809: psz = "English (United Kingdom)";     break;
        case 0x0C09: psz = "English (Australian)";         break;
        case 0x1009: psz = "English (Canadian)";           break;
        case 0x1409: psz = "English (New Zealand)";        break;
        case 0x1809: psz = "English (Ireland)";            break;
        case 0x1C09: psz = "English (South Africa)";       break;
        case 0x2009: psz = "English (Jamaica)";            break;
        case 0x2409: psz = "English (Caribbean)";          break;
        case 0x2809: psz = "English (Belize)";             break;
        case 0x2C09: psz = "English (Trinidad)";           break;
        case 0x3009: psz = "English (Zimbabwe)";           break;
        case 0x3409: psz = "English (Philippines)";        break;
        case 0x0425: psz = "Estonian";                     break;
        case 0x0438: psz = "Faeroese";                     break;
        case 0x0429: psz = "Farsi";                        break;
        case 0x040B: psz = "Finnish";                      break;
        case 0x040C: psz = "French (Standard)";            break;
        case 0x080C: psz = "French (Belgian)";             break;
        case 0x0C0C: psz = "French (Canadian)";            break;
        case 0x100C: psz = "French (Switzerland)";         break;
        case 0x140C: psz = "French (Luxembourg)";          break;
        case 0x180C: psz = "French (Monaco)";              break;
        case 0x0437: psz = "Georgian";                     break;
        case 0x0407: psz = "German (Standard)";            break;
        case 0x0807: psz = "German (Switzerland)";         break;
        case 0x0C07: psz = "German (Austria)";             break;
        case 0x1007: psz = "German (Luxembourg)";          break;
        case 0x1407: psz = "German (Liechtenstein)";       break;
        case 0x0408: psz = "Greek";                        break;
        case 0x0447: psz = "Gujarati";                     break;
        case 0x040D: psz = "Hebrew";                       break;
        case 0x0439: psz = "Hindi";                        break;
        case 0x040E: psz = "Hungarian";                    break;
        case 0x040F: psz = "Icelandic";                    break;
        case 0x0421: psz = "Indonesian";                   break;
        case 0x0410: psz = "Italian (Standard)";           break;
        case 0x0810: psz = "Italian (Switzerland)";        break;
        case 0x0411: psz = "Japanese";                     break;
        case 0x044B: psz = "Kannada";                      break;
        case 0x0860: psz = "Kashmiri (India)";             break;
        case 0x043F: psz = "Kazakh";                       break;
        case 0x0457: psz = "Konkani";                      break;
        case 0x0412: psz = "Korean";                       break;
        case 0x0812: psz = "Korean (Johab)";               break;
        case 0x0426: psz = "Latvian";                      break;
        case 0x0427: psz = "Lithuanian";                   break;
        case 0x0827: psz = "Lithuanian (Classic)";         break;
        case 0x042F: psz = "Macedonian";                   break;
        case 0x043E: psz = "Malay (Malaysian)";            break;
        case 0x083E: psz = "Malay (Brunei Darussalam)";    break;
        case 0x044C: psz = "Malayalam";                    break;
        case 0x0458: psz = "Manipuri";                     break;
        case 0x044E: psz = "Marathi";                      break;
        case 0x0861: psz = "Nepali (India)";               break;
        case 0x0414: psz = "Norwegian (Bokmal)";           break;
        case 0x0814: psz = "Norwegian (Nynorsk)";          break;
        case 0x0448: psz = "Oriya";                        break;
        case 0x0415: psz = "Polish";                       break;
        case 0x0416: psz = "Portuguese (Brazil)";          break;
        case 0x0816: psz = "Portuguese (Standard)";        break;
        case 0x0446: psz = "Punjabi";                      break;
        case 0x0418: psz = "Romanian";                     break;
        case 0x0419: psz = "Russian";                      break;
        case 0x044F: psz = "Sanskrit";                     break;
        case 0x0C1A: psz = "Serbian (Cyrillic)";           break;
        case 0x081A: psz = "Serbian (Latin)";              break;
        case 0x0459: psz = "Sindhi";                       break;
        case 0x041B: psz = "Slovak";                       break;
        case 0x0424: psz = "Slovenian";                    break;
        case 0x040A: psz = "Spanish (Traditional Sort)";   break;
        case 0x080A: psz = "Spanish (Mexican)";            break;
        case 0x0C0A: psz = "Spanish (Modern Sort)";        break;
        case 0x100A: psz = "Spanish (Guatemala)";          break;
        case 0x140A: psz = "Spanish (Costa Rica)";         break;
        case 0x180A: psz = "Spanish (Panama)";             break;
        case 0x1C0A: psz = "Spanish (Dominican Republic)"; break;
        case 0x200A: psz = "Spanish (Venezuela)";          break;
        case 0x240A: psz = "Spanish (Colombia)";           break;
        case 0x280A: psz = "Spanish (Peru)";               break;
        case 0x2C0A: psz = "Spanish (Argentina)";          break;
        case 0x300A: psz = "Spanish (Ecuador)";            break;
        case 0x340A: psz = "Spanish (Chile)";              break;
        case 0x380A: psz = "Spanish (Uruguay)";            break;
        case 0x3C0A: psz = "Spanish (Paraguay)";           break;
        case 0x400A: psz = "Spanish (Bolivia)";            break;
        case 0x440A: psz = "Spanish (El Salvador)";        break;
        case 0x480A: psz = "Spanish (Honduras)";           break;
        case 0x4C0A: psz = "Spanish (Nicaragua)";          break;
        case 0x500A: psz = "Spanish (Puerto Rico)";        break;
        case 0x0430: psz = "Sutu";                         break;
        case 0x0441: psz = "Swahili (Kenya)";              break;
        case 0x041D: psz = "Swedish";                      break;
        case 0x081D: psz = "Swedish (Finland)";            break;
        case 0x0449: psz = "Tamil";                        break;
        case 0x0444: psz = "Tatar (Tatarstan)";            break;
        case 0x044A: psz = "Telugu";                       break;
        case 0x041E: psz = "Thai";                         break;
        case 0x041F: psz = "Turkish";                      break;
        case 0x0422: psz = "Ukrainian";                    break;
        case 0x0420: psz = "Urdu (Pakistan)";              break;
        case 0x0820: psz = "Urdu (India)";                 break;
        case 0x0443: psz = "Uzbek (Latin)";                break;
        case 0x0843: psz = "Uzbek (Cyrillic)";             break;
        case 0x042A: psz = "Vietnamese";                   break;
        default:     psz = "Unknown";                      break;
    }
    SCPrintf(szBuffer, sizeof(szBuffer), "0x%04X: %s", (DWORD)pSI->langId, psz);
    fResult &= pfnSIC(lParam, "OS Language", szBuffer);

    //
    // Build the Memory Load
    //
    SCPrintf(szBuffer, sizeof(szBuffer), "%u%%", pSI->dwMemoryLoad);
    fResult &= pfnSIC(lParam, "Memory Load", szBuffer);

    //
    // Build the Physical Memory
    //
    SCPrintf(szBuffer, sizeof(szBuffer), "%s (%I64u MB)",
             FormatValue(szValue, sizeof(szValue), pSI->dwlTotalPhys),
             (pSI->dwlTotalPhys + (DWORDLONG)1048575) / (DWORDLONG)1048576);
    fResult &= pfnSIC(lParam, "Physical Memory Total", szBuffer);
    fResult &= pfnSIC(lParam, "Physical Memory Used", FormatValue(szValue, sizeof(szValue), pSI->dwlTotalPhys - pSI->dwlAvailPhys));
    fResult &= pfnSIC(lParam, "Physical Memory Free", FormatValue(szValue, sizeof(szValue), pSI->dwlAvailPhys));

    //
    // Build the Page File Memory
    //
    fResult &= pfnSIC(lParam, "Page File Memory Total", FormatValue(szValue, sizeof(szValue), pSI->dwlTotalPageFile));
    fResult &= pfnSIC(lParam, "Page File Memory Used", FormatValue(szValue, sizeof(szValue), pSI->dwlTotalPageFile - pSI->dwlAvailPageFile));
    fResult &= pfnSIC(lParam, "Page File Memory Free", FormatValue(szValue, sizeof(szValue), pSI->dwlAvailPageFile));

    //
    // Build the Virtual Memory
    //
    fResult &= pfnSIC(lParam, "Virtual Memory Total", FormatValue(szValue, sizeof(szValue), pSI->dwlTotalVirtual));
    fResult &= pfnSIC(lParam, "Virtual Memory Used", FormatValue(szValue, sizeof(szValue), pSI->dwlTotalVirtual - pSI->dwlAvailVirtual));
    fResult &= pfnSIC(lParam, "Virtual Memory Free", FormatValue(szValue, sizeof(szValue), pSI->dwlAvailVirtual));

    //
    // Build the Page Size
    //
    SCPrintf(szBuffer, sizeof(szBuffer), "0x%08X (%s)", pSI->dwPageSize, FormatValue(szValue, sizeof(szValue), pSI->dwPageSize));
    fResult &= pfnSIC(lParam, "Page Size", szBuffer);

    //
    // Build the Allocation Granularity
    //
    SCPrintf(szBuffer, sizeof(szBuffer), "0x%08X (%s)", pSI->dwAllocationGranularity,
             FormatValue(szValue, sizeof(szValue), pSI->dwAllocationGranularity));
    fResult &= pfnSIC(lParam, "Allocation Granularity", szBuffer);

    //
    // Build the Minimum Application Address
    //
    SCPrintf(szBuffer, sizeof(szBuffer), (pSI->wFlags & SI_64BIT_DW) ? "0x%016I64X (%s)" : "0x%08I64X (%s)",
             pSI->dwlMinimumApplicationAddress,
             FormatValue(szValue, sizeof(szValue), pSI->dwlMinimumApplicationAddress));
    fResult &= pfnSIC(lParam, "Min. App. Address", szBuffer);

    //
    // Build the Maximum Application Address
    //
    SCPrintf(szBuffer, sizeof(szBuffer), (pSI->wFlags & SI_64BIT_DW) ? "0x%016I64X (%s)" : "0x%08I64X (%s)",
             pSI->dwlMaximumApplicationAddress,
             FormatValue(szValue, sizeof(szValue), pSI->dwlMaximumApplicationAddress));
    fResult &= pfnSIC(lParam, "Max. App. Address", szBuffer);

    return fResult;
}

//******************************************************************************
//
// I ran some tests of my own and came up with the following...
//
//                           OS Version    Build Version                       SP Version
// Operating System         Major Minor  Build Major Minor      OS-String     Major Minor  Suite  Product
// ----------------         ----- -----  ----- ----- -----  ----------------  ----- -----  ------  -------
// Windows 95 Gold            4      0    950    4      0   ""                 N/A   N/A     N/A     N/A
// Windows 95B OSR 2          4      0   1111    4      0   " B"               N/A   N/A     N/A     N/A
// Windows 95B OSR 2.1        4      0   1212    4      3   " B"               N/A   N/A     N/A     N/A
// Windows 95C OSR 2.5        4      0   1111    4      0   " C"               N/A   N/A     N/A     N/A
// Windows 98 Gold            4     10   1998    4     10   " "                N/A   N/A     N/A     N/A
// Windows 98 SE              4     10   2222    4     10   " A "               0     0    0x0000     0
// Windows 98 SE French       4     10   2222    4     10   " A "               0     0    0x0000     0
// Windows Me Gold            4     90   3000    4     90   " "                 0     0    0x0000     0
//
// Windows NT 3.10                        511
// Windows NT 3.11 (alpha)                528
// Windows NT 3.50                        807
// Windows NT 3.51            3     51   1057    0      0   ""                 N/A   N/A     N/A     N/A
// Windows NT 3.51 SP1        3     51   1057    0      0   "Service Pack 1"   N/A   N/A     N/A     N/A
// Windows NT 3.51 SP2        3     51   1057    0      0   "Service Pack 2"   N/A   N/A     N/A     N/A
// Windows NT 3.51 SP3        3     51   1057    0      0   "Service Pack 3"   N/A   N/A     N/A     N/A
// Windows NT 3.51 SP4        3     51   1057    0      0   "Service Pack 4"   N/A   N/A     N/A     N/A
// Windows NT 3.51 SP5        3     51   1057    0      0   "Service Pack 5"   N/A   N/A     N/A     N/A
// Windows NT 3.51 SP5A       3     51   1057    0      0   "Service Pack 5"   N/A   N/A     N/A     N/A
// Windows NT 4.00            4      0   1381                                                    
// Windows NT 4.00 SP1        4      0   1381               "Service Pack 1"   N/A   N/A     N/A     N/A
// Windows 2000 Server w/TS   5      0   2195    0      0   ""                  0     0    0x0110     3
// Windows 2000 Server SP1    5      0   2195    0      0   "Service Pack 1"    1     0    0x0000     3
//
//
// Suite Masks
// -----------------------------------------------------------------------------
// 0x0001 VER_SUITE_SMALLBUSINESS             
// 0x0002 VER_SUITE_ENTERPRISE                
// 0x0004 VER_SUITE_BACKOFFICE                
// 0x0008 VER_SUITE_COMMUNICATIONS            
// 0x0010 VER_SUITE_TERMINAL                  
// 0x0020 VER_SUITE_SMALLBUSINESS_RESTRICTED  
// 0x0040 VER_SUITE_EMBEDDEDNT                
// 0x0080 VER_SUITE_DATACENTER                
// 0x0100 VER_SUITE_SINGLEUSERTS              
// 0x0200 VER_SUITE_PERSONAL                  
// 0x0400 VER_SUITE_BLADE          //!! what is this?           
//
//
// Products 
// -----------------------------------------------------------------------------
// 1 Workstation
// 2 Domain Controller
// 3 Server
//
//
// NT Build History (taken from http://winweb/build/BuildHistory.asp)
// -----------------------------------------------------------------------------
//  196 was the first PDK release of October 1991
//  297 was the PDC of June 1992
//  340 was beta 1 of 3.1 in October 1992
//  397 was beta 2 of 3.1 in March 1993
//  511 was 3.1 in July 1993
//  528 was 3.11 (Alpha release) in September 1993
//  611 was beta 1 of 3.5 in April 1994
//  683 was beta 2 of 3.5 in June 1994
//  756 was RC1 of 3.5 in August 1994
//  807 was 3.5 in September 1994
//  944 was beta 1 of 3.51 in February 1995
// 1057 was 3.51 in May 1995
// 1234 was beta 1 of 4.0 in January 1996
// 1314 was beta 2 of 4.0 in May 1996
// 1381 was 4.0 in July 1996
// 1671 was beta 1 of 5.0 in September 1997
// 1877 was beta 2 of 5.0 in September 1998
// 1946 was RC0 of Beta 3 of Win2000 Pro in December 1998
// 2000.3 was RC1 of Beta 3 of Win2000 Pro in March 1999
// 2031 was Beta 3 of Win2000 Pro in April 1999
// 2072 was RC1 of Win2000 Pro in July 1999
// 2128 was RC2 of Win2000 Pro in September 1999
// 2183 was RC3 of Win2000 Pro in November 1999
// 2195 was Win2000 Pro (English and German), December 15, 1999
// 2195.01L was Win2000 Pro Japanese, December 21, 1999
// 2296 was Beta 1 of Whistler/Windows XP on 10-28-2000
// 2462 was Beta 2 of Whistler/Windows XP
// 2505 was RC1 of Whistler/Windows XP
// 2600 was Windows XP Pro and Home

LPSTR BuildOSNameString(LPSTR pszBuf, int cBuf, SYSINFO *pSI)
{
    switch (pSI->dwPlatformId)
    {
        case VER_PLATFORM_WIN32s: // Shouldn't ever see this since we don't run on Win32s
            StrCCpy(pszBuf, "Microsoft Win32s", cBuf);
            break;

        case VER_PLATFORM_WIN32_WINDOWS:
            if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 0))
            {
                StrCCpy(pszBuf, "Microsoft Windows 95", cBuf);
            }
            else if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 10))
            {
                StrCCpy(pszBuf, "Microsoft Windows 98", cBuf);
            }
            else if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 90))
            {
                StrCCpy(pszBuf, "Microsoft Windows Me", cBuf);
            }
            else
            {
                StrCCpy(pszBuf, "Microsoft Windows 9x/Me based", cBuf);
            }
            break;

        case VER_PLATFORM_WIN32_NT:
            if (pSI->dwMajorVersion < 5)
            {
                StrCCpy(pszBuf, "Microsoft Windows NT", cBuf);
            }
            else if ((pSI->dwMajorVersion == 5) && (pSI->dwMinorVersion == 0))
            {
                StrCCpy(pszBuf, "Microsoft Windows 2000", cBuf);
            }
            else if ((pSI->dwMajorVersion == 5) && (pSI->dwMinorVersion == 1))
            {
                StrCCpy(pszBuf, "Microsoft Windows XP", cBuf);
            }
            else
            {
                StrCCpy(pszBuf, "Microsoft Windows NT/2000/XP based", cBuf);
            }
            break;

        case VER_PLATFORM_WIN32_CE: // Shouldn't ever see this since we don't run on CE
            StrCCpy(pszBuf, "Microsoft Windows CE", cBuf);
            break;

        default:
            SCPrintf(pszBuf, cBuf, "Unknown (%u)", pSI->dwPlatformId);
    }

    if (pSI->wProductType == VER_NT_WORKSTATION)
    {
        if (pSI->wSuiteMask & VER_SUITE_PERSONAL)
        {
            StrCCat(pszBuf, " Personal", cBuf);
        }
        else
        {
            StrCCat(pszBuf, " Professional", cBuf);
        }
    }
    else if (pSI->wProductType == VER_NT_DOMAIN_CONTROLLER)
    {
        StrCCat(pszBuf, " Domain Controller", cBuf);
    }
    else if (pSI->wProductType == VER_NT_SERVER)
    {
        if (pSI->wSuiteMask & VER_SUITE_DATACENTER)
        {
            StrCCat(pszBuf, " Datacenter Server", cBuf);
        }
        else if (pSI->wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            StrCCat(pszBuf, " Advanced Server", cBuf);
        }
        else if (pSI->wSuiteMask & (VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED))
        {
            StrCCat(pszBuf, " Server for Small Business Server", cBuf);
        }
        else
        {
            StrCCat(pszBuf, " Server", cBuf);
        }
    }
    if (pSI->wSuiteMask & VER_SUITE_EMBEDDEDNT)
    {
        StrCCat(pszBuf, " Embedded", cBuf);
    }
    return StrCCat(pszBuf, (pSI->wFlags & SI_64BIT_OS) ? " (64-bit)" : " (32-bit)", cBuf);
}

//******************************************************************************
LPSTR BuildOSVersionString(LPSTR pszBuf, int cBuf, SYSINFO *pSI)
{
    // Locate the first non-whitespace character in the OS string.
    for (LPSTR psz = pSI->szCSDVersion; *psz && isspace(*psz); psz++);

    // Starting with the first non-whitespace character, copy the string to a local buffer.
    CHAR szCSDVersion[sizeof(pSI->szCSDVersion)];
    StrCCpy(szCSDVersion, psz, sizeof(szCSDVersion));

    // Remove trailing whitespace from our local buffer.
    for (psz = szCSDVersion + strlen(szCSDVersion) - 1; (psz >= szCSDVersion) && isspace(*psz); psz--)
    {
        *psz = '\0';
    }

    // If we don't have an OS string, but do have a service pack value, then
    // we build a fake OS string with the service pack in it.  This should never
    // be needed since the service pack is supposed to always be in the OS string,
    // but just in case...
    if (!*szCSDVersion)
    {
        if (pSI->wServicePackMinor)
        {
            SCPrintf(szCSDVersion, sizeof(szCSDVersion), " Service Pack %u.%u", (DWORD)pSI->wServicePackMajor, (DWORD)pSI->wServicePackMinor);
        }
        else if (pSI->wServicePackMajor)
        {
            SCPrintf(szCSDVersion, sizeof(szCSDVersion), " Service Pack %u", (DWORD)pSI->wServicePackMajor);
        }
    }

    // Windows 9x breaks up the build DWORD into 3 parts.
    DWORD dwMajor = (DWORD)HIBYTE(HIWORD(pSI->dwBuildNumber));
    DWORD dwMinor = (DWORD)LOBYTE(HIWORD(pSI->dwBuildNumber));
    DWORD dwBuild = (DWORD)       LOWORD(pSI->dwBuildNumber);

    // Build Version + Build + OS String.
    SCPrintf(pszBuf, cBuf, "%u.%02u.%u%s%s", pSI->dwMajorVersion, pSI->dwMinorVersion,
            (pSI->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? dwBuild : pSI->dwBuildNumber,
            *szCSDVersion ? " " : "", szCSDVersion);

    switch (pSI->dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            
            // Check for Windows 95
            if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 0))
            {
                if ((dwMajor == 4) && (dwMinor == 0) && (dwBuild == 950) && !*szCSDVersion)
                {
                    StrCCat(pszBuf, " (Gold)", cBuf);
                }
                else if ((dwMajor == 4) && (dwMinor == 0) && (dwBuild == 1111) && (*szCSDVersion == 'B'))
                {
                    StrCCat(pszBuf, " (OSR 2)", cBuf);
                }
                else if ((dwMajor == 4) && (dwMinor == 3) && (dwBuild == 1212) && (*szCSDVersion == 'B'))
                {
                    StrCCat(pszBuf, " (OSR 2.1)", cBuf);
                }
                else if ((dwMajor == 4) && (dwMinor == 0) && (dwBuild == 1111) && (*szCSDVersion == 'C'))
                {
                    StrCCat(pszBuf, " (OSR 2.5)", cBuf);
                }
            }

            // Check for Windows 98
            else if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 10))
            {
                if ((dwMajor == 4) && (dwMinor == 10) && (dwBuild == 1998) && !*szCSDVersion)
                {
                    StrCCat(pszBuf, " (Gold)", cBuf);
                }
                else if ((dwMajor == 4) && (dwMinor == 10) && (dwBuild == 2222) && (*szCSDVersion == 'A'))
                {
                    StrCCat(pszBuf, " (Second Edition)", cBuf);
                }
            }

            // Check for Windows Me
            else if ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion == 90))
            {
                if ((dwMajor == 4) && (dwMinor == 90) && (dwBuild == 3000) && !*szCSDVersion)
                {
                    StrCCat(pszBuf, " (Gold)", cBuf);
                }
            }
            break;

        case VER_PLATFORM_WIN32_NT:

            // Check for a known "Gold" release.
            if (!*szCSDVersion &&
                (((pSI->dwMajorVersion == 3) && (pSI->dwMinorVersion == 10) && (pSI->dwBuildNumber ==  511)) ||
                 ((pSI->dwMajorVersion == 3) && (pSI->dwMinorVersion == 11) && (pSI->dwBuildNumber ==  528)) ||
                 ((pSI->dwMajorVersion == 3) && (pSI->dwMinorVersion == 50) && (pSI->dwBuildNumber ==  807)) ||
                 ((pSI->dwMajorVersion == 3) && (pSI->dwMinorVersion == 51) && (pSI->dwBuildNumber == 1057)) ||
                 ((pSI->dwMajorVersion == 4) && (pSI->dwMinorVersion ==  0) && (pSI->dwBuildNumber == 1381)) ||
                 ((pSI->dwMajorVersion == 5) && (pSI->dwMinorVersion ==  0) && (pSI->dwBuildNumber == 2195)) ||
                 ((pSI->dwMajorVersion == 5) && (pSI->dwMinorVersion ==  1) && (pSI->dwBuildNumber == 2600))))
            {
                StrCCat(pszBuf, " (Gold)", cBuf);
            }

            // Otherwise, just check for any known builds.
            else
            {
                switch (pSI->dwBuildNumber)
                {
                    case  196: StrCCat(pszBuf, " (PDK)",           cBuf); break; // first PDK release of October 1991
                    case  297: StrCCat(pszBuf, " (PDC)",           cBuf); break; // the PDC of June 1992
                    case  340: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // beta 1 of 3.1 in October 1992
                    case  397: StrCCat(pszBuf, " (Beta 2)",        cBuf); break; // beta 2 of 3.1 in March 1993
                    case  611: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // beta 1 of 3.5 in April 1994
                    case  683: StrCCat(pszBuf, " (Beta 2)",        cBuf); break; // beta 2 of 3.5 in June 1994
                    case  756: StrCCat(pszBuf, " (RC1)",           cBuf); break; // RC1 of 3.5 in August 1994
                    case  944: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // beta 1 of 3.51 in February 1995
                    case 1234: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // beta 1 of 4.0 in January 1996
                    case 1314: StrCCat(pszBuf, " (Beta 2)",        cBuf); break; // beta 2 of 4.0 in May 1996
                    case 1671: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // beta 1 of 5.0 in September 1997
                    case 1877: StrCCat(pszBuf, " (Beta 2)",        cBuf); break; // beta 2 of 5.0 in September 1998
                    case 1946: StrCCat(pszBuf, " (RC0 of Beta 3)", cBuf); break; // RC0 of Beta 3 of Win2000 Pro in December 1998
                    case 2000: StrCCat(pszBuf, " (RC1 of Beta 3)", cBuf); break; // RC1 of Beta 3 of Win2000 Pro in March 1999
                    case 2031: StrCCat(pszBuf, " (Beta 3)",        cBuf); break; // Beta 3 of Win2000 Pro in April 1999
                    case 2072: StrCCat(pszBuf, " (RC1)",           cBuf); break; // RC1 of Win2000 Pro in July 1999
                    case 2128: StrCCat(pszBuf, " (RC2)",           cBuf); break; // RC2 of Win2000 Pro in September 1999
                    case 2183: StrCCat(pszBuf, " (RC3)",           cBuf); break; // RC3 of Win2000 Pro in November 1999
                    case 2296: StrCCat(pszBuf, " (Beta 1)",        cBuf); break; // Beta 1 of Whistler/Windows XP on 10-28-2000
                    case 2462: StrCCat(pszBuf, " (Beta 2)",        cBuf); break; // Beta 1 of Whistler/Windows XP
                    case 2505: StrCCat(pszBuf, " (RC1)",           cBuf); break; // RC1 of Whistler/Windows XP
                }
            }
            break;
    }

    return pszBuf;
}

//******************************************************************************
LPSTR BuildCpuString(LPSTR pszBuf, int cBuf, SYSINFO *pSI)
{
    *pszBuf = '\0';

    // If we have an identifier string, then just use it.  This is more future
    // proof and works even when the OS lies to us for compatability reasons
    // (like an x86 binary running on an Alpha, or a 32-bit binary running under WOW64)
    if (*pSI->szCpuIdentifier)
    {
        StrCCpy(pszBuf, pSI->szCpuIdentifier, cBuf);
    }

    // If we don't have an identifier string, then attempt to build one from what we know.
    else
    {
        // WOW64 expects a 32-bit CPU type for compatibility.  Since we
        // want to display the real CPU type, we change the CPU to 64-bit.
        // The only time this fails is when we have a 32-bit x86 binary running
        // in an alpha WOW64.
        if (pSI->wFlags &= SI_64BIT_OS)
        {
            if (pSI->dwProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
            {
                pSI->dwProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;            
                pSI->dwProcessorType         = PROCESSOR_INTEL_IA64;
            }
            else if (pSI->dwProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)
            {
                pSI->dwProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA64;            
            }
        }

        // Build the CPU strings.
        switch (pSI->dwProcessorArchitecture)
        {
            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_INTEL:

                // Windows NT and Windows 98 and beyond use the Processor Level member.
                if (pSI->wProcessorLevel)
                {
                    switch (pSI->wProcessorLevel)
                    {
                        case 3: StrCCpy(pszBuf, "386",            cBuf); break;
                        case 4: StrCCpy(pszBuf, "486",            cBuf); break;
                        case 5: StrCCpy(pszBuf, "Pentium",        cBuf); break;
                        case 6: StrCCpy(pszBuf, "Pentium Pro/II", cBuf); break;
                        default:
                            SCPrintf(pszBuf, cBuf, "x86 Family, Level %hu", pSI->wProcessorLevel);
                            break;
                    }
                }

                // If we have no level, then we are probably on Windows 95.  We can use the
                // Processor Type to determine what CPU we are on.
                else
                {
                    switch (pSI->dwProcessorType)
                    {
                        case PROCESSOR_INTEL_386:     StrCCpy(pszBuf, "386",     cBuf); break;
                        case PROCESSOR_INTEL_486:     StrCCpy(pszBuf, "486",     cBuf); break;
                        case PROCESSOR_INTEL_PENTIUM: StrCCpy(pszBuf, "Pentium", cBuf); break;
                        default:
                            SCPrintf(pszBuf, cBuf, "x86 Family (%u)", pSI->dwProcessorType);
                            break;
                    }
                }

                // Windows NT and Windows 98 and beyond should have a revision number.
                if (pSI->wProcessorRevision)
                {
                    // Check to see if it is a 386 and 486.
                    if ((*pszBuf == '3') || (*pszBuf == '4'))
                    {
                        // From SYSTEM_INFO help: A value of the form xxyz. 
                        // If xx is equal to 0xFF, y - 0xA is the model number, and z is the stepping identifier.
                        // For example, an Intel 80486-D0 system returns 0xFFD0
                        if (HIBYTE(pSI->wProcessorRevision) == 0xFF)
                        {
                            SCPrintfCat(pszBuf, cBuf, ", Model %d, Stepping %u",
                                    ((DWORD)LOBYTE(pSI->wProcessorRevision) >> 8) - 0xA,
                                     (DWORD)LOBYTE(pSI->wProcessorRevision) & 0xF);
                        }

                        // If xx is not equal to 0xFF, xx + 'A' is the stepping letter and yz is the minor stepping. 
                        else if (HIBYTE(pSI->wProcessorRevision) < 26)
                        {
                            SCPrintfCat(pszBuf, cBuf, ", Stepping %c%02u",
                                    'A' + HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));
                        }
                        else 
                        {
                            SCPrintfCat(pszBuf, cBuf, ", Stepping %u.%u",
                                    (DWORD)HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));
                        }
                    }

                    // Otherwise, it is a 586 (Pentium) or beyond.
                    else
                    {
                        SCPrintfCat(pszBuf, cBuf, ", Model %u, Stepping %u",
                                (DWORD)HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));
                    }
                }
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_MIPS:

                // Windows NT uses the Processor Level member.
                switch (pSI->wProcessorLevel)
                {
                    case 4: StrCCpy(pszBuf, "MIPS R4000", cBuf); break;
                    default:
                        switch (pSI->dwProcessorType)
                        {
                            case PROCESSOR_MIPS_R2000: StrCCpy(pszBuf, "MIPS R2000", cBuf); break;
                            case PROCESSOR_MIPS_R3000: StrCCpy(pszBuf, "MIPS R3000", cBuf); break;
                            case PROCESSOR_MIPS_R4000: StrCCpy(pszBuf, "MIPS R4000", cBuf); break;
                            default:
                                SCPrintf(pszBuf, cBuf, "MIPS Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                                break;
                        }
                        break;
                }

                // We should have a revision number.
                if (pSI->wProcessorRevision)
                {
                    // A value of the form 00xx, where xx is the 8-bit revision number of
                    // the processor (the low-order 8 bits of the PRId register).
                    SCPrintfCat(pszBuf, cBuf, ", Revision %u", (DWORD)LOBYTE(pSI->wProcessorRevision));
                }
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_ALPHA:

                // Windows NT uses the Processor Level member.
                if (pSI->wProcessorLevel)
                {
                    SCPrintf(pszBuf, cBuf, "Alpha %u", pSI->wProcessorLevel);
                }
                else
                {
                    SCPrintf(pszBuf, cBuf, "Alpha Family (%u)", pSI->dwProcessorType);
                }

                // We should have a revision number.
                if (pSI->wProcessorRevision)
                {
                    // A value of the form xxyy, where xxyy is the low-order 16 bits of the processor
                    // revision number from the firmware. Display this value as follows: Model A+xx, Pass yy
                    if (HIBYTE(pSI->wProcessorRevision) < 26)
                    {
                        SCPrintfCat(pszBuf, cBuf, ", Model %c, Pass %u",
                                    'A' + HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));
                    }
                    else 
                    {
                        SCPrintfCat(pszBuf, cBuf, ", Model %u, Pass %u",
                                    (DWORD)HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));
                    }
                }
                break;
           
            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_PPC:

                // Windows NT uses the Processor Level member.
                switch (pSI->wProcessorLevel)
                {
                    case  1: StrCCpy(pszBuf, "PPC 601",  cBuf); break;
                    case  3: StrCCpy(pszBuf, "PPC 603",  cBuf); break;
                    case  4: StrCCpy(pszBuf, "PPC 604",  cBuf); break;
                    case  6: StrCCpy(pszBuf, "PPC 603+", cBuf); break;
                    case  9: StrCCpy(pszBuf, "PPC 604+", cBuf); break;
                    case 20: StrCCpy(pszBuf, "PPC 620",  cBuf); break;
                    default:
                        switch (pSI->dwProcessorType)
                        {
                            case PROCESSOR_PPC_601: StrCCpy(pszBuf, "PPC 601", cBuf); break;
                            case PROCESSOR_PPC_603: StrCCpy(pszBuf, "PPC 603", cBuf); break;
                            case PROCESSOR_PPC_604: StrCCpy(pszBuf, "PPC 604", cBuf); break;
                            case PROCESSOR_PPC_620: StrCCpy(pszBuf, "PPC 620", cBuf); break;
                            default:
                                SCPrintf(pszBuf, cBuf, "PPC Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                                break;
                        }
                        break;
                }

                // We should have a revision number.
                if (pSI->wProcessorRevision)
                {
                    // A value of the form xxyy, where xxyy is the low-order 16 bits of the processor
                    // version register. Display this value as follows: xx.yy
                    SCPrintfCat(pszBuf, cBuf, ", Revision %u.%u",
                                (DWORD)HIBYTE(pSI->wProcessorRevision), (DWORD)LOBYTE(pSI->wProcessorRevision));

                }
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_SHX:
                SCPrintf(pszBuf, cBuf, "SHx Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_ARM:
                SCPrintf(pszBuf, cBuf, "ARM Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_IA64: //!! look into this
                SCPrintf(pszBuf, cBuf, "IA64 Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_ALPHA64:
                SCPrintf(pszBuf, cBuf, "Alpha64 Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_MSIL:
                SCPrintf(pszBuf, cBuf, "MSIL/OPTIL Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_AMD64: //!! look into this
                SCPrintf(pszBuf, cBuf, "AMD64 Family (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: //!! look into this
                SCPrintf(pszBuf, cBuf, "IA32 on Win64 (%u)", pSI->wProcessorLevel ? (DWORD)pSI->wProcessorLevel : pSI->dwProcessorType);
                break;

            //----------------------------------------------------------------------
            default:
                SCPrintf(pszBuf, cBuf, "Unknown (%u)", pSI->dwProcessorArchitecture);
                break;
        }
    }

    // Windows NT and Windows 95 OSR2 and beyond should have a vender name.
    if (*pSI->szCpuVendorIdentifier)
    {
        SCPrintfCat(pszBuf, cBuf, ", %s", pSI->szCpuVendorIdentifier);
    }

    // Windows NT 4.00 and beyond should have a CPU speed.
    if (pSI->dwCpuMHz)
    {
        SCPrintfCat(pszBuf, cBuf, ", ~%uMHz", pSI->dwCpuMHz);
    }

    return pszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\document.h ===
//******************************************************************************
//
// File:        DOCUMENT.H
//
// Description: Definition file for the Document class.
//
// Classes:     CDocDepends
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __DOCUMENT_H__
#define __DOCUMENT_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CDocDepends
//******************************************************************************

class CDocDepends : public CDocument
{
// Internal variables
protected:
    bool          m_fInitialized;
    bool          m_fError;
    bool          m_fChildProcess;
    CSearchGroup *m_psgHead;
    CString       m_strSaveName;
    SAVETYPE      m_saveType;

// Public static functions
public:
    static bool ReadAutoExpandSetting();
    static void WriteAutoExpandSetting(bool fAutoExpand);
    static bool ReadFullPathsSetting();
    static void WriteFullPathsSetting(bool fFullPaths);
    static bool ReadUndecorateSetting();
    static void WriteUndecorateSetting(bool fUndecorate);
    static bool SaveSession(LPCSTR pszSaveName, SAVETYPE saveType, CSession *pSession, bool fFullPaths,
                            bool fUndecorate, int sortColumnModules, int sortColumnImports,
                            int sortColumnExports, CRichEditCtrl *pre);

// Private static functions
protected:
    static bool CALLBACK SysInfoCallback(LPARAM lParam, LPCSTR pszField, LPCSTR pszValue);
    static bool SaveSearchPath(HANDLE hFile, CSession *pSession);

// Public variables
public:
    bool              m_fCommandLineProfile;
    CSession         *m_pSession;
    CString           m_strDefaultDirectory;
    CString           m_strProfileDirectory;
    CString           m_strProfileArguments;
    CString           m_strProfileSearchPath;
    DWORD             m_dwProfileFlags;
    CChildFrame      *m_pChildFrame;
//  BOOL              m_fDetailView;
    CTreeViewModules *m_pTreeViewModules;
    CListViewModules *m_pListViewModules;
//  CRichViewDetails *m_pRichViewDetails;
    CListViewImports *m_pListViewImports;
    CListViewExports *m_pListViewExports;
    CRichViewProfile *m_pRichViewProfile;
    bool              m_fViewFullPaths;
    bool              m_fViewUndecorated;
    bool              m_fAutoExpand;
    BOOL              m_fWarnToRefresh;
    HFONT             m_hFontList;
    int               m_cxHexWidths[18];       // 0x01234567890ABCDEF
    int               m_cxOrdHintWidths[14];   // 65535 (0xFFFF)
    int               m_cxTimeStampWidths[17]; // 01/23/4567 01:23p
    int               m_cxDigit;
    int               m_cxSpace;
    int               m_cxAP;

    // Values shared between the CListViewsImports and CListViewExports
    CModule *m_pModuleCur;
    int      m_cImports;
    int      m_cExports;
    int      m_cxColumns[LVFC_COUNT];

// Constructor/Destructor (serialization only)
protected:
    CDocDepends();
    virtual ~CDocDepends();
    DECLARE_DYNCREATE(CDocDepends)

// Public Functions
public:
    void BeforeVisible();
    void AfterVisible();
    void DisplayModule(CModule *pModule);
    void DoSettingChange();
    void InitFontAndFixedWidths(CWnd *pWnd);
    int* GetHexWidths(LPCSTR pszItem);
    int* GetOrdHintWidths(LPCSTR pszItem);
    int* GetTimeStampWidths();

    inline BOOL     IsLive()        { return m_pSession && !(m_pSession->GetSessionFlags() & DWSF_DWI); }
    inline bool     IsError()       { return m_fError; }
    inline CModule* GetRootModule() { return m_pSession ? m_pSession->GetRootModule() : NULL; }

// Private functions
protected:
    void UpdateTimeStampWidths(HDC hDC);
    void UpdateAll();
    void UpdateModule(CModule *pModule);
    void AddModuleTree(CModule *pModule);
    void RemoveModuleTree(CModule *pModule);
    void AddImport(CModule *pModule, CFunction *pFunction);
    void ExportsChanged(CModule *pModule);
    void ChangeOriginal(CModule *pModuleOld, CModule *pModuleNew);
    BOOL LogOutput(LPCSTR pszOutput, DWORD dwFlags, DWORD dwElapsed);

    void ProfileUpdate(DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2);
    static void CALLBACK StaticProfileUpdate(DWORD_PTR dwpCookie, DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2)
    {
        ((CDocDepends*)dwpCookie)->ProfileUpdate(dwType, dwpParam1, dwpParam2);
    }

// Overridden functions
public:
    //{{AFX_VIRTUAL(CDocDepends)
public:
    virtual void DeleteContents();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
protected:
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CDocDepends)
    afx_msg void OnFileSave();
    afx_msg void OnFileSaveAs();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnUpdateShowMatchingItem(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditClearLog(CCmdUI* pCmdUI);
    afx_msg void OnEditClearLog();
    afx_msg void OnUpdateViewFullPaths(CCmdUI *pCmdUI);
    afx_msg void OnViewFullPaths();
    afx_msg void OnUpdateViewUndecorated(CCmdUI* pCmdUI);
    afx_msg void OnViewUndecorated();
    afx_msg void OnExpandAll();
    afx_msg void OnCollapseAll();
    afx_msg void OnUpdateRefresh(CCmdUI* pCmdUI);
    afx_msg void OnFileRefresh();
    afx_msg void OnViewSysInfo();
    afx_msg void OnUpdateExternalViewer(CCmdUI* pCmdUI);
    afx_msg void OnUpdateExternalHelp(CCmdUI* pCmdUI);
    afx_msg void OnUpdateExecute(CCmdUI* pCmdUI);
    afx_msg void OnExecute();
    afx_msg void OnUpdateTerminate(CCmdUI* pCmdUI);
    afx_msg void OnTerminate();
    afx_msg void OnConfigureSearchOrder();
    afx_msg void OnUpdateAutoExpand(CCmdUI* pCmdUI);
    afx_msg void OnAutoExpand();
    afx_msg void OnUpdateShowOriginalModule(CCmdUI* pCmdUI);
    afx_msg void OnShowOriginalModule();
    afx_msg void OnUpdateShowPreviousModule(CCmdUI* pCmdUI);
    afx_msg void OnShowPreviousModule();
    afx_msg void OnUpdateShowNextModule(CCmdUI* pCmdUI);
    afx_msg void OnShowNextModule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif __DOCUMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\funcview.cpp ===
//******************************************************************************
//
// File:        FUNCVIEW.CPP
//
// Description: Implementation file for the Parent Imports View, the Exports
//              View, and their base class.
//
// Classes:     CListViewFunction
//              CListViewImports
//              CListViewExports
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "msdnhelp.h"
#include "document.h"
#include "mainfrm.h"
#include "listview.h"
#include "funcview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CListViewFunction
//******************************************************************************

/*static*/ LPCSTR CListViewFunction::ms_szColumns[] =
{
    "",  // Image
    "Ordinal",
    "Hint",
    "Function",
    "Entry Point"
};

/*static*/ int  CListViewFunction::ms_sortColumn        = 0;
/*static*/ bool CListViewFunction::ms_fUndecorate       = false;
/*static*/ bool CListViewFunction::ms_fIgnoreCalledFlag = false;

//******************************************************************************
IMPLEMENT_DYNCREATE(CListViewFunction, CSmartListView)
BEGIN_MESSAGE_MAP(CListViewFunction, CSmartListView)
    //{{AFX_MSG_MAP(CListViewFunction)
    ON_NOTIFY(HDN_DIVIDERDBLCLICKA, 0, OnDividerDblClick)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRClick)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblClk)
    ON_NOTIFY_REFLECT(NM_RETURN, OnReturn)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_HELP, OnUpdateExternalHelp)
    ON_COMMAND(IDM_EXTERNAL_HELP, OnExternalHelp)
    ON_NOTIFY(HDN_DIVIDERDBLCLICKW, 0, OnDividerDblClick)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_VIEWER, OnUpdateExternalViewer)
    ON_COMMAND(IDM_EXTERNAL_VIEWER, OnExternalViewer)
    ON_UPDATE_COMMAND_UI(IDM_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(IDM_PROPERTIES, OnProperties)
    //}}AFX_MSG_MAP
    // Standard printing commands
//  ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()


//******************************************************************************
// CListViewFunction :: Constructor/Destructor
//******************************************************************************

CListViewFunction::CListViewFunction(bool fExports) :
    m_fExports(fExports)
{
}

//******************************************************************************
CListViewFunction::~CListViewFunction()
{
}


//******************************************************************************
// CListViewFunction :: Static Functions
//******************************************************************************

/*static*/ int CListViewFunction::ReadSortColumn(bool fExports)
{
    // Read the value from the registry.
    int column = g_theApp.GetProfileInt(g_pszSettings, fExports ? "SortColumnExports" : "SortColumnImports", LVFC_DEFAULT); // inspected. MFC function

    // If the value is invalid, then just return our default value.
    if ((column < 0) || (column >= LVFC_COUNT))
    {
        return LVFC_DEFAULT;
    }

    return column;
}

//******************************************************************************
/*static*/ void CListViewFunction::WriteSortColumn(bool fExports, int column)
{
    g_theApp.WriteProfileInt(g_pszSettings, fExports ? "SortColumnExports" : "SortColumnImports", column);
}

//******************************************************************************
/*static*/ bool CListViewFunction::SaveToTxtFile(HANDLE hFile, CModule *pModule,
                                                 int sortColumn, bool fUndecorate,
                                                 bool fExports, int *pMaxWidths)
{
    CHAR   szBuf[4096], szTmp[1024], *pszBase, *psz2, *psz3, *pszBufNull = szBuf + sizeof(szBuf) - 1;
    LPCSTR psz = NULL;
    int    column, i, length;
    CFunction *pFunction, **ppCur, **ppFunctions = GetSortedList(pModule, sortColumn, fExports, fUndecorate);

    // Import  Ordinal       Hint          Function         Entry Point
    // ------  ------------  ------------  ---------------  ----------------
    // [OEF]   123 (0x1234)  123 (0x1234)  FooFooFooFooFoo  blahblahblahblah
    // [+R*]
    // [C  ]

    length = min(((int)pModule->GetDepth() + 1) * 5, (int)sizeof(szBuf) - 1);
    memset(szBuf, ' ', length);
    szBuf[sizeof(szBuf) - 1] = '\0';

    pszBase = szBuf + length;

    // Build the header row.
    for (psz2 = pszBase, column = 0; column < LVFC_COUNT; column++)
    {
        StrCCpy(psz2, column ? ms_szColumns[column] : fExports ? "Export" : "Import", sizeof(szBuf) - (int)(psz2 - szBuf));
        psz3 = psz2 + strlen(psz2);
        if (column < 4)
        {
            while (((psz3 - psz2) < (pMaxWidths[column] + 2)) && (psz3 < pszBufNull))
            {
                *psz3++ = ' ';
            }
        }
        psz2 = psz3;
    }
    StrCCpy(psz2, "\r\n", sizeof(szBuf) - (int)(psz2 - szBuf));

    // Output the header row.
    if (!WriteText(hFile, szBuf))
    {
        MemFree((LPVOID&)ppFunctions);
        return false;
    }

    // Build the header underline.
    for (psz2 = pszBase, column = 0; column < LVFC_COUNT; column++)
    {
        for (i = 0; (i < pMaxWidths[column]) && (psz2 < pszBufNull); i++)
        {
            *psz2++ = '-';
        }
        if (column < 4)
        {
            if (psz2 < pszBufNull)
            {
                *psz2++ = ' ';
            }
            if (psz2 < pszBufNull)
            {
                *psz2++ = ' ';
            }
        }
    }
    StrCCpy(psz2, "\r\n", sizeof(szBuf) - (int)(psz2 - szBuf));

    // Output the header underline.
    if (!WriteText(hFile, szBuf))
    {
        MemFree((LPVOID&)ppFunctions);
        return false;
    }

    // Loop through each function, logging them to the file.
    for (ppCur = ppFunctions; *ppCur; ppCur++)
    {
        pFunction = *ppCur;

        // Loop through each column and build the output string.
        for (psz2 = psz3 = pszBase, column = 0; column < LVFC_COUNT; column++)
        {
            switch (column)
            {
                case 0:
                {
                    LPSTR pszTmp = szTmp;
                    *pszTmp++ = '[';
                    LPCSTR pszName = pFunction->GetName();
                    if (!pszName || !*pszName)
                    {
                        *pszTmp++ = 'O';
                    }
                    else if (*pszName == '?')
                    {
                        *pszTmp++ = '+';
                    }
                    else
                    {
                        *pszTmp++ = 'C';
                    }
                    if (fExports)
                    {
                        *pszTmp++ = (pFunction->GetFlags() & DWFF_CALLED_ALO) ? 'R' : ' ';
                        *pszTmp++ = (pFunction->GetExportForwardName())       ? 'F' : ' ';
                    }
                    else
                    {
                        *pszTmp++ = (pFunction->GetAssociatedExport())        ? ' ' : 'E';
                        *pszTmp++ = (pFunction->GetFlags() & DWFF_DYNAMIC)    ? 'D' : ' ';
                    }
                    *pszTmp++ = ']';
                    *pszTmp++ = '\0';
                    psz = szTmp;
                    break;
                }
                case 1: psz = pFunction->GetOrdinalString(szTmp, sizeof(szTmp));               break;
                case 2: psz = pFunction->GetHintString(szTmp, sizeof(szTmp));                  break;
                case 3: psz = pFunction->GetFunctionString(szTmp, sizeof(szTmp), fUndecorate); break;
                case 4: psz = pFunction->GetAddressString(szTmp, sizeof(szTmp));               break;
            }

            length = (int)strlen(psz);

            if ((column == 1) || (column == 2))
            {
                while ((length < pMaxWidths[column]) && (psz3 < pszBufNull))
                {
                    *psz3++ = ' ';
                    length++;
                }
            }
            StrCCpyFilter(psz3, psz, sizeof(szBuf) - (int)(psz3 - szBuf));
            psz3 = psz2 + length;

            if (column < 4)
            {
                while (((psz3 - psz2) < (pMaxWidths[column] + 2)) && (psz3 < pszBufNull))
                {
                    *psz3++ = ' ';
                }
            }
            psz2 = psz3;
        }
        StrCCpy(psz2, "\r\n", sizeof(szBuf) - (int)(psz2 - szBuf));

        if (!WriteText(hFile, szBuf))
        {
            MemFree((LPVOID&)ppFunctions);
            return false;
        }
    }

    MemFree((LPVOID&)ppFunctions);
    return WriteText(hFile, "\r\n");
}

//******************************************************************************
/*static*/ int CListViewFunction::GetImage(CFunction *pFunction)
{
    //   0  C    import  error
    //   1  C++  import  error
    //   2  Ord  import  error
    //   3  C    import  error  dynamic
    //   4  C++  import  error  dynamic
    //   5  Ord  import  error  dynamic

    //   6  C    import
    //   7  C++  import
    //   8  Ord  import
    //   9  C    import         dynamic
    //  10  C++  import         dynamic
    //  11  Ord  import         dynamic

    //  12  C    export  called
    //  13  C++  export  called
    //  14  Ord  export  called
    //  15  C    export  called forward
    //  16  C++  export  called forward
    //  17  Ord  export  called forward

    //  18  C    export  alo
    //  19  C++  export  alo
    //  20  Ord  export  alo
    //  21  C    export  alo    forward
    //  22  C++  export  alo    forward
    //  23  Ord  export  alo    forward

    //  24  C    export
    //  25  C++  export
    //  26  Ord  export
    //  27  C    export         forward
    //  28  C++  export         forward
    //  29  Ord  export         forward

    int   image;
    DWORD dwFlags = pFunction->GetFlags();

    // Determine the image for this function
    if (pFunction->IsExport())
    {
        if ((dwFlags & DWFF_CALLED) && !ms_fIgnoreCalledFlag)
        {
            image = 12;
        }
        else if (dwFlags & DWFF_CALLED_ALO)
        {
            image = 18;
        }
        else
        {
            image = 24;
        }
        if (pFunction->GetExportForwardName())
        {
            image += 3;
        }
    }
    else
    {
        image = (pFunction->GetAssociatedExport() ? 6 : 0) +
                ((dwFlags & DWFF_DYNAMIC) ? 3 : 0);
    }
    LPCSTR pszName = pFunction->GetName();
    if (!pszName || !*pszName)
    {
        image += 2;
    }
    else if (*pszName == '?')
    {
        image += 1;
    }
    return image;
}

//******************************************************************************
/*static*/ int CListViewFunction::CompareFunctions(CFunction *pFunction1, CFunction *pFunction2,
                                                   int sortColumn, BOOL fUndecorate)
{
    // Return Negative value if the first item should precede the second.
    // Return Positive value if the first item should follow the second.
    // Return Zero if the two items are equivalent.

    int    result = 0;
    LPCSTR psz1, psz2;

    // Compute the relationship based on the current sort column
    switch (sortColumn)
    {
        //------------------------------------------------------------------------
        case LVFC_IMAGE: // Image

            // Just sort by the image and return. We don't do a tie breakers
            // for the image column. This allows the user to sort by name, then
            // by image and have all the C++ functions group together and sorted
            // by name.
            return GetImage(pFunction1) - GetImage(pFunction2);

            //------------------------------------------------------------------------
        case LVFC_HINT: // Hint - Smallest to Largest, but N/A's (-1) come last.
            result = Compare((DWORD)pFunction1->GetHint(),
                             (DWORD)pFunction2->GetHint());
            break;

            //------------------------------------------------------------------------
        case LVFC_FUNCTION: // Function Name - String Sort with blanks at the end.
            psz1 = pFunction1->GetName();
            psz2 = pFunction2->GetName();

            if (psz1 && *psz1)
            {
                if (psz2 && *psz2)
                {
                    // Both are string - do string sort.
                    CHAR szUD1[1024], szUD2[1024];

                    // Check to see if we are viewing undecorated names
                    if (fUndecorate && g_theApp.m_pfnUnDecorateSymbolName)
                    {
                        // Attempt to undecorate function 1.
                        if (g_theApp.m_pfnUnDecorateSymbolName(psz1, szUD1,
                            sizeof(szUD1), UNDNAME_32_BIT_DECODE | UNDNAME_NAME_ONLY))
                        {
                            psz1 = szUD1;
                        }

                        // Attempt to undecorate function 2.
                        if (g_theApp.m_pfnUnDecorateSymbolName(psz2, szUD2,
                            sizeof(szUD2), UNDNAME_32_BIT_DECODE | UNDNAME_NAME_ONLY))
                        {
                            psz2 = szUD2;
                        }
                    }

                    // Walk over leading underscores in the function names so that
                    // we don't use them in the string compare.
                    while (*psz1 == '_')
                    {
                        psz1++;
                    }
                    while (*psz2 == '_')
                    {
                        psz2++;
                    }

                    // Compare the two strings.
                    result = _stricmp(psz1, psz2);
                }
                else
                {
                    // 1 is string, 2 is blank - 1 precedes 2
                    result = -1;
                }
            }
            else
            {
                if (psz2 && *psz2)
                {
                    // 1 is blank, 2 is string - 1 follows 2
                    result = 1;
                }
                else
                {
                    // Both are blank - Tie
                    result = 0;
                }
            }
            break;

            //------------------------------------------------------------------------
        case LVFC_ENTRYPOINT: // Entry Point

            // We sort differently if we are an export vs. and import
            if (pFunction1->IsExport())
            {
                psz1 = pFunction1->GetExportForwardName();
                psz2 = pFunction2->GetExportForwardName();

                if (psz1)
                {
                    if (psz2)
                    {
                        // 1 has forward string, 2 has forward string - String Sort
                        result = _stricmp(psz1, psz2);
                    }
                    else
                    {
                        // 1 has forward string, 2 has address - 1 follows 2
                        result = 1;
                    }
                }
                else
                {
                    if (psz2)
                    {
                        // 1 has address, 2 has forward string - 1 precedes 2
                        result = -1;
                    }
                    else
                    {
                        // 1 has address, 2 has address - Address compare
                        result = Compare(pFunction1->GetAddress(),
                                         pFunction2->GetAddress());
                    }
                }
            }
            else
            {
                // The item is an import - always a address compare
                result = Compare(pFunction1->GetAddress(),
                                 pFunction2->GetAddress());
            }
            break;
    }

    //---------------------------------------------------------------------------
    // If the sort resulted in a tie, we use the ordinal value to break the tie.
    if (result == 0)
    {
        // Smallest to Largest, but N/A's (-1) come last.
        result = Compare((DWORD)pFunction1->GetOrdinal(),
                         (DWORD)pFunction2->GetOrdinal());

        // If the result is still a tie, and we haven't already tried the hint value,
        // then sort by hint.
        if ((result == 0) && (sortColumn != LVFC_HINT))
        {
            // Smallest to Largest, but N/A's come last.
            result = Compare((DWORD)pFunction1->GetHint(),
                             (DWORD)pFunction2->GetHint());

        }
    }

    return result;
}

//******************************************************************************
/*static*/ int __cdecl CListViewFunction::QSortCompare(const void *ppFunction1, const void *ppFunction2)
{
    return CompareFunctions(*(CFunction**)ppFunction1, *(CFunction**)ppFunction2, ms_sortColumn, ms_fUndecorate);
}

//******************************************************************************
/*static*/ CFunction** CListViewFunction::GetSortedList(CModule *pModule, int sortColumn, bool fExports, bool fUndecorate)
{
    // Count the functions.
    int count = 0;
    for (CFunction *pFunction = fExports ? pModule->GetFirstModuleExport() :
         pModule->GetFirstParentModuleImport();
        pFunction; pFunction = pFunction->GetNextFunction())
    {
        count++;
    }

    // Allocate and array to hold pointers to all our original CFunction objects.
    CFunction **ppCur, **ppFunctions = (CFunction**)MemAlloc((count + 1) * sizeof(CFunction*));
    ZeroMemory(ppFunctions, (count + 1) * sizeof(CFunction*)); // inspected

    // Fill in our array.
    for (ppCur = ppFunctions,
         pFunction = fExports ? pModule->GetFirstModuleExport() :
         pModule->GetFirstParentModuleImport();
        pFunction; pFunction = pFunction->GetNextFunction(), ppCur++)
    {
        *ppCur = pFunction;
    }

    // Since the qsort function does not allow for any user data, we need to store
    // some info globally so it can be accessed in our callback.
    ms_sortColumn  = sortColumn;
    ms_fUndecorate = fUndecorate;

    // We ignore the called flag when sorting for file save.
    ms_fIgnoreCalledFlag = true;

    // Sort the array
    qsort(ppFunctions, count, sizeof(CFunction*), QSortCompare);

    ms_fIgnoreCalledFlag = false;

    return ppFunctions;
}

//******************************************************************************
/*static*/ void CListViewFunction::GetMaxFunctionWidths(CModule *pModule, int *pMaxWidths, bool fImports, bool fExports, bool fUndecorate)
{
    CHAR   szBuffer[1024];
    LPCSTR psz = NULL;
    int    column, width;

    // First check the max widths of our column headers.
    pMaxWidths[LVFC_IMAGE] = 6;
    for (column = 1; column < LVFC_COUNT; column++)
    {
        pMaxWidths[column] = (int)strlen(ms_szColumns[column]);
    }

    for (int i = (fImports ? 0 : 1); i < (fExports ? 2 : 1); i++)
    {
        // Compute the maximum width of each column.
        for (CFunction *pFunction = i ? pModule->GetFirstModuleExport() : pModule->GetFirstParentModuleImport();
             pFunction; pFunction = pFunction->GetNextFunction())
        {
            for (column = 1; column < LVFC_COUNT; column++)
            {
                switch (column)
                {
                    case LVFC_ORDINAL:    psz = pFunction->GetOrdinalString(szBuffer, sizeof(szBuffer));               break;
                    case LVFC_HINT:       psz = pFunction->GetHintString(szBuffer, sizeof(szBuffer));                  break;
                    case LVFC_FUNCTION:   psz = pFunction->GetFunctionString(szBuffer, sizeof(szBuffer), fUndecorate); break;
                    case LVFC_ENTRYPOINT: psz = pFunction->GetAddressString(szBuffer, sizeof(szBuffer));               break;
                }
                if ((width = (int)strlen(psz)) > pMaxWidths[column])
                {
                    pMaxWidths[column] = width;
                }
            }
        }
    }
}


//******************************************************************************
// CListViewFunction :: Public functions
//******************************************************************************

void CListViewFunction::SetCurrentModule(CModule *pModule)
{
    // This function is called by our document when we need to update our
    // function views to show a new module or to clear our current module (if
    // pModule is NULL). The Parent Imports View and the Exports View always act
    // in sync.  Their columns are the same width and they update their views at
    // the same time.

    // Since the results for all this processing is stored in a shared section
    // of our document, both views will have access to the data.  To sum up
    // everything, SetCurrentModule() only needs to be called for one of the two
    // function views to cause both views to get updated with a new module.

    GetDocument()->m_cImports = 0;
    GetDocument()->m_cExports = 0;

    // Make sure we are being passed an actual module.
    if (pModule)
    {
        // Determine the maximum parent export ordinal and hint values.
        for (CFunction *pFunction = pModule->GetFirstModuleExport();
            pFunction; pFunction = pFunction->GetNextFunction())
        {
            // While we are walking the export list, clear the called flag.
            pFunction->m_dwFlags &= ~DWFF_CALLED;

            // Increment our export count.
            GetDocument()->m_cExports++;
        }

        // Determine the maximum parent import ordinal and hint values.
        for (pFunction = pModule->GetFirstParentModuleImport();
            pFunction; pFunction = pFunction->GetNextFunction())
        {
            // While we are walking the import list, set the called flag on
            // each export we actually call.
            if (pFunction->GetAssociatedExport())
            {
                pFunction->GetAssociatedExport()->m_dwFlags |= DWFF_CALLED;
            }

            // Increment our import count.
            GetDocument()->m_cImports++;
        }
    }

    // Store this module as our current module.
    GetDocument()->m_pModuleCur = pModule;

    // We get a pointer to our DC so that we can call GetTextExtentPoint32() on
    // all of our strings to determine the maximum for each column.  We used
    // to call CListCtrl::GetStringWidth(), but that function is almost 4
    // times slower than GetTextExtentPoint32(). Once we get the DC, we need to
    // select our control's font into the DC since the List Control does not
    // use the system font that comes as the default in the DC.

    HDC   hDC = ::GetDC(GetSafeHwnd());
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
    }

    // Update our column widths.
    for (int column = 0; column < LVFC_COUNT; column++)
    {
        CalcColumnWidth(column, NULL, hDC);
        UpdateColumnWidth(column);
    }

    // Unselect our font and free our DC.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(hDC, hFontStock);
    }
    ::ReleaseDC(GetSafeHwnd(), hDC);
}

//******************************************************************************
void CListViewFunction::RealizeNewModule()
{
    // RealizeNewModule() is called for both function views after
    // SetCurrentModule() has been called.  SetCurrentModule() initializes the
    // shared data area in the document that RealizeNewModule() relies on.

    // Clear all items from the control.
    DeleteContents();

    // Make sure we have a current module.
    if (!GetDocument()->m_pModuleCur)
    {
        return;
    }

    CFunction *pFunctionHead, *pFunction;
    int        item = -1;

    // Since we know how many items we are going to add, we can help out the
    // list control by telling it the item count before adding items.  At the
    // same time, we grab a pointer to first node in the function list for this view.
    if (m_fExports)
    {
        GetListCtrl().SetItemCount(GetDocument()->m_cExports);
        pFunctionHead = GetDocument()->m_pModuleCur->GetFirstModuleExport();
    }
    else
    {
        GetListCtrl().SetItemCount(GetDocument()->m_cImports);
        pFunctionHead = GetDocument()->m_pModuleCur->GetFirstParentModuleImport();
    }

    // Loop through all our functions, adding them to our List Control.
    for (pFunction = pFunctionHead; pFunction;
        pFunction = pFunction->GetNextFunction())
    {
        // Add the item to our list control.
        item = GetListCtrl().InsertItem(LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM, ++item, NULL,
                                        0, 0, GetImage(pFunction), (LPARAM)pFunction);
    }

    // Apply our current sorting method to the List Control.
    Sort();
}

//******************************************************************************
void CListViewFunction::UpdateNameColumn()
{
    LVITEM lvi;
    lvi.mask = LVIF_IMAGE | LVIF_PARAM;
    lvi.iSubItem = 0;

    int count = GetListCtrl().GetItemCount();

    for (lvi.iItem = 0; lvi.iItem < count; lvi.iItem++)
    {
        GetListCtrl().GetItem(&lvi);

        //   1  C++  import  error
        //   4  C++  import  error  dynamic
        //   7  C++  import
        //  10  C++  import         dynamic
        //  13  C++  export  called
        //  16  C++  export  called forward
        //  19  C++  export  alo
        //  22  C++  export  alo    forward
        //  25  C++  export
        //  28  C++  export         forward

        if ((lvi.iImage ==  1) || (lvi.iImage ==  4) || (lvi.iImage ==  7) ||
            (lvi.iImage == 10) || (lvi.iImage == 13) || (lvi.iImage == 16) ||
            (lvi.iImage == 19) || (lvi.iImage == 22) || (lvi.iImage == 25) ||
            (lvi.iImage == 28))
        {
            GetListCtrl().SetItemText(lvi.iItem, LVFC_FUNCTION, LPSTR_TEXTCALLBACK);
        }
    }

    // Resort if we are sorted by function name.
    if (m_sortColumn == LVFC_FUNCTION)
    {
        Sort();
    }
}


//******************************************************************************
// CListViewFunction :: Internal functions
//******************************************************************************

void CListViewFunction::CalcColumnWidth(int column, CFunction *pFunction /*=NULL*/, HDC hDC /*=NULL*/)
{
    // If we don't have a module, then we start fresh and update the entire column.
    // Get the width of the header button text. We use GetStringWidth for this
    // since we want to use the font that is in the header control.
    if (!pFunction)
    {
        GetDocument()->m_cxColumns[column] = GetListCtrl().GetStringWidth(GetHeaderText(column)) +
                                             GetListCtrl().GetStringWidth(" ^") + 14;
    }

    // For the image column, we always use a fixed width.
    if (column == LVFC_IMAGE)
    {
        if (GetDocument()->m_cxColumns[LVFC_IMAGE] < 37)
        {
            GetDocument()->m_cxColumns[LVFC_IMAGE] = 37;
        }
        return;
    }

    // Get our DC and select our current font into it. We need to use this DC to
    // compute text widths in the control itself since our control may have a
    // different font caused from the user changing the system-wide "icon" font.
    bool  fFreeDC = false;
    HFONT hFontStock = NULL;
    if (!hDC)
    {
        hDC = ::GetDC(GetSafeHwnd());
        if (GetDocument()->m_hFontList)
        {
            hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
        }
        fFreeDC = true;
    }

    int cx;

    // Check to see if a particular module was passed in.
    if (pFunction)
    {
        // Compute the width of this column for the module passed in.
        cx = GetFunctionColumnWidth(hDC, pFunction, column);

        // check to see if it is a new widest.
        if ((cx + 10) > GetDocument()->m_cxColumns[column])
        {
            GetDocument()->m_cxColumns[column] = (cx + 10);
        }
    }
    else if (GetDocument()->m_pModuleCur)
    {
        for (int pass = 0; pass < 2; pass++)
        {
            // Pass 0 - loop through the exports, Pass 1 - loop through the parent imports.
            for (pFunction = pass ? GetDocument()->m_pModuleCur->GetFirstParentModuleImport() :
                 GetDocument()->m_pModuleCur->GetFirstModuleExport();
                 pFunction; pFunction = pFunction->GetNextFunction())
            {
                // Compute the width of this column.
                cx = GetFunctionColumnWidth(hDC, pFunction, column);

                // Check to see if it is a new widest.
                if ((cx + 10) > GetDocument()->m_cxColumns[column])
                {
                    GetDocument()->m_cxColumns[column] = (cx + 10);
                }
            }
        }
    }

    // Unselect our font and free our DC.
    if (fFreeDC)
    {
        if (GetDocument()->m_hFontList)
        {
            ::SelectObject(hDC, hFontStock);
        }
        ::ReleaseDC(GetSafeHwnd(), hDC);
    }
}

//*****************************************************************************
int CListViewFunction::GetFunctionColumnWidth(HDC hDC, CFunction *pFunction, int column)
{
    CHAR   szBuffer[1024];
    LPCSTR pszItem;

    switch (column)
    {
        case LVFC_ORDINAL:
            pszItem = pFunction->GetOrdinalString(szBuffer, sizeof(szBuffer));
            return GetTextWidth(hDC, pszItem, GetDocument()->GetOrdHintWidths(pszItem));

        case LVFC_HINT:
            pszItem = pFunction->GetHintString(szBuffer, sizeof(szBuffer));
            return GetTextWidth(hDC, pszItem, GetDocument()->GetOrdHintWidths(pszItem));

        case LVFC_FUNCTION:
            return GetTextWidth(hDC, pFunction->GetFunctionString(szBuffer, sizeof(szBuffer), GetDocument()->m_fViewUndecorated), NULL);

        case LVFC_ENTRYPOINT:
            pszItem = pFunction->GetAddressString(szBuffer, sizeof(szBuffer));
            return GetTextWidth(hDC, pszItem, GetDocument()->GetHexWidths(pszItem));
    }

    return 0;
}

//*****************************************************************************
void CListViewFunction::UpdateColumnWidth(int column)
{
    if (GetListCtrl().GetColumnWidth(column) != GetDocument()->m_cxColumns[column])
    {
        GetListCtrl().SetColumnWidth(column, GetDocument()->m_cxColumns[column]);
    }
}

//*****************************************************************************
void CListViewFunction::OnItemChanged(HD_NOTIFY *pHDNotify)
{
    // We can crash if we don't check the doc
    if (!GetDocument())
    {
        return;
    }

    // OnItemChanged() is called whenever the a column width has been modified.
    // If Full Drag is on, we will get a HDN_ITEMCHANGED when the column width
    // is changing.  When Full Drag is off we get a HDN_ITEMCHANGED when the
    // user has finished moving the slider around.

    // When the user changes a column width in one view, then we programmatically
    // change that column width in our neighboring view. We prevent re-entrancy
    // so that we don't get stuck in a loop since we are changing a column width
    // within the column width change notification handler.

    // Re-entrancy protection wrapper.
    static fInOnTrack = FALSE;
    if (!fInOnTrack)
    {
        fInOnTrack = TRUE;

        // Get the column information.
        CListViewFunction *pListViewNeighbor;

        // Get a pointer to our neighboring function list view.
        if (m_fExports)
        {
            pListViewNeighbor = GetDocument()->m_pListViewImports;
        }
        else
        {
            pListViewNeighbor = GetDocument()->m_pListViewExports;
        }

        // Resize our neighboring function list view's column to match ours. There
        // is a bug in several versions of the List Control that cause it to fill
        // in pHDNotify->pitem->cxy with an invalid value.  A work around is to
        // call GetColumnWidth() on our column and use that value as the width.

        if (pListViewNeighbor)
        {
            pListViewNeighbor->GetListCtrl().SetColumnWidth(
                                                           pHDNotify->iItem, GetListCtrl().GetColumnWidth(pHDNotify->iItem));
        }

        fInOnTrack = FALSE;
    }
}

//******************************************************************************
int CListViewFunction::CompareColumn(int item, LPCSTR pszText)
{
    CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);
    if (!pFunction)
    {
        return -2;
    }

    CHAR   szBuffer[1024];
    LPCSTR psz = szBuffer;
    ULONG  ulValue;

    switch (m_sortColumn)
    {
        case LVFC_ORDINAL:
            if (isdigit(*pszText))
            {
                if ((ulValue = strtoul(pszText, NULL, 0)) != ULONG_MAX)
                {
                    return Compare(ulValue, pFunction->GetOrdinal());
                }
            }
            return -2;

        case LVFC_HINT:
            if (isdigit(*pszText))
            {
                if ((ulValue = strtoul(pszText, NULL, 0)) != ULONG_MAX)
                {
                    return Compare(ulValue, pFunction->GetHint());
                }
            }
            return -2;

        case LVFC_FUNCTION:

            // Get the function name.
            psz = (LPSTR)pFunction->GetName();

            // Check to see if there is no function name.
            if (!psz || !*psz)
            {
                return -1;
            }

            // Attempt to undecorate the name if we are asked to,
            if (GetDocument()->m_fViewUndecorated && g_theApp.m_pfnUnDecorateSymbolName &&
                g_theApp.m_pfnUnDecorateSymbolName(psz, szBuffer, sizeof(szBuffer),
                                                   UNDNAME_32_BIT_DECODE | UNDNAME_NAME_ONLY))
            {
                psz = szBuffer;
            }

            // Walk over leading underscores in the function name.
            while (*psz == '_')
            {
                psz++;
            }
            break;

        case LVFC_ENTRYPOINT:
            psz = pFunction->GetAddressString(szBuffer, sizeof(szBuffer));
            break;

        default:
            return -2;
    }

    INT i = _stricmp(pszText, psz);
    return (i < 0) ? -1 :
           (i > 0) ?  1 : 0;
}

//******************************************************************************
void CListViewFunction::Sort(int sortColumn /*=-1*/)
{
    // Bail now if we don't need to sort.
    if ((m_sortColumn == sortColumn) && (sortColumn != -1))
    {
        return;
    }

    // If the default arg is used, then just re-sort with our current sort column.
    if (sortColumn == -1)
    {
        GetListCtrl().SortItems(StaticCompareFunc, (DWORD_PTR)this);
    }

    // Otherwise, we need to re-sort and update our column header text.
    else
    {
        LVCOLUMN lvc;
        lvc.mask = LVCF_TEXT;

        if (m_sortColumn >= 0)
        {
            // Remove the "^" from the previous sort column header item.
            lvc.pszText = (LPSTR)GetHeaderText(m_sortColumn);
            GetListCtrl().SetColumn(m_sortColumn, &lvc);
        }

        // Store our new sort column.
        m_sortColumn = sortColumn;

        // Add the "^" to our new sort column header item.
        CHAR szColumn[32];
        lvc.pszText = StrCCat(StrCCpy(szColumn, GetHeaderText(m_sortColumn), sizeof(szColumn)),
                             m_sortColumn ? " ^" : "^", sizeof(szColumn));
        GetListCtrl().SetColumn(m_sortColumn, &lvc);

        // Apply our new sorting method the List Control.
        GetListCtrl().SortItems(StaticCompareFunc, (DWORD_PTR)this);
    }

    // If we have an item that has the focus, then make sure it is visible.
    int item = GetFocusedItem();
    if (item >= 0)
    {
        GetListCtrl().EnsureVisible(item, FALSE);
    }
}

//******************************************************************************
int CListViewFunction::CompareFunc(CFunction *pFunction1, CFunction *pFunction2)
{
    return CompareFunctions(pFunction1, pFunction2, m_sortColumn, GetDocument()->m_fViewUndecorated);
}


//******************************************************************************
// CListViewFunction :: Overridden functions
//******************************************************************************

BOOL CListViewFunction::PreCreateWindow(CREATESTRUCT &cs)
{
    // Set our window style and then complete the creation of our view.
    cs.style |= LVS_REPORT | LVS_OWNERDRAWFIXED | LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS;
    return CSmartListView::PreCreateWindow(cs);
}

//******************************************************************************
#if 0 //{{AFX
BOOL CListViewFunction::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CListViewFunction::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CListViewFunction::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}
#endif //}}AFX

//******************************************************************************
void CListViewFunction::OnInitialUpdate()
{
    // Set our list control's image list with our application's global image list.
    // We do this just as a means of setting the item height for each item.
    // Since we are owner draw, we will actually be drawing our own images.
    GetListCtrl().SetImageList(&g_theApp.m_ilFunctions, LVSIL_SMALL);

    // Initialize our font and fixed width character spacing arrays.
    GetDocument()->InitFontAndFixedWidths(this);

    // Add all of our columns.
    for (int column = 0; column < LVFC_COUNT; column++)
    {
        GetListCtrl().InsertColumn(column, GetHeaderText(column));
    }

    // Sort by our default sort column.
    Sort(ReadSortColumn(m_fExports));
}

//******************************************************************************
LRESULT CListViewFunction::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // We catch the HDN_ITEMCHANGED notification message here because of a bug in
    // MFC. The ON_NOTIFY() macro for HDN_XXX notification messages prevent the
    // List Control from getting the message which cause problems with the UI.
    // By hooking the message here, we allow MFC to continue processing the
    // message and send it to the List Control.

    if ((message == WM_NOTIFY) && ((((LPNMHDR)lParam)->code == HDN_ITEMCHANGEDA) ||
                                   (((LPNMHDR)lParam)->code == HDN_ITEMCHANGEDW)))
    {
        OnItemChanged((HD_NOTIFY*)lParam);
    }

    return CSmartListView::WindowProc(message, wParam, lParam);
}

//******************************************************************************
void CListViewFunction::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    // Make sure everything is valid.
    if (!lpDIS->itemData)
    {
        return;
    }

    // Use our global font that the control was created with.
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(lpDIS->hDC, GetDocument()->m_hFontList);
    }

    // Make sure text alignment is set to top.  This should be the default.
    ::SetTextAlign(lpDIS->hDC, TA_TOP);

    // Get a pointer to our CModule for this item.
    CFunction *pFunction = (CFunction*)lpDIS->itemData;

    // Select the background and text colors.
    ::SetBkColor  (lpDIS->hDC, GetSysColor(COLOR_WINDOW));
    ::SetTextColor(lpDIS->hDC, GetSysColor(COLOR_WINDOWTEXT));

    // Create a copy of our item's rectangle so we can manipulate the values.
    CRect rcClip(&lpDIS->rcItem);

    CHAR   szBuffer[1024];
    LPCSTR pszItem;
    int    imageWidth = 0, left = rcClip.left, width, *pWidths;

    for (int column = 0; column < LVFC_COUNT; column++)
    {
        // Compute the width for this column.
        width = GetListCtrl().GetColumnWidth(column);

        // Compute the clipping rectangle for this column's text.
        if (column == LVFC_IMAGE)
        {
            rcClip.left  = left;
            rcClip.right = left + width;
        }
        else if (column > LVFC_ORDINAL)
        {
            rcClip.left  = left + 5;
            rcClip.right = left + width - 5;
        }

        // Call the correct routine to draw this column's text.
        switch (column)
        {
            case LVFC_IMAGE:

                // Store the width for later calculations.
                imageWidth = width;

                // Erase the image area with the window background color.
                ::ExtTextOut(lpDIS->hDC, rcClip.left, rcClip.top, ETO_OPAQUE, &rcClip, "", 0, NULL);

                // Draw the image in the image area.
                ImageList_Draw(g_theApp.m_ilFunctions.m_hImageList, GetImage(pFunction),
                               lpDIS->hDC, rcClip.left + 3, rcClip.top + ((rcClip.Height() - 14) / 2),
                               m_fFocus && (lpDIS->itemState & ODS_SELECTED) ?
                               (ILD_BLEND50 | ILD_SELECTED | ILD_BLEND) : ILD_TRANSPARENT);
                break;

            case LVFC_ORDINAL:

                // If the item is selected, then select new background and text colors.
                if (lpDIS->itemState & ODS_SELECTED)
                {
                    ::SetBkColor  (lpDIS->hDC, GetSysColor(m_fFocus ? COLOR_HIGHLIGHT     : COLOR_BTNFACE));
                    ::SetTextColor(lpDIS->hDC, GetSysColor(m_fFocus ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
                }

                // Erase the text area with the window background color.
                rcClip.left = rcClip.right;
                rcClip.right = lpDIS->rcItem.right;
                ::ExtTextOut(lpDIS->hDC, rcClip.left, rcClip.top, ETO_OPAQUE, &rcClip, "", 0, NULL);

                rcClip.left  = left + 5;
                rcClip.right = left + width - 5;

                pszItem = pFunction->GetOrdinalString(szBuffer, sizeof(szBuffer));
                if (pWidths = GetDocument()->GetOrdHintWidths(pszItem))
                {
                    DrawRightText(lpDIS->hDC, pszItem, &rcClip, GetDocument()->m_cxColumns[LVFC_ORDINAL] - 10, pWidths);
                }
                else
                {
                    DrawLeftText(lpDIS->hDC, pszItem, &rcClip);
                }
                break;

            case LVFC_HINT:
                pszItem = pFunction->GetHintString(szBuffer, sizeof(szBuffer));
                if (pWidths = GetDocument()->GetOrdHintWidths(pszItem))
                {
                    DrawRightText(lpDIS->hDC, pszItem, &rcClip, GetDocument()->m_cxColumns[LVFC_HINT] - 10, pWidths);
                }
                else
                {
                    DrawLeftText(lpDIS->hDC, pszItem, &rcClip);
                }
                break;

            case LVFC_FUNCTION:
                pszItem = pFunction->GetFunctionString(szBuffer, sizeof(szBuffer), GetDocument()->m_fViewUndecorated);
                DrawLeftText(lpDIS->hDC, pszItem, &rcClip, NULL);
                break;

            case LVFC_ENTRYPOINT:
                pszItem = pFunction->GetAddressString(szBuffer, sizeof(szBuffer));
                DrawLeftText(lpDIS->hDC, pszItem, &rcClip, GetDocument()->GetHexWidths(pszItem));
                break;
        }

        // Draw a vertical divider line between the columns.
        ::MoveToEx(lpDIS->hDC, left + width - 1, rcClip.top, NULL);
        ::LineTo  (lpDIS->hDC, left + width - 1, rcClip.bottom);

        // Increment our location to the beginning of the next column
        left += width;
    }

    // Draw the focus box if this item has the focus.
    if (m_fFocus && (lpDIS->itemState & ODS_FOCUS))
    {
        rcClip.left  = lpDIS->rcItem.left + imageWidth;
        rcClip.right = lpDIS->rcItem.right;
        ::DrawFocusRect(lpDIS->hDC, &rcClip);
    }

    // Unselect our font.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(lpDIS->hDC, hFontStock);
    }
}

//******************************************************************************
// CListViewFunction :: Event handler functions
//******************************************************************************

void CListViewFunction::OnDividerDblClick(NMHDR *pNMHDR, LRESULT *pResult)
{
    int column = ((HD_NOTIFY*)pNMHDR)->iItem;

    // Set this column width to its "best fit" width.
    GetListCtrl().SetColumnWidth(column, GetDocument()->m_cxColumns[column]);
    *pResult = TRUE;
}

//******************************************************************************
void CListViewFunction::OnRClick(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Ask our main frame to display our context menu.
    g_pMainFrame->DisplayPopupMenu(1);

    *pResult = FALSE;
}

//******************************************************************************
void CListViewFunction::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // Double-click or enter is used to do help lookup.
    OnExternalHelp();

    *pResult = FALSE;
}

//******************************************************************************
void CListViewFunction::OnReturn(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // Double-click or enter is used to do help lookup.
    OnExternalHelp();

    *pResult = FALSE;
}

//******************************************************************************
void CListViewFunction::OnUpdateEditCopy(CCmdUI *pCmdUI)
{
    // Get the number of selected items.
    int count = GetListCtrl().GetSelectedCount();

    // Set the text according to how many items are selected.
    pCmdUI->SetText((count == 1) ? "&Copy Function Name\tCtrl+C" : "&Copy Function Names\tCtrl+C");

    // Enable the copy command if at least one function is selected.
    pCmdUI->Enable(count > 0);
}

//******************************************************************************
void CListViewFunction::OnEditCopy()
{
    CString strNames;
    CHAR szBuffer[1024];

    // Loop through all the selected functions.
    int item = -1, count = 0;
    while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
    {
        // Get the function object from the item.
        CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);

        // If this item is not the first, then insert a newline.
        if (count++)
        {
            strNames += "\r\n";
        }

        // Add the text for this function to our string.
        if (pFunction->GetName())
        {
            strNames += pFunction->GetFunctionString(szBuffer, sizeof(szBuffer), GetDocument()->m_fViewUndecorated);
        }
        else if (pFunction->GetOrdinal() >= 0)
        {
            CHAR szOrdinal[40];
            SCPrintf(szOrdinal, sizeof(szOrdinal), "%u (0x%04X)", pFunction->GetOrdinal(), pFunction->GetOrdinal());
            strNames += szOrdinal;
        }
    }

    // If we added more than one item, then we append a newline to the end.
    if (count > 1)
    {
        strNames += "\r\n";
    }

    // Copy the string list to the clipboard.
    g_pMainFrame->CopyTextToClipboard(strNames);
}

//******************************************************************************
void CListViewFunction::OnEditSelectAll()
{
    // Loop through every function in our list and select them all.
    for (int item = GetListCtrl().GetItemCount() - 1; item >= 0; item--)
    {
        GetListCtrl().SetItemState(item, LVIS_SELECTED, LVIS_SELECTED);
    }
}

//******************************************************************************
void CListViewFunction::OnUpdateExternalHelp(CCmdUI* pCmdUI) 
{
    // Make sure our "Enter" accelerator is part of the string.
    pCmdUI->SetText("Lookup Function in External &Help\tEnter");

    // Make sure we have a CMsdnHelp object - we always should.
    if (g_theApp.m_pMsdnHelp)
    {
        // Get the item that has the focus.
        int item = GetFocusedItem();

        // Check to see if we found an item.
        if (item >= 0)
        {
            // Get the function associated with this item.
            CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);
            if (pFunction)
            {
                // Get the function name for this item.
                LPCSTR pszFunction = pFunction->GetName();
                if (pszFunction && *pszFunction)
                {
                    // If we have a name, then enable this menu item.
                    pCmdUI->Enable(TRUE);
                    return;
                }
            }
        }
    }

    // If we failed to find a valid function name, then disable the menu item.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CListViewFunction::OnExternalHelp() 
{
    // Make sure we have a CMsdnHelp object - we always should.
    if (g_theApp.m_pMsdnHelp)
    {
        // Get the item that has the focus.
        int item = GetFocusedItem();

        // Check to see if we found an item.
        if (item >= 0)
        {
            // Get the function associated with this item.
            CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);
            if (pFunction)
            {
                // Get the function name for this item.
                LPCSTR pszFunction = pFunction->GetName();
                if (pszFunction && *pszFunction)
                {
                    // Attempt to decode the function name.
                    CHAR szBuffer[1024];
                    *szBuffer = '\0';
                    if (!g_theApp.m_pfnUnDecorateSymbolName ||
                        !g_theApp.m_pfnUnDecorateSymbolName(pszFunction, szBuffer,
                            sizeof(szBuffer), UNDNAME_32_BIT_DECODE | UNDNAME_NAME_ONLY) ||
                        !*szBuffer)
                    {
                        // If anything failed, then just use the raw function name.
                        StrCCpy(szBuffer, pszFunction, sizeof(szBuffer));
                    }

                    // Remove any trailing uppercase 'A' or 'W'.
                    int length = (int)strlen(szBuffer);
                    if (('A' == szBuffer[length - 1]) || ('W' == szBuffer[length - 1]))
                    {
                        szBuffer[--length] = '\0';
                    }

                    // Tell our CMsdnHelp object to do its magic.
                    if (g_theApp.m_pMsdnHelp->DisplayHelp(szBuffer))
                    {
                        return;
                    }
                }
            }
        }
    }

    // Beep to signify an error.
    MessageBeep(0);
}

//******************************************************************************
void CListViewFunction::OnUpdateExternalViewer(CCmdUI* pCmdUI) 
{
    // Make sure the "Enter" accelerator is not part of this string.
    pCmdUI->SetText("View Module in External &Viewer");

    // Enable this command if we currently have a module.
    pCmdUI->Enable(GetDocument()->IsLive() && (GetDocument()->m_pModuleCur != NULL));
}

//******************************************************************************
void CListViewFunction::OnExternalViewer() 
{
    if (GetDocument()->m_pModuleCur)
    {
        g_theApp.m_dlgViewer.LaunchExternalViewer(
            GetDocument()->m_pModuleCur->GetName(true));
    }
}

//******************************************************************************
void CListViewFunction::OnUpdateProperties(CCmdUI* pCmdUI) 
{
    // Enable this command if we currently have a module.
    pCmdUI->Enable(GetDocument()->IsLive() && (GetDocument()->m_pModuleCur != NULL));
}

//******************************************************************************
void CListViewFunction::OnProperties() 
{
    if (GetDocument()->m_pModuleCur)
    {
        PropertiesDialog(GetDocument()->m_pModuleCur->GetName(true));
    }
}


//******************************************************************************
//***** CListViewImports
//******************************************************************************

IMPLEMENT_DYNCREATE(CListViewImports, CListViewFunction)
BEGIN_MESSAGE_MAP(CListViewImports, CListViewFunction)
    //{{AFX_MSG_MAP(CListViewImports)
    ON_COMMAND(ID_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_PREV_PANE, OnPrevPane)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_MATCHING_ITEM, OnUpdateShowMatchingItem)
    ON_COMMAND(IDM_SHOW_MATCHING_ITEM, OnShowMatchingItem)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()

//******************************************************************************
// CListViewImports :: Constructor/Destructor
//******************************************************************************

CListViewImports::CListViewImports() :
    CListViewFunction(false)
{
}

//******************************************************************************
CListViewImports::~CListViewImports()
{
}


//******************************************************************************
// CListViewImports :: Public functions
//******************************************************************************

void CListViewImports::AddDynamicImport(CFunction *pImport)
{
    // Add the item to the end of our list control.
    GetListCtrl().InsertItem(LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM,
                             GetDocument()->m_cImports++, LPSTR_TEXTCALLBACK,
                             0, 0, GetImage(pImport), (LPARAM)pImport);

    HDC   hDC = ::GetDC(GetSafeHwnd());
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
    }

    // Loop through each column to determine if we have set a new max width.
    for (int column = 0; column < LVFC_COUNT; column++)
    {
        CalcColumnWidth(column, pImport, hDC);
        UpdateColumnWidth(column);
    }

    // Unselect our font and free our DC.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(hDC, hFontStock);
    }
    ::ReleaseDC(GetSafeHwnd(), hDC);

    // Apply our current sorting method to the List Control.
    Sort();
}

//******************************************************************************
void CListViewImports::HighlightFunction(CFunction *pExport)
{
    int item = -1, count = GetListCtrl().GetItemCount();

    // Unselect all functions in our list.
    while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
    {
        GetListCtrl().SetItemState(item, 0, LVNI_SELECTED);
    }

    // Loop through each import in the list.
    for (item = 0; item < count; item++)
    {
        // Get the function associated with this item.
        CFunction *pImport = (CFunction*)GetListCtrl().GetItemData(item);

        // Check to see if this import points to the export we are looking for.
        if (pImport && (pImport->GetAssociatedExport() == pExport))
        {
            // Select the item and ensure that it is visible.
            GetListCtrl().SetItemState(item, LVNI_SELECTED | LVNI_FOCUSED, LVNI_SELECTED | LVNI_FOCUSED);
            GetListCtrl().EnsureVisible(item, FALSE);

            // Give ourself the focus.
            GetParentFrame()->SetActiveView(this);
            break;
        }
    }
}


//******************************************************************************
// CListViewImports :: Event handler functions
//******************************************************************************

void CListViewImports::OnUpdateShowMatchingItem(CCmdUI* pCmdUI)
{
    // Set the text to for this menu item.
    pCmdUI->SetText("&Highlight Matching Export Function\tCtrl+M");

    // Get the item that has the focus.
    int item = GetFocusedItem();

    // Check to see if we found an item.
    if (item >= 0)
    {
        // Get the function associated with this item.
        CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);

        // If the function is resolved, then enable this command.
        if (pFunction && pFunction->GetAssociatedExport())
        {
            pCmdUI->Enable(TRUE);
            return;
        }
    }

    // If we make it here, then we failed to find a reason to enable the command.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CListViewImports::OnShowMatchingItem()
{
    // Get the item that has the focus.
    int item = GetFocusedItem();

    // Check to see if we found an item.
    if (item >= 0)
    {
        // Get the function associated with this item.
        CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);

        // If we have a function, then tell our export view to find and highlight
        // the associated export function.
        if (pFunction && pFunction->GetAssociatedExport())
        {
            GetDocument()->m_pListViewExports->HighlightFunction(pFunction->GetAssociatedExport());
        }
    }
}

//******************************************************************************
void CListViewImports::OnNextPane()
{
    // Change the focus to our next pane, the Exports View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewExports);
}

//******************************************************************************
void CListViewImports::OnPrevPane()
{
    // Change the focus to our previous pane, the Module Dependency Tree View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pTreeViewModules);
}

//******************************************************************************
LRESULT CListViewImports::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    // Called when the context help pointer (SHIFT+F1) is clicked on our client.
    return (0x20000 + IDR_IMPORT_LIST_VIEW);
}

//******************************************************************************
LRESULT CListViewImports::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    // Called when the user chooses help (F1) while our view is active.
    g_theApp.WinHelp(0x20000 + IDR_IMPORT_LIST_VIEW);
    return TRUE;
}


//******************************************************************************
//***** CListViewExports
//******************************************************************************

IMPLEMENT_DYNCREATE(CListViewExports, CListViewFunction)
BEGIN_MESSAGE_MAP(CListViewExports, CListViewFunction)
    //{{AFX_MSG_MAP(CListViewExports)
    ON_COMMAND(ID_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_PREV_PANE, OnPrevPane)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_MATCHING_ITEM, OnUpdateShowMatchingItem)
    ON_COMMAND(IDM_SHOW_MATCHING_ITEM, OnShowMatchingItem)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()

//******************************************************************************
// CListViewExports :: Constructor/Destructor
//******************************************************************************

CListViewExports::CListViewExports() :
    CListViewFunction(true)
{
}

//******************************************************************************
CListViewExports::~CListViewExports()
{
}


//******************************************************************************
// CListViewExports :: Public functions
//******************************************************************************

void CListViewExports::AddDynamicImport(CFunction *pImport)
{
    // Check to see if this import has been resolved to an export.
    CFunction *pExport = pImport->GetAssociatedExport();
    if (!pExport)
    {
        return;
    }
    pExport->m_dwFlags |= DWFF_CALLED;

    // Find the function in our list that goes with this function object.
    LVITEM lvi;
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pExport;
    if ((lvi.iItem = GetListCtrl().FindItem(&lvfi)) < 0)
    {
        return;
    }

    // Update the image for this export.
    lvi.mask = LVIF_IMAGE;
    lvi.iSubItem = 0;
    lvi.iImage = GetImage(pExport);
    GetListCtrl().SetItem(&lvi);

    // If we are sorted by image, then resort.
    if (m_sortColumn == LVFC_IMAGE)
    {
        Sort();
    }
}

//******************************************************************************
void CListViewExports::ExportsChanged()
{
    // If we are sorted by icon, then resort.
    if (m_sortColumn == LVFC_IMAGE)
    {
        Sort();
    }

    // Force our icons to update.
    CRect rc;
    GetClientRect(&rc);
    rc.right = GetListCtrl().GetColumnWidth(0);
    InvalidateRect(&rc, FALSE);
}

//******************************************************************************
void CListViewExports::HighlightFunction(CFunction *pExport)
{
    // Unselect all functions in our list.
    for (int item = -1; (item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0; )
    {
        GetListCtrl().SetItemState(item, 0, LVNI_SELECTED);
    }

    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pExport;

    // Find the function in our list that goes with this function object.
    if ((item = GetListCtrl().FindItem(&lvfi)) >= 0)
    {
        // Select the item and ensure that it is visible.
        GetListCtrl().SetItemState(item, LVNI_SELECTED | LVNI_FOCUSED, LVNI_SELECTED | LVNI_FOCUSED);
        GetListCtrl().EnsureVisible(item, FALSE);

        // Give ourself the focus.
        GetParentFrame()->SetActiveView(this);
    }
}


//******************************************************************************
// CListViewExports :: Event handler functions
//******************************************************************************

void CListViewExports::OnUpdateShowMatchingItem(CCmdUI* pCmdUI)
{
    // Set the text to for this menu item.
    pCmdUI->SetText("&Highlight Matching Import Function\tCtrl+M");

    // Get the item that has the focus.
    LVITEM lvi;
    lvi.iItem = GetFocusedItem();

    // Check to see if we found an item.
    if (lvi.iItem >= 0)
    {
        // Get the item's image.
        lvi.mask = LVIF_IMAGE;
        lvi.iSubItem = 0;
        GetListCtrl().GetItem(&lvi);

        // If the image shows that the function is called, then enable this command.
        if ((lvi.iImage >= 12) && (lvi.iImage <= 17))
        {
            pCmdUI->Enable(TRUE);
            return;
        }
    }

    // If we make it here, then we failed to find a reason to enable the command.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CListViewExports::OnShowMatchingItem()
{
    // Get the item that has the focus.
    int item = GetFocusedItem();

    // Check to see if we found an item.
    if (item >= 0)
    {
        // Get the function associated with this item.
        CFunction *pFunction = (CFunction*)GetListCtrl().GetItemData(item);

        // If we have a function, then tell our import view to find and highlight
        // the import function that is associated with this export.
        if (pFunction)
        {
            GetDocument()->m_pListViewImports->HighlightFunction(pFunction);
        }
    }
}

//******************************************************************************
void CListViewExports::OnNextPane()
{
    // Change the focus to our next pane, the Module List View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewModules);
}

//******************************************************************************
void CListViewExports::OnPrevPane()
{
    // Change the focus to our next pane, the Parent Imports View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewImports);
}

//******************************************************************************
LRESULT CListViewExports::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    // Called when the context help pointer (SHIFT+F1) is clicked on our client.
    return (0x20000 + IDR_EXPORT_LIST_VIEW);
}

//******************************************************************************
LRESULT CListViewExports::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    // Called when the user chooses help (F1) while our view is active.
    g_theApp.WinHelp(0x20000 + IDR_EXPORT_LIST_VIEW);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\document.cpp ===
//******************************************************************************
//
// File:        DOCUMENT.CPP
//
// Description: Implementation file for the Document class.
//
// Classes:     CDocDepends
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "search.h"
#include "dbgthread.h"
#include "session.h"
#include "document.h"
#include "splitter.h"
#include "mainfrm.h"
#include "childfrm.h"
#include "listview.h"
#include "modtview.h"
#include "modlview.h"
#include "profview.h"
#include "funcview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CDocDepends
//******************************************************************************

IMPLEMENT_DYNCREATE(CDocDepends, CDocument)
BEGIN_MESSAGE_MAP(CDocDepends, CDocument)
    //{{AFX_MSG_MAP(CDocDepends)
    ON_COMMAND(ID_FILE_SAVE, OnFileSave)
    ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_MATCHING_ITEM, OnUpdateShowMatchingItem)
    ON_UPDATE_COMMAND_UI(IDM_EDIT_LOG_CLEAR, OnUpdateEditClearLog)
    ON_COMMAND(IDM_EDIT_LOG_CLEAR, OnEditClearLog)
    ON_UPDATE_COMMAND_UI(IDM_VIEW_FULL_PATHS, OnUpdateViewFullPaths)
    ON_COMMAND(IDM_VIEW_FULL_PATHS, OnViewFullPaths)
    ON_UPDATE_COMMAND_UI(IDM_VIEW_UNDECORATED, OnUpdateViewUndecorated)
    ON_COMMAND(IDM_VIEW_UNDECORATED, OnViewUndecorated)
    ON_COMMAND(IDM_EXPAND_ALL, OnExpandAll)
    ON_COMMAND(IDM_COLLAPSE_ALL, OnCollapseAll)
    ON_UPDATE_COMMAND_UI(IDM_REFRESH, OnUpdateRefresh)
    ON_COMMAND(IDM_REFRESH, OnFileRefresh)
    ON_COMMAND(IDM_VIEW_SYS_INFO, OnViewSysInfo)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_VIEWER, OnUpdateExternalViewer)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_HELP, OnUpdateExternalHelp)
    ON_UPDATE_COMMAND_UI(IDM_EXECUTE, OnUpdateExecute)
    ON_COMMAND(IDM_EXECUTE, OnExecute)
    ON_UPDATE_COMMAND_UI(IDM_TERMINATE, OnUpdateTerminate)
    ON_COMMAND(IDM_TERMINATE, OnTerminate)
    ON_COMMAND(IDM_CONFIGURE_SEARCH_ORDER, OnConfigureSearchOrder)
    ON_UPDATE_COMMAND_UI(IDM_AUTO_EXPAND, OnUpdateAutoExpand)
    ON_COMMAND(IDM_AUTO_EXPAND, OnAutoExpand)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_ORIGINAL_MODULE, OnUpdateShowOriginalModule)
    ON_COMMAND(IDM_SHOW_ORIGINAL_MODULE, OnShowOriginalModule)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_PREVIOUS_MODULE, OnUpdateShowPreviousModule)
    ON_COMMAND(IDM_SHOW_PREVIOUS_MODULE, OnShowPreviousModule)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_NEXT_MODULE, OnUpdateShowNextModule)
    ON_COMMAND(IDM_SHOW_NEXT_MODULE, OnShowNextModule)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
// CDocDepends :: Constructor/Destructor
//******************************************************************************

CDocDepends::CDocDepends() :

    m_fInitialized(false),
    m_fError(false),
    m_fChildProcess(g_theApp.m_pProcess != NULL),
    m_psgHead(NULL),
    m_saveType(ST_UNKNOWN),

    m_fCommandLineProfile(g_theApp.m_cmdInfo.m_fProfile),
    m_pSession(NULL),
    m_strProfileDirectory(g_theApp.m_cmdInfo.m_pszProfileDirectory ? g_theApp.m_cmdInfo.m_pszProfileDirectory : ""),
    m_strProfileArguments(g_theApp.m_cmdInfo.m_pszProfileArguments ? g_theApp.m_cmdInfo.m_pszProfileArguments : ""),

    // Set the profile flags.  The only special case is that we disable the
    // clear log flag when in auto-profile mode or profiling child processes.
    // This is to prevent errors from being cleared before the user has had a
    // chance to see them.
    m_dwProfileFlags(
        ((!m_fCommandLineProfile && !m_fChildProcess && CRichViewProfile::ReadLogClearSetting()) ? PF_LOG_CLEAR : 0) |
        (CRichViewProfile::ReadSimulateShellExecute()   ? PF_SIMULATE_SHELLEXECUTE    : 0) |
        (CRichViewProfile::ReadLogDllMainProcessMsgs()  ? PF_LOG_DLLMAIN_PROCESS_MSGS : 0) |
        (CRichViewProfile::ReadLogDllMainOtherMsgs()    ? PF_LOG_DLLMAIN_OTHER_MSGS   : 0) |
        (CRichViewProfile::ReadHookProcess()            ? PF_HOOK_PROCESS             : 0) |
        (CRichViewProfile::ReadLogLoadLibraryCalls()    ? PF_LOG_LOADLIBRARY_CALLS    : 0) |
        (CRichViewProfile::ReadLogGetProcAddressCalls() ? PF_LOG_GETPROCADDRESS_CALLS : 0) |
        (CRichViewProfile::ReadLogThreads()             ? PF_LOG_THREADS              : 0) |
        (CRichViewProfile::ReadUseThreadIndexes()       ? PF_USE_THREAD_INDEXES       : 0) |
        (CRichViewProfile::ReadLogExceptions()          ? PF_LOG_EXCEPTIONS           : 0) |
        (CRichViewProfile::ReadLogDebugOutput()         ? PF_LOG_DEBUG_OUTPUT         : 0) |
        (CRichViewProfile::ReadUseFullPaths()           ? PF_USE_FULL_PATHS           : 0) |
        (CRichViewProfile::ReadLogTimeStamps()          ? PF_LOG_TIME_STAMPS          : 0) |
        (CRichViewProfile::ReadChildren()               ? PF_PROFILE_CHILDREN         : 0)),

    m_pChildFrame(NULL),
    // m_fDetailView(FALSE),
    m_pTreeViewModules(NULL),
    m_pListViewModules(NULL),
    m_pListViewImports(NULL),
    // m_pRichViewDetails(NULL),
    m_pListViewExports(NULL),
    m_pRichViewProfile(NULL),

    m_fViewFullPaths  (ReadFullPathsSetting()),
    m_fViewUndecorated(ReadUndecorateSetting()),
    m_fAutoExpand     (ReadAutoExpandSetting()),

    m_fWarnToRefresh(FALSE),

    m_hFontList(NULL),
    m_cxDigit(0),
    m_cxSpace(0),
    m_cxAP(0),

    m_pModuleCur(NULL),
    m_cImports(0),
    m_cExports(0)
{
    ZeroMemory(m_cxHexWidths, sizeof(m_cxHexWidths)); // inspected
    ZeroMemory(m_cxOrdHintWidths, sizeof(m_cxOrdHintWidths)); // inspected
    ZeroMemory(m_cxTimeStampWidths, sizeof(m_cxTimeStampWidths)); // inspected
    ZeroMemory(m_cxColumns, sizeof(m_cxColumns)); // inspected

    // We temporarily store a pointer to ourself so our child frame window can
    // access some of our members.  Our child frame window is created immediately
    // after us and needs to be able to locate our class object.
    g_theApp.m_pNewDoc = this;

    // Clear the profile flag so that other documents will not auto-start profiling.
    g_theApp.m_cmdInfo.m_fProfile = false;
    g_theApp.m_cmdInfo.m_pszProfileDirectory = NULL;
    g_theApp.m_cmdInfo.m_pszProfileArguments = NULL;

    g_theApp.m_cmdInfo.m_autoExpand = -1;
    g_theApp.m_cmdInfo.m_fullPaths  = -1;
    g_theApp.m_cmdInfo.m_undecorate = -1;
}

//******************************************************************************
CDocDepends::~CDocDepends()
{
    // Free our search order.
    CSearchGroup::DeleteSearchOrder(m_psgHead);

    // Destroy our list font.
    if (m_hFontList)
    {
        ::DeleteObject(m_hFontList);
        m_hFontList = NULL;
    }
}


//******************************************************************************
// CDocDepends :: Public Static functions
//******************************************************************************

/*static*/ bool CDocDepends::ReadAutoExpandSetting()
{
    return g_theApp.GetProfileInt(g_pszSettings, "AutoExpand", false) ? true : false; // inspected. MFC function
}

//******************************************************************************
/*static*/ void CDocDepends::WriteAutoExpandSetting(bool fAutoExpand)
{
    g_theApp.WriteProfileInt(g_pszSettings, "AutoExpand", fAutoExpand ? 1 : 0);
}

//******************************************************************************
/*static*/ bool CDocDepends::ReadFullPathsSetting()
{
    return g_theApp.GetProfileInt(g_pszSettings, "ViewFullPaths", false) ? true : false; // inspected. MFC function
}

//******************************************************************************
/*static*/ void CDocDepends::WriteFullPathsSetting(bool fFullPaths)
{
    g_theApp.WriteProfileInt(g_pszSettings, "ViewFullPaths", fFullPaths ? 1 : 0);
}

//******************************************************************************
/*static*/ bool CDocDepends::ReadUndecorateSetting()
{
    return g_theApp.GetProfileInt(g_pszSettings, "ViewUndecorated", false) ? true : false; // inspected. MFC function
}

//******************************************************************************
/*static*/ void CDocDepends::WriteUndecorateSetting(bool fUndecorate)
{
    g_theApp.WriteProfileInt(g_pszSettings, "ViewUndecorated", fUndecorate ? 1 : 0);
}

//******************************************************************************
/*static*/ bool CDocDepends::SaveSession(LPCSTR pszSaveName, SAVETYPE saveType, CSession *pSession,
                                         bool fFullPaths, bool fUndecorate, int sortColumnModules,
                                         int sortColumnImports, int sortColumnExports,
                                         CRichEditCtrl *pre)
{
    bool fResult = false;

    HANDLE hFile = CreateFile(pszSaveName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, // inspected.
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    if (saveType == ST_DWI)
    {
        fResult = pSession->SaveToDwiFile(hFile);
    }
    else if ((saveType == ST_TXT) || (saveType == ST_TXT_IE))
    {
        // Get the system info - use the one from our session if it exists (means
        // it is a DWI file), otherwise, create a live sys info.
        SYSINFO si, *psi = pSession->GetSysInfo();
        if (!psi)
        {
            BuildSysInfo(psi = &si);
        }

        //                          12345678901234567890123456789012345678901234567890123456789012345678901234567890
        fResult = WriteText(hFile, "*****************************| System Information |*****************************\r\n\r\n") &&
                  BuildSysInfo(psi, SysInfoCallback, (LPARAM)hFile) &&
                  WriteText(hFile, "\r\n") &&
                  SaveSearchPath(hFile, pSession) &&
                  CTreeViewModules::SaveToTxtFile(hFile, pSession, saveType == ST_TXT_IE, sortColumnImports, sortColumnExports, fFullPaths, fUndecorate) &&
                  CListViewModules::SaveToTxtFile(hFile, pSession, sortColumnModules, fFullPaths) &&
                  WriteText(hFile, "************************************| Log |*************************************\r\n\r\n");
    }
    else if (saveType == ST_CSV)
    {
        fResult = CListViewModules::SaveToCsvFile(hFile, pSession, sortColumnModules, fFullPaths);
    }

    // Write out the contents of that.
    if (fResult && pre && ((saveType == ST_DWI) || (saveType == ST_TXT) || (saveType == ST_TXT_IE)))
    {
        fResult &= CRichViewProfile::SaveToFile(pre, hFile, saveType);
    }

    CloseHandle(hFile);

    // If we failed to save the file, then delete it so that we don't leave a
    // partially written file on the disk.
    if (!fResult)
    {
        DWORD dwError = GetLastError();
        DeleteFile(pszSaveName);
        SetLastError(dwError);
    }

    return fResult;
}

//******************************************************************************
/*static*/ bool CALLBACK CDocDepends::SysInfoCallback(LPARAM lParam, LPCSTR pszField, LPCSTR pszValue)
{
    CHAR szBuffer[512], *psz, *pszNull = szBuffer + sizeof(szBuffer) - 1;
    StrCCpy(szBuffer, pszField, sizeof(szBuffer));
    psz = szBuffer + strlen(szBuffer);
    if (psz < pszNull)
    {
        *psz++ = ':';
    }
    while (((psz - szBuffer) < 25) && (psz < pszNull))
    {
        *psz++ = ' ';
    }
    StrCCpy(psz, pszValue, sizeof(szBuffer) - (int)(psz - szBuffer));
    StrCCat(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));
    return (WriteText((HANDLE)lParam, szBuffer) != FALSE);
}

//******************************************************************************
/*static*/ bool CDocDepends::SaveSearchPath(HANDLE hFile, CSession *pSession)
{
    //                12345678901234567890123456789012345678901234567890123456789012345678901234567890
    WriteText(hFile, "********************************| Search Order |********************************\r\n"
                     "*                                                                              *\r\n"
                     "* Legend: F  File                     E  Error (path not valid)                *\r\n"
                     "*                                                                              *\r\n"
                     "********************************************************************************\r\n\r\n");

    CHAR szBuffer[DW_MAX_PATH + MAX_PATH + 4];

    // Loop through all the search groups.
    for (CSearchGroup *psg = pSession->m_psgHead; psg; psg = psg->GetNext())
    {
        if (!WriteText(hFile, StrCCat(StrCCpy(szBuffer, psg->GetName(), sizeof(szBuffer)), "\r\n", sizeof(szBuffer))))
        {
            return false;
        }

        for (CSearchNode *psn = psg->GetFirstNode(); psn; psn = psn->GetNext())
        {
            DWORD dwFlags = psn->GetFlags();

            if (dwFlags & SNF_NAMED_FILE)
            {
                SCPrintf(szBuffer, sizeof(szBuffer), "   [%c%c] %s = %s\r\n",
                         (dwFlags & SNF_FILE)  ? 'F' : ' ',
                         (dwFlags & SNF_ERROR) ? 'E' : ' ', psn->GetName(), psn->GetPath());
            }
            else
            {
                SCPrintf(szBuffer, sizeof(szBuffer), "   [%c%c] %s\r\n",
                         (dwFlags & SNF_FILE)  ? 'F' : ' ',
                         (dwFlags & SNF_ERROR) ? 'E' : ' ', psn->GetPath());
            }

            if (!WriteText(hFile, szBuffer))
            {
                return false;
            }
        }
    }

    return (WriteText(hFile, "\r\n") != FALSE);
}


//******************************************************************************
// CDocDepends :: Public functions
//******************************************************************************

void CDocDepends::DisplayModule(CModule *pModule)
{
    // Change our pointer to an hour glass since the list controls can be slow.
    CWaitCursor waitCursor;

    // Hide our windows to help improve the speed of building the lists, and to
    // prevent the user from seeing the scroll bars go crazy, the headers resize,
    // and the sort take place.
    m_pListViewImports->ShowWindow(SW_HIDE); // hide/show seems to work better than redraw
    m_pListViewExports->ShowWindow(SW_HIDE);

    // SetCurrentModule() only needs to be called on one of the lists since it
    // initializes the shared data between the two functions list views.
    m_pListViewImports->SetCurrentModule(pModule);

    // Tell both views to load the current module into their view.
    m_pListViewImports->RealizeNewModule();
    m_pListViewExports->RealizeNewModule();

    // Show our two function list views.
    m_pListViewImports->ShowWindow(SW_SHOWNOACTIVATE);
    m_pListViewExports->ShowWindow(SW_SHOWNOACTIVATE);
}

//******************************************************************************
void CDocDepends::DoSettingChange()
{
    if (m_cxDigit)
    {
        // Get our DC and select our control's font into it.
        HDC hDC = ::GetDC(m_pListViewModules->GetSafeHwnd());
        HFONT hFontStock = NULL;
        if (m_hFontList)
        {
            hFontStock = (HFONT)::SelectObject(hDC, m_hFontList);
        }

        UpdateTimeStampWidths(hDC);

        // Unselect our font and free our DC.
        if (m_hFontList)
        {
            ::SelectObject(hDC, hFontStock);
        }
        ::ReleaseDC(m_pListViewModules->GetSafeHwnd(), hDC);
    }

    // Tell our module list view about the change so it can refresh any font or
    // locale changes.
    m_pListViewModules->DoSettingChange();
}

//******************************************************************************
void CDocDepends::InitFontAndFixedWidths(CWnd *pWnd)
{
    // If we are already initialized, then bail.
    if (m_hFontList)
    {
        return;
    }

    // Get the current font for our window and make a copy of it.  We will use this
    // font for all drawing in the future.  We do this in case the user changes
    // their system-wide "icon" font while depends is running.  This causes the
    // font in our control to change, but the height of each item stays the same.
    // By using the original font, we guarantee that the font will never change
    // in this particular control during it's lifetime.
    HFONT hFont = (HFONT)pWnd->SendMessage(WM_GETFONT);

    // Copy the font.
    if (hFont)
    {
        LOGFONT lf;
        ZeroMemory(&lf, sizeof(lf)); // inspected
        ::GetObject(hFont, sizeof(lf), &lf);
        m_hFontList = ::CreateFontIndirect(&lf);
    }

    // Initialize our static hex character width array.
    // Get our DC and select our control's font into it.
    HDC hDC = ::GetDC(pWnd->GetSafeHwnd());
    HFONT hFontStock = NULL;
    if (m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(hDC, m_hFontList);
    }

    // GetCharWidth32 returns ERROR_CALL_NOT_IMPLEMENTED on 9x, so we use GetCharWidth instead.

    int cxHexSet[16], cxX = 0, cxDash = 0, cxOpen = 0, cxClose = 0, cxA, cxP;
    ZeroMemory(cxHexSet, sizeof(cxHexSet)); // inspected

    // Get the character widths for the characters the we care about.
    if (::GetCharWidth(hDC, (UINT)'0', (UINT)'9', cxHexSet)      &&
        ::GetCharWidth(hDC, (UINT)'A', (UINT)'F', cxHexSet + 10) &&
        ::GetCharWidth(hDC, (UINT)'x', (UINT)'x', &cxX)          &&
        ::GetCharWidth(hDC, (UINT)'-', (UINT)'-', &cxDash)       &&
        ::GetCharWidth(hDC, (UINT)' ', (UINT)' ', &m_cxSpace)    &&
        ::GetCharWidth(hDC, (UINT)'(', (UINT)'(', &cxOpen)       &&
        ::GetCharWidth(hDC, (UINT)')', (UINT)')', &cxClose)      &&
        ::GetCharWidth(hDC, (UINT)'a', (UINT)'a', &cxA)          &&
        ::GetCharWidth(hDC, (UINT)'p', (UINT)'p', &cxP))
    {
        // Store the max width needed to display either an 'a' or a 'p'.
        m_cxAP = max(cxA, cxP);

        // Determine the widest digit - for most fonts, all digits are the same width.
        m_cxDigit = 0;
        for (int i = 0; i < 10; i++)
        {
            if (cxHexSet[i] > m_cxDigit)
            {
                m_cxDigit = cxHexSet[i];
            }
        }

        // Determine the widest hex character.
        int cxHex = m_cxDigit;
        for (i = 10; i < 16; i++)
        {
            if (cxHexSet[i] > cxHex)
            {
                cxHex = cxHexSet[i];
            }
        }

        // Build our hex array. Format: "0x01234567890ABCDEF" or "0x--------012345678"
        m_cxHexWidths[0] = cxHexSet[0];
        m_cxHexWidths[1] = cxX;
        m_cxHexWidths[2] = max(cxHex, cxDash);
        for (i = 3; i < 18; i++)
        {
            m_cxHexWidths[i] = m_cxHexWidths[2];
        }

        // Build our ordinal/hint array. Format: 65535 (0xFFFF)
        m_cxOrdHintWidths[ 0] = m_cxDigit;
        m_cxOrdHintWidths[ 1] = m_cxDigit;
        m_cxOrdHintWidths[ 2] = m_cxDigit;
        m_cxOrdHintWidths[ 3] = m_cxDigit;
        m_cxOrdHintWidths[ 4] = m_cxDigit;
        m_cxOrdHintWidths[ 5] = m_cxSpace;
        m_cxOrdHintWidths[ 6] = cxOpen;
        m_cxOrdHintWidths[ 7] = cxHexSet[0];
        m_cxOrdHintWidths[ 8] = cxX;
        m_cxOrdHintWidths[ 9] = cxHex;
        m_cxOrdHintWidths[10] = cxHex;
        m_cxOrdHintWidths[11] = cxHex;
        m_cxOrdHintWidths[12] = cxHex;
        m_cxOrdHintWidths[13] = cxClose;

        // Calculate the width of our country specific timestamp values.
        UpdateTimeStampWidths(hDC);
    }

    // If we failed to get the width of any of the characters, then don't build our arrays.
    else
    {
        ZeroMemory(m_cxHexWidths, sizeof(m_cxHexWidths)); // inspected
        ZeroMemory(m_cxOrdHintWidths, sizeof(m_cxOrdHintWidths)); // inspected
        ZeroMemory(m_cxTimeStampWidths, sizeof(m_cxTimeStampWidths)); // inspected
        m_cxDigit = m_cxSpace = m_cxAP = 0;
    }

    // Unselect our font and free our DC.
    if (m_hFontList)
    {
        ::SelectObject(hDC, hFontStock);
    }
    ::ReleaseDC(pWnd->GetSafeHwnd(), hDC);
}

//******************************************************************************
int* CDocDepends::GetHexWidths(LPCSTR pszItem)
{
    // If this is a hex number, then return our hex buffer.
    if ((*pszItem == '0') && (*(pszItem + 1) == 'x') && m_cxHexWidths[0])
    {
        return m_cxHexWidths;
    }

    return NULL;
}

//******************************************************************************
int* CDocDepends::GetOrdHintWidths(LPCSTR pszItem)
{
    // If this is a hex number, then return our hex buffer.
    if ((*pszItem >= '0') && (*pszItem <= '9') && m_cxOrdHintWidths[0])
    {
        int length = (int)strlen(pszItem);
        if (length <= 14)
        {
            return (m_cxOrdHintWidths + (14 - length));
        }
    }

    return NULL;
}

//******************************************************************************
int* CDocDepends::GetTimeStampWidths()
{
    return m_cxTimeStampWidths[0] ? m_cxTimeStampWidths : NULL;
}


//******************************************************************************
// CDocDepends :: Private functions
//******************************************************************************

void CDocDepends::UpdateTimeStampWidths(HDC hDC)
{
    int cxDate = m_cxDigit, cxTime = m_cxDigit;

    // Get the character widths for the characters the we care about.
    ::GetCharWidth(hDC, (UINT)g_theApp.m_cDateSeparator, (UINT)g_theApp.m_cDateSeparator, &cxDate);
    ::GetCharWidth(hDC, (UINT)g_theApp.m_cTimeSeparator, (UINT)g_theApp.m_cTimeSeparator, &cxTime);

    // To start with, fill in the entire timestamp buffer with digit spaces.
    for (int i = 0; i < countof(m_cxTimeStampWidths); i++)
    {
        m_cxTimeStampWidths[i] = m_cxDigit;
    }

    // Then, change the values needed according to the current time format.
    if (g_theApp.m_nShortDateFormat == LOCALE_DATE_YMD)
    {
        // YYYY/MM/DD
        m_cxTimeStampWidths[4] = cxDate;
        m_cxTimeStampWidths[7] = cxDate;
    }
    else
    {
        // DD/MM/YYYY or MM/DD/YYYY
        m_cxTimeStampWidths[2] = cxDate;
        m_cxTimeStampWidths[5] = cxDate;
    }

    // Set the space after the date.
    m_cxTimeStampWidths[10] = m_cxSpace;

    // Set the time separator space.  It deosn't matter if we are doing 12/24 hour
    // or leading zeros since we always display two characters for the hour.
    m_cxTimeStampWidths[13] = cxTime;

    // Set the AM/PM character width.  24-hour format will not use this.
    m_cxTimeStampWidths[16] = m_cxAP;
}

//******************************************************************************
void CDocDepends::UpdateAll()
{
    m_pListViewModules->UpdateAll();
}

//******************************************************************************
void CDocDepends::UpdateModule(CModule *pModule)
{
    m_pTreeViewModules->UpdateModule(pModule);
    m_pListViewModules->UpdateModule(pModule);
}

//******************************************************************************
void CDocDepends::AddModuleTree(CModule *pModule)
{
    m_pTreeViewModules->AddModuleTree(pModule);
    m_pListViewModules->AddModuleTree(pModule);
}

//******************************************************************************
void CDocDepends::RemoveModuleTree(CModule *pModule)
{
    m_pTreeViewModules->RemoveModuleTree(pModule);
    m_pListViewModules->RemoveModuleTree(pModule);
}

//******************************************************************************
void CDocDepends::AddImport(CModule *pModule, CFunction *pFunction)
{
    if (pModule == m_pModuleCur)
    {
        m_pListViewImports->AddDynamicImport(pFunction);
        m_pListViewExports->AddDynamicImport(pFunction);
    }
}

//******************************************************************************
void CDocDepends::ExportsChanged(CModule *pModule)
{
    if (m_pModuleCur && pModule && (m_pModuleCur->GetOriginal() == pModule->GetOriginal()))
    {
        m_pListViewExports->ExportsChanged();
    }
}

//******************************************************************************
void CDocDepends::ChangeOriginal(CModule *pModuleOld, CModule *pModuleNew)
{
    m_pListViewModules->ChangeOriginal(pModuleOld, pModuleNew);
}

//******************************************************************************
BOOL CDocDepends::LogOutput(LPCSTR pszOutput, DWORD dwFlags, DWORD dwElapsed)
{
    m_pRichViewProfile->AddText(pszOutput, dwFlags, dwElapsed);
    return TRUE;
}

//******************************************************************************
void CDocDepends::ProfileUpdate(DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2)
{
    switch (dwType)
    {
        case DWPU_ARGUMENTS:       m_strProfileArguments  = (LPCSTR)dwpParam1;               break;
        case DWPU_DIRECTORY:       m_strProfileDirectory  = (LPCSTR)dwpParam1;               break;
        case DWPU_SEARCH_PATH:     m_strProfileSearchPath = (LPCSTR)dwpParam1;               break;
        case DWPU_UPDATE_ALL:      UpdateAll();                                              break;
        case DWPU_UPDATE_MODULE:   UpdateModule((CModule*)dwpParam1);                        break;
        case DWPU_ADD_TREE:        AddModuleTree((CModule*)dwpParam1);                       break;
        case DWPU_REMOVE_TREE:     RemoveModuleTree((CModule*)dwpParam1);                    break;
        case DWPU_ADD_IMPORT:      AddImport((CModule*)dwpParam1, (CFunction*)dwpParam2);    break;
        case DWPU_EXPORTS_CHANGED: ExportsChanged((CModule*)dwpParam1);                      break;
        case DWPU_CHANGE_ORIGINAL: ChangeOriginal((CModule*)dwpParam1, (CModule*)dwpParam2); break;
        case DWPU_LOG:
            LogOutput((LPCSTR)dwpParam1, ((PDWPU_LOG_STRUCT)dwpParam2)->dwFlags,
                      ((PDWPU_LOG_STRUCT)dwpParam2)->dwElapsed);
            break;

        case DWPU_PROFILE_DONE:
            if (m_fCommandLineProfile)
            {
                m_fCommandLineProfile = false;
                CWaitCursor waitCursor;
                g_theApp.SaveCommandLineFile(m_pSession, &m_pRichViewProfile->GetRichEditCtrl());
            }
            break;
    }
}


//******************************************************************************
// CDocDepends :: Overridden functions
//******************************************************************************

void CDocDepends::DeleteContents()
{
    // Clear our views.
    if (m_pTreeViewModules)
    {
        m_pTreeViewModules->DeleteContents();
    }
    if (m_pListViewModules)
    {
        m_pListViewModules->DeleteContents();
    }
    if (m_pListViewImports)
    {
        m_pListViewImports->DeleteContents();
        m_pListViewImports->SetCurrentModule(NULL);
    }
    if (m_pListViewExports)
    {
        m_pListViewExports->DeleteContents();
    }
    if (m_pRichViewProfile)
    {
        m_pRichViewProfile->DeleteContents();
    }
    if (m_pChildFrame)
    {
        m_pChildFrame->UpdateWindow();
    }

    // Free our module session.
    if (m_pSession)
    {
        delete m_pSession;
        m_pSession = NULL;
    }
}

//******************************************************************************
BOOL CDocDepends::OnOpenDocument(LPCTSTR pszPath)
{
    // Check to make sure the file exists and is readable.
    CFileException fe;
    CFile* pFile = GetFile(pszPath, CFile::modeRead|CFile::shareDenyWrite, &fe);
    if (pFile == NULL)
    {
        ReportSaveLoadException(pszPath, &fe, FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
        return FALSE;
    }

    // Unload our current document.
    DeleteContents();

    // Save the path of this file in our path buffer.
    CHAR *pc = strrchr(pszPath, '\\');
    if (pc)
    {
        CHAR c = *(++pc);
        *pc = '\0';
        m_strDefaultDirectory = pszPath;
        *pc = c;
    }

    // Create a new session.
    if (!(m_pSession = new CSession(StaticProfileUpdate, (DWORD_PTR)this)))
    {
        ReleaseFile(pFile, FALSE);
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Show hour glass.
    CWaitCursor waitCursor;

    BOOL  fResult;
    DWORD dwSignature = 0;

    // Read the first DWORD of the file and see if it matches our DWI signature.
    if (ReadBlock((HANDLE)pFile->m_hFile, &dwSignature, sizeof(dwSignature)) && (dwSignature == DWI_SIGNATURE))
    {
        // Open the saved module session image.
        if (fResult = m_pSession->ReadDwi((HANDLE)pFile->m_hFile, pszPath))
        {
            CRichViewProfile::ReadFromFile(&m_pRichViewProfile->GetRichEditCtrl(), (HANDLE)pFile->m_hFile);
        }
        ReleaseFile(pFile, FALSE);

        m_psgHead = m_pSession->m_psgHead;
    }

    // If the file failed to open or is not a DWI file, then try to scan it.  All file errors
    // will be handled by the session, so we don't need to do anything here.
    else
    {
        // Close the file.
        ReleaseFile(pFile, FALSE);

        // Check to see if we have already created a search order.
        if (m_fInitialized)
        {
            // Refresh our search order nodes.
            CSearchGroup *psgNew = CSearchGroup::CopySearchOrder(m_psgHead, m_strPathName);
            CSearchGroup::DeleteSearchOrder(m_psgHead);
            m_psgHead = psgNew;
        }
        else
        {
            // Create a new search order.
            m_psgHead = CSearchGroup::CopySearchOrder(g_theApp.m_psgDefault, pszPath);
        }
        fResult = m_pSession->DoPassiveScan(pszPath, m_psgHead); //!! check for errors?
    }

    // Clear hour glass.
    waitCursor.Restore();

    // Check to see if we are a child process of another process.
    if (g_theApp.m_pProcess)
    {
        // Check to see if the process has the args, directory, or path.
        if (g_theApp.m_pProcess->m_pszArguments)
        {
            m_strProfileArguments = g_theApp.m_pProcess->m_pszArguments;
            MemFree((LPVOID&)g_theApp.m_pProcess->m_pszArguments);
        }
        if (g_theApp.m_pProcess->m_pszDirectory)
        {
            m_strProfileDirectory = g_theApp.m_pProcess->m_pszDirectory;
            MemFree((LPVOID&)g_theApp.m_pProcess->m_pszDirectory);
        }
        if (g_theApp.m_pProcess->m_pszSearchPath)
        {
            m_strProfileSearchPath = g_theApp.m_pProcess->m_pszSearchPath;
            MemFree((LPVOID&)g_theApp.m_pProcess->m_pszSearchPath);
        }

        // If so, tell the session how they can send log to us.
        m_pSession->SetRuntimeProfile(m_strProfileDirectory.IsEmpty()  ? NULL : (LPCSTR)m_strProfileArguments,
                                      m_strProfileDirectory.IsEmpty()  ? NULL : (LPCSTR)m_strProfileDirectory,
                                      m_strProfileSearchPath.IsEmpty() ? NULL : (LPCSTR)m_strProfileSearchPath);
    }

    if (m_strProfileDirectory.IsEmpty())
    {
        m_strProfileDirectory = m_strDefaultDirectory;
    }

    // Check to see if we have a read error.
    if (m_pSession->GetReadErrorString())
    {
        AfxMessageBox(m_pSession->GetReadErrorString(), MB_ICONERROR | MB_OK);
        fResult = false;
        m_fError = true;
    }

    // Don't add files to our MRU if they contain one of these errors.
    if ((m_pSession->GetReturnFlags() & (DWRF_COMMAND_LINE_ERROR | DWRF_FILE_NOT_FOUND | DWRF_FILE_OPEN_ERROR | DWRF_DWI_NOT_RECOGNIZED)) ||
        (!(m_pSession->GetSessionFlags() & DWSF_DWI) && (!m_pSession->GetRootModule() || (m_pSession->GetRootModule()->GetFlags() & DWMF_FORMAT_NOT_PE))))
    {
        m_fError = true;
    }

    // We set our dirty flag to force SaveModified() to get called before
    // allowing the document to be closed.
    SetModifiedFlag(fResult);

    m_fInitialized = true;

    return fResult;
}

//******************************************************************************
void CDocDepends::BeforeVisible()
{
    // Populate our views.
    if (m_pTreeViewModules)
    {
        m_pTreeViewModules->Refresh();
    }
    if (m_pListViewModules)
    {
        m_pListViewModules->Refresh();
    }
}

//******************************************************************************
void CDocDepends::AfterVisible()
{    
    if (m_pSession)
    {
        // If we are supposed to profile, then do so now.  We don't display the
        // error dialog for errors when in auto-profile mode.
        if (m_fCommandLineProfile)
        {
            // Dont't allow profiling of DWI files.
            if (m_pSession->GetSessionFlags() & DWSF_DWI)
            {
                m_fCommandLineProfile = false;
                AfxMessageBox("The \"/pb\" command line option cannot be used when opening a Dependency Walker Image (DWI) file.", MB_ICONERROR | MB_OK);
            }

            // Don't profile modules that we shouldn't be doing.
            else if (!g_theApp.m_fNeverDenyProfile && !m_pSession->IsExecutable())
            {
                m_fCommandLineProfile = false;
                AfxMessageBox("This module cannot be profiled since it is either not a main application module or is not designed to run on this computer.", MB_ICONERROR | MB_OK);
            } 

            // If we have no errors, then start the profiling and return
            else
            {
                // Tell the session to start profiling.
                m_pSession->StartRuntimeProfile(m_strProfileArguments.IsEmpty() ? NULL : (LPCSTR)m_strProfileArguments,
                                                m_strProfileDirectory.IsEmpty() ? NULL : (LPCSTR)m_strProfileDirectory,
                                                m_dwProfileFlags);
                return;
            }
        }
        
        // If not in auto-profile mode, this is not a child process, and we
        // have errors, then display the error dialog.
        if (!m_fChildProcess && (m_pSession->GetReturnFlags() & (DWRF_ERROR_MASK | DWRF_PROCESS_ERROR_MASK)))
        {
            CString strError("Errors were detected when processing \"");
            strError += m_pSession->GetRootModule() ? m_pSession->GetRootModule()->GetName(true, true) : GetPathName();
            strError += "\".  See the log window for details.";
            AfxMessageBox(strError, MB_ICONWARNING | MB_OK);
        }

    }
}

//******************************************************************************
BOOL CDocDepends::SaveModified()
{
    // This function is called before any document is closed. If we are profiling,
    // then we need to terminate the process before we close.
    if (m_pSession && m_pSession->m_pProcess)
    {
        // Prompt the user if they really want to terminate the process.
        CString strMsg = "\"" + GetPathName() + "\" is currently being profiled."
                         "\n\nDo you wish to terminate it?";
        if (IDYES != AfxMessageBox(strMsg, MB_ICONQUESTION | MB_YESNO))
        {
            // Tell MFC not to close us right now.
            return FALSE;
        }
    }

    // Tell MFC that we are safe to close.
    return TRUE;
}

//******************************************************************************
void CDocDepends::OnFileSave()
{
    if (m_strSaveName.IsEmpty())
    {
        OnFileSaveAs();
    }
    else
    {
        CWaitCursor waitCursor;
        bool fSuccess = SaveSession(m_strSaveName, m_saveType, m_pSession,
                                    m_fViewFullPaths, m_fViewUndecorated,
                                    m_pListViewModules->GetSortColumn(),
                                    m_pListViewImports->GetSortColumn(),
                                    m_pListViewExports->GetSortColumn(),
                                    &m_pRichViewProfile->GetRichEditCtrl());
        DWORD dwError = GetLastError();
        waitCursor.Restore();

        if (!fSuccess)
        {
            m_strSaveName.Empty();
            CString strError("Error saving \"");
            strError += m_strSaveName;
            strError += "\".";
            LPCSTR pszError = BuildErrorMessage(dwError, strError);
            AfxMessageBox(pszError, MB_OK | MB_ICONERROR);
            MemFree((LPVOID&)pszError);
        }
    }
}

//******************************************************************************
void CDocDepends::OnFileSaveAs()
{
    // We handle our own file save dialog because we want to use multiple file
    // extension filters and MFC currently only allows one filter per document
    // template.

    // Create the dialog.
    CSaveDialog dlgSave;

    CHAR szPath[DW_MAX_PATH], szInitialDir[DW_MAX_PATH], *psz;

    // Check to see if we don't already have a save name.
    if (m_strSaveName.IsEmpty())
    {
        // Copy our file name to our path buffer.  Note: In version 2.0 we used
        // to copy the entire module path to the buffer, then change the name to
        // end in ".dwi", but starting with Win2K the GetOpenFileName function uses
        // this path as the starting path for the dialog, even when we specify
        // a path in the lpstrInitialDir member.  To meet logo requirements, we
        // now only specify only the file name and fill in the lpstrInitialDir
        // with a path to the "My Documents" folder.
        StrCCpy(szPath, GetFileNameFromPath(m_strPathName), sizeof(szPath));

        // Change the extension to ".dwi".
        if (psz = strrchr(szPath, '.'))
        {
            StrCCpy(psz, ".dwi", sizeof(szPath) - (int)(psz - szPath));
        }
        else
        {
            StrCCat(szPath, ".dwi", sizeof(szPath));
        }

        // Default to DWI type file.
        dlgSave.GetOFN().nFilterIndex = ST_DWI;
        
        // Since we don't have a path full yet, we default to the "My Documents"
        // folder to meet logo requirements.
        dlgSave.GetOFN().lpstrInitialDir = GetMyDocumentsPath(szInitialDir);
    }

    // If we do already have a saved name, then just copy the save name to our path buffer.
    else
    {
        StrCCpy(szPath, m_strSaveName, sizeof(szPath));
        dlgSave.GetOFN().nFilterIndex = (DWORD)m_saveType;
    }

    // Initialize the dialog's members.
    dlgSave.GetOFN().lpstrFilter = "Dependency Walker Image (*.dwi)\0*.dwi\0"
                                   "Text (*.txt)\0*.txt\0"
                                   "Text with Import/Export Lists (*.txt)\0*.txt\0"
                                   "Comma Separated Values (*.csv)\0*.csv\0";
    dlgSave.GetOFN().lpstrFile = szPath;
    dlgSave.GetOFN().nMaxFile = sizeof(szPath);
    dlgSave.GetOFN().lpstrDefExt = "dwi";
    
    // Note: Don't use OFN_EXPLORER as it breaks us on NT 3.51
    dlgSave.GetOFN().Flags |=
        OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN |
        OFN_ENABLEHOOK | OFN_SHOWHELP | OFN_OVERWRITEPROMPT;

    // Display the dialog and continue saving the file if dialog returns success.
    if (dlgSave.DoModal() == IDOK)
    {
        // Attempt to save the file with the user specified name.
        CWaitCursor waitCursor;
        bool fSuccess = SaveSession(szPath, (SAVETYPE)dlgSave.GetOFN().nFilterIndex,
                                    m_pSession, m_fViewFullPaths, m_fViewUndecorated,
                                    m_pListViewModules->GetSortColumn(),
                                    m_pListViewImports->GetSortColumn(),
                                    m_pListViewExports->GetSortColumn(),
                                    &m_pRichViewProfile->GetRichEditCtrl());
        DWORD dwError = GetLastError();
        waitCursor.Restore();

        if (fSuccess)
        {
            // If it was a success, then store the file name for future saves.
            m_strSaveName = szPath;
            m_saveType = (SAVETYPE)dlgSave.GetOFN().nFilterIndex;

            // If we saved a DWI file, then add it to our MRU file list.
            if ((SAVETYPE)dlgSave.GetOFN().nFilterIndex == ST_DWI)
            {
                g_theApp.AddToRecentFileList(szPath);
            }
        }
        else
        {
            m_strSaveName.Empty();
            CString strError("Error saving \"");
            strError += szPath;
            strError += "\".";
            LPCSTR pszError = BuildErrorMessage(dwError, strError);
            AfxMessageBox(pszError, MB_OK | MB_ICONERROR);
            MemFree((LPVOID&)pszError);
        }
    }
}

//******************************************************************************
BOOL CDocDepends::OnSaveDocument(LPCTSTR lpszPathName)
{
    // We should not reach this point, but to be safe we handle it and return
    // FALSE. If this were to make it to CDocument::OnSaveDocument(), then our
    // module file would get overwritten by the default MFC save code.
    return FALSE;
}

//******************************************************************************
// CDocDepends :: Event handler functions
//******************************************************************************

void CDocDepends::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    // Set the text to the default.
    pCmdUI->SetText("&Copy\tCtrl+C");

    // If no view has the focus, then there is nothing to copy.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CDocDepends::OnUpdateShowMatchingItem(CCmdUI* pCmdUI)
{
    // Set the text to the default.
    pCmdUI->SetText("&Highlight Matching Item\tCtrl+M");

    // If no view has the focus that can handle this command, then disable it.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CDocDepends::OnUpdateShowOriginalModule(CCmdUI* pCmdUI)
{
    m_pTreeViewModules->OnUpdateShowOriginalModule(pCmdUI);
}

//******************************************************************************
void CDocDepends::OnShowOriginalModule()
{
    m_pTreeViewModules->OnShowOriginalModule();
    m_pTreeViewModules->SetFocus();
}

//******************************************************************************
void CDocDepends::OnUpdateShowPreviousModule(CCmdUI* pCmdUI)
{
    m_pTreeViewModules->OnUpdateShowPreviousModule(pCmdUI);
}

//******************************************************************************
void CDocDepends::OnShowPreviousModule()
{
    m_pTreeViewModules->OnShowPreviousModule();
    m_pTreeViewModules->SetFocus();
}

//******************************************************************************
void CDocDepends::OnUpdateShowNextModule(CCmdUI* pCmdUI)
{
    m_pTreeViewModules->OnUpdateShowNextModule(pCmdUI);
}

//******************************************************************************
void CDocDepends::OnShowNextModule()
{
    m_pTreeViewModules->OnShowNextModule();
    m_pTreeViewModules->SetFocus();
}

//******************************************************************************
void CDocDepends::OnUpdateEditClearLog(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsLive());
}

//******************************************************************************
void CDocDepends::OnEditClearLog()
{
    m_pRichViewProfile->DeleteContents();
}

//******************************************************************************
void CDocDepends::OnConfigureSearchOrder()
{
    // Display the configure search order dialog.
    CDlgSearchOrder dlg(m_psgHead, !IsLive(), IsLive() ? (LPCSTR)m_strPathName : NULL, GetTitle());

    if (dlg.DoModal() == IDOK)
    {
        m_psgHead = dlg.GetHead();
        if (m_pSession)
        {
            m_pSession->m_psgHead = m_psgHead;
        }

        // Ask the user if they wish to refresh.
        if (IDYES == AfxMessageBox("Would you like to refresh the current session to "
                                   "reflect your changes to the search path?",
                                   MB_ICONQUESTION | MB_YESNO))
        {
            OnFileRefresh();
        }
    }
}

//******************************************************************************
void CDocDepends::OnUpdateViewFullPaths(CCmdUI *pCmdUI)
{
    // If the view full path option is enabled, then display a check mark next to
    // the menu item and show the toolbar button as depressed.
    pCmdUI->SetCheck(m_fViewFullPaths);
}

//******************************************************************************
void CDocDepends::OnViewFullPaths()
{
    // Toggle our option flag and update our views to reflect the change.
    m_fViewFullPaths = !m_fViewFullPaths;
    m_pTreeViewModules->OnViewFullPaths();
    m_pListViewModules->OnViewFullPaths();

    // This setting is persistent, so store it in the registry.
    WriteFullPathsSetting(m_fViewFullPaths);
}

//******************************************************************************
void CDocDepends::OnUpdateViewUndecorated(CCmdUI* pCmdUI)
{
    // Enable the undecorated option is we were able to find the
    // UnDecorateSymbolName function in IMAGEHLP.DLL.
    pCmdUI->Enable(g_theApp.m_pfnUnDecorateSymbolName != NULL);

    // If the view undecorated option is enabled, then display a check mark next to
    // the menu item and show the toolbar button as depressed.
    pCmdUI->SetCheck(m_fViewUndecorated && g_theApp.m_pfnUnDecorateSymbolName);
}

//******************************************************************************
void CDocDepends::OnViewUndecorated()
{
    // Make sure we were able to find the UnDecorateSymbolName function in IMAGEHLP.DLL.
    if (!g_theApp.m_pfnUnDecorateSymbolName)
    {
        return;
    }

    // Toggle our option flag and update our views to reflect the change.
    m_fViewUndecorated = !m_fViewUndecorated;

    // SetRedraw works better then HIDE/SHOW because HIDE/SHOW causes the entire
    // control to repaint when shown.
    m_pListViewImports->SetRedraw(FALSE);
    m_pListViewExports->SetRedraw(FALSE);

    // Update the text for C++ functions and also calculate the new column width.
    m_pListViewImports->UpdateNameColumn();
    m_pListViewExports->UpdateNameColumn();

    // Adjust the column width to reflect the new names. AdjustColumnWidths()
    // only needs to be called on one of the lists since the column widths are
    // always mirrored to the neighboring view.
    m_pListViewImports->CalcColumnWidth(LVFC_FUNCTION);
    m_pListViewImports->UpdateColumnWidth(LVFC_FUNCTION);

    // All done, enable painting again.
    m_pListViewImports->SetRedraw(TRUE);
    m_pListViewExports->SetRedraw(TRUE);

    // This setting is persistent, so store it in the registry.
    WriteUndecorateSetting(m_fViewUndecorated);
}

//******************************************************************************
void CDocDepends::OnUpdateAutoExpand(CCmdUI* pCmdUI)
{
    // If the view full path option is enabled, then display a check mark next to
    // the menu item and show the toolbar button as depressed.
    pCmdUI->SetCheck(m_fAutoExpand);
}

//******************************************************************************
void CDocDepends::OnAutoExpand()
{
    // Toggle our option flag
    m_fAutoExpand = !m_fAutoExpand;

    // This setting is persistent, so store it in the registry.
    WriteAutoExpandSetting(m_fAutoExpand);

    // Let our tree know about the change.
    m_pTreeViewModules->UpdateAutoExpand(m_fAutoExpand);
}

//******************************************************************************
void CDocDepends::OnExpandAll()
{
    // Tell our Module Dependency Tree View to expand all of its items.
    m_pTreeViewModules->ExpandOrCollapseAll(TRUE);
}

//******************************************************************************
void CDocDepends::OnCollapseAll()
{
    // Tell our Module Dependency Tree View to collapse all of its items.
    m_pTreeViewModules->ExpandOrCollapseAll(FALSE);
}

//******************************************************************************
void CDocDepends::OnUpdateRefresh(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsLive());
}

//******************************************************************************
void CDocDepends::OnFileRefresh()
{
    if (m_fWarnToRefresh)
    {
        CString strMsg;

        if (m_pSession && m_pSession->m_pProcess)
        {
            strMsg = "\"" + GetPathName() + "\" is currently being profiled. A refresh will terminate "
                     "it and clear all profiling information from the current session.\n\n"
                     "Do you wish to continue?";
        }
        else
        {
            strMsg = "A refresh will clear all profiling information from the current session.\n\n"
                     "Do you wish to continue?";
        }

        // Display the warning and bail if they did not answer "yes".
        if (IDYES != AfxMessageBox(strMsg, MB_ICONQUESTION | MB_YESNO))
        {
            return;
        }
    }

    // Show hour glass.
    CWaitCursor waitCursor;

    // Make sure we are not profiling.
    OnTerminate();

    // Re-open our base module.
    OnOpenDocument(m_strPathName);

    // Refresh our views.
    m_pTreeViewModules->Refresh();
    m_pListViewModules->Refresh();

    // Set our focus to the module tree control.
    m_pTreeViewModules->SetFocus();

    // Clear our refresh warning flag.
    m_fWarnToRefresh = FALSE;
}

//******************************************************************************
void CDocDepends::OnViewSysInfo()
{
    CDlgSysInfo dlgSysInfo(m_pSession ? m_pSession->GetSysInfo() : NULL, GetTitle());
    dlgSysInfo.DoModal();
}

//******************************************************************************
void CDocDepends::OnUpdateExternalViewer(CCmdUI* pCmdUI) 
{
    // Make sure the "Enter" accelerator is not part of this string.
    pCmdUI->SetText("View Module in External &Viewer");
}

//******************************************************************************
void CDocDepends::OnUpdateExternalHelp(CCmdUI* pCmdUI) 
{
    // Make sure the "Enter" accelerator is not part of this string.
    pCmdUI->SetText("Lookup Function in External &Help");
}

//******************************************************************************
void CDocDepends::OnUpdateExecute(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pSession && (m_pSession->IsExecutable() ||
                   (g_theApp.m_fNeverDenyProfile && !(m_pSession->GetSessionFlags() & DWSF_DWI))));
}

//******************************************************************************
void CDocDepends::OnExecute()
{
    // Create the profile dialog.
    CDlgProfile dlgProfile(this);

    // Display the dialog and check for success.
    if (dlgProfile.DoModal() == IDOK)
    {
        m_fWarnToRefresh = TRUE;

        // If the user requested to clear the log, then do so now.
        if (m_dwProfileFlags & PF_LOG_CLEAR)
        {
            m_pRichViewProfile->DeleteContents();
        }

        // Tell our session to start profiling.
        m_pSession->StartRuntimeProfile(m_strProfileArguments, m_strProfileDirectory, m_dwProfileFlags);
    }
}

//******************************************************************************
void CDocDepends::OnUpdateTerminate(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pSession && m_pSession->m_pProcess);
}

//******************************************************************************
void CDocDepends::OnTerminate()
{
    if (m_pSession->m_pProcess)
    {
        m_pSession->m_pProcess->Terminate();
        LogOutput("Terminating process by user's request.\n", LOG_BOLD | LOG_TIME_STAMP,
                  GetTickCount() - m_pSession->m_pProcess->GetStartingTime());
    }
}

//******************************************************************************
#if 0 //{{AFX
void CDocDepends::OnUpdateViewFunctions(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(!m_fDetailView);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CDocDepends::OnViewFunctions()
{
    if (m_fDetailView)
    {
        m_pChildFrame->CreateFunctionsView();
        m_fDetailView = FALSE;
    }
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CDocDepends::OnUpdateViewDetails(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fDetailView);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CDocDepends::OnViewDetails()
{
    if (!m_fDetailView)
    {
        m_pChildFrame->CreateDetailView();
        m_fDetailView = TRUE;
    }
}
#endif //}}AFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\helpers.h ===
//******************************************************************************
//
// File:        HELPERS.H
//
// Description: Global helper functions.
//             
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 06/03/01  stevemil  Moved over from depends.h and modified (version 2.1)
//
//******************************************************************************

#ifndef __HELPERS_H__
#define __HELPERS_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** Types and Structures
//******************************************************************************

typedef bool (CALLBACK *PFN_SYSINFOCALLBACK)(LPARAM, LPCSTR, LPCSTR);

// Make sure we have consistent packing for anything we save/load to disk.
#pragma pack(push, 4)

typedef struct _SYSINFO
{
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    WORD  wBuildVersion;
    WORD  wPatchVersion;
    WORD  wBetaVersion;
    WORD  wFlags;

    // GetComputerName() - MAX_COMPUTERNAME_LENGTH is defined to 15 in WINBASE.H.
    // We need to be able to store MAX_COMPUTERNAME_LENGTH + 1
    CHAR  szComputer[32];

    // GetUserName() - UNLEN is defined to 256 in LMCONS.H.
    // We need to be able to store UNLEN + 1.
    CHAR  szUser[260];

    // GetSystemInfo(SYSTEM_INFO)
    DWORD     dwProcessorArchitecture;
    DWORD     dwPageSize;
    DWORDLONG dwlMinimumApplicationAddress;
    DWORDLONG dwlMaximumApplicationAddress;
    DWORDLONG dwlActiveProcessorMask;
    DWORD     dwNumberOfProcessors;
    DWORD     dwProcessorType;
    DWORD     dwAllocationGranularity;
    WORD      wProcessorLevel;
    WORD      wProcessorRevision;

    // Values from HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0\.
    CHAR      szCpuIdentifier[128];
    CHAR      szCpuVendorIdentifier[128];
    DWORD     dwCpuMHz;

    // GetVersionEx(OSVERSIONINFOEX)
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WORD  wServicePackMajor;
    WORD  wServicePackMinor;
    WORD  wSuiteMask;
    WORD  wProductType;
    CHAR  szCSDVersion[128];

    // GlobalMemoryStatus(MEMORYSTATUS)
    DWORD     dwMemoryLoad;
    DWORDLONG dwlTotalPhys;
    DWORDLONG dwlAvailPhys;
    DWORDLONG dwlTotalPageFile;
    DWORDLONG dwlAvailPageFile;
    DWORDLONG dwlTotalVirtual;
    DWORDLONG dwlAvailVirtual;

    // GetTimeZoneInformation(TIME_ZONE_INFORMATION)
    CHAR  szTimeZone[32];
    LONG  lBias;

    // GetSystemTimeAsFileTime() and FileTimeToLocalFileTime()
    FILETIME ftLocal;

    // GetSystemDefaultLangID()
    LANGID langId; // WORD

} SYSINFO, *PSYSINFO;

// Restore packing.
#pragma pack(pop)

typedef struct _FILE_MAP {
   HANDLE hFile;
   HANDLE hMap;
   LPVOID lpvFile;
   DWORD  dwSize;
   DWORD  dwSizeHigh;
} FILE_MAP, *PFILE_MAP;


//******************************************************************************
//***** Global Helper Functions
//******************************************************************************

#ifdef _DEBUG
void NameThread(LPCSTR pszName, DWORD dwThreadId = (DWORD)-1);
#else
inline void NameThread(LPCSTR pszName, DWORD dwThreadId = (DWORD)-1) {}
#endif

int    ExceptionFilter(unsigned long ulCode, bool fHandle);

int    Compare(DWORD dw1, DWORD dw2);
int    Compare(DWORDLONG dwl1, DWORDLONG dwl2);

LPSTR  FormatValue(LPSTR pszBuf, int cBuf, DWORD dwValue);
LPSTR  FormatValue(LPSTR pszBuf, int cBuf, DWORDLONG dwlValue);

LPSTR  StrAlloc(LPCSTR pszText);
LPVOID MemAlloc(DWORD dwSize); // Throws exception on failure
void   MemFree(LPVOID &pvMem);

int    SCPrintf(LPSTR pszBuf, int count, LPCSTR pszFormat, ...);
int    SCPrintfCat(LPSTR pszBuf, int count, LPCSTR pszFormat, ...);
LPSTR  StrCCpy(LPSTR pszDst, LPCSTR pszSrc, int count);
LPSTR  StrCCat(LPSTR pszDst, LPCSTR pszSrc, int count);
LPSTR  StrCCpyFilter(LPSTR pszDst, LPCSTR pszSrc, int count);
LPSTR  TrimWhitespace(LPSTR pszBuffer);
LPSTR  AddTrailingWack(LPSTR pszDirectory, int cDirectory);
LPSTR  RemoveTrailingWack(LPSTR pszDirectory);
LPCSTR GetFileNameFromPath(LPCSTR pszPath);
void   FixFilePathCase(LPSTR pszPath);

BOOL   ReadBlock(HANDLE hFile, LPVOID lpBuffer, DWORD dwBytesToRead);
bool   WriteBlock(HANDLE hFile, LPCVOID lpBuffer, DWORD dwBytesToWrite = (DWORD)-1);
BOOL   ReadString(HANDLE hFile, LPSTR &psz);
BOOL   WriteString(HANDLE hFile, LPCSTR psz);
bool   WriteText(HANDLE hFile, LPCSTR pszText);

bool   ReadRemoteMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD dwSize);
bool   WriteRemoteMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD dwSize, bool fExecute);
bool   ReadRemoteString(HANDLE hProcess, LPSTR pszBuffer, int cBuf, LPCVOID lpvAddress, BOOL fUnicode);

LPSTR  BuildErrorMessage(DWORD dwError, LPCSTR pszMessage);

LPCSTR GetMyDocumentsPath(LPSTR pszPath);

bool   DirectoryChooser(LPSTR pszDirectory, int cDirectory, LPCSTR pszTitle, CWnd *pParentWnd); // pszDirectory needs to be at least MAX_PATH
bool   PropertiesDialog(LPCSTR pszPath);

void   RegisterDwiDwpExtensions();
void   GetRegisteredExtensions(CString &strExts);
BOOL   RegDeleteKeyRecursive(HKEY hKey, LPCSTR pszKey);
void   UnRegisterExtensions(LPCSTR pszExts);
bool   RegisterExtensions(LPCSTR pszExts);

bool   ExtractResourceFile(DWORD dwId, LPCSTR pszFile, LPSTR pszPath, int cPath);
bool   OpenMappedFile(LPCTSTR pszPath, FILE_MAP *pfm);
bool   CloseMappedFile(FILE_MAP *pfm);

LPSTR  BuildCompileDateString(LPSTR pszDate, int cDate);
LPCSTR GetMonthString(int month);
LPCSTR GetDayOfWeekString(int dow);

void   DetermineOS();
void   BuildSysInfo(SYSINFO *pSI);
bool   BuildSysInfo(SYSINFO *pSI, PFN_SYSINFOCALLBACK pfnSIC, LPARAM lParam);
LPSTR  BuildOSNameString(LPSTR pszBuf, int cBuf, SYSINFO *pSI);
LPSTR  BuildOSVersionString(LPSTR pszBuf, int cBuf, SYSINFO *pSI);
LPSTR  BuildCpuString(LPSTR pszBuf, int cBuf, SYSINFO *pSI);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __HELPERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\listview.h ===
//******************************************************************************
//
// File:        LISTVIEW.H
//
// Description: Definition file for CSmartListView class.
//
// Classes:     CSmartListView
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __LISTVIEW_H__
#define __LISTVIEW_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define CHAR_DELAY  1000

//******************************************************************************
//***** CSmartListView
//******************************************************************************

class CSmartListView : public CListView
{
protected:
    bool   m_fFocus;
    int    m_sortColumn;
    int    m_item;
    CHAR   m_szSearch[256];
    DWORD  m_dwSearchLength;
    DWORD  m_dwTimeOfLastChar;
    int    m_cRedraw;

// Constructor/Destructor (serialization only)
protected:
    CSmartListView();
    DECLARE_DYNAMIC(CSmartListView)

// Public functions
public:
    inline int  GetSortColumn()  { return m_sortColumn; }
    inline void DeleteContents() { GetListCtrl().DeleteAllItems(); }

    void SetRedraw(BOOL fRedraw);

// Internal functions
protected:
    inline  CDocDepends* GetDocument() { return (CDocDepends*)m_pDocument; }

    int  GetFocusedItem();
    int  GetTextWidth(HDC hDC, LPCSTR pszItem, int *pWidths);
    void DrawLeftText(HDC hDC, LPCSTR pszItem, CRect *prcClip, int *pWidths = NULL);
    void DrawRightText(HDC hDC, LPCSTR pszItem, CRect *prcClip, int x, int *pWidths = NULL);
    void OnChangeFocus(bool fFocus);

    virtual int  CompareColumn(int item, LPCSTR pszText) = 0;
    virtual void Sort(int sortColumn = -1) = 0;
    virtual void VirtualWriteSortColumn() = 0;

// Overrides
public:
    //{{AFX_VIRTUAL(CSmartListView)
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CSmartListView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif


// Generated message map functions
protected:
    //{{AFX_MSG(CSmartListView)
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __LISTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\listview.cpp ===
//******************************************************************************
//
// File:        LISTVIEW.CPP
//
// Description: Implementation file for CSmartListView class.
//
// Classes:     CSmartListView
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "listview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CSmartListView
//******************************************************************************

//IMPLEMENT_DYNACREATE(CSmartListView, CListView)
IMPLEMENT_DYNAMIC(CSmartListView, CListView)
BEGIN_MESSAGE_MAP(CSmartListView, CListView)
    //{{AFX_MSG_MAP(CSmartListView)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_WM_CHAR()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//******************************************************************************
// CSmartListView :: Constructor/Destructor
//******************************************************************************

CSmartListView::CSmartListView() :
    m_fFocus(false),
    m_sortColumn(-1),
    m_item(0),
    m_dwSearchLength(0),
    m_dwTimeOfLastChar(0),
    m_cRedraw(0)
{
    *m_szSearch = '\0';
}

//******************************************************************************
CSmartListView::~CSmartListView()
{
}


//******************************************************************************
// CSmartListView :: Public functions
//******************************************************************************

void CSmartListView::SetRedraw(BOOL fRedraw)
{
    if (fRedraw)
    {
        if (--m_cRedraw != 0)
        {
            return;
        }
    }
    else
    {
        if (++m_cRedraw != 1)
        {
            return;
        }
    }
    SendMessage(WM_SETREDRAW, fRedraw);
}


//******************************************************************************
// CSmartListView :: Internal functions
//******************************************************************************

int CSmartListView::GetFocusedItem()
{
    int item = GetListCtrl().GetNextItem(-1, LVNI_FOCUSED);

    // If that failed, but there is one item selectec, then get that item.
    if ((item < 0) && (GetListCtrl().GetSelectedCount() == 1))
    {
        item = GetListCtrl().GetNextItem(-1, LVNI_SELECTED);
    }

    return item;
}

//******************************************************************************
int CSmartListView::GetTextWidth(HDC hDC, LPCSTR pszItem, int *pWidths)
{
    SIZE size;
    size.cx = 0;

    if (pWidths)
    {
        while (*(pszItem++))
        {
            size.cx += *(pWidths++);
        }
    }
    else
    {
        GetTextExtentPoint32(hDC, pszItem, (int)strlen(pszItem), &size);
    }

    return size.cx;
}

//*****************************************************************************
void CSmartListView::DrawLeftText(HDC hDC, LPCSTR pszItem, CRect *prcClip, int *pWidths /*=NULL*/)
{
    // Draw the text using a fixed width for each character.
    ::ExtTextOut(hDC, prcClip->left, prcClip->top + 1, ETO_CLIPPED, prcClip,
                 pszItem, (UINT)strlen(pszItem), pWidths);
}

//*****************************************************************************
void CSmartListView::DrawRightText(HDC hDC, LPCSTR pszItem, CRect *prcClip, int x, int *pWidths /*=NULL*/)
{
    // Temporarily set our text alignment to be right-aligned.
    UINT uAlign = ::GetTextAlign(hDC);
    ::SetTextAlign(hDC, uAlign | TA_RIGHT);

    // Draw our size string to our view.
    ::ExtTextOut(hDC, min(prcClip->right, prcClip->left + x), prcClip->top + 1, ETO_CLIPPED, prcClip,
                 pszItem, (UINT)strlen(pszItem), pWidths);

    // Restore our text alignment.
    ::SetTextAlign(hDC, uAlign);
}

//******************************************************************************
void CSmartListView::OnChangeFocus(bool fFocus)
{
    // Set out focus flag. This flag is used by DrawItem() to decide when to
    // show/hide the selections and focus rectangle.
    m_fFocus = fFocus;

    // Get our client rectangle
    CRect rcClient, rcItem;
    GetClientRect(&rcClient);

    // We need to invalidate all our items that are visually effected by the
    // change in focus to the control.  The List Control should do this, but it
    // has a bug that causes it to only invalidate a portion of the first column,
    // leaving items partially redrawn after a focus change.

    // Invalidate all our selected items
    int item = -1;
    while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
    {
        GetListCtrl().GetItemRect(item, &rcItem, LVIR_BOUNDS);
        InvalidateRect(rcItem, FALSE);
    }

    // Invalidate our focused item
    if ((item = GetListCtrl().GetNextItem(-1, LVNI_FOCUSED)) >= 0)
    {
        GetListCtrl().GetItemRect(item, &rcItem, LVIR_BOUNDS);
        InvalidateRect(rcItem, FALSE);
    }
}


//******************************************************************************
// CSmartListView :: Overridden functions
//******************************************************************************

void CSmartListView::OnSetFocus(CWnd* pOldWnd)
{
    // Tell our view that the focus has changed so that it can repaint if needed.
    OnChangeFocus(TRUE);
    CListView::OnSetFocus(pOldWnd);
}

//******************************************************************************
void CSmartListView::OnKillFocus(CWnd* pNewWnd)
{
    // Tell our view that the focus has changed so that it can repaint if needed.
    OnChangeFocus(FALSE);
    CListView::OnKillFocus(pNewWnd);
}

//******************************************************************************
void CSmartListView::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    NMLISTVIEW *pNMListView = (NMLISTVIEW*)pNMHDR;

    // Make sure the user didn't click on the column that we are already sorted by.
    if (pNMListView->iSubItem != m_sortColumn)
    {
        m_dwTimeOfLastChar = 0;
        m_dwSearchLength = 0;
        *m_szSearch = '\0';
        m_item = 0;

        // Re-sort to reflect the new sort column.
        Sort(pNMListView->iSubItem);

        // Store this sort column as our new default column.
        VirtualWriteSortColumn();
    }

    *pResult = 0;
}

//******************************************************************************
void CSmartListView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    // Get the actual time that the user pressed this key.
    DWORD dwTime = GetMessageTime();

    // If the user waited too long since the last keypress, then we start a new search.
    if (!m_dwTimeOfLastChar || ((dwTime - m_dwTimeOfLastChar) > CHAR_DELAY) ||
        (m_dwSearchLength >= sizeof(m_szSearch)))
    {
        m_dwSearchLength = 0;
        m_item = 0;
    }

    // If this is not a valid character, then reset our search and pass it to the base class.
    // We used to use isprint(), but that can mess up with foreign character sets.
    if ((DWORD)nChar < 32)
    {
        m_dwTimeOfLastChar = 0;
        m_dwSearchLength = 0;
        *m_szSearch = '\0';

        // If this is not a printable character, then pass it along to our base class.
        CListView::OnChar(nChar, nRepCnt, nFlags);
        return;
    }

    // Remember the time that we received this character so we can compute
    // an elapsed time when the next character arrives.
    m_dwTimeOfLastChar = dwTime;

    // Append the new character to our search string.
    m_szSearch[m_dwSearchLength++] = (CHAR)nChar;
    m_szSearch[m_dwSearchLength] = '\0';

    // Start at our current location and search our column for the best match.
    for (int count = GetListCtrl().GetItemCount(); m_item < count; m_item++)
    {
        int result = CompareColumn(m_item, m_szSearch);
        if (result == -2)
        {
            MessageBeep(0);
            return;
        }

        // If the text for this column is greater than or equal to our search text, then stop.
        else if (result <= 0)
        {
            break;
        }
    }

    // If we walked past the end of the list, then just select the last item.
    if (m_item >= count)
    {
        m_item = count - 1;
    }

    if (m_item >= 0)
    {
        // Unselect all functions in our list.
        for (int i = -1; (i = GetListCtrl().GetNextItem(i, LVNI_SELECTED)) >= 0; )
        {
            GetListCtrl().SetItemState(i, 0, LVNI_SELECTED);
        }

        // Select the item and ensure that it is visible.
        GetListCtrl().SetItemState(m_item, LVNI_SELECTED | LVNI_FOCUSED, LVNI_SELECTED | LVNI_FOCUSED);
        GetListCtrl().EnsureVisible(m_item, FALSE);
    }
    else
    {
        m_item = 0;
    }
}

//******************************************************************************
#ifdef _DEBUG
void CSmartListView::AssertValid() const
{
    CListView::AssertValid();
}
void CSmartListView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\funcview.h ===
//******************************************************************************
//
// File:        FUNCVIEW.H
//
// Description: Definition file for the Parent Imports View, the Exports View,
//              and their base class.
//
// Classes:     CListViewFunction
//              CListViewImports
//              CListViewExports
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __FUNCVIEW_H__
#define __FUNCVIEW_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CListViewFunction
//******************************************************************************

class CListViewFunction : public CSmartListView
{
// Internal variables
protected:
    static LPCSTR ms_szColumns[];
    static int    ms_sortColumn;
    static bool   ms_fUndecorate;
    static bool   ms_fIgnoreCalledFlag;

    bool m_fExports;

// Constructor/Destructor (serialization only)
protected:
    CListViewFunction()
    {
    };
    CListViewFunction(bool fExports);
    virtual ~CListViewFunction();
    DECLARE_DYNCREATE(CListViewFunction)

// Public static functions
public:
    static int  ReadSortColumn(bool fExports);
    static void WriteSortColumn(bool fExports, int sortColumn);
    static bool SaveToTxtFile(HANDLE hFile, CModule *pModule, int sortColumn, bool fUndecorate, bool fExports, int *pMaxWidths);

// Private static functions
public:
    static int         GetImage(CFunction *pFunction);
    static int         CompareFunctions(CFunction *pFunction1, CFunction *pFunction2,
                                        int sortColumn, BOOL fUndecorate);
    static int __cdecl QSortCompare(const void *ppFunction1, const void *ppFunction2);
    static CFunction** GetSortedList(CModule *pModule, int sortColumn, bool fExports, bool fUndecorate);
    static void        GetMaxFunctionWidths(CModule *pModule, int *pMaxWidths, bool fImports, bool fExports, bool fUndecorate);

// Public functions
public:
    void SetCurrentModule(CModule *pModule);
    void RealizeNewModule();
    void UpdateNameColumn();
    void CalcColumnWidth(int column, CFunction *pFunction = NULL, HDC hDC = NULL);
    void UpdateColumnWidth(int column);

// Internal functions
protected:
    int  GetFunctionColumnWidth(HDC hDC, CFunction *pFunction, int column);
    void OnItemChanged(HD_NOTIFY *pHDNotify);

    inline LPCSTR GetHeaderText(int column) { return column ? ms_szColumns[column] : (m_fExports ? "E" : "PI"); }

    virtual int  CompareColumn(int item, LPCSTR pszText);
    virtual void Sort(int sortColumn = -1);
    virtual void VirtualWriteSortColumn()
    {
        WriteSortColumn(m_fExports, m_sortColumn);
    }

    int CompareFunc(CFunction *Function1, CFunction *Function2);
    static int CALLBACK StaticCompareFunc(LPARAM lp1, LPARAM lp2, LPARAM lpThis)
    {
        return ((CListViewFunction*)lpThis)->CompareFunc((CFunction*)lp1, (CFunction*)lp2);
    }

// Overridden functions
public:
    //{{AFX_VIRTUAL(CListViewFunction)
public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
//  virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
//  virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
//  virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnInitialUpdate(); // called first time after construct
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CListViewFunction)
    afx_msg void OnDividerDblClick(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnRClick(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnReturn(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateEditCopy(CCmdUI *pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateExternalHelp(CCmdUI* pCmdUI);
    afx_msg void OnExternalHelp();
    afx_msg void OnUpdateExternalViewer(CCmdUI* pCmdUI);
    afx_msg void OnExternalViewer();
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnProperties();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//***** CListViewImports
//******************************************************************************

class CListViewImports : public CListViewFunction
{
// Constructor/Destructor (serialization only)
protected:
    CListViewImports();
    virtual ~CListViewImports();
    DECLARE_DYNCREATE(CListViewImports)

// Public functions
public:
    void AddDynamicImport(CFunction *pImport);
    void HighlightFunction(CFunction *pExport);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CListViewImports)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CListViewImports)
    afx_msg void OnUpdateShowMatchingItem(CCmdUI* pCmdUI);
    afx_msg void OnShowMatchingItem();
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    //}}AFX_MSG
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};


//******************************************************************************
//***** CListViewExports
//******************************************************************************

class CListViewExports : public CListViewFunction
{
// Constructor/Destructor (serialization only)
protected:
    CListViewExports();
    virtual ~CListViewExports();
    DECLARE_DYNCREATE(CListViewExports)

// Public functions
public:
    void AddDynamicImport(CFunction *pImport);
    void ExportsChanged();
    void HighlightFunction(CFunction *pExport);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CListViewExports)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CListViewExports)
    afx_msg void OnUpdateShowMatchingItem(CCmdUI* pCmdUI);
    afx_msg void OnShowMatchingItem();
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    //}}AFX_MSG
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __FUNCVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\modlview.cpp ===
//******************************************************************************
//
// File:        MODLVIEW.CPP
//
// Description: Implementation file for the Module List View.
//
// Classes:     CListViewModules
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "document.h"
#include "mainfrm.h"
#include "listview.h"
#include "modtview.h"
#include "modlview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CListViewModules
//******************************************************************************

/*static*/ LPCSTR CListViewModules::ms_szColumns[] =
{
    "", // Image
    "Module",
    "File Time Stamp",
    "Link Time Stamp",
    "File Size",
    "Attr.",
    "Link Checksum",
    "Real Checksum",
    "CPU",
    "Subsystem",
    "Symbols",
    "Preferred Base",
    "Actual Base",
    "Virtual Size",
    "Load Order",
    "File Ver",
    "Product Ver",
    "Image Ver",
    "Linker Ver",
    "OS Ver",
    "Subsystem Ver"
};

/*static*/ int  CListViewModules::ms_sortColumn = -1;
/*static*/ bool CListViewModules::ms_fFullPaths = false;

//******************************************************************************
IMPLEMENT_DYNCREATE(CListViewModules, CSmartListView)
BEGIN_MESSAGE_MAP(CListViewModules, CSmartListView)
    //{{AFX_MSG_MAP(CListViewModules)
    ON_NOTIFY(HDN_DIVIDERDBLCLICKA, 0, OnDividerDblClick)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRClick)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblClk)
    ON_NOTIFY_REFLECT(NM_RETURN, OnReturn)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_VIEWER, OnUpdateExternalViewer)
    ON_COMMAND(IDM_EXTERNAL_VIEWER, OnExternalViewer)
    ON_UPDATE_COMMAND_UI(IDM_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(IDM_PROPERTIES, OnProperties)
    ON_COMMAND(ID_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_PREV_PANE, OnPrevPane)
    ON_NOTIFY(HDN_DIVIDERDBLCLICKW, 0, OnDividerDblClick)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_MATCHING_ITEM, OnUpdateShowMatchingItem)
    ON_COMMAND(IDM_SHOW_MATCHING_ITEM, OnShowMatchingItem)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    // Standard printing commands
//  ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()


//******************************************************************************
// CListViewModules :: Constructor/Destructor
//******************************************************************************

CListViewModules::CListViewModules()
{
    ZeroMemory(m_cxColumns, sizeof(m_cxColumns)); // inspected
}

//******************************************************************************
CListViewModules::~CListViewModules()
{
}


//******************************************************************************
// CListViewModules :: Static Functions
//******************************************************************************

/*static*/ int CListViewModules::ReadSortColumn()
{
    // Read the value from the registry.
    int sortColumn = g_theApp.GetProfileInt(g_pszSettings, "SortColumnModules", LVMC_DEFAULT); // inspected. MFC function

    // If the value is invalid, then just return our default value.
    if ((sortColumn < 0) || (sortColumn >= LVMC_COUNT))
    {
        return LVMC_DEFAULT;
    }

    return sortColumn;
}

//******************************************************************************
/*static*/ void CListViewModules::WriteSortColumn(int column)
{
    g_theApp.WriteProfileInt(g_pszSettings, "SortColumnModules", column);
}

//******************************************************************************
/*static*/ bool CListViewModules::SaveToTxtFile(HANDLE hFile, CSession *pSession, int sortColumn, bool fFullPaths)
{
    //                12345678901234567890123456789012345678901234567890123456789012345678901234567890
    WriteText(hFile, "********************************| Module List |*********************************\r\n"
                     "*                                                                              *\r\n"
                     "* Legend: D  Delay Load Module   ?  Missing Module           6  64-bit Module  *\r\n"
                     "*         *  Dynamic Module      !  Invalid Module                             *\r\n"
                     "*                                E  Import/Export Mismatch or Load Failure     *\r\n"
                     "*                                                                              *\r\n"
                     "********************************************************************************\r\n\r\n");

    int      i, j, width[LVMC_COUNT], maxWidth[LVMC_COUNT];
    DWORD    dwFlags;
    CHAR     szBuffer[DW_MAX_PATH + (32 * LVMC_COUNT)], *psz, *psz2, *pszNull = szBuffer + sizeof(szBuffer) - 1;
    CModule *pModule, **ppCur, **ppModules = GetSortedList(pSession, sortColumn, fFullPaths);

    ZeroMemory(maxWidth, sizeof(maxWidth)); // inspected
    maxWidth[0] = 5;

    // Fill in our column width maxes with the widths of the headers.
    for (int column = 1; column < LVMC_COUNT; column++)
    {
        maxWidth[column] = (int)strlen(ms_szColumns[column]);
    }

    // Loop through each module, checking for the maximum columns widths.
    for (ppCur = ppModules; *ppCur; ppCur++)
    {
        pModule = *ppCur;

        ZeroMemory(width, sizeof(width)); // inspected

        width[LVMC_MODULE] = (int)strlen(pModule->GetName(fFullPaths, true));

        if (!(pModule->GetFlags() & DWMF_ERROR_MESSAGE))
        {
            width[LVMC_FILE_TIME_STAMP] = (int)strlen(pModule->BuildTimeStampString(szBuffer, sizeof(szBuffer), TRUE, ST_TXT));

            width[LVMC_LINK_TIME_STAMP] = (int)strlen(pModule->BuildTimeStampString(szBuffer, sizeof(szBuffer), FALSE, ST_TXT));

            width[LVMC_FILE_SIZE] = (int)strlen(pModule->BuildFileSizeString(szBuffer, sizeof(szBuffer)));

            width[LVMC_ATTRIBUTES] = (int)strlen(pModule->BuildAttributesString(szBuffer, sizeof(szBuffer)));

            width[LVMC_LINK_CHECKSUM] = (int)strlen(pModule->BuildLinkCheckSumString(szBuffer, sizeof(szBuffer)));

            width[LVMC_REAL_CHECKSUM] = (int)strlen(pModule->BuildRealCheckSumString(szBuffer, sizeof(szBuffer)));

            width[LVMC_MACHINE] = (int)strlen(pModule->BuildMachineString(szBuffer, sizeof(szBuffer)));

            width[LVMC_SUBSYSTEM] = (int)strlen(pModule->BuildSubsystemString(szBuffer, sizeof(szBuffer)));

            width[LVMC_SYMBOLS] = (int)strlen(pModule->BuildSymbolsString(szBuffer, sizeof(szBuffer)));

            width[LVMC_PREFERRED_BASE] = (int)strlen(pModule->BuildBaseAddressString(szBuffer, sizeof(szBuffer), TRUE, pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_TXT));

            width[LVMC_ACTUAL_BASE] = (int)strlen(pModule->BuildBaseAddressString(szBuffer, sizeof(szBuffer), FALSE, pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_TXT));

            width[LVMC_VIRTUAL_SIZE] = (int)strlen(pModule->BuildVirtualSizeString(szBuffer, sizeof(szBuffer)));

            width[LVMC_LOAD_ORDER] = (int)strlen(pModule->BuildLoadOrderString(szBuffer, sizeof(szBuffer)));

            width[LVMC_FILE_VER] = (int)strlen(pModule->BuildFileVersionString(szBuffer, sizeof(szBuffer)));

            width[LVMC_PRODUCT_VER] = (int)strlen(pModule->BuildProductVersionString(szBuffer, sizeof(szBuffer)));

            width[LVMC_IMAGE_VER] = (int)strlen(pModule->BuildImageVersionString(szBuffer, sizeof(szBuffer)));

            width[LVMC_LINKER_VER] = (int)strlen(pModule->BuildLinkerVersionString(szBuffer, sizeof(szBuffer)));

            width[LVMC_OS_VER] = (int)strlen(pModule->BuildOSVersionString(szBuffer, sizeof(szBuffer)));

            width[LVMC_SUBSYSTEM_VER] = (int)strlen(pModule->BuildSubsystemVersionString(szBuffer, sizeof(szBuffer)));
        }

        // Update our max widths for each column
        for (column = 1; column < LVMC_COUNT; column++)
        {
            if (width[column] > maxWidth[column])
            {
                maxWidth[column] = width[column];
            }
        }
    }

    // Output the header row.
    for (psz = szBuffer, column = 0; column < LVMC_COUNT; column++)
    {
        StrCCpy(psz, ms_szColumns[column], sizeof(szBuffer) - (int)(psz - szBuffer));
        psz2 = psz + strlen(psz);
        if (column < (LVMC_COUNT - 1))
        {
            while (((psz2 - psz) < (maxWidth[column] + 2)) && (psz2 < pszNull))
            {
                *psz2++ = ' ';
            }
        }
        psz = psz2;
    }
    StrCCpy(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

    if (!WriteText(hFile, szBuffer))
    {
        MemFree((LPVOID&)ppModules);
        return false;
    }

    // Output the header underline.
    for (psz = szBuffer, column = 0; column < LVMC_COUNT; column++)
    {
        for (i = 0; (i < maxWidth[column]) && (psz < pszNull); i++)
        {
            *psz++ = '-';
        }
        if (column < (LVMC_COUNT - 1))
        {
            if (psz < pszNull)
            {
                *psz++ = ' ';
            }
            if (psz < pszNull)
            {
                *psz++ = ' ';
            }
        }
    }
    StrCCpy(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

    if (!WriteText(hFile, szBuffer))
    {
        MemFree((LPVOID&)ppModules);
        return false;
    }

    // Loop through each module, this time logging them to the file.
    for (ppCur = ppModules; *ppCur; ppCur++)
    {
        pModule = *ppCur;

        // Loop through each column and build the output string.
        for (psz = szBuffer, column = 0; column < LVMC_COUNT; column++)
        {
            switch (column)
            {
                case LVMC_IMAGE: // example [DE6]
                    dwFlags = pModule->GetFlags();
                    psz2 = psz;

                    if (psz2 < pszNull)
                    {
                        *psz2++ = '[';
                    }

                    if (dwFlags & DWMF_IMPLICIT_ALO)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = ' ';
                        }
                    }
                    else if (dwFlags & DWMF_DYNAMIC_ALO)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = '*';
                        }
                    }
                    else if (dwFlags & DWMF_DELAYLOAD_ALO)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = 'D';
                        }
                    }
                    else
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = ' ';
                        }
                    }

                    if (dwFlags & DWMF_FILE_NOT_FOUND)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = '?';
                        }
                    }
                    else if (dwFlags & DWMF_ERROR_MESSAGE)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = '!';
                        }
                    }
                    else if (dwFlags & DWMF_MODULE_ERROR)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = 'E';
                        }
                    }
                    else
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = ' ';
                        }
                    }

                    if (dwFlags & DWMF_64BIT)
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = '6';
                        }
                    }
                    else
                    {
                        if (psz2 < pszNull)
                        {
                            *psz2++ = ' ';
                        }
                    }

                    if (psz2 < pszNull)
                    {
                        *psz2++ = ']';
                    }
                    *psz2 = '\0';
                    break;

                case LVMC_MODULE:
                    StrCCpyFilter(psz, pModule->GetName(fFullPaths, true), sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_FILE_TIME_STAMP:
                    // If the module has an error, then we display it now and skip
                    // the rest of the columns.
                    if (pModule->GetFlags() & DWMF_ERROR_MESSAGE)
                    {
                        psz += strlen(StrCCpy(psz, pModule->GetErrorMessage(), sizeof(szBuffer) - (int)(psz - szBuffer)));
                        goto SKIP;
                    }

                    pModule->BuildTimeStampString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), TRUE, ST_TXT);
                    break;

                case LVMC_LINK_TIME_STAMP:
                    pModule->BuildTimeStampString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), FALSE, ST_TXT);
                    break;

                case LVMC_FILE_SIZE:
                    pModule->BuildFileSizeString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    for (psz2 = psz, j = maxWidth[LVMC_FILE_SIZE] - (int)strlen(psz); (j > 0) && (psz2 < pszNull); j--)
                    {
                        *psz2++ = ' ';
                    }
                    pModule->BuildFileSizeString(psz2, sizeof(szBuffer) - (int)(psz2 - szBuffer));
                    break;

                case LVMC_ATTRIBUTES:
                    pModule->BuildAttributesString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LINK_CHECKSUM:
                    pModule->BuildLinkCheckSumString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_REAL_CHECKSUM:
                    pModule->BuildRealCheckSumString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_MACHINE:
                    pModule->BuildMachineString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SUBSYSTEM:
                    pModule->BuildSubsystemString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SYMBOLS:
                    pModule->BuildSymbolsString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_PREFERRED_BASE:
                    pModule->BuildBaseAddressString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), TRUE, pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_TXT);
                    break;

                case LVMC_ACTUAL_BASE:
                    pModule->BuildBaseAddressString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), FALSE, pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_TXT);
                    break;

                case LVMC_VIRTUAL_SIZE:
                    pModule->BuildVirtualSizeString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LOAD_ORDER:
                    pModule->BuildLoadOrderString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_FILE_VER:
                    pModule->BuildFileVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_PRODUCT_VER:
                    pModule->BuildProductVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_IMAGE_VER:
                    pModule->BuildImageVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LINKER_VER:
                    pModule->BuildLinkerVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_OS_VER:
                    pModule->BuildOSVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SUBSYSTEM_VER:
                    pModule->BuildSubsystemVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                default:
                    *psz = '\0';
            }

            psz2 = psz + strlen(psz);
            if (column < (LVMC_COUNT - 1))
            {
                while (((psz2 - psz) < (maxWidth[column] + 2)) && (psz2 < pszNull))
                {
                    *psz2++ = ' ';
                }
            }
            psz = psz2;
        }

        SKIP:
        StrCCpy(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

        if (!WriteText(hFile, szBuffer))
        {
            MemFree((LPVOID&)ppModules);
            return false;
        }
    }

    MemFree((LPVOID&)ppModules);
    return WriteText(hFile, "\r\n");
}

//******************************************************************************
/*static*/ bool CListViewModules::SaveToCsvFile(HANDLE hFile, CSession *pSession, int sortColumn, bool fFullPaths)
{
    CHAR  szBuffer[DW_MAX_PATH + (32 * LVMC_COUNT)], *psz, *pszNull = szBuffer + sizeof(szBuffer) - 1;
    int   column;
    DWORD dwFlags;
    CModule *pModule, **ppCur, **ppModules = GetSortedList(pSession, sortColumn, fFullPaths);

    // Build the header row.
    psz = szBuffer + strlen(StrCCpy(szBuffer, "Status", sizeof(szBuffer)));
    for (column = 1; (column < LVMC_COUNT) && (psz < pszNull); column++)
    {
        *psz++ = ',';
        psz += strlen(StrCCpy(psz, ms_szColumns[column], sizeof(szBuffer) - (int)(psz - szBuffer)));
    }
    StrCCpy(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

    // Output the header row.
    if (!WriteText(hFile, szBuffer))
    {
        MemFree((LPVOID&)ppModules);
        return false;
    }

    // Loop through each module, checking for the maximum columns widths.
    for (ppCur = ppModules; *ppCur; ppCur++)
    {
        pModule = *ppCur;

        dwFlags = pModule->GetFlags();

        // Loop through each column and build the output string.
        for (psz = szBuffer, column = 0; column < LVMC_COUNT; column++)
        {
            switch (column)
            {
                case LVMC_IMAGE:
                    if (dwFlags & DWMF_IMPLICIT_ALO)
                    {
                    }
                    else if (dwFlags & DWMF_DYNAMIC_ALO)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = '*';
                        }
                    }
                    else if (dwFlags & DWMF_DELAYLOAD_ALO)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = 'D';
                        }
                    }
                    if (dwFlags & DWMF_FILE_NOT_FOUND)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = '?';
                        }
                    }
                    else if (dwFlags & DWMF_ERROR_MESSAGE)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = '!';
                        }
                    }
                    else if (dwFlags & DWMF_MODULE_ERROR_ALO)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = 'E';
                        }
                    }
                    if (dwFlags & DWMF_64BIT)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = '6';
                        }
                    }
                    *psz = '\0';
                    break;

                case LVMC_MODULE:
                    // We put the file name in quotes since a comma is a legal filename character.
                    if (psz < pszNull)
                    {
                        *psz++ = '\"';
                    }
                    StrCCpyFilter(psz, pModule->GetName(fFullPaths, true), sizeof(szBuffer) - (int)(psz - szBuffer));
                    StrCCat(psz, "\"", sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_FILE_TIME_STAMP:
                    // If we have an error, dump it out now and skip the rest of the columns.
                    if (dwFlags & DWMF_ERROR_MESSAGE)
                    {
                        if (psz < pszNull)
                        {
                            *psz++ = '\"';
                        }
                        psz += strlen(StrCCpy(psz, pModule->GetErrorMessage(), sizeof(szBuffer) - (int)(psz - szBuffer)));
                        if (psz < pszNull)
                        {
                            *psz++ = '\"';
                        }
                        while ((++column < LVMC_COUNT) && (psz < pszNull))
                        {
                            *psz++ = ',';
                        }
                        *psz = '\0';
                        goto SKIP;
                    }
                    pModule->BuildTimeStampString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), TRUE, ST_CSV);
                    break;

                case LVMC_LINK_TIME_STAMP:
                    pModule->BuildTimeStampString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), FALSE, ST_CSV);
                    break;

                case LVMC_FILE_SIZE:
                    // We don't use BuildFileSizeString() since it sticks commas in.
                    SCPrintf(psz, sizeof(szBuffer) - (int)(psz - szBuffer), "%u", pModule->GetFileSize());
                    break;

                case LVMC_ATTRIBUTES:
                    pModule->BuildAttributesString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LINK_CHECKSUM:
                    pModule->BuildLinkCheckSumString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_REAL_CHECKSUM:
                    pModule->BuildRealCheckSumString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_MACHINE:
                    pModule->BuildMachineString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SUBSYSTEM:
                    pModule->BuildSubsystemString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SYMBOLS:
                    if (psz < pszNull)
                    {
                        *psz++ = '\"';
                    }
                    pModule->BuildSymbolsString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    StrCCat(psz, "\"", sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_PREFERRED_BASE:
                    pModule->BuildBaseAddressString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), TRUE, FALSE, ST_CSV);
                    break;

                case LVMC_ACTUAL_BASE:
                    pModule->BuildBaseAddressString(psz, sizeof(szBuffer) - (int)(psz - szBuffer), FALSE, FALSE, ST_CSV);
                    break;

                case LVMC_VIRTUAL_SIZE:
                    pModule->BuildVirtualSizeString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LOAD_ORDER:
                    pModule->BuildLoadOrderString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_FILE_VER:
                    pModule->BuildFileVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_PRODUCT_VER:
                    pModule->BuildProductVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_IMAGE_VER:
                    pModule->BuildImageVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_LINKER_VER:
                    pModule->BuildLinkerVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_OS_VER:
                    pModule->BuildOSVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                case LVMC_SUBSYSTEM_VER:
                    pModule->BuildSubsystemVersionString(psz, sizeof(szBuffer) - (int)(psz - szBuffer));
                    break;

                default:
                    *psz = '\0';
            }

            psz += strlen(psz);
            if ((column < (LVMC_COUNT - 1)) && (psz < pszNull))
            {
                *psz++ = ',';
            }
        }

        SKIP:
        StrCCpy(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

        if (!WriteText(hFile, szBuffer))
        {
            MemFree((LPVOID&)ppModules);
            return false;
        }
    }

    MemFree((LPVOID&)ppModules);
    return true;
}

//******************************************************************************
/*static*/ int CListViewModules::GetImage(CModule *pModule)
{
    //  0  missing  implicit
    //  1  missing  delay
    //  2  missing  dynamic
    //  3  error    implicit
    //  4  error    delay
    //  5  error    dynamic
    //  6  export   implicit
    //  7  export   implicit  64bit
    //  8  export   delay
    //  9  export   delay     64bit
    // 10  export   dynamic
    // 11  export   dynamic   64bit
    // 12  export   dynamic          data
    // 13  export   dynamic   64bit  data
    // 14  good     implicit
    // 15  good     implicit  64bit
    // 16  good     delay
    // 17  good     delay     64bit
    // 18  good     dynamic
    // 19  good     dynamic   64bit
    // 20  good     dynamic          data
    // 21  good     dynamic   64bit  data

    DWORD dwFlags = pModule->GetFlags();

    if (dwFlags & DWMF_FILE_NOT_FOUND)
    {
        if (dwFlags & DWMF_IMPLICIT_ALO)
        {
            return 0;
        }
        else if (dwFlags & DWMF_DYNAMIC_ALO)
        {
            return 2;
        }
        else if (dwFlags & DWMF_DELAYLOAD_ALO)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

    if (dwFlags & DWMF_ERROR_MESSAGE)
    {
        if (dwFlags & DWMF_IMPLICIT_ALO)
        {
            return 3;
        }
        else if (dwFlags & DWMF_DYNAMIC_ALO)
        {
            return 5;
        }
        else if (dwFlags & DWMF_DELAYLOAD_ALO)
        {
            return 4;
        }
        else
        {
            return 3;
        }
    }

    int image = 14;

    if (dwFlags & DWMF_MODULE_ERROR_ALO)
    {
        if (dwFlags & DWMF_IMPLICIT_ALO)
        {
            image = 6;
        }
        else if (dwFlags & DWMF_NO_RESOLVE_CORE)
        {
            image = 12;
        }
        else if (dwFlags & DWMF_DYNAMIC_ALO)
        {
            image = 10;
        }
        else if (dwFlags & DWMF_DELAYLOAD_ALO)
        {
            image = 8;
        }
        else
        {
            image = 6;
        }
    }
    else if (dwFlags & DWMF_IMPLICIT_ALO)
    {
        image = 14;
    }
    else if (dwFlags & DWMF_NO_RESOLVE_CORE)
    {
        image = 20;
    }
    else if (dwFlags & DWMF_DYNAMIC_ALO)
    {
        image = 18;
    }
    else if (dwFlags & DWMF_DELAYLOAD_ALO)
    {
        image = 16;
    }
    else
    {
        image = 14;
    }

    if (dwFlags & DWMF_64BIT)
    {
        image++;
    }

    return image;
}

//******************************************************************************
/*static*/ int CListViewModules::CompareModules(CModule *pModule1, CModule *pModule2,
                                                int sortColumn, bool fFullPaths)
{
    // Return Negative value if the first item should precede the second.
    // Return Positive value if the first item should follow the second.
    // Return Zero if the two items are equivalent.

    int   result = 0;
    char  szItem1[64], szItem2[64];
    DWORD dwMS1, dwLS1, dwMS2, dwLS2, dwOrder1, dwOrder2;

    // If we not sorted by one of the first two columns and one of the modules
    // has an error, then we always move the error to the top.
    if ((sortColumn > LVMC_MODULE) &&
        (pModule1->GetErrorMessage() || pModule2->GetErrorMessage()))
    {
        result = (pModule1->GetErrorMessage() ? -1 : 0) +
                 (pModule2->GetErrorMessage() ?  1 : 0);
    }

    // Otherwise, just do a module-to-module compare for the column
    else
    {
        // Compute the relationship based on the current sort column
        switch (sortColumn)
        {
            case LVMC_IMAGE: // Image Index Sort - Smallest to Largest
                result = GetImage(pModule1) -
                         GetImage(pModule2);
                break;

            case LVMC_FILE_TIME_STAMP: // File Time Stamp - Oldest to Newest

                result = CompareFileTime(pModule1->GetFileTimeStamp(),
                                         pModule2->GetFileTimeStamp());
                break;

            case LVMC_LINK_TIME_STAMP: // Link Time Stamp - Oldest to Newest
                result = CompareFileTime(pModule1->GetLinkTimeStamp(),
                                         pModule2->GetLinkTimeStamp());
                break;

            case LVMC_FILE_SIZE: // File Size - Smallest to Largest
                result = Compare(pModule1->GetFileSize(), pModule2->GetFileSize());
                break;

            case LVMC_ATTRIBUTES: // Attributes - String Sort
                result = strcmp(pModule1->BuildAttributesString(szItem1, sizeof(szItem1)),
                                pModule2->BuildAttributesString(szItem2, sizeof(szItem2)));
                break;

            case LVMC_LINK_CHECKSUM: // Reported CheckSum - Lowest to Highest
                result = Compare(pModule1->GetLinkCheckSum(),
                                 pModule2->GetLinkCheckSum());
                break;

            case LVMC_REAL_CHECKSUM: // Real CheckSum - Lowest to Highest
                result = Compare(pModule1->GetRealCheckSum(),
                                 pModule2->GetRealCheckSum());
                break;

            case LVMC_MACHINE: // Machine - String Sort
                result = _stricmp(pModule1->BuildMachineString(szItem1, sizeof(szItem1)),
                                  pModule2->BuildMachineString(szItem2, sizeof(szItem2)));
                break;

            case LVMC_SUBSYSTEM: // Subsystem - String Sort
                result = _stricmp(pModule1->BuildSubsystemString(szItem1, sizeof(szItem1)),
                                  pModule2->BuildSubsystemString(szItem2, sizeof(szItem2)));
                break;

            case LVMC_SYMBOLS: // Symbols - String Sort
                result = strcmp(pModule1->BuildSymbolsString(szItem1, sizeof(szItem1)),
                                pModule2->BuildSymbolsString(szItem2, sizeof(szItem2)));
                break;

            case LVMC_PREFERRED_BASE: // Preferred Base Address - Lowest to Highest
                result = Compare(pModule1->GetPreferredBaseAddress(),
                                 pModule2->GetPreferredBaseAddress());
                break;

            case LVMC_ACTUAL_BASE: // Actual Base Address - Lowest to Highest
                if (pModule1->GetFlags() & DWMF_DATA_FILE_CORE)
                {
                    if (pModule2->GetFlags() & DWMF_DATA_FILE_CORE)
                    {
                        // Both are data files.
                        result = 0;
                    }
                    else
                    {
                        // 1 is data file, 2 is not a data file.
                        result = -1;
                    }
                }
                else
                {
                    if (pModule2->GetFlags() & DWMF_DATA_FILE_CORE)
                    {
                        // 1 is not a data file, 2 is a data file.
                        result = 1;
                    }
                    else
                    {
                        // Neither is a data file.
                        result = Compare(pModule1->GetActualBaseAddress(),
                                         pModule2->GetActualBaseAddress());
                    }
                }
                break;

            case LVMC_VIRTUAL_SIZE: // Virtual Size - Smallest to Largest
                result = Compare(pModule1->GetVirtualSize(),
                                 pModule2->GetVirtualSize());
                break;

            case LVMC_LOAD_ORDER: // Load Order - Lowest to Highest, but N/A's (0) go to end.
                dwOrder1 = pModule1->GetLoadOrder();
                dwOrder2 = pModule2->GetLoadOrder();
                result = Compare(dwOrder1 ? dwOrder1 : 0xFFFFFFF,
                                 dwOrder2 ? dwOrder2 : 0xFFFFFFF);
                break;

            case LVMC_FILE_VER: // File Version - Lowest to Highest
                dwLS1 = pModule1->GetFileVersion(&dwMS1);
                dwLS2 = pModule2->GetFileVersion(&dwMS2);
                if (!(result = Compare(dwMS1, dwMS2)))
                {
                    result = Compare(dwLS1, dwLS2);
                }
                break;

            case LVMC_PRODUCT_VER: // Product Version - Lowest to Highest
                dwLS1 = pModule1->GetProductVersion(&dwMS1);
                dwLS2 = pModule2->GetProductVersion(&dwMS2);
                if (!(result = Compare(dwMS1, dwMS2)))
                {
                    result = Compare(dwLS1, dwLS2);
                }
                break;

            case LVMC_IMAGE_VER: // Image Version - Lowest to Highest
                result = Compare(pModule1->GetImageVersion(),
                                 pModule2->GetImageVersion());
                break;

            case LVMC_LINKER_VER: // Linker Version - Lowest to Highest
                result = Compare(pModule1->GetLinkerVersion(),
                                 pModule2->GetLinkerVersion());
                break;

            case LVMC_OS_VER: // OS Version - Lowest to Highest
                result = Compare(pModule1->GetOSVersion(),
                                 pModule2->GetOSVersion());
                break;

            case LVMC_SUBSYSTEM_VER: // Subsystem Version - Lowest to Highest
                result = Compare(pModule1->GetSubsystemVersion(),
                                 pModule2->GetSubsystemVersion());
                break;
        }
    }

    // If the sort resulted in a tie, we use the module name to break the tie.
    if (result == 0)
    {
        result = _stricmp(pModule1->GetName(fFullPaths), pModule2->GetName(fFullPaths));
    }

    return result;
}

//******************************************************************************
/*static*/ int __cdecl CListViewModules::QSortCompare(const void *ppModule1, const void *ppModule2)
{
    return CompareModules(*(CModule**)ppModule1, *(CModule**)ppModule2, ms_sortColumn, ms_fFullPaths);
}

//******************************************************************************
/*static*/ CModule** CListViewModules::GetSortedList(CSession *pSession, int sortColumn, bool fFullPaths)
{
    // Allocate and array to hold pointers to all our original CModule objects.
    CModule **ppModules = (CModule**)MemAlloc((pSession->GetOriginalCount() + 1) * sizeof(CModule*));
    ZeroMemory(ppModules, (pSession->GetOriginalCount() + 1) * sizeof(CModule*)); // inspected

    // Locate all the originals and fill in the array.
    FindOriginalModules(pSession->GetRootModule(), ppModules);

    // Since the qsort function does not allow for any user data, we need to store
    // some info globally so it can be accessed in our callback.
    ms_sortColumn = sortColumn;
    ms_fFullPaths = fFullPaths;

    // Sort the array
    qsort(ppModules, pSession->GetOriginalCount(), sizeof(CModule*), QSortCompare);

    return ppModules;
}

//******************************************************************************
/*static*/ CModule** CListViewModules::FindOriginalModules(CModule *pModule, CModule **ppModuleList)
{
    if (pModule)
    {
        // If the module is an original, then store it in the array and increment it.
        if (pModule->IsOriginal())
        {
            *(ppModuleList++) = pModule;
        }

        // recurse into our children and siblings.
        ppModuleList = FindOriginalModules(pModule->GetChildModule(), ppModuleList);
        ppModuleList = FindOriginalModules(pModule->GetNextSiblingModule(), ppModuleList);
    }

    // Return the potentially updated list pointer.
    return ppModuleList;
}


//******************************************************************************
// CListViewModules :: Public functions
//******************************************************************************

void CListViewModules::HighlightModule(CModule *pModule)
{
    // Unselect all modules in our list.
    for (int item = -1; (item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0; )
    {
        GetListCtrl().SetItemState(item, 0, LVNI_SELECTED);
    }

    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pModule;

    // Find the module in our list that goes with this module object.
    if ((item = GetListCtrl().FindItem(&lvfi)) >= 0)
    {
        // Select the item and ensure that it is visible.
        GetListCtrl().SetItemState(item, LVNI_SELECTED | LVNI_FOCUSED, LVNI_SELECTED | LVNI_FOCUSED);
        GetListCtrl().EnsureVisible(item, FALSE);

        // Give ourself the focus.
        GetParentFrame()->SetActiveView(this);
    }
}

//******************************************************************************
void CListViewModules::Refresh()
{
    // Hide the window to increase drawing speed.
    SetRedraw(FALSE);

    // Add all modules to our view by recursing into our root module.
    for (CModule *pModule = GetDocument()->GetRootModule(); pModule;
        pModule = pModule->GetNextSiblingModule())
    {
        AddModules(pModule, NULL);
    }

    // Get our DC and select our font into it.
    HDC hDC = ::GetDC(GetSafeHwnd());
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
    }

    // Set the widths of each column to "best fit".
    for (int column = 0; column < LVMC_COUNT; column++)
    {
        CalcColumnWidth(column, NULL, hDC);
        UpdateColumnWidth(column);
    }

    // Free our DC.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(hDC, hFontStock);
    }
    ::ReleaseDC(GetSafeHwnd(), hDC);

    // Sort the newly added items with our current sort method.
    Sort();

    // Restore the window.
    SetRedraw(TRUE);
}

//******************************************************************************
void CListViewModules::OnViewFullPaths()
{
    // Update the width of the module name column to reflect the change.
    CalcColumnWidth(LVMC_MODULE);
    UpdateColumnWidth(LVMC_MODULE);

    // Invalidate the first column so that it will repaint with the new module
    // strings. We do this just as a precaution since changing the column width
    // should invalidate the column as well.
    CRect rcClient;
    GetClientRect(&rcClient);
    rcClient.right = GetListCtrl().GetColumnWidth(LVMC_MODULE);
    InvalidateRect(&rcClient, FALSE);

    // If we are currently sorting by module name, then re-sort the items.
    if (m_sortColumn == LVMC_MODULE)
    {
        Sort();
    }
}

//******************************************************************************
void CListViewModules::DoSettingChange()
{
    // Update our timesatamp columns as they may have changed widths do to changes
    // in the time and date separators.
    CalcColumnWidth(LVMC_FILE_TIME_STAMP);
    UpdateColumnWidth(LVMC_FILE_TIME_STAMP);
    CalcColumnWidth(LVMC_LINK_TIME_STAMP);
    UpdateColumnWidth(LVMC_LINK_TIME_STAMP);

    // Update our file size column in case the digit grouping character changed.
    CalcColumnWidth(LVMC_FILE_SIZE);
    UpdateColumnWidth(LVMC_FILE_SIZE);

    // Invalidate all the items so they will repaint - this is needed when a
    // country specific change is made that does not cause our column to
    // resize (which does a paint on its own).  An example is when you change
    // the "hour" setting for "h" to "hh", the we do not see 0 padded hours
    // until we repaint.
    GetListCtrl().RedrawItems(0, GetListCtrl().GetItemCount() - 1);

    // Make sure the update takes effect.
    UpdateWindow();
}


//******************************************************************************
// CListViewModules :: Internal functions
//******************************************************************************

void CListViewModules::AddModules(CModule *pModule, HDC hDC)
{
    // This view only displays unique modules. Skip the InsertItem() if this
    // module is a duplicate.  We still need to recurse on the dependent modules
    // since a duplicate module can have a unique forwarded module under it.

    if (pModule->IsOriginal())
    {
        // Check to see if this item is already in our list.
        LVFINDINFO lvfi;
        lvfi.flags  = LVFI_PARAM;
        lvfi.lParam = (LPARAM)pModule;

        if (GetListCtrl().FindItem(&lvfi) < 0)
        {
            // Add the current module to our list.
            GetListCtrl().InsertItem(TVIF_IMAGE | TVIF_PARAM, GetListCtrl().GetItemCount(),
                NULL, 0, 0, GetImage(pModule), (LPARAM)pModule);

            // If a DC was passed in, then check for new column max widths.
            if (hDC)
            {
                for (int column = 0; column < LVMC_COUNT; column++)
                {
                    CalcColumnWidth(column, pModule, hDC);
                }
            }
        }
    }

    // Recurse into AddModules() for each dependent module.
    pModule = pModule->GetChildModule();
    while (pModule)
    {
        AddModules(pModule, hDC);
        pModule = pModule->GetNextSiblingModule();
    }
}

//******************************************************************************
void CListViewModules::AddModuleTree(CModule *pModule)
{
    // Hide the window to increase drawing speed.
    SetRedraw(FALSE);

    // Get our DC and select our font into it.
    HDC hDC = ::GetDC(GetSafeHwnd());
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
    }

    // Add all the modules.
    AddModules(pModule, hDC);

    // Free our DC.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(hDC, hFontStock);
    }
    ::ReleaseDC(GetSafeHwnd(), hDC);

    // Update the width of any columns that may have change.
    for (int column = 0; column < LVMC_COUNT; column++)
    {
        UpdateColumnWidth(column);
    }

    // Sort the newly added item with our current sort method.
    Sort();

    // Restore the window.
    SetRedraw(TRUE);
}

//******************************************************************************
void CListViewModules::RemoveModuleTree(CModule *pModule)
{
    // We only delete original modules.
    if (pModule->IsOriginal())
    {
        // Find this module in our list.
        LVFINDINFO lvfi;
        lvfi.flags  = LVFI_PARAM;
        lvfi.lParam = (LPARAM)pModule;
        int index = GetListCtrl().FindItem(&lvfi);

        // Make sure the item exists.
        if (index >= 0)
        {
            // Delete the item from our list.
            GetListCtrl().DeleteItem(index);
        }
    }
}

//******************************************************************************
void CListViewModules::UpdateModule(CModule *pModule)
{
    // We only care about these flags.
    if (!(pModule->GetUpdateFlags() & (DWUF_LIST_IMAGE | DWUF_ACTUAL_BASE | DWUF_LOAD_ORDER)))
    {
        return;
    }

    // Find this module in our list.
    LVFINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pModule->GetOriginal();
    int index = GetListCtrl().FindItem(&lvfi);

    // Make sure the item exists.
    if (index < 0)
    {
        return;
    }

    // Update our load address column width if it has changed.
    CalcColumnWidth(LVMC_ACTUAL_BASE, pModule);
    UpdateColumnWidth(LVMC_ACTUAL_BASE);

    // Get the bounding rect of the item.
    RECT rc;
    GetListCtrl().GetItemRect(index, &rc, LVIR_BOUNDS);
    InvalidateRect(&rc, FALSE);

    // Resort if data changed in a column that we are sorted by.
    if (((pModule->GetUpdateFlags() & DWUF_LIST_IMAGE)  && (m_sortColumn == LVMC_IMAGE))       ||
        ((pModule->GetUpdateFlags() & DWUF_ACTUAL_BASE) && (m_sortColumn == LVMC_ACTUAL_BASE)) ||
        ((pModule->GetUpdateFlags() & DWUF_LOAD_ORDER)  && (m_sortColumn == LVMC_LOAD_ORDER)))
    {
        Sort();
    }
}

//******************************************************************************
void CListViewModules::UpdateAll()
{
    GetListCtrl().RedrawItems(0, GetListCtrl().GetItemCount() - 1);

    // Resort if we are currently sorted by a column that is effected by UpdateAll.
    if ((m_sortColumn == LVMC_ACTUAL_BASE) || (m_sortColumn == LVMC_LOAD_ORDER))
    {
        Sort();
    }

    // Make sure the update occurs before we move on.
    UpdateWindow();
}

//******************************************************************************
void CListViewModules::ChangeOriginal(CModule *pModuleOld, CModule *pModuleNew)
{
    // Find this module in our list.
    LVFINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pModuleOld;
    int index = GetListCtrl().FindItem(&lvfi);

    // Make sure the item exists.
    if (index >= 0)
    {
        GetListCtrl().SetItemData(index, (DWORD_PTR)pModuleNew);
    }
}

//******************************************************************************
void CListViewModules::CalcColumnWidth(int column, CModule *pModule /*=NULL*/, HDC hDC /*=NULL*/)
{
    // For the image column, we always use a fixed width.
    if (column == LVMC_IMAGE)
    {
        m_cxColumns[LVMC_IMAGE] = 33; // 26 for icon plus 7 buffer
        return;
    }

    // If we don't have a module, then we start fresh and update the entire column.
    // Get the width of the header button text. We use GetStringWidth for this
    // since we want to use the font that is in the header control.
    if (!pModule)
    {
        m_cxColumns[column] = GetListCtrl().GetStringWidth(ms_szColumns[column]) +
                              GetListCtrl().GetStringWidth(" ^") + 14;
    }

    // Get our DC and select our current font into it. We need to use this DC to
    // compute text widths in the control itself since our control may have a
    // different font caused from the user changing the system-wide "icon" font.
    bool  fFreeDC = false;
    HFONT hFontStock = NULL;
    if (!hDC)
    {
        hDC = ::GetDC(GetSafeHwnd());
        if (GetDocument()->m_hFontList)
        {
            hFontStock = (HFONT)::SelectObject(hDC, GetDocument()->m_hFontList);
        }
        fFreeDC = true;
    }

    int cx;

    // Check to see if a particular module was passed in.
    if (pModule)
    {
        // Compute the width of this column for the module passed in.
        cx = GetModuleColumnWidth(hDC, pModule, column);

        // check to see if it is a new widest.
        if ((cx + 10) > m_cxColumns[column])
        {
            m_cxColumns[column] = (cx + 10);
        }
    }
    else
    {
        // Loop through each item in the list, looking for the widest string in this column.
        for (int item = GetListCtrl().GetItemCount() - 1; item >= 0; item--)
        {
            // Get the module.
            pModule = (CModule*)GetListCtrl().GetItemData(item);

            // Compute the width of this column.
            cx = GetModuleColumnWidth(hDC, pModule, column);

            // check to see if it is a new widest.
            if ((cx + 10) > m_cxColumns[column])
            {
                m_cxColumns[column] = (cx + 10);
            }
        }
    }

    // Unselect our font and free our DC.
    if (fFreeDC)
    {
        if (GetDocument()->m_hFontList)
        {
            ::SelectObject(hDC, hFontStock);
        }
        ::ReleaseDC(GetSafeHwnd(), hDC);
    }
}

//*****************************************************************************
int CListViewModules::GetModuleColumnWidth(HDC hDC, CModule *pModule, int column)
{
    // If the module has an error, then only the module name column is displayed,
    // so don't bother getting the width for any other column.
    if (pModule->GetErrorMessage() && (column != LVMC_MODULE))
    {
        return 0;
    }

    CHAR szItem[64];

    switch (column)
    {
        case LVMC_MODULE:
            return GetTextWidth(hDC, pModule->GetName(GetDocument()->m_fViewFullPaths, true), NULL);

        case LVMC_FILE_TIME_STAMP:
            return GetTextWidth(hDC, pModule->BuildTimeStampString(szItem, sizeof(szItem), TRUE, ST_UNKNOWN), GetDocument()->GetTimeStampWidths());

        case LVMC_LINK_TIME_STAMP:
            return GetTextWidth(hDC, pModule->BuildTimeStampString(szItem, sizeof(szItem), FALSE, ST_UNKNOWN), GetDocument()->GetTimeStampWidths());

        case LVMC_FILE_SIZE:
            return GetTextWidth(hDC, pModule->BuildFileSizeString(szItem, sizeof(szItem)), NULL);

        case LVMC_ATTRIBUTES:
            return GetTextWidth(hDC, pModule->BuildAttributesString(szItem, sizeof(szItem)), NULL);

        case LVMC_LINK_CHECKSUM:
            pModule->BuildLinkCheckSumString(szItem, sizeof(szItem));
            return GetTextWidth(hDC, szItem, GetDocument()->GetHexWidths(szItem));

        case LVMC_REAL_CHECKSUM:
            pModule->BuildRealCheckSumString(szItem, sizeof(szItem));
            return GetTextWidth(hDC, szItem, GetDocument()->GetHexWidths(szItem));

        case LVMC_MACHINE:
            return GetTextWidth(hDC, pModule->BuildMachineString(szItem, sizeof(szItem)), NULL);

        case LVMC_SUBSYSTEM:
            return GetTextWidth(hDC, pModule->BuildSubsystemString(szItem, sizeof(szItem)), NULL);

        case LVMC_SYMBOLS:
            return GetTextWidth(hDC, pModule->BuildSymbolsString(szItem, sizeof(szItem)), NULL);

        case LVMC_PREFERRED_BASE:
            pModule->BuildBaseAddressString(szItem, sizeof(szItem), TRUE, GetDocument()->m_pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_UNKNOWN);
            return GetTextWidth(hDC, szItem, GetDocument()->GetHexWidths(szItem));

        case LVMC_ACTUAL_BASE:
            pModule->BuildBaseAddressString(szItem, sizeof(szItem), FALSE, GetDocument()->m_pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_UNKNOWN);
            return GetTextWidth(hDC, szItem, GetDocument()->GetHexWidths(szItem));

        case LVMC_VIRTUAL_SIZE:
            pModule->BuildVirtualSizeString(szItem, sizeof(szItem));
            return GetTextWidth(hDC, szItem, GetDocument()->GetHexWidths(szItem));

        case LVMC_LOAD_ORDER:
            return GetTextWidth(hDC, pModule->BuildLoadOrderString(szItem, sizeof(szItem)), NULL);

        case LVMC_FILE_VER:
            return GetTextWidth(hDC, pModule->BuildFileVersionString(szItem, sizeof(szItem)), NULL);

        case LVMC_PRODUCT_VER:
            return GetTextWidth(hDC, pModule->BuildProductVersionString(szItem, sizeof(szItem)), NULL);

        case LVMC_IMAGE_VER:
            return GetTextWidth(hDC, pModule->BuildImageVersionString(szItem, sizeof(szItem)), NULL);

        case LVMC_LINKER_VER:
            return GetTextWidth(hDC, pModule->BuildLinkerVersionString(szItem, sizeof(szItem)), NULL);

        case LVMC_OS_VER:
            return GetTextWidth(hDC, pModule->BuildOSVersionString(szItem, sizeof(szItem)), NULL);

        case LVMC_SUBSYSTEM_VER:
            return GetTextWidth(hDC, pModule->BuildSubsystemVersionString(szItem, sizeof(szItem)), NULL);
    }

    return 0;
}

//*****************************************************************************
void CListViewModules::UpdateColumnWidth(int column)
{
    if (GetListCtrl().GetColumnWidth(column) != m_cxColumns[column])
    {
        GetListCtrl().SetColumnWidth(column, m_cxColumns[column]);
    }
}

//*****************************************************************************
void CListViewModules::OnItemChanged(HD_NOTIFY *pHDNotify)
{
    // OnItemChanged() is called whenever a column width has been modified.
    // If Full Drag is on, we will get an HDN_ITEMCHANGED when the column width
    // is changing.  When Full Drag is off we get a HDN_ITEMCHANGED when the
    // user has finished moving the slider around.

    // Invalidate any items that contain error strings.  The default behavior
    // when a column is resized is to repaint only that column.  Since our error
    // text spans multiple columns, we need to invalidate the entire column to
    // ensure that the error text is properly displayed.

    for (int i = GetListCtrl().GetItemCount() - 1; i >= 0; i--)
    {
        CModule *pModule = (CModule*)GetListCtrl().GetItemData(i);
        if (pModule->GetErrorMessage())
        {
            CRect rcItem;
            GetListCtrl().GetItemRect(i, &rcItem, LVIR_BOUNDS);
            rcItem.left = GetListCtrl().GetColumnWidth(LVMC_MODULE);
            InvalidateRect(&rcItem, FALSE);
        }
    }
}

//******************************************************************************
int CListViewModules::CompareColumn(int item, LPCSTR pszText)
{
    CModule *pModule = (CModule*)GetListCtrl().GetItemData(item);
    if (!pModule)
    {
        return -2;
    }

    CHAR   szBuffer[DW_MAX_PATH];
    LPCSTR psz = szBuffer;
    ULONG  ulValue;

    switch (m_sortColumn)
    {
        case LVMC_MODULE:
            psz = pModule->GetName(GetDocument()->m_fViewFullPaths);
            break;

        case LVMC_FILE_SIZE:
            if (isdigit(*pszText))
            {
                if ((ulValue = strtoul(pszText, NULL, 0)) != ULONG_MAX)
                {
                    return Compare(ulValue, pModule->GetFileSize());
                }
            }
            return -2;

        case LVMC_ATTRIBUTES:
            psz = pModule->BuildAttributesString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_LINK_CHECKSUM:
            psz = pModule->BuildLinkCheckSumString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_REAL_CHECKSUM:
            psz = pModule->BuildRealCheckSumString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_MACHINE:
            psz = pModule->BuildMachineString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_SUBSYSTEM:
            psz = pModule->BuildSubsystemString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_SYMBOLS:
            psz = pModule->BuildSymbolsString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_PREFERRED_BASE:
            psz = pModule->BuildBaseAddressString(szBuffer, sizeof(szBuffer), TRUE,  FALSE, ST_UNKNOWN);
            break;

        case LVMC_ACTUAL_BASE:
            psz = pModule->BuildBaseAddressString(szBuffer, sizeof(szBuffer), FALSE, FALSE, ST_UNKNOWN);
            break;

        case LVMC_VIRTUAL_SIZE:
            psz = pModule->BuildVirtualSizeString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_LOAD_ORDER:
            if (isdigit(*pszText))
            {
                if ((ulValue = strtoul(pszText, NULL, 0)) != ULONG_MAX)
                {
                    return Compare(ulValue, pModule->GetLoadOrder());
                }
            }
            return -2;

        case LVMC_FILE_VER:
            psz = pModule->BuildFileVersionString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_PRODUCT_VER:
            psz = pModule->BuildProductVersionString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_IMAGE_VER:
            psz = pModule->BuildImageVersionString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_LINKER_VER:
            psz = pModule->BuildLinkerVersionString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_OS_VER:
            psz = pModule->BuildOSVersionString(szBuffer, sizeof(szBuffer));
            break;

        case LVMC_SUBSYSTEM_VER:
            psz = pModule->BuildSubsystemVersionString(szBuffer, sizeof(szBuffer));
            break;

        default:
            return -2;
    }

    INT i = _stricmp(pszText, psz);
    return (i < 0) ? -1 :
           (i > 0) ?  1 : 0;
}

//******************************************************************************
void CListViewModules::Sort(int sortColumn)
{
    // Bail now if we don't need to sort.
    if ((m_sortColumn == sortColumn) && (sortColumn != -1))
    {
        return;
    }

    // If the default arg is used, then just re-sort with our current sort column.
    if (sortColumn == -1)
    {
        GetListCtrl().SortItems(StaticCompareFunc, (DWORD_PTR)this);
    }

    // Otherwise, we need to re-sort and update our column header text.
    else
    {
        LVCOLUMN lvc;
        lvc.mask = LVCF_TEXT;

        if (m_sortColumn >= 0)
        {
            // Remove the "^" from the previous sort column header item.
            lvc.pszText = (LPSTR)ms_szColumns[m_sortColumn];
            GetListCtrl().SetColumn(m_sortColumn, &lvc);
        }

        // Store our new sort column.
        m_sortColumn = sortColumn;

        // Add the "^" to our new sort column header item.
        CHAR szColumn[32];
        lvc.pszText = StrCCat(StrCCpy(szColumn, ms_szColumns[m_sortColumn], sizeof(szColumn)),
                             m_sortColumn ? " ^" : "^", sizeof(szColumn));
        GetListCtrl().SetColumn(m_sortColumn, &lvc);

        // Apply our new sorting method the List Control.
        GetListCtrl().SortItems(StaticCompareFunc, (DWORD_PTR)this);
    }

    // If we have an item that has the focus, then make sure it is visible.
    int item = GetFocusedItem();
    if (item >= 0)
    {
        GetListCtrl().EnsureVisible(item, FALSE);
    }
}

//******************************************************************************
int CListViewModules::CompareFunc(CModule *pModule1, CModule *pModule2)
{
    return CompareModules(pModule1, pModule2, m_sortColumn, GetDocument()->m_fViewFullPaths);
}

//******************************************************************************
// CListViewModules :: Overridden functions
//******************************************************************************

BOOL CListViewModules::PreCreateWindow(CREATESTRUCT &cs)
{
    // Set our window style and then complete the creation of our view.
    cs.style |= LVS_REPORT | LVS_OWNERDRAWFIXED | LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS;
    return CSmartListView::PreCreateWindow(cs);
}

//******************************************************************************
#if 0 //{{AFX
BOOL CListViewModules::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CListViewModules::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CListViewModules::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}
#endif //}}AFX

//******************************************************************************
void CListViewModules::OnInitialUpdate()
{
    // Set our list control's image list with our application's global image list.
    // We do this just as a means of setting the item height for each item.
    // Since we are owner draw, we will actually be drawing our own images.
    GetListCtrl().SetImageList(&g_theApp.m_ilListModules, LVSIL_SMALL);

    // Initialize our font and fixed width character spacing arrays.
    GetDocument()->InitFontAndFixedWidths(this);

    // Add all of our columns.
    for (int column = 0; column < LVMC_COUNT; column++)
    {
        GetListCtrl().InsertColumn(column, ms_szColumns[column]);
    }

    // We center column 0, so the sort image '^' will be centered.  There appears
    // to be a bug in InsertItem that does not allow column 0 to be centered, but
    // we are able to set this using SetColumn after the column is inserted.
    LVCOLUMN lvc;
    lvc.mask = LVCF_FMT;
    lvc.fmt = LVCFMT_CENTER;
    GetListCtrl().SetColumn(0, &lvc);

    // Sort our list by our default sort column.
    Sort(ReadSortColumn());
}

//******************************************************************************
void CListViewModules::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    // Make sure everything is valid.
    if (!lpDIS->itemData)
    {
        return;
    }

    // Use our global font that the control was created with.
    HFONT hFontStock = NULL;
    if (GetDocument()->m_hFontList)
    {
        hFontStock = (HFONT)::SelectObject(lpDIS->hDC, GetDocument()->m_hFontList);
    }

    // Make sure text alignment is set to top.  This should be the default.
    ::SetTextAlign(lpDIS->hDC, TA_TOP);

    // Get a pointer to our CModule for this item.
    CModule *pModule = (CModule*)lpDIS->itemData;

    // Get any error string that may be associated with this module.
    LPCSTR pszModuleError = pModule->GetErrorMessage();

    // Select the background and text colors.
    ::SetBkColor  (lpDIS->hDC, GetSysColor(COLOR_WINDOW));
    ::SetTextColor(lpDIS->hDC, GetSysColor(COLOR_WINDOWTEXT));

    // Create a copy of our item's rectangle so we can manipulate the values.
    CRect rcClip(&lpDIS->rcItem);

    CHAR szItem[64];
    int imageWidth = 0, left = rcClip.left, width;

    for (int column = 0; column < LVMC_COUNT; column++)
    {
        // Compute the width for this column.
        width = GetListCtrl().GetColumnWidth(column);

        // Compute the clipping rectangle for this column's text.
        if (column == LVMC_IMAGE)
        {
            rcClip.left  = left;
            rcClip.right = left + width;
        }
        else if (column > LVMC_MODULE)
        {
            // Bail after the image and module name if we have an error.
            if (pszModuleError)
            {
                break;
            }

            rcClip.left  = left + 5;
            rcClip.right = left + width - 5;
        }

        // Call the correct routine to draw this column's text.
        switch (column)
        {
            case LVMC_IMAGE:

                // Store the width for later calculations.
                imageWidth = width;

                // Erase the image area with the window background color.
                ::ExtTextOut(lpDIS->hDC, rcClip.left, rcClip.top, ETO_OPAQUE, &rcClip, "", 0, NULL);

                // Draw the image in the image area.
                ImageList_Draw(g_theApp.m_ilListModules.m_hImageList, GetImage(pModule),
                               lpDIS->hDC, rcClip.left + 3, rcClip.top + ((rcClip.Height() - 15) / 2),
                               m_fFocus && (lpDIS->itemState & ODS_SELECTED) ?
                               (ILD_BLEND50 | ILD_SELECTED | ILD_BLEND) : ILD_TRANSPARENT);
                break;

            case LVMC_MODULE:

                // If the item is selected, then select new background and text colors.
                if (lpDIS->itemState & ODS_SELECTED)
                {
                    ::SetBkColor  (lpDIS->hDC, GetSysColor(m_fFocus ? COLOR_HIGHLIGHT     : COLOR_BTNFACE));
                    ::SetTextColor(lpDIS->hDC, GetSysColor(m_fFocus ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
                }

                // Erase the text area with the window background color.
                rcClip.left = rcClip.right;
                rcClip.right = lpDIS->rcItem.right;
                ::ExtTextOut(lpDIS->hDC, rcClip.left, rcClip.top, ETO_OPAQUE, &rcClip, "", 0, NULL);

                rcClip.left  = left + 5;
                rcClip.right = left + width - 5;

                DrawLeftText(lpDIS->hDC, pModule->GetName(GetDocument()->m_fViewFullPaths, true), &rcClip);
                break;

            case LVMC_FILE_TIME_STAMP:
                DrawLeftText(lpDIS->hDC, pModule->BuildTimeStampString(szItem, sizeof(szItem), TRUE, ST_UNKNOWN), &rcClip, GetDocument()->GetTimeStampWidths());
                break;

            case LVMC_LINK_TIME_STAMP:
                DrawLeftText(lpDIS->hDC, pModule->BuildTimeStampString(szItem, sizeof(szItem), FALSE, ST_UNKNOWN), &rcClip, GetDocument()->GetTimeStampWidths());
                break;

            case LVMC_FILE_SIZE:
                DrawRightText(lpDIS->hDC, pModule->BuildFileSizeString(szItem, sizeof(szItem)), &rcClip, m_cxColumns[LVMC_FILE_SIZE] - 10);
                break;

            case LVMC_ATTRIBUTES:
                DrawLeftText(lpDIS->hDC, pModule->BuildAttributesString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_LINK_CHECKSUM:
                pModule->BuildLinkCheckSumString(szItem, sizeof(szItem));

                // Check to see if we need to draw this text in red.
                if (!(lpDIS->itemState & ODS_SELECTED) && pModule->GetLinkCheckSum() &&
                    (pModule->GetLinkCheckSum() != pModule->GetRealCheckSum()))
                {
                    COLORREF crStock = ::SetTextColor(lpDIS->hDC, RGB(255, 0, 0));
                    DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                    ::SetTextColor(lpDIS->hDC, crStock);
                }
                else
                {
                    DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                }
                break;

            case LVMC_REAL_CHECKSUM:
                pModule->BuildRealCheckSumString(szItem, sizeof(szItem));
                DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                break;

            case LVMC_MACHINE:
                // Check to see if we need to draw this text in red.
                if (!(lpDIS->itemState & ODS_SELECTED) &&
                    (pModule->GetMachineType() != GetDocument()->m_pSession->GetMachineType()))
                {
                    COLORREF crStock = ::SetTextColor(lpDIS->hDC, RGB(255, 0, 0));
                    DrawLeftText(lpDIS->hDC, pModule->BuildMachineString(szItem, sizeof(szItem)), &rcClip);
                    ::SetTextColor(lpDIS->hDC, crStock);
                }
                else
                {
                    DrawLeftText(lpDIS->hDC, pModule->BuildMachineString(szItem, sizeof(szItem)), &rcClip);
                }
                break;

            case LVMC_SUBSYSTEM:
                DrawLeftText(lpDIS->hDC, pModule->BuildSubsystemString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_SYMBOLS:
                DrawLeftText(lpDIS->hDC, pModule->BuildSymbolsString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_PREFERRED_BASE:
                pModule->BuildBaseAddressString(szItem, sizeof(szItem), TRUE, GetDocument()->m_pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_UNKNOWN);
                DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                break;

            case LVMC_ACTUAL_BASE:
                pModule->BuildBaseAddressString(szItem, sizeof(szItem), FALSE, GetDocument()->m_pSession->GetSessionFlags() & DWSF_64BIT_ALO, ST_UNKNOWN);

                // Check to see if we need to draw this text in red.
                if (!(lpDIS->itemState & ODS_SELECTED) &&
                    !(pModule->GetFlags() & DWMF_DATA_FILE_CORE) &&
                    (pModule->GetActualBaseAddress() != (DWORDLONG)-1) &&
                    (pModule->GetPreferredBaseAddress() != pModule->GetActualBaseAddress()))
                {
                    COLORREF crStock = ::SetTextColor(lpDIS->hDC, RGB(255, 0, 0));
                    DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                    ::SetTextColor(lpDIS->hDC, crStock);
                }
                else
                {
                    DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                }
                break;

            case LVMC_VIRTUAL_SIZE:
                pModule->BuildVirtualSizeString(szItem, sizeof(szItem));
                DrawLeftText(lpDIS->hDC, szItem, &rcClip, GetDocument()->GetHexWidths(szItem));
                break;

            case LVMC_LOAD_ORDER:
                DrawLeftText(lpDIS->hDC, pModule->BuildLoadOrderString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_FILE_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildFileVersionString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_PRODUCT_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildProductVersionString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_IMAGE_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildImageVersionString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_LINKER_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildLinkerVersionString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_OS_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildOSVersionString(szItem, sizeof(szItem)), &rcClip);
                break;

            case LVMC_SUBSYSTEM_VER:
                DrawLeftText(lpDIS->hDC, pModule->BuildSubsystemVersionString(szItem, sizeof(szItem)), &rcClip);
                break;
        }

        // Draw a vertical divider line between the columns.
        ::MoveToEx(lpDIS->hDC, left + width - 1, rcClip.top, NULL);
        ::LineTo  (lpDIS->hDC, left + width - 1, rcClip.bottom);

        // Increment our location to the beginning of the next column
        left += width;
    }

    // Check to see if this module has an error string.  If we do have an error
    // string, then we just display the module error in columns 2 and beyond.

    if (pszModuleError)
    {
        // Build a clipping rect for the error string.
        rcClip.left  = left + 5;
        rcClip.right = lpDIS->rcItem.right - 5;

        // Draw the error string spanning across all the columns.
        if (!(lpDIS->itemState & ODS_SELECTED))
        {
            ::SetTextColor(lpDIS->hDC, RGB(255, 0, 0));
        }
        ::ExtTextOut(lpDIS->hDC, rcClip.left, rcClip.top, ETO_CLIPPED, &rcClip,
                     pszModuleError, (UINT)strlen(pszModuleError), NULL);

        // Draw a vertical divider line after the last column.
        ::MoveToEx(lpDIS->hDC, rcClip.right + 4, rcClip.top, NULL);
        ::LineTo  (lpDIS->hDC, rcClip.right + 4, rcClip.bottom);
    }

    // Draw the focus box if this item has the focus.
    if (m_fFocus && (lpDIS->itemState & ODS_FOCUS))
    {
        rcClip.left  = lpDIS->rcItem.left + imageWidth;
        rcClip.right = lpDIS->rcItem.right;
        ::DrawFocusRect(lpDIS->hDC, &rcClip);
    }

    // Unselect our font.
    if (GetDocument()->m_hFontList)
    {
        ::SelectObject(lpDIS->hDC, hFontStock);
    }
}

//******************************************************************************
LRESULT CListViewModules::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // We catch the HDN_ITEMCHANGED notification message here because of a bug in
    // MFC. The ON_NOTIFY() macro for HDN_XXX notification messages prevent the
    // List Control from getting the message which cause problems with the UI.
    // By hooking the message here, we allow MFC to continue processing the
    // message and send it to the List Control.
    if ((message == WM_NOTIFY) && ((((LPNMHDR)lParam)->code == HDN_ITEMCHANGEDA) ||
                                   (((LPNMHDR)lParam)->code == HDN_ITEMCHANGEDW)))
    {
        OnItemChanged((HD_NOTIFY*)lParam);
    }

    return CSmartListView::WindowProc(message, wParam, lParam);
}

//******************************************************************************
// CListViewModules :: Event handler functions
//******************************************************************************

void CListViewModules::OnDividerDblClick(NMHDR *pNMHDR, LRESULT *pResult)
{
    int column = ((HD_NOTIFY*)pNMHDR)->iItem;

    // Update our column width to "best fit" width.
    if ((column >= 0) && (column < LVMC_COUNT))
    {
        UpdateColumnWidth(column);
    }
    *pResult = TRUE;
}

//******************************************************************************
void CListViewModules::OnRClick(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Tell our main frame to display our context menu.
    g_pMainFrame->DisplayPopupMenu(2);

    *pResult = FALSE;
}

//******************************************************************************
void CListViewModules::OnDblClk(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Simulate the user selecting our IDM_EXTERNAL_VIEWER menu item.
    OnExternalViewer();

    // Stop further processing of the this message.
    *pResult = TRUE;
}

//******************************************************************************
void CListViewModules::OnReturn(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Simulate the user selected our IDM_EXTERNAL_VIEWER menu item.
    OnExternalViewer();

    // Stop further processing of the this message to prevent the default beep.
    *pResult = TRUE;
}

//******************************************************************************
void CListViewModules::OnUpdateShowMatchingItem(CCmdUI* pCmdUI)
{
    // Set the text to for this menu item.
    pCmdUI->SetText("&Highlight Matching Module In Tree\tCtrl+M");

    // Get the item that has the focus.
    int item = GetFocusedItem();

    // If we found an item, then we are enabled.
    pCmdUI->Enable(item >= 0);
}

//******************************************************************************
void CListViewModules::OnShowMatchingItem()
{
    // Get the item that has the focus.
    int item = GetFocusedItem();

    // Check to see if we found an item.
    if (item >= 0)
    {
        // Get the function associated with this item.
        CModule *pModule = (CModule*)GetListCtrl().GetItemData(item);

        // If we have a module, then tell our tree view to highlight it.
        if (pModule)
        {
            GetDocument()->m_pTreeViewModules->HighlightModule(pModule);
        }
    }
}

//******************************************************************************
void CListViewModules::OnUpdateEditCopy(CCmdUI *pCmdUI)
{
    // Get the number of selected items.
    int count = GetListCtrl().GetSelectedCount();

    // Set the text according to how many items are selected.
    pCmdUI->SetText(GetDocument()->m_fViewFullPaths ?
                    ((count == 1) ? "&Copy File Path\tCtrl+C" : "&Copy File Paths\tCtrl+C") :
                    ((count == 1) ? "&Copy File Name\tCtrl+C" : "&Copy File Names\tCtrl+C"));

    // Enable the copy command if at least one function is selected.
    pCmdUI->Enable(count > 0);
}

//******************************************************************************
void CListViewModules::OnEditCopy()
{
    CString strPaths;

    // Loop through all selected modules.
    int item = -1, count = 0;
    while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
    {
        // Get the module object from the item
        CModule *pModule = (CModule*)GetListCtrl().GetItemData(item);

        // If this item is not the first, then insert a newline
        if (count++)
        {
            strPaths += "\r\n";
        }

        // Add the path for this module to our string
        strPaths += (pModule->GetName(GetDocument()->m_fViewFullPaths, true));
    }

    // If we added more than one item, then we append a newline to the end.
    if (count > 1)
    {
        strPaths += "\r\n";
    }

    // Copy the string list to the clipboard.
    g_pMainFrame->CopyTextToClipboard(strPaths);
}

//******************************************************************************
void CListViewModules::OnEditSelectAll()
{
    // Loop through all modules in our view and select each one.
    for (int item = GetListCtrl().GetItemCount() - 1; item >= 0; item--)
    {
        GetListCtrl().SetItemState(item, LVIS_SELECTED, LVIS_SELECTED);
    }
}

//******************************************************************************
void CListViewModules::OnUpdateExternalViewer(CCmdUI *pCmdUI)
{
    // Get the number of selected items.
    int count = GetListCtrl().GetSelectedCount();

    // Set the text according to how many items are selected.
    pCmdUI->SetText((count == 1) ? "View Module in External &Viewer\tEnter" :
                                   "View Modules in External &Viewer\tEnter");

    // Enable our External Viewer command if at least one module is selected.
    pCmdUI->Enable(GetDocument()->IsLive() && (count > 0));
}

//******************************************************************************
void CListViewModules::OnExternalViewer()
{
    if (GetDocument()->IsLive())
    {
        // Loop through all the selected modules, launching each with our external viewer.
        int item = -1;
        while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
        {
            g_theApp.m_dlgViewer.LaunchExternalViewer(
                ((CModule*)GetListCtrl().GetItemData(item))->GetName(true));
        }
    }
}

//******************************************************************************
void CListViewModules::OnUpdateProperties(CCmdUI *pCmdUI)
{
    // Enable our Properties Dialog command at least one module is selected.
    pCmdUI->Enable(GetDocument()->IsLive() && (GetListCtrl().GetSelectedCount() > 0));
}

//******************************************************************************
void CListViewModules::OnProperties()
{
    // Loop through all the selected modules, displaying a Properties Dialog for each.
    int item = -1;
    while ((item = GetListCtrl().GetNextItem(item, LVNI_SELECTED)) >= 0)
    {
        CModule *pModule = (CModule*)GetListCtrl().GetItemData(item);
        if (pModule)
        {
            PropertiesDialog(pModule->GetName(true));
        }
    }
}

//******************************************************************************
void CListViewModules::OnNextPane()
{
    // Change the focus to our next pane, the Profile Edit View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pRichViewProfile);
}

//******************************************************************************
void CListViewModules::OnPrevPane()
{
    // Change the focus to our previous pane, the Exports View.
#if 0 //{{AFX
    GetParentFrame()->SetActiveView(GetDocument()->m_fDetailView ?
                                    (CView*)GetDocument()->m_pRichViewDetails :
                                    (CView*)GetDocument()->m_pListViewExports);
#endif //}}AFX
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewExports);
}

//******************************************************************************
LRESULT CListViewModules::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    // Called when the context help pointer (SHIFT+F1) is clicked on our client.
    return (0x20000 + IDR_MODULE_LIST_VIEW);
}

//******************************************************************************
LRESULT CListViewModules::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    // Called when the user chooses help (F1) while our view is active.
    g_theApp.WinHelp(0x20000 + IDR_MODULE_LIST_VIEW);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\mainfrm.cpp ===
//******************************************************************************
//
// File:        MAINFRM.CPP
//
// Description: Implementation file for the Main Frame window
//
// Classes:     CMainFrame
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "msdnhelp.h"
#include "mainfrm.h"
#include "dbgthread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static UINT indicators[] =
{
    ID_SEPARATOR // status line indicator
};

//******************************************************************************
//***** CMainFrame
//******************************************************************************

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_MOVE()
    ON_WM_DESTROY()
    ON_MESSAGE(WM_MAIN_THREAD_CALLBACK, OnMainThreadCallback)
    ON_WM_SETTINGCHANGE()
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
    ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

//******************************************************************************
// CMainFrame :: Constructor/Destructor
//******************************************************************************

CMainFrame::CMainFrame() :
    m_rcWindow(INT_MAX, INT_MAX, INT_MIN, INT_MIN), // set to an invalid rect.
    m_evaMainThreadCallback(NULL)
{
    // Store global access to us.
    g_pMainFrame = this;

    // Create a critical section and event to be used by MainThreadCallback.
    InitializeCriticalSection(&m_csMainThreadCallback); // inpsected
    m_evaMainThreadCallback = CreateEvent(NULL, FALSE, FALSE, NULL); // inspected. nameless event.
}

//******************************************************************************
CMainFrame::~CMainFrame()
{
    // Close our MainThreadCallback event and critical section.
    CloseHandle(m_evaMainThreadCallback);
    DeleteCriticalSection(&m_csMainThreadCallback);

    g_pMainFrame = NULL;
}


//******************************************************************************
// CMainFrame :: Private functions
//******************************************************************************

void CMainFrame::SetPreviousWindowPostion()
{
    // Get our startup information.
    STARTUPINFO si;
    ZeroMemory(&si, sizeof(si)); // inspected
    si.cb = sizeof(si);
    GetStartupInfo(&si);

    // If the app that started us specified a position, then we use it instead of
    // restoring our previous position.
    if (si.dwFlags & (STARTF_USESIZE | STARTF_USEPOSITION))
    {
        return;
    }

    // Read in old settings.  If any of them are undefined, then return.  Negative values are allowed.
    CRect rcWindow;
    if (((rcWindow.left   = g_theApp.GetProfileInt(g_pszSettings, "WindowLeft",   INT_MAX)) == INT_MAX) || // inspected. MFC function
        ((rcWindow.top    = g_theApp.GetProfileInt(g_pszSettings, "WindowTop",    INT_MAX)) == INT_MAX) || // inspected. MFC function
        ((rcWindow.right  = g_theApp.GetProfileInt(g_pszSettings, "WindowRight",  INT_MIN)) == INT_MIN) || // inspected. MFC function
        ((rcWindow.bottom = g_theApp.GetProfileInt(g_pszSettings, "WindowBottom", INT_MIN)) == INT_MIN))   // inspected. MFC function
    {
        return;
    }

    // Read in old screen settings - use all signed ints since negatives are allowed.
    int cxScreen = GetSystemMetrics(SM_CXSCREEN);
    int cyScreen = GetSystemMetrics(SM_CYSCREEN);
    int cxPrev   = g_theApp.GetProfileInt(g_pszSettings, "ScreenWidth",  cxScreen); // inspected. MFC function
    int cyPrev   = g_theApp.GetProfileInt(g_pszSettings, "ScreenHeight", cyScreen); // inspected. MFC function

    // If the screen resolution has changed since our last run, then scale our window
    // to our current resolution.
    if (cxPrev != cxScreen)
    {
        rcWindow.left   = (rcWindow.left  * cxScreen)  / cxPrev;
        rcWindow.right  = (rcWindow.right * cxScreen)  / cxPrev;
    }
    if (cyPrev != cyScreen)
    {
        rcWindow.top    = (rcWindow.top    * cyScreen) / cyPrev;
        rcWindow.bottom = (rcWindow.bottom * cyScreen) / cyPrev;
    }

    // Try to get the virtual screen size (only Win98+ and Win2K+ support multi-mon)
    CRect rcVScreen;
    if ((rcVScreen.right  = GetSystemMetrics(SM_CXVIRTUALSCREEN)) &&
        (rcVScreen.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN)))
    {
        rcVScreen.left    = GetSystemMetrics(SM_XVIRTUALSCREEN);
        rcVScreen.top     = GetSystemMetrics(SM_YVIRTUALSCREEN);
        rcVScreen.right  += rcVScreen.left;
        rcVScreen.bottom += rcVScreen.top;
    }

    // If that fails, then we just get the primary monitor size.
    else
    {
        rcVScreen.left   = 0;
        rcVScreen.top    = 0;
        rcVScreen.right  = cxScreen;
        rcVScreen.bottom = cyScreen;
    }

    // This is mostly just a last minute sanity check to ensure we are on screen
    // somewhere and that our window rect is valid.  It is possible to have "holes"
    // in a virtual desktop, but this is better than no check at all.
    if ((rcWindow.left  >= rcVScreen.right) || (rcWindow.top    >= rcVScreen.bottom) ||
        (rcWindow.right <= rcVScreen.left)  || (rcWindow.bottom <= rcVScreen.top)    ||
        (rcWindow.left  >= rcWindow.right)  || (rcWindow.top    >= rcWindow.bottom))
    {
        // If there is a problem, then just let the OS position us.
        return;
    }

    // Move our window to these new coordinates.
    MoveWindow(&rcWindow, FALSE);
}

//******************************************************************************
void CMainFrame::SaveWindowPosition()
{
    // Store the screen coordinates.
    g_theApp.WriteProfileInt(g_pszSettings, "ScreenWidth",  GetSystemMetrics(SM_CXSCREEN));
    g_theApp.WriteProfileInt(g_pszSettings, "ScreenHeight", GetSystemMetrics(SM_CYSCREEN));

    // Store our window rectangle.
    if ((m_rcWindow.left <= m_rcWindow.right) && (m_rcWindow.top <= m_rcWindow.bottom))
    {
        g_theApp.WriteProfileInt(g_pszSettings, "WindowLeft",   m_rcWindow.left);
        g_theApp.WriteProfileInt(g_pszSettings, "WindowTop",    m_rcWindow.top);
        g_theApp.WriteProfileInt(g_pszSettings, "WindowRight",  m_rcWindow.right);
        g_theApp.WriteProfileInt(g_pszSettings, "WindowBottom", m_rcWindow.bottom);
    }
}

//******************************************************************************
// CMainFrame :: Public functions
//******************************************************************************

void CMainFrame::DisplayPopupMenu(int menu)
{
    // Get the mouse position in screen coordinates.
    CPoint ptScreen(GetMessagePos());

    // Get our global popups menu from the resource file.
    CMenu menuPopups;
    menuPopups.LoadMenu(IDR_POPUPS);

    // Extract the system view menu.
    CMenu *pMenuPopup = menuPopups.GetSubMenu(menu);

    // Draw and track the "floating" popup - send menu messages to our main frame.
    pMenuPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                               ptScreen.x, ptScreen.y, this);
}

//******************************************************************************
void CMainFrame::CopyTextToClipboard(LPCSTR pszText)
{
    // Open the clipboard
    if (OpenClipboard())
    {
        // Clear the clipboard
        if (EmptyClipboard())
        {
            // Create a shared memory object and copy the string to it.
            HANDLE hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, strlen(pszText) + 1);
            LPSTR pszMem = (LPSTR)GlobalLock(hMem);
            strcpy(pszMem, pszText); // inspected
            GlobalUnlock(hMem);

            // Put our string memory object on the clipboard
            SetClipboardData(CF_TEXT, hMem);
        }

        // Close the clipboard
        CloseClipboard();
    }
}

//******************************************************************************
void CMainFrame::CallMeBackFromTheMainThreadPlease(PFN_MAIN_THREAD_CALLBACK pfnCallback, LPARAM lParam)
{
    // If we are being called on our main thread, then just call our private
    // routine directly. If we are not on our main thread, then we post a
    // message to our main thread and wait for the main thread to complete the
    // operation to complete.  Note, we use a PostMessage() combined with a
    // WaitForSingleObject() instead of a SendMessage(), as SendMessage() can
    // sometimes cause deadlocks due to blocked incoming and blocked outgoing
    // synchronous system calls (Error 0x8001010D).

    if (GetCurrentThreadId() == g_theApp.m_nThreadID)
    {
        // Call the function directly if we are on are main thread
        pfnCallback(lParam);
    }

    // Post a message to the function if we are not on our main thread.
    EnterCriticalSection(&m_csMainThreadCallback);
    {
        if (GetSafeHwnd())
        {
            PostMessage(WM_MAIN_THREAD_CALLBACK, (WPARAM)pfnCallback, lParam);
            WaitForSingleObject(m_evaMainThreadCallback, INFINITE);
        }
    }
    LeaveCriticalSection(&m_csMainThreadCallback);
}


//******************************************************************************
// CMainFrame :: Event handler functions
//******************************************************************************

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    // Move window to the saved position from the previous run
    SetPreviousWindowPostion();

    // Call our MFC base class to create the frame window itself.
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    // Create our toolbar.
    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP |
                               CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    // Create our status bar.
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)))
    {
        TRACE("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // Enable dockable toolbar.
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

//******************************************************************************
void CMainFrame::OnSize(UINT nType, int cx, int cy) 
{
    CMDIFrameWnd::OnSize(nType, cx, cy);
    
    // When ever we see a change to the normal window size, we store it away.
    if ((nType == SIZE_RESTORED) && !IsIconic() && !IsZoomed())
    {
        GetWindowRect(&m_rcWindow);
    }
}

//******************************************************************************
void CMainFrame::OnMove(int x, int y) 
{
    CMDIFrameWnd::OnMove(x, y);
    
    // When ever we see a change to the normal window size, we store it away.
    if (!IsIconic() && !IsZoomed())
    {
        GetWindowRect(&m_rcWindow);
    }
}

//******************************************************************************
void CMainFrame::OnDestroy()
{
    // Store our window position for our next run
    SaveWindowPosition();

    // Shutdown our profiling engine.
    if (!CDebuggerThread::IsShutdown())
    {
        // We create a modal dialog simply to block and pump. I originally planned
        // to have this dialog be a popup dialog that would display...
        // "Please wait while Dependency Walker shuts down...".  I found that the
        // dialog appeared and disappeared so fast that it was sure to cause people
        // to think "what was that?". So, the dialog is now a child dialog of the
        // mainframe, which at this point in the code has been hidden by MFC for
        // shutdown.  The result is that the dialog is still created, but is never
        // display. We still get our message pump out of the deal and our app
        // quickly shuts down.
        CDlgShutdown dlg(this);
        dlg.DoModal();
    }
    CDebuggerThread::Shutdown();

    // Tell our help to do any shutdonw stuff it may have to do.
    if (g_theApp.m_pMsdnHelp)
    {
        g_theApp.m_pMsdnHelp->Shutdown();
    }

    // Call base class.
    CMDIFrameWnd::OnDestroy();
}

//******************************************************************************
LONG CMainFrame::OnMainThreadCallback(WPARAM wParam, LPARAM lParam)
{
    // Make the call to the callback from our main thread.
    ((PFN_MAIN_THREAD_CALLBACK)wParam)(lParam);

    // Notify calling thread that the call has completed.
    SetEvent(m_evaMainThreadCallback);

    return 0;
}

//******************************************************************************
void CMainFrame::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    // Call our base class - we must do this first or we don't recognize the changes.
    CMDIFrameWnd::OnSettingChange(uFlags, lpszSection);

    // Notify our app about the setting change.
    g_theApp.DoSettingChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\mainfrm.h ===
//******************************************************************************
//
// File:        MAINFRM.H
//
// Description: Definition file for the Main Frame window
//
// Classes:     CMainFrame
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __MAINFRM_H__
#define __MAINFRM_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** Types and Structures
//******************************************************************************

typedef void (WINAPI *PFN_MAIN_THREAD_CALLBACK)(LPARAM);


//******************************************************************************
//***** CMainFrame
//******************************************************************************

class CMainFrame : public CMDIFrameWnd
{
// Internal variables
protected:
    CRect            m_rcWindow;
    CStatusBar       m_wndStatusBar;
    CToolBar         m_wndToolBar;
    CRITICAL_SECTION m_csMainThreadCallback;
    HANDLE           m_evaMainThreadCallback;

// Constructor/Destructor
public:
    CMainFrame();
    virtual ~CMainFrame();
    DECLARE_DYNAMIC(CMainFrame)

// Private functions
protected:
    void SetPreviousWindowPostion();
    void SaveWindowPosition();

// Public functions
public:
    void DisplayPopupMenu(int menu);
    void CopyTextToClipboard(LPCSTR pszText);
    void CallMeBackFromTheMainThreadPlease(PFN_MAIN_THREAD_CALLBACK pfnCallback, LPARAM lParam);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CMainFrame)
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnMove(int x, int y);
    afx_msg void OnDestroy();
    afx_msg LONG OnMainThreadCallback(WPARAM wParam, LPARAM lParam);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\modlview.h ===
//******************************************************************************
//
// File:        MODLVIEW.H
//
// Description: Definition file for the Module List View.
//
// Classes:     CListViewModules
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __MODLVIEW_H__
#define __MODLVIEW_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CListViewModules
//******************************************************************************

class CListViewModules : public CSmartListView
{
// Internal variables
protected:
    static LPCSTR ms_szColumns[];
    static int    ms_sortColumn;
    static bool   ms_fFullPaths;

    int           m_cxColumns[LVMC_COUNT];

// Constructor/Destructor (serialization only)
protected:
    CListViewModules();
    virtual ~CListViewModules();
    DECLARE_DYNCREATE(CListViewModules)

// Public static functions
public:
    static int  ReadSortColumn();
    static void WriteSortColumn(int column);
    static bool SaveToTxtFile(HANDLE hFile, CSession *pSession, int sortColumn, bool fFullPaths);
    static bool SaveToCsvFile(HANDLE hFile, CSession *pSession, int sortColumn, bool fFullPaths);

// Private static functions
protected:
    static int         GetImage(CModule *pModule);
    static int         CompareModules(CModule *pModule1, CModule *pModule2, int sortColumn, bool fFullPaths);
    static int __cdecl QSortCompare(const void *pModule1, const void *pModule2);
    static CModule**   GetSortedList(CSession *pSession, int sortColumn, bool fFullPaths);
    static CModule**   FindOriginalModules(CModule *pModule, CModule **ppModuleList);

// Public functions
public:
    void HighlightModule(CModule *pModule);
    void Refresh();
    void OnViewFullPaths();
    void DoSettingChange();
    void AddModuleTree(CModule *pModule);
    void RemoveModuleTree(CModule *pModule);
    void UpdateModule(CModule *pModule);
    void UpdateAll();
    void ChangeOriginal(CModule *pModuleOld, CModule *pModuleNew);

// Internal functions
protected:
    void  AddModules(CModule *Module, HDC hDC);
    void  CalcColumnWidth(int column, CModule *pModule = NULL, HDC hDC = NULL);
    int   GetModuleColumnWidth(HDC hDC, CModule *pModule, int column);
    void  UpdateColumnWidth(int column);
    void  OnItemChanged(HD_NOTIFY *pHDNotify);

    virtual int  CompareColumn(int item, LPCSTR pszText);
    virtual void Sort(int sortColumn = -1);
    virtual void VirtualWriteSortColumn()
    {
        WriteSortColumn(m_sortColumn);
    }

    int CompareFunc(CModule *Module1, CModule *Module2);
    static int CALLBACK StaticCompareFunc(LPARAM lp1, LPARAM lp2, LPARAM lpThis)
    {
        return ((CListViewModules*)lpThis)->CompareFunc((CModule*)lp1, (CModule*)lp2);
    }

// Overridden functions
public:
    //{{AFX_VIRTUAL(CListViewModules)
public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
//  virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
//  virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
//  virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnInitialUpdate();
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CListViewModules)
    afx_msg void OnDividerDblClick(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnRClick(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnDblClk(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnReturn(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnUpdateShowMatchingItem(CCmdUI* pCmdUI);
    afx_msg void OnShowMatchingItem();
    afx_msg void OnUpdateEditCopy(CCmdUI *pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateExternalViewer(CCmdUI *pCmdUI);
    afx_msg void OnExternalViewer();
    afx_msg void OnUpdateProperties(CCmdUI *pCmdUI);
    afx_msg void OnProperties();
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    //}}AFX_MSG
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __MODLVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\modtview.cpp ===
//******************************************************************************
//
// File:        MODTVIEW.CPP
//
// Description: Implementation file for the Module Dependency Tree View.
//
// Classes:     CTreeViewModules
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "document.h"
#include "mainfrm.h"
#include "listview.h"
#include "funcview.h"
#include "modlview.h"
#include "modtview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CTreeViewModules
//******************************************************************************

/*static*/ HANDLE   CTreeViewModules::ms_hFile              = INVALID_HANDLE_VALUE;
/*static*/ bool     CTreeViewModules::ms_fImportsExports    = false;
/*static*/ int      CTreeViewModules::ms_sortColumnImports  = -1;
/*static*/ int      CTreeViewModules::ms_sortColumnsExports = -1;
/*static*/ bool     CTreeViewModules::ms_fFullPaths         = false;
/*static*/ bool     CTreeViewModules::ms_fUndecorate        = false;
/*static*/ bool     CTreeViewModules::ms_fModuleFound       = false;
/*static*/ CModule* CTreeViewModules::ms_pModuleFind        = NULL;
/*static*/ CModule* CTreeViewModules::ms_pModulePrevNext    = NULL;

//******************************************************************************
IMPLEMENT_DYNCREATE(CTreeViewModules, CTreeView)
BEGIN_MESSAGE_MAP(CTreeViewModules, CTreeView)
    //{{AFX_MSG_MAP(CTreeViewModules)
    ON_NOTIFY_REFLECT(TVN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRClick)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblClk)
    ON_NOTIFY_REFLECT(NM_RETURN, OnReturn)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_MATCHING_ITEM, OnUpdateShowMatchingItem)
    ON_COMMAND(IDM_SHOW_MATCHING_ITEM, OnShowMatchingItem)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_ORIGINAL_MODULE, OnUpdateShowOriginalModule)
    ON_COMMAND(IDM_SHOW_ORIGINAL_MODULE, OnShowOriginalModule)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_PREVIOUS_MODULE, OnUpdateShowPreviousModule)
    ON_COMMAND(IDM_SHOW_PREVIOUS_MODULE, OnShowPreviousModule)
    ON_UPDATE_COMMAND_UI(IDM_SHOW_NEXT_MODULE, OnUpdateShowNextModule)
    ON_COMMAND(IDM_SHOW_NEXT_MODULE, OnShowNextModule)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(IDM_EXTERNAL_VIEWER, OnUpdateExternalViewer)
    ON_COMMAND(IDM_EXTERNAL_VIEWER, OnExternalViewer)
    ON_UPDATE_COMMAND_UI(IDM_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(IDM_PROPERTIES, OnProperties)
    ON_COMMAND(ID_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_PREV_PANE, OnPrevPane)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    // Standard printing commands
//  ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

//******************************************************************************
// CTreeViewModules :: Constructor/Destructor
//******************************************************************************

CTreeViewModules::CTreeViewModules() :
    m_fInOnItemExpanding(false),
    m_fIgnoreSelectionChanges(false),
    m_cRedraw(0)
{
}

//******************************************************************************
CTreeViewModules::~CTreeViewModules()
{
    GetDocument()->m_pTreeViewModules = NULL;
}


//******************************************************************************
// CTreeViewModules :: Static functions
//******************************************************************************

/*static*/ bool CTreeViewModules::SaveToTxtFile(HANDLE hFile, CSession *pSession,
    bool fImportsExports, int sortColumnImports, int sortColumnsExports, bool fFullPaths, bool fUndecorate)
{
    //                    12345678901234567890123456789012345678901234567890123456789012345678901234567890
    WriteText(hFile,     "***************************| Module Dependency Tree |***************************\r\n"
                         "*                                                                              *\r\n"
                         "* Legend: F  Forwarded Module   ?  Missing Module        6  64-bit Module      *\r\n"
                         "*         D  Delay Load Module  !  Invalid Module                              *\r\n"
                         "*         *  Dynamic Module     E  Import/Export Mismatch or Load Failure      *\r\n"
                         "*                               ^  Duplicate Module                            *\r\n");
    if (fImportsExports)
    {
        WriteText(hFile, "*                                                                              *\r\n"
                         "*         O  Ordinal Function   E  Import/Export Error   F  Forwarded Function *\r\n"
                         "*         C  C Function         R  Called At Least Once  *  Dynamic Function   *\r\n"
                         "*         +  C++ Function                                                      *\r\n");
    }
    WriteText(hFile,     "*                                                                              *\r\n"
                         "********************************************************************************\r\n\r\n");

    // Save some info statically so we don't need to pass it to our recursion...
    ms_hFile              = hFile;
    ms_fImportsExports    = fImportsExports;
    ms_sortColumnImports  = sortColumnImports;
    ms_sortColumnsExports = sortColumnsExports;
    ms_fFullPaths         = fFullPaths;
    ms_fUndecorate        = fUndecorate;

    if (!SaveAllModules(pSession->GetRootModule()))
    {
        return false;
    }

    return WriteText(hFile, "\r\n");
}

//******************************************************************************
/*static*/ BOOL CTreeViewModules::SaveAllModules(CModule *pModule)
{
    if (pModule)
    {
        if (!SaveModule(pModule))
        {
            return FALSE;
        }
        if (!SaveAllModules(pModule->GetChildModule()))
        {
            return FALSE;
        }
        if (!SaveAllModules(pModule->GetNextSiblingModule()))
        {
            return FALSE;
        }
    }
    return TRUE;
}

//******************************************************************************
/*static*/ BOOL CTreeViewModules::SaveModule(CModule *pModule)
{
    char szBuffer[DW_MAX_PATH + 1296], *psz = szBuffer, *pszNull = szBuffer + sizeof(szBuffer) - 1;
    for (int i = pModule->GetDepth(); i && (psz < (pszNull - 4)); i--) // max depth is 255
    {
        *psz++ = ' ';
        *psz++ = ' ';
        *psz++ = ' ';
        *psz++ = ' ';
        *psz++ = ' ';
    }

    DWORD dwFlags = pModule->GetFlags();

    if (psz < pszNull)
    {
        *psz++ = '[';
    }

    if (dwFlags & DWMF_FORWARDED)
    {
        if (psz < pszNull)
        {
            *psz++ = 'F';
        }
    }
    else if (dwFlags & DWMF_DELAYLOAD)
    {
        if (psz < pszNull)
        {
            *psz++ = 'D';
        }
    }
    else if (dwFlags & DWMF_DYNAMIC)
    {
        if (psz < pszNull)
        {
            *psz++ = '*';
        }
    }
    else
    {
        if (psz < pszNull)
        {
            *psz++ = ' ';
        }
    }

    if (dwFlags & DWMF_FILE_NOT_FOUND)
    {
        if (psz < pszNull)
        {
            *psz++ = '?';
        }
    }
    else if (dwFlags & DWMF_ERROR_MESSAGE)
    {
        if (psz < pszNull)
        {
            *psz++ = '!';
        }
    }
    else if (dwFlags & (DWMF_MODULE_ERROR | DWMF_WRONG_CPU))
    {
        if (psz < pszNull)
        {
            *psz++ = 'E';
        }
    }
    else if (dwFlags & DWMF_DUPLICATE)
    {
        if (psz < pszNull)
        {
            *psz++ = '^';
        }
    }
    else
    {
        if (psz < pszNull)
        {
            *psz++ = ' ';
        }
    }

    if (dwFlags & DWMF_64BIT)
    {
        if (psz < pszNull)
        {
            *psz++ = '6';
        }
    }
    else
    {
        if (psz < pszNull)
        {
            *psz++ = ' ';
        }
    }

    if (psz < pszNull)
    {
        *psz++ = ']';
    }
    if (psz < pszNull)
    {
        *psz++ = ' ';
    }

    StrCCpyFilter(psz, pModule->GetName(ms_fFullPaths, true), sizeof(szBuffer) - (int)(psz - szBuffer));
    StrCCat(psz, "\r\n", sizeof(szBuffer) - (int)(psz - szBuffer));

    BOOL fResult = WriteText(ms_hFile, szBuffer);

    // check to see if we are supposed to save the import and export lists.
    if (ms_fImportsExports)
    {
        int maxWidths[LVFC_COUNT];
        ZeroMemory(maxWidths, sizeof(maxWidths)); // inspected

        // Get the maximum column widths for this module's imports and optionally the exports.
        CListViewFunction::GetMaxFunctionWidths(pModule, maxWidths, true, pModule->IsOriginal(), ms_fUndecorate);

        WriteText(ms_hFile, "\r\n");

        // Save this module's imports to disk.
        CListViewFunction::SaveToTxtFile(ms_hFile, pModule, ms_sortColumnImports, ms_fUndecorate, false, maxWidths);

        // Save this module's exports to disk if it is an original module.
        if (pModule->IsOriginal())
        {
            CListViewFunction::SaveToTxtFile(ms_hFile, pModule, ms_sortColumnsExports, ms_fUndecorate, true, maxWidths);
        }
    }

    return fResult;
}

//******************************************************************************
/*static*/ int CTreeViewModules::GetImage(CModule *pModule)
{
    DWORD dwFlags = pModule->GetFlags();

    int image = 2;

    if (dwFlags & DWMF_FILE_NOT_FOUND)
    {
        image = 0;
    }
    else if (dwFlags & DWMF_ERROR_MESSAGE)
    {
        image = 1;
    }
    else if (dwFlags & DWMF_NO_RESOLVE)
    {
        if (dwFlags & (DWMF_MODULE_ERROR | DWMF_WRONG_CPU))
        {
            return (dwFlags & DWMF_64BIT) ? 43 : 42;
        }
        else
        {
            return (dwFlags & DWMF_64BIT) ? 41 : 40;
        }
    }
    else
    {
        if (dwFlags & DWMF_DUPLICATE)
        {
            image += 1;
        }
        if (dwFlags & (DWMF_MODULE_ERROR | DWMF_WRONG_CPU))
        {
            image += 2;
        }
        if (dwFlags & DWMF_64BIT)
        {
            image += 4;
        }
    }

    if (dwFlags & DWMF_FORWARDED)
    {
        image += 10;
    }
    else if (dwFlags & DWMF_DELAYLOAD)
    {
        image += 20;
    }
    else if (dwFlags & DWMF_DYNAMIC)
    {
        image += 30;
    }

    return image;
}


//******************************************************************************
// CTreeViewModules :: Public functions
//******************************************************************************

void CTreeViewModules::DeleteContents()
{
    // Delete everything.
    GetTreeCtrl().DeleteAllItems();
}

//******************************************************************************
void CTreeViewModules::SetRedraw(BOOL fRedraw)
{
    if (fRedraw)
    {
        if (--m_cRedraw != 0)
        {
            return;
        }
    }
    else
    {
        if (++m_cRedraw != 1)
        {
            return;
        }
    }
    SendMessage(WM_SETREDRAW, fRedraw);
}

//******************************************************************************
void CTreeViewModules::HighlightModule(CModule *pModule)
{
    // Get the tree item from the module's data.
    HTREEITEM hti = (HTREEITEM)pModule->GetUserData();
    if (hti)
    {
        // Select the item and ensure it is visible.
        GetTreeCtrl().Select(hti, TVGN_CARET);
        GetTreeCtrl().EnsureVisible(hti);

        // Give ourself the focus.
        GetParentFrame()->SetActiveView(this);
    }
}

//******************************************************************************
void CTreeViewModules::Refresh()
{
    // Disable redrawing.
    SetRedraw(FALSE);

    // Disable the processing of selction changes.
    m_fIgnoreSelectionChanges = true;

    // Call our recursive AddModules() function on the root module to build the tree.
    for (CModule *pModule = GetDocument()->GetRootModule(); pModule;
        pModule = pModule->GetNextSiblingModule())
    {
        AddModules(pModule, TVI_ROOT);
    }

    // Select the root item.
    HTREEITEM hti = GetTreeCtrl().GetRootItem();
    if (hti)
    {
        GetTreeCtrl().Select(hti, TVGN_FIRSTVISIBLE);
        GetTreeCtrl().Select(hti, TVGN_CARET);
        GetTreeCtrl().EnsureVisible(hti);
    }

    // Enable redrawing.
    SetRedraw(TRUE);

    // Enable the processing of selction changes.
    m_fIgnoreSelectionChanges = false;

    // Notify our function list views to show this module.
    GetDocument()->DisplayModule(GetDocument()->GetRootModule());
}

//******************************************************************************
void CTreeViewModules::UpdateAutoExpand(bool fAutoExpand)
{
    // If they want auto expand, then expand the entire tree.
    if (fAutoExpand)
    {
        ExpandOrCollapseAll(true);
    }

    // Otherwise collapse the entire tree, then expand the root node and all error nodes.
    else
    {
        ExpandOrCollapseAll(false);
        HTREEITEM hti = GetTreeCtrl().GetRootItem();
        if (hti)
        {
            SetRedraw(FALSE);
            GetTreeCtrl().Expand(hti, TVE_EXPAND);
            ExpandAllErrors((CModule*)GetTreeCtrl().GetItemData(hti));
            SetRedraw(TRUE);
        }
    }
}

//******************************************************************************
void CTreeViewModules::ExpandAllErrors(CModule *pModule)
{
    // Bail if we have reached the end of a subtree.
    if (!pModule)
    {
        return;
    }

    // Check to see if we have found a module with an error.
    if ((pModule->GetFlags() & (DWMF_FILE_NOT_FOUND | DWMF_ERROR_MESSAGE | DWMF_MODULE_ERROR | DWMF_WRONG_CPU | DWMF_FORMAT_NOT_PE)) &&
        pModule->GetUserData())
    {
        GetTreeCtrl().EnsureVisible((HTREEITEM)pModule->GetUserData());
    }

    // Recurse into our children.
    ExpandAllErrors(pModule->GetChildModule());

    // Recurse into our next sibling.
    ExpandAllErrors(pModule->GetNextSiblingModule());
}

//******************************************************************************
void CTreeViewModules::ExpandOrCollapseAll(bool fExpand)
{
    // Call ExpandOrCollapseAll() on all root items.
    for (HTREEITEM hti = GetTreeCtrl().GetRootItem(); hti;
        hti = GetTreeCtrl().GetNextSiblingItem(hti))
    {
        ExpandOrCollapseAll(hti, fExpand ? TVE_EXPAND : TVE_COLLAPSE);
    }

    // Since the selection can change during a collapse, we need to update our
    // functions views if we are now on a different module.
    CModule *pModule = NULL;
    if (hti = GetTreeCtrl().GetSelectedItem())
    {
        pModule = (CModule*)GetTreeCtrl().GetItemData(hti);
    }
    if (pModule != GetDocument()->m_pModuleCur)
    {
        GetDocument()->DisplayModule(pModule);
    }
}

//******************************************************************************
void CTreeViewModules::OnViewFullPaths()
{
    // Hide the window to increase drawing speed.
    SetRedraw(FALSE);

    // Call ViewFullPaths() on all root items.
    for (HTREEITEM hti = GetTreeCtrl().GetRootItem(); hti;
        hti = GetTreeCtrl().GetNextSiblingItem(hti))
    {
        ViewFullPaths(hti);
    }

    // Restore the window.
    SetRedraw(TRUE);
}

//******************************************************************************
CModule* CTreeViewModules::FindPrevNextInstance(bool fPrev)
{
    CModule   *pModuleRoot;
    HTREEITEM  hti;

    // Clear some static variables used in our recursion.
    ms_fModuleFound    = false;
    ms_pModulePrevNext = NULL;

    // Get the selected item.
    if (hti = GetTreeCtrl().GetSelectedItem())
    {
        // Get the module object for the selected item.
        if (ms_pModuleFind = (CModule*)GetTreeCtrl().GetItemData(hti))
        {
            // Get the root item.
            if (hti = GetTreeCtrl().GetRootItem())
            {
                // Get the module object for the root item.
                if (pModuleRoot = (CModule*)GetTreeCtrl().GetItemData(hti))
                {
                    // Locate the prev/next instance in the tree.
                    if (fPrev)
                    {
                        FindPrevInstance(pModuleRoot);
                    }
                    else
                    {
                        FindNextInstance(pModuleRoot);
                    }
                }
            }
        }
    }

    return ms_pModulePrevNext;
}

//******************************************************************************
bool CTreeViewModules::FindPrevInstance(CModule *pModule)
{
    // Bail if we have reached the end of a subtree.
    if (!pModule)
    {
        return false;
    }

    // Check to see if we have found a module that matches ours.
    if (pModule->GetOriginal() == ms_pModuleFind->GetOriginal())
    {
        // If we found the exact module we are looking for, then it is time to
        // bail out. If we found a previous module, then pModulePrev is pointing
        // to it. If we did not, then it will be NULL. We return true to short
        // circuit the recursion and take us to the surface.
        if (pModule == ms_pModuleFind)
        {
            return true;
        }

        // Store this module - so far, this is the previous module.
        ms_pModulePrevNext = pModule;
    }

    // Recurse into our children.
    if (FindPrevInstance(pModule->GetChildModule()))
    {
        return true;
    }

    // Recurse into our next sibling.
    return FindPrevInstance(pModule->GetNextSiblingModule());
}

//******************************************************************************
bool CTreeViewModules::FindNextInstance(CModule *pModule)
{
    // Bail if we have reached the end of a subtree.
    if (!pModule)
    {
        return false;
    }

    // Check to see if we have found a module that matches ours.
    if (pModule->GetOriginal() == ms_pModuleFind->GetOriginal())
    {
        // Check to see if we have already found the currently highlighted module.
        if (ms_fModuleFound)
        {
            // If so, then this must be the next module. We return true to short
            // circuit the recursion and take us to the surface
            ms_pModulePrevNext = pModule;
            return true;
        }

        // Otherwise, check to see if we have an exact match.
        else if (pModule == ms_pModuleFind)
        {
            // If so, then make a note that we have found the currently highlighted
            // module. The next match we find is the one we want.
            ms_fModuleFound = true;
        }
    }

    // Recurse into our children.
    if (FindNextInstance(pModule->GetChildModule()))
    {
        return true;
    }

    // Recurse into our next sibling.
    return FindNextInstance(pModule->GetNextSiblingModule());
}

//******************************************************************************
void CTreeViewModules::UpdateModule(CModule *pModule)
{
    // We only update if the image changed.
    if (pModule->GetUpdateFlags() & DWUF_TREE_IMAGE)
    {
        // Get the handle and make sure it is valid.
        HTREEITEM hti = (HTREEITEM)pModule->GetUserData();
        if (hti)
        {
            // Update the module's image.
            int image = GetImage(pModule);
            GetTreeCtrl().SetItemImage(hti, image, image);

            // If the module has an error, then we ensure it is visible by walking
            // up the tree and expanding all the parents.                         
            if (pModule->GetFlags() & (DWMF_FILE_NOT_FOUND | DWMF_ERROR_MESSAGE | DWMF_MODULE_ERROR | DWMF_WRONG_CPU | DWMF_FORMAT_NOT_PE))
            {
                HTREEITEM htiParent = hti;
                while (htiParent = GetTreeCtrl().GetParentItem(htiParent))
                {
                    GetTreeCtrl().Expand(htiParent, TVE_EXPAND);
                }
            }
        }
    }
}


//******************************************************************************
// CTreeViewModules :: Internal functions
//******************************************************************************

void CTreeViewModules::AddModules(CModule *pModule, HTREEITEM htiParent, HTREEITEM htiPrev /*=TVI_SORT*/)
{
    // Add the current module to our tree.  We preserve the order of the tree
    // instead of sorting them for two reasons.  First, there is a bug in the tree
    // control which causes our text strings to get stepped on when TVI_SORT is
    // used.  The fix for this is not until post IE 3.0.  Second, by using
    // TVI_LAST, we preserve the link order of the dependent modules which helps
    // us better match other utilities output like LINK /DUMP or DUMPBIN.

    // We initially pass in TVI_SORT, which just tells us to figure out what
    // htiPrev should really be.  After that, we pass the correct value for
    // htiPrev as we recurse into ourself.

    if (htiPrev == TVI_SORT)
    {
        htiPrev = TVI_FIRST;
        CModule *pModulePrev = NULL;

        // If we have a parent, then get our parent's first child.
        if (pModule->GetParentModule())
        {
            pModulePrev = pModule->GetParentModule()->GetChildModule();
        }

        // If we have don't have a parent, then just get the root module.
        else
        {
            pModulePrev = GetDocument()->GetRootModule();
        }

        // Walk through this list looking for our module.  We store the handle
        // to each item as we walk, so that when we find our module, we will
        // have the handle to the previous module.
        while (pModulePrev && (pModulePrev != pModule))
        {
            htiPrev = (HTREEITEM)pModulePrev->GetUserData();
            pModulePrev = pModulePrev->GetNextSiblingModule();
        }
    }

    // Make sure this item is not already in our list.
    HTREEITEM hti = (HTREEITEM)pModule->GetUserData();
    if (!hti)
    {
        int image = GetImage(pModule);

        hti = GetTreeCtrl().InsertItem(
            TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE | TVIF_PARAM,
            LPSTR_TEXTCALLBACK, image, image,
            ((htiParent == TVI_ROOT) && !(pModule->GetFlags() & DWMF_DYNAMIC)) ? TVIS_EXPANDED : 0,
            TVIS_EXPANDED, (LPARAM)pModule, htiParent, htiPrev);

        // Store this tree item in the module's user data.
        pModule->SetUserData((DWORD_PTR)hti);

        // If we are in auto-expand mode, or the module has an error, then we ensure
        // it is visible by walking up the tree and expanding all the parents.
        if (GetDocument()->m_fAutoExpand ||
            (pModule->GetFlags() & (DWMF_FILE_NOT_FOUND | DWMF_ERROR_MESSAGE | DWMF_MODULE_ERROR | DWMF_WRONG_CPU | DWMF_FORMAT_NOT_PE)))
        {
            HTREEITEM htiExpand = hti;
            while (htiExpand = GetTreeCtrl().GetParentItem(htiExpand))
            {
                GetTreeCtrl().Expand(htiExpand, TVE_EXPAND);
            }
        }
    }

    // If this is not a data file, then recurse into AddModules() for each dependent module.
    if (!(pModule->GetFlags() & DWMF_NO_RESOLVE))
    {
        htiPrev = TVI_FIRST;
        pModule = pModule->GetChildModule();
        while (pModule)
        {
            AddModules(pModule, hti, htiPrev);
            htiPrev = (HTREEITEM)pModule->GetUserData();
            pModule = pModule->GetNextSiblingModule();
        }
    }
}

//******************************************************************************
void CTreeViewModules::AddModuleTree(CModule *pModule)
{
    // Hide the window to increase drawing speed.
    SetRedraw(FALSE);

    CModule *pParent = pModule->GetParentModule();
    if (pParent)
    {
        AddModules(pModule, (HTREEITEM)pParent->GetUserData());
    }
    else
    {
        AddModules(pModule, TVI_ROOT);
    }

    // Restore the window.
    SetRedraw(TRUE);
}

//******************************************************************************
void CTreeViewModules::RemoveModuleTree(CModule *pModule)
{
    // Get the handle and make sure it is valid.
    HTREEITEM hti = (HTREEITEM)pModule->GetUserData();
    if (hti)
    {
        GetTreeCtrl().DeleteItem(hti);

        // Clear the HTREEITEMs from this module and all children.
        pModule->SetUserData(0);
        ClearUserDatas(pModule->GetChildModule());
    }
}

//******************************************************************************
void CTreeViewModules::ClearUserDatas(CModule *pModule)
{
    if (pModule)
    {
        pModule->SetUserData(0);
        ClearUserDatas(pModule->GetChildModule());
        ClearUserDatas(pModule->GetNextSiblingModule());
    }
}

//******************************************************************************
void CTreeViewModules::ExpandOrCollapseAll(HTREEITEM htiParent, UINT nCode)
{
    // Hide the window.
    SetRedraw(FALSE);

    // Recurse into our subtree, expanding or collapsing each item.
    for (HTREEITEM hti = GetTreeCtrl().GetChildItem(htiParent); hti;
        hti = GetTreeCtrl().GetNextSiblingItem(hti))
    {
        ExpandOrCollapseAll(hti, nCode);
    }

    // Expand or collapse this item.
    GetTreeCtrl().Expand(htiParent, nCode);

    // Restore the window.
    SetRedraw(TRUE);
}

//******************************************************************************
void CTreeViewModules::ViewFullPaths(HTREEITEM htiParent)
{
    // Recurse into our subtree, updated each string
    for (HTREEITEM hti = GetTreeCtrl().GetChildItem(htiParent); hti;
        hti = GetTreeCtrl().GetNextSiblingItem(hti))
    {
        ViewFullPaths(hti);
    }

    // Tell the tree control to re-evaluate the string and its width.
    GetTreeCtrl().SetItemText(htiParent, LPSTR_TEXTCALLBACK);
}


//******************************************************************************
// CTreeViewModules :: Overridden functions
//******************************************************************************

BOOL CTreeViewModules::PreCreateWindow(CREATESTRUCT &cs)
{
    // Set our window style and then complete the creation of our view.
    cs.style |= TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS |
                TVS_SHOWSELALWAYS | TVS_DISABLEDRAGDROP;
    return CTreeView::PreCreateWindow(cs);
}

//******************************************************************************
#if 0 //{{AFX
BOOL CTreeViewModules::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CTreeViewModules::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CTreeViewModules::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}
#endif //}}AFX

//******************************************************************************
void CTreeViewModules::OnInitialUpdate()
{
    // Set our tree control's image lists with our application's global image lists.
    GetTreeCtrl().SetImageList(&g_theApp.m_ilTreeModules, TVSIL_NORMAL);
}

//******************************************************************************
// CTreeViewModules :: Event handler functions
//******************************************************************************

void CTreeViewModules::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
{
    TVITEM *pTVI = &((NMTVDISPINFO*)pNMHDR)->item;

    // Display our file name or full path string based on the user's options.
    if (pTVI->hItem && pTVI->lParam)
    {
        pTVI->pszText = (LPSTR)(((CModule*)pTVI->lParam)->GetName(GetDocument()->m_fViewFullPaths, true));
    }

    *pResult = 0;
}

//******************************************************************************
void CTreeViewModules::OnSelChanged(NMHDR *pNMHDR, LRESULT *pResult)
{
    if (!m_fIgnoreSelectionChanges)
    {
        NMTREEVIEW *pNMTreeView = (NMTREEVIEW*)pNMHDR;

        CModule *pModule = (CModule*)pNMTreeView->itemNew.lParam;

        // Notify our function list views whenever the user selects a different module
        // so that they can update their views with the new module's function lists.
        GetDocument()->DisplayModule(pModule);
    }
    *pResult = 0;
}

//******************************************************************************
void CTreeViewModules::OnItemExpanding(NMHDR *pNMHDR, LRESULT *pResult)
{
    NMTREEVIEW *pNMTreeView = (NMTREEVIEW*)pNMHDR;
    *pResult = 0;

    // When a tree control normally collapses, the default behavior is to
    // maintain the state of all child items so that when expanded later,
    // the subtree will appear the same as it was before it was collapsed.  We
    // change this behavior by collapsing all children so that when the item is
    // later expanded, only the immediate children become visible.  This makes it
    // easy to quickly collapse and expand an item to filter out all modules that
    // are not immediate children of the item being toggled. To prevent recursing
    // into ourselves as a result of collapsing items pragmatically, we ignore
    // all collapse messages that are generated by us internally.

    if ((pNMTreeView->action & TVE_COLLAPSE) && !m_fInOnItemExpanding)
    {
        m_fInOnItemExpanding = true;

        // Collapse all items under the pivot item.
        ExpandOrCollapseAll(pNMTreeView->itemNew.hItem, TVE_COLLAPSE);

        // If this pivot item became selected as a result of a child item passing
        // the selection to the parent, then notify our function list views that a
        // different module is selected so that they can update their views with
        // the new module's function lists. NOTE: There is a bug in GetItemState()
        // that causes it to ignore the mask parameter so we need to test for the
        // TVIS_SELECTED bit ourselves.

        if (!(pNMTreeView->itemNew.state & TVIS_SELECTED) &&
            (GetTreeCtrl().GetItemState(pNMTreeView->itemNew.hItem, TVIS_SELECTED) & TVIS_SELECTED))
        {
            GetDocument()->DisplayModule((CModule*)pNMTreeView->itemNew.lParam);
        }

        m_fInOnItemExpanding = false;
    }
}

//******************************************************************************
void CTreeViewModules::OnRClick(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Get the mouse position in client coordinates.
    CPoint ptHit(GetMessagePos());
    ScreenToClient(&ptHit);

    // If an item was right clicked on, then select it.
    UINT uFlags = 0;
    HTREEITEM hti = GetTreeCtrl().HitTest(ptHit, &uFlags);
    if (hti)
    {
        GetTreeCtrl().Select(hti, TVGN_CARET);
        GetTreeCtrl().EnsureVisible(hti);
    }

    // Display our context menu.
    g_pMainFrame->DisplayPopupMenu(0);

    *pResult = 0;
}

//******************************************************************************
void CTreeViewModules::OnDblClk(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Get the mouse position in client coordinates.
    CPoint ptHit(GetMessagePos());
    ScreenToClient(&ptHit);

    // Do a hit test to determine where the item was double clicked on.
    UINT uFlags = 0;
    GetTreeCtrl().HitTest(ptHit, &uFlags);

    // If the mouse was clicked to the left of the item's image, then we ignore
    // this double click. We do this so the user can quickly double click the
    // +/- button to collapse and expand the item without launching the external
    // viewer.
    if ((uFlags & TVHT_ONITEMBUTTON) || (uFlags & TVHT_ONITEMINDENT))
    {
        *pResult = FALSE;
        return;
    }

    // Simulate the user selecting our IDM_EXTERNAL_VIEWER menu item.
    OnExternalViewer();

    // Stop further processing of the this message to prevent the item from
    // being expanded/collapsed.
    *pResult = TRUE;
}

//******************************************************************************
void CTreeViewModules::OnReturn(NMHDR *pNMHDR, LRESULT *pResult)
{
    // Simulate the user selecting our IDM_EXTERNAL_VIEWER menu item.
    OnExternalViewer();

    // Stop further processing of the this message to prevent the default beep.
    *pResult = TRUE;
}

//******************************************************************************
void CTreeViewModules::OnUpdateShowMatchingItem(CCmdUI* pCmdUI)
{
    // Set the menu text to match this view.
    pCmdUI->SetText("&Highlight Matching Module In List\tCtrl+M");

    // Enable this command if a module is selected in our tree.
    pCmdUI->Enable(GetTreeCtrl().GetSelectedItem() != NULL);
}

//******************************************************************************
void CTreeViewModules::OnShowMatchingItem()
{
    // Get the selected item.
    HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
    if (hti)
    {
        // Get the module object for this item.
        CModule *pModule = (CModule*)GetTreeCtrl().GetItemData(hti);
        if (pModule && pModule->GetOriginal())
        {
            // Tell our list to highlight it.
            GetDocument()->m_pListViewModules->HighlightModule(pModule->GetOriginal());
        }
    }
}

//******************************************************************************
void CTreeViewModules::OnUpdateShowOriginalModule(CCmdUI* pCmdUI)
{
    // Get the selected item.
    HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
    if (hti)
    {
        // Get the module object for the selected item.
        CModule *pModule = (CModule *)GetTreeCtrl().GetItemData(hti);

        // If the module is not an original, then enable this command.
        if (pModule && !pModule->IsOriginal())
        {
            pCmdUI->Enable(TRUE);
            return;
        }
    }

    // Otherwise, we disabled this command.
    pCmdUI->Enable(FALSE);
}

//******************************************************************************
void CTreeViewModules::OnShowOriginalModule()
{
    // Get the selected item.
    HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
    if (hti)
    {
        // Get the module object for the selected item.
        CModule *pModule = (CModule*)GetTreeCtrl().GetItemData(hti);

        // Select the original module and ensure it is visible.
        if (pModule && pModule->GetOriginal() && pModule->GetOriginal()->GetUserData())
        {
            hti = (HTREEITEM)pModule->GetOriginal()->GetUserData();
            GetTreeCtrl().Select(hti, TVGN_CARET);
            GetTreeCtrl().EnsureVisible(hti);
        }
    }
}

//******************************************************************************
void CTreeViewModules::OnUpdateShowPreviousModule(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FindPrevNextInstance(true) != NULL);
}

//******************************************************************************
void CTreeViewModules::OnShowPreviousModule()
{
    CModule   *pModule = FindPrevNextInstance(true);
    HTREEITEM  hti;

    // Check to see if we found a previous module.
    if (pModule && (hti = (HTREEITEM)pModule->GetUserData()))
    {
        // Scroll the tree so that the module's parent is visible.  We do
        // this since the user most likely wants to see who is bringing
        // in this previous instance of the module.
        GetTreeCtrl().EnsureVisible(GetTreeCtrl().GetParentItem(hti));

        // Move the selection to the new module and ensure it is visible.
        GetTreeCtrl().Select(hti, TVGN_CARET);
        GetTreeCtrl().EnsureVisible(hti);
    }

    // If anything fails, then beep.
    else
    {
        MessageBeep(0);
    }
}

//******************************************************************************
void CTreeViewModules::OnUpdateShowNextModule(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FindPrevNextInstance(false) != NULL);
}

//******************************************************************************
void CTreeViewModules::OnShowNextModule()
{
    CModule   *pModule = FindPrevNextInstance(false);
    HTREEITEM  hti;

    // Check to see if we found a previous module.
    if (pModule && (hti = (HTREEITEM)pModule->GetUserData()))
    {
        // Move the selection to the new module and ensure it is visible.
        GetTreeCtrl().Select(hti, TVGN_CARET);
        GetTreeCtrl().EnsureVisible(hti);
    }

    // If anything fails, then beep.
    else
    {
        MessageBeep(0);
    }
}

//******************************************************************************
void CTreeViewModules::OnUpdateEditCopy(CCmdUI *pCmdUI)
{
    // Set the text according to how our full path flag is set.
    pCmdUI->SetText(GetDocument()->m_fViewFullPaths ?
                    "&Copy File Path\tCtrl+C" : "&Copy File Name\tCtrl+C");

    // Enable the copy command if a module is selected in our tree.
    pCmdUI->Enable(GetTreeCtrl().GetSelectedItem() != NULL);
}

//******************************************************************************
void CTreeViewModules::OnEditCopy()
{
    // Get the selected item's CModule object.
    HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
    CModule *pModule = (CModule*)GetTreeCtrl().GetItemData(hti);

    // Copy the module's file name or path name to the clipboard.
    g_pMainFrame->CopyTextToClipboard(pModule->GetName(GetDocument()->m_fViewFullPaths, true));
}

//******************************************************************************
void CTreeViewModules::OnUpdateExternalViewer(CCmdUI *pCmdUI)
{
    // Make sure our "Enter" accelerator is part of this string.
    pCmdUI->SetText("View Module in External &Viewer\tEnter");

    // Enable our External Viewer command if a module is selected in our tree.
    pCmdUI->Enable(GetDocument()->IsLive() && (GetTreeCtrl().GetSelectedItem() != NULL));
}

//******************************************************************************
void CTreeViewModules::OnExternalViewer()
{
    if (GetDocument()->IsLive())
    {
        // Launch our selected item with our external viewer.
        HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
        CModule *pModule = (CModule*)GetTreeCtrl().GetItemData(hti);
        g_theApp.m_dlgViewer.LaunchExternalViewer(pModule->GetName(true));
    }
}

//******************************************************************************
void CTreeViewModules::OnUpdateProperties(CCmdUI *pCmdUI)
{
    // Enable our Properties Dialog command if a module is selected in our tree.
    pCmdUI->Enable(GetDocument()->IsLive() && (GetTreeCtrl().GetSelectedItem() != NULL));
}

//******************************************************************************
void CTreeViewModules::OnProperties()
{
    // Tell the shell to display a properties dialog for this module.
    HTREEITEM hti = GetTreeCtrl().GetSelectedItem();
    if (hti)
    {
        CModule *pModule = (CModule*)GetTreeCtrl().GetItemData(hti);
        if (pModule)
        {
            PropertiesDialog(pModule->GetName(true));
        }
    }
}

//******************************************************************************
void CTreeViewModules::OnNextPane()
{
    // Change the focus to our next pane, the Parent Imports View.
#if 0 //{{AFX
    GetParentFrame()->SetActiveView(GetDocument()->m_fDetailView ?
                                    (CView*)GetDocument()->m_pRichViewDetails :
                                    (CView*)GetDocument()->m_pListViewImports);
#endif //}}AFX
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewImports);
}

//******************************************************************************
void CTreeViewModules::OnPrevPane()
{
    // Change the focus to our previous pane, the Profile Edit View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pRichViewProfile);
}

//******************************************************************************
LRESULT CTreeViewModules::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    // Called when the context help pointer (SHIFT+F1) is clicked on our client.
    return (0x20000 + IDR_MODULE_TREE_VIEW);
}

//******************************************************************************
LRESULT CTreeViewModules::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    // Called when the user chooses help (F1) while our view is active.
    g_theApp.WinHelp(0x20000 + IDR_MODULE_TREE_VIEW);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\msdnhelp.h ===
//******************************************************************************
//
// File:        MSDNHELP.H
//
// Description: Definition file for all the classes related to enumerating
//              help collections and performing help lookups in the various
//              help viewers.
//
// Classes:     CMsdnHelp
//              CMsdnCollection
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 06/03/01  stevemil  Created  (version 2.1)
//
//******************************************************************************

#ifndef __MSDNHELP_H__
#define __MSDNHELP_H__


//******************************************************************************
//***** Constants and Macros
//******************************************************************************

// MSDN Collection Flags
#define MCF_2_LANG_PREFERRED 0x00000800
#define MCF_2_LANG_USER      0x00000400
#define MCF_2_LANG_SYSTEM    0x00000200
#define MCF_2_LANG_OTHER     0x00000100
#define MCF_1_LANG_PREFERRED 0x00000008
#define MCF_1_LANG_USER      0x00000004
#define MCF_1_LANG_SYSTEM    0x00000002
#define MCF_1_LANG_OTHER     0x00000001
#define MCF_1_MASK           (MCF_1_LANG_PREFERRED | MCF_1_LANG_USER | MCF_1_LANG_SYSTEM | MCF_1_LANG_OTHER)
#define MCF_2_MASK           (MCF_2_LANG_PREFERRED | MCF_2_LANG_USER | MCF_2_LANG_SYSTEM | MCF_2_LANG_OTHER)


//******************************************************************************
//***** CMsdnCollection
//******************************************************************************

class CMsdnCollection
{
public:
    CMsdnCollection *m_pNext;
    CString          m_strPath;
    CString          m_strDescription;
    DWORD            m_dwFlags;
    FILETIME         m_ftGroup;
    FILETIME         m_ftLanguage;
    FILETIME         m_ftCollection;

    CMsdnCollection(CMsdnCollection *pNext, LPCSTR pszPath, LPCSTR pszDescription, DWORD dwFlags,
                    FILETIME &ftGroup, FILETIME &ftLanguage, FILETIME &ftCollection) :
        m_pNext(pNext),
        m_strPath(pszPath),
        m_strDescription((pszDescription && *pszDescription) ? pszDescription : pszPath),
        m_dwFlags(dwFlags),
        m_ftGroup(ftGroup),
        m_ftLanguage(ftLanguage),
        m_ftCollection(ftCollection)
    {
    }
};


//******************************************************************************
//***** CMsdnHelp
//******************************************************************************

class CMsdnHelp
{
protected:
    CMsdnCollection *m_pCollectionHead;
    CMsdnCollection *m_pCollectionActive;
    CString          m_strUrl;
    bool             m_fInitialized;
    bool             m_fCoInitialized;
    DWORD_PTR        m_dwpHtmlHelpCookie;
    Help            *m_pHelp;

public:
    CMsdnHelp();
    ~CMsdnHelp();

    void             Shutdown();
    CMsdnCollection* GetCollectionList();
    CMsdnCollection* GetActiveCollection();
    CString&         GetUrl();
    LPCSTR           GetDefaultUrl(); 
    void             SetActiveCollection(CMsdnCollection *pCollectionActive);
    void             SetUrl(CString strUrl);
    void             RefreshCollectionList();
    bool             DisplayHelp(LPCSTR pszKeyword);

protected:
    void Initialize();
    void Initialize2x();
    void Release2x();
    void EnumerateCollections1x();
    void EnumerateCollections2x();
    bool Display1x(LPCSTR pszKeyword, LPCSTR pszPath);
    bool Display2x(LPCSTR pszKeyword, LPCSTR pszPath);
    bool DisplayOnline(LPCSTR pszKeyword);
    bool AddCollection(LPCSTR pszPath, LPCSTR pszDescription, DWORD dwFlags, FILETIME &ftGroup, FILETIME &ftLanguage, FILETIME &ftCollection);
    void DeleteCollectionList();
    BSTR SysAllocString(LPCSTR pszText);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __MSDNHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\modtview.h ===
//******************************************************************************
//
// File:        MODTVIEW.H
//
// Description: Definition file for the Module Dependency Tree View.
//
// Classes:     CTreeViewModules
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __MODTVIEW_H__
#define __MODTVIEW_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CTreeViewModules
//******************************************************************************

class CTreeViewModules : public CTreeView
{
// Our document needs to be able to forward some messages to us.
friend class CDocDepends;

// Internal variables
protected:
    static HANDLE   ms_hFile;
    static bool     ms_fImportsExports;
    static int      ms_sortColumnImports;
    static int      ms_sortColumnsExports;
    static bool     ms_fFullPaths;
    static bool     ms_fUndecorate;
    static bool     ms_fModuleFound;
    static CModule* ms_pModuleFind;
    static CModule* ms_pModulePrevNext;

    bool m_fInOnItemExpanding;
    bool m_fIgnoreSelectionChanges;
    int  m_cRedraw;

// Constructor/Destructor (serialization only)
protected:
    CTreeViewModules();
    virtual ~CTreeViewModules();
    DECLARE_DYNCREATE(CTreeViewModules)

// Public static functions
public:
    static bool SaveToTxtFile(HANDLE hFile, CSession *pSession, bool fImportsExports,
                              int sortColumnImports, int sortColumnExports,
                              bool fFullPaths, bool fUndecorate);

// Private static functions
protected:
    static BOOL SaveAllModules(CModule *pModule);
    static BOOL SaveModule(CModule *pModule);
    static int  GetImage(CModule *pModule);

// Public functions
public:
    void DeleteContents();
    void SetRedraw(BOOL fRedraw);
    void HighlightModule(CModule *pModule);
    void Refresh();
    void UpdateAutoExpand(bool fAutoExpand);
    void ExpandAllErrors(CModule *pModule);
    void ExpandOrCollapseAll(bool fExpand);
    void OnViewFullPaths();
    void UpdateModule(CModule *pModule);
    void AddModuleTree(CModule *pModule);
    void RemoveModuleTree(CModule *pModule);

// Internal functions
protected:
    inline CDocDepends* GetDocument() { return (CDocDepends*)m_pDocument; }

    void     AddModules(CModule *pModule, HTREEITEM htiParent, HTREEITEM htiPrev = TVI_SORT);
    void     ClearUserDatas(CModule *pModule);
    void     ExpandOrCollapseAll(HTREEITEM htiParent, UINT nCode);
    void     ViewFullPaths(HTREEITEM htiParent);
    CModule* FindPrevNextInstance(bool fPrev);
    bool     FindPrevInstance(CModule *pModule);
    bool     FindNextInstance(CModule *pModule);

// Overridden functions
public:
    //{{AFX_VIRTUAL(CTreeViewModules)
public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
//  virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
//  virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
//  virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnInitialUpdate();
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CTreeViewModules)
    afx_msg void OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnSelChanged(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnItemExpanding(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnRClick(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnDblClk(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnReturn(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnUpdateShowMatchingItem(CCmdUI* pCmdUI);
    afx_msg void OnShowMatchingItem();
    afx_msg void OnUpdateShowOriginalModule(CCmdUI* pCmdUI);
    afx_msg void OnShowOriginalModule();
    afx_msg void OnUpdateShowPreviousModule(CCmdUI* pCmdUI);
    afx_msg void OnShowPreviousModule();
    afx_msg void OnUpdateShowNextModule(CCmdUI* pCmdUI);
    afx_msg void OnShowNextModule();
    afx_msg void OnUpdateEditCopy(CCmdUI *pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateExternalViewer(CCmdUI *pCmdUI);
    afx_msg void OnExternalViewer();
    afx_msg void OnUpdateProperties(CCmdUI *pCmdUI);
    afx_msg void OnProperties();
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    //}}AFX_MSG
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __MODTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\msdnhelp.cpp ===
//******************************************************************************
//
// File:        MSDNHELP.CPP
//
// Description: Implementation file for all the classes related to enumerating
//              help collections and performing help lookups in the various
//              help viewers.
//             
// Classes:     CMsdnHelp
//              CMsdnCollection
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 06/03/01  stevemil  Created (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "msdnhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CMsdnHelp
//******************************************************************************

CMsdnHelp::CMsdnHelp() :
    m_pCollectionHead(NULL),
    m_pCollectionActive(NULL),
    m_fInitialized(false),
    m_fCoInitialized(false),
    m_dwpHtmlHelpCookie(0),
    m_pHelp(NULL)
{
}

//******************************************************************************
CMsdnHelp::~CMsdnHelp()
{
    // Free our collection list.
    DeleteCollectionList();

    // Release the help interface if we have one open - this will close DExplore.exe
    Release2x();
}

//******************************************************************************
void CMsdnHelp::Initialize()
{
    // Initialize our help interface and string functions.
    Initialize2x();

    // Free the current collection list.
    DeleteCollectionList();

    // Build the new list.
    EnumerateCollections1x();
    EnumerateCollections2x();

    // Query the collection description from the registry.
    CString strCollection = g_theApp.GetProfileString("External Help", "Collection"); // inspected

    // If it is not the online collection, then attempt to find the collection.
    if (strCollection.CompareNoCase("Online"))
    {
        // Make sure we got a string back and it was not our invalid string.
        if (!strCollection.IsEmpty())
        {
            // Look for that collection.
            for (m_pCollectionActive = m_pCollectionHead;
                 m_pCollectionActive && m_pCollectionActive->m_strDescription.Compare(strCollection);
                 m_pCollectionActive = m_pCollectionActive->m_pNext)
            {
            }
        }

        // If we did not find a match, then just use the first collection, which should
        // be the most likely collection the user wants as we try to weigh the collections
        // from most likely to least likely.  If we have no collections at all, then 
        // m_pCollectionActive will just point to NULL, which signifies that we are using
        // the online collection.
        if (!m_pCollectionActive)
        {
            m_pCollectionActive = m_pCollectionHead;
        }
    }

    // Set the URL.
    m_strUrl = g_theApp.GetProfileString("External Help", "URL", GetDefaultUrl()); // inspected

    m_fInitialized = true;
}

//******************************************************************************
void CMsdnHelp::Initialize2x()
{
    // Load OLE32.DLL and get the three functions we care about if they are not already loaded.
    if ((!g_theApp.m_hOLE32              && !(g_theApp.m_hOLE32 = LoadLibrary("OLE32.DLL"))) || // inspected. need full path?
        (!g_theApp.m_pfnCoInitialize     && !(g_theApp.m_pfnCoInitialize     = (PFN_CoInitialize)    GetProcAddress(g_theApp.m_hOLE32, "CoInitialize")))   ||
        (!g_theApp.m_pfnCoUninitialize   && !(g_theApp.m_pfnCoUninitialize   = (PFN_CoUninitialize)  GetProcAddress(g_theApp.m_hOLE32, "CoUninitialize"))) ||
        (!g_theApp.m_pfnCoCreateInstance && !(g_theApp.m_pfnCoCreateInstance = (PFN_CoCreateInstance)GetProcAddress(g_theApp.m_hOLE32, "CoCreateInstance"))))
    {
        return;
    }

    // Make sure COM is initialized.
    if (!m_fCoInitialized)
    {
        if (SUCCEEDED(g_theApp.m_pfnCoInitialize(NULL)))
        {
            m_fCoInitialized = true;
        }
    }

    // Attempt to get the help interface if we don't already have one.
    if (!m_pHelp)
    {
        if (FAILED(g_theApp.m_pfnCoCreateInstance(CLSID_DExploreAppObj, NULL, CLSCTX_LOCAL_SERVER, IID_Help, (LPVOID*)&m_pHelp)))
        {
            m_pHelp = NULL;
        }
    }

    // We need SysAllocStringLen and SysMemFree for MSDN 2.x to work.
    if (m_pHelp && !g_theApp.m_hOLEAUT32)
    {
        if (g_theApp.m_hOLEAUT32 = LoadLibrary("OLEAUT32.DLL")) // inspected. need full path?
        {
            g_theApp.m_pfnSysAllocStringLen = (PFN_SysAllocStringLen)GetProcAddress(g_theApp.m_hOLEAUT32, "SysAllocStringLen");
            g_theApp.m_pfnSysFreeString     = (PFN_SysFreeString)    GetProcAddress(g_theApp.m_hOLEAUT32, "SysFreeString");
        }
    }
}

//******************************************************************************
void CMsdnHelp::Release2x()
{
    // Release the help interface if we have one open - this will close DExplore.exe
    if (m_pHelp)
    {
        // Wrap access to m_pHelp in exception handling just in case.
        __try
        {
            m_pHelp->Release();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
        m_pHelp = NULL;
    }
    
    // If we initialized COM, then uninitialize it.
    if (m_fCoInitialized && g_theApp.m_pfnCoUninitialize)
    {
        g_theApp.m_pfnCoUninitialize();
        m_fCoInitialized = false;
    }
}

//******************************************************************************
void CMsdnHelp::Shutdown()
{
    // We have to uninitialize the MsdnHelp library if we initialized it.
    if (m_dwpHtmlHelpCookie)
    {
        HtmlHelp(NULL, NULL, HH_CLOSE_ALL, 0);
        HtmlHelp(NULL, NULL, HH_UNINITIALIZE, m_dwpHtmlHelpCookie);
        m_dwpHtmlHelpCookie = 0;
    }
}

//******************************************************************************
CMsdnCollection* CMsdnHelp::GetCollectionList()
{
    // Make sure we are initialized.
    if (!m_fInitialized)
    {
        Initialize();
    }

    return m_pCollectionHead;
}

//******************************************************************************
CMsdnCollection* CMsdnHelp::GetActiveCollection()
{
    // Make sure we are initialized.
    if (!m_fInitialized)
    {
        Initialize();
    }

    return m_pCollectionActive;
}

//******************************************************************************
CString& CMsdnHelp::GetUrl()
{
    // Make sure we are initialized.
    if (!m_fInitialized)
    {
        Initialize();
    }

    return m_strUrl;
}

//******************************************************************************
LPCSTR CMsdnHelp::GetDefaultUrl()
{
    // Site ID:                 siteid=us/dev
    //
    // New Search:              nq=NEW
    //
    // Sort Order: Relevance:   so=RECCNT  (default)
    //             Title:       so=TITLE
    //             Category:    so=SITENAME
    //
    // Type: Exact Phrase:      boolean=PHRASE
    //       All Words:         boolean=ALL
    //       Any Words:         boolean=ANY
    //       Boolean Search:    boolean=BOOLEAN
    //
    // Group: MSDN Library:     ig=01
    //
    // Subitem: User Interface: i=15
    //          Visual C++:     i=23
    //          Windows:        i=41
    //          All of MSDN     i=99
    //
    // Search String:           qu=SearchString
    //

    return "http://search.microsoft.com/default.asp?siteid=us/dev&nq=NEW&boolean=PHRASE&ig=01&i=99&qu=%1";
}

//******************************************************************************
void CMsdnHelp::SetActiveCollection(CMsdnCollection *pCollectionActive)
{
    // Set the new collection as the default.
    m_pCollectionActive = pCollectionActive;

    // Save this setting to the registry.
    g_theApp.WriteProfileString("External Help", "Collection",
        m_pCollectionActive ? m_pCollectionActive->m_strDescription : "Online");

}

//******************************************************************************
void CMsdnHelp::SetUrl(CString strUrl)
{
    // Set the new URL.
    m_strUrl = strUrl;

    // Save this setting to the registry.
    g_theApp.WriteProfileString("External Help", "URL", m_strUrl);
}

//******************************************************************************
void CMsdnHelp::RefreshCollectionList()
{
    // Reinitialize will repopulate the collection list.
    Initialize();
}

//******************************************************************************
bool CMsdnHelp::DisplayHelp(LPCSTR pszKeyword)
{
    // Make sure we are initialized.
    if (!m_fInitialized)
    {
        Initialize();
    }

    // Check to see if we have an active collection.
    if (m_pCollectionActive)
    {
        // If it is a 1.x collection, then use the 1.x viewer.
        if (m_pCollectionActive->m_dwFlags & MCF_1_MASK)
        {
            return Display1x(pszKeyword, m_pCollectionActive->m_strPath);
        }

        // If it is a 2.x collection, then use the 2.x viewer.
        else
        {
            return Display2x(pszKeyword, m_pCollectionActive->m_strPath);
        }
    }

    // Otherwise, just use the online MSDN.
    return DisplayOnline(pszKeyword);
}

//******************************************************************************
void CMsdnHelp::EnumerateCollections1x()
{
    // HKEY_LOCAL_MACHINE\
    //     SOFTWARE\
    //       Microsoft\
    //           HTML Help Collections\
    //               Developer Collections\
    //                   Language="0x0409"
    //                   0x0409\
    //                       Preferred="0x03a1bed80"
    //                       0x0393bb260\
    //                           Default="MSDN Library - July 2000"
    //                           Filename="C:\VStudio\MSDN\2000JUL\1033\MSDN020.COL"
    //                       0x03a1bed80\
    //                           Default="MSDN Library - January 2001"
    //                           Filename="C:\VStudio\MSDN\2001JAN\1033\MSDN100.COL"
    //               CE Studio Developer Collections\
    //                   0x0409\
    //                       Preferred="0x030000000"
    //                       0x030000000\
    //                           Filename="C:\CETools\Htmlhelp\emtools\embed.col"

    // Open the root key for the "HTML Help Collections"
    HKEY hKeyRoot = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\HTML Help Collections", 0, KEY_ENUMERATE_SUB_KEYS, &hKeyRoot) || !hKeyRoot)
    {
        // Bail immediately if we cannot find this root key.
        return;
    }

    HKEY     hKeyGroup = NULL, hKeyLang = NULL, hKeyCol = NULL;
    CHAR     szBuffer[2048], szPreferred[256], szDescription[256];
    DWORD    dwSize, dwLangCur, dwLangPreferred, dwFlags;
    FILETIME ftGroup, ftLang, ftCol;

    // Get the user and system languages.
    DWORD dwLangUser   = GetUserDefaultLangID();
    DWORD dwLangSystem = GetSystemDefaultLangID();

    // Loop through each collection group.
    for (DWORD dwGroup = 0; !RegEnumKeyEx(hKeyRoot, dwGroup, szBuffer, &(dwSize = sizeof(szBuffer)), NULL, NULL, NULL, &ftGroup); dwGroup++)
    {
        // Open this collection group.
        if (!RegOpenKeyEx(hKeyRoot, szBuffer, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hKeyGroup) && hKeyGroup)
        {
            // If this is "Developer Collections", then we fake the timestamp so it comes first.
            if (!_stricmp(szBuffer, "Developer Collections"))
            {
                ftGroup.dwHighDateTime = ftGroup.dwLowDateTime = 0xFFFFFFFF;
            }

            // Attempt to get the preferred langauge.
            if (!RegQueryValueEx(hKeyGroup, "Language", NULL, NULL, (LPBYTE)szBuffer, &(dwSize = sizeof(szBuffer)))) // inspected
            {
                szBuffer[sizeof(szBuffer) - 1] = '\0';
                dwLangPreferred = strtoul(szBuffer, NULL, 0);
            }
            else
            {
                dwLangPreferred = 0;
            }

            // Loop through each language in this collection group.
            for (DWORD dwLang = 0; !RegEnumKeyEx(hKeyGroup, dwLang, szBuffer, &(dwSize = sizeof(szBuffer)), NULL, NULL, NULL, &ftLang); dwLang++)
            {
                //!! Do we really want PREFERRED to come before anything else?

                // Check to see if this is a language that we care about.
                dwLangCur = strtoul(szBuffer, NULL, 0);
                dwFlags   = (dwLangCur == dwLangPreferred) ? MCF_1_LANG_PREFERRED :
                            (dwLangCur == dwLangUser)      ? MCF_1_LANG_USER      :
                            (dwLangCur == dwLangSystem)    ? MCF_1_LANG_SYSTEM    : MCF_1_LANG_OTHER;

                // Open this language key.
                if (!RegOpenKeyEx(hKeyGroup, szBuffer, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hKeyLang) && hKeyLang)
                {
                    // Attempt to get the preferred collection.
                    if (!RegQueryValueEx(hKeyLang, "Preferred", NULL, NULL, (LPBYTE)szPreferred, &(dwSize = sizeof(szPreferred)))) // inspected
                    {
                        szPreferred[sizeof(szPreferred) - 1] = '\0';
                    }
                    else
                    {
                        *szPreferred = '\0';
                    }

                    // Loop through each collection for this language.
                    for (DWORD dwCol = 0; !RegEnumKeyEx(hKeyLang, dwCol, szBuffer, &(dwSize = sizeof(szBuffer)), NULL, NULL, NULL, &ftCol); dwCol++)
                    {
                        // Open this collection.
                        if (!RegOpenKeyEx(hKeyLang, szBuffer, 0, KEY_QUERY_VALUE, &hKeyCol) && hKeyCol)
                        {
                            // If this is the preferred collection, then we fake the timestamp so it comes first.
                            if (!_stricmp(szBuffer, szPreferred))
                            {
                                ftCol.dwHighDateTime = ftCol.dwLowDateTime = 0xFFFFFFFF;
                            }

                            // Attempt to get the collection path.
                            if (!RegQueryValueEx(hKeyCol, "Filename", NULL, NULL, (LPBYTE)szBuffer, &(dwSize = sizeof(szBuffer)))) // inspected
                            {
                                szBuffer[sizeof(szBuffer) - 1] = '\0';

                                // Attempt to get the collection description.
                                if (!RegQueryValueEx(hKeyCol, NULL, NULL, NULL, (LPBYTE)szDescription, &(dwSize = sizeof(szDescription)))) // inspected
                                {
                                    szDescription[sizeof(szDescription) - 1] = '\0';
                                }
                                else
                                {
                                    *szDescription = '\0';
                                }

                                // All that work for this one call.
                                AddCollection(szBuffer, szDescription, dwFlags, ftGroup, ftLang, ftCol);
                            }
                            RegCloseKey(hKeyCol);
                            hKeyCol = NULL;
                        }
                    }
                    RegCloseKey(hKeyLang);
                    hKeyLang = NULL;
                }
            }
            RegCloseKey(hKeyGroup);
            hKeyGroup = NULL;
        }
    }
    RegCloseKey(hKeyRoot);
    hKeyRoot = NULL;
}

//******************************************************************************
void CMsdnHelp::EnumerateCollections2x()
{
    // HKEY_LOCAL_MACHINE\
    //     SOFTWARE\
    //         Microsoft\
    //             MSDN\
    //                 7.0\
    //                     Help\
    //                         ms-help://ms.msdnvs="(no filter)"
    //                         ms-help://ms.vscc="(no filter)"
    //                         0x0409\
    //                             {12380850-3413-4466-A07D-4FE8CA8720E1}\
    //                                 default="MSDN Library - Visual Studio.NET Beta"                                
    //                                 Filename="ms-help://ms.msdnvs"
    //                             {2042FFE0-48B0-477b-903E-389A19903EA4}\
    //                                 default="Visual Studio.NET Combined Help Collection"
    //                                 Filename="ms-help://ms.vscc"

    // Make sure we have a help interface pointer and string functions.
    if (!m_pHelp || !g_theApp.m_pfnSysAllocStringLen || !g_theApp.m_pfnSysFreeString)
    {
        return;
    }

    // Open the root key for the MSDN 7.0 collections.
    HKEY hKeyRoot = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\MSDN\\7.0\\Help", 0, KEY_ENUMERATE_SUB_KEYS, &hKeyRoot) || !hKeyRoot)
    {
        // Bail immediately if we cannot find this root key.
        return;
    }

    bool     fFound = false;
    HKEY     hKeyLang = NULL, hKeyCol = NULL;
    CHAR     szBuffer[2048], szDescription[256];
    DWORD    dwSize, dwLangCur, dwFlags;
    FILETIME ftMax = { 0xFFFFFFFF, 0xFFFFFFFF }, ftLang, ftCol;

    // Get the user and system languages.
    DWORD dwLangUser   = GetUserDefaultLangID();
    DWORD dwLangSystem = GetSystemDefaultLangID();

    // Loop through each language in this collection group.
    for (DWORD dwLang = 0; !RegEnumKeyEx(hKeyRoot, dwLang, szBuffer, &(dwSize = sizeof(szBuffer)), NULL, NULL, NULL, &ftLang); dwLang++)
    {
        // Check to see if this is a language that we care about.
        dwLangCur = strtoul(szBuffer, NULL, 0);
        dwFlags   = (dwLangCur == dwLangUser)   ? MCF_2_LANG_USER   :
                    (dwLangCur == dwLangSystem) ? MCF_2_LANG_SYSTEM : MCF_2_LANG_OTHER;

        // Open this language key.
        if (!RegOpenKeyEx(hKeyRoot, szBuffer, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hKeyLang) && hKeyLang)
        {
            // Loop through each collection for this language.
            for (DWORD dwCol = 0; !RegEnumKeyEx(hKeyLang, dwCol, szBuffer, &(dwSize = sizeof(szBuffer)), NULL, NULL, NULL, &ftCol); dwCol++)
            {
                // Open this collection.
                if (!RegOpenKeyEx(hKeyLang, szBuffer, 0, KEY_QUERY_VALUE, &hKeyCol) && hKeyCol)
                {
                    // Attempt to get the collection path.
                    if (!RegQueryValueEx(hKeyCol, "Filename", NULL, NULL, (LPBYTE)szBuffer, &(dwSize = sizeof(szBuffer)))) // inspected
                    {
                        szBuffer[sizeof(szBuffer) - 1] = '\0';

                        // Attempt to get the collection description.
                        if (!RegQueryValueEx(hKeyCol, NULL, NULL, NULL, (LPBYTE)szDescription, &(dwSize = sizeof(szDescription)))) // inspected
                        {
                            szDescription[sizeof(szDescription) - 1] = '\0';
                        }
                        else
                        {
                            *szDescription = '\0';
                        }

                        // All that work for this one call.
                        AddCollection(szBuffer, szDescription, dwFlags, ftMax, ftLang, ftCol);
                        fFound = true;
                    }
                    RegCloseKey(hKeyCol);
                    hKeyCol = NULL;
                }
            }
            RegCloseKey(hKeyLang);
            hKeyLang = NULL;
        }
    }
    RegCloseKey(hKeyRoot);
    hKeyRoot = NULL;

    // If we found at least one collection, then add the default collection.
    if (fFound)
    {
        AddCollection(NULL, "Default Collection", MCF_2_LANG_PREFERRED, ftMax, ftMax, ftMax);
    }
}

//******************************************************************************
bool CMsdnHelp::Display1x(LPCSTR pszKeyword, LPCSTR pszPath)
{
    // Initialize the MsdnHelp library if we haven't done so already.  If we
    // don't do this, then depends.exe may hang during shutdown.  I mostly
    // saw this behavior on Windows XP.
    if (!m_dwpHtmlHelpCookie)
    {
        HtmlHelp(NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&m_dwpHtmlHelpCookie);
    }

    // Build our search request.
    HH_AKLINK hhaklink;
    ZeroMemory(&hhaklink, sizeof(hhaklink)); // inspected
    hhaklink.cbStruct     = sizeof(hhaklink);
    hhaklink.pszKeywords  = pszKeyword;
    hhaklink.fIndexOnFail = TRUE;

    // HH_DISPLAY_TOPIC brings up the help window.  HH_KEYWORD_LOOKUP looks up
    // the keyword and displays a dialog if there is a conflict.  I like the
    // behavior of HH_KEYWORD_LOOKUP by itself as it does not bring up the main
    // help window if the user presses cancel in the conflict dialog, but the
    // docs say you must call HtmlHelp with HH_DISPLAY_TOPIC before it it is
    // called with HH_KEYWORD_LOOKUP.  I'm finding this to not be true, but maybe
    // it is neccessary in earlier versions of HtmlHelp.  Visual C++ seems to
    // always display the help window then the conflict dialog, so they must be
    // using both HH_DISPLAY_TOPIC and HH_KEYWORD_LOOKUP.

    HWND hWnd = GetDesktopWindow();
    HtmlHelp(hWnd, pszPath, HH_DISPLAY_TOPIC, 0);
    return (HtmlHelp(hWnd, pszPath, HH_KEYWORD_LOOKUP, (DWORD_PTR)&hhaklink) != NULL);
}

//******************************************************************************
bool CMsdnHelp::Display2x(LPCSTR pszKeyword, LPCSTR pszPath)
{
    // If we don't have a help interface, then go get one.  The only time this
    // should really happen is when we had a help interface, but it died with a
    // RPC_S_SERVER_UNAVAILABLE error during a previous lookup.
    if (!m_pHelp)
    {
        Initialize2x();
    }

    // Make sure we have a help interface pointer and string functions.
    if (!m_pHelp || !g_theApp.m_pfnSysAllocStringLen || !g_theApp.m_pfnSysFreeString)
    {
        return false;
    }

    BSTR bstrKeyword = SysAllocString(pszKeyword);
    if (bstrKeyword)
    {
        HRESULT hr;
        BSTR bstrCollection = NULL, bstrFilter = NULL;

        // Wrap access to m_pHelp in exception handling just in case.
        __try
        {
            // If a collection was passed to us, then use it to initialize DExplore.
            if (*pszPath)
            {
                bstrCollection = SysAllocString(pszPath);
                bstrFilter     = SysAllocString("");
                m_pHelp->SetCollection(bstrCollection, bstrFilter);
            }

            // If no collection was passed to us, then we attempt to get the current
            // collection and filter, and then set the collection and filter back into
            // DExplore.  We need to do this to force DExplore to load the default page
            // for this collection.
            else if (SUCCEEDED(m_pHelp->get_Collection(&bstrCollection)) && bstrCollection &&
                     SUCCEEDED(m_pHelp->get_Filter(&bstrFilter))         && bstrFilter)
            {
                m_pHelp->SetCollection(bstrCollection, bstrFilter);
            }

            // Query the keyword and display DExplore.exe
            // There is also a DisplayTopicFromF1Keyword function.
            // The difference is that if the F1 version cannot find the
            // keyword, it will briefly display DExplore, then hide it
            // and return failure.  The non F1 version, will always
            // display DExplore and the index, even if it can't find
            // the keyword.
            hr = m_pHelp->DisplayTopicFromKeyword(bstrKeyword);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_POINTER;
        }

        // Free the strings if we allocated them.
        g_theApp.m_pfnSysFreeString(bstrKeyword);
        g_theApp.m_pfnSysFreeString(bstrCollection);
        g_theApp.m_pfnSysFreeString(bstrFilter);

        // If DExplore.exe crashes for some reason (seems to happen all the
        // time for me when running VS 9219 on XP Beta 2) we will get a 
        // RPC_S_SERVER_UNAVAILABLE error.  If we ever want help to work
        // again, we need to release our help interface so that next time through
        // this function, we will get a fresh pointer and a new instance of
        // DExplore.exe.
        if ((HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) || (E_POINTER == hr))
        {
            Release2x();
        }

        return SUCCEEDED(hr);
    }

    return false;
}

//******************************************************************************
bool CMsdnHelp::DisplayOnline(LPCSTR pszKeyword)
{
    // Build a URL to the MSDN search engine by replacing all %1's in our URL with the keyword
    CString strUrl = m_strUrl;
    strUrl.Replace("%1", pszKeyword);

    // Launch the URL.
    return ((DWORD_PTR)ShellExecute(NULL, "open", strUrl, NULL, NULL, SW_SHOWNORMAL) > 32); // inspected. opens URL
}

//******************************************************************************
bool CMsdnHelp::AddCollection(LPCSTR pszPath, LPCSTR pszDescription, DWORD dwFlags, FILETIME &ftGroup, FILETIME &ftLanguage, FILETIME &ftCollection)
{
    int compare;
    for (CMsdnCollection *pPrev = NULL, *pCur = m_pCollectionHead; pCur; pPrev = pCur, pCur = pCur->m_pNext)
    {
        // First level of sort order if the flags.  Higher values float to the top.
        if (dwFlags > pCur->m_dwFlags)
        {
            break;
        }
        if (dwFlags < pCur->m_dwFlags)
        {
            continue;
        }

        // Next level of sort order is the group timestamp.
        if ((compare = CompareFileTime(&ftGroup, &pCur->m_ftGroup)) > 0)
        {
            break;
        }
        if (compare < 0)
        {
            continue;
        }

        // Next level of sort order is the language timestamp.
        if ((compare = CompareFileTime(&ftLanguage, &pCur->m_ftLanguage)) > 0)
        {
            break;
        }
        if (compare < 0)
        {
            continue;
        }

        // Next level of sort order is the collection timestamp.
        if (CompareFileTime(&ftCollection, &pCur->m_ftCollection) > 0)
        {
            break;
        }
    }

    // Create the new node.
    if (!(pCur = new CMsdnCollection(pCur, pszPath, pszDescription, dwFlags, ftGroup, ftLanguage, ftCollection)))
    {
        return false;
    }

    // Insert the node into our list.
    if (pPrev)
    {
        pPrev->m_pNext = pCur;
    }
    else
    {
        m_pCollectionHead = pCur;
    }

    return true;
}

//******************************************************************************
void CMsdnHelp::DeleteCollectionList()
{
    // Delete our collection list.
    while (m_pCollectionHead)
    {
        CMsdnCollection *pNext = m_pCollectionHead->m_pNext;
        delete m_pCollectionHead;
        m_pCollectionHead = pNext;
    }
    m_pCollectionActive = NULL;
}

//******************************************************************************
BSTR CMsdnHelp::SysAllocString(LPCSTR pszText)
{
    if (g_theApp.m_pfnSysAllocStringLen)
    {
        DWORD dwLength = MultiByteToWideChar(CP_ACP, 0, pszText, -1, NULL, NULL); // inspected
        BSTR bstr = g_theApp.m_pfnSysAllocStringLen(NULL, dwLength);
        if (bstr)
        {
            MultiByteToWideChar(CP_ACP, 0, pszText, -1, bstr, dwLength); // inspected
            return bstr;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\search.cpp ===
//******************************************************************************
//
// File:        SEARCH.CPP
//
// Description: Implementation file for the CSearchNode and CSearchGroup classes.
//
// Classes:     CSearchNode
//              CSearchGroup
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "search.h"
#include "dbgthread.h"
#include "session.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//****** CSearchNode
//******************************************************************************

DWORD CSearchNode::UpdateErrorFlag()
{
    // We don't allow updating of flags for nodes loaded from DWI files.
    if (!(m_wFlags & SNF_DWI))
    {
        // Locate the file or directory.
        DWORD dwAttribs = GetFileAttributes(m_szPath);

        // Make sure the item exists and is what it is supposed to be (file or dir).
        if ((dwAttribs == 0xFFFFFFFF) ||
            (((m_wFlags & SNF_FILE) != 0) == ((dwAttribs & FILE_ATTRIBUTE_DIRECTORY) != 0)))
        {
            // Set the error flag.
            m_wFlags |= SNF_ERROR;
        }
        else
        {
            // Clear the error flag.
            m_wFlags &= ~SNF_ERROR;
        }
    }

    return (DWORD)m_wFlags;
}

//******************************************************************************
//****** CSearchGroup : Static Data
//******************************************************************************

/*static*/ LPCSTR CSearchGroup::ms_szGroups[SG_COUNT] =
{
    "A user defined directory",
    "Side-by-Side Components (Windows XP only)",
    "The system's \"KnownDLLs\" list",
    "The application directory",
//  "The starting directory",
    "The 32-bit system directory",
    "The 16-bit system directory (Windows NT/2000/XP only)",
    "The system's root OS directory",
    "The application's registered \"App Paths\" directories",
    "The system's \"PATH\" environment variable directories",
};

/*static*/ LPCSTR CSearchGroup::ms_szShortNames[SG_COUNT] =
{
    "UserDir",
    "SxS",
    "KnownDLLs",
    "AppDir",
    "32BitSysDir",
    "16BitSysDir",
    "OSDir",
    "AppPath",
    "SysPath",
};


//******************************************************************************
//****** CSearchGroup : Static Functions
//******************************************************************************

/*static*/ CSearchGroup* CSearchGroup::CreateDefaultSearchOrder(LPCSTR pszApp /*=NULL*/)
{
    CSearchGroup *pHead = NULL;

    // Create our default list.
    for (int type = SG_COUNT - 1; type > 0; type--)
    {
        // If this is the side-by-side group, but the OS does not support, then skip it.
        // If this is the 16-bit system dir and we are not on NT, then skip it.
        if (((type == SG_SIDE_BY_SIDE)  && !g_theApp.m_pfnCreateActCtxA) ||
            ((type == SG_16BIT_SYS_DIR) && !g_fWindowsNT))
        {
            continue;
        }

        // Create the node, insert it into our list, and check for errors.
        if (!(pHead = new CSearchGroup((SEARCH_GROUP_TYPE)type, pHead, pszApp)))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
    }
    return pHead;
}

//******************************************************************************
/*static*/ CSearchGroup* CSearchGroup::CopySearchOrder(CSearchGroup *psgHead, LPCSTR pszApp /*=NULL*/)
{
    // Loop through each node in the original list.
    for (CSearchGroup *psgCopyHead = NULL, *psgNew, *psgLast = NULL;
        psgHead; psgHead = psgHead->GetNext())
    {
        // Create a copy of the current node.
        if (!(psgNew = new CSearchGroup(psgHead->GetType(), NULL, pszApp,
                                        ((psgHead->GetType() == SG_USER_DIR) && psgHead->GetFirstNode()) ?
                                        psgHead->GetFirstNode()->GetPath() : NULL)))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // Add this node to the end of our new list.
        if (psgLast)
        {
            psgLast->m_pNext = psgNew;
        }
        else
        {
            psgCopyHead = psgNew;
        }
        psgLast = psgNew;
    }

    // Return the head of the new list.
    return psgCopyHead;
}

//******************************************************************************
/*static*/ bool CSearchGroup::SaveSearchOrder(LPCSTR pszPath, CTreeCtrl *ptc)
{
    HANDLE hFile    = INVALID_HANDLE_VALUE;
    bool   fSuccess = false;
    CHAR   szBuffer[DW_MAX_PATH + 64];

    __try
    {
        // Open the file for write.
        hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, // inspected - always uses full path
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        // Check for any errors.
        if (hFile == INVALID_HANDLE_VALUE)
        {
            __leave;
        }

        // Loop through all the items in our current list.
        for (HTREEITEM hti = ptc->GetRootItem(); hti; hti = ptc->GetNextSiblingItem(hti))
        {
            // Get the group node associated with this item.
            CSearchGroup *psg = (CSearchGroup*)ptc->GetItemData(hti);

            if (psg)
            {
                if ((psg->GetType() == SG_USER_DIR) && psg->GetFirstNode())
                {
                    SCPrintf(szBuffer, sizeof(szBuffer), "%s ", psg->GetShortName());
                    if (!WriteBlock(hFile, szBuffer)                       ||
                        !WriteBlock(hFile, psg->GetFirstNode()->GetPath()) ||
                        !WriteBlock(hFile, "\r\n"))
                    {
                        __leave;
                    }
                }
                else
                {
                    SCPrintf(szBuffer, sizeof(szBuffer), "%s\r\n", psg->GetShortName());
                    if (!WriteBlock(hFile, szBuffer) != FALSE)
                    {
                        __leave;
                    }
                }
            }
        }

        // Mark ourself as success.
        fSuccess = true;
    }
    __finally
    {
        // Display an error if we encountered one.
        if (!fSuccess)
        {
            if (INVALID_HANDLE_VALUE == hFile)
            {
                SCPrintf(szBuffer, sizeof(szBuffer), "Error creating \"%s\".", pszPath);
            }
            else
            {
                SCPrintf(szBuffer, sizeof(szBuffer), "Error writing to \"%s\".", pszPath);
            }
            LPCSTR pszError = BuildErrorMessage(GetLastError(), szBuffer);
            AfxMessageBox(pszError, MB_OK | MB_ICONERROR);
            MemFree((LPVOID&)pszError);
        }

        // Close the file.
        if (INVALID_HANDLE_VALUE != hFile)
        {
            CloseHandle(hFile);
        }
    }

    return fSuccess;
}

//******************************************************************************
/*static*/ bool CSearchGroup::LoadSearchOrder(LPCSTR pszPath, CSearchGroup* &psgHead, LPCSTR pszApp /*=NULL*/)
{
    psgHead = NULL;

    CHAR szBuffer[DW_MAX_PATH + 64];
    FILE_MAP fm;

    // Open and map this file for read.
    if (!OpenMappedFile(pszPath, &fm))
    {
        SCPrintf(szBuffer, sizeof(szBuffer), "Error opening \"%s\".", pszPath);
        LPCSTR pszError = BuildErrorMessage(GetLastError(), szBuffer);
        AfxMessageBox(pszError, MB_OK | MB_ICONERROR);
        MemFree((LPVOID&)pszError);
        return false;
    }

    CSearchGroup *psgNew = NULL, *psgLast = NULL;
    CHAR         *pcBuffer;
    LPCSTR        pcBufferEnd = (LPCSTR)((DWORD_PTR)szBuffer + sizeof(szBuffer));
    LPCSTR        pcFile      = (LPCSTR)fm.lpvFile;
    LPCSTR        pcFileEnd   = (LPCSTR)((DWORD_PTR)fm.lpvFile + (DWORD_PTR)fm.dwSize);
    int           line = 1, userDirLength = (int)strlen(CSearchGroup::GetShortName(SG_USER_DIR));
    bool          fSuccess = false;
    bool          fFound[SG_COUNT];

    ZeroMemory(fFound, sizeof(fFound)); // inspected

    while (pcFile < pcFileEnd)
    {
        // Walk over whitespace, newlines, etc., until we reach a non-whitespace char.
        while ((pcFile < pcFileEnd) && isspace(*pcFile))
        {
            if (*pcFile == '\n')
            {
                line++;
            }
            pcFile++;
        }

        // Copy the line to our buffer.
        for (pcBuffer = szBuffer;
            (pcFile < pcFileEnd) && (pcBuffer < (pcBufferEnd - 1)) && (*pcFile != '\r') && (*pcFile != '\n');
            *(pcBuffer++) = *(pcFile++))
        {
        }
        *(pcBuffer--) = '\0';

        // Walk backwards, removing any whitespace.
        while ((pcBuffer >= szBuffer) && isspace(*pcBuffer))
        {
            *(pcBuffer--) = '\0';
        }

        // We skip blank lines and lines that start with '/', '#', ':', and ';' ''' since
        // these are commonly used to represent a comment.
        if (!*szBuffer || (*szBuffer == '/') || (*szBuffer == '#') || (*szBuffer == ':') || (*szBuffer == ';') || (*szBuffer == '\''))
        {
            continue;
        }

        // Check to see if this is a UserDir. UserDir requires one or more spaces after it
        // and a path. We also allow for a comma since this used to be used in many betas.
        if (!_strnicmp(szBuffer, CSearchGroup::GetShortName(SG_USER_DIR), userDirLength) &&
            (isspace(szBuffer[userDirLength]) || (szBuffer[userDirLength] == ',')))
        {
            // Locate beginning of path string.
            for (pcBuffer = szBuffer + userDirLength + 1; isspace(*pcBuffer); pcBuffer++)
            {
            }

            // Make sure the user specified a path.
            if (!*pcBuffer)
            {
                goto FINALLY;
            }

            // We allow environment variables in DWP files, so expand the path if necessary.
            CHAR szExpanded[DW_MAX_PATH];
            if (ExpandEnvironmentStrings(pcBuffer, szExpanded, sizeof(szExpanded)))
            {
                psgNew = new CSearchGroup(SG_USER_DIR, NULL, pszApp, szExpanded);
            }
            else
            {
                psgNew = new CSearchGroup(SG_USER_DIR, NULL, pszApp, pcBuffer);
            }

            // Make sure we allocated a node.
            if (!psgNew)
            {
                RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
            }
        }
        else
        {
            // Loop through each known type.
            for (int i = 1; i < SG_COUNT; i++)
            {
                // Do a string compare to see if we have a match.
                if (!_stricmp(szBuffer, CSearchGroup::GetShortName((SEARCH_GROUP_TYPE)i)))
                {
                    // We don't allow duplicate groups, other than user dirs.
                    if (fFound[i])
                    {
                        goto FINALLY;
                    }
                    else
                    {
                        if (!(psgNew = new CSearchGroup((SEARCH_GROUP_TYPE)i, NULL, pszApp)))
                        {
                            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
                        }
                        fFound[i] = true;
                        break;
                    }
                }
            }

            // Bail if we did not find a match.
            if (i >= SG_COUNT)
            {
                goto FINALLY;
            }
        }

        // Add the node to our list.
        if (psgLast)
        {
            psgLast->m_pNext = psgNew;
        }
        else
        {
            psgHead = psgNew;
        }
        psgLast = psgNew;
    }

    // Mark ourself as success.
    fSuccess = true;

FINALLY:
    // Build a complete error message if we encountered an error.
    if (!fSuccess)
    {
        SCPrintf(szBuffer, sizeof(szBuffer), "Error found in \"%s\" at line %u.", pszPath, line);
        AfxMessageBox(szBuffer, MB_OK | MB_ICONERROR);

        DeleteSearchOrder(psgHead);
    }

    // Unmap and close our file.
    CloseMappedFile(&fm);

    return fSuccess;
}

//******************************************************************************
/*static*/ void CSearchGroup::DeleteSearchOrder(CSearchGroup* &psgHead)
{
    while (psgHead)
    {
        CSearchGroup *psgTemp = psgHead->GetNext();
        delete psgHead;
        psgHead = psgTemp;
    }
}

//******************************************************************************
/*static*/ CSearchNode* CSearchGroup::CreateNode(LPCSTR pszPath, DWORD dwFlags /*=0*/)
{
    // Make sure we have a directory.
    if (!pszPath || !*pszPath)
    {
        return NULL;
    }

    int length = (int)strlen(pszPath);

    // Check to see if we need to add a wack when we are done.
    BOOL fNeedWack = !(dwFlags & SNF_FILE) && (pszPath[length - 1] != TEXT('\\'));

    // Allocate the node.
    CSearchNode *psnNew = (CSearchNode*)MemAlloc(sizeof(CSearchNode) + length + fNeedWack);

    // Fill in the node.
    psnNew->m_pNext   = NULL;
    psnNew->m_wFlags = (WORD)dwFlags;
    strcpy(psnNew->m_szPath, pszPath); // inspected

    // Add trailing wack if necessary.
    if (fNeedWack)
    {
        psnNew->m_szPath[length++] = '\\'; // inspected
        psnNew->m_szPath[length]   = '\0';
    }

    // Determine the offset of the name.
    LPCSTR pszWack = strrchr(psnNew->m_szPath, '\\');
    psnNew->m_wNameOffset = (WORD)(pszWack ? ((pszWack - psnNew->m_szPath) + 1) : 0);

    return psnNew;
}

//******************************************************************************
/*static*/ CSearchNode* CSearchGroup::CreateFileNode(CSearchNode *psnHead, DWORD dwFlags, LPSTR pszPath, LPCSTR pszName /*=NULL*/)
{
    bool         fNamed = ((dwFlags & SNF_NAMED_FILE) != 0);
    int          pathLength = (int)strlen(pszPath);
    CSearchNode *psnNew;

    // If the file is named, then we do a special creating of the node.
    if (fNamed)
    {
        int nameLength;

        // If we have a name, then use it.
        if (pszName)
        {
            nameLength = (int)strlen(pszName);
        }

        // Otherwise, we use just use the file name minus the extension.
        else
        {
            pszName = GetFileNameFromPath(pszPath);
            LPCSTR pDot = strrchr(pszName, '.');
            if (pDot)
            {
                nameLength = (int)(pDot - pszName);
            }
            else
            {
                nameLength = (int)strlen(pszName);
            }
        }

        // Create a new node for this module.
        psnNew = (CSearchNode*)MemAlloc(sizeof(CSearchNode) + pathLength + 1 + nameLength);

        // Fill in the node.
        psnNew->m_wFlags = (WORD)(dwFlags | SNF_FILE);
        psnNew->m_wNameOffset = (WORD)(pathLength + 1);
        StrCCpy(psnNew->m_szPath,                  pszPath, pathLength + 1);
        StrCCpy(psnNew->m_szPath + pathLength + 1, pszName, nameLength + 1);

        // Get the name and make it uppercase.
        pszName = psnNew->GetName();
        _strupr((LPSTR)pszName);
    }

    // If not a named file, then just create the node normally.
    else
    {
        if (!(psnNew = CreateNode(pszPath, dwFlags | SNF_FILE)))
        {
            return psnHead;
        }
        pszName = psnNew->m_szPath;
    }

    // Fix the case of the path to make it easier to read.
    FixFilePathCase(psnNew->m_szPath);

    // Locate the sorted insertion point.
    for (CSearchNode *psnPrev = NULL, *psn = psnHead;
        psn && (_stricmp(pszName, fNamed ? psn->GetName() : psn->m_szPath) > 0);
        psnPrev = psn, psn = psn->GetNext())
    {
    }

    // Insert the node into our list.
    psnNew->m_pNext = psn;
    if (psnPrev)
    {
        psnPrev->m_pNext = psnNew;
    }
    else
    {
        psnHead = psnNew;
    }

    // return the head of the updated list.
    return psnHead;
}

//******************************************************************************
/*static*/ void CSearchGroup::DeleteNodeList(CSearchNode *&psn)
{
    while (psn)
    {
        CSearchNode *psnNext = psn->GetNext();
        MemFree((LPVOID&)psn);
        psn = psnNext;
    }
}


//******************************************************************************
//****** CSearchGroup : Constructor / Destructor
//******************************************************************************

CSearchGroup::CSearchGroup(SEARCH_GROUP_TYPE sgType, CSearchNode *psnHead) :
    m_pNext(NULL),
    m_sgType(sgType),
    m_psnHead(psnHead),
    m_hActCtx(INVALID_HANDLE_VALUE),
    m_dwErrorManifest(0),
    m_dwErrorExe(0)
{
}

//******************************************************************************
CSearchGroup::CSearchGroup(SEARCH_GROUP_TYPE sgType, CSearchGroup *pNext, LPCSTR pszApp /*=NULL*/, LPCSTR pszDir /*=NULL*/) :
    m_pNext(pNext),
    m_sgType(sgType),
    m_psnHead(NULL),
    m_hActCtx(INVALID_HANDLE_VALUE),
    m_dwErrorManifest(0),
    m_dwErrorExe(0)
{
    // Make sure type is valid.
    if (((int)sgType < 0) || ((int)sgType >= SG_COUNT))
    {
        return;
    }

    int  length;
    CHAR szDirectory[DW_MAX_PATH + 16], *psz;
    *szDirectory = '\0';

    switch (sgType)
    {
        case SG_USER_DIR:
            if (pszDir)
            {
                m_psnHead = CreateNode(pszDir);
            }
            break;

        case SG_SIDE_BY_SIDE:

            // Make sure this OS supports the SxS functions.
            if (g_theApp.m_pfnCreateActCtxA && pszApp && *pszApp)
            {
                DWORD dwError, dwErrorExe = 0;
                ACTCTXA ActCtxA;

                //--------------------------------------------------------------
                // Attempt to locate SxS information in a .MANIFEST file.
                SCPrintf(szDirectory, sizeof(szDirectory), "%s.manifest", pszApp);

                ZeroMemory(&ActCtxA, sizeof(ActCtxA)); // inspected
                ActCtxA.cbSize = sizeof(ActCtxA);
                ActCtxA.dwFlags = ACTCTX_FLAG_APPLICATION_NAME_VALID;
                ActCtxA.lpSource = szDirectory;
                ActCtxA.lpApplicationName = pszApp;

                SetLastError(0);
                if (INVALID_HANDLE_VALUE != (m_hActCtx = g_theApp.m_pfnCreateActCtxA(&ActCtxA)))
                {
                    // Bail if we succeeded.
                    break;
                }

                // If that failed, check to see if we got an SxS error code.
                dwError = GetLastError();
                if ((dwError >= SXS_ERROR_FIRST) && (dwError <= SXS_ERROR_LAST))
                {
                    // If we did, then make a note of it so we can log it later.
                    m_dwErrorManifest = dwError;
                }

                //--------------------------------------------------------------
                // Next, try to look for the SxS information in the EXE itself.
                // This usually fails on Windows XP because of a post-XP beta 2
                // bug that causes CreateActCtx to fail if a specific resource
                // is not specifed.
                ZeroMemory(&ActCtxA, sizeof(ActCtxA)); // inspected
                ActCtxA.cbSize = sizeof(ActCtxA);
                ActCtxA.dwFlags = ACTCTX_FLAG_APPLICATION_NAME_VALID;
                ActCtxA.lpSource = pszApp;
                ActCtxA.lpApplicationName = pszApp;

                SetLastError(0);
                if (INVALID_HANDLE_VALUE != (m_hActCtx = g_theApp.m_pfnCreateActCtxA(&ActCtxA)))
                {
                    // Bail if we succeeded.
                    break;
                }

                // If that failed, check to see if we got a SxS error code.
                dwError = GetLastError();
                if ((dwError >= SXS_ERROR_FIRST) && (dwError <= SXS_ERROR_LAST))
                {
                    // If we did, then make a note of it so we can log it later.
                    dwErrorExe = dwError;
                }

                //--------------------------------------------------------------
                // Next, try to look for the SxS information in resource Id 1 and 2.
                for (DWORD_PTR dwpId = 1; dwpId <= 2; dwpId++)
                {
                    ZeroMemory(&ActCtxA, sizeof(ActCtxA)); // inspected
                    ActCtxA.cbSize = sizeof(ActCtxA);
                    ActCtxA.dwFlags = ACTCTX_FLAG_APPLICATION_NAME_VALID | ACTCTX_FLAG_RESOURCE_NAME_VALID;
                    ActCtxA.lpSource = pszApp;
                    ActCtxA.lpApplicationName = pszApp;
                    ActCtxA.lpResourceName = (LPCSTR)dwpId;

                    SetLastError(0);
                    if (INVALID_HANDLE_VALUE != (m_hActCtx = g_theApp.m_pfnCreateActCtxA(&ActCtxA)))
                    {
                        // Bail if we succeeded.
                        break;
                    }

                    // If that failed, check to see if we got a SxS error code
                    // and that we don't already have an error code for the EXE.
                    dwError = GetLastError();
                    if (!dwErrorExe && (dwError >= SXS_ERROR_FIRST) && (dwError <= SXS_ERROR_LAST))
                    {
                        // If we did, then make a note of it so we can log it later.
                        dwErrorExe = dwError;
                    }
                }

                // Store the final error.
                if (INVALID_HANDLE_VALUE == m_hActCtx)
                {
                    m_dwErrorExe = dwErrorExe;
                }
            }
            break;

        case SG_KNOWN_DLLS:
            // First try the Windows NT method, then the Windows 9x method.
            if (!(m_psnHead = GetKnownDllsOnNT()))
            {
                m_psnHead = GetKnownDllsOn9x();
            }
            break;

        case SG_APP_DIR:
            if (pszApp && (psz = strrchr(StrCCpy(szDirectory, pszApp, sizeof(szDirectory)), '\\')))
            {
                *(psz + 1) = '\0';
                m_psnHead = CreateNode(szDirectory);
            }
            break;

        case SG_32BIT_SYS_DIR:
            length = GetSystemDirectory(szDirectory, sizeof(szDirectory));
            if ((length > 0) && (length <= sizeof(szDirectory)))
            {
                m_psnHead = CreateNode(szDirectory);
            }
            break;

        case SG_16BIT_SYS_DIR:
            length = GetWindowsDirectory(szDirectory, sizeof(szDirectory) - 7);
            if ((length > 0) && (length <= (sizeof(szDirectory) - 7)))
            {
                StrCCat(AddTrailingWack(szDirectory, sizeof(szDirectory)), "system", sizeof(szDirectory));
                m_psnHead = CreateNode(szDirectory);
            }
            break;

        case SG_OS_DIR:
            length = GetWindowsDirectory(szDirectory, sizeof(szDirectory));
            if ((length > 0) && (length <= sizeof(szDirectory)))
            {
                m_psnHead = CreateNode(szDirectory);
            }
            break;

        case SG_APP_PATH:
            m_psnHead = GetAppPath(pszApp);
            break;

        case SG_SYS_PATH:
            m_psnHead = GetSysPath();
            break;
    }
}

//******************************************************************************
CSearchGroup::~CSearchGroup()
{
    // Delete this group's node list.
    DeleteNodeList(m_psnHead);

    // If this is a SxS node and we have created a handle for it, then close it.
    if ((m_hActCtx != INVALID_HANDLE_VALUE) && g_theApp.m_pfnReleaseActCtx)
    {
        g_theApp.m_pfnReleaseActCtx(m_hActCtx);
        m_hActCtx = INVALID_HANDLE_VALUE;
    }

    m_dwErrorManifest = 0;
    m_dwErrorExe      = 0;
}


//******************************************************************************
//****** CSearchGroup : Protected Functions
//******************************************************************************

//******************************************************************************
CSearchNode* CSearchGroup::GetSysPath()
{
    //!! This is getting the PATH environment from DW.  This is fine at first,
    //   but if the user modifies their environment and hits refresh in DW, they
    //   are not going to see the result of their change.  The shell seems to know
    //   when the environment has changed, maybe we can look at getting the
    //   "global" PATH environent variable in the future.  Also, when we launch
    //   a process using CreateProcess, we pass our environment along with it.
    //   That would need to be modified as well to pass the global environment.

    // Get the length of the PATH environment variable.
    DWORD dwSize = GetEnvironmentVariable("Path", NULL, 0);
    if (!dwSize)
    {
        return NULL;
    }

    // Allocate a PATH buffer.
    LPSTR pszPath = (LPSTR)MemAlloc(dwSize);
    *pszPath = '\0';

    // Get the PATH variable.
    CSearchNode *psnNew = NULL;
    if (GetEnvironmentVariable("Path", pszPath, dwSize) && *pszPath)
    {
        // Parse out each directory within the path.
        psnNew = ParsePath(pszPath);
    }

    // Free our path buffer.
    MemFree((LPVOID&)pszPath);

    return psnNew;
}

//******************************************************************************
CSearchNode* CSearchGroup::GetAppPath(LPCSTR pszApp)
{
    LPSTR pszPath = NULL;
    CSearchNode *psnNew = NULL;

    if (!pszApp || !*pszApp)
    {
        return NULL;
    }

    // Build the subkey name.
    CHAR szSubKey[80 + MAX_PATH];
    StrCCpy(szSubKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\", sizeof(szSubKey));
    StrCCat(szSubKey, GetFileNameFromPath(pszApp), sizeof(szSubKey));

    // Attempt to open key.  It is very likely the key doesn't even exist.
    HKEY hKey = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_QUERY_VALUE, &hKey) || !hKey)
    {
        return NULL;
    }

    // Get the length of the PATH registry variable.
    DWORD dwSize = 0;
    if (RegQueryValueEx(hKey, "Path", NULL, NULL, NULL, &dwSize) || !dwSize) // inspected
    {
        RegCloseKey(hKey);
        return NULL;
    }

    __try {
        // Allocate a PATH buffer.
        pszPath = (LPSTR)MemAlloc(dwSize);
        *pszPath = '\0';

        DWORD dwSize2 = dwSize;
        // Get the PATH variable.
        if (!RegQueryValueEx(hKey, "Path", NULL, NULL, (LPBYTE)pszPath, &dwSize2) && dwSize2) // inspected
        {
            pszPath[dwSize - 1] = '\0';

            // Parse out each directory within the path.
            psnNew = ParsePath(pszPath);
        }
    } __finally {
        // Close our registry key.
        RegCloseKey(hKey);

        // Free our path buffer.
        MemFree((LPVOID&)pszPath);
    }

    return psnNew;
}

//******************************************************************************
CSearchNode* CSearchGroup::ParsePath(LPSTR pszPath)
{
    CSearchNode *psnHead = NULL, *psnNew, *psnLast = NULL;

    // Get the first directory - we used to use strtok, but AVRF.EXE would report
    // an access violation in our code because of it.  It only seemed to occur
    // when using the retail VC 6.0 static CRT.  Oh well, strtok is evil anyway.
    LPSTR pszDirectory = pszPath;

    // Loop on all the directories in the path.
    while (pszDirectory)
    {
        // Look for a semicolon.
        LPSTR pszNext = strchr(pszDirectory, ';');
        if (pszNext)
        {
            // Null terminate at the semicolon and move over it.
            *pszNext++ = '\0';
        }

        // Trim off leading whitespace and quotes.
        while (isspace(*pszDirectory) || (*pszDirectory == '\"'))
        {
            pszDirectory++;
        }

        // Trim off trailing whitespace and quotes.
        LPSTR pszEnd = pszDirectory + strlen(pszDirectory) - 1;
        while ((pszEnd >= pszDirectory) && (isspace(*pszEnd) || (*pszEnd == '\"')))
        {
            *(pszEnd--) = '\0';
        }

        // Make sure we still have something to work with.
        if (*pszDirectory)
        {
            // Make sure the path is expanded.
            CHAR szExpanded[DW_MAX_PATH];
            if (ExpandEnvironmentStrings(pszDirectory, szExpanded, sizeof(szExpanded)))
            {
                psnNew = CreateNode(szExpanded);
            }
            else
            {
                psnNew = CreateNode(pszDirectory);
            }

            // Add the node to our list.
            if (psnLast)
            {
                psnLast->m_pNext = psnNew;
            }
            else
            {
                psnHead = psnNew;
            }
            psnLast = psnNew;
        }

        // Get the next directory.
        pszDirectory = pszNext;
    }

    return psnHead;
}

//******************************************************************************
CSearchNode* CSearchGroup::GetKnownDllsOn9x()
{
    CSearchNode *psnHead = NULL;
    CHAR         szBuffer[DW_MAX_PATH], szPath[DW_MAX_PATH], *pszFile;
    DWORD        dwBufferSize, dwPathSize, dwAppendSize, dwIndex = 0;

    HKEY hKey = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs",
                     0, KEY_QUERY_VALUE, &hKey))
    {
        return NULL;
    }

    // Attempt to locate the DllDirectory value in our KnownDlls list.
    if (!RegQueryValueEx(hKey, "DllDirectory", NULL, NULL, (LPBYTE)szBuffer, &(dwBufferSize = sizeof(szBuffer)))) // inspected.
    {
        szBuffer[sizeof(szBuffer) - 1] = '\0';

        // If we found a string, make sure it is expanded.
        dwPathSize = ExpandEnvironmentStrings(szBuffer, szPath, sizeof(szPath));
    }
    else
    {
        dwPathSize = 0;
    }

    // If we failed to find the string, then just use our system directory.
    if (!dwPathSize)
    {
        if ((dwPathSize = GetSystemDirectory(szPath, sizeof(szPath))) >= sizeof(szPath))
        {
            dwPathSize = 0;
        }
    }

    // Null terminate and add a wack if necessary.
    szPath[dwPathSize] = '\0';
    AddTrailingWack(szPath, sizeof(szPath));

    // Store a pointer to where we will later append file names to.
    pszFile = szPath + strlen(szPath);
    dwAppendSize = sizeof(szPath) - (DWORD)(pszFile - szPath);

    while (RegEnumValue(hKey, dwIndex++, szBuffer, &(dwBufferSize = sizeof(szBuffer)),
                        NULL, NULL, (LPBYTE)pszFile, &(dwPathSize = dwAppendSize)) == ERROR_SUCCESS)
    {
        // Make sure this is not our DllDirectory entry.
        if (_stricmp(szBuffer, "DllDirectory"))
        {
            // Create this node and insert it into our list.
            psnHead = CreateFileNode(psnHead, SNF_FILE | SNF_NAMED_FILE, szPath, szBuffer);
        }
    }

    RegCloseKey(hKey);

    return psnHead;
}

//******************************************************************************
CSearchNode* CSearchGroup::GetKnownDllsOnNT()
{
    // WOW64 (tested on build 2250) has a bug (NTRAID 146932) where NtQueryDirectoryObject
    // writes past the end of the buffer past to it.  This was trashing our stack and
    // causing us to fail.  The solution is to create a buffer larger than need, then tell
    // NtQueryDirectoryObject that the buffer is smaller than it really is.  32-bit NT
    // does not seem to have this problem.  We could do a runtime check to see if we are
    // running in WOW64, but this workaround is harmless on 32-bit NT.
    #define BUF_SIZE 4096
    #define BUF_USE  2048

    CSearchNode                  *psnHead = NULL;
    PFN_NtClose                   pfnNtClose = NULL;
    PFN_NtOpenDirectoryObject     pfnNtOpenDirectoryObject;
    PFN_NtQueryDirectoryObject    pfnNtQueryDirectoryObject;
    PFN_NtOpenSymbolicLinkObject  pfnNtOpenSymbolicLinkObject;
    PFN_NtQuerySymbolicLinkObject pfnNtQuerySymbolicLinkObject;
    BYTE                         *pbBuffer = NULL;
    HANDLE                        hDirectory = NULL, hLink = NULL;
    ULONG                         ulContext = 0, ulReturnedLength;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    OBJECT_ATTRIBUTES             Attributes;
    UNICODE_STRING                usDirectory;
    CHAR                          szPath[DW_MAX_PATH], *pszFile = NULL;
    DWORD                         dwAppendSize;

    __try
    {
        // Allocate a buffer for storing directories entries and module names.
        pbBuffer = (BYTE*)MemAlloc(BUF_SIZE);

        // Load NTDLL.DLL if not already loaded - it will be freed later.
        if (!g_theApp.m_hNTDLL && (!(g_theApp.m_hNTDLL = LoadLibrary("ntdll.dll")))) // inspected. need full path?
        {
            __leave;
        }

        // Locate the functions we need to call in order to get the known dll list.
        if (!(pfnNtClose                   = (PFN_NtClose)                  GetProcAddress(g_theApp.m_hNTDLL, "NtClose"))                  ||
            !(pfnNtOpenDirectoryObject     = (PFN_NtOpenDirectoryObject)    GetProcAddress(g_theApp.m_hNTDLL, "NtOpenDirectoryObject"))    ||
            !(pfnNtQueryDirectoryObject    = (PFN_NtQueryDirectoryObject)   GetProcAddress(g_theApp.m_hNTDLL, "NtQueryDirectoryObject"))   ||
            !(pfnNtOpenSymbolicLinkObject  = (PFN_NtOpenSymbolicLinkObject) GetProcAddress(g_theApp.m_hNTDLL, "NtOpenSymbolicLinkObject")) ||
            !(pfnNtQuerySymbolicLinkObject = (PFN_NtQuerySymbolicLinkObject)GetProcAddress(g_theApp.m_hNTDLL, "NtQuerySymbolicLinkObject")))
        {
            __leave;
        }

        // Fill in a UNICODE_STRING structure with the directory we want to query.
        usDirectory.Buffer = L"\\KnownDlls";
        usDirectory.Length = (USHORT)(wcslen(usDirectory.Buffer) * sizeof(WCHAR));
        usDirectory.MaximumLength = (USHORT)(usDirectory.Length + sizeof(WCHAR));

        // Initialize our Attributes structure so that we can read in the directory.
        InitializeObjectAttributes(&Attributes, &usDirectory, OBJ_CASE_INSENSITIVE, NULL, NULL);

        // Open the directory with query permission.
        if (!NT_SUCCESS(pfnNtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &Attributes)))
        {
            __leave;
        }

        // Clear out our buffers.
        ZeroMemory(pbBuffer, BUF_SIZE); // inspected
        ZeroMemory(szPath, sizeof(szPath)); // inspected

        // We make two passes through the directory.  The first pass is to locate
        // the KnownDllPath entry so that we can determine the base directory that
        // the known dlls live in.  The second pass it to actually enumerate the
        // known dlls.

        // Pass 1: Grab a block of records for this directory.
        while (!pszFile && NT_SUCCESS(pfnNtQueryDirectoryObject(hDirectory, pbBuffer, BUF_USE, FALSE,
                                                                FALSE, &ulContext, &ulReturnedLength)))
        {
            // Our buffer now contains an array of OBJECT_DIRECTORY_INFORMATION structures.
            // Walk through the records in this block.
            for (pDirInfo = (POBJECT_DIRECTORY_INFORMATION)pbBuffer; !pszFile && pDirInfo->Name.Length; pDirInfo++)
            {
                // Check to see if we found what we are looking for.
                if (!_wcsicmp(pDirInfo->Name.Buffer,     L"KnownDllPath") &&
                    !_wcsicmp(pDirInfo->TypeName.Buffer, L"SymbolicLink"))
                {
                    // Initialize our Attributes structure so that we can read in the link.
                    InitializeObjectAttributes(&Attributes, &pDirInfo->Name, OBJ_CASE_INSENSITIVE, hDirectory, NULL);

                    // Open the link.
                    if (NT_SUCCESS(pfnNtOpenSymbolicLinkObject(&hLink, SYMBOLIC_LINK_QUERY, &Attributes)))
                    {
                        // Build a UNICODE_STRING to hold the link directory.
                        ZeroMemory(pbBuffer, BUF_SIZE); // inspected
                        usDirectory.Buffer = (PWSTR)pbBuffer;
                        usDirectory.Length = 0;
                        usDirectory.MaximumLength = BUF_SIZE;

                        // Query the link for its directory.
                        if (NT_SUCCESS(pfnNtQuerySymbolicLinkObject(hLink, &usDirectory, NULL)))
                        {
                            // Make sure the string is NULL terminated.
                            usDirectory.Buffer[usDirectory.Length / sizeof(WCHAR)] = L'\0';

                            // Store the directory in our buffer.
                            if (wcstombs(szPath, usDirectory.Buffer, sizeof(szPath)) < sizeof(szPath))
                            {
                                AddTrailingWack(szPath, sizeof(szPath));
                                pszFile = szPath + strlen(szPath);
                            }
                        }

                        // Close the link.
                        pfnNtClose(hLink);
                        hLink = NULL;
                    }

                    // We should have found something.  If we encountered an error
                    // then bail out of the for loop since we trashed pbBuffer anyway.
                    if (!pszFile)
                    {
                        break;
                    }
                }
            }

            // Clear out our buffer.
            ZeroMemory(pbBuffer, BUF_SIZE); // inspected
        }

        // If we did not find a path, then we assume the system directory.
        if (!pszFile)
        {
            if (GetSystemDirectory(szPath, sizeof(szPath)) == 0)
            {
                __leave;
            }
            AddTrailingWack(szPath, sizeof(szPath));
            pszFile = szPath + strlen(szPath);
        }

        // Calculate how much space is left in our buffer for appending.
        dwAppendSize = sizeof(szPath) - (DWORD)(pszFile - szPath);

        // Pass 2: Grab a block of records for this directory.
        ulContext = 0;
        while (NT_SUCCESS(pfnNtQueryDirectoryObject(hDirectory, pbBuffer, BUF_USE, FALSE,
                                                    FALSE, &ulContext, &ulReturnedLength)))
        {
            // Our buffer now contains an array of OBJECT_DIRECTORY_INFORMATION structures.
            // Walk through the records in this block.
            for (pDirInfo = (POBJECT_DIRECTORY_INFORMATION)pbBuffer; pDirInfo->Name.Length; pDirInfo++)
            {
                // Check to see if we found a known dll.
                if (!_wcsicmp(pDirInfo->TypeName.Buffer, L"Section"))
                {
                    if (wcstombs(pszFile, pDirInfo->Name.Buffer, dwAppendSize) < dwAppendSize)
                    {
                        // Create this node and insert it into our list.
                        psnHead = CreateFileNode(psnHead, SNF_FILE, szPath);
                    }
                }
            }

            // Clear out our buffer.
            ZeroMemory(pbBuffer, BUF_SIZE); // inspected
        }

        // NTDLL.DLL is never listed as a KnownDll, but it always is one.
        if (GetModuleFileName(g_theApp.m_hNTDLL, szPath, sizeof(szPath)))
        {
            psnHead = CreateFileNode(psnHead, SNF_FILE, szPath);
        }
    }
    __finally
    {
        // Close the directory object if we opened one.
        if (hDirectory && g_theApp.m_hNTDLL && pfnNtClose)
        {
            pfnNtClose(hDirectory);
        }

        // Free our buffer.
        MemFree((LPVOID&)pbBuffer);
    }

    return psnHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\profview.cpp ===
//******************************************************************************
//
// File:        PROFVIEW.CPP
//
// Description: Implementation file for the Runtime Profile Edit View.
//
// Classes:     CRichViewProfile
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "dbgthread.h"
#include "session.h"
#include "document.h"
#include "mainfrm.h"
#include "profview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// NOTE: In version 2.0 we derived CRichViewProfile off of CRichViewProfile which
// is the MFC default for a RichEdit control view.  In examining the code, I
// realized that the CRichViewProfile bumps our retail binary up 70K and drags in
// OLEDLG.DLL and OLE32.DLL as dependencies.  It turns out that neither the
// extra code nor the DLLs are needed as we don't use the OLE interfaces of the
// RichEdit control.  So, we now just derive off of CCtrlView directly.


//******************************************************************************
//***** CRichViewProfile
//******************************************************************************

AFX_STATIC const UINT _afxMsgFindReplace2 = ::RegisterWindowMessage(FINDMSGSTRING);

IMPLEMENT_DYNCREATE(CRichViewProfile, CCtrlView)
BEGIN_MESSAGE_MAP(CRichViewProfile, CCtrlView)
    //{{AFX_MSG_MAP(CRichViewProfile)
    ON_WM_DESTROY()
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEWHEEL()
    ON_WM_VSCROLL()
    ON_COMMAND(ID_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_PREV_PANE, OnPrevPane)
    ON_WM_RBUTTONUP()
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateEditFind)
    ON_COMMAND(ID_EDIT_FIND, OnEditFind)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, OnUpdateEditRepeat)
    ON_COMMAND(ID_EDIT_REPEAT, OnEditRepeat)
    //}}AFX_MSG_MAP
    ON_REGISTERED_MESSAGE(_afxMsgFindReplace2, OnFindReplaceCmd)
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    // Standard printing commands
//  ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
//  ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
ON_WM_CREATE()
END_MESSAGE_MAP()

//******************************************************************************
CRichViewProfile::CRichViewProfile() :
    CCtrlView("RICHEDIT", AFX_WS_DEFAULT_VIEW |
        WS_HSCROLL | WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL |
        ES_MULTILINE | ES_NOHIDESEL | ES_SAVESEL | ES_SELECTIONBAR),
    m_fIgnoreSelChange(false),
    m_fCursorAtEnd(true),
    m_fNewLine(true),
    m_cPrev('\0'),
    m_pDlgFind(NULL),
    m_fFindCase(false),
    m_fFindWord(false),
    m_fFirstSearch(true),
    m_lInitialSearchPos(0)
{
}

//******************************************************************************
CRichViewProfile::~CRichViewProfile()
{
}


//******************************************************************************
// CListViewModules :: Overridden functions
//******************************************************************************

BOOL CRichViewProfile::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.lpszName = "";
    cs.cx = cs.cy = 100; // necessary to avoid bug with ES_SELECTIONBAR and zero for cx and cy
    cs.style |= ES_READONLY | WS_HSCROLL | WS_VSCROLL | ES_LEFT | ES_MULTILINE |
                ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_NOHIDESEL | WS_CLIPSIBLINGS;
    cs.dwExStyle |= WS_EX_CLIENTEDGE;
    return CCtrlView::PreCreateWindow(cs);
}

//******************************************************************************
int CRichViewProfile::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CCtrlView::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    // Don't limit our rich edit view.  The docs for EM_EXLIMITTEXT say the
    // default size of a rich edit control is limited to 32,767 characters.
    // Dependency Walker 2.0 seemed to have no limitations at all, but DW 2.1
    // will truncate the profile logs of loaded DWIs to 32,767 characters.
    // However, we have no problems writing more than 32K characters to the
    // log with DW 2.1 during a live profile.  The docs for EM_EXLIMITTEXT
    // also say that it has no effect on the EM_STREAMIN functionality.  This
    // must be wrong, since when we call LimitText with something higher than
    // 32K, we can stream more characters in.  We need to limit it here and
    // not in OnInitialUpdate since OnInitialUpdate is called after the this
    // view is filled by a command line load of a DWI file.
    GetRichEditCtrl().LimitText(0x7FFFFFFE);

    return 0;
}

//******************************************************************************
#if 0 //{{AFX
BOOL CRichViewProfile::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CRichViewProfile::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}
#endif //}}AFX

//******************************************************************************
#if 0 //{{AFX
void CRichViewProfile::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}
#endif //}}AFX

//******************************************************************************
void CRichViewProfile::OnInitialUpdate()
{
    CCtrlView::OnInitialUpdate();

    // Make sure we receive EN_SELCHANGE messages.
    GetRichEditCtrl().SetEventMask(ENM_SELCHANGE);

    // Turn off word wrap.
    GetRichEditCtrl().SetTargetDevice(NULL, 1);
}


//******************************************************************************
// CRichViewProfile :: Event handler functions
//******************************************************************************

void CRichViewProfile::OnDestroy() 
{
    CCtrlView::OnDestroy();
    DeleteContents();
}

//******************************************************************************
// This function will enable/disable autoscroll based on keyboard activity.
void CRichViewProfile::OnSelChange(NMHDR *pNMHDR, LRESULT *pResult)
{
    *pResult = 0;

    if (!m_fIgnoreSelChange)
    {
        DWORD dwCount = GetRichEditCtrl().GetTextLength();

        // Check to see if the user moved the cursor away from the end.
        if (m_fCursorAtEnd)
        {
            if ((DWORD)((SELCHANGE*)pNMHDR)->chrg.cpMin < dwCount)
            {
                m_fCursorAtEnd = false;
            }
        }

        // Check to see if the user moved the cursor to the end.
        else if ((DWORD)((SELCHANGE*)pNMHDR)->chrg.cpMin >= dwCount)
        {
            m_fCursorAtEnd = true;
        }
    }
}

//******************************************************************************
// This function will enable/disable autoscroll based on mouse button activity.
void CRichViewProfile::OnLButtonDown(UINT nFlags, CPoint point) 
{
    if (!m_fIgnoreSelChange)
    {
        DWORD dwCount = GetRichEditCtrl().GetTextLength();
        DWORD dwChar  = (DWORD)SendMessage(EM_CHARFROMPOS, 0, (LPARAM)(POINT*)&point);

        // Check to see if the user moved the cursor away from the end.
        if (m_fCursorAtEnd)
        {
            if (dwChar < dwCount)
            {
                m_fCursorAtEnd = false;
            }
        }

        // Check to see if the user moved the cursor to the end.
        else if (dwChar >= dwCount)
        {
            m_fCursorAtEnd = true;
        }
    }
    
    CCtrlView::OnLButtonDown(nFlags, point);
}

//******************************************************************************
// This function will disable autoscroll based on scroll bar activity.
void CRichViewProfile::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
    // If the user scrolls up, then disable our autoscroll.
    if (!m_fIgnoreSelChange && (nSBCode != SB_LINEDOWN) && (nSBCode != SB_PAGEDOWN) && (nSBCode != SB_ENDSCROLL))
    {
        m_fCursorAtEnd = false;
    }
    
    CCtrlView::OnVScroll(nSBCode, nPos, pScrollBar);
}

//******************************************************************************
// This function will disable autoscroll based on mouse wheel activity.
BOOL CRichViewProfile::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
    // If the user scrolls up, then disable our autoscroll.
    if (!m_fIgnoreSelChange && (zDelta > 0))
    {
        m_fCursorAtEnd = false;
    }
    
    return CCtrlView::OnMouseWheel(nFlags, zDelta, pt);
}

//******************************************************************************
void CRichViewProfile::OnRButtonUp(UINT nFlags, CPoint point)
{
    // Let base class know the mouse was released.
    CCtrlView::OnRButtonUp(nFlags, point);

    // Display our context menu.
    g_pMainFrame->DisplayPopupMenu(3);
}

//******************************************************************************
void CRichViewProfile::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    // Set the text to the default.
    pCmdUI->SetText("&Copy Text\tCtrl+C");

    long nStartChar, nEndChar;
    GetRichEditCtrl().GetSel(nStartChar, nEndChar);
    pCmdUI->Enable(nStartChar != nEndChar);
}

//******************************************************************************
void CRichViewProfile::OnEditCopy() 
{
    GetRichEditCtrl().Copy();
}

//******************************************************************************
void CRichViewProfile::OnUpdateEditSelectAll(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(GetRichEditCtrl().GetTextLength() != 0);
}

//******************************************************************************
void CRichViewProfile::OnEditSelectAll() 
{
    GetRichEditCtrl().SetSel(0, -1);
}

//******************************************************************************
void CRichViewProfile::OnNextPane()
{
    // Change the focus to our next pane, the Module Dependency Tree View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pTreeViewModules);
}

//******************************************************************************
void CRichViewProfile::OnPrevPane()
{
    // Change the focus to our previous pane, the Module List View.
    GetParentFrame()->SetActiveView((CView*)GetDocument()->m_pListViewModules);
}

//******************************************************************************
LRESULT CRichViewProfile::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
    // Called when the context help pointer (SHIFT+F1) is clicked on our client.
    return (0x20000 + IDR_PROFILE_RICH_VIEW);
}

//******************************************************************************
LRESULT CRichViewProfile::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    // Called when the user chooses help (F1) while our view is active.
    g_theApp.WinHelp(0x20000 + IDR_PROFILE_RICH_VIEW);
    return TRUE;
}


//******************************************************************************
// CRichViewProfile :: Find Functions - Taken from CRichEditView and modified.
//******************************************************************************

void CRichViewProfile::OnUpdateEditFind(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(GetRichEditCtrl().GetTextLength() != 0);
}

//******************************************************************************
void CRichViewProfile::OnEditFind() 
{
    // Make this as a new search.
    m_fFirstSearch = true;

    // If we have a find dialog up, then give it focus.
    if (m_pDlgFind != NULL)
    {
        m_pDlgFind->SetActiveWindow();
        m_pDlgFind->ShowWindow(SW_SHOW);
        return;
    }

    // Get the current text selection.
    CString strFind = GetRichEditCtrl().GetSelText();

    // If selection is empty or spans multiple lines, then we use the old find text
    if (strFind.IsEmpty() || (strFind.FindOneOf(_T("\n\r")) != -1))
    {
        strFind = m_strFind;
    }

    // We only support "search down", not "search up".  We also support
    // "match case" and "match whole word"
    DWORD dwFlags = FR_DOWN | FR_HIDEUPDOWN |
        (m_fFindCase ? FR_MATCHCASE : 0) | (m_fFindWord ? FR_WHOLEWORD : 0);

    // Create the find dialog.
    if (!(m_pDlgFind = new CFindReplaceDialog) ||
        !m_pDlgFind->Create(TRUE, strFind, NULL, dwFlags, this))
    {
        // The dialog will self-delete, so we don't need to call delete.
        m_pDlgFind = NULL;
        return;
    }
    
    // Show the window.
    m_pDlgFind->SetActiveWindow();
    m_pDlgFind->ShowWindow(SW_SHOW);
}

//******************************************************************************
void CRichViewProfile::OnUpdateEditRepeat(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(GetRichEditCtrl().GetTextLength() != 0);
}

//******************************************************************************
void CRichViewProfile::OnEditRepeat() 
{
    // If we don't have a search string, then just display the find dialog.
    if (m_strFind.IsEmpty())
    {
        OnEditFind();
    }

    // Otherwise, just search for the text.
    else if (!FindText())
    {
        TextNotFound();
    }
}

//******************************************************************************
LRESULT CRichViewProfile::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
    // Determine the dialog that sent us this message.
    CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
    if (!pDialog && !(pDialog = m_pDlgFind))
    {
        return 0;
    }

    // Check to see if the dialog is terminating.
    if (pDialog->IsTerminating())
    {
        m_pDlgFind = NULL;
    }

    // Check to see if the user pressed the "Find Next" button.
    else if (pDialog->FindNext())
    {
        m_strFind   = pDialog->GetFindString();
        m_fFindCase = (pDialog->MatchCase() == TRUE);
        m_fFindWord = (pDialog->MatchWholeWord() == TRUE);

        if (!FindText())
        {
            TextNotFound();
        }
        else
        {
            AdjustDialogPosition();
        }
    }

    return 0;
}

//******************************************************************************
BOOL CRichViewProfile::FindText()
{
    // This could take a while.
    CWaitCursor wait;

    // Get the beginning of the selection.
    FINDTEXTEX ft;
    GetRichEditCtrl().GetSel(ft.chrg);
    if (m_fFirstSearch)
    {
        m_lInitialSearchPos = ft.chrg.cpMin;
        m_fFirstSearch = false;
    }

    // If there is a selection, step over the first character so our search
    // doesn't rematch the text it just found.
    ft.lpstrText = (LPCTSTR)m_strFind;
    if (ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
    {
        // If byte at beginning of selection is a DBCS lead byte,
        // increment by one extra byte.
        TEXTRANGE textRange;
        TCHAR ch[2];
        textRange.chrg.cpMin = ft.chrg.cpMin;
        textRange.chrg.cpMax = ft.chrg.cpMin + 1;
        textRange.lpstrText = ch;
        GetRichEditCtrl().SendMessage(EM_GETTEXTRANGE, 0, (LPARAM)&textRange);
        if (_istlead(ch[0]))
        {
            ft.chrg.cpMin++;
        }
        ft.chrg.cpMin++;
    }

    if (m_lInitialSearchPos >= 0)
    {
        ft.chrg.cpMax = GetRichEditCtrl().GetTextLength();
    }
    else
    {
        ft.chrg.cpMax = GetRichEditCtrl().GetTextLength() + m_lInitialSearchPos;
    }

    // Compute search our flags.
    DWORD dwFlags = (m_fFindCase ? FR_MATCHCASE : 0) | (m_fFindWord ? FR_WHOLEWORD : 0);

    // Search the rich edit control for this text.
    // If we found something, then select it and bail.
    if (-1 != GetRichEditCtrl().FindText(dwFlags, &ft))
    {
        GetRichEditCtrl().SetSel(ft.chrgText);
        return TRUE;
    }

    // Otherwise, if the original starting point was not the beginning of the
    // buffer and we haven't already been here, then wrap around and search
    // from beginning.
    else if (m_lInitialSearchPos > 0)
    {
        ft.chrg.cpMin = 0;
        ft.chrg.cpMax = m_lInitialSearchPos;
        m_lInitialSearchPos = m_lInitialSearchPos - GetRichEditCtrl().GetTextLength();
        if (-1 != GetRichEditCtrl().FindText(dwFlags, &ft))
        {
            GetRichEditCtrl().SetSel(ft.chrgText);
            return TRUE;
        }
    }

    // Otherwise, we did not find it.
    return FALSE;
}

//******************************************************************************
void CRichViewProfile::TextNotFound()
{
    // Our next search will be new search.
    m_fFirstSearch = true;

    // Display an error.
    CString strError("Cannot find the string '");
    strError += m_strFind;
    strError += "'.";
    AfxMessageBox(strError, MB_OK | MB_ICONWARNING);
}

//******************************************************************************
void CRichViewProfile::AdjustDialogPosition()
{
    // Get the selection start location in screen coordinates.
    long lStart, lEnd;
    GetRichEditCtrl().GetSel(lStart, lEnd);
    CPoint point = GetRichEditCtrl().GetCharPos(lStart);
    ClientToScreen(&point);

    // Get the dialog location.
    CRect rectDlg;
    m_pDlgFind->GetWindowRect(&rectDlg);

    // If the dialog is over the selection start, then move the dialog.
    if (rectDlg.PtInRect(point))
    {
        if (point.y > rectDlg.Height())
        {
            rectDlg.OffsetRect(0, point.y - rectDlg.bottom - 20);
        }
        else
        {
            int nVertExt = GetSystemMetrics(SM_CYSCREEN);
            if (point.y + rectDlg.Height() < nVertExt)
            {
                rectDlg.OffsetRect(0, 40 + point.y - rectDlg.top);
            }
        }
        m_pDlgFind->MoveWindow(&rectDlg);
    }
}


//******************************************************************************
// CRichViewProfile :: Public Functions
//******************************************************************************

void CRichViewProfile::DeleteContents()
{
    // If we have a find dialog, then close it.
    if (m_pDlgFind)
    {
        m_pDlgFind->SendMessage(WM_CLOSE);
    }

    SetWindowText(_T(""));
    GetRichEditCtrl().EmptyUndoBuffer();

    m_fCursorAtEnd = true;
    m_fNewLine = true;
    m_cPrev = '\0';
}

//******************************************************************************
void CRichViewProfile::AddText(LPCSTR pszText, DWORD dwFlags, DWORD dwElapsed)
{
    // Tell ourself to ignore selection changes for a bit.
    m_fIgnoreSelChange = true;

    // If our cursor is not at the end, then store the current selection location
    // and disable auto-scrolling.
    CHARRANGE crCur;
    if (!m_fCursorAtEnd)
    {
        GetRichEditCtrl().GetSel(crCur);
        GetRichEditCtrl().SetOptions(ECOOP_AND, (DWORD)~ECO_AUTOVSCROLL);
    }

    // Add the text to our control.
    AddTextToRichEdit(&GetRichEditCtrl(), pszText, dwFlags,
                      (GetDocument()->m_dwProfileFlags & PF_LOG_TIME_STAMPS) ? true : false,
                      &m_fNewLine, &m_cPrev, dwElapsed);

    // If our cursor was originally not at the end, then restore the selection location
    // and re-enable auto-scrolling.
    if (!m_fCursorAtEnd)
    {
        GetRichEditCtrl().SetSel(crCur);
        GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOVSCROLL);
    }

    // Tell ourself that it is ok to process selection change messages again.
    m_fIgnoreSelChange = false;
}

//******************************************************************************
/*static*/ void CRichViewProfile::AddTextToRichEdit(CRichEditCtrl *pRichEdit, LPCSTR pszText,
    DWORD dwFlags, bool fTimeStamps, bool *pfNewLine, CHAR *pcPrev, DWORD dwElapsed)
{
    LPCSTR pszSrc = pszText;
    CHAR   szBuffer[2 * DW_MAX_PATH], *pszDst = szBuffer, *pszNull = szBuffer + sizeof(szBuffer) - 1, cSrc;

    // Debug messages may or may not include trailing newlines.  If they don't
    // include trailing newlines, we leave them hanging in case more debug
    // output is coming to complete the line.  However, if we are left hanging
    // at the end of some line and an event needs to be logged that is not
    // debug output, then we force a newline so the new event will start at
    // the beginning of a new line.

    if (!(dwFlags & LOG_APPEND) && !*pfNewLine)
    {
        if (pszDst < pszNull)
        {
            *(pszDst++) = '\r';
        }
        if (pszDst < pszNull)
        {
            *(pszDst++) = '\n';
        }
        *pfNewLine = true;
    }

    // Copy the buffer into a new buffer while performing the following
    // newline conversions:
    //    Single CR -> CR/LF
    //    Single LF -> CR/LF
    //    CR and LF -> CR/LF
    //    LF and CR -> CR/LF

    for ( ; *pszSrc; pszSrc++)
    {
        // Determine what character to copy to the destination buffer.
        // A '\0' means we don't copy any character.
        cSrc = '\0';
        if (*pszSrc == '\n')
        {
            // This is sort of a hack. We want to strip all '\n' and '\r' from logs that
            // don't belong in them (such as ones within file names and function names).
            // We know that normal log (not a debug/gray message) only contain newlines
            // at the end of the buffer passed to us.  Going off this assumption, any
            // newlines in non-gray text that are not at the end of the buffer can be
            // replaced.
            if (!(dwFlags & LOG_GRAY) && *(pszSrc + 1))
            {
                cSrc = '\004';
            }
            else if (*pcPrev != '\r')
            {
                cSrc = '\n';
            }
        }
        else if (*pszSrc == '\r')
        {
            if (!(dwFlags & LOG_GRAY) && *(pszSrc + 1))
            {
                cSrc = '\004';
            }
            else if (*pcPrev != '\n')
            {
                cSrc = '\r';
            }
        }
        else
        {
            cSrc = *pszSrc;
        }

        if (cSrc)
        {
            // Check to see if we are starting a new line and we have been told to
            // insert a time stamp into each line of log.
            if (fTimeStamps && *pfNewLine && (dwFlags & LOG_TIME_STAMP))
            {
                // If we have some current log buffered up that is red, gray, or bold,
                // then flush that out to our control before appending the time stamp.
                if ((pszDst > szBuffer) && (dwFlags & (LOG_RED | LOG_GRAY | LOG_BOLD)))
                {
                    *pszDst = '\0';
                    AddTextToRichEdit2(pRichEdit, szBuffer, dwFlags);
                    pszDst = szBuffer;
                }

                // Append the time stamp to the destination buffer.
                pszDst += SCPrintf(pszDst, sizeof(szBuffer) - (int)(pszDst - szBuffer), "%02u:%02u:%02u.%03u: ",
                                   (dwElapsed / 3600000),
                                   (dwElapsed /   60000) %   60,
                                   (dwElapsed /    1000) %   60,
                                   (dwElapsed          ) % 1000);

                // We always log our timestamp in non-bold black print. If the log is also
                // non-bold black, then we will just build the entire line and log it at
                // once. However, if it is not non-bold black, then we need to first log
                // the time stamp, then log the line of text.
                if (dwFlags & (LOG_RED | LOG_GRAY | LOG_BOLD))
                {
                    AddTextToRichEdit2(pRichEdit, szBuffer, 0);
                    pszDst = szBuffer;
                }
            }

            // Check for a new line character.
            if ((cSrc == '\r') || (cSrc == '\n'))
            {
                if (pszDst < pszNull)
                {
                    *(pszDst++) = '\r';
                }
                if (pszDst < pszNull)
                {
                    *(pszDst++) = '\n';
                }
                *pfNewLine = true;
            }

            // Otherwise, it is just a normal character.
            else
            {
                if (pszDst < pszNull)
                {
                    *(pszDst++) = ((cSrc < 32) ? '\004' : cSrc);
                }
                *pfNewLine = false;
            }

            // Make a note of this character so out next character can look back at it.
            *pcPrev = cSrc;
        }
    }

    // Flush our buffer to the control.
    if (pszDst > szBuffer)
    {
        *pszDst = '\0';
        AddTextToRichEdit2(pRichEdit, szBuffer, dwFlags);
    }
}

//******************************************************************************
/*static*/ void CRichViewProfile::AddTextToRichEdit2(CRichEditCtrl *pRichEdit, LPCSTR pszText, DWORD dwFlags)
{
    // Set the selection to the end of our text.
    pRichEdit->SetSel(0x7FFFFFFF, 0x7FFFFFFF);

    // Set the font style
    CHARFORMAT cf;
    ZeroMemory(&cf, sizeof(cf)); // inspected
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_COLOR | CFM_BOLD;
    if (dwFlags & LOG_RED)
    {
        cf.crTextColor = RGB(255, 0, 0);
    }
    else if (dwFlags & LOG_GRAY)
    {
        cf.crTextColor = GetSysColor(COLOR_GRAYTEXT);
    }
    else
    {
        cf.dwEffects = CFE_AUTOCOLOR;
    }
    if (dwFlags & LOG_BOLD)
    {
        cf.dwEffects |= CFE_BOLD;
    }
    pRichEdit->SetSelectionCharFormat(cf);

    // Add the new text.
    pRichEdit->ReplaceSel(pszText, FALSE);
}

//******************************************************************************
/*static*/ bool CRichViewProfile::SaveToFile(CRichEditCtrl *pre, HANDLE hFile, SAVETYPE saveType)
{
    // Write the contents of our control to the file.
    EDITSTREAM es;
    es.dwCookie    = (DWORD_PTR)hFile;
    es.dwError     = 0;
    es.pfnCallback = EditStreamWriteCallback;
    pre->StreamOut((saveType == ST_DWI) ? SF_RTF : SF_TEXT, es);

    // Check for an error.
    if (es.dwError)
    {
        SetLastError(es.dwError);
        return false;
    }

    return true;
}

//******************************************************************************
/*static*/ bool CRichViewProfile::ReadFromFile(CRichEditCtrl *pre, HANDLE hFile)
{
    // Write the contents of our control to the file.
    EDITSTREAM es;
    es.dwCookie    = (DWORD_PTR)hFile;
    es.dwError     = 0;
    es.pfnCallback = EditStreamReadCallback;
    pre->StreamIn(SF_RTF, es); // We only read DWI files which are always RTF.

    // Check for an error.
    if (es.dwError)
    {
        SetLastError(es.dwError);
        return false;
    }

    return true;
}

//******************************************************************************
/*static*/ DWORD CALLBACK CRichViewProfile::EditStreamWriteCallback(DWORD_PTR dwpCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    if (!WriteFile((HANDLE)dwpCookie, pbBuff, (DWORD)cb, (LPDWORD)pcb, NULL))
    {
        return GetLastError();
    }
    return 0;
}

//******************************************************************************
/*static*/ DWORD CALLBACK CRichViewProfile::EditStreamReadCallback(DWORD_PTR dwpCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    if (!ReadFile((HANDLE)dwpCookie, pbBuff, (DWORD)cb, (LPDWORD)pcb, NULL))
    {
        return GetLastError();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\search.h ===
//******************************************************************************
//
// File:        SEARCH.H
//
// Description: Definition file for the file search classes
//
// Classes:     CSearchNode
//              CSearchGroup
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __SEARCH_H__
#define __SEARCH_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//****** Constants and Macros
//******************************************************************************

// Search Group (CSearchGRoup) Flags
#define SGF_NOT_LINKED             ((CSearchGroup*)1)

// Search Node (CSearchNode) flags
#define SNF_DWI                    ((WORD)0x0001)
#define SNF_ERROR                  ((WORD)0x0002)
#define SNF_FILE                   ((WORD)0x0004)
#define SNF_NAMED_FILE             ((WORD)0x0008)


//******************************************************************************
//****** Types and Structure
//******************************************************************************

//!! During the next rev of the DWI format, move SxS above KnownDlls
typedef enum _SEARCH_GROUP_TYPE
{
    SG_USER_DIR = 0,
    SG_SIDE_BY_SIDE,
    SG_KNOWN_DLLS,
    SG_APP_DIR,
    SG_32BIT_SYS_DIR,
    SG_16BIT_SYS_DIR,
    SG_OS_DIR,
    SG_APP_PATH,
    SG_SYS_PATH,
    SG_COUNT
} SEARCH_GROUP_TYPE, *PSEARCH_GROUP_TYPE;


//******************************************************************************
//****** CSearchNode
//******************************************************************************

class CSearchNode
{
private:
    // Since we are variable in size, we should never be allocated or freed by
    // the new/delete functions directly.
    inline CSearchNode()  { ASSERT(false); }
    inline ~CSearchNode() { ASSERT(false); }

public:
    CSearchNode *m_pNext;
    WORD         m_wFlags;
    WORD         m_wNameOffset;
    CHAR         m_szPath[1];

public:
    inline CSearchNode* GetNext()  { return m_pNext; }
    inline DWORD        GetFlags() { return (DWORD)m_wFlags; }
    inline LPCSTR       GetPath()  { return m_szPath; }
    inline LPCSTR       GetName()  { return m_szPath + m_wNameOffset; }

    DWORD UpdateErrorFlag();
};


//******************************************************************************
//****** CSearchGroup
//******************************************************************************

class CSearchGroup
{
friend CSession;

protected:
    static LPCSTR      ms_szGroups[SG_COUNT];
    static LPCSTR      ms_szShortNames[SG_COUNT];

public:
    CSearchGroup      *m_pNext;

protected:
    SEARCH_GROUP_TYPE  m_sgType;
    CSearchNode       *m_psnHead;

    HANDLE m_hActCtx;         // this is only used by the SxS group.
    DWORD  m_dwErrorManifest; // this is only used by the SxS group.
    DWORD  m_dwErrorExe;      // this is only used by the SxS group.

    CSearchGroup(SEARCH_GROUP_TYPE sgType, CSearchNode *psnHead);

public:
    CSearchGroup(SEARCH_GROUP_TYPE sgType, CSearchGroup *pNext, LPCSTR pszApp = NULL, LPCSTR pszDir = NULL);
    ~CSearchGroup();

    static CSearchGroup* CreateDefaultSearchOrder(LPCSTR pszApp = NULL);
    static CSearchGroup* CopySearchOrder(CSearchGroup *psgHead, LPCSTR pszApp = NULL);
    static bool          SaveSearchOrder(LPCSTR pszPath, CTreeCtrl *ptc);
    static bool          LoadSearchOrder(LPCSTR pszPath, CSearchGroup* &psgHead, LPCSTR pszApp = NULL);
    static void          DeleteSearchOrder(CSearchGroup* &psgHead);
    static CSearchNode*  CreateNode(LPCSTR pszPath, DWORD dwFlags = 0);
    static CSearchNode*  CreateFileNode(CSearchNode *psnHead, DWORD dwFlags, LPSTR pszPath, LPCSTR pszName = NULL);
    static LPCSTR        GetShortName(SEARCH_GROUP_TYPE sgType)
    {
        return ms_szShortNames[sgType];
    }

protected:
    static void DeleteNodeList(CSearchNode *&psn);

public:
    inline LPCSTR            GetName()      { return (m_sgType < SG_COUNT) ? ms_szGroups[m_sgType]     : "Unknown"; }
    inline LPCSTR            GetShortName() { return (m_sgType < SG_COUNT) ? ms_szShortNames[m_sgType] : "Unknown"; }
    inline bool              IsLinked()     { return m_pNext != SGF_NOT_LINKED; }
    inline CSearchGroup*     GetNext()      { return m_pNext; }
    inline SEARCH_GROUP_TYPE GetType()      { return m_sgType; }
    inline CSearchNode*      GetFirstNode() { return m_psnHead; }
    inline void              Unlink()       { m_pNext = SGF_NOT_LINKED; }

    inline DWORD             GetSxSManifestError() { return m_dwErrorManifest; }
    inline DWORD             GetSxSExeError()      { return m_dwErrorExe;      }

protected:
    CSearchNode* GetSysPath();
    CSearchNode* GetAppPath(LPCSTR pszApp);
    CSearchNode* ParsePath(LPSTR pszPath);
    CSearchNode* GetKnownDllsOn9x();
    CSearchNode* GetKnownDllsOnNT();
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __SEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by depends.rc
//
#define IDR_MODULE_TREE_VIEW            101
#define IDR_IMPORT_LIST_VIEW            102
#define IDR_EXPORT_LIST_VIEW            103
#define IDR_MODULE_LIST_VIEW            104
#define IDR_PROFILE_RICH_VIEW           105
#define IDR_COMMAND_LINE_HELP           106

#define IDR_MAINFRAME                   128
#define IDR_DEPENDTYPE                  129
#define IDR_POPUPS                      130
#define IDR_SEARCH                      131

#define IDR_DEPENDS_CNT                 140
#define IDR_DEPENDS_HLP                 141
#define IDR_DEPENDS_DLL                 142

#define IDB_TREE_MODULES                150
#define IDB_FUNCTIONS                   151
#define IDB_LIST_MODULES                152
#define IDB_SEARCH                      153

#define IDD_SYS_INFO                    160
#define IDD_SEARCH_ORDER                161
#define IDD_CONFIGURE_VIEWER            162
#define IDD_CONFIGURE_EXTERNAL_HELP     163
#define IDD_EXTENSIONS                  164
#define IDD_FILE_SEARCH                 165
#define IDD_PROFILE                     166
#define IDD_ABOUT                       167
#define IDD_SHUTDOWN                    168

#define IDC_ADD                         1001
#define IDC_ADD_DIRECTORY               1002
#define IDC_ANIMATE                     1003
#define IDC_ARGUMENTS                   1004
#define IDC_AVAILABLE_SEARCHES          1005
#define IDC_AVAILABLE_SEARCHES_TEXT     1006
#define IDC_BROWSE                      1007
#define IDC_COLLECTIONS                 1008
#define IDC_COMMAND                     1009
#define IDC_COPY                        1010
#define IDC_COPYRIGHT_STR               1011
#define IDC_CURRENT_ORDER               1012
#define IDC_CURRENT_ORDER_TEXT          1013
#define IDC_DEFAULT                     1014
#define IDC_DEFAULT_URL                 1015
#define IDC_DEVELOPER_STR               1016
#define IDC_DIRECTORY                   1017
#define IDC_DRIVES                      1018
#define IDC_EXPAND                      1019
#define IDC_EXT                         1020
#define IDC_EXTS                        1021
#define IDC_FULLPRODUCT_STR             1022
#define IDC_HOOK_PROCESS                1023
#define IDC_LOAD                        1024
#define IDC_LOG_CLEAR                   1025
#define IDC_LOG_DEBUG_OUTPUT            1026
#define IDC_LOG_DLLMAIN_OTHER_MSGS      1027
#define IDC_LOG_DLLMAIN_PROCESS_MSGS    1028
#define IDC_LOG_EXCEPTIONS              1029
#define IDC_LOG_GETPROCADDRESS_CALLS    1030
#define IDC_LOG_LOADLIBRARY_CALLS       1031
#define IDC_LOG_TIME_STAMPS             1032
#define IDC_LOG_THREADS                 1033
#define IDC_MOVE_DOWN                   1034
#define IDC_MOVE_UP                     1035
#define IDC_MSDN                        1036
#define IDC_ONLINE                      1037
#define IDC_PRODUCT_STR                 1038
#define IDC_PROFILE_CHILDREN            1039
#define IDC_REFRESH                     1040
#define IDC_REMOVE                      1041
#define IDC_RICHEDIT                    1042
#define IDC_SAVE                        1043
#define IDC_SEARCH                      1044
#define IDC_SELECT_ALL                  1045
#define IDC_SIMULATE_SHELLEXECUTE       1046
#define IDC_STOP                        1047
#define IDC_TIME_STAMP                  1048
#define IDC_URL                         1049
#define IDC_USE_FULL_PATHS              1050
#define IDC_USE_THREAD_INDEXES          1051
#define IDC_VERSION_STR                 1052

#define IDM_EDIT_LOG_CLEAR              32781
#define IDM_VIEW_SYS_INFO               32782
#define IDM_EXPAND_ALL                  32783
#define IDM_COLLAPSE_ALL                32784
#define IDM_AUTO_EXPAND                 32785
#define IDM_VIEW_FULL_PATHS             32786
#define IDM_VIEW_UNDECORATED            32787
#define IDM_SHOW_MATCHING_ITEM          32788
#define IDM_SHOW_ORIGINAL_MODULE        32789
#define IDM_SHOW_PREVIOUS_MODULE        32790
#define IDM_SHOW_NEXT_MODULE            32791
#define IDM_REFRESH                     32792
#define IDM_EXTERNAL_VIEWER             32793
#define IDM_EXTERNAL_HELP               32794
#define IDM_PROPERTIES                  32795
#define IDM_CONFIGURE_SEARCH_ORDER      32796
#define IDM_CONFIGURE_VIEWER            32797
#define IDM_CONFIGURE_EXTERNAL_HELP     32798
#define IDM_HANDLED_FILE_EXTS           32799
#define IDM_EXECUTE                     32800
#define IDM_TERMINATE                   32801

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        169
#define _APS_NEXT_COMMAND_VALUE         32802
#define _APS_NEXT_CONTROL_VALUE         1053
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\profview.h ===
//******************************************************************************
//
// File:        PROFVIEW.H
//
// Description: Definition file for the Runtime Profile Edit View.
//
// Classes:     CRichViewProfile
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __PROFVIEW_H__
#define __PROFVIEW_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CRichViewProfile
//******************************************************************************

class CRichViewProfile : public CCtrlView
{
// Internal variables
protected:
    bool  m_fIgnoreSelChange;
    bool  m_fCursorAtEnd;
    bool  m_fNewLine;
    CHAR  m_cPrev;

    CFindReplaceDialog *m_pDlgFind;
    CString             m_strFind;
    bool                m_fFindCase;
    bool                m_fFindWord;
    bool                m_fFirstSearch;
    long                m_lInitialSearchPos;

// Constructor/Destructor (serialization only)
protected:
    CRichViewProfile();
    virtual ~CRichViewProfile();
    DECLARE_DYNCREATE(CRichViewProfile)

// Public functions
public:
    CRichEditCtrl& GetRichEditCtrl() const
    {
        return *(CRichEditCtrl*)this;
    }
    
    void DeleteContents();
    void AddText(LPCSTR pszText, DWORD dwFlags, DWORD dwElapsed);

// Public static functions
public:
    static void AddTextToRichEdit(CRichEditCtrl *pRichEdit, LPCSTR pszText, DWORD dwFlags, bool fTimeStamps, bool *pfNewLine, CHAR *pcPrev, DWORD dwElapsed);
    static bool SaveToFile(CRichEditCtrl *pre, HANDLE hFile, SAVETYPE st);
    static bool ReadFromFile(CRichEditCtrl *pre, HANDLE hFile);

    static inline bool ReadLogClearSetting()        { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogClear",               0) ? true : false; } // inspected. MFC function
    static inline bool ReadSimulateShellExecute()   { return g_theApp.GetProfileInt(g_pszSettings, "ProfileSimulateShellExecute",   1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogDllMainProcessMsgs()  { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogDllMainProcessMsgs",  1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogDllMainOtherMsgs()    { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogDllMainOtherMsgs",    0) ? true : false; } // inspected. MFC function
    static inline bool ReadHookProcess()            { return g_theApp.GetProfileInt(g_pszSettings, "ProfileHookProcess",            1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogLoadLibraryCalls()    { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogLoadLibraryCalls",    1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogGetProcAddressCalls() { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogGetProcAddressCalls", 1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogThreads()             { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogThreads",             0) ? true : false; } // inspected. MFC function
    static inline bool ReadUseThreadIndexes()       { return g_theApp.GetProfileInt(g_pszSettings, "ProfileUseThreadIndexes",       1) ? true : false; } // inspected. MFC function
    static inline bool ReadLogExceptions()          { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogExceptions",          0) ? true : false; } // inspected. MFC function
    static inline bool ReadLogDebugOutput()         { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogDebugOutput",         1) ? true : false; } // inspected. MFC function
    static inline bool ReadUseFullPaths()           { return g_theApp.GetProfileInt(g_pszSettings, "ProfileUseFullPaths",           0) ? true : false; } // inspected. MFC function
    static inline bool ReadLogTimeStamps()          { return g_theApp.GetProfileInt(g_pszSettings, "ProfileLogTimeStamps",          0) ? true : false; } // inspected. MFC function
    static inline bool ReadChildren()               { return g_theApp.GetProfileInt(g_pszSettings, "ProfileChildren",               1) ? true : false; } // inspected. MFC function

    static inline void WriteLogClearSetting(bool fSet)        { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogClear",               fSet); }
    static inline void WriteSimulateShellExecute(bool fSet)   { g_theApp.WriteProfileInt(g_pszSettings, "ProfileSimulateShellExecute",   fSet); }
    static inline void WriteLogDllMainProcessMsgs(bool fSet)  { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogDllMainProcessMsgs",  fSet); }
    static inline void WriteLogDllMainOtherMsgs(bool fSet)    { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogDllMainOtherMsgs",    fSet); }
    static inline void WriteHookProcess(bool fSet)            { g_theApp.WriteProfileInt(g_pszSettings, "ProfileHookProcess",            fSet); }
    static inline void WriteLogLoadLibraryCalls(bool fSet)    { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogLoadLibraryCalls",    fSet); }
    static inline void WriteLogGetProcAddressCalls(bool fSet) { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogGetProcAddressCalls", fSet); }
    static inline void WriteLogThreads(bool fSet)             { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogThreads",             fSet); }
    static inline void WriteUseThreadIndexes(bool fSet)       { g_theApp.WriteProfileInt(g_pszSettings, "ProfileUseThreadIndexes",       fSet); }
    static inline void WriteLogExceptions(bool fSet)          { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogExceptions",          fSet); }
    static inline void WriteLogDebugOutput(bool fSet)         { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogDebugOutput",         fSet); }
    static inline void WriteUseFullPaths(bool fSet)           { g_theApp.WriteProfileInt(g_pszSettings, "ProfileUseFullPaths",           fSet); }
    static inline void WriteLogTimeStamps(bool fSet)          { g_theApp.WriteProfileInt(g_pszSettings, "ProfileLogTimeStamps",          fSet); }
    static inline void WriteChildren(bool fSet)               { g_theApp.WriteProfileInt(g_pszSettings, "ProfileChildren",               fSet); }

// Internal static functions
protected:
    BOOL FindText();
    void TextNotFound();
    void AdjustDialogPosition();

    static void           AddTextToRichEdit2(CRichEditCtrl *pRichEdit, LPCSTR pszText, DWORD dwFlags);
    static DWORD CALLBACK EditStreamWriteCallback(DWORD_PTR dwpCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);
    static DWORD CALLBACK EditStreamReadCallback(DWORD_PTR dwpCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

// Internal functions
protected:
    inline CDocDepends* GetDocument() { return (CDocDepends*)m_pDocument; }

// Overridden functions
public:
    //{{AFX_VIRTUAL(CRichViewProfile)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnInitialUpdate();
    //}}AFX_VIRTUAL

// Event handler functions
protected:
    //{{AFX_MSG(CRichViewProfile)
    afx_msg void OnDestroy();
    afx_msg void OnSelChange(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateEditFind(CCmdUI* pCmdUI);
    afx_msg void OnEditFind();
    afx_msg void OnUpdateEditRepeat(CCmdUI* pCmdUI);
    afx_msg void OnEditRepeat();
    //}}AFX_MSG
    afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
public:
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __PROFVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\splitter.cpp ===
//******************************************************************************
//
// File:        SPLITTER.CPP
//
// Description: Implementation file for the CSmartSplitter class.
//
// Classes:     CSmartSplitter
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "splitter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//******************************************************************************
//***** CSmartSplitter
//******************************************************************************

BEGIN_MESSAGE_MAP(CSmartSplitter, CSplitterWnd)
    //{{AFX_MSG_MAP(CSmartSplitter)
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//******************************************************************************
CSmartSplitter::CSmartSplitter() :
    m_fVertical(FALSE),
    m_dwRatio(5000)
{
}

//******************************************************************************
CSmartSplitter::~CSmartSplitter()
{
}

//******************************************************************************
BOOL CSmartSplitter::CreateStatic(CWnd *pParentWnd, int nRows, int nCols, DWORD dwRatio,
                                  DWORD dwStyle /* = WS_CHILD | WS_VISIBLE */,
                                  UINT nID /* = AFX_IDW_PANE_FIRST */)
{
    m_fVertical = (nCols > nRows);
    m_dwRatio = dwRatio;
    return CSplitterWnd::CreateStatic(pParentWnd, nRows, nCols, dwStyle, nID);
}

//******************************************************************************
void CSmartSplitter::StopTracking(BOOL bAccept)
{
    // Call base class.
    CSplitterWnd::StopTracking(bAccept);

    // Check to see if this was a real update of our splitter location.
    if (bAccept)
    {
        int cur, min, client;

        // get our client rectangle.
        CRect rcClient;
        GetClientRect(&rcClient);

        // Get our splitter location
        if (m_fVertical)
        {
            GetColumnInfo(0, cur, min);
            client = rcClient.Width();
        }
        else
        {
            GetRowInfo(0, cur, min);
            client = rcClient.Height();
        }

        // Calculate the splitter location as a ratio of the client area.
        m_dwRatio = (client > 0) ? ((cur * 10000 + 9999) / client) : 0;
    }
}

//******************************************************************************
void CSmartSplitter::OnSize(UINT nType, int cx, int cy)
{
    if (m_pRowInfo)
    {
        if (m_fVertical)
        {
            SetColumnInfo(0, (cx * m_dwRatio) / 10000, 0);
        }
        else
        {
            SetRowInfo(0, (cy * m_dwRatio) / 10000, 0);
        }
        RecalcLayout();
    }
    CSplitterWnd::OnSize(nType, cx, cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\stdafx.cpp ===
//******************************************************************************
//
// File:        STDAFX.CPP
//
// Description: Source file that includes just the standard includes found in
//              STDAFX.H.  When compiled, this file will create our precompiled
//              header file DEPENDS.PCH.
//
// Classes:     None
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\vshelp.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Jun 03 22:40:16 2001
 */
/* Compiler settings for C:\TEMP\IDL7E.tmp:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_VsHelp = {0x83285928,0x227C,0x11D3,{0xB8,0x70,0x00,0xC0,0x4F,0x79,0xF8,0x02}};


const IID IID_IVsHelpOwner = {0xB9B0983A,0x364C,0x4866,{0x87,0x3F,0xD5,0xED,0x19,0x01,0x38,0xFB}};


const IID IID_IVsHelpTopicShowEvents = {0xD1AAC64A,0x6A25,0x4274,{0xB2,0xC6,0xBC,0x3B,0x84,0x0B,0x6E,0x54}};


const IID IID_Help = {0x4A791148,0x19E4,0x11D3,{0xB8,0x6B,0x00,0xC0,0x4F,0x79,0xF8,0x02}};


const IID IID_IVsHelpEvents = {0x507E4490,0x5A8C,0x11D3,{0xB8,0x97,0x00,0xC0,0x4F,0x79,0xF8,0x02}};


const CLSID CLSID_DExploreAppObj = {0x4A79114D,0x19E4,0x11D3,{0xB8,0x6B,0x00,0xC0,0x4F,0x79,0xF8,0x02}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\splitter.h ===
//******************************************************************************
//
// File:        SPLITTER.H
//
// Description: Definition file for the CSmartSplitter class.
//
// Classes:     CSmartSplitter
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __SPLITTER_H__
#define __SPLITTER_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** CSmartSplitter window
//******************************************************************************

class CSmartSplitter : public CSplitterWnd
{
protected:
    BOOL  m_fVertical;
    DWORD m_dwRatio;

public:
    CSmartSplitter();
    BOOL CreateStatic(CWnd *pParentWnd, int nRows, int nCols, DWORD dwRatio,
                      DWORD dwStyle = WS_CHILD | WS_VISIBLE,
                      UINT nID = AFX_IDW_PANE_FIRST);

public:
    //{{AFX_VIRTUAL(CSmartSplitter)
    //}}AFX_VIRTUAL

public:
    virtual ~CSmartSplitter();

protected:
    virtual void StopTracking(BOOL bAccept);

protected:
    //{{AFX_MSG(CSmartSplitter)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __SPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\vshelp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Jun 03 22:40:08 2001
 */
/* Compiler settings for C:\TEMP\IDL75.tmp:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __vshelp_h__
#define __vshelp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpOwner_FWD_DEFINED__
#define __IVsHelpOwner_FWD_DEFINED__
typedef interface IVsHelpOwner IVsHelpOwner;
#endif  /* __IVsHelpOwner_FWD_DEFINED__ */


#ifndef __IVsHelpTopicShowEvents_FWD_DEFINED__
#define __IVsHelpTopicShowEvents_FWD_DEFINED__
typedef interface IVsHelpTopicShowEvents IVsHelpTopicShowEvents;
#endif  /* __IVsHelpTopicShowEvents_FWD_DEFINED__ */


#ifndef __Help_FWD_DEFINED__
#define __Help_FWD_DEFINED__
typedef interface Help Help;
#endif  /* __Help_FWD_DEFINED__ */


#ifndef __IVsHelpEvents_FWD_DEFINED__
#define __IVsHelpEvents_FWD_DEFINED__
typedef interface IVsHelpEvents IVsHelpEvents;
#endif  /* __IVsHelpEvents_FWD_DEFINED__ */


#ifndef __DExploreAppObj_FWD_DEFINED__
#define __DExploreAppObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class DExploreAppObj DExploreAppObj;
#else
typedef struct DExploreAppObj DExploreAppObj;
#endif /* __cplusplus */

#endif  /* __DExploreAppObj_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __VsHelp_LIBRARY_DEFINED__
#define __VsHelp_LIBRARY_DEFINED__

/* library VsHelp */
/* [version][uuid] */ 






EXTERN_C const IID LIBID_VsHelp;

#ifndef __IVsHelpOwner_INTERFACE_DEFINED__
#define __IVsHelpOwner_INTERFACE_DEFINED__

/* interface IVsHelpOwner */
/* [object][oleautomation][dual][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IVsHelpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9B0983A-364C-4866-873F-D5ED190138FB")
    IVsHelpOwner : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BringHelpToTop( 
            /* [in] */ long hwndHelpApp) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutomationObject( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IVsHelpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpOwner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringHelpToTop )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [in] */ long hwndHelpApp);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutomationObject )( 
            IVsHelpOwner __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);
        
        END_INTERFACE
    } IVsHelpOwnerVtbl;

    interface IVsHelpOwner
    {
        CONST_VTBL struct IVsHelpOwnerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpOwner_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpOwner_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpOwner_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IVsHelpOwner_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVsHelpOwner_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVsHelpOwner_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVsHelpOwner_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVsHelpOwner_BringHelpToTop(This,hwndHelpApp)   \
    (This)->lpVtbl -> BringHelpToTop(This,hwndHelpApp)

#define IVsHelpOwner_get_AutomationObject(This,ppObj)   \
    (This)->lpVtbl -> get_AutomationObject(This,ppObj)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVsHelpOwner_BringHelpToTop_Proxy( 
    IVsHelpOwner __RPC_FAR * This,
    /* [in] */ long hwndHelpApp);


void __RPC_STUB IVsHelpOwner_BringHelpToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IVsHelpOwner_get_AutomationObject_Proxy( 
    IVsHelpOwner __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);


void __RPC_STUB IVsHelpOwner_get_AutomationObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IVsHelpOwner_INTERFACE_DEFINED__ */


#ifndef __IVsHelpTopicShowEvents_INTERFACE_DEFINED__
#define __IVsHelpTopicShowEvents_INTERFACE_DEFINED__

/* interface IVsHelpTopicShowEvents */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsHelpTopicShowEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1AAC64A-6A25-4274-B2C6-BC3B840B6E54")
    IVsHelpTopicShowEvents : public IDispatch
    {
    public:
        virtual HRESULT __stdcall OnBeforeTopicShow( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ IDispatch __RPC_FAR *pWB) = 0;
        
        virtual HRESULT __stdcall OnTopicShowComplete( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ IDispatch __RPC_FAR *pWB) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IVsHelpTopicShowEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpTopicShowEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpTopicShowEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( __stdcall __RPC_FAR *OnBeforeTopicShow )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ IDispatch __RPC_FAR *pWB);
        
        HRESULT ( __stdcall __RPC_FAR *OnTopicShowComplete )( 
            IVsHelpTopicShowEvents __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ IDispatch __RPC_FAR *pWB);
        
        END_INTERFACE
    } IVsHelpTopicShowEventsVtbl;

    interface IVsHelpTopicShowEvents
    {
        CONST_VTBL struct IVsHelpTopicShowEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpTopicShowEvents_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpTopicShowEvents_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpTopicShowEvents_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IVsHelpTopicShowEvents_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVsHelpTopicShowEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVsHelpTopicShowEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVsHelpTopicShowEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVsHelpTopicShowEvents_OnBeforeTopicShow(This,bstrURL,pWB)  \
    (This)->lpVtbl -> OnBeforeTopicShow(This,bstrURL,pWB)

#define IVsHelpTopicShowEvents_OnTopicShowComplete(This,bstrURL,pWB)    \
    (This)->lpVtbl -> OnTopicShowComplete(This,bstrURL,pWB)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT __stdcall IVsHelpTopicShowEvents_OnBeforeTopicShow_Proxy( 
    IVsHelpTopicShowEvents __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ IDispatch __RPC_FAR *pWB);


void __RPC_STUB IVsHelpTopicShowEvents_OnBeforeTopicShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IVsHelpTopicShowEvents_OnTopicShowComplete_Proxy( 
    IVsHelpTopicShowEvents __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ IDispatch __RPC_FAR *pWB);


void __RPC_STUB IVsHelpTopicShowEvents_OnTopicShowComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IVsHelpTopicShowEvents_INTERFACE_DEFINED__ */


#ifndef __Help_INTERFACE_DEFINED__
#define __Help_INTERFACE_DEFINED__

/* interface Help */
/* [object][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_Help;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A791148-19E4-11D3-B86B-00C04F79F802")
    Help : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Contents( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Index( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Search( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IndexResults( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SearchResults( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromId( 
            /* [in] */ BSTR bstrFile,
            /* [in] */ unsigned long Id) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURL( 
            /* [in] */ BSTR pszURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURLEx( 
            /* [in] */ BSTR pszURL,
            /* [in] */ IVsHelpTopicShowEvents __RPC_FAR *pIVsHelpTopicShowEvents) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromKeyword( 
            /* [in] */ BSTR pszKeyword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromF1Keyword( 
            /* [in] */ BSTR pszKeyword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DisplayTopicFrom_OLD_Help( 
            /* [in] */ BSTR bstrFile,
            /* [in] */ unsigned long Id) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SyncContents( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanSyncContents( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNextTopic( 
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNext) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPrevTopic( 
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPrev) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FilterUI( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanShowFilterUI( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SyncIndex( 
            /* [in] */ BSTR bstrKeyword,
            /* [in] */ long fShow) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetCollection( 
            /* [in] */ BSTR bstrCollection,
            /* [in] */ BSTR bstrFilter) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCollection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilter) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ BSTR pbstrFilter) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FilterQuery( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterQuery) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HelpOwner( 
            /* [retval][out] */ IVsHelpOwner __RPC_FAR *__RPC_FAR *ppObj) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_HelpOwner( 
            /* [in] */ IVsHelpOwner __RPC_FAR *ppObj) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HxSession( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Help( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR bstrMoniker,
            /* [in] */ BSTR bstrOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct HelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Help __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Help __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Help __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Help __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Help __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Help __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Help __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Contents )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Index )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Search )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IndexResults )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SearchResults )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromId )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrFile,
            /* [in] */ unsigned long Id);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromURL )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR pszURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromURLEx )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR pszURL,
            /* [in] */ IVsHelpTopicShowEvents __RPC_FAR *pIVsHelpTopicShowEvents);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromKeyword )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR pszKeyword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromF1Keyword )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR pszKeyword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFrom_OLD_Help )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrFile,
            /* [in] */ unsigned long Id);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SyncContents )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanSyncContents )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextTopic )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNext);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPrevTopic )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPrev);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterUI )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanShowFilterUI )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            Help __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SyncIndex )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrKeyword,
            /* [in] */ long fShow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCollection )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrCollection,
            /* [in] */ BSTR bstrFilter);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Collection )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filter )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilter);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Filter )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR pbstrFilter);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilterQuery )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterQuery);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpOwner )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ IVsHelpOwner __RPC_FAR *__RPC_FAR *ppObj);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HelpOwner )( 
            Help __RPC_FAR * This,
            /* [in] */ IVsHelpOwner __RPC_FAR *ppObj);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HxSession )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Help )( 
            Help __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObject )( 
            Help __RPC_FAR * This,
            /* [in] */ BSTR bstrMoniker,
            /* [in] */ BSTR bstrOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        END_INTERFACE
    } HelpVtbl;

    interface Help
    {
        CONST_VTBL struct HelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Help_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Help_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define Help_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define Help_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Help_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Help_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Help_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Help_Contents(This) \
    (This)->lpVtbl -> Contents(This)

#define Help_Index(This)    \
    (This)->lpVtbl -> Index(This)

#define Help_Search(This)   \
    (This)->lpVtbl -> Search(This)

#define Help_IndexResults(This) \
    (This)->lpVtbl -> IndexResults(This)

#define Help_SearchResults(This)    \
    (This)->lpVtbl -> SearchResults(This)

#define Help_DisplayTopicFromId(This,bstrFile,Id)   \
    (This)->lpVtbl -> DisplayTopicFromId(This,bstrFile,Id)

#define Help_DisplayTopicFromURL(This,pszURL)   \
    (This)->lpVtbl -> DisplayTopicFromURL(This,pszURL)

#define Help_DisplayTopicFromURLEx(This,pszURL,pIVsHelpTopicShowEvents) \
    (This)->lpVtbl -> DisplayTopicFromURLEx(This,pszURL,pIVsHelpTopicShowEvents)

#define Help_DisplayTopicFromKeyword(This,pszKeyword)   \
    (This)->lpVtbl -> DisplayTopicFromKeyword(This,pszKeyword)

#define Help_DisplayTopicFromF1Keyword(This,pszKeyword) \
    (This)->lpVtbl -> DisplayTopicFromF1Keyword(This,pszKeyword)

#define Help_DisplayTopicFrom_OLD_Help(This,bstrFile,Id)    \
    (This)->lpVtbl -> DisplayTopicFrom_OLD_Help(This,bstrFile,Id)

#define Help_SyncContents(This,bstrURL) \
    (This)->lpVtbl -> SyncContents(This,bstrURL)

#define Help_CanSyncContents(This,bstrURL)  \
    (This)->lpVtbl -> CanSyncContents(This,bstrURL)

#define Help_GetNextTopic(This,bstrURL,pbstrNext)   \
    (This)->lpVtbl -> GetNextTopic(This,bstrURL,pbstrNext)

#define Help_GetPrevTopic(This,bstrURL,pbstrPrev)   \
    (This)->lpVtbl -> GetPrevTopic(This,bstrURL,pbstrPrev)

#define Help_FilterUI(This) \
    (This)->lpVtbl -> FilterUI(This)

#define Help_CanShowFilterUI(This)  \
    (This)->lpVtbl -> CanShowFilterUI(This)

#define Help_Close(This)    \
    (This)->lpVtbl -> Close(This)

#define Help_SyncIndex(This,bstrKeyword,fShow)  \
    (This)->lpVtbl -> SyncIndex(This,bstrKeyword,fShow)

#define Help_SetCollection(This,bstrCollection,bstrFilter)  \
    (This)->lpVtbl -> SetCollection(This,bstrCollection,bstrFilter)

#define Help_get_Collection(This,pbstrCollection)   \
    (This)->lpVtbl -> get_Collection(This,pbstrCollection)

#define Help_get_Filter(This,pbstrFilter)   \
    (This)->lpVtbl -> get_Filter(This,pbstrFilter)

#define Help_put_Filter(This,pbstrFilter)   \
    (This)->lpVtbl -> put_Filter(This,pbstrFilter)

#define Help_get_FilterQuery(This,pbstrFilterQuery) \
    (This)->lpVtbl -> get_FilterQuery(This,pbstrFilterQuery)

#define Help_get_HelpOwner(This,ppObj)  \
    (This)->lpVtbl -> get_HelpOwner(This,ppObj)

#define Help_put_HelpOwner(This,ppObj)  \
    (This)->lpVtbl -> put_HelpOwner(This,ppObj)

#define Help_get_HxSession(This,ppObj)  \
    (This)->lpVtbl -> get_HxSession(This,ppObj)

#define Help_get_Help(This,ppObj)   \
    (This)->lpVtbl -> get_Help(This,ppObj)

#define Help_GetObject(This,bstrMoniker,bstrOptions,ppDisp) \
    (This)->lpVtbl -> GetObject(This,bstrMoniker,bstrOptions,ppDisp)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE Help_Contents_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_Index_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_Search_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_Search_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_IndexResults_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_IndexResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_SearchResults_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_SearchResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFromId_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrFile,
    /* [in] */ unsigned long Id);


void __RPC_STUB Help_DisplayTopicFromId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFromURL_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR pszURL);


void __RPC_STUB Help_DisplayTopicFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFromURLEx_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR pszURL,
    /* [in] */ IVsHelpTopicShowEvents __RPC_FAR *pIVsHelpTopicShowEvents);


void __RPC_STUB Help_DisplayTopicFromURLEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFromKeyword_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR pszKeyword);


void __RPC_STUB Help_DisplayTopicFromKeyword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFromF1Keyword_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR pszKeyword);


void __RPC_STUB Help_DisplayTopicFromF1Keyword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_DisplayTopicFrom_OLD_Help_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrFile,
    /* [in] */ unsigned long Id);


void __RPC_STUB Help_DisplayTopicFrom_OLD_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_SyncContents_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB Help_SyncContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_CanSyncContents_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB Help_CanSyncContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_GetNextTopic_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrNext);


void __RPC_STUB Help_GetNextTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_GetPrevTopic_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPrev);


void __RPC_STUB Help_GetPrevTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_FilterUI_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_FilterUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_CanShowFilterUI_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_CanShowFilterUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_Close_Proxy( 
    Help __RPC_FAR * This);


void __RPC_STUB Help_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_SyncIndex_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrKeyword,
    /* [in] */ long fShow);


void __RPC_STUB Help_SyncIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_SetCollection_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrCollection,
    /* [in] */ BSTR bstrFilter);


void __RPC_STUB Help_SetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_Collection_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCollection);


void __RPC_STUB Help_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_Filter_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFilter);


void __RPC_STUB Help_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE Help_put_Filter_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR pbstrFilter);


void __RPC_STUB Help_put_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_FilterQuery_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterQuery);


void __RPC_STUB Help_get_FilterQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_HelpOwner_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ IVsHelpOwner __RPC_FAR *__RPC_FAR *ppObj);


void __RPC_STUB Help_get_HelpOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE Help_put_HelpOwner_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ IVsHelpOwner __RPC_FAR *ppObj);


void __RPC_STUB Help_put_HelpOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_HxSession_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);


void __RPC_STUB Help_get_HxSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE Help_get_Help_Proxy( 
    Help __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObj);


void __RPC_STUB Help_get_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Help_GetObject_Proxy( 
    Help __RPC_FAR * This,
    /* [in] */ BSTR bstrMoniker,
    /* [in] */ BSTR bstrOptions,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB Help_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __Help_INTERFACE_DEFINED__ */


#ifndef __IVsHelpEvents_INTERFACE_DEFINED__
#define __IVsHelpEvents_INTERFACE_DEFINED__

/* interface IVsHelpEvents */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IVsHelpEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("507E4490-5A8C-11D3-B897-00C04F79F802")
    IVsHelpEvents : public IDispatch
    {
    public:
        virtual HRESULT __stdcall OnFilterChanged( 
            /* [in] */ BSTR bstrNewFilter) = 0;
        
        virtual HRESULT __stdcall OnCollectionChanged( 
            /* [in] */ BSTR bstrNewCollection,
            /* [in] */ BSTR bstrNewFilter) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IVsHelpEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( __stdcall __RPC_FAR *OnFilterChanged )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ BSTR bstrNewFilter);
        
        HRESULT ( __stdcall __RPC_FAR *OnCollectionChanged )( 
            IVsHelpEvents __RPC_FAR * This,
            /* [in] */ BSTR bstrNewCollection,
            /* [in] */ BSTR bstrNewFilter);
        
        END_INTERFACE
    } IVsHelpEventsVtbl;

    interface IVsHelpEvents
    {
        CONST_VTBL struct IVsHelpEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpEvents_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpEvents_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpEvents_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IVsHelpEvents_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVsHelpEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVsHelpEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVsHelpEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVsHelpEvents_OnFilterChanged(This,bstrNewFilter)   \
    (This)->lpVtbl -> OnFilterChanged(This,bstrNewFilter)

#define IVsHelpEvents_OnCollectionChanged(This,bstrNewCollection,bstrNewFilter) \
    (This)->lpVtbl -> OnCollectionChanged(This,bstrNewCollection,bstrNewFilter)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT __stdcall IVsHelpEvents_OnFilterChanged_Proxy( 
    IVsHelpEvents __RPC_FAR * This,
    /* [in] */ BSTR bstrNewFilter);


void __RPC_STUB IVsHelpEvents_OnFilterChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IVsHelpEvents_OnCollectionChanged_Proxy( 
    IVsHelpEvents __RPC_FAR * This,
    /* [in] */ BSTR bstrNewCollection,
    /* [in] */ BSTR bstrNewFilter);


void __RPC_STUB IVsHelpEvents_OnCollectionChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IVsHelpEvents_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DExploreAppObj;

#ifdef __cplusplus

class DECLSPEC_UUID("4A79114D-19E4-11D3-B86B-00C04F79F802")
DExploreAppObj;
#endif
#endif /* __VsHelp_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\session.h ===
//******************************************************************************
//
// File:        SESSION.H
//
// Description: Definition file for the Session class and all classes used by
//              it including the Module class, its Data class, and the Function
//              class.  The Session object is the a UI-free object that contains
//              all the information for a given session.
//
// Classes:     CSession
//              CModule
//              CModuleData
//              CModuleDataNode
//              CFunction
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created  (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __SESSION_H__
#define __SESSION_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//****** Constants and Macros
//******************************************************************************

// Our signature for our DWI files.
#define DWI_SIGNATURE              0x00495744 // "DWI\0"

// DWI File Revision History
//
// 0xFFFF  2.0 Beta 2 (first version to support DWI files)
// 0xFFFE  2.0 Beta 3 (added 64-bit fields for Win64 binaries)
// 0xFFFD  2.0 Beta 4 (added DWFF_EXPORT, search path, and more)
// 0xFFFC  2.0 Beta 4 (private release (added module checksums)
// 0xFFFB  2.0 Beta 4 (private release for MikeB and others (rich text log))
// 0xFFFA  2.0 Beta 5 (lots of flag changes)
// 0xFFF9  2.0 Beta 5 (did some private builds for people)
// 0xFFF8  2.0 Beta 6 (added a bunch of stuff to SYSINFO, port to 64-bit)
// 0xFFF7  2.0 Beta 6 (private release)
// 0xFFF6  use for next beta
// 0x0001  2.0 and 2.1 Released
// 0x0002  use for next release
#define DWI_FILE_REVISION          ((WORD)0x0001)

// PDB signature found in a CODEVIEW debug block.
#define PDB_SIGNATURE              0x3031424E // "NB10"

// Log flags.
#define LOG_TIME_STAMP             0x00000001
#define LOG_RED                    0x00000002
#define LOG_GRAY                   0x00000004
#define LOG_BOLD                   0x00000008
#define LOG_APPEND                 0x00000010
#define LOG_ERROR                  (LOG_RED  | LOG_BOLD)
#define LOG_DEBUG                  (LOG_GRAY | LOG_APPEND)

// Binary type flags.
#define NE_UNKNOWN                 ((WORD)0x0000)  // Unknown (any "new-format" OS)
#define NE_OS2                     ((WORD)0x0001)  // Microsoft/IBM OS/2 (default)
#define NE_WINDOWS                 ((WORD)0x0002)  // Microsoft Windows
#define NE_DOS4                    ((WORD)0x0003)  // Microsoft MS-DOS 4.x
#define NE_DEV386                  ((WORD)0x0004)  // Microsoft Windows 386

// Dependency Walker Session Flags (ATO = At Least One)
#define DWSF_DWI                   0x00000001
#define DWSF_64BIT_ALO             0x00000002

// Dependency Walker Module Flags (ATO = At Least One)
#define DWMF_IMPLICIT              0x00000000
#define DWMF_IMPLICIT_ALO          0x00000001
#define DWMF_FORWARDED             0x00000002
#define DWMF_FORWARDED_ALO         0x00000004 //!! We set this flag, but never read it.
#define DWMF_DELAYLOAD             0x00000008
#define DWMF_DELAYLOAD_ALO         0x00000010
#define DWMF_DYNAMIC               0x00000020
#define DWMF_DYNAMIC_ALO           0x00000040
#define DWMF_MODULE_ERROR          0x00000080
#define DWMF_MODULE_ERROR_ALO      0x00000100
#define DWMF_NO_RESOLVE            0x00000200
#define DWMF_NO_RESOLVE_CORE       0x00000400
#define DWMF_DATA_FILE_CORE        0x00000800
#define DWMF_VERSION_INFO          0x00001000
#define DWMF_64BIT                 0x00002000
#define DWMF_DUPLICATE             0x00004000
#define DWMF_LOADED                0x00008000
#define DWMF_ERROR_MESSAGE         0x00010000
#define DWMF_WRONG_CPU             0x00020000
#define DWMF_FORMAT_NOT_PE         0x00040000
#define DWMF_FILE_NOT_FOUND        0x00080000
#define DWMF_ORPHANED              0x00100000

// Dependency Walker Update Flags
#define DWUF_TREE_IMAGE            0x00000001
#define DWUF_LIST_IMAGE            0x00000002
#define DWUF_ACTUAL_BASE           0x00000004
#define DWUF_LOAD_ORDER            0x00000008

// Dependency Walker Function Flags
#define DWFF_EXPORT                0x00000001
#define DWFF_ORDINAL               0x00000002
#define DWFF_HINT                  0x00000004
#define DWFF_NAME                  0x00000008
#define DWFF_ADDRESS               0x00000010
#define DWFF_FORWARDED             0x00000020
#define DWFF_64BIT                 0x00000040
#define DWFF_RESOLVED              0x00000080
#define DWFF_CALLED                DWFF_RESOLVED
#define DWFF_DYNAMIC               0x00000100
#define DWFF_CALLED_ALO            0x00000200
#define DWFF_32BITS_USED           0x00004000
#define DWFF_64BITS_USED           0x00008000

// Dependency Walker Symbol Flags
#define DWSF_INVALID               0x00000001
#define DWSF_DBG                   0x00000002
#define DWSF_COFF                  0x00000004
#define DWSF_CODEVIEW              0x00000008
#define DWSF_PDB                   0x00000010
#define DWSF_FPO                   0x00000020
#define DWSF_OMAP                  0x00000040
#define DWSF_BORLAND               0x00000080
#define DWSF_UNKNOWN               0x80000000
#define DWSF_MASK                  0x000000FF

// FindModule() flags
#define FMF_RECURSE                0x00000001
#define FMF_ORIGINAL               0x00000002
#define FMF_DUPLICATE              0x00000004
#define FMF_SIBLINGS               0x00000008
#define FMF_LOADED                 0x00000010
#define FMF_NEVER_LOADED           0x00000020
#define FMF_EXPLICIT_ONLY          0x00000040
#define FMF_FORWARD_ONLY           0x00000080
#define FMF_ADDRESS                0x00000100
#define FMF_PATH                   0x00000200
#define FMF_FILE                   0x00000400
#define FMF_FILE_NO_EXT            0x00000800
#define FMF_MODULE                 0x00001000
#define FMF_EXCLUDE_TREE           0x00002000

// Dependency Walker Profile Update Type
#define DWPU_ARGUMENTS                      1
#define DWPU_DIRECTORY                      2
#define DWPU_SEARCH_PATH                    3
#define DWPU_UPDATE_ALL                     4
#define DWPU_UPDATE_MODULE                  5
#define DWPU_ADD_TREE                       6
#define DWPU_REMOVE_TREE                    7
#define DWPU_ADD_IMPORT                     8
#define DWPU_EXPORTS_CHANGED                9
#define DWPU_CHANGE_ORIGINAL               10
#define DWPU_LOG                           11
#define DWPU_PROFILE_DONE                  12

//******************************************************************************
//****** Types and Structure
//******************************************************************************

typedef void (CALLBACK *PFN_PROFILEUPDATE)(DWORD_PTR dwpCookie, DWORD dwType, DWORD_PTR dwpParam1, DWORD_PTR dwpParam2);

// The structure passed along with a DWPU_LOG message.
typedef struct _DWPU_LOG_STRUCT
{
    DWORD dwFlags;
    DWORD dwElapsed;
} DWPU_LOG_STRUCT, *PDWPU_LOG_STRUCT;

// Make sure we have consistent packing for anything we save/load to disk.
#pragma pack(push, 4)

typedef struct _DWI_HEADER
{
    DWORD dwSignature;
    WORD  wFileRevision;
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    WORD  wBuildVersion;
    WORD  wPatchVersion;
    WORD  wBetaVersion;
} DWI_HEADER, *PDWI_HEADER;

typedef struct _DISK_SESSION
{
    DWORD dwSessionFlags;
    DWORD dwReturnFlags;
    DWORD dwMachineType;
    DWORD dwNumSearchGroups;
    DWORD dwNumModuleDatas;
    DWORD dwNumModules;
} DISK_SESSION, *PDISK_SESSION;

typedef struct _DISK_SEARCH_GROUP
{
    WORD wType;
    WORD wNumDirNodes;
} DISK_SEARCH_GROUP, *PDISK_SEARCH_GROUP;

typedef struct _DISK_SEARCH_NODE
{
    DWORD dwFlags;
} DISK_SEARCH_NODE, *PDISK_SEARCH_NODE;

typedef struct _DISK_MODULE_DATA
{
    DWORDLONG dwlKey;
    DWORD     dwNumExports;
    DWORD     dwFlags;
    DWORD     dwSymbolFlags;
    DWORD     dwCharacteristics;
    FILETIME  ftFileTimeStamp;
    FILETIME  ftLinkTimeStamp;
    DWORD     dwFileSize;
    DWORD     dwAttributes;
    DWORD     dwMachineType;
    DWORD     dwLinkCheckSum;
    DWORD     dwRealCheckSum;
    DWORD     dwSubsystemType;
    DWORDLONG dwlPreferredBaseAddress;
    DWORDLONG dwlActualBaseAddress;
    DWORD     dwVirtualSize;
    DWORD     dwLoadOrder;
    DWORD     dwImageVersion;
    DWORD     dwLinkerVersion;
    DWORD     dwOSVersion;
    DWORD     dwSubsystemVersion;
    DWORD     dwFileVersionMS;
    DWORD     dwFileVersionLS;
    DWORD     dwProductVersionMS;
    DWORD     dwProductVersionLS;
} DISK_MODULE_DATA, *PDISK_MODULE_DATA;

typedef struct _DISK_MODULE
{
    DWORDLONG dwlModuleDataKey;
    DWORD     dwNumImports;
    DWORD     dwFlags;
    DWORD     dwDepth;
} DISK_MODULE, *PDISK_MODULE;

typedef struct _DISK_FUNCTION
{
    DWORD     dwFlags;
    WORD      wOrdinal;
    WORD      wHint;
} DISK_FUNCTION, *PDISK_FUNCTION;

// Restore our packing.
#pragma pack(pop)


//******************************************************************************
//****** Forward Declarations
//******************************************************************************

class CModule;
class CModuleData;
class CModuleDataNode;
class CFunction;


//******************************************************************************
//***** CSession
//******************************************************************************

class CSession
{
friend class CProcess;

// Internal variables
protected:
    PFN_PROFILEUPDATE m_pfnProfileUpdate;
    DWORD_PTR         m_dwpProfileUpdateCookie;

    // The following 9 members contain information about the currently opened
    // module file. We can store them here in our session since there is never
    // a time when two files are open at once.
    HANDLE                 m_hFile;
    DWORD                  m_dwSize;
    bool                   m_fCloseFileHandle;
    HANDLE                 m_hMap;
    LPCVOID                m_lpvFile;
    bool                   m_f64Bit;
    PIMAGE_FILE_HEADER     m_pIFH;
    PIMAGE_OPTIONAL_HEADER m_pIOH;
    PIMAGE_SECTION_HEADER  m_pISH;

    // User defined value.
    DWORD_PTR m_dwpUserData;

    // Allocated for DWI files.
    SYSINFO  *m_pSysInfo;

    // A combination of our DWSF_??? flags.
    DWORD     m_dwFlags;

    // A combination of our DWRF_??? flags.
    DWORD     m_dwReturnFlags;

    // Main machine type of all modules.
    DWORD     m_dwMachineType;

    DWORD     m_dwModules;

    // Incremented as each module is processed.
    DWORD     m_dwLoadOrder;

    DWORD_PTR m_dwpDWInjectBase;
    DWORD     m_dwDWInjectSize;

    CModule  *m_pModuleRoot;

    // Used during dynamic module loads to help search algorithm find dependent modules.
    CEventLoadDll *m_pEventLoadDllPending;
 
    LPCSTR    m_pszReadError;
    LPCSTR    m_pszExceptionError;

    bool      m_fInitialBreakpoint;

    DWORD     m_dwProfileFlags;

public:
    CProcess     *m_pProcess;
    CSearchGroup *m_psgHead;

public:
    CSession(PFN_PROFILEUPDATE pfnProfileUpdate, DWORD_PTR dwpCookie);
    ~CSession();

    inline DWORD_PTR GetUserData()        { return m_dwpUserData; }
    inline void      SetUserData(DWORD_PTR dwpUserData) { m_dwpUserData = dwpUserData; }
    inline SYSINFO*  GetSysInfo()         { return m_pSysInfo; }
    inline CModule*  GetRootModule()      { return m_pModuleRoot; }
    inline DWORD     GetSessionFlags()    { return m_dwFlags; }
    inline DWORD     GetReturnFlags()     { return m_dwReturnFlags; }
    inline DWORD     GetMachineType()     { return m_dwMachineType; }
    inline LPCSTR    GetReadErrorString() { return m_pszReadError; }
    inline DWORD     GetOriginalCount()   { return m_dwModules; }

    BOOL       DoPassiveScan(LPCSTR pszPath, CSearchGroup *psgHead);
    BOOL       ReadDwi(HANDLE hFile, LPCSTR pszPath);
    BOOL       IsExecutable();
    BOOL       StartRuntimeProfile(LPCSTR pszArguments, LPCSTR pszDirectory, DWORD dwFlags);
    void       SetRuntimeProfile(LPCSTR pszArguments, LPCSTR pszDirectory, LPCSTR pszSearchPath);
    bool       SaveToDwiFile(HANDLE hFile);

protected:
    void       LogProfileBanner(LPCSTR pszArguments, LPCSTR pszDirectory, LPCSTR pszPath);
    void       LogErrorStrings();
    LPSTR      AllocatePath(LPCSTR pszFilePath, LPSTR &pszEnvPath);
    int        SaveSearchGroups(HANDLE hFile);
    int        RecursizeSaveModuleData(HANDLE hFile, CModule *pModule);
    BOOL       SaveModuleData(HANDLE hFile, CModuleData *pModuleData);
    int        RecursizeSaveModule(HANDLE hFile, CModule *pModule);
    BOOL       SaveModule(HANDLE hFile, CModule *pModule);
    BOOL       SaveFunction(HANDLE hFile, CFunction *pFunction);
    BOOL       ReadSearchGroups(HANDLE hFile, DWORD dwGroups);
    CModuleDataNode* ReadModuleData(HANDLE hFile);
    CModule*   ReadModule(HANDLE hFile, CModuleDataNode *pMDN);
    CFunction* ReadFunction(HANDLE hFile);

    CModule*   CreateModule(CModule *pParent, LPCSTR pszModPath);
    void       DeleteModule(CModule *pModule, bool fSiblings);
    void       DeleteParentImportList(CModule *pModule);
    void       DeleteExportList(CModuleData *pModuleData);
    void       ResolveDynamicFunction(CModule *&pModule, CFunction *&pImport);
   
    CFunction* CreateFunction(DWORD dwFlags, WORD wOrdinal, WORD wHint, LPCSTR pszName, DWORDLONG dwlAddress,
                              LPCSTR pszForward = NULL, BOOL fAlreadyAllocated = FALSE);

    BOOL       MapFile(CModule *pModule, HANDLE hFile = NULL);
    void       UnMapFile();

    BOOL       ProcessModule(CModule *pModule);
    void       PrepareModulesForRuntimeProfile(CModule *pModuleCur);
    void       MarkModuleAsLoaded(CModule *pModule, DWORDLONG dwlBaseAddress, bool fDataFile);

    CModule*   FindModule(CModule *pModule, DWORD dwFlags, DWORD_PTR dwpData);

    void       SetModuleError(CModule *pModule, DWORD dwError, LPCTSTR pszMessage);

    BOOL       SearchPathForFile(LPCSTR pszFile, LPSTR pszPath, int cPath, LPSTR *ppszFilePart);

    bool       IsValidFile(LPCSTR pszPath);
    DWORD_PTR  RVAToAbsolute(DWORD dwRVA);
    PVOID      GetImageDirectoryEntry(DWORD dwEntry, DWORD *pdwSize);

    BOOL       VerifyModule(CModule *pModule);
    BOOL       GetFileInfo(CModule *pModule);
    BOOL       GetModuleInfo(CModule *pModule);
    DWORD      ComputeChecksum(CModule *pModule);
    BOOL       GetVersionInfo(CModule *pModule);
    BOOL       BuildImports(CModule *pModule);
    BOOL       BuildDelayImports(CModule *pModule);
    BOOL       WalkIAT32(PIMAGE_THUNK_DATA32 pITDN32, PIMAGE_THUNK_DATA32 pITDA32, CModule *pModule, DWORD dwRVAOffset);
    BOOL       WalkIAT64(PIMAGE_THUNK_DATA64 pITDN64, PIMAGE_THUNK_DATA64 pITDA64, CModule *pModule, DWORDLONG dwlRVAOffset);
    BOOL       BuildExports(CModule *pModule);
    void       VerifyParentImports(CModule *pModule);
    BOOL       CheckForSymbols(CModule *pModule);

    CModule*   ChangeModulePath(CModule *pModuleOld, LPCSTR pszPath);
    CModule*   SwapOutModule(CModule *pModuleOld, LPCSTR pszPath);
    void       OrphanDependents(CModule *pModule);
    void       OrphanForwardDependents(CModule *pModule);
    void       MoveOriginalToDuplicate(CModule *pModuleOld, CModule *pModuleNew);
    void       SetDepths(CModule *pModule, bool fSiblings = false);
    void       UpdateCalledExportFlags(CModule *pModule);
    void       BuildCalledExportFlags(CModule *pModule, CModuleData *pModuleData);
    void       BuildAloFlags();
    void       ClearAloFlags(CModule *pModule);
    void       SetAloFlags(CModule *pModule, DWORD dwFlags);

    CModule*   AddImplicitModule(LPCSTR pszModule, DWORD_PTR dwpBaseAddress);
    CModule*   AddDynamicModule(LPCSTR pszModule, DWORD_PTR dwpBaseAddress, bool fNoResolve, bool fDataFile, bool fGetProcAddress, bool fForward, CModule *pParent);

protected:
    DWORD  HandleEvent(CEvent *pEvent);
    DWORD  EventCreateProcess(CEventCreateProcess *pEvent);
    DWORD  EventExitProcess(CEventExitProcess *pEvent);
    DWORD  EventCreateThread(CEventCreateThread *pEvent);
    DWORD  EventExitThread(CEventExitThread *pEvent);
    DWORD  EventLoadDll(CEventLoadDll *pEvent);
    DWORD  EventUnloadDll(CEventUnloadDll *pEvent);
    DWORD  EventDebugString(CEventDebugString *pEvent);
    DWORD  EventException(CEventException *pEvent);
    DWORD  EventRip(CEventRip *pEvent);
    DWORD  EventDllMainCall(CEventDllMainCall *pEvent);
    DWORD  EventDllMainReturn(CEventDllMainReturn *pEvent);
    DWORD  EventLoadLibraryCall(CEventLoadLibraryCall *pEvent);
    DWORD  EventLoadLibraryReturn(CEventFunctionReturn *pEvent);
    DWORD  EventGetProcAddressCall(CEventGetProcAddressCall *pEvent);
    DWORD  EventGetProcAddressReturn(CEventFunctionReturn *pEvent);
    DWORD  EventMessage(CEventMessage *pEvent);

    LPCSTR GetThreadName(CThread *pThread);
    LPCSTR ThreadString(CThread *pThread);
    LPSTR  BuildLoadLibraryString(LPSTR pszBuf, int cBuf, CEventLoadLibraryCall *pLLC);
    void   FlagModuleWithError(CModule *pModule, bool fOnlyFlagListModule = false);
    void   ProcessLoadLibrary(CEventLoadLibraryCall *pEvent);
    void   ProcessGetProcAddress(CEventGetProcAddressCall *pEvent);

    void   AddModule(DWORD dwBaseAddress);
    void   Log(DWORD dwFlags, DWORD dwTickCount, LPCSTR pszFormat, ...);
};


//******************************************************************************
//***** CModuleData
//******************************************************************************

// Every CModule object points to a CModuleData object. There is a single
// CModuleData for every unique module we process. If a module is duplicated in
// in our tree, there will be a CModule object for each instance, but they will
// all point to the same CModuleData object. For each unique module, a CModule
// object and a CModuleData object are created and the module is opened and
// processed. For every duplicate module, just a CModule object is created and
// pointed to the existing CModuleData. Duplicate modules are never opened since
// all the data that would be achieved by processing the file are already stored
// in the CModuleData.

class CModuleData
{
friend class CSession;
friend class CModule;

protected:

    CModuleData()
    {
        ZeroMemory(this, sizeof(*this)); // inspected
    }

    ~CModuleData()
    {
        MemFree((LPVOID&)m_pszError);
        MemFree((LPVOID&)m_pszPath);
    }

    // This points to the CModule that is the original module.
    CModule *m_pModuleOriginal;

    // Flag to determine if this module has been processed yet.
    bool m_fProcessed;

    // A combination of our DWMF_??? flags that is common for this module.
    DWORD m_dwFlags;

    // A combination of our DWSF_??? flags for this module.
    DWORD m_dwSymbolFlags;

    DWORD m_dwLoadOrder;

    FILETIME m_ftFileTimeStamp;
    FILETIME m_ftLinkTimeStamp;

    // Filled in by GetFileInfo()
    DWORD m_dwFileSize;
    DWORD m_dwAttributes;

    // Filled in by GetModuleInfo()
    DWORD m_dwMachineType;
    DWORD m_dwCharacteristics;
    DWORD m_dwLinkCheckSum;
    DWORD m_dwRealCheckSum;
    DWORD m_dwSubsystemType;
    DWORDLONG m_dwlPreferredBaseAddress;
    DWORDLONG m_dwlActualBaseAddress;
    DWORD m_dwVirtualSize;
    DWORD m_dwImageVersion;
    DWORD m_dwLinkerVersion;
    DWORD m_dwOSVersion;
    DWORD m_dwSubsystemVersion;

    // Filled in by GetVersionInfo()
    DWORD m_dwFileVersionMS;
    DWORD m_dwFileVersionLS;
    DWORD m_dwProductVersionMS;
    DWORD m_dwProductVersionLS;

    // Build by BuildExports()
    CFunction *m_pExports;

    // Allocated and filled in by SetModuleError() if an error occurs.
    LPSTR m_pszError;

    // Allocated and filled in by CreateModule()
    LPSTR m_pszFile;
    LPSTR m_pszPath;
};


//******************************************************************************
//***** CModuleDataNode
//******************************************************************************

class CModuleDataNode
{
public:
    CModuleDataNode *m_pNext;
    CModuleData     *m_pModuleData;
    DWORDLONG        m_dwlKey;

    CModuleDataNode(CModuleData *pModuleData, DWORDLONG dwlKey) :
        m_pNext(NULL),
        m_pModuleData(pModuleData),
        m_dwlKey(dwlKey)
    {
    }
};


//******************************************************************************
//***** CModule
//******************************************************************************

class CModule
{
friend class CSession;

protected:

    CModule()
    {
        ZeroMemory(this, sizeof(*this)); // inspected
    }

    // Our next sibling module.
    CModule *m_pNext;

    // Our parent module, or NULL for root module.
    CModule *m_pParent;

    // Head pointer to a list of dependent modules.
    CModule *m_pDependents;

    // User defined value.
    DWORD_PTR m_dwpUserData;

    // A combination of our DWMF_??? flags that is specific to this module instance.
    DWORD m_dwFlags;

    // A combination of our DWMUF_??? flags that is specific to doing UI updates during profiling.
    DWORD m_dwUpdateFlags;

    // Head pointer to a list of functions that our parent module imports from us.
    CFunction *m_pParentImports;

    // Depth of this module in our tree. Used to catch circular dependencies.
    DWORD m_dwDepth;

    // Pointer to the bulk of our module's processed information.
    CModuleData *m_pData;

public:
    inline DWORD_PTR GetUserData()                      { return m_dwpUserData; }
    inline void      SetUserData(DWORD_PTR dwpUserData) { m_dwpUserData = dwpUserData; }

public:
    inline CModule*   GetChildModule()                 { return m_pDependents; }
    inline CModule*   GetNextSiblingModule()           { return m_pNext; }
    inline CModule*   GetParentModule()                { return m_pParent; }
    inline CModule*   GetOriginal()                    { return m_pData->m_pModuleOriginal; }
    inline bool       IsOriginal()                     { return !(m_dwFlags & DWMF_DUPLICATE); }
    inline BOOL       Is64bit()                        { return (m_dwFlags & DWMF_64BIT) == DWMF_64BIT; }
    inline DWORD      GetDepth()                       { return m_dwDepth; }
    inline DWORD      GetFlags()                       { return m_pData->m_dwFlags | m_dwFlags; }
    inline DWORD      GetUpdateFlags()                 { return m_dwUpdateFlags; }
    inline DWORD      GetSymbolFlags()                 { return m_pData->m_dwSymbolFlags; }
    inline CONST FILETIME* GetFileTimeStamp()          { return &m_pData->m_ftFileTimeStamp; }
    inline CONST FILETIME* GetLinkTimeStamp()          { return &m_pData->m_ftLinkTimeStamp; }
    inline DWORD      GetFileSize()                    { return m_pData->m_dwFileSize; }
    inline DWORD      GetAttributes()                  { return m_pData->m_dwAttributes; }
    inline DWORD      GetMachineType()                 { return m_pData->m_dwMachineType; }
    inline DWORD      GetCharacteristics()             { return m_pData->m_dwCharacteristics; }
    inline DWORD      GetLinkCheckSum()                { return m_pData->m_dwLinkCheckSum; }
    inline DWORD      GetRealCheckSum()                { return m_pData->m_dwRealCheckSum; }
    inline DWORD      GetSubsystemType()               { return m_pData->m_dwSubsystemType; }
    inline DWORDLONG  GetPreferredBaseAddress()        { return m_pData->m_dwlPreferredBaseAddress; }
    inline DWORDLONG  GetActualBaseAddress()           { return m_pData->m_dwlActualBaseAddress; }
    inline DWORD      GetVirtualSize()                 { return m_pData->m_dwVirtualSize; }
    inline DWORD      GetLoadOrder()                   { return m_pData->m_dwLoadOrder; }
    inline DWORD      GetImageVersion()                { return m_pData->m_dwImageVersion; }
    inline DWORD      GetLinkerVersion()               { return m_pData->m_dwLinkerVersion; }
    inline DWORD      GetOSVersion()                   { return m_pData->m_dwOSVersion; }
    inline DWORD      GetSubsystemVersion()            { return m_pData->m_dwSubsystemVersion; }
    inline DWORD      GetFileVersion(LPDWORD pdwMS)    { *pdwMS = m_pData->m_dwFileVersionMS; return m_pData->m_dwFileVersionLS; }
    inline DWORD      GetProductVersion(LPDWORD pdwMS) { *pdwMS = m_pData->m_dwProductVersionMS; return m_pData->m_dwProductVersionLS; }
    inline CFunction* GetFirstParentModuleImport()     { return m_pParentImports; }
    inline CFunction* GetFirstModuleExport()           { return m_pData->m_pExports; }
    inline LPCSTR     GetErrorMessage()                { return m_pData->m_pszError; }

    LPCSTR GetName(bool fPath, bool fDisplay = false);
    LPSTR  BuildTimeStampString(LPSTR pszBuf, int cBuf, BOOL fFile, SAVETYPE saveType);
    LPSTR  BuildFileSizeString(LPSTR pszBuf, int cBuf);
    LPSTR  BuildAttributesString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildMachineString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildLinkCheckSumString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildRealCheckSumString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildSubsystemString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildSymbolsString(LPSTR pszBuf, int cBuf);
    LPSTR  BuildBaseAddressString(LPSTR pszBuf, int cBuf, BOOL fPreferred, BOOL f64BitPadding, SAVETYPE saveType);
    LPSTR  BuildVirtualSizeString(LPSTR pszBuf, int cBuf);
    LPCSTR BuildLoadOrderString(LPSTR pszBuf, int cBuf);

    inline LPSTR BuildFileVersionString(LPSTR pszBuf, int cBuf)      { return BuildVerString(m_pData->m_dwFileVersionMS, m_pData->m_dwFileVersionLS, pszBuf, cBuf); }
    inline LPSTR BuildProductVersionString(LPSTR pszBuf, int cBuf)   { return BuildVerString(m_pData->m_dwProductVersionMS, m_pData->m_dwProductVersionLS, pszBuf, cBuf); }
    inline LPSTR BuildImageVersionString(LPSTR pszBuf, int cBuf)     { return BuildVerString(GetImageVersion(), pszBuf, cBuf); }
    inline LPSTR BuildLinkerVersionString(LPSTR pszBuf, int cBuf)    { return BuildVerString(GetLinkerVersion(), pszBuf, cBuf); }
    inline LPSTR BuildOSVersionString(LPSTR pszBuf, int cBuf)        { return BuildVerString(GetOSVersion(), pszBuf, cBuf); }
    inline LPSTR BuildSubsystemVersionString(LPSTR pszBuf, int cBuf) { return BuildVerString(GetSubsystemVersion(), pszBuf, cBuf); }

protected:
    LPSTR  BuildVerString(DWORD dwMS, DWORD dwLS, LPSTR pszBuf, int cBuf);
    LPSTR  BuildVerString(DWORD dwVer, LPSTR pszBuf, int cBuf);
};


//******************************************************************************
//***** CFunction
//******************************************************************************

class CFunction
{
friend class CSession;
friend class CListViewFunction;
friend class CListViewExports;

private:
    // Since we are variable in size, we should never be allocated or freed by
    // the new/delete functions directly.
    inline CFunction()  { ASSERT(false); }
    inline ~CFunction() { ASSERT(false); }

protected:
    CFunction    *m_pNext;
    DWORD         m_dwFlags;
    WORD          m_wOrdinal;
    WORD          m_wHint;
    union
    {
        LPSTR      m_pszForward;         // Used for forwarded exports.
        CFunction *m_pAssociatedExport; // Used for resolved imports.
    };

    // We create more CFunction objects then any other object. Notepad alone can
    // create well over 20K CFunction objects. For this reason, we try to
    // conserve some space by creating the smallest object neccesary to hold the
    // function information.  The two members that are optional are the address
    // and the function name.  The address is usually 0 (not bound import) or
    // 32-bits, even on 64-bit Windows.  The only time we ever have a 64-bit
    // function is when we create a bound import to a 64-bit module or a 
    // dynamic import to a 64-bit module.  All others will be either 0 or a
    // 32-bit RVA.  So, we optionally save 0, 32, or 64 bits worrth of address
    // information depending on how many bits are used for the address. The
    // name string is variable in length, so we just tack on enough bytes at
    // the end of our object to store the string and the NULL.
    //
    // All-in-all, this doesn't buy us too much in regards to memory, but it
    // does set us up to conserve around 20% when we save to a DWI file.

public:
    inline bool       IsExport()             { return (m_dwFlags & DWFF_EXPORT) != 0; }
    inline CFunction* GetNextFunction()      { return m_pNext; }
    inline DWORD      GetFlags()             { return m_dwFlags; }
    inline int        GetOrdinal()           { return (m_dwFlags & DWFF_ORDINAL) ? (int)m_wOrdinal : -1; }
    inline int        GetHint()              { return (m_dwFlags & DWFF_HINT)    ? (int)m_wHint    : -1; }
    inline LPCSTR     GetExportForwardName() { return m_pszForward; }
    inline CFunction* GetAssociatedExport()  { return m_pAssociatedExport; }

    // The address is stored just past the end of our object.
    inline DWORDLONG GetAddress()
    {
        return (m_dwFlags & DWFF_32BITS_USED) ? (DWORDLONG)*(DWORD*)(this + 1) : 
               (m_dwFlags & DWFF_64BITS_USED) ?        *(DWORDLONG*)(this + 1) : 0;
    }

    // The name is stored just past the address.
    inline LPCSTR GetName()
    {
        return !(m_dwFlags & DWFF_NAME)       ? ""                                                  :
               (m_dwFlags & DWFF_32BITS_USED) ? (LPCSTR)((DWORD_PTR)(this + 1) + sizeof(DWORD))     : 
               (m_dwFlags & DWFF_64BITS_USED) ? (LPCSTR)((DWORD_PTR)(this + 1) + sizeof(DWORDLONG)) : 
                                                (LPCSTR)            (this + 1);
    }

    LPCSTR GetOrdinalString(LPSTR pszBuf, int cBuf);
    LPCSTR GetHintString(LPSTR pszBuf, int cBuf);
    LPCSTR GetFunctionString(LPSTR pszBuf, int cBuf, BOOL fUndecorate);
    LPCSTR GetAddressString(LPSTR pszBuf, int cBuf);
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif __SESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\session.cpp ===
//******************************************************************************
//
// File:        SESSION.CPP
//
// Description: Implementation file for the Session class and all classes used by
//              it including the Module class, its Data class, and the Function
//              class.  The Session object is the a UI-free object that contains
//              all the information for a given session.
//
// Classes:     CSession
//              CModule
//              CModuleData
//              CModuleDataNode
//              CFunction
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#include "stdafx.h"
#include "depends.h"
#include "search.h"
#include "dbgthread.h"
#include "session.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

#define IOH_VALUE(member) (m_f64Bit ? ((PIMAGE_OPTIONAL_HEADER64)m_pIOH)->member : ((PIMAGE_OPTIONAL_HEADER32)m_pIOH)->member)
#define IDD_VALUE(pIDD, member) RVAToAbsolute((pIDD->grAttrs & dlattrRva) ? pIDD->member : (pIDD->member - (DWORD)IOH_VALUE(ImageBase)))
#define GET_NAME(p) (p ? (p->GetName((m_dwProfileFlags & PF_USE_FULL_PATHS) != 0)) : "Unknown")


//******************************************************************************
//***** CModule
//******************************************************************************

LPCSTR CModule::GetName(bool fPath, bool fDisplay /*=false*/)
{
    LPCSTR pszName = fPath ? m_pData->m_pszPath : m_pData->m_pszFile;
    if (!pszName || !*pszName)
    {
        return fDisplay ? "<empty string>" : "";
    }
    return pszName;
}

//******************************************************************************
LPSTR CModule::BuildTimeStampString(LPSTR pszBuf, int cBuf, BOOL fFile, SAVETYPE saveType)
{
    // Get the module's local time stamp.
    SYSTEMTIME st;
    FileTimeToSystemTime(fFile ? GetFileTimeStamp() : GetLinkTimeStamp(), &st);

    // We special case CSV files.  We always create a YYYY-MM-DD HH:MM:SS time.
    // This meats the ISO 8601 standard and is easy to parse.
    if (ST_CSV == saveType)
    {
        SCPrintf(pszBuf, cBuf, "%04u-%02u-%02u %02u:%02u:%02u", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
        return pszBuf;
    }

    int length;

    // Build the date string.
    if (LOCALE_DATE_DMY == g_theApp.m_nShortDateFormat)
    {
        length = SCPrintf(pszBuf, cBuf, "%02u%c%02u%c%04u", st.wDay, g_theApp.m_cDateSeparator, st.wMonth, g_theApp.m_cDateSeparator, st.wYear);
    }
    else if (LOCALE_DATE_YMD == g_theApp.m_nShortDateFormat)
    {
        length = SCPrintf(pszBuf, cBuf, "%04u%c%02u%c%02u", st.wYear, g_theApp.m_cDateSeparator, st.wMonth, g_theApp.m_cDateSeparator, st.wDay);
    }
    else
    {
        length = SCPrintf(pszBuf, cBuf, "%02u%c%02u%c%04u", st.wMonth, g_theApp.m_cDateSeparator, st.wDay, g_theApp.m_cDateSeparator, st.wYear);
    }

    // Check to see if we need to do 24-hour time.
    if (g_theApp.m_f24HourTime)
    {
        SCPrintf(pszBuf + length, cBuf - length, " %s%u%c%02u",
                 (st.wHour >= 10) ? "" : g_theApp.m_fHourLeadingZero ? "0" : " ",
                 st.wHour, g_theApp.m_cTimeSeparator, st.wMinute);
    }
    else
    {
        // Convert 24 hour time to 12 hour time.
        bool fPM = st.wHour >= 12;
        st.wHour = (WORD)(((int)st.wHour % 12) ? ((int)st.wHour % 12) : 12);

        SCPrintf(pszBuf + length, cBuf - length, " %s%u%c%02u%c",
                 (st.wHour >= 10) ? "" : g_theApp.m_fHourLeadingZero ? "0" : " ",
                 st.wHour, g_theApp.m_cTimeSeparator, st.wMinute, fPM ? 'p' : 'a');
    }

    return pszBuf;
}

//******************************************************************************
LPSTR CModule::BuildFileSizeString(LPSTR pszBuf, int cBuf)
{
    // Get the module size and format it.
    return FormatValue(pszBuf, cBuf, GetFileSize());
}

//******************************************************************************
LPSTR CModule::BuildAttributesString(LPSTR pszBuf, int cBuf)
{
    // Build the attribute string according to the flags specified for this module.
    SCPrintf(pszBuf, cBuf, "%s%s%s%s%s%s%s%s",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_READONLY)   ? "R" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_HIDDEN)     ? "H" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_SYSTEM)     ? "S" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_ARCHIVE)    ? "A" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_COMPRESSED) ? "C" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_DIRECTORY)  ? "D" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_TEMPORARY)  ? "T" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_OFFLINE)    ? "O" : "",
             (m_pData->m_dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)  ? "E" : "");
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildMachineString(LPSTR pszBuf, int cBuf)
{
    // Return the appropriate machine type string for this module.
    // Last updated 4/12/2002 from VS NET 7.0.
    switch (m_pData->m_dwMachineType)
    {
        case IMAGE_FILE_MACHINE_I386:      return StrCCpy(pszBuf, "x86",           cBuf); // 0x014c Intel 386.
        case IMAGE_FILE_MACHINE_R3000_BE:  return StrCCpy(pszBuf, "R3000 BE",      cBuf); // 0x0160 MIPS big-endian
        case IMAGE_FILE_MACHINE_R3000:     return StrCCpy(pszBuf, "R3000",         cBuf); // 0x0162 MIPS little-endian
        case IMAGE_FILE_MACHINE_R4000:     return StrCCpy(pszBuf, "R4000",         cBuf); // 0x0166 MIPS little-endian
        case IMAGE_FILE_MACHINE_R10000:    return StrCCpy(pszBuf, "R10000",        cBuf); // 0x0168 MIPS little-endian
        case IMAGE_FILE_MACHINE_WCEMIPSV2: return StrCCpy(pszBuf, "MIPS WinCE V2", cBuf); // 0x0169 MIPS little-endian WCE v2
        case IMAGE_FILE_MACHINE_ALPHA:     return StrCCpy(pszBuf, "Alpha AXP",     cBuf); // 0x0184 Alpha_AXP
        case IMAGE_FILE_MACHINE_SH3:       return StrCCpy(pszBuf, "SH3",           cBuf); // 0x01a2 SH3 little-endian
        case IMAGE_FILE_MACHINE_SH3DSP:    return StrCCpy(pszBuf, "SH3 DSP",       cBuf); // 0x01a3
        case IMAGE_FILE_MACHINE_SH3E:      return StrCCpy(pszBuf, "SH3E",          cBuf); // 0x01a4 SH3E little-endian
        case IMAGE_FILE_MACHINE_SH4:       return StrCCpy(pszBuf, "SH4",           cBuf); // 0x01a6 SH4 little-endian
        case IMAGE_FILE_MACHINE_SH5:       return StrCCpy(pszBuf, "SH5",           cBuf); // 0x01a8 SH5
        case IMAGE_FILE_MACHINE_ARM:       return StrCCpy(pszBuf, "ARM",           cBuf); // 0x01c0 ARM Little-Endian
        case IMAGE_FILE_MACHINE_THUMB:     return StrCCpy(pszBuf, "Thumb",         cBuf); // 0x01c2
        case IMAGE_FILE_MACHINE_AM33:      return StrCCpy(pszBuf, "AM33",          cBuf); // 0x01d3
        case IMAGE_FILE_MACHINE_POWERPC:   return StrCCpy(pszBuf, "PowerPC",       cBuf); // 0x01F0 IBM PowerPC Little-Endian
        case IMAGE_FILE_MACHINE_POWERPCFP: return StrCCpy(pszBuf, "PowerPC FP",    cBuf); // 0x01f1
        case IMAGE_FILE_MACHINE_IA64:      return StrCCpy(pszBuf, "IA64",          cBuf); // 0x0200 Intel 64
        case IMAGE_FILE_MACHINE_MIPS16:    return StrCCpy(pszBuf, "MIPS 16",       cBuf); // 0x0266 MIPS
        case IMAGE_FILE_MACHINE_ALPHA64:   return StrCCpy(pszBuf, "Alpha 64",      cBuf); // 0x0284 ALPHA64
        case IMAGE_FILE_MACHINE_MIPSFPU:   return StrCCpy(pszBuf, "MIPS FPU",      cBuf); // 0x0366 MIPS
        case IMAGE_FILE_MACHINE_MIPSFPU16: return StrCCpy(pszBuf, "MIPS FPU 16",   cBuf); // 0x0466 MIPS
        case IMAGE_FILE_MACHINE_TRICORE:   return StrCCpy(pszBuf, "TRICORE",       cBuf); // 0x0520 Infineon
        case IMAGE_FILE_MACHINE_CEF:       return StrCCpy(pszBuf, "CEF",           cBuf); // 0x0CEF
        case IMAGE_FILE_MACHINE_EBC:       return StrCCpy(pszBuf, "EFI Byte Code", cBuf); // 0x0EBC EFI Byte Code
        case IMAGE_FILE_MACHINE_AMD64:     return StrCCpy(pszBuf, "AMD64",         cBuf); // 0x8664 AMD K8
        case IMAGE_FILE_MACHINE_M32R:      return StrCCpy(pszBuf, "M32R",          cBuf); // 0x9104 M32R little-endian
        case IMAGE_FILE_MACHINE_CEE:       return StrCCpy(pszBuf, "CEE",           cBuf); // 0xC0EE
    }

    SCPrintf(pszBuf, cBuf, "%u (0x%04u)", m_pData->m_dwMachineType, m_pData->m_dwMachineType);
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildLinkCheckSumString(LPSTR pszBuf, int cBuf)
{
    // Build the string.
    SCPrintf(pszBuf, cBuf, "0x%08X", m_pData->m_dwLinkCheckSum);
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildRealCheckSumString(LPSTR pszBuf, int cBuf)
{
    // Build the string.
    SCPrintf(pszBuf, cBuf, "0x%08X", m_pData->m_dwRealCheckSum);
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildSubsystemString(LPSTR pszBuf, int cBuf)
{
    // Return the appropriate subsystem string for this module.
    // Last update 4/12/2002 with VS NET 7.0.
    switch (m_pData->m_dwSubsystemType)
    {
        case IMAGE_SUBSYSTEM_NATIVE:                  return StrCCpy(pszBuf, "Native",             cBuf); // 1: Image doesn't require a subsystem.
        case IMAGE_SUBSYSTEM_WINDOWS_GUI:             return StrCCpy(pszBuf, "GUI",                cBuf); // 2: Image runs in the Windows GUI subsystem.
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:             return StrCCpy(pszBuf, "Console",            cBuf); // 3: Image runs in the Windows character subsystem.
        case IMAGE_SUBSYSTEM_WINDOWS_OLD_CE_GUI:      return StrCCpy(pszBuf, "WinCE 1.x GUI",      cBuf); // 4: Image runs in the Windows CE subsystem.
        case IMAGE_SUBSYSTEM_OS2_CUI:                 return StrCCpy(pszBuf, "OS/2 console",       cBuf); // 5: image runs in the OS/2 character subsystem.
        case IMAGE_SUBSYSTEM_POSIX_CUI:               return StrCCpy(pszBuf, "Posix console",      cBuf); // 7: image runs in the Posix character subsystem.
        case IMAGE_SUBSYSTEM_NATIVE_WINDOWS:          return StrCCpy(pszBuf, "Win9x driver",       cBuf); // 8: image is a native Win9x driver.
        case IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:          return StrCCpy(pszBuf, "WinCE 2.0+ GUI",     cBuf); // 9: Image runs in the Windows CE subsystem.
        case IMAGE_SUBSYSTEM_EFI_APPLICATION:         return StrCCpy(pszBuf, "EFI Application",    cBuf); // 10:
        case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: return StrCCpy(pszBuf, "EFI Boot Driver",    cBuf); // 11:
        case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:      return StrCCpy(pszBuf, "EFI Runtime Driver", cBuf); // 12:
        case IMAGE_SUBSYSTEM_EFI_ROM:                 return StrCCpy(pszBuf, "EFI ROM",            cBuf); // 13:
        case IMAGE_SUBSYSTEM_XBOX:                    return StrCCpy(pszBuf, "Xbox",               cBuf); // 14:
    }

    SCPrintf(pszBuf, cBuf, "%u", m_pData->m_dwSubsystemType);
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildSymbolsString(LPSTR pszBuf, int cBuf)
{
    // Buffer needs to be at least 41 chars.
    *pszBuf = '\0';

    if (m_pData->m_dwSymbolFlags & DWSF_INVALID)
    {
        StrCCpy(pszBuf, "Invalid", cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_DBG)
    {
        StrCCat(pszBuf, ",DBG" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_COFF)
    {
        StrCCat(pszBuf, ",COFF" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_CODEVIEW)
    {
        StrCCat(pszBuf, ",CV" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_PDB)
    {
        StrCCat(pszBuf, ",PDB" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_FPO)
    {
        StrCCat(pszBuf, ",FPO" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_OMAP)
    {
        StrCCat(pszBuf, ",OMAP" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & DWSF_BORLAND)
    {
        StrCCat(pszBuf, ",Borland" + !*pszBuf, cBuf);
    }
    if (m_pData->m_dwSymbolFlags & ~DWSF_MASK)
    {
        StrCCat(pszBuf, ",Unknown" + !*pszBuf, cBuf);
    }
    if (!*pszBuf)
    {
        StrCCpy(pszBuf, "None", cBuf);
    }
    return pszBuf;
}

//******************************************************************************
LPSTR CModule::BuildBaseAddressString(LPSTR pszBuf, int cBuf, BOOL fPreferred, BOOL f64BitPadding, SAVETYPE saveType)
{
    // Get the appropriate base address
    DWORDLONG dwlAddress = (fPreferred ? GetPreferredBaseAddress() : GetActualBaseAddress());

    // Build the string.
    if (!fPreferred && (m_pData->m_dwFlags & DWMF_DATA_FILE_CORE) && (dwlAddress != (DWORDLONG)-1))
    {
        StrCCpy(pszBuf, "Data file", cBuf);
    }
    else if (dwlAddress == (DWORDLONG)-1)
    {
        StrCCpy(pszBuf, "Unknown", cBuf);
    }
    else if (m_pData->m_dwFlags & DWMF_64BIT)
    {
        SCPrintf(pszBuf, cBuf, "0x%016I64X", dwlAddress);
    }
    else if (f64BitPadding && (saveType != ST_CSV))
    {
        SCPrintf(pszBuf, cBuf, "0x--------%08I64X", dwlAddress);
    }
    else
    {
        SCPrintf(pszBuf, cBuf, "0x%08I64X", dwlAddress);
    }

    return pszBuf;
}

//******************************************************************************
LPSTR CModule::BuildVirtualSizeString(LPSTR pszBuf, int cBuf)
{
    // Build the string.
    SCPrintf(pszBuf, cBuf, "0x%08X", m_pData->m_dwVirtualSize);
    return pszBuf;
}

//******************************************************************************
LPCSTR CModule::BuildLoadOrderString(LPSTR pszBuf, int cBuf)
{
    // Build the string.
    if (m_pData->m_dwLoadOrder)
    {
        FormatValue(pszBuf, cBuf, m_pData->m_dwLoadOrder);
    }
    else
    {
        StrCCpy(pszBuf, "Not Loaded", cBuf);
    }

    return pszBuf;
}

//******************************************************************************
LPSTR CModule::BuildVerString(DWORD dwVer, LPSTR pszBuf, int cBuf)
{
    // Return the two part version string in the form "xxx.xxx"
    SCPrintf(pszBuf, cBuf, "%u.%u", HIWORD(dwVer), LOWORD(dwVer));
    return pszBuf;
}

//******************************************************************************
LPSTR CModule::BuildVerString(DWORD dwMS, DWORD dwLS, LPSTR pszBuf, int cBuf)
{
    // Check to see if the file actually contains version info.
    if (m_pData->m_dwFlags & DWMF_VERSION_INFO)
    {
        // Return the four part version string in the form "xxx.xxx.xxx.xxx"
        SCPrintf(pszBuf, cBuf, "%u.%u.%u.%u", HIWORD(dwMS), LOWORD(dwMS), HIWORD(dwLS), LOWORD(dwLS));
    }

    // Otherwise, just return "N/A"
    else
    {
        StrCCpy(pszBuf, "N/A", cBuf);
    }
    return pszBuf;
}


//******************************************************************************
//***** CFunction
//******************************************************************************

LPCSTR CFunction::GetOrdinalString(LPSTR pszBuf, int cBuf)
{
    // Get the function's ordinal value.
    int ordinal = GetOrdinal();

    // If no ordinal value exists, then just return the string "N/A".

    if (ordinal < 0)
    {
        return "N/A";
    }

    SCPrintf(pszBuf, cBuf, "%d (0x%04X)", ordinal, ordinal);
    return pszBuf;
}

//******************************************************************************
LPCSTR CFunction::GetHintString(LPSTR pszBuf, int cBuf)
{
    // Get the function's hint value.
    int hint = GetHint();

    // If no hint value exists, then just return the string "N/A"
    if (hint < 0)
    {
        return "N/A";
    }

    SCPrintf(pszBuf, cBuf, "%d (0x%04X)", hint, hint);
    return pszBuf;
}

//******************************************************************************
LPCSTR CFunction::GetFunctionString(LPSTR pszBuf, int cBuf, BOOL fUndecorate)
{
    // If we have no name, then special case the return value.
    if (!(m_dwFlags & DWFF_NAME))
    {
        // The function must have an ordinal or a function name. If it has neither,
        // the a non-ordinal value (greater than 0xFFFF) was pass to GetProcAddress(),
        // but the address could not be read for a sting.
        return ((m_dwFlags & DWFF_ORDINAL) ? "N/A" : "<invalid string>");
    }

    // Check to see if the function name is empty.  This can occur if the user calls
    // GetProcAddress(hModule, "");
    if (!*GetName())
    {
        return "<empty string>";
    }

    // Attempt to undecorate the function name.
    if (fUndecorate && g_theApp.m_pfnUnDecorateSymbolName &&
        g_theApp.m_pfnUnDecorateSymbolName(
            GetName(), pszBuf, cBuf,
            UNDNAME_NO_LEADING_UNDERSCORES |
            UNDNAME_NO_MS_KEYWORDS         |
            UNDNAME_NO_ALLOCATION_MODEL    |
            UNDNAME_NO_ALLOCATION_LANGUAGE |
            UNDNAME_NO_MS_THISTYPE         |
            UNDNAME_NO_CV_THISTYPE         |
            UNDNAME_NO_THISTYPE            |
            UNDNAME_NO_ACCESS_SPECIFIERS   |
            UNDNAME_NO_THROW_SIGNATURES    |
            UNDNAME_NO_MEMBER_TYPE         |
            UNDNAME_32_BIT_DECODE))
    {
        // If the name was undecorated, then set our return pointer to it.
        return pszBuf;
    }

    return GetName();
}

//******************************************************************************
LPCSTR CFunction::GetAddressString(LPSTR pszBuf, int cBuf)
{
    // If this function is an import (not an export) and is not bound (no address),
    // then just return the string "Not Bound"
    if (!(GetFlags() & (DWFF_EXPORT | DWFF_ADDRESS)))
    {
        return (GetFlags() & DWFF_DYNAMIC) ? "N/A" : "Not Bound";
    }

    // If this function is an export and has a forwarded string, then return the
    // forward string instead of an address since the address is meaningless.
    else if (IsExport() && GetExportForwardName())
    {
        return GetExportForwardName();
    }

    // Otherwise just build the address string and return it.
    if (GetFlags() & DWFF_64BIT)
    {
        SCPrintf(pszBuf, cBuf, "0x%016I64X", GetAddress());
    }
    else
    {
        SCPrintf(pszBuf, cBuf, "0x%08X", (DWORD)GetAddress());
    }
    return pszBuf;
}


//******************************************************************************
//***** CSession
//******************************************************************************

CSession::CSession(PFN_PROFILEUPDATE pfnProfileUpdate, DWORD_PTR dwpCookie) :

    m_pfnProfileUpdate(pfnProfileUpdate),
    m_dwpProfileUpdateCookie(dwpCookie),

    m_hFile(NULL),
    m_dwSize(0),
    m_fCloseFileHandle(false),
    m_hMap(NULL),
    m_lpvFile(NULL),
    m_f64Bit(false),
    m_pIFH(NULL),
    m_pIOH(NULL),
    m_pISH(NULL),

    m_dwpUserData(0),
    m_pSysInfo(NULL),
    m_dwFlags(0),
    m_dwReturnFlags(0),
    m_dwMachineType((DWORD)-1),
    m_dwModules(0),
    m_dwLoadOrder(0),
    m_dwpDWInjectBase(0),
    m_dwDWInjectSize(0),
    m_pModuleRoot(NULL),
    m_pEventLoadDllPending(NULL),
    m_pszReadError(NULL),
    m_pszExceptionError(NULL),

    m_fInitialBreakpoint(false),

    m_psgHead(NULL),

    m_pProcess(g_theApp.m_pProcess),
    m_dwProfileFlags(g_theApp.m_pProcess ? g_theApp.m_pProcess->GetFlags() : 0)
{
}

//******************************************************************************
CSession::~CSession()
{
    // Free any error string we may have.
    MemFree((LPVOID&)m_pszReadError);

    // If we are profiling, then kill off our process.
    if (m_pProcess)
    {
        m_pProcess->DetachFromSession();
        m_pProcess->Terminate();
        m_pProcess = NULL;
    }

    // Delete all modules by recursing into DeleteModule() with our root module.
    if (m_pModuleRoot)
    {
        DeleteModule(m_pModuleRoot, true);
        m_pModuleRoot = NULL;
    }

    // Delete our system info data if we allocated it.
    if (m_pSysInfo)
    {
        delete m_pSysInfo;
        m_pSysInfo = NULL;
    }

    // Merge our return value into our global return value.
    g_dwReturnFlags |= m_dwReturnFlags;
}

//******************************************************************************
BOOL CSession::DoPassiveScan(LPCSTR pszPath, CSearchGroup *psgHead)
{
    m_dwModules       = 0;
    m_dwLoadOrder     = 0;
    m_dwpDWInjectBase = 0;
    m_dwDWInjectSize  = 0;

    // Store the search path.
    m_psgHead = psgHead;

    // Create our root module node.
    m_pModuleRoot = CreateModule(NULL, pszPath);

    // Mark this module as implicit.
    m_pModuleRoot->m_dwFlags |= DWMF_IMPLICIT;

    // Start the recursion on the head module to process all modules.
    ProcessModule(m_pModuleRoot);

    // Build all our *_ALO flags after calling ProcessModule.
    BuildAloFlags();

    // Report any errors that we found.
    LogErrorStrings();

    return TRUE; //!! always true?
}

//******************************************************************************
BOOL CSession::StartRuntimeProfile(LPCSTR pszArguments, LPCSTR pszDirectory, DWORD dwFlags)
{
    // Fail if we don't have a root module or are already profiling one.
    if (!GetRootModule())
    {
        Log(LOG_ERROR, 0, "No root module to profile.\n");
        if (m_pfnProfileUpdate)
        {
            m_dwReturnFlags |= DWRF_PROFILE_ERROR;
            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_PROFILE_DONE, 0, 0);
        }
        return FALSE;
    }

    // Store our profile flags for later.
    m_dwProfileFlags = dwFlags;

    LPSTR pszPath = NULL, pszOldPath = NULL;

    // Check to see if we need to simulate a ShellExecute/ShellExecuteEx call by
    // inserting the App Paths into the beginning of our path.
    if (dwFlags & PF_SIMULATE_SHELLEXECUTE)
    {
        if (pszPath = AllocatePath(GetRootModule()->GetName(true), pszOldPath))
        {
            SetEnvironmentVariable("Path", pszPath);
        }
        else
        {
            pszOldPath = NULL;
        }
    }

    // Otherwise, just get and store the path variable so that we can log it.
    if (!pszPath)
    {
        DWORD dwSize = GetEnvironmentVariable("Path", NULL, 0);
        if (dwSize && (pszPath = (LPSTR)malloc(dwSize)))
        {
            if (GetEnvironmentVariable("Path", pszPath, dwSize) > dwSize)
            {
                MemFree((LPVOID&)pszPath);
            }
        }
    }

    // Write out our banner to signify that we are starting a new profile.
    LogProfileBanner(pszArguments, pszDirectory, pszPath);

    // Check to see if we are hooking and therefore need DEPENDS.DLL.
    if (m_dwProfileFlags & PF_HOOK_PROCESS)
    {
        // Make sure DEPENDS.DLL exists - if not, then we create the file from our
        // resource data.
        CHAR szPath[DW_MAX_PATH];
        if (g_pszDWInjectPath)
        {
            StrCCpy(szPath, g_pszDWInjectPath, sizeof(szPath));
        }
        else
        {
            *szPath = '\0';
        }
        if (ExtractResourceFile(IDR_DEPENDS_DLL, "depends.dll", szPath, countof(szPath)))
        {
            // If the path changed, then update our path buffer.
            if (!g_pszDWInjectPath || strcmp(g_pszDWInjectPath, szPath))
            {
                MemFree((LPVOID&)g_pszDWInjectPath);
                g_pszDWInjectPath = StrAlloc(szPath);
            }
        }
    }

    // Clear our breakpoint flag.
    m_fInitialBreakpoint = false;

    m_dwLoadOrder     = 0;
    m_dwpDWInjectBase = 0;
    m_dwDWInjectSize  = 0;

    // Recurse through all the modules preparing them for profiling.
    PrepareModulesForRuntimeProfile(m_pModuleRoot);

    // Update and re-sort our views.
    if (m_pfnProfileUpdate)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_ALL, 0, 0);
    }

    //!! make sure we don't already have a pThread - we shouldn't
    CDebuggerThread *pDebuggerThread = new CDebuggerThread();
    if (!pDebuggerThread)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    m_pProcess = pDebuggerThread->BeginProcess(this, m_pModuleRoot->GetName(true), pszArguments, pszDirectory, dwFlags);

    // If we changed our path before calling CreateProcess, then restore it now
    // back to what it used to be.
    if ((dwFlags & PF_SIMULATE_SHELLEXECUTE) && pszOldPath)
    {
        SetEnvironmentVariable("Path", pszOldPath);
    }
    MemFree((LPVOID&)pszPath);

    if (!m_pProcess)
    {
        if (!pDebuggerThread->DidCreateProcess())
        {
            m_dwReturnFlags |= DWRF_PROFILE_ERROR;
        }
        delete pDebuggerThread;
        if (m_pfnProfileUpdate)
        {
            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_PROFILE_DONE, 0, 0);
        }
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
void CSession::SetRuntimeProfile(LPCSTR pszArguments, LPCSTR pszDirectory, LPCSTR pszSearchPath)
{
    // Write out our banner to signify that we are starting a new profile.
    LogProfileBanner(pszArguments, pszDirectory, pszSearchPath);
}

//******************************************************************************
void CSession::LogErrorStrings()
{
    bool fNewLine = false;

    // Output any session error string we may have.
    if (m_pszReadError)
    {
        Log(LOG_ERROR, 0, "Error: %s\n", m_pszReadError);
        fNewLine = true;
    }

    // Output any processing errors we may have.
    if (m_dwReturnFlags & DWRF_COMMAND_LINE_ERROR)
    {
        Log(LOG_ERROR, 0, "Error: There was an error with at least one command line option.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_FILE_NOT_FOUND)
    {
        Log(LOG_ERROR, 0, "Error: The file you specified to load could not be found.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_FILE_OPEN_ERROR)
    {
        Log(LOG_ERROR, 0, "Error: At least one file could not be opened for reading.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_DWI_NOT_RECOGNIZED)
    {
        Log(LOG_ERROR, 0, "Error: The format of the Dependency Walker Image (DWI) file was unrecognized.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_PROFILE_ERROR)
    {
        Log(LOG_ERROR, 0, "Error: There was an error while trying to profile the application.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_WRITE_ERROR)
    {
        Log(LOG_ERROR, 0, "Error: There was an error writing the results to an output file.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_OUT_OF_MEMORY)
    {
        Log(LOG_ERROR, 0, "Error: Dependency Walker ran out of memory.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_INTERNAL_ERROR)
    {
        Log(LOG_ERROR, 0, "Error: Dependency Walker encountered an internal error.\n");
        fNewLine = true;
    }

    // Output any module errors we may have.
    if (m_dwReturnFlags & DWRF_FORMAT_NOT_PE)
    {
        Log(LOG_ERROR, 0, "Error: At least one file was not a 32-bit or 64-bit Windows module.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_IMPLICIT_NOT_FOUND)
    {
        Log(LOG_ERROR, 0, "Error: At least one required implicit or forwarded dependency was not found.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_MISSING_IMPLICIT_EXPORT)
    {
        Log(LOG_ERROR, 0, "Error: At least one module has an unresolved import due to a missing export function in an implicitly dependent module.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_MIXED_CPU_TYPES)
    {
        Log(LOG_ERROR, 0, "Error: Modules with different CPU types were found.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_CIRCULAR_DEPENDENCY)
    {
        Log(LOG_ERROR, 0, "Error: A circular dependency was detected.\n");
        fNewLine = true;
    }

    // Check to see if our SxS group encountered any errors.  We only do this
    // if the root module is a PE file, since the SxS calls always fail for
    // non-binary files.  We don't want to confuse people by saying "bad SxS data"
    // when they open a text file or something.
    if (m_pModuleRoot && !(m_pModuleRoot->GetFlags() & DWMF_FORMAT_NOT_PE))
    {
        // Loop through all the search groups we have.
        for (CSearchGroup *psgCur = m_psgHead; psgCur; psgCur = psgCur->m_pNext)
        {
            // Check to see if this is a SxS group with errors.
            if ((SG_SIDE_BY_SIDE == psgCur->GetType()) &&
                (psgCur->GetSxSManifestError() || psgCur->GetSxSExeError()))
            {
                // Add this error into our return value.
                m_dwReturnFlags |= DWRF_SXS_ERROR;

                // Display the appropriate errors.
                if (psgCur->GetSxSManifestError())
                {
                    LPCSTR pszError = BuildErrorMessage(psgCur->GetSxSManifestError(), NULL);
                    Log(LOG_ERROR, 0, "Error: The Side-by-Side configuration information in \"%s.manifest\" contains errors. %s\n",
                        m_pModuleRoot->GetName(true), pszError);
                    MemFree((LPVOID&)pszError);
                }
                if (psgCur->GetSxSExeError())
                {
                    LPCSTR pszError = BuildErrorMessage(psgCur->GetSxSExeError(), NULL);
                    Log(LOG_ERROR, 0, "Error: The Side-by-Side configuration information in \"%s\" contains errors. %s\n",
                        m_pModuleRoot->GetName(true), pszError);
                    MemFree((LPVOID&)pszError);
                }
                fNewLine = true;
                break;
            }
        }
    }

    // Output any warnings we may have.
    if (m_dwReturnFlags & DWRF_DYNAMIC_NOT_FOUND)
    {
        Log(LOG_ERROR, 0, "Warning: At least one dynamic dependency module was not found.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_DELAYLOAD_NOT_FOUND)
    {
        Log(LOG_ERROR, 0, "Warning: At least one delay-load dependency module was not found.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_MISSING_DYNAMIC_EXPORT)
    {
        Log(LOG_ERROR, 0, "Warning: At least one module could not dynamically locate a function in another module using the GetProcAddress function call.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_MISSING_DELAYLOAD_EXPORT)
    {
        Log(LOG_ERROR, 0, "Warning: At least one module has an unresolved import due to a missing export function in a delay-load dependent module.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_FORMAT_NOT_RECOGNIZED)
    {
        Log(LOG_ERROR, 0, "Warning: At least one module was corrupted or unrecognizable to Dependency Walker, but still appeared to be a Windows module.\n");
        fNewLine = true;
    }
    if (m_dwReturnFlags & DWRF_MODULE_LOAD_FAILURE)
    {
        Log(LOG_ERROR, 0, "Warning: At least one module failed to load at runtime.\n");
        fNewLine = true;
    }
    
    // If we output anything, then write out a newline.
    if (fNewLine)
    {
        Log(0, 0, "\n");
    }
}

//******************************************************************************
void CSession::LogProfileBanner(LPCSTR pszArguments, LPCSTR pszDirectory, LPCSTR pszPath)
{
    // Get the local time.
    SYSTEMTIME st;
    GetLocalTime(&st);

    // Log the banner
    Log(LOG_BOLD, 0, "--------------------------------------------------------------------------------\n");

    // Build the date string according to the user's locale.
    CHAR szDate[32], szTime[32];
    if (!GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szDate, sizeof(szDate)))
    {
        // Fallback to US format if GetDateFormat fails (really shouldn't ever fail)
        SCPrintf(szDate, sizeof(szDate), "%02u/%02u/%04u", (int)st.wMonth, (int)st.wDay, (int)st.wYear);
    }

    // Build the time string according to the user's locale.
    if (!GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, szTime, sizeof(szTime)))
    {
        // Fallback to US format if GetTimeFormat fails (really shouldn't ever fail)
        SCPrintf(szTime, sizeof(szTime), "%u:%02u %cM", ((DWORD)st.wHour % 12) ? ((DWORD)st.wHour % 12) : 12,
                 st.wMinute, (st.wHour < 12) ? _T('A') : _T('P'));
    }

    Log(LOG_BOLD, 0, "Starting profile on %s at %s\n", szDate, szTime);
    Log(0, 0, "\n");

    SYSINFO si;
    BuildSysInfo(&si);

    CHAR szBuffer1[256], szBuffer2[256];
    BuildOSNameString(szBuffer1, sizeof(szBuffer1), &si);
    BuildOSVersionString(szBuffer2, sizeof(szBuffer2), &si);

    // Log the OS name, version, and build number.
    Log(LOG_BOLD, 0, "Operating System: ");
    Log(LOG_APPEND, 0, "%s, version %s\n", szBuffer1, szBuffer2);

    Log(LOG_BOLD, 0, "Program Executable: ");
    Log(LOG_APPEND, 0, "%s\n", GetRootModule() ? GetRootModule()->GetName(true, true) : "");

    if (pszArguments)
    {
        Log(LOG_BOLD, 0, "Program Arguments: ");
        Log(LOG_APPEND, 0, "%s\n", pszArguments);
    }

    if (pszDirectory)
    {
        Log(LOG_BOLD, 0, "Starting Directory: ");
        Log(LOG_APPEND, 0, "%s\n", pszDirectory);
    }

    if (pszPath)
    {
        Log(LOG_BOLD, 0, "Search Path: ");
        Log(LOG_APPEND, 0, "%s\n", pszPath);
    }

    Log(0, 0, "\n");
    Log(LOG_BOLD, 0, "Options Selected:\n");

    if (m_dwProfileFlags & PF_SIMULATE_SHELLEXECUTE)
    {
        Log(0, 0, "     Simulate ShellExecute by inserting any App Paths directories into the PATH environment variable.\n");
    }
    if (m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS)
    {
        Log(0, 0, "     Log DllMain calls for process attach and process detach messages.\n");
    }
    if (m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS)
    {
        Log(0, 0, "     Log DllMain calls for all other messages, including thread attach and thread detach.\n");
    }
    if (m_dwProfileFlags & PF_HOOK_PROCESS)
    {
        Log(0, 0, "     Hook the process to gather more detailed dependency information.\n");
        if (m_dwProfileFlags & PF_LOG_LOADLIBRARY_CALLS)
        {
            Log(0, 0, "     Log LoadLibrary function calls.\n");
        }
        if (m_dwProfileFlags & PF_LOG_GETPROCADDRESS_CALLS)
        {
            Log(0, 0, "     Log GetProcAddress function calls.\n");
        }
    }
    if (m_dwProfileFlags & PF_LOG_THREADS)
    {
        Log(0, 0, "     Log thread information.\n");
        if (m_dwProfileFlags & PF_USE_THREAD_INDEXES)
        {
            Log(0, 0, "     Use simple thread numbers instead of actual thread IDs.\n");
        }
    }
    if (m_dwProfileFlags & PF_LOG_EXCEPTIONS)
    {
        Log(0, 0, "     Log first chance exceptions.\n");
    }
    if (m_dwProfileFlags & PF_LOG_DEBUG_OUTPUT)
    {
        Log(0, 0, "     Log debug output messages.\n");
    }
    if (m_dwProfileFlags & PF_USE_FULL_PATHS)
    {
        Log(0, 0, "     Use full paths when logging file names.\n");
    }
    if (m_dwProfileFlags & PF_LOG_TIME_STAMPS)
    {
        Log(0, 0, "     Log a time stamp with each line of log.\n");
    }
    if (m_dwProfileFlags & PF_PROFILE_CHILDREN)
    {
        Log(0, 0, "     Automatically open and profile child processes.\n");
    }

    Log(LOG_BOLD, 0, "--------------------------------------------------------------------------------\n");
    Log(0, 0, "\n");
}

//******************************************************************************
LPSTR CSession::AllocatePath(LPCSTR pszFilePath, LPSTR &pszEnvPath)
{
    LPSTR pszPath  = NULL;
    HKEY  hKey     = NULL;
    bool  fSuccess = false;

    __try
    {
        // Build the subkey name.
        CHAR szSubKey[80 + MAX_PATH];
        StrCCpy(szSubKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\", sizeof(szSubKey));
        StrCCat(szSubKey, GetFileNameFromPath(pszFilePath), sizeof(szSubKey));

        // Attempt to open the key. It is very likely the key doesn't even exist.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_QUERY_VALUE, &hKey) || !hKey)
        {
            __leave;
        }

        // Get the length of the PATH registry variable.
        DWORD dwRegSize = 0;
        if (RegQueryValueEx(hKey, "Path", NULL, NULL, NULL, &dwRegSize) || !dwRegSize) // inspected
        {
            __leave;
        }

        // Get the length of the PATH environment variable.
        DWORD dwEnvSize = GetEnvironmentVariable("Path", NULL, 0);
        if (!dwEnvSize)
        {
            __leave;
        }

        // Allocate a buffer.
        DWORD dwSize = dwRegSize + dwEnvSize + 4;

        pszPath = (LPSTR)MemAlloc(dwSize);
        *pszPath = '\0';

        // Get the PATH registry variable.
        if ((RegQueryValueEx(hKey, "Path", NULL, NULL, (LPBYTE)pszPath, &(dwRegSize = dwSize))) || (dwRegSize > dwSize) || !*pszPath) // inspected
        {
            __leave;
        }
        pszPath[dwSize - 1] = '\0';

        // Locate the end of the registry path and append a semicolon.
        pszEnvPath = pszPath + strlen(pszPath);
        *(pszEnvPath++) = ';';

        // Get the PATH environment variable.
        if ((dwEnvSize = GetEnvironmentVariable("Path", pszEnvPath, dwSize - (DWORD)(pszEnvPath - pszPath))) >= dwSize - (DWORD)(pszEnvPath - pszPath))
        {
            pszEnvPath = NULL;
            __leave;
        }

        // Ensure that the path is NULL terminated.
        pszEnvPath[dwEnvSize] = '\0';

        fSuccess = true;
    }
    __finally
    {
        // Close the registry key if we opened one.
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        // Free our buffer if we allocated it, but then failed.
        if (!fSuccess && pszPath)
        {
            MemFree((LPVOID&)pszPath); // will set pszPath to NULL
        }
    }

    return pszPath;
}

//******************************************************************************
BOOL CSession::IsExecutable()
{
    // We are ready to execute if we have a root file, we are not currently
    // debugging it, we are not a DWI session, it is an executable, not a DLL,
    // is for our architecture, and is not for CE.
    //
    // We used to require the IMAGE_FILE_32BIT_MACHINE bit be set, but it turns
    // out that this bit is not required to be set.  In fact, many modules from
    // the COM+ team do not have this bit set.

    return (m_pModuleRoot && !m_pProcess && !(m_dwFlags & DWSF_DWI) &&
           (m_pModuleRoot->GetCharacteristics() & IMAGE_FILE_EXECUTABLE_IMAGE) &&
           !(m_pModuleRoot->GetCharacteristics() & IMAGE_FILE_DLL) &&
#if defined(_IA64_)
           (m_pModuleRoot->GetMachineType() == IMAGE_FILE_MACHINE_IA64) &&
#elif defined(_X86_)
           (m_pModuleRoot->GetMachineType() == IMAGE_FILE_MACHINE_I386) &&
#elif defined(_ALPHA64_) // Must come before _ALPHA_ check
           (m_pModuleRoot->GetMachineType() == IMAGE_FILE_MACHINE_ALPHA64) &&
#elif defined(_ALPHA_)
           (m_pModuleRoot->GetMachineType() == IMAGE_FILE_MACHINE_ALPHA) &&
#elif defined(_AMD64_)
           (m_pModuleRoot->GetMachineType() == IMAGE_FILE_MACHINE_AMD64) &&
#else
#error("Unknown Target Machine");
#endif
           (m_pModuleRoot->GetSubsystemType() != IMAGE_SUBSYSTEM_WINDOWS_OLD_CE_GUI) &&
           (m_pModuleRoot->GetSubsystemType() != IMAGE_SUBSYSTEM_WINDOWS_CE_GUI));
}

//******************************************************************************
bool CSession::SaveToDwiFile(HANDLE hFile)
{
    // Build our DWI file header
    DWI_HEADER dwih;
    dwih.dwSignature   = DWI_SIGNATURE;
    dwih.wFileRevision = DWI_FILE_REVISION;
    dwih.wMajorVersion = VERSION_MAJOR;
    dwih.wMinorVersion = VERSION_MINOR;
    dwih.wBuildVersion = VERSION_BUILD;
    dwih.wPatchVersion = VERSION_PATCH;
    dwih.wBetaVersion  = VERSION_BETA;

    // Write our DWI file header to the file.
    if (!WriteBlock(hFile, &dwih, sizeof(dwih)))
    {
        return false;
    }

    // Get the system info - use the one from our session if it exists (means
    // it is a DWI file), otherwise, create a live sys info.
    SYSINFO si, *psi = m_pSysInfo;
    if (!psi)
    {
        BuildSysInfo(psi = &si);
    }

    // Write our system information to the file.
    if (!WriteBlock(hFile, psi, sizeof(si)))
    {
        return false;
    }

    // Build our session information.
    DISK_SESSION ds;
    ds.dwSessionFlags = m_dwFlags;
    ds.dwReturnFlags  = m_dwReturnFlags;
    ds.dwMachineType  = m_dwMachineType;

    // Remember our current file pointer and then move it down so that we make
    // room for a DISK_SESSION block to be written later.
    DWORD dwPointer1 = GetFilePointer(hFile);
    SetFilePointer(hFile, sizeof(ds), NULL, FILE_CURRENT);

    // Store all the search groups.
    if (-1 == (int)(ds.dwNumSearchGroups = SaveSearchGroups(hFile)))
    {
        return false;
    }

    // Store all the module data blocks.
    if (-1 == (int)(ds.dwNumModuleDatas = RecursizeSaveModuleData(hFile, m_pModuleRoot)))
    {
        return false;
    }

    // Store all the module blocks.
    if (-1 == (int)(ds.dwNumModules = RecursizeSaveModule(hFile, m_pModuleRoot)))
    {
        return false;
    }

    // Go back to our DISK_SESSION area, write out the block, and restore the
    // file pointer back to it current location.
    DWORD dwPointer2 = GetFilePointer(hFile);
    if ((SetFilePointer(hFile, dwPointer1, NULL, FILE_BEGIN) == 0xFFFFFFFF) ||
        !WriteBlock(hFile, &ds, sizeof(ds)) ||
        (SetFilePointer(hFile, dwPointer2, NULL, FILE_BEGIN) == 0xFFFFFFFF))
    {
        return false;
    }

    return true;
}

//******************************************************************************
int CSession::SaveSearchGroups(HANDLE hFile)
{
    DISK_SEARCH_GROUP dsg;
    DISK_SEARCH_NODE  dsn;
    int               cGroups = 0;

    for (CSearchGroup *psg = m_psgHead; psg; psg = psg->GetNext())
    {
        // Fill in our DISK_SEARCH_GROUP structure.
        dsg.wType = (WORD)psg->GetType();
        dsg.wNumDirNodes = 0;

        // SxS Hack: Since we want to remain compatible with the DW 2.0's DWI
        // format, we need to convert our types to match the old type values.
        // We also need to a special way to save the SxS group since DW 2.0
        // did not support this group type.  We do this by saving it as a
        // UserDir group and add a special fake file node under it.  To a DW 2.0
        // user, they will just see UserDir with a file named "<Side-by-Side Components>"
        // under it.  DW 2.1 knows to convert this back into a SxS group.
        //
        //    Type             2.0 2.1
        //    ---------------- --- ---
        //    SG_USER_DIR        0   0
        //    SG_SIDE_BY_SIDE    -   1
        //    SG_KNOWN_DLLS      1   2
        //    SG_APP_DIR         2   3
        //    SG_32BIT_SYS_DIR   3   4
        //    SG_16BIT_SYS_DIR   4   5
        //    SG_OS_DIR          5   6
        //    SG_APP_PATH        6   7
        //    SG_SYS_PATH        7   8
        //    SG_COUNT           8   9
        //
        bool fSxS = false;
        if (dsg.wType == SG_SIDE_BY_SIDE)
        {
            dsg.wType = SG_USER_DIR;
            dsg.wNumDirNodes++;
            fSxS = true;
        }
        else if (dsg.wType != SG_USER_DIR)
        {
            dsg.wType--;
        }

        // Count the number of search nodes that this group has.
        for (CSearchNode *psn = psg->GetFirstNode(); psn; psn = psn->GetNext())
        {
            dsg.wNumDirNodes++;
        }

        // Write the DISK_SEARCH_GROUP to the file.
        if (!WriteBlock(hFile, &dsg, sizeof(dsg)))
        {
            return -1;
        }

        // SxS Hack: We write our a fake node to identify this group as the SxS group.
        if (fSxS)
        {
            dsn.dwFlags = SNF_FILE;
            if (!WriteBlock(hFile, &dsn, sizeof(dsn)) || !WriteString(hFile, "<Side-by-Side Components>"))
            {
                return -1;
            }
        }

        // Write each search node to the file.
        for (psn = psg->GetFirstNode(); psn; psn = psn->GetNext())
        {
            // Get the flags for this search node.
            dsn.dwFlags = psn->UpdateErrorFlag();

            // Write the DISK_SEARCH_NODE and path to the file.
            if (!WriteBlock(hFile, &dsn, sizeof(dsn)) || !WriteString(hFile, psn->GetPath()))
            {
                return -1;
            }

            // If this is a named file, then write the name as well.
            if (dsn.dwFlags & SNF_NAMED_FILE)
            {
                if (!WriteString(hFile, psn->GetName()))
                {
                    return NULL;
                }
            }
        }

        // Increment our group counter.
        cGroups++;
    }

    return cGroups;
}

//******************************************************************************
int CSession::RecursizeSaveModuleData(HANDLE hFile, CModule *pModule)
{
    if (!pModule)
    {
        return 0;
    }

    int total = 0, count;

    // Save this module data to disk if this module is an original.
    if (pModule->IsOriginal())
    {
        if (!SaveModuleData(hFile, pModule->m_pData))
        {
            return -1;
        }
        total++;
    }

    // Recurse into our children.
    if ((count = RecursizeSaveModuleData(hFile, pModule->m_pDependents)) == -1)
    {
        return -1;
    }
    total += count;

    // Recurse into our siblings.
    if ((count = RecursizeSaveModuleData(hFile, pModule->m_pNext)) == -1)
    {
        return -1;
    }

    return total + count;
}

//******************************************************************************
BOOL CSession::SaveModuleData(HANDLE hFile, CModuleData *pModuleData)
{
    // Build the module data structure
    DISK_MODULE_DATA dmd;
    dmd.dwlKey                  = (DWORDLONG)pModuleData;
    dmd.dwFlags                 = pModuleData->m_dwFlags;
    dmd.dwSymbolFlags           = pModuleData->m_dwSymbolFlags;
    dmd.dwCharacteristics       = pModuleData->m_dwCharacteristics;
    dmd.ftFileTimeStamp         = pModuleData->m_ftFileTimeStamp;
    dmd.ftLinkTimeStamp         = pModuleData->m_ftLinkTimeStamp;
    dmd.dwFileSize              = pModuleData->m_dwFileSize;
    dmd.dwAttributes            = pModuleData->m_dwAttributes;
    dmd.dwMachineType           = pModuleData->m_dwMachineType;
    dmd.dwLinkCheckSum          = pModuleData->m_dwLinkCheckSum;
    dmd.dwRealCheckSum          = pModuleData->m_dwRealCheckSum;
    dmd.dwSubsystemType         = pModuleData->m_dwSubsystemType;
    dmd.dwlPreferredBaseAddress = pModuleData->m_dwlPreferredBaseAddress;
    dmd.dwlActualBaseAddress    = pModuleData->m_dwlActualBaseAddress;
    dmd.dwVirtualSize           = pModuleData->m_dwVirtualSize;
    dmd.dwLoadOrder             = pModuleData->m_dwLoadOrder;
    dmd.dwImageVersion          = pModuleData->m_dwImageVersion;
    dmd.dwLinkerVersion         = pModuleData->m_dwLinkerVersion;
    dmd.dwOSVersion             = pModuleData->m_dwOSVersion;
    dmd.dwSubsystemVersion      = pModuleData->m_dwSubsystemVersion;
    dmd.dwFileVersionMS         = pModuleData->m_dwFileVersionMS;
    dmd.dwFileVersionLS         = pModuleData->m_dwFileVersionLS;
    dmd.dwProductVersionMS      = pModuleData->m_dwProductVersionMS;
    dmd.dwProductVersionLS      = pModuleData->m_dwProductVersionLS;

    // Count the number of exports we have.
    dmd.dwNumExports = 0;
    for (CFunction *pFunction = pModuleData->m_pExports; pFunction; pFunction = pFunction->m_pNext)
    {
        dmd.dwNumExports++;
    }

    // Write out our module data structure followed by the path and error strings.
    if (!WriteBlock(hFile, &dmd, sizeof(dmd)) ||
        !WriteString(hFile, pModuleData->m_pszPath) ||
        !WriteString(hFile, pModuleData->m_pszError))
    {
        return FALSE;
    }

    // Loop through each export, writing each to disk.
    for (pFunction = pModuleData->m_pExports; pFunction; pFunction = pFunction->m_pNext)
    {
        if (!SaveFunction(hFile, pFunction))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
int CSession::RecursizeSaveModule(HANDLE hFile, CModule *pModule)
{
    if (!pModule)
    {
        return 0;
    }

    int total = 0, count;

    // Save this module to disk.
    if (!SaveModule(hFile, pModule))
    {
        return -1;
    }
    total++;

    // Recurse into our children.
    if ((count = RecursizeSaveModule(hFile, pModule->m_pDependents)) == -1)
    {
        return -1;
    }
    total += count;

    // Recurse into our siblings.
    if ((count = RecursizeSaveModule(hFile, pModule->m_pNext)) == -1)
    {
        return -1;
    }

    return total + count;
}

//******************************************************************************
BOOL CSession::SaveModule(HANDLE hFile, CModule *pModule)
{
    // Build the module structure
    DISK_MODULE dm;
    dm.dwlModuleDataKey = (DWORDLONG)pModule->m_pData;
    dm.dwFlags          = pModule->m_dwFlags;
    dm.dwDepth          = pModule->m_dwDepth;

    // Count the number of imports we have.
    dm.dwNumImports = 0;
    for (CFunction *pFunction = pModule->m_pParentImports; pFunction; pFunction = pFunction->m_pNext)
    {
        dm.dwNumImports++;
    }

    // Write out our module structure.
    if (!WriteBlock(hFile, &dm, sizeof(dm)))
    {
        return FALSE;
    }

    // Loop through each import, writing each to disk.
    for (pFunction = pModule->m_pParentImports; pFunction; pFunction = pFunction->m_pNext)
    {
        if (!SaveFunction(hFile, pFunction))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
BOOL CSession::SaveFunction(HANDLE hFile, CFunction *pFunction)
{
    // Build our function structure.
    DISK_FUNCTION df;
    df.dwFlags    = pFunction->m_dwFlags;
    df.wOrdinal   = pFunction->m_wOrdinal;
    df.wHint      = pFunction->m_wHint;

    // Make sure we remove the CALLED flag from exports.
    if (pFunction->IsExport())
    {
        df.dwFlags &= ~DWFF_CALLED;
    }

    // Write out the function structure.
    if (!WriteBlock(hFile, &df, sizeof(df)))
    {
        return FALSE;
    }

    // If 64-bits are used, then write out the 64-bit address.
    if (df.dwFlags & DWFF_64BITS_USED)
    {
        DWORDLONG dwlAddress = pFunction->GetAddress();
        if (!WriteBlock(hFile, &dwlAddress, sizeof(dwlAddress)))
        {
            return FALSE;
        }
    }

    // Otherwsie, check to see if 32-bits are used.
    else if (df.dwFlags & DWFF_32BITS_USED)
    {
        DWORD dwAddress = (DWORD)pFunction->GetAddress();
        if (!WriteBlock(hFile, &dwAddress, sizeof(dwAddress)))
        {
            return FALSE;
        }
    }

    // If this function has a name, then write it out.
    if (df.dwFlags & DWFF_NAME)
    {
        if (!WriteString(hFile, pFunction->GetName()))
        {
            return FALSE;
        }
    }

    // If this is a forwared export, then write out the forward name.
    if ((df.dwFlags & DWFF_EXPORT) && (df.dwFlags & DWFF_FORWARDED))
    {
        if (!WriteString(hFile, pFunction->GetExportForwardName()))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
CFunction* CSession::ReadFunction(HANDLE hFile)
{
    // Read our function structure.
    DISK_FUNCTION df;
    if (!ReadBlock(hFile, &df, sizeof(df)))
    {
        return NULL;
    }

    // If 64-bits are used, then read in a 64-bit address.
    DWORDLONG dwlAddress = 0;
    if (df.dwFlags & DWFF_64BITS_USED)
    {
        if (!ReadBlock(hFile, &dwlAddress, sizeof(dwlAddress)))
        {
            return NULL;
        }
    }

    // Otherwsie, if 32-bits are used, then read in a 32-bit address.
    else if (df.dwFlags & DWFF_32BITS_USED)
    {
        DWORD dwAddress;
        if (!ReadBlock(hFile, &dwAddress, sizeof(dwAddress)))
        {
            return NULL;
        }
        dwlAddress = (DWORDLONG)dwAddress;
    }

    // If this function has a name, then read it.
    LPSTR pszName = NULL;
    if (df.dwFlags & DWFF_NAME)
    {
        if (!ReadString(hFile, pszName))
        {
            return NULL;
        }
    }

    // If this is a forwared export, then read in the formard name.
    LPSTR pszForward = NULL;
    if ((df.dwFlags & DWFF_EXPORT) && (df.dwFlags & DWFF_FORWARDED))
    {
        if (!ReadString(hFile, pszForward))
        {
            MemFree((LPVOID&)pszName);
            return NULL;
        }
    }

    // Create the function object.  We ensure the save flags have been removed.
    CFunction *pFunction = CreateFunction(
        df.dwFlags & ~(DWFF_32BITS_USED | DWFF_64BITS_USED),
        df.wOrdinal, df.wHint, pszName, dwlAddress, pszForward, TRUE);
    
    // Free the name string.
    MemFree((LPVOID&)pszName);

    return pFunction;
}

//******************************************************************************
BOOL CSession::ReadDwi(HANDLE hFile, LPCSTR pszPath)
{
    CHAR             szError[DW_MAX_PATH + 64], *psz = szError;
    CModuleDataNode *pMDN, *pMDNHead = NULL, *pMDNLast = NULL;
    CModule         *pModule, *pModuleTree[256];
    int              depth = -1;

    // Initialize our flags to having only the DWI bit set.
    m_dwFlags = DWSF_DWI;

    // Read in the file header, minus the signature since we've already read that.
    DWI_HEADER dwih;
    if (!ReadBlock(hFile, ((LPDWORD)&dwih) + 1, sizeof(dwih) - sizeof(DWORD)))
    {
        m_dwReturnFlags |= DWRF_DWI_NOT_RECOGNIZED;
        return FALSE;
    }

    // Check to see if we don't handle this file format revision.
    if (dwih.wFileRevision != DWI_FILE_REVISION)
    {
        psz += SCPrintf(szError, sizeof(szError),
                        "The format of \"%s\" is not supported by "
                        "this version of Dependency Walker.\n\n"
                        "It was created using Dependency Walker version %u.%u",
                        pszPath, (DWORD)dwih.wMajorVersion, (DWORD)dwih.wMinorVersion);
        if ((dwih.wPatchVersion > 0) && (dwih.wPatchVersion < 27) && ((psz - szError) < sizeof(szError)))
        {
            *psz++ = (CHAR)((int)'a' - 1 + (int)dwih.wPatchVersion);
            *psz   = '\0';
        }
        if (dwih.wBetaVersion)
        {
            SCPrintf(psz, sizeof(szError) - (int)(psz - szError), " Beta %u", dwih.wBetaVersion);
        }
        if (dwih.wBuildVersion)
        {
            SCPrintf(psz, sizeof(szError) - (int)(psz - szError), " (Build %u)", dwih.wBuildVersion);
        }
        m_pszReadError = StrAlloc(szError);
        m_dwReturnFlags |= DWRF_DWI_NOT_RECOGNIZED;
        return FALSE;
    }

    // Read in the session data.
    if (!(m_pSysInfo = new SYSINFO))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    if (!ReadBlock(hFile, m_pSysInfo, sizeof(SYSINFO)))
    {
        goto FORMAT_ERROR;
    }

    // Read in the session data.
    DISK_SESSION ds;
    if (!ReadBlock(hFile, &ds, sizeof(ds)))
    {
        goto FORMAT_ERROR;
    }

    // Add in our session and return flags.
    m_dwFlags       |= ds.dwSessionFlags;
    m_dwReturnFlags |= ds.dwReturnFlags;
    m_dwMachineType  = ds.dwMachineType;

    if (!ReadSearchGroups(hFile, ds.dwNumSearchGroups))
    {
        goto FORMAT_ERROR;
    }

    // Read in all the module datas
    for ( ; ds.dwNumModuleDatas > 0; ds.dwNumModuleDatas--)
    {
        // Read in the module data.
        if (!(pMDN = ReadModuleData(hFile)))
        {
            goto FORMAT_ERROR;
        }

        // Add the node to our list.
        if (pMDNLast)
        {
            pMDNLast->m_pNext = pMDN;
        }
        else
        {
            pMDNHead = pMDN;
        }
        pMDNLast = pMDN;
    }

    // Read in all the modules
    for ( ; ds.dwNumModules > 0; ds.dwNumModules--)
    {
        // Read in the module data.
        if (!(pModule = ReadModule(hFile, pMDNHead)))
        {
            goto FORMAT_ERROR;
        }

        if ((pModule->m_dwDepth > 255) || ((int)pModule->m_dwDepth > (depth + 1)))
        {
            //!! We need to (should) delete this module.
            SetLastError(0);
            goto FORMAT_ERROR;
        }

        // Check the imports against the exports.
        VerifyParentImports(pModule);

        // If we have a depth greater than zero, then set our parent module pointer.
        if (pModule->m_dwDepth)
        {
            pModule->m_pParent = pModuleTree[pModule->m_dwDepth - 1];
        }

        // If we have a previous module, then set it's next pointer to us.
        if ((int)pModule->m_dwDepth <= depth)
        {
            pModuleTree[pModule->m_dwDepth]->m_pNext = pModule;
        }

        // Otherwise, we must be the first dependent of our parent module.
        else if (pModule->m_dwDepth)
        {
            pModuleTree[pModule->m_dwDepth - 1]->m_pDependents = pModule;
        }

        // If this is our first module, then point our root pointer at it.
        if (depth == -1)
        {
            m_pModuleRoot = pModule;
        }

        // set our depth to this module's depth and add it to our depth table.
        pModuleTree[depth = pModule->m_dwDepth] = pModule;
    }

    // Free our module node list.
    while (pMDNHead)
    {
        pMDN = pMDNHead->m_pNext;
        delete pMDNHead;
        pMDNHead = pMDN;
    }

    return TRUE;

FORMAT_ERROR:

    // Free our module data node list.
    while (pMDNHead)
    {
        // If we never found an original module to take ownership of this module data,
        // then we need to free it now or it will get leaked.  If it has been processed,
        // then DeleteModule will free it.
        if (!pMDNHead->m_pModuleData->m_fProcessed)
        {
            // Delete all the exports.
            DeleteExportList(pMDNHead->m_pModuleData);

            // Delete the module data object.
            delete pMDNHead->m_pModuleData;
            m_dwModules--;
        }

        pMDN = pMDNHead->m_pNext;
        delete pMDNHead;
        pMDNHead = pMDN;
    }

    // Free any modules we managed to process.
    if (m_pModuleRoot)
    {
        DeleteModule(m_pModuleRoot, true);
        m_pModuleRoot = NULL;
    }

    // Delete our system info data if we allocated it.
    if (m_pSysInfo)
    {
        delete m_pSysInfo;
        m_pSysInfo = NULL;
    }

    // Free our search order.
    CSearchGroup::DeleteSearchOrder(m_psgHead);

    // Build the error string.
    DWORD dwError = GetLastError();
    SCPrintf(szError, sizeof(szError), "An error occurred while reading \"%s\".", pszPath);
    m_pszReadError = BuildErrorMessage(dwError, szError);

    m_dwReturnFlags |= DWRF_DWI_NOT_RECOGNIZED;

    return FALSE;
}

//******************************************************************************
BOOL CSession::ReadSearchGroups(HANDLE hFile, DWORD dwGroups)
{
    DISK_SEARCH_GROUP dsg;
    DISK_SEARCH_NODE  dsn;
    CSearchGroup     *psgLast = NULL, *psgNew;
    LPSTR             szPath, szName;

    // Loop through each search group.
    for (; dwGroups; dwGroups--)
    {
        // Read in the DISK_SEARCH_GROUP for this search group.
        if (!ReadBlock(hFile, &dsg, sizeof(dsg)))
        {
            return FALSE;
        }

        // SxS Hack: Update the type to reflect our new 2.1 types.
        //
        //    Type             2.0 2.1
        //    ---------------- --- ---
        //    SG_USER_DIR        0   0
        //    SG_SIDE_BY_SIDE    -   1
        //    SG_KNOWN_DLLS      1   2
        //    SG_APP_DIR         2   3
        //    SG_32BIT_SYS_DIR   3   4
        //    SG_16BIT_SYS_DIR   4   5
        //    SG_OS_DIR          5   6
        //    SG_APP_PATH        6   7
        //    SG_SYS_PATH        7   8
        //    SG_COUNT           8   9
        //
        if (dsg.wType != SG_USER_DIR)
        {
            dsg.wType++;
        }

        CSearchNode *psnHead = NULL;

        // Loop through each search node for this search group.
        for (; dsg.wNumDirNodes; dsg.wNumDirNodes--)
        {
            // Read in the DISK_SEARCH_GROUP for this search group.
            szPath = NULL;
            if (!ReadBlock(hFile, &dsn, sizeof(dsn)) ||
                !ReadString(hFile, szPath))
            {
                CSearchGroup::DeleteNodeList(psnHead);
                return FALSE;
            }

            // Check to see if this node is a named file.
            if (dsn.dwFlags & SNF_NAMED_FILE)
            {
                // If so, then read in the name.
                if (!ReadString(hFile, szName))
                {
                    CSearchGroup::DeleteNodeList(psnHead);
                    return FALSE;
                }

                // Create the named file node and insert it into the list.
                psnHead = CSearchGroup::CreateFileNode(psnHead, dsn.dwFlags | SNF_DWI, szPath, szName);

                // Free our name string that was allocated by ReadString().
                MemFree((LPVOID&)szName);
            }
            else if (dsn.dwFlags & SNF_FILE)
            {
                // SxS Hack: Check to see if this is really our Side-by-Side group.
                if ((dsg.wType == SG_USER_DIR) && !strcmp(szPath, "<Side-by-Side Components>"))
                {
                    // If it is, then don't add this fake node and change our type to SxS.
                    dsg.wType = SG_SIDE_BY_SIDE;
                }

                // Otherwise, proceed as normal. 
                else
                {
                    // Create the unnamed file node and insert it into the list.
                    psnHead = CSearchGroup::CreateFileNode(psnHead, dsn.dwFlags | SNF_DWI, szPath);
                }
            }

            // Otherwise, it is just a directory node.
            else if (psnHead)
            {
                // If we have a head node, then walk to the end of the list.
                for (CSearchNode *psnLast = psnHead; psnLast->m_pNext; psnLast = psnLast->m_pNext)
                {
                }
                psnLast->m_pNext = CSearchGroup::CreateNode(szPath, dsn.dwFlags | SNF_DWI);;
            }

            // If there is no head node, then just make this new node our head node.
            else
            {
                psnHead = CSearchGroup::CreateNode(szPath, dsn.dwFlags | SNF_DWI);
            }

            // Free our string that was allocated by ReadString().
            MemFree((LPVOID&)szPath);
        }

        // Create the search group.
        if (!(psgNew = new CSearchGroup((SEARCH_GROUP_TYPE)dsg.wType, psnHead)))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }

        // Add the search group to our list.
        if (psgLast)
        {
            psgLast->m_pNext = psgNew;
        }
        else
        {
            m_psgHead = psgNew;
        }
        psgLast = psgNew;
    }

    return TRUE;
}

//******************************************************************************
CModuleDataNode* CSession::ReadModuleData(HANDLE hFile)
{
    CFunction *pFunction, *pFunctionLast = NULL;

    // read in the module data block
    DISK_MODULE_DATA dmd;
    if (!ReadBlock(hFile, &dmd, sizeof(dmd)))
    {
        return NULL;
    }

    // Create a CModuleData object.
    CModuleData *pModuleData = new CModuleData();
    if (!pModuleData)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    m_dwModules++;

    // Fill in the CModuleData object with the data from the file.
    pModuleData->m_dwFlags                 = dmd.dwFlags;
    pModuleData->m_dwSymbolFlags           = dmd.dwSymbolFlags;
    pModuleData->m_dwCharacteristics       = dmd.dwCharacteristics;
    pModuleData->m_ftFileTimeStamp         = dmd.ftFileTimeStamp;
    pModuleData->m_ftLinkTimeStamp         = dmd.ftLinkTimeStamp;
    pModuleData->m_dwFileSize              = dmd.dwFileSize;
    pModuleData->m_dwAttributes            = dmd.dwAttributes;
    pModuleData->m_dwMachineType           = dmd.dwMachineType;
    pModuleData->m_dwLinkCheckSum          = dmd.dwLinkCheckSum;
    pModuleData->m_dwRealCheckSum          = dmd.dwRealCheckSum;
    pModuleData->m_dwSubsystemType         = dmd.dwSubsystemType;
    pModuleData->m_dwlPreferredBaseAddress = dmd.dwlPreferredBaseAddress;
    pModuleData->m_dwlActualBaseAddress    = dmd.dwlActualBaseAddress;
    pModuleData->m_dwVirtualSize           = dmd.dwVirtualSize;
    pModuleData->m_dwLoadOrder             = dmd.dwLoadOrder;
    pModuleData->m_dwImageVersion          = dmd.dwImageVersion;
    pModuleData->m_dwLinkerVersion         = dmd.dwLinkerVersion;
    pModuleData->m_dwOSVersion             = dmd.dwOSVersion;
    pModuleData->m_dwSubsystemVersion      = dmd.dwSubsystemVersion;
    pModuleData->m_dwFileVersionMS         = dmd.dwFileVersionMS;
    pModuleData->m_dwFileVersionLS         = dmd.dwFileVersionLS;
    pModuleData->m_dwProductVersionMS      = dmd.dwProductVersionMS;
    pModuleData->m_dwProductVersionLS      = dmd.dwProductVersionLS;

//  Some code if we ever need to convert this local time to a utc time.
//  DWORDLONG dwl;
//  dwl = (*(LONGLONG*)&dmd.ftFileTimeStamp) + ((LONGLONG)m_pSysInfo->lBias * (LONGLONG)600000000i64);
//  pModuleData->m_ftFileTimeStamp = *(FILETIME*)&dwl;
//  dwl = (*(LONGLONG*)&dmd.ftLinkTimeStamp) + ((LONGLONG)m_pSysInfo->lBias * (LONGLONG)600000000i64);
//  pModuleData->m_ftLinkTimeStamp = *(FILETIME*)&dwl;

    // Read in the path and error strings.
    if (!ReadString(hFile, pModuleData->m_pszPath) || !pModuleData->m_pszPath ||
        !ReadString(hFile, pModuleData->m_pszError))
    {
        goto FORMAT_ERROR;
    }

    // Set the file pointer to the file portion of the path.
    if (pModuleData->m_pszFile = strrchr(pModuleData->m_pszPath, '\\'))
    {
        pModuleData->m_pszFile++;
    }
    else
    {
        pModuleData->m_pszFile = pModuleData->m_pszPath;
    }

    // Read in all the export functions.
    for ( ; dmd.dwNumExports > 0; dmd.dwNumExports--)
    {
        // Read the function in and create a function object.
        if (!(pFunction = ReadFunction(hFile)))
        {
            goto FORMAT_ERROR;
        }

        // Add the function to the end of our function list.
        if (pFunctionLast)
        {
            pFunctionLast->m_pNext = pFunction;
        }
        else
        {
            pModuleData->m_pExports = pFunction;
        }
        pFunctionLast = pFunction;
    }

    CModuleDataNode *pMDN;
    if (!(pMDN = new CModuleDataNode(pModuleData, dmd.dwlKey)))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }
    return pMDN;

FORMAT_ERROR:

    // Check to see if we allocated a module data object.
    if (pModuleData)
    {
        // Delete all the exports.
        DeleteExportList(pModuleData);

        // Delete the module data object.
        delete pModuleData;
        m_dwModules--;
    }
    return NULL;
}

//******************************************************************************
CModule* CSession::ReadModule(HANDLE hFile, CModuleDataNode *pMDN)
{
    CFunction *pFunction, *pFunctionLast = NULL;

    // Read in the module structure.
    DISK_MODULE dm;
    if (!ReadBlock(hFile, &dm, sizeof(dm)))
    {
        return NULL;
    }

    // Create a module object.
    CModule *pModule = new CModule();
    if (!pModule)
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Fill in the module object.
    pModule->m_dwFlags = dm.dwFlags;
    pModule->m_dwDepth = dm.dwDepth;

    // Read in all the import function structures.
    for ( ; dm.dwNumImports > 0; dm.dwNumImports--)
    {
        // Read the function in and create a function object.
        if (!(pFunction = ReadFunction(hFile)))
        {
            goto FORMAT_ERROR;
        }

        // Add the function to the end of our function list.
        if (pFunctionLast)
        {
            pFunctionLast->m_pNext = pFunction;
        }
        else
        {
            pModule->m_pParentImports = pFunction;
        }
        pFunctionLast = pFunction;
    }

    // Walk through all the module datas, looking for the one that this module should point to.
    for ( ; pMDN; pMDN = pMDN->m_pNext)
    {
        // Check to see if our keys match.
        if (pMDN->m_dwlKey == dm.dwlModuleDataKey)
        {
            // If so, then we belong together.
            pModule->m_pData = pMDN->m_pModuleData;

            // If this module is the original, then point the module data to it and mark
            // it as processed.
            if (!(pModule->m_dwFlags & DWMF_DUPLICATE))
            {
                pModule->m_pData->m_pModuleOriginal = pModule;
                pModule->m_pData->m_fProcessed = true;
            }

            // Return this module.
            return pModule;
        }
    }

    // If we did not find a module data to go with this module, then we fail.

FORMAT_ERROR:

    // Check to see if we allocated a module data object.
    if (pModule)
    {
        // Delete all the parent imports.
        DeleteParentImportList(pModule);

        // Delete the module data object.
        delete pModule;
    }
    return NULL;
}

//******************************************************************************
// The next few functions are called during profiling when a module was loaded
// with a path that differs from the path that we predicted during the passive
// scan.  This can happen if the user has the search path set up wrong, or the
// OS has added some new functionality that we are unaware of.  Whistler added
// support for a ".manifest" file that can override the default search path and
// possibly cause us to pick a bad path.  Anyway, if we got a bad path, we need
// to fix it.
//
// At first, this doesn't seem too difficult to fix, but it turns out to be
// fairly complicated.  For starters, if we have a path that is incorrect, then
// every instance of that module in the tree (and the one in the list) need to
// be replaced.  Also, the entire subtree of modules under each module that
// needs to be fixed becomes invalid since they are dependencies of the wrong
// module.  It is possible that the correct module has different dependencies.
// Maybe some functions are now implemented as a forward that didn't used to be,
// or vice versa.  Maybe some modules have been made delay-laod that didn't used
// to be.  Implicit dependencies may have been added or removed.
// 
// We would like to just be able to delete a incorrect module and its subtree,
// then add the correct module in its place and build the new subtree of
// dependencies.  However, the subtree cannot simply be deleted for a couple
// reasons.  First, there may be "original" modules in the subtree that
// "duplicate" modules elsewhere in the tree point to.  Second, if any of the
// modules in the subtree have ever been loaded, then we don't want to delete
// them, or we might be completely removing a guarenteed dependency from the
// UI.
//
// Our solution is to "orphan" the subtree instead of delete it.  We do this
// by moving the subtree to the bottom of the root of our tree.  We can then
// delete the incorrect module and add the correct module in its place.  Next,
// we process the new module, which in turn scans the tree when looking for
// dependencies, and will pick up "duplicates" of any orphans if needed.  We do
// this for the original instance of the incorrect module, plus every duplicate
// of the incorrect module.  Once done, all incorrect modules have been replaced
// and their new correct subtrees have been built, but we still have a bunch
// of orphans living in our root (MFC42.DLL leaves nearly 200 orphans just by
// itself).  So, we try to find a home for each of these.
//
// Any orphan that is a duplicate can simply be deleted since it already has
// a home somewhere else in the tree.  Like with the incorrect module that
// started all this, we cannot simply delete a module if it has a subtree.
// So, before deleting the duplicate orphan, we first orphan its children.
//
// If an orphan is an "original", then we scan the entire tree looking for
// a "duplicate" of that module.  If we find one, then we basically swap the
// two.  This is done by moving the core data from the original to the
// duplicate, then swapping the duplicate/original flags.  Now we have a
// duplicate orphan and can delete it (after we orphan its children).  The
// only exception to this is if the only duplicates are part of the subtree
// of the original.  Doing a swap like that is bad since it can cause all
// sorts of recursive parent/child pointers.  In this fairly rare case, we
// just add the original module and its subtree to the root.
//
// If we have a one-of-a-kind "original" module and cannot find any duplicates
// for it, then we check to see if the module has ever been loaded.  If not,
// then we just assume this module was a dependency of the incorrect module,
// and that the new correct module does not require it.  With that, we delete
// it (again, after orphaning its children).  If the "original" orphan has
// been loaded and we cannot find a duplicate to swap it with, then we just
// add that module and its current subtree to the UI at the root level.  This
// would be an extreemely rare (if not impossible) case.
//
// In the end, we usually find a home for all orphans.
// 
// Along the way, we need to fix certain flags that change as a result of
// modules being changed and deleted.  Every time a module is deleted, we need
// clear the implicit, delay-load, and dynamic flags, then scan the entire
// tree for instances of this module and rebuild the flags.  Every time we
// break a parent/child relationship (like when we orphan modules), we need
// to clear all the DWFF_CALLED_ALO flags on all the exports for each child.
// Then we need to search the tree for each instance of each child module
// and rebuild the flags.
//
CModule* CSession::ChangeModulePath(CModule *pModuleOld, LPCSTR pszPath)
{
    // Swap out the original version of this old module.
    CModule *pModule, *pModuleNew = SwapOutModule(pModuleOld, pszPath);

    // Loop through all the duplicates of this old module and swap them out as well.
    while (pModule = FindModule(m_pModuleRoot, FMF_RECURSE | FMF_SIBLINGS | FMF_MODULE | FMF_DUPLICATE,
           (DWORD_PTR)pModuleOld))
    {
        ASSERT(!pModule->IsOriginal());
        SwapOutModule(pModule, pszPath);
        DeleteModule(pModule, false);
    }

    // Walk through all the orphaned modules and try to find a home for them.
    CModule *pModuleNext, *pModulePrev = m_pModuleRoot;
    for (pModule = m_pModuleRoot->m_pNext; pModule; pModule = pModuleNext)
    {
        bool fDelete = false;

        // Check to see if we found an orphan.
        if (pModule->m_dwFlags & DWMF_ORPHANED)
        {
            // Check to see if this orphan is an original.
            if (pModule->IsOriginal())
            {
                // Look for a duplicate of this module elsewhere in the tree.
                // The FMF_EXCLUDE_TREE flag tells FindModule to exclude our
                // module and all modules under it.  We do not want to swap
                // with a module that is a child of our module.  This is very
                // bad - results in abandoned modules and circular module loops.
                CModule *pModuleDup = FindModule(m_pModuleRoot,
                    FMF_RECURSE | FMF_SIBLINGS | FMF_MODULE | FMF_DUPLICATE | FMF_EXCLUDE_TREE,
                    (DWORD_PTR)pModule);
                
                // Check to see if we found a duplicate.
                if (pModuleDup)
                {
                    // Make that duplicate an original.
                    MoveOriginalToDuplicate(pModule, pModuleDup);

                    // Update the UI.
                    if (m_pfnProfileUpdate)
                    {
                        // Tell our list control that we have changed the original
                        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_CHANGE_ORIGINAL, (DWORD_PTR)pModule, (DWORD_PTR)pModuleDup);

                        // Walk up the tree to see if this new original is an orphan or a child of an orphan.
                        for (CModule *pModuleTemp = pModuleDup; pModuleTemp && !(pModuleTemp->m_dwFlags & DWMF_ORPHANED);
                             pModuleTemp = pModuleTemp->m_pParent)
                        {
                        }

                        // If we reached the root, then this module is not an
                        // orphan, so we go ahead and add the new tree.  If it
                        // is an orphan, then we will eventually get to it in
                        // this loop and handle it.
                        if (!pModuleTemp)
                        {
                            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_ADD_TREE, (DWORD_PTR)pModuleDup, 0);

                            // Remove the duplicate icon so it looks like an original.
                            pModuleDup->m_dwUpdateFlags = DWUF_TREE_IMAGE;
                            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pModuleDup, 0);
                            pModuleDup->m_dwUpdateFlags = 0;
                        }
                    }

                    // Make a note that we want to delete this module.
                    fDelete = true;
                }

                // There are two cases where we add the module.  The first is
                // when this original module has a duplicate of itself as a
                // dependent.  This is a difficult case to take care of, so we
                // just add the module to the root.  The second case is if this
                // original module has actually been loaded.  We don't want to
                // blow it away since it did load at some point, so it must be
                // needed. However, we don't have any place to put it, so we
                // just leave it here at the root.
                else if (FindModule(pModule, FMF_RECURSE | FMF_MODULE | FMF_DUPLICATE, (DWORD_PTR)pModule) ||
                         pModule->m_pData->m_dwLoadOrder)
                {
                    // Remove the orphan flag.
                    pModule->m_dwFlags &= ~DWMF_ORPHANED;

                    // Add this new tree to our UI.
                    if (m_pfnProfileUpdate)
                    {
                        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_ADD_TREE, (DWORD_PTR)pModule, 0);
                    }
                }

                // If this orphan has never actually loaded and has no
                // duplicates, then we can just blow it away.  It is most
                // likely just a module we brought in by mistake as a result of
                // its parent being the wrong module.  At this point we have
                // already replaced the previous parent with the right module
                // and processed it, so if this module was really needed we
                // would have found a dup of it under the new module.
                else
                {
                    fDelete = true;

                    // Orphan all of its children since we need to process
                    // them seperately.
                    OrphanDependents(pModule);
                }
            }
            
            // If this orphan is a duplicate, then we can just delete it.
            else
            {
                // Remove from list.
                fDelete = true;

                // Orphan all of its children since we need to process them seperately.
                OrphanDependents(pModule);
            }
        }

        // Get the next pointer after we are done processing, but before we
        // delete.  The above processing may have added more modules to the end
        // our root list, so we don't want to get the next pointer before that.
        pModuleNext = pModule->m_pNext;

        // If we are deleting this module, then do so now.  We leave the
        // previous pointer alone since it will still be the previous module
        // for the next pass.
        if (fDelete)
        {
            // Remove this module from our list.
            pModulePrev->m_pNext = pModuleNext;
            pModule->m_pNext = NULL;

            // Tell our UI to remove this module from the tree and list (if it is an original).
            if (m_pfnProfileUpdate)
            {
                m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_REMOVE_TREE, (DWORD_PTR)pModule, 0);
            }

            CModuleData *pData = NULL;
            if (!pModule->IsOriginal())
            {
                pData = pModule->m_pData;
            }

            // Delete the module.
            DeleteModule(pModule, false);

            if (pData)
            {
                // Clear the core module type flags, then rebuild them.  We need
                // to do this to remove any types that may not be valid anymore
                // as a result of this module being deleted.
                DWORD dwOldFlags = pData->m_dwFlags;
                BuildAloFlags();
                
                // If we changed the core flags, then update the image in the list view.
                if (m_pfnProfileUpdate && (pData->m_dwFlags != dwOldFlags))
                {
                    pData->m_pModuleOriginal->m_dwUpdateFlags = DWUF_LIST_IMAGE;
                    m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pData->m_pModuleOriginal, 0);
                    pData->m_pModuleOriginal->m_dwUpdateFlags = 0;
                }
            }
        }

        // If we did not delete the current module, then make it the new previous module.
        else
        {
            pModulePrev = pModule;
        }
    }

    DeleteModule(pModuleOld, false);

    return pModuleNew;
}

//******************************************************************************
CModule* CSession::SwapOutModule(CModule *pModuleOld, LPCSTR pszPath)
{
    // Create the new node.
    CModule *pModule, *pModulePrev, *pModuleNew = CreateModule(pModuleOld->m_pParent, pszPath);

    // Copy over the implicit, forward, and delay-load flags - these are the only
    // types of modules that we should encounter since we know the module has never
    // loaded.  We also copy over the orphaned flag in case we are replacing an orphan.
    // If we are replacing an orphan, then we don't want to add the new orphan to our
    // UI.  We let ChangeModulePath deal with adding orphans to the UI once all modules
    // have been processed.
    pModuleNew->m_dwFlags          |= (pModuleOld->m_dwFlags          & (DWMF_IMPLICIT     | DWMF_FORWARDED     | DWMF_DELAYLOAD | DWMF_ORPHANED));
    pModuleNew->m_pData->m_dwFlags |= (pModuleOld->m_pData->m_dwFlags & (DWMF_IMPLICIT_ALO | DWMF_FORWARDED_ALO | DWMF_DELAYLOAD_ALO));

    // Make sure this old module has a parent - it always should since it is an
    // implicit dependency of another module.
    if (pModuleOld->m_pParent)
    {
        // Search our parent's dependent list for the old module.
        for (pModulePrev = NULL, pModule = pModuleOld->m_pParent->m_pDependents;
             pModule; pModulePrev = pModule, pModule = pModule->m_pNext)
        {
            // If we found the old module, then remove the old module from the list
            // and insert our new module at the same location in the list.
            if (pModule == pModuleOld)
            {
                pModuleNew->m_pNext = pModule->m_pNext;
                if (pModulePrev)
                {
                    pModulePrev->m_pNext = pModuleNew;
                }
                else
                {
                    pModuleOld->m_pParent->m_pDependents = pModuleNew;
                }
                break;
            }
        }
    }

    else
    {
        // If we don't have a parent, then just search all root modules.
        for (pModulePrev = NULL, pModule = m_pModuleRoot;
             pModule; pModulePrev = pModule, pModule = pModule->m_pNext)
        {
            // If we found the old module, then remove the old module from the list
            // and insert our new module at the same location in the list.
            if (pModule == pModuleOld)
            {
                pModuleNew->m_pNext = pModule->m_pNext;
                if (pModulePrev)
                {
                    pModulePrev->m_pNext = pModuleNew;
                }
                else
                {
                    // If we get here, then we are swapping out the main exe module.
                    // This would be weird, but I suppose it could occur if the OS
                    // decided to execute a different module than was passed to
                    // CreateProcess.  I've never seen this happen, but can
                    // imagine there may be some reason in the future to support
                    // this - maybe to support runtime CPU emulation or something.
                    m_pModuleRoot = pModuleNew;
                }
                break;
            }
        }
    }

    // We should always find the module we are looking for.
    ASSERT(pModule);

    // Tell our UI to remove the old module from the tree (and its children) and list.
    // We need to do this before we orphan the children so our tree control can
    // zero out all the user datas for the children modules.
    if (m_pfnProfileUpdate)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_REMOVE_TREE, (DWORD_PTR)pModuleOld, 0);
    }

    // Orpan all of the old module's children so they can be picked up as
    // children of the new module.
    OrphanDependents(pModuleOld);

    // Process the new module.  Since the old dependents are part of our root,
    // this new module will pick them up as dependents if neccessary.
    ProcessModule(pModuleNew);

    // Move the parent import list from the old module to the new module.
    pModuleNew->m_pParentImports = pModuleOld->m_pParentImports;
    pModuleOld->m_pParentImports = NULL;

    // Go through and resolve all our parent's imports.
    VerifyParentImports(pModuleNew);

    // We need to call BuildAloFlags after ProcessModule and after VerifyParentImports.
    BuildAloFlags();

    // Tell our UI to add the new module to the tree (and it's children) and the list.
    if (m_pfnProfileUpdate)
    {
        // Walk up the tree to see if this new module is an orphan or a child of an orphan.
        for (CModule *pModuleTemp = pModuleNew; pModuleTemp && !(pModuleTemp->m_dwFlags & DWMF_ORPHANED);
             pModuleTemp = pModuleTemp->m_pParent)
        {
        }

        // If we reached the root, then this module is not an orphan, so we go
        // ahead and add the new tree.  If it an orphan, then we will eventually
        // get to it and handle it.
        if (!pModuleTemp)
        {
            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_ADD_TREE, (DWORD_PTR)pModuleNew, 0);
        }
    }

    return pModuleNew;
}

//******************************************************************************
void CSession::OrphanDependents(CModule *pModule)
{
    // Locate the last module at the root level.
    for (CModule *pModuleLast = m_pModuleRoot; pModuleLast->m_pNext; pModuleLast = pModuleLast->m_pNext)
    {
    }

    // Move our dependent list of the old module to the end of our root list.
    pModuleLast->m_pNext = pModule->m_pDependents;
    pModule->m_pDependents = NULL;

    // Loop through all these new root modules while fixing the flags and
    // nulling the parent.
    for (pModule = pModuleLast->m_pNext; pModule; pModule = pModule->m_pNext)
    {
        // Make sure we clear the forwarded flag and delay-load flag since these
        // both require a parent.
        pModule->m_dwFlags &= ~(DWMF_FORWARDED | DWMF_DELAYLOAD_ALO);

        // Flag each as being orphaned.
        pModule->m_dwFlags |= DWMF_ORPHANED;

        // NULL out their parent since they are now root modules and have no parent.
        pModule->m_pParent = NULL;

        // Delete all the parent imports of the module since it has no parent anymore.
        DeleteParentImportList(pModule);
    }

    // After all the parents have been nulled, make a second pass to fix the
    // depths and get rid of forwarded dependencies.
    for (pModule = pModuleLast->m_pNext; pModule; pModule = pModule->m_pNext)
    {
        // Fix the depths of the modules.
        SetDepths(pModule);

        // Remove the DWFF_CALLED_ALO flag from all the exports and rebuild them.
        UpdateCalledExportFlags(pModule);

        // It does not make sense for this module to have a forward dependency
        // since this implies that a parent module is calling a function in this
        // module that actually lives in a forward module.  Since we don't have
        // a parent anymore, then we can't have any forward dependencies.  If
        // we do have some left over from our previous parent (before this module
        // was orphaned), then orphan those forward dependencies as well.
        OrphanForwardDependents(pModule);
    }
}

//******************************************************************************
void CSession::OrphanForwardDependents(CModule *pModule)
{
    CModule *pLast = NULL, *pNext;

    // Loop through all the dependents of this module.
    for (CModule *pPrev = NULL, *pCur = pModule->m_pDependents; pCur; pCur = pNext)
    {
        // Get the next pointer now in case we have to move the current module.
        pNext = pCur->m_pNext;

        // Check to see if this is a forwarded module.
        if (pCur->m_dwFlags & DWMF_FORWARDED)
        {
            // Remove the node from our module's dependent list.
            if (pPrev)
            {
                pPrev->m_pNext = pCur->m_pNext;
            }
            else
            {
                pModule->m_pDependents = pCur->m_pNext;
            }

            // Clear the forwarded flag.
            pCur->m_dwFlags &= ~DWMF_FORWARDED;

            // Flag this module as being orphaned.
            pCur->m_dwFlags |= DWMF_ORPHANED;

            // NULL out the parent since it is now a root module and has no parent.
            pCur->m_pParent = NULL;

            // Delete all the parent imports of the module since it has no parent anymore.
            DeleteParentImportList(pCur);

            // Locate the last module at the root level.
            for (pLast = m_pModuleRoot; pLast->m_pNext; pLast = pLast->m_pNext)
            {
            }

            // Append this forwarded module to the end of the root list.
            pLast->m_pNext = pCur;

            // Fix the depths of the module.
            SetDepths(pCur);

            // Remove the DWFF_CALLED_ALO flag from all the exports and rebuild them.
            UpdateCalledExportFlags(pCur);

            // Make sure it does not have any forward dependents of its own.
            OrphanForwardDependents(pCur);
        }

        // If this is not a forwarded module, then just update our previous pointer
        // and continue searching.
        else
        {
            pPrev = pCur;
        }
    }
}

//******************************************************************************
void CSession::MoveOriginalToDuplicate(CModule *pModuleOld, CModule *pModuleNew)
{
    // Move the duplicate flag from the duplicate to the original.
    pModuleOld->m_dwFlags |=  DWMF_DUPLICATE;
    pModuleNew->m_dwFlags &= ~DWMF_DUPLICATE;

    // Tell the module data object who the new original module is.
    pModuleOld->m_pData->m_pModuleOriginal = pModuleNew;

    // Locate the last module in the old original's dependent list.
    for (CModule *pModuleOldLast = pModuleOld->m_pDependents;
         pModuleOldLast && pModuleOldLast->m_pNext;
         pModuleOldLast = pModuleOldLast->m_pNext)
    {
        // Along the way, tell each module that they have a new parent.
        pModuleOldLast->m_pParent = pModuleNew;
    }

    // Insert the old module's dependent list into the beginning of the new
    // module's dependent list.  The only modules that should already be in
    // the new module's list is forward dependents.
    if (pModuleOldLast)
    {
        // We need to set this last module's parent since it got skipped
        // in the above for loop. 
        pModuleOldLast->m_pParent = pModuleNew;

        pModuleOldLast->m_pNext   = pModuleNew->m_pDependents;
        pModuleNew->m_pDependents = pModuleOld->m_pDependents;
        pModuleOld->m_pDependents = NULL;

        // Fix the depths of all the old modules that just got put under this
        // new module.
        SetDepths(pModuleNew);
    }
}

//******************************************************************************
void CSession::SetDepths(CModule *pModule, bool fSiblings /*=false*/)
{
    if (pModule)
    {
        // Set the depth of this module to be one greater than its parent.
        pModule->m_dwDepth = (pModule->m_pParent ? (pModule->m_pParent->m_dwDepth + 1) : 0);

        // Recurse.
        SetDepths(pModule->m_pDependents, true);
        if (fSiblings)
        {
            SetDepths(pModule->m_pNext, true);
        }
    }
}

//******************************************************************************
void CSession::UpdateCalledExportFlags(CModule *pModule)
{
    // Remove the DWFF_CALLED_ALO flag from all of this module's export functions.
    for (CFunction *pExport = pModule->m_pData->m_pExports; pExport; pExport = pExport->m_pNext)
    {
        pExport->m_dwFlags &= ~DWFF_CALLED_ALO;
    }

    // Rebuild the flags.
    BuildCalledExportFlags(m_pModuleRoot, pModule->m_pData);

    // Let our UI know about this new import in case it needs to add it.
    if (m_pfnProfileUpdate)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_EXPORTS_CHANGED, (DWORD_PTR)pModule, 0);
    }
}

//******************************************************************************
void CSession::BuildCalledExportFlags(CModule *pModule, CModuleData *pModuleData)
{
    // Make sure we have a module.
    if (pModule)
    {
        // Check to see if this module matches the one we are looking for.
        if (pModule->m_pData == pModuleData)
        {
            // Loop through all the functions that our parent imports from us and
            // mark them as called in the export list.
            for (CFunction *pImport = pModule->m_pParentImports; pImport; pImport = pImport->m_pNext)
            {
                if (pImport->m_pAssociatedExport)
                {
                    pImport->m_pAssociatedExport->m_dwFlags |= DWFF_CALLED_ALO; 
                }
            }
        }

        // Recurse into our children and siblings.
        BuildCalledExportFlags(pModule->m_pDependents, pModuleData);
        BuildCalledExportFlags(pModule->m_pNext, pModuleData);
    }
}

//******************************************************************************
void CSession::BuildAloFlags()
{
    ClearAloFlags(m_pModuleRoot);
    SetAloFlags(m_pModuleRoot, DWMF_IMPLICIT_ALO);
    SetAloFlags(m_pModuleRoot, DWMF_IMPLICIT_ALO);
}

//******************************************************************************
void CSession::ClearAloFlags(CModule *pModule)
{
    // Make sure we have a module.
    if (pModule)
    {
        // Clear all our ALO flags.
        pModule->m_pData->m_dwFlags &= ~(DWMF_IMPLICIT_ALO | DWMF_FORWARDED_ALO | DWMF_DELAYLOAD_ALO | DWMF_DYNAMIC_ALO);

        // Recurse into ClearAloFlags() for all our dependents and siblings.
        ClearAloFlags(pModule->m_pDependents);
        ClearAloFlags(pModule->m_pNext);
    }
}

//******************************************************************************
void CSession::SetAloFlags(CModule *pModule, DWORD dwFlags)
{
    DWORD dwChildFlags;

    // Make sure we have a module.
    if (pModule)
    {
        // If this module is forwarded, then set the DWMF_FORWARDED_ALO flag.
        if (pModule->m_dwFlags & DWMF_FORWARDED)
        {
            pModule->m_pData->m_dwFlags |= DWMF_FORWARDED_ALO;
        }

        // If this module is implicit anywhere in the tree, OR
        // If the parent is implicit and this instance of the module is implicit,
        // Then set our DWMF_IMPLICIT_ALO flag.

        if ((pModule->m_pData->m_dwFlags & DWMF_IMPLICIT_ALO) ||
            ((DWMF_IMPLICIT_ALO == dwFlags) && !(pModule->m_dwFlags & (DWMF_DYNAMIC | DWMF_DELAYLOAD))))
        {
            pModule->m_pData->m_dwFlags |= DWMF_IMPLICIT_ALO;
            dwChildFlags = DWMF_IMPLICIT_ALO;
        }

        // Otherwise,
        // If this module is dynamic anywhere in the tree, OR
        // If the this instance of the module is dynamic, OR
        // If the parent is dynamic and this instance is implicit (i.e. not delayload), OR
        // If this module is loaded (we need to do this as it is possible to
        //    have a module be loaded, but never show up as dynamic in the tree.
        //    This occurs when hooking is not used and a delay-load module gets
        //    loaded.  We know the module loaded dynamically, but we don't know
        //    which instance of the module in the tree to update the flags on)
        // Then set our DWMF_DYNAMIC_ALO flag.

        else if ((pModule->m_pData->m_dwFlags & DWMF_DYNAMIC_ALO) ||
                 (pModule->m_dwFlags & DWMF_DYNAMIC) ||
                 ((DWMF_DYNAMIC_ALO == dwFlags) && !(pModule->m_dwFlags & DWMF_DELAYLOAD)) ||
                 pModule->m_pData->m_dwLoadOrder)
        {
            pModule->m_pData->m_dwFlags |= DWMF_DYNAMIC_ALO;
            dwChildFlags = DWMF_DYNAMIC_ALO;
        }

        // Otherwise, we assume this module is a delay-load only module.
        else
        {
            pModule->m_pData->m_dwFlags |= DWMF_DELAYLOAD_ALO;
            dwChildFlags = DWMF_DELAYLOAD_ALO;
        }

        // Recurse into SetAloFlags() for all our dependents and siblings.
        SetAloFlags(pModule->m_pDependents, dwChildFlags);
        SetAloFlags(pModule->m_pNext, dwFlags);
    }
}

//******************************************************************************
CModule* CSession::AddImplicitModule(LPCSTR pszModule, DWORD_PTR dwpBaseAddress)
{
    // Attempt to locate this module by its full path.
    CModule *pModule = FindModule(m_pModuleRoot,
        FMF_ORIGINAL | FMF_RECURSE | FMF_PATH | FMF_SIBLINGS, (DWORD_PTR)pszModule);
    
    // If that failed, then look for an implicit module with the same name that
    // has never been loaded.  We do this in case we got the path wrong during
    // our passive scan.
    if (!pModule)
    {
        pModule = FindModule(m_pModuleRoot,
            FMF_ORIGINAL | FMF_RECURSE | FMF_NEVER_LOADED | FMF_FILE | FMF_SIBLINGS,
            (DWORD_PTR)GetFileNameFromPath(pszModule));

        // If we found a module, then we need to fix its path.
        if (pModule)
        {
            // This following check ensures that szModule is a complete path and not
            // just a file name.  If it were just a file name, then it would send our
            // ChangeModulePath() into an infinite loop as it just replaced the same
            // module over and over.  It should never be just a file name since the path
            // comes from the debugging APIs and the debugging APIs are always supposed
            // to return a full path.  However, the one special case is NTDLL.DLL.
            // Prior to Windows XP, NT always reported no name for NTDLL.  We looked for
            // this special case and checked to see if it was really NTDLL.DLL, and built a
            // full path if it was.  On Windows XP, they decided to report "ntdll.dll" as
            // the name, so it bypassed our special case and made it here as just "NTDLL.DLL".
            // So, DW 2.0 on Windows XP just spins inside ChangeModulePath() forever.  We
            // now catch and handle "ntdll.dll" as well as the no-name case in our debugging
            // code, so this check below should not be neccessary, but it is here in case
            // another pathless DLL shows up in the debugging APIs in the future.
            if (GetFileNameFromPath(pszModule) != pszModule)
            {
                pModule = ChangeModulePath(pModule, pszModule);
            }
        }
        
        // If we did not find a module with that name in our tree, then we
        // just add the module as a dynamic module of our root.
        if (!pModule)
        {
            return AddDynamicModule(pszModule, dwpBaseAddress, false, false, false, false, NULL)->GetOriginal();
        }
    }

    // Mark this module as loaded.
    MarkModuleAsLoaded(pModule, (DWORDLONG)dwpBaseAddress, false);

    // Tell our UI to update this module if needed.
    if (m_pfnProfileUpdate && pModule->m_dwUpdateFlags)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pModule, 0);
        pModule->m_dwUpdateFlags = 0;
    }

    return pModule->GetOriginal();
}

//******************************************************************************
CModule* CSession::AddDynamicModule(LPCSTR pszModule, DWORD_PTR dwpBaseAddress, bool fNoResolve,
                                    bool fDataFile, bool fGetProcAddress, bool fForward,
                                    CModule *pParent)
{
    bool fAddTree = false;

    // First, check to see if we have already loaded this module.
    CModule *pModule = FindModule(pParent ? pParent->m_pDependents : m_pModuleRoot,
                                  (fForward ? FMF_FORWARD_ONLY : FMF_EXPLICIT_ONLY) | FMF_PATH | FMF_SIBLINGS,
                                  (DWORD_PTR)pszModule);

    // Check to see if we found a module.
    if (pModule)
    {
        // If the previous module was loaded as a data file, but this time it is
        // loaded as a real module then we remove the data file flag and flag our
        // image as updated.
        if (!fNoResolve && !fGetProcAddress && (pModule->m_dwFlags & DWMF_NO_RESOLVE))
        {
            pModule->m_dwFlags &= ~DWMF_NO_RESOLVE;
            pModule->m_dwUpdateFlags |= DWUF_TREE_IMAGE;
            fAddTree = true;

            // If the core module data is for a datafile, then we to mark
            // it as not processed so that it gets re-processed.
            if (pModule->m_pData->m_dwFlags & DWMF_NO_RESOLVE_CORE)
            {
                pModule->m_pData->m_dwFlags &= ~(DWMF_NO_RESOLVE_CORE | DWMF_DATA_FILE_CORE);
                pModule->m_pData->m_fProcessed = false;
                pModule->m_dwUpdateFlags |= DWUF_LIST_IMAGE;
            }
        }

        // If the module was previously loaded as a data-file, but now is loaded
        // as just a no-resolve, then remove the data-file bit from the core so
        // that the actual base address will show up in the list view instead of
        // the "Data file" text.
        else if (fNoResolve && !fDataFile && (pModule->m_pData->m_dwFlags & DWMF_DATA_FILE_CORE))
        {
            pModule->m_pData->m_dwFlags &= ~DWMF_DATA_FILE_CORE;
            pModule->m_dwUpdateFlags |= DWUF_LIST_IMAGE;
        }
    }
    else
    {
        fAddTree = true;

        // Create a new module object.
        pModule = CreateModule(pParent, pszModule);

        // If this module is loaded as a data file, then make a note of it.
        if (fNoResolve)
        {
            pModule->m_dwFlags |= DWMF_NO_RESOLVE;

            // If the core module data is new, then flag it as a data file
            // as well to prevent us from processing its dependents.
            if (!pModule->m_pData->m_fProcessed)
            {
                pModule->m_pData->m_dwFlags |= (DWMF_NO_RESOLVE_CORE | (fDataFile ? DWMF_DATA_FILE_CORE : 0));
            }

            // If the module was previously loaded as a data-file, but now is loaded
            // as just a no-resolve, then remove the data-file bit from the core so
            // that the actual base address will show up in the list view instead of
            // the "Data file" text.
            else if (!fDataFile && (pModule->m_pData->m_dwFlags & DWMF_DATA_FILE_CORE))
            {
                pModule->m_pData->m_dwFlags &= ~DWMF_DATA_FILE_CORE;
                pModule->m_dwUpdateFlags |= DWUF_LIST_IMAGE;
            }
        }

        // Otherwise, if it is not a data file and the core module is a data file,
        // then we need to change the core module to a non data file.
        else if (!fGetProcAddress && (pModule->m_pData->m_dwFlags & DWMF_NO_RESOLVE_CORE))
        {
            CModule *pModuleOldOriginal = pModule->m_pData->m_pModuleOriginal;

            // Since the original module is a data file and will never have
            // children under it, we need to make this new module the original
            // so that it can show the real dependent modules under it.  Otherwise,
            // this module would show up as a duplicate and the user would never
            // be able to view the dependent modules under it.
            pModule->m_pData->m_pModuleOriginal->m_dwFlags |= DWMF_DUPLICATE;
            pModule->m_dwFlags &= ~DWMF_DUPLICATE;
            pModule->m_pData->m_pModuleOriginal = pModule;

            // Tell the UI that the original changed.
            if (m_pfnProfileUpdate)
            {
                m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_CHANGE_ORIGINAL, (DWORD_PTR)pModuleOldOriginal, (DWORD_PTR)pModule);
            }

            // Mark it as not processed so that it gets re-processed.
            pModule->m_pData->m_dwFlags &= ~(DWMF_NO_RESOLVE_CORE | DWMF_DATA_FILE_CORE);
            pModule->m_pData->m_fProcessed = false;
            pModule->m_dwUpdateFlags |= DWUF_LIST_IMAGE;
        }

        // Mark this module as dynamic.
        pModule->m_dwFlags |= (fForward ? DWMF_FORWARDED : DWMF_DYNAMIC);

        if (pParent)
        {
            // Add the module to the end of our list.
            if (pParent->m_pDependents)
            {
                // Locate the end of our module list off of our root module.
                for (CModule *pModuleLast = pParent->m_pDependents; pModuleLast->m_pNext;
                    pModuleLast = pModuleLast->m_pNext)
                {
                }
                pModuleLast->m_pNext = pModule;
            }
            else
            {
                pParent->m_pDependents = pModule;
            }
        }
        else
        {
            // Add the module to the end of our list.
            if (m_pModuleRoot->m_pNext)
            {
                // Locate the end of our module list off of our root module.
                for (CModule *pModuleLast = m_pModuleRoot->m_pNext; pModuleLast->m_pNext;
                    pModuleLast = pModuleLast->m_pNext)
                {
                }
                pModuleLast->m_pNext = pModule;
            }
            else
            {
                m_pModuleRoot->m_pNext = pModule;
            }
        }
    }

    if (dwpBaseAddress)
    {
        // Check to see if this module is already loaded.
        bool fLoaded = (pModule->m_pData->m_dwFlags & DWMF_LOADED) ? true : false;

        // Mark this module as loaded.
        MarkModuleAsLoaded(pModule, (DWORDLONG)dwpBaseAddress, fDataFile);

        // If this is a data file and the module was not already loaded, then
        // mark the module as not loaded since data files are really never
        // "loaded" - they are rather mapped.
        if (fDataFile && !fLoaded)
        {
            pModule->m_pData->m_dwFlags &= ~DWMF_LOADED;
        }
    }

    // Process the new module if it has not been already processed.
    if (!pModule->m_pData->m_fProcessed)
    {
        ProcessModule(pModule);
    }

    // We need to call BuildAloFlags after changing pModule->m_dwFlags and after ProcessModule.
    BuildAloFlags();

    // Let our UI know about this possibly new tree.
    if (m_pfnProfileUpdate && fAddTree)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_ADD_TREE, (DWORD_PTR)pModule, 0);
    }

    // Tell our UI to update this module if needed.
    if (m_pfnProfileUpdate && pModule->m_dwUpdateFlags)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pModule, 0);
        pModule->m_dwUpdateFlags = 0;
    }

    return pModule;
}

//******************************************************************************
CModule* CSession::CreateModule(CModule *pParent, LPCSTR pszModPath)
{
    CHAR szPath[DW_MAX_PATH] = "", *pszFile = NULL;
    CModule *pModule, *pModuleOriginal = NULL;

    // Check to see if the file already has a path.
    if (pszFile = strrchr(pszModPath, '\\'))
    {
        // If so, then we use the path given.
        StrCCpy(szPath, pszModPath, sizeof(szPath));
        pszFile = szPath + (pszFile - pszModPath) + 1;
    }

    // If no path, then check to see if we already have a module by this name loaded.
    else if (pModuleOriginal = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_LOADED | FMF_FILE, (DWORD_PTR)pszModPath))
    {
        // If we do, then use this module's path as our path.
        StrCCpy(szPath, pModuleOriginal->m_pData->m_pszPath, sizeof(szPath));
        pszFile = szPath + (pModuleOriginal->m_pData->m_pszFile - pModuleOriginal->m_pData->m_pszPath);
    }

    // Otherwise, search for this module in our search path.
    else
    {
        SearchPathForFile(pszModPath, szPath, sizeof(szPath), &pszFile);
    }

    // Create a new CModule object
    if (!(pModule = new CModule()))
    {
        RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

    // Store the parent pointer.
    pModule->m_pParent = pParent;

    // Store our module's depth for later recursion overflow checks.
    pModule->m_dwDepth = pParent ? (pParent->m_dwDepth + 1) : 0;

    // Recurse our module tree to see if this module is a duplicate of another.
    if (!pModuleOriginal)
    {
        pModuleOriginal = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_PATH, (DWORD_PTR)szPath);
    }

    // Check to see if a duplicate was found.
    if (pModuleOriginal)
    {
        // If the module is a duplicate, then just point our data field to the
        // original module's data field and flag this module as a duplicate.
        pModule->m_pData = pModuleOriginal->m_pData;
        pModule->m_dwFlags |= DWMF_DUPLICATE;
    }
    else
    {
        // If this module is not a duplicate, then create a new CModuleData object.
        if (!(pModule->m_pData = new CModuleData()))
        {
            RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
        }
        m_dwModules++;

        // Point the module data to this module as the original module.
        pModule->m_pData->m_pModuleOriginal = pModule;

        // Set the actual base address to our special "unknown" value.
        pModule->m_pData->m_dwlActualBaseAddress = (DWORDLONG)-1;

        // Store the path, and set the file pointer
        pModule->m_pData->m_pszPath = StrAlloc(szPath);
        pModule->m_pData->m_pszFile = pModule->m_pData->m_pszPath + (pszFile - szPath);

        // For readability, make path lowercase and file uppercase.
        _strlwr(pModule->m_pData->m_pszPath);
        _strupr(pModule->m_pData->m_pszFile);
    }

    // Return our new module object.
    return pModule;
}

//******************************************************************************
void CSession::DeleteModule(CModule *pModule, bool fSiblings)
{
    if (!pModule)
    {
        return;
    }

    // Recurse into DeleteModule() for all our dependents and siblings.
    DeleteModule(pModule->m_pDependents, true);
    if (fSiblings)
    {
        DeleteModule(pModule->m_pNext, true);
    }

    // Delete all of our current module's parent import functions.
    DeleteParentImportList(pModule);

    // If we are an original module, then free our CModuleData.
    if (pModule->IsOriginal())
    {
        // Delete all of our current module's export functions.
        DeleteExportList(pModule->m_pData);

        // Delete our current module's CModuleData object.
        delete pModule->m_pData;
        m_dwModules--;
    }

    // Delete our current module object itself.
    delete pModule;
}

//******************************************************************************
void CSession::DeleteParentImportList(CModule *pModule)
{
    // Delete all of this module's parent import functions.
    while (pModule->m_pParentImports)
    {
        CFunction *pFunctionNext = pModule->m_pParentImports->m_pNext;
        MemFree((LPVOID&)pModule->m_pParentImports);
        pModule->m_pParentImports = pFunctionNext;
    }
}

//******************************************************************************
void CSession::DeleteExportList(CModuleData *pModuleData)
{
    // Delete all of our current module's export functions.
    while (pModuleData->m_pExports)
    {
        // Delete our forward string if we allocated one.
        MemFree((LPVOID&)pModuleData->m_pExports->m_pszForward);

        // Delete the export node itself.
        CFunction *pFunctionNext = pModuleData->m_pExports->m_pNext;
        MemFree((LPVOID&)pModuleData->m_pExports);
        pModuleData->m_pExports = pFunctionNext;
    }
}

//******************************************************************************
void CSession::ResolveDynamicFunction(CModule *&pModule, CFunction *&pImport)
{
    CModule   *pModuleStart = pModule;
    CFunction *pImportStart = pImport;

    // If this module is 64-bit, then the import is 64-bit.
    if (pModule->GetFlags() & DWMF_64BIT)
    {
        pImport->m_dwFlags |= DWFF_64BIT;
    }

    // Loop through all our exports, looking for a match with our current import.
    bool fExportsChanged = false;
    for (CFunction *pExport = pModule->m_pData->m_pExports; pExport; pExport = pExport->m_pNext)
    {
        // If we have a name, then check for the match by name.
        if (*pImport->GetName())
        {
            if (!strcmp(pImport->GetName(), pExport->GetName()))
            {
                // We found a match. Link this parent import to its associated
                // export, flag the export as being called at least once, break
                // out of loop, and move on to handling our next parent import.
                pImport->m_pAssociatedExport = pExport;
                pImport->m_dwFlags |= DWFF_RESOLVED;
                if (!(pExport->m_dwFlags & DWFF_CALLED_ALO))
                {
                    pExport->m_dwFlags |= DWFF_CALLED_ALO;
                    fExportsChanged = true;
                }
                break;
            }
        }

        // If we don't have a name, then check for the match by ordinal.
        else if (pImport->m_wOrdinal == pExport->m_wOrdinal)
        {
            // We found a match. Link this parent import to its associated
            // export, flag the export as being called at least once, break
            // out of loop, and move on to handling our next parent import.
            pImport->m_pAssociatedExport = pExport;
            pImport->m_dwFlags |= DWFF_RESOLVED;
            if (!(pExport->m_dwFlags & DWFF_CALLED_ALO))
            {
                pExport->m_dwFlags |= DWFF_CALLED_ALO;
                fExportsChanged = true;
            }
            break;
        }
    }

    // If we modified an export, then let the UI know about it.
    if (m_pfnProfileUpdate && fExportsChanged)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_EXPORTS_CHANGED, (DWORD_PTR)pModule, 0);
    }

    // Check for circular forward dependencies.
    if (pModule->m_dwDepth >= 255)
    {
        // Flag this as a circular dependency.
        m_dwReturnFlags |= DWRF_CIRCULAR_DEPENDENCY;

        // We flag this module as having a an error so it will show up in red.
        pModule->m_dwFlags |= DWMF_MODULE_ERROR;

        // Tell our UI to update this module.
        if (m_pfnProfileUpdate)
        {
            // We know we need to update the tree item.
            pModule->m_dwUpdateFlags |= DWUF_TREE_IMAGE;

            // If this module's core has never seen an error before, then update
            // the list icon as well.
            if (!(pModule->m_pData->m_dwFlags & DWMF_MODULE_ERROR_ALO))
            {
                pModule->m_pData->m_dwFlags |= DWMF_MODULE_ERROR_ALO;
                pModule->m_dwUpdateFlags    |= DWUF_LIST_IMAGE;
            }

            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pModule, 0);
            pModule->m_dwUpdateFlags = 0;
        }
    }

    // Check to see if an export match was found.
    else if (pImport->GetAssociatedExport())
    {
        CHAR   szFile[1024];
        LPCSTR pszFunction;
        int    fileLen;
        LPCSTR pszDot, pszFile;

        // If an export was found, check to see if it is a forwarded function.
        // If it is forwarded, then we need to make sure we consider the
        // forwarded module as a new dependent of the current module.
        LPCSTR pszForward = pImport->GetAssociatedExport()->GetExportForwardName();
        if (pszForward)
        {
            // The forward text is formatted as Module.Function. Look for the dot.
            pszDot = strchr(pszForward, '.');
            if (pszDot)
            {
                // Compute the file name length.
                fileLen = min((int)(pszDot - pszForward), (int)sizeof(szFile) - 5);

                // Copy the file portion of the forward string to our file buffer.
                // We add 1 because we want the entire name plus a null char copied over.
                StrCCpy(szFile, pszForward, fileLen + 1);

                // Store a pointer to the function name portion of the forward string.
                pszFunction = pszDot + 1;
            }

            // If no dot was found in the forward string, then something is wrong.
            else
            {
                fileLen = (int)strlen(StrCCpy(szFile, "Invalid", sizeof(szFile)));
                pszFunction = pszForward;
            }

            // First, we search our module dependency list to see if we have
            // already created a forward CModoule for this file.
            CModule *pModuleForward = FindModule(pModule->m_pDependents,
                FMF_FORWARD_ONLY | FMF_FILE_NO_EXT | FMF_SIBLINGS, (DWORD_PTR)szFile);

            // Second, we search our pending module list that we know loaded
            // as a result of this dynamic function being added.
            if (!pModuleForward)
            {
                for (CEventLoadDll *pDll = m_pEventLoadDllPending; pDll; pDll = pDll->m_pNextDllInFunctionCall)
                {
                    // Check to see if this module has a path (it always should).
                    if (pDll->m_pModule->GetName(false) != pDll->m_pModule->GetName(true))
                    {
                        // Attempt to locate the dot in the file name.
                        pszDot = strrchr(pszFile = pDll->m_pModule->GetName(false), '.');

                        // If there is a dot and the name portions are equal in length,
                        // then compare just the name portions. If there is no dot,
                        // then just compare the names.  If the compare finds a match,
                        // then this is the module we are looking for.
                        if ((pszDot && ((pszDot - pszFile) == fileLen) && !_strnicmp(pszFile, szFile, fileLen)) ||
                            (!pszDot && !_stricmp(pszFile, szFile)))
                        {
                            // Create the module using the complete path.
                            pModuleForward = AddDynamicModule(
                                pDll->m_pModule->GetName(true), (DWORD_PTR)pDll->m_pModule->m_dwpImageBase,
                                false, false, false, true, pModule);
                            break;
                        }
                    }
                }
            }

            // Third, if we have not created a forward module for this file yet, then
            // create it now and add it to the end of our list.
            if (!pModuleForward)
            {
                CHAR szPath[DW_MAX_PATH], *pszTemp;

                // Check to see if we already have a module with this same base name.
                if (pModuleForward = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_FILE_NO_EXT, (DWORD_PTR)szFile))
                {
                    // If so, then just store it's path away.
                    StrCCpy(szPath, pModuleForward->GetName(true), sizeof(szPath));
                }

                // Otherwise, we need to search for the module.
                else
                {
                    // First, we check for a DLL file.
                    StrCCpy(szFile + fileLen, ".DLL", sizeof(szFile) - fileLen);
                    if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                    {
                        // If that fails, then check for and EXE file.
                        StrCCpy(szFile + fileLen, ".EXE", sizeof(szFile) - fileLen);
                        if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                        {
                            // If that fails, then check for a SYS file.
                            StrCCpy(szFile + fileLen, ".SYS", sizeof(szFile) - fileLen);
                            if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                            {
                                // If that fails, then we just use the file name without an extension.
                                szFile[fileLen] = '\0';
                                StrCCpy(szPath, szFile, sizeof(szPath));
                            }
                        }
                    }
                }

                // Create the module using the complete path.
                pModuleForward = AddDynamicModule(szPath, NULL, false, false, false, true, pModule);
            }

            pModule = pModuleForward;

            // Create a new CFunction object for this import function.
            pImport = CreateFunction(0, 0, 0, pszFunction, 0);

            // Insert this function object into our forward module's import list.
            pImport->m_pNext = pModule->m_pParentImports;
            pModule->m_pParentImports = pImport;

            // Recurse into ourself and resolve this new import.
            ResolveDynamicFunction(pModule, pImport);
        }
    }

    // Let our UI know about this new import in case it needs to add it.
    if (m_pfnProfileUpdate)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_ADD_IMPORT, (DWORD_PTR)pModuleStart, (DWORD_PTR)pImportStart);
    }
}

//******************************************************************************
CFunction* CSession::CreateFunction(DWORD dwFlags, WORD wOrdinal, WORD wHint, LPCSTR pszName,
                                    DWORDLONG dwlAddress, LPCSTR pszForward, BOOL fAlreadyAllocated)
{
    // All forward strings must have a period in them.
    ASSERT(!pszForward || strchr(pszForward, '.'));

    DWORD dwSize = sizeof(CFunction);

    // If we have a forward string, then set the forward flag.
    if (pszForward)
    {
        dwFlags |= DWFF_FORWARDED;
    }
    
    // If the address uses 64-bits, then set the 64-bit flag and bump up our size.
    if (dwlAddress & 0xFFFFFFFF00000000ui64)
    {
        dwFlags |= DWFF_64BITS_USED;
        dwSize  += sizeof(DWORDLONG);
    }

    // Otherwsie, if the address uses 32-bits, then set the 32-bit flag and bump up our size.
    // This address may still be 64-bits, but we don't need to store the upper 32-bits since
    // we know they are 0's.
    else if (dwlAddress & 0x00000000FFFFFFFFui64)
    {
        dwFlags |= DWFF_32BITS_USED;
        dwSize  += sizeof(DWORD);
    }

    // If we have a name, then set the name flag and add its length to our size.
    if (pszName)
    {
        dwFlags |= DWFF_NAME;
        dwSize  += ((DWORD)strlen(pszName) + 1);
    }

    // Create a CFunction object with the size we have calulated.
    CFunction *pFunction = (CFunction*)MemAlloc(dwSize);

    // Clear the function object and fill in its members.
    ZeroMemory(pFunction, dwSize); // inspected
    pFunction->m_dwFlags  = dwFlags;
    pFunction->m_wOrdinal = wOrdinal;
    pFunction->m_wHint    = wHint;

    // If we have a forward string, then store it now.
    if (pszForward)
    {
        pFunction->m_pszForward = fAlreadyAllocated ? (LPSTR)pszForward : StrAlloc(pszForward);
    }

    // If we have 64-bits worth of address, then store all 64-bits of it, and then
    // store the name right after it.
    if (dwFlags & DWFF_64BITS_USED)
    {
        *(DWORDLONG*)(pFunction + 1) = dwlAddress; 
        if (pszName)
        {
            strcpy((LPSTR)((DWORD_PTR)(pFunction + 1) + sizeof(DWORDLONG)), pszName); // inspected
        }
    }

    // Otherwise, if we have 32-bits worth of address, then store all 32-bits of it,
    // and then store the name right after it.
    else if (dwFlags & DWFF_32BITS_USED)
    {
        *(DWORD*)(pFunction + 1) = (DWORD)dwlAddress; 
        if (pszName)
        {
            strcpy((LPSTR)((DWORD_PTR)(pFunction + 1) + sizeof(DWORD)), pszName); // inspected
        }
    }

    // Otherwise, skip the address and just store the name right after our object.
    else if (pszName)
    {
        strcpy((LPSTR)(pFunction + 1), pszName); // inspected
    }

    // Return our new function object.
    return pFunction;
}

//******************************************************************************
BOOL CSession::MapFile(CModule *pModule, HANDLE hFile /*=NULL*/)
{
    // If we were not passed in a file handle, then get one by opening the file.
    if (!hFile || (hFile == INVALID_HANDLE_VALUE))
    {
        // If so, open the file for read.
        hFile = CreateFile(pModule->GetName(true), GENERIC_READ, // inspected - opens with full path
                           FILE_SHARE_READ, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);

        // Check for success.
        if (hFile != INVALID_HANDLE_VALUE)
        {
            // Make sure this file is not a device, like "AUX".  Prior to Win2K SP1
            // WINMM.DLL always dynamically loads "AUX".
            if ((GetFileType(hFile) & 0x7FFF) == FILE_TYPE_CHAR)
            {
                SetModuleError(pModule, 0, "This is a reserved device name and not a valid file name.");
                CloseHandle(hFile);
                m_dwReturnFlags |= DWRF_FORMAT_NOT_PE;
                pModule->m_pData->m_dwFlags |= DWMF_FORMAT_NOT_PE;
                return FALSE;
            }

            // This is a workaround to a case where CreateFile attempts to locate
            // a file on its own when it does not contain a path.  We don't want
            // this behavior.  We want to be very strict about only loading modules
            // that live along the search path specified by the user.  The bug I was
            // seeing is that I could remove all search paths from the search path
            // dialog, but CreateFile would still open "C:\MSVCRT.DLL" when passed
            // just "MSVCRT.DLL" when depends.exe's current directoy was "C:\"
            // We could do this check before even opening the file, but then we
            // don't have a chance to catch the "AUX" bug.  Since "AUX" has no path
            // we would just mark it as file not found, which is not what we want.
            if (pModule->m_pData->m_pszFile == pModule->m_pData->m_pszPath)
            {
                // Simulate a file not found failure.
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                SetLastError(ERROR_FILE_NOT_FOUND);
            }
        }

        // Exit now if the file failed to open.
        if (hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwGLE = GetLastError();

            // Check for a file not found type error.
            if ((dwGLE == ERROR_FILE_NOT_FOUND) || (dwGLE == ERROR_PATH_NOT_FOUND))
            {
                // Mark this module as not found.
                pModule->m_pData->m_dwFlags |= DWMF_FILE_NOT_FOUND;

                // Set the appropriate return flag.
                if (!m_pModuleRoot || (m_pModuleRoot == pModule))
                {
                    m_dwReturnFlags |= DWRF_FILE_NOT_FOUND;
                }
                else
                {
                    // Walk up the parent list looking for a module that lets
                    // us know what type of dependency this is.  we mostly need
                    // to do this for forwared modules since their parent dragged
                    // them in.
                    for (CModule *pModuleCur = pModule; pModuleCur; pModuleCur = pModuleCur->m_pParent)
                    {
                        // If we found a delay-load module, then add this to our flags and bail.
                        if (pModuleCur->m_dwFlags & DWMF_DELAYLOAD)
                        {
                            m_dwReturnFlags |= DWRF_DELAYLOAD_NOT_FOUND;
                            break;
                        }
                        if (pModuleCur->m_dwFlags & DWMF_DYNAMIC)
                        {
                            m_dwReturnFlags |= DWRF_DYNAMIC_NOT_FOUND;
                            break;
                        }
                    }
                    if (!pModuleCur)
                    {
                        m_dwReturnFlags |= DWRF_IMPLICIT_NOT_FOUND;
                    }
                }
            }
            else
            {
                // If some unknown error occurred, then make note that we failed to open the file.
                m_dwReturnFlags |= DWRF_FILE_OPEN_ERROR;
            }
            SetModuleError(pModule, dwGLE, "Error opening file.");
            return FALSE;
        }

        // Make a note to ourself, telling us that we need to close this file
        // handle since we opened it.
        m_fCloseFileHandle = true;
    }

    // Store this file handle.
    m_hFile = hFile;

    // Make sure the file size is not 0.  This causes CreateFileMapping() with
    // some ugly error message (1006).
    m_dwSize = GetFileSize(m_hFile, NULL);
    if ((m_dwSize == 0) || (m_dwSize == 0xFFFFFFFF))
    {
        SetModuleError(pModule, 0, "This file is not a valid 32-bit or 64-bit Windows module.");
        UnMapFile();
        m_dwReturnFlags |= DWRF_FORMAT_NOT_PE;
        pModule->m_pData->m_dwFlags |= DWMF_FORMAT_NOT_PE;
        return FALSE;
    }

    // Create a file mapping object for the open module.
    m_hMap = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL); // inspected

    // Exit now if the file failed to map.
    if (m_hMap == NULL)
    {
        SetModuleError(pModule, GetLastError(), "Error reading file.");
        UnMapFile();
        m_dwReturnFlags |= DWRF_FILE_OPEN_ERROR;
        return FALSE;
    }

    // Create a file mapping view for the open module.
    m_lpvFile = MapViewOfFile(m_hMap, FILE_MAP_READ, 0, 0, 0); // inspected

    // Exit now if the mapped view failed to create.
    if (m_lpvFile == NULL)
    {
        SetModuleError(pModule, GetLastError(), "Error reading file.");
        UnMapFile();
        m_dwReturnFlags |= DWRF_FILE_OPEN_ERROR;
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
void CSession::UnMapFile()
{
    // Unmap our map view pointer.
    if (m_lpvFile)
    {
        UnmapViewOfFile(m_lpvFile);
        m_lpvFile = NULL;
    }

    // Close our map handle.
    if (m_hMap)
    {
        CloseHandle(m_hMap);
        m_hMap = NULL;
    }

    // Close our file handle.
    if (m_fCloseFileHandle && m_hFile && (m_hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(m_hFile);
    }
    m_fCloseFileHandle = false;
    m_hFile = NULL;
    m_dwSize = 0;

    // Clear our 64bit flag.
    m_f64Bit = false;

    // Clear our PE structure pointers.
    m_pIFH = NULL;
    m_pIOH = NULL;
    m_pISH = NULL;
}

//******************************************************************************
BOOL CSession::ProcessModule(CModule *pModule)
{
    BOOL fResult = FALSE;

    // First check to see if this module is a duplicate. If it is, make sure the
    // original instance of this module has been processed and then just perform
    // the Parent Import Verify. If the module being passed in is an original,
    // then just ensure that we haven't already processed this module.

    if (!pModule->IsOriginal())
    {
        // Process the original module and its subtree.
        fResult = ProcessModule(pModule->m_pData->m_pModuleOriginal);
    }

    // Exit now if we have already processed this original module in the past.
    else if (pModule->m_pData->m_fProcessed)
    {
        return TRUE;
    }
    else
    {
        // Mark this module as processed.
        pModule->m_pData->m_fProcessed = true;

        // Map the file into memory.
        if (!MapFile(pModule))
        {
            return FALSE;
        }

        __try
        {
            // Everything from here on is pretty much relying on the file being a
            // valid binary with valid pointers and offsets. It is fairly safe to
            // just wrap everything in exception handling and then blindly access
            // the file. Anything that causes us to move outside our file mapping
            // will generate an exception and bring us back here to fail the file.

            m_pszExceptionError = NULL;

            fResult = (VerifyModule(pModule)      &&
                       GetFileInfo(pModule)       &&
                       GetModuleInfo(pModule)     &&
                       GetVersionInfo(pModule)    &&
                       BuildImports(pModule)      &&
                       BuildDelayImports(pModule) &&
                       BuildExports(pModule)      &&
                       CheckForSymbols(pModule));
        }
        __except (ExceptionFilter(_exception_code(), true))
        {
            // If we encountered an exception, check to see if we were in a known area.
            // If so, display the appropriate error.
            if (m_pszExceptionError)
            {
                SetModuleError(pModule, 0, m_pszExceptionError);
                m_pszExceptionError = NULL;
            }

            // Otherwise, display a generic error.
            else
            {
                SetModuleError(pModule, 0, "Error processing file. This file may not be a valid 32-bit or 64-bit Windows module.");
            }
            m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        }

        // Free the module from memory.
        UnMapFile();
    }

    // Compare our parent imports with our exports to make sure they all match up.
    VerifyParentImports(pModule);

    // Safeguard to ensure that we don't get stuck in some recursive loop.  This
    // can occur if there is a circular dependency with forwarded functions. This
    // is extremely rare and would require a bonehead to design it, but we need
    // to handle this case to prevent us from crashing on it.  When NT encounters
    // a module like this, it fails the load with exception 0xC00000FD which is
    // defined as STATUS_STACK_OVERFLOW in WINNT.H.  We use 255 as our max depth
    // because the several versions of the tree control crash if more than 256
    // depths are displayed.

    if (pModule->m_dwDepth >= 255)
    {
        // If this module has dependents, then delete them.
        if (pModule->m_pDependents)
        {
            DeleteModule(pModule->m_pDependents, true);
            pModule->m_pDependents = NULL;
        }

        // Flag this document as having a circular dependency error.
        m_dwReturnFlags |= DWRF_CIRCULAR_DEPENDENCY;

        // We flag this module as having a an error so it will show up in red.
        pModule->m_dwFlags          |= DWMF_MODULE_ERROR;
        pModule->m_pData->m_dwFlags |= DWMF_MODULE_ERROR_ALO;

        return FALSE;
    }

    // If it is a data file, then we don't recurse.
    if (!(pModule->m_dwFlags & DWMF_NO_RESOLVE))
    {
        // Recurse into ProcessModule() to handle all our dependent modules.
        for (CModule *pModDep = pModule->m_pDependents; pModDep; pModDep = pModDep->m_pNext)
        {
            ProcessModule(pModDep);
        }
    }

    return fResult;
}

//******************************************************************************
void CSession::PrepareModulesForRuntimeProfile(CModule *pModuleCur)
{
    if (!pModuleCur)
    {
        return;
    }

    // Clear loaded bit, actual base address, and load order.
    pModuleCur->m_pData->m_dwFlags &= ~DWMF_LOADED;
    pModuleCur->m_pData->m_dwlActualBaseAddress = (DWORDLONG)-1;
    pModuleCur->m_pData->m_dwLoadOrder = 0;

    // Recurse into PrepareModulesForRuntimeProfile() for each dependent module
    // and sibling module.
    PrepareModulesForRuntimeProfile(pModuleCur->m_pDependents);
    PrepareModulesForRuntimeProfile(pModuleCur->m_pNext);
}

//******************************************************************************
void CSession::MarkModuleAsLoaded(CModule *pModule, DWORDLONG dwlBaseAddress, bool fDataFile)
{
    // Store the actual base address.  For data files, we only store the base
    // address if the module core is a data file - we don't ever want to step on
    // a real base address with a data file address.
    if ((!fDataFile || (pModule->m_pData->m_dwFlags & DWMF_DATA_FILE_CORE)) &&
        (pModule->m_pData->m_dwlActualBaseAddress != dwlBaseAddress))
    {
        pModule->m_pData->m_dwlActualBaseAddress = dwlBaseAddress;
        pModule->m_dwUpdateFlags |= DWUF_ACTUAL_BASE;
    }

    // Set the loaded flag on this module.
    pModule->m_pData->m_dwFlags |= DWMF_LOADED;

    // Store this modules load order if it is the first time it has been loaded.
    if (!pModule->m_pData->m_dwLoadOrder)
    {
        pModule->m_pData->m_dwLoadOrder = ++m_dwLoadOrder;
        pModule->m_dwUpdateFlags |= DWUF_LOAD_ORDER;

        // We need to call BuildAloFlags after setting pModule->m_pData->m_dwLoadOrder.
        BuildAloFlags();

        // If this module is never implicit, then we need to update its image since
        // we probably just swithced a delay-load to a dynamic.
        if (!(pModule->m_pData->m_dwFlags & DWMF_IMPLICIT_ALO))
        {
            pModule->m_dwUpdateFlags |= DWUF_LIST_IMAGE;
        }
    }
}

//******************************************************************************
CModule* CSession::FindModule(CModule *pModule, DWORD dwFlags, DWORD_PTR dwpData)
{
    if (!pModule || ((dwFlags & FMF_EXCLUDE_TREE) && (pModule == (CModule*)dwpData)))
    {
        return NULL;
    }

    // Make sure the loaded flag is not specified or that the module is loaded.
    if ((!(dwFlags & FMF_LOADED)        || (pModule->m_pData->m_dwFlags & DWMF_LOADED)) &&
        (!(dwFlags & FMF_NEVER_LOADED)  || (pModule->m_pData->m_dwLoadOrder == 0)) &&
        (!(dwFlags & FMF_EXPLICIT_ONLY) || (pModule->m_dwFlags & DWMF_DYNAMIC)) &&
        (!(dwFlags & FMF_FORWARD_ONLY)  || (pModule->m_dwFlags & DWMF_FORWARDED)) &&
        (!(dwFlags & FMF_DUPLICATE)     || !pModule->IsOriginal()))
    {
        // Check to see if we are searching by full path.
        if (dwFlags & FMF_PATH)
        {
            // Check to see if our current module matches by path.
            if (!_stricmp(pModule->m_pData->m_pszPath, (LPCSTR)dwpData))
            {
                return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                       pModule->m_pData->m_pModuleOriginal : pModule);
            }
        }

        // Check to see if we are searching by file name.
        else if (dwFlags & FMF_FILE)
        {
            // Check to see if our current module matches by file name.
            if (!_stricmp(pModule->m_pData->m_pszFile, (LPCSTR)dwpData))
            {
                return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                       pModule->m_pData->m_pModuleOriginal : pModule);
            }
        }

        // Check to see if we are searching by file name, but ignoring extension.
        else if (dwFlags & FMF_FILE_NO_EXT)
        {
            CHAR *pszDot = strrchr(pModule->m_pData->m_pszFile, '.');
            if (pszDot)
            {
                if (((int)strlen((LPCSTR)dwpData) == (pszDot - pModule->m_pData->m_pszFile)) &&
                    !_strnicmp((LPCSTR)dwpData, pModule->m_pData->m_pszFile, pszDot - pModule->m_pData->m_pszFile))
                {
                    return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                           pModule->m_pData->m_pModuleOriginal : pModule);
                }
            }
            else if (!_stricmp(pModule->m_pData->m_pszFile, (LPCSTR)dwpData))
            {
                return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                       pModule->m_pData->m_pModuleOriginal : pModule);
            }
        }

        // Check to see if we are searching by the address of the module data.
        else if (dwFlags & FMF_MODULE)
        {
            // Check to see if our current module matches by module data pointer.
            if (pModule->m_pData == ((CModule*)dwpData)->m_pData)
            {
                return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                       pModule->m_pData->m_pModuleOriginal : pModule);
            }
        }

        // Otherwise, we are checking by address.
        else
        {
            // Check to see if the address lies within our current module.
            if ((pModule->m_pData->m_dwlActualBaseAddress != (DWORDLONG)-1) &&
                (pModule->m_pData->m_dwlActualBaseAddress <= (DWORDLONG)dwpData) &&
                (pModule->m_pData->m_dwlActualBaseAddress +
                 (DWORDLONG)pModule->m_pData->m_dwVirtualSize > (DWORDLONG)dwpData))
            {
                return (((dwFlags & FMF_ORIGINAL) && pModule->m_pData->m_pModuleOriginal) ?
                       pModule->m_pData->m_pModuleOriginal : pModule);
            }
        }
    }

    CModule *pFound = NULL;
    if (dwFlags & FMF_RECURSE)
    {
        // Recurse into the dependent modules. We set the FMF_SIBLINGS flag since
        // we want the recursion in from us to walk the siblings since they are all
        // dependents of our current module.
        pFound = FindModule(pModule->m_pDependents, dwFlags | FMF_SIBLINGS, dwpData);
    }

    // If we did not find a module and the FMF_SIBLINGS flag is set, then recurse
    // on our next sibling.
    if (!pFound && (dwFlags & FMF_SIBLINGS))
    {
        pFound = FindModule(pModule->m_pNext, dwFlags, dwpData);
    }

    return pFound;
}

//******************************************************************************
void CSession::SetModuleError(CModule *pModule, DWORD dwError, LPCTSTR pszMessage)
{
    // Make sure this module doesn't already have an error.
    if (pModule->m_pData->m_pszError)
    {
        TRACE("WARNING: SetModuleError() called when an error string already exists.");
        return;
    }

    // Allocate a string buffer in our module and copy the error text to it.
    pModule->m_pData->m_pszError = BuildErrorMessage(dwError, pszMessage);

    // Flag this module as having an error message.
    pModule->m_pData->m_dwFlags |= DWMF_ERROR_MESSAGE;
}

//******************************************************************************
BOOL CSession::SearchPathForFile(LPCSTR pszFile, LPSTR pszPath, int cPath, LPSTR *ppszFilePart)
{
    // When we dynamically load modules, m_pEventLoadDllPending will point to
    // a list of pending modules that loaded as dependents of the main module
    // being loaded.  There is a good chance one of the modules in the list is
    // the module we are looking for.  So, we first check the list, then we
    // default to our seach path.
    for (CEventLoadDll *pDll = m_pEventLoadDllPending; pDll; pDll = pDll->m_pNextDllInFunctionCall)
    {
        // Check to see if this module has a path and the filename matches.
        if ((pDll->m_pModule->GetName(false) != pDll->m_pModule->GetName(true)) &&
            !_stricmp(pszFile, pDll->m_pModule->GetName(false)))
        {
            // Copy the fully qualified path to the return buffer.
            StrCCpy(pszPath, pDll->m_pModule->GetName(true), cPath);
            *ppszFilePart = (LPSTR)GetFileNameFromPath(pszPath);
            return TRUE;
        }
    }

    // Walk through each search group.
    for (CSearchGroup *psg = m_psgHead; psg; psg = psg->GetNext())
    {
        // Walk through each directory/file in this search group.
        for (CSearchNode *psn = psg->GetFirstNode(); psn; psn = psn->GetNext())
        {
            DWORD dwFlags = psn->GetFlags();

            if (dwFlags & SNF_NAMED_FILE)
            {
                // Locate the file extension and then compute the length of just the name.
                LPCSTR pszDot = strrchr(pszFile, '.');
                int length = pszDot ? (int)(pszDot - pszFile) : (int)strlen(pszFile);

                // Check to see if this matches the name of the current search node.
                if (((int)strlen(psn->GetName()) == length) && !_strnicmp(psn->GetName(), pszFile, length))
                {
                    // Copy the fully qualified path to the return buffer.
                    StrCCpy(pszPath, psn->GetPath(), cPath);
                    *ppszFilePart = (LPSTR)GetFileNameFromPath(pszPath);
                    return TRUE;
                }
            }
            else if (dwFlags & SNF_FILE)
            {
                // Check to see if this matches the name of the current search node.
                if (!_stricmp(psn->GetName(), pszFile))
                {
                    // Copy the fully qualified path to the return buffer.
                    StrCCpy(pszPath, psn->GetPath(), cPath);
                    *ppszFilePart = (LPSTR)GetFileNameFromPath(pszPath);
                    return TRUE;
                }
            }
            else
            {
                // Build a fully qualified path to the file using the current search directory.
                StrCCpy(pszPath, psn->GetPath(), cPath);
                *ppszFilePart = pszPath + strlen(pszPath);
                StrCCpy(*ppszFilePart, pszFile, cPath - (int)(*ppszFilePart - pszPath));

                // Check to see if this file exists.
                WIN32_FIND_DATA w32fd;
                ZeroMemory(&w32fd, sizeof(w32fd)); // inspected
                HANDLE hFind = FindFirstFile(pszPath, &w32fd);
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    // First, close the find handle.
                    FindClose(hFind);

                    // We know something with this path exists. If it is not a
                    // directory and is a valid file, then we return true.
                    // Non-valid files include AUX, LPTx, CON, etc. Most of them
                    // are found by FindFirstFile, even though they are not real
                    // files. It appears that all non-valid files have a last
                    // write time of 0, so we can do a quick test to see if we
                    // even need to call IsValidFile.
                    if (!(w32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        ((w32fd.ftLastWriteTime.dwLowDateTime  != 0) ||
                         (w32fd.ftLastWriteTime.dwHighDateTime != 0) ||
                         IsValidFile(pszPath)))
                    {
                        return TRUE;
                    }
                }
            }
        }

        // All this Side-by-Side code below is basically a hack until the OS
        // provides some functions for querying the SxS data (the fusion team
        // is working on this).  So, in the meantime, we abuse SearchPath() to
        // query if this module is a SxS component.  First off, Windows XP has
        // a default SxS context that exists even before we activate a context.
        // This is how GDIPLUS.DLL gets resolved.  I'm not sure this default
        // context will exist when Windows XP officially ships, but it exists
        // in Beta 1, and post beta 1 builds (I'm on 2432 right now).  
        //
        // SearchPath(NULL, ...) will query the default context as well as any
        // contexts that are stacked on top of it before scanning the standard
        // search path.  The problem is that we only want to use module paths
        // that are found as a result of them being part of the SxS data, and
        // not part of the ordinary search path.  To do this, we do two hacks.
        // First, we call just call SearchPath and check the result to see if
        // it starts with "%SystemRoot%\WinSxS\".  If it does, then it was most
        // likely found as a result of being in the SxS data.  This is how we
        // pick up modules from the default context, like GDIPLUS.DLL.  Next,
        // if we have an context handle for this application, then we activate
        // it, call SearchPath() again, and then deactivate it.  If the result
        // from this second call to SearchPath differs from the result of the
        // first call to SearchPath, then we assume the change occured because
        // of the context we activated, and therefore the path of the second
        // call is probably an SxS path.

        if (psg->GetType() == SG_SIDE_BY_SIDE)
        {
            bool  fFound = false;
            DWORD dwLength;

            // Call SearchPath without the context activated.  This will use the
            // default context if the OS has loaded one for us.
            CHAR szPathNoActCtx[DW_MAX_PATH];
            if (!(dwLength = SearchPath(NULL, pszFile, NULL, sizeof(szPathNoActCtx), szPathNoActCtx, NULL)) || (dwLength > sizeof(szPathNoActCtx))) // inspected
            {
                *szPathNoActCtx = '\0';
            }

            // Check to see if we have an SxS context handle for this application.
            if ((psg->m_hActCtx != INVALID_HANDLE_VALUE) && g_theApp.m_pfnActivateActCtx)
            {
                // Activate the context.
                ULONG_PTR ulpCookie = 0;
                if (g_theApp.m_pfnActivateActCtx(psg->m_hActCtx, &ulpCookie))
                {
                    // Call SearchPath again, this time with the context activated.
                    if (!(dwLength = SearchPath(NULL, pszFile, NULL, cPath, pszPath, NULL)) || ((int)dwLength > cPath)) // inspected
                    {
                        *pszPath = '\0';
                    }

                    // Deactivate the context.
                    g_theApp.m_pfnDeactivateActCtx(0, ulpCookie);

                    // If we got a path while the context was activated, and it was
                    // different then the path we got when not activated, then
                    // we must have found an SxS specific module.
                    if (*pszPath && strcmp(szPathNoActCtx, pszPath))
                    {
                        fFound = true;
                    }
                }
            }

            // If we did not find an SxS module with the context activated, then
            // check to see if our first call to SearchPath returned a path to
            // our WinSxS directory.
            if (!fFound)
            {
                // Temporarily abusing our szPath buffer...
                if (!(dwLength = GetWindowsDirectory(pszPath, cPath)) || ((int)dwLength > cPath))
                {
                    // GetWindowsDirectory() should never fail, but just in case...
                    StrCCpy(pszPath, "C:\\Windows", cPath);
                }
                StrCCat(AddTrailingWack(pszPath, cPath), "WinSxS\\", cPath);

                // Check to see if this path is goes into our WinSxS directory.
                if (!_strnicmp(szPathNoActCtx, pszPath, strlen(pszPath)))
                {
                    // Move this path into our resulting path buffer and set our found flag.
                    StrCCpy(pszPath, szPathNoActCtx, cPath);
                    fFound = true;
                }
            }

            // Check to see if we found a path one way or another.
            if (fFound)
            {
                // Add this file to this search group so we can find
                // it quicker next time through.  Also, it will show up
                // in the search dialog under the SxS group.
                psg->m_psnHead = psg->CreateFileNode(psg->m_psnHead, SNF_FILE, pszPath);
                *ppszFilePart = (LPSTR)GetFileNameFromPath(pszPath);
                return TRUE;
            }
        }
    }

    *ppszFilePart = StrCCpy(pszPath, pszFile, cPath);
    return FALSE;
}

//******************************************************************************
bool CSession::IsValidFile(LPCSTR pszPath)
{
    // This function should only be called to test a suspicious file (last write
    // time of 0) to see if it is really a device name (CON, PRN, AUX, NUL,
    // COM1 - COM9, LPT1 - LPT9).  On my Win2K machine, only AUX, COM1, COM2,
    // and NUL return FILE_TYPE_CHAR.  The rest fail the call to CreateFile with
    // either access denied (CON), or file not found.

    bool fResult = false;
    HANDLE hFile = CreateFile(pszPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); // inspected
    if (INVALID_HANDLE_VALUE != hFile)
    {
        fResult = ((GetFileType(hFile) & 0x7FFF) != FILE_TYPE_CHAR);
        CloseHandle(hFile);
    }
    return fResult;
}

//******************************************************************************
DWORD_PTR CSession::RVAToAbsolute(DWORD dwRVA)
{
    // In Dependency Walker 1.0, we used to look up a directory (for example,
    // IMAGE_DIRECTORY_ENTRY_IMPORT), locate its section, and then create a base
    // address that we added to all RVAs for that directory.  I have since found
    // that occasionally an RVA in one section will point to another section.
    // When this happened, we would be adding in the incorrect base offset and the
    // result would be a bogus pointer.  So, we don't use base pointers anymore.
    // Everytime we encounter an RVA, we search for the section it belongs to
    // and calculate the absolute position.  This is a bit slower, but more
    // robust and accurate.

    // Locate the section that contains this RVA. We do this by walking through
    // all of our sections until we find the one that specifies an address range
    // that our RVA fits in.

    PIMAGE_SECTION_HEADER pISH = m_pISH;

    for (int i = 0; i < m_pIFH->NumberOfSections; i++, pISH++)
    {
        if ((dwRVA >= pISH->VirtualAddress) &&
            (dwRVA < (pISH->VirtualAddress + pISH->SizeOfRawData)))
        {
            return (DWORD_PTR)m_lpvFile + (DWORD_PTR)pISH->PointerToRawData +
                   ((DWORD_PTR)dwRVA - (DWORD_PTR)pISH->VirtualAddress);
        }
    }

    return 0;
}

//******************************************************************************
PVOID CSession::GetImageDirectoryEntry(DWORD dwEntry, DWORD *pdwSize)
{
    // Bail out if this directory does not exist.
    if (dwEntry >= IOH_VALUE(NumberOfRvaAndSizes))
    {
        return NULL;
    }

    // Get the size of this image directory.
    *pdwSize = IOH_VALUE(DataDirectory[dwEntry].Size);
    if (*pdwSize == 0)
    {
        return NULL;
    }

    // Locate the section that contains this image directory.
    return (PVOID)RVAToAbsolute(IOH_VALUE(DataDirectory[dwEntry].VirtualAddress));
}

//******************************************************************************
BOOL CSession::VerifyModule(CModule *pModule)
{
    // Map an IMAGE_DOS_HEADER structure onto our module file mapping.
    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)m_lpvFile;

    // Check for the DOS signature ("MZ").
    if ((m_dwSize < sizeof(IMAGE_DOS_HEADER)) || (pIDH->e_magic != IMAGE_DOS_SIGNATURE))
    {
        SetModuleError(pModule, 0, "No DOS or PE signature found. This file is not a valid 32-bit or 64-bit Windows module.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_PE;
        pModule->m_pData->m_dwFlags |= DWMF_FORMAT_NOT_PE;
        return FALSE;
    }

    // Map an IMAGE_NT_HEADERS structure onto our module file mapping.
    PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((DWORD_PTR)m_lpvFile + (DWORD_PTR)pIDH->e_lfanew);

    // Check to see if this file does not have a NT/PE signature ("PE\0\0").
    if (((DWORD)pIDH->e_lfanew > (m_dwSize - sizeof(IMAGE_NT_HEADERS))) ||
        (pINTH->Signature != IMAGE_NT_SIGNATURE))
    {
        // Make note that this in not a PE file.
        m_dwReturnFlags |= DWRF_FORMAT_NOT_PE;
        pModule->m_pData->m_dwFlags |= DWMF_FORMAT_NOT_PE;

        // Map an IMAGE_OS2_HEADER structure onto our buffer.
        PIMAGE_OS2_HEADER pIOS2H = (PIMAGE_OS2_HEADER)pINTH;

        // Then check for OS/2 signature (which also includes DOS and Win16).
        if (((DWORD)pIDH->e_lfanew <= (m_dwSize - sizeof(IMAGE_OS2_HEADER))) &&
            (pIOS2H->ne_magic == IMAGE_OS2_SIGNATURE))
        {
            // Check for a 16-bit OS/2 binary.
            if (pIOS2H->ne_exetyp == NE_OS2)
            {
                SetModuleError(pModule, 0, "No PE signature found. This file appears to be a 16-bit OS/2 module.");
                return FALSE;
            }

            // Check for a 16-bit Windows binary.
            else if ((pIOS2H->ne_exetyp == NE_DEV386) || (pIOS2H->ne_exetyp == NE_WINDOWS))
            {
                SetModuleError(pModule, 0, "No PE signature found. This file appears to be a 16-bit Windows module.");
                return FALSE;
            }
        }

        SetModuleError(pModule, 0, "No PE signature found. This file appears to be a 16-bit DOS module.");
        return FALSE;
    }

    m_f64Bit = false;

    // Check for a 64-bit module.
    if (pINTH->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        m_dwFlags |= DWSF_64BIT_ALO;
        pModule->m_pData->m_dwFlags |= DWMF_64BIT;
        m_f64Bit = true;
    }
    else if (pINTH->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        SetModuleError(pModule, 0, "This file contains a PE header, but has an unknown format.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        return FALSE;
    }

    // Map our IMAGE_FILE_HEADER structure onto our module file mapping.
    m_pIFH = &pINTH->FileHeader;

    // Map our IMAGE_OPTIONAL_HEADER structure onto our module file mapping.
    m_pIOH = &pINTH->OptionalHeader;

    // Map our IMAGE_SECTION_HEADER structure array onto our module file mapping
    m_pISH = m_f64Bit ? IMAGE_FIRST_SECTION((PIMAGE_NT_HEADERS64)pINTH) :
                        IMAGE_FIRST_SECTION((PIMAGE_NT_HEADERS32)pINTH);

    return TRUE;
}

//******************************************************************************
BOOL CSession::GetFileInfo(CModule *pModule)
{
    // Get file information from our module's file handle.
    BY_HANDLE_FILE_INFORMATION bhfi;
    if (!GetFileInformationByHandle(m_hFile, &bhfi))
    {
        SetModuleError(pModule, GetLastError(), "Unable to query file information.");
        m_dwReturnFlags |= DWRF_FILE_OPEN_ERROR;
        return FALSE;
    }

    // Convert the file time to a local file time and store.
    FileTimeToLocalFileTime(&bhfi.ftLastWriteTime, &pModule->m_pData->m_ftFileTimeStamp);
//  pModule->m_pData->m_ftFileTimeStamp = bhfi.ftLastWriteTime; //!! we should be storing local times - do this in next rev of file format.

    // Store the other information that we care about.  Note that we only store
    // the low part of file size.  File mappings have a max of 1GB, so if we made
    // it this far, we know the file size will fit in a single DWORD.
    pModule->m_pData->m_dwFileSize   = bhfi.nFileSizeLow;
    pModule->m_pData->m_dwAttributes = bhfi.dwFileAttributes;

    return TRUE;
}

//******************************************************************************
BOOL CSession::GetModuleInfo(CModule *pModule)
{
    // Store the machine type.
    pModule->m_pData->m_dwMachineType = m_pIFH->Machine;

    // Check for a mismatched machine error.
    if (m_dwMachineType == (DWORD)-1)
    {
        m_dwMachineType = pModule->m_pData->m_dwMachineType;
    }
    else if (m_dwMachineType != pModule->m_pData->m_dwMachineType)
    {
        pModule->m_pData->m_dwFlags |= DWMF_WRONG_CPU | DWMF_MODULE_ERROR_ALO;
        m_dwReturnFlags             |= DWRF_MIXED_CPU_TYPES;
    }

    // Get the linker timestamp and convert it to the 64-bit FILETIME format. The
    // TimeDateStamp field is time_t value, which is a 32-bit value for the
    // number of seconds since January 1, 1970.  A FILETIME is a 64-bit value for
    // the number of 100-nanosecond intervals since January 1, 1601.  We do the
    // conversion by multiplying the time_t value by 10000000 to get it to the
    // same granularity as a FILETIME, then we add 116444736000000000 to it,
    // which is the number of 100-nanosecond intervals between January 1, 1601
    // and January 1, 1970.
    DWORDLONG dwl = ((DWORDLONG)m_pIFH->TimeDateStamp * (DWORDLONG)10000000ui64) +
                    (DWORDLONG)116444736000000000ui64;

    // Convert the linker timestamp to a local file time and store it.
    FileTimeToLocalFileTime((FILETIME*)&dwl, &pModule->m_pData->m_ftLinkTimeStamp);
//  pModule->m_pData->m_ftLinkTimeStamp = *(FILETIME*)&dwl; //!! we should be storing local times - do this in next rev of file format.

    // Store the characteristics of the file.
    pModule->m_pData->m_dwCharacteristics = m_pIFH->Characteristics;

    // Get the checksum from the file.
    pModule->m_pData->m_dwLinkCheckSum = IOH_VALUE(CheckSum);

    // Compute the real checksum for the file.  We used to use CheckSumMappedFile
    // from IMAGEHLP.DLL, but it has a bug causing it to incorrectly compute
    // the checksum with odd size files.
    pModule->m_pData->m_dwRealCheckSum = ComputeChecksum(pModule);

    // Store the subsystem type.
    pModule->m_pData->m_dwSubsystemType = IOH_VALUE(Subsystem);

    // Store the preferred base address.
    pModule->m_pData->m_dwlPreferredBaseAddress = (DWORDLONG)IOH_VALUE(ImageBase);

    // Store the image version.
    pModule->m_pData->m_dwImageVersion =
    MAKELONG(IOH_VALUE(MinorImageVersion), IOH_VALUE(MajorImageVersion));

    // Store the linker version.
    pModule->m_pData->m_dwLinkerVersion =
    MAKELONG(IOH_VALUE(MinorLinkerVersion), IOH_VALUE(MajorLinkerVersion));

    // Store the OS version.
    pModule->m_pData->m_dwOSVersion =
    MAKELONG(IOH_VALUE(MinorOperatingSystemVersion), IOH_VALUE(MajorOperatingSystemVersion));

    // Store the subsystem version.
    pModule->m_pData->m_dwSubsystemVersion =
    MAKELONG(IOH_VALUE(MinorSubsystemVersion), IOH_VALUE(MajorSubsystemVersion));

    // Store the virtual size.
    pModule->m_pData->m_dwVirtualSize = IOH_VALUE(SizeOfImage);

    return TRUE;
}

//******************************************************************************
DWORD CSession::ComputeChecksum(CModule *pModule)
{
    // Compute the number of WORDs in the file.  If the file has an odd size,
    // this will round down to the nearest WORD.
    DWORD dwWords = m_dwSize >> 1;

    // Locate the two WORDs in our module's header where the checksum is stored.
    LPWORD pwHeaderChecksum1 = (LPWORD)&IOH_VALUE(CheckSum);
    LPWORD pwHeaderChecksum2 = pwHeaderChecksum1 + 1;

    // Walk the module WORD by WORD, computing the checksum along the way.
    LPWORD pwFile = (LPWORD)m_lpvFile;
    DWORD  dwChecksum = 0;
    while (dwWords--)
    {
        // If we are processing a WORD that is part of our header's checksum,
        // then ignore it since it needs to be masked out of the computed checksum.
        if ((pwFile == pwHeaderChecksum1) || (pwFile == pwHeaderChecksum2))
        {
            pwFile++;
        }

        // Otherwise, add this WORD to our checksum.
        else
        {
            dwChecksum += *pwFile++;
            dwChecksum = (dwChecksum >> 16) + (dwChecksum & 0xFFFF);
        }
    }

    // If the file size is odd, we have one byte left that needs to be checksummed.
    // This is the whole reason we do our checksum instead of calling IMAGEHLP's
    // CheckSumMappedFile() function.  CheckSumMappedFile() has a bug that rounds
    // the file size *up* to the nearest WORD, which includes one byte past the end
    // of the file for odd size files.  On NT, this seems ok since NT zeros out
    // the memory past the end of the file when mapping it to memory.  However,
    // Win9x just leaves garbage in that byte causing CheckSumMappedFile() to
    // basically return random checksums for odd size files (like MSVCRT.DLL and
    // MFC42.DLL). We round *down* to the nearest WORD and then special case the
    // last byte for odd size files.

    if (m_dwSize % 2)
    {
        dwChecksum += *pwFile & 0xFF;
        dwChecksum = (dwChecksum >> 16) + (dwChecksum & 0xFFFF);
    }

    // Fold final carry into a single word result, then add the file size.
    // The final checksum is a combination of the 16-bit checksum plus the file size.
    return (((dwChecksum >> 16) + dwChecksum) & 0xFFFF) + m_dwSize;
}

//******************************************************************************
BOOL CSession::GetVersionInfo(CModule *pModule)
{
    m_pszExceptionError = "Error processing the module's version resource table.";

    // See help on "VS_VERSIONINFO" for more info about this structure.
    typedef struct _VS_VERSIONINFO_X
    {
        WORD  wLength;
        WORD  wValueLength;
        WORD  wType;
        WCHAR szKey[16];   // Always "VS_VERSION_INFO"
        WORD  Padding1[1];
        VS_FIXEDFILEINFO Value;
    } VS_VERSIONINFO_X, *PVS_VERSIONINFO_X;

    // Get the Resource Directory.
    DWORD dwSize = 0;
    PIMAGE_RESOURCE_DIRECTORY pIRD = (PIMAGE_RESOURCE_DIRECTORY)
                                     GetImageDirectoryEntry(IMAGE_DIRECTORY_ENTRY_RESOURCE, &dwSize);

    // If this module has no resources, then just return success.
    if (dwSize == 0)
    {
        m_pszExceptionError = NULL;
        return TRUE;
    }

    // Make sure we were able to locate the resource directory.
    if (!pIRD)
    {
        SetModuleError(pModule, 0, "Could not find the section that owns the Resource Directory.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        m_pszExceptionError = NULL;
        return FALSE;
    }

    // In DW 1.0, we used to call GetFileVersionInfoSize and GetFileVersionInfo
    // to get the version info.  On Win32, these functions fail for Win64
    // modules, so we had to do our own version stuff.  One advantage to doing
    // our own version code is that it is more optimal and frees us from
    // being dependent on VERSION.DLL.

    DWORD_PTR dwpBase = (DWORD_PTR)pIRD;
    DWORD     dwDepth = 0, dw;

    // Wrap in exception handling so we can catch any local exceptions since we
    // don't necessarily want to fail the entire module just because the version
    // info is messed up.
    __try
    {
        do
        {
            // The first resource directory entry immediate follows resource directory structure.
            PIMAGE_RESOURCE_DIRECTORY_ENTRY pIRDE = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pIRD + 1);

            // Walk through all our directory entries - both by name and by Id.
            for (dw = (DWORD)pIRD->NumberOfNamedEntries + (DWORD)pIRD->NumberOfIdEntries; dw > 0; dw--, pIRDE++)
            {
                // Check to see if we are not the root directory, or we are the root
                // and this entry is for a VERSION resource.
                if (dwDepth || (!pIRDE->NameIsString && (pIRDE->Id == (WORD)RT_VERSION)))
                {
                    // If this entry points to another directory, then go walk that directory.
                    if (pIRDE->DataIsDirectory)
                    {
                        pIRD = (PIMAGE_RESOURCE_DIRECTORY)(dwpBase + (DWORD_PTR)pIRDE->OffsetToDirectory);
                        dwDepth++;
                    }

                    // Otherwise, we have found an actual VERSION resource - read it in.
                    else
                    {
                        // Get the data entry for this VERSION resource
                        PIMAGE_RESOURCE_DATA_ENTRY pIRDataE = (PIMAGE_RESOURCE_DATA_ENTRY)(dwpBase + (DWORD_PTR)pIRDE->OffsetToData);

                        // Locate the VS_VERSIONINFO structure
                        PVS_VERSIONINFO_X pVSVI = (PVS_VERSIONINFO_X)RVAToAbsolute(pIRDataE->OffsetToData);

                        // Make sure we actually have a VS_FIXEDFILEINFO structure.
                        if (pVSVI->wValueLength)
                        {
                            ASSERT(wcscmp(pVSVI->szKey, L"VS_VERSION_INFO") == 0);

                            // Store the file version
                            pModule->m_pData->m_dwFileVersionMS = pVSVI->Value.dwFileVersionMS;
                            pModule->m_pData->m_dwFileVersionLS = pVSVI->Value.dwFileVersionLS;

                            // Store the product version
                            pModule->m_pData->m_dwProductVersionMS = pVSVI->Value.dwProductVersionMS;
                            pModule->m_pData->m_dwProductVersionLS = pVSVI->Value.dwProductVersionLS;

                            // Mark this module as having valid version info.
                            pModule->m_pData->m_dwFlags |= DWMF_VERSION_INFO;
                        }

                        m_pszExceptionError = NULL;
                        return TRUE;
                    }

                    // Break out of the for loop.
                    break;
                }
            }

            // Loop until we have walked an entire directory without finding anything useful.
        } while (dw);
    }

    // Pass "out of memory" exceptions up, but eat all other exceptions.
    __except (ExceptionFilter(_exception_code(), true))
    {
    }

    m_pszExceptionError = NULL;
    return TRUE;
}

//******************************************************************************
BOOL CSession::WalkIAT32(PIMAGE_THUNK_DATA32 pITDN32, PIMAGE_THUNK_DATA32 pITDA32, CModule *pModule, DWORD dwRVAOffset)
{
    CFunction *pFunctionLast = NULL, *pFunctionNew;

    // Loop through all the Image Thunk Data structures in the function array.
    while (pITDN32->u1.Ordinal)
    {
        LPCSTR pszFunction = NULL;
        WORD   wOrdinal = 0, wHint = 0;
        DWORD  dwFlags = 0;

        // Check to see if this function is by ordinal or by name. If the
        // function is by ordinal, the ordinal's high bit will be set. If the
        // the high bit is not set, then the ordinal value is really a virtual
        // address of an IMAGE_IMPORT_BY_NAME structure.

        if (IMAGE_SNAP_BY_ORDINAL32(pITDN32->u1.Ordinal))
        {
            wOrdinal = (WORD)IMAGE_ORDINAL32(pITDN32->u1.Ordinal);
            dwFlags = DWFF_ORDINAL;
        }
        else
        {
            // We usually reference the name structure through u1.AddressOfData,
            // but we use u1.Ordinal to ensure that we get only 32-bits.
            PIMAGE_IMPORT_BY_NAME pIIBN = (PIMAGE_IMPORT_BY_NAME)RVAToAbsolute(pITDN32->u1.Ordinal - dwRVAOffset);
            if (pIIBN) {
                pszFunction = (LPCSTR)pIIBN->Name;
    
                // Delay-loaded modules do not use hint values.
                if (!(pModule->m_dwFlags & DWMF_DELAYLOAD))
                {
                    // For non delay-load modules, get the hint value.
                    wHint = pIIBN->Hint;
                    dwFlags |= DWFF_HINT;
                }
            }
        }

        // If this import module has been pre-bound, then get this function's
        // entrypoint memory address. This is usually referenced through u1.Function,
        // but we use u1.Ordinal to ensure that we get only 32-bits.
        DWORD dwAddress = 0;
        if (pITDA32)
        {
            dwFlags |= DWFF_ADDRESS;
            dwAddress = pITDA32->u1.Ordinal;
        }

        // Create a new CFunction object for this import function.
        pFunctionNew = CreateFunction(dwFlags, wOrdinal, wHint, pszFunction, (DWORDLONG)dwAddress);

        // Add the function to the end of our module's function linked list
        if (pFunctionLast)
        {
            pFunctionLast->m_pNext = pFunctionNew;
        }
        else
        {
            pModule->m_pParentImports = pFunctionNew;
        }
        pFunctionLast = pFunctionNew;

        // Increment to the next function and address.
        pITDN32++;
        if (pITDA32)
        {
            pITDA32++;
        }
    }
    return TRUE;
}

//******************************************************************************
BOOL CSession::WalkIAT64(PIMAGE_THUNK_DATA64 pITDN64, PIMAGE_THUNK_DATA64 pITDA64, CModule *pModule, DWORDLONG dwlRVAOffset)
{
    CFunction *pFunctionLast = NULL, *pFunctionNew;

    // Loop through all the Image Thunk Data structures in the function array.
    while (pITDN64->u1.Ordinal)
    {
        LPCSTR pszFunction = NULL;
        WORD   wOrdinal = 0, wHint = 0;
        DWORD  dwFlags = 0;

        // Check to see if this function is by ordinal or by name. If the
        // function is by ordinal, the ordinal's high bit will be set. If the
        // the high bit is not set, then the ordinal value is really a virtual
        // address of an IMAGE_IMPORT_BY_NAME structure.

        if (IMAGE_SNAP_BY_ORDINAL64(pITDN64->u1.Ordinal))
        {
            wOrdinal = (WORD)IMAGE_ORDINAL64(pITDN64->u1.Ordinal);
            dwFlags = DWFF_ORDINAL;
        }
        else
        {
            // We usually reference the name structure through u1.AddressOfData,
            // but we use u1.Ordinal to ensure that we get all 64-bits.
            PIMAGE_IMPORT_BY_NAME pIIBN = (PIMAGE_IMPORT_BY_NAME)RVAToAbsolute((DWORD)(pITDN64->u1.Ordinal - dwlRVAOffset));
            if (pIIBN) {
                pszFunction = (LPCSTR)pIIBN->Name;
                wHint = pIIBN->Hint;
            }
            dwFlags |= DWFF_HINT;
        }

        // If this import module has been pre-bound, then get this function's
        // entrypoint memory address. This is usually referenced through u1.Function,
        // but we use u1.Ordinal to ensure that we get all 64-bits.
        DWORDLONG dwlAddress = 0;
        if (pITDA64)
        {
            dwFlags |= DWFF_ADDRESS | DWFF_64BIT;
            dwlAddress = pITDA64->u1.Ordinal;
        }

        // Create a new CFunction object for this import function.
        pFunctionNew = CreateFunction(dwFlags, wOrdinal, wHint, pszFunction, dwlAddress);

        // Add the function to the end of our module's function linked list
        if (pFunctionLast)
        {
            pFunctionLast->m_pNext = pFunctionNew;
        }
        else
        {
            pModule->m_pParentImports = pFunctionNew;
        }
        pFunctionLast = pFunctionNew;

        // Increment to the next function and address.
        pITDN64++;
        if (pITDA64)
        {
            pITDA64++;
        }
    }
    return TRUE;
}

//******************************************************************************
BOOL CSession::BuildImports(CModule *pModule)
{
    // If this module is a datafile, then we skip all imports.
    if (pModule->m_dwFlags & DWMF_NO_RESOLVE)
    {
        return TRUE;
    }

    m_pszExceptionError = "Error processing the module's imports table.";

    // Get the Import Image Directory.
    DWORD dwSize = 0;
    PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)
                                    GetImageDirectoryEntry(IMAGE_DIRECTORY_ENTRY_IMPORT, &dwSize);

    // If this module has no imports (like NTDLL.DLL), then just return success.
    if (dwSize == 0)
    {
        m_pszExceptionError = NULL;
        return TRUE;
    }

    // Make sure we were able to locate the image directory.
    if (!pIID)
    {
        SetModuleError(pModule, 0, "Could not find the section that owns the Import Directory.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        m_pszExceptionError = NULL;
        return FALSE;
    }

    CModule *pModuleLast = NULL, *pModuleNew;

    // Loop through all the Image Import Descriptors in the array.
    while (pIID->OriginalFirstThunk || pIID->FirstThunk)
    {
        // Locate our module name string and create the module object.
        pModuleNew = CreateModule(pModule, (LPCSTR)RVAToAbsolute(pIID->Name));

        // Mark this module as implicit.
        pModuleNew->m_dwFlags |= DWMF_IMPLICIT;

        // Add the module to the end of our module linked list.
        if (pModuleLast)
        {
            pModuleLast->m_pNext = pModuleNew;
        }
        else
        {
            pModule->m_pDependents = pModuleNew;
        }
        pModuleLast = pModuleNew;

        // Locate the beginning of our function array and address array. The
        // function array (pITDN) is an array of IMAGE_THUNK_DATA structures that
        // contains all the exported functions, both by name and by ordinal. The
        // address array (pITDA) is an parallel array of IMAGE_THUNK_DATA
        // structures that is used to store the all the function's entrypoint
        // addresses. Usually the address array contains the exact same values
        // the function array contains until the OS loader actually loads all the
        // modules. At that time, the loader will set (bind) these addresses to
        // the actual addresses that the given functions reside at in memory. Some
        // modules have their exports pre-bound which can provide a speed increase
        // when loading the module. If a module is pre-bound (often seen with
        // system modules), the TimeDateStamp field of our IMAGE_IMPORT_DESCRIPTOR
        // structure will be set and the address array will contain the actual
        // memory addresses that the functions will reside at, assuming that the
        // imported module loads at its preferred base address.

        PIMAGE_THUNK_DATA pITDN = NULL, pITDA = NULL;

        // Check to see if module is Microsoft format or Borland format.
        if (pIID->OriginalFirstThunk)
        {
            // Microsoft uses the OriginalFirstThunk field for the function array.
            pITDN = (PIMAGE_THUNK_DATA)RVAToAbsolute((DWORD)pIID->OriginalFirstThunk);

            // Microsoft optionally uses the FirstThunk as a bound address array.
            // If the TimeDateStamp field is set, then the module has been bound.
            if (pIID->TimeDateStamp)
            {
                pITDA = (PIMAGE_THUNK_DATA)RVAToAbsolute((DWORD)pIID->FirstThunk);
            }
        }
        else
        {
            // Borland uses the FirstThunk field for the function array.
            pITDN = (PIMAGE_THUNK_DATA)RVAToAbsolute((DWORD)pIID->FirstThunk);
        }

        if (pITDN) {
            // Find imports
            if (m_f64Bit)
            {
                if (!WalkIAT64((PIMAGE_THUNK_DATA64)pITDN, (PIMAGE_THUNK_DATA64)pITDA, pModuleLast, 0))
                {
                    m_pszExceptionError = NULL;
                    return FALSE;
                }
            }
            else if (!WalkIAT32((PIMAGE_THUNK_DATA32)pITDN, (PIMAGE_THUNK_DATA32)pITDA, pModuleLast, 0))
            {
                m_pszExceptionError = NULL;
                return FALSE;
            }
        } else {
            SetModuleError(pModule, 0, "Could not find the section that owns the Import Name Table.");
            m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
            m_pszExceptionError = NULL;
            return FALSE;
        }

        // Increment to the next import module
        pIID++;
    }

    m_pszExceptionError = NULL;
    return TRUE;
}

//******************************************************************************
BOOL CSession::BuildDelayImports(CModule *pModule)
{
    // If we are not processes delay-load modules or if this module is a datafile,
    // then we skip all imports.
    if (g_theApp.m_fNoDelayLoad || (pModule->m_dwFlags & DWMF_NO_RESOLVE))
    {
        return TRUE;
    }

    m_pszExceptionError = "Error processing the module's delay-load imports table.";

    // Get the Import Image Directory.
    DWORD dwSize = 0;
    PImgDelayDescr pIDD = (PImgDelayDescr)GetImageDirectoryEntry(IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, &dwSize);

    // If this module has no delayed imports, then just return success.
    if (dwSize == 0)
    {
        m_pszExceptionError = NULL;
        return TRUE;
    }

    // Make sure we were able to locate the image directory.
    if (!pIDD)
    {
        SetModuleError(pModule, 0, "Could not find the section that owns the Delay Import Directory.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        m_pszExceptionError = NULL;
        return FALSE;
    }

    CModule *pModuleLast = NULL, *pModuleNew;

    // Loop through all the Image Import Descriptors in the array.
    while (pIDD->rvaINT)
    {
        // Locate our module name string.
        LPCSTR pszName = (LPCSTR)IDD_VALUE(pIDD, rvaDLLName);
        if (!pszName)
        {
            SetModuleError(pModule, 0, "Could not find the section that owns the Delay Import DLL Name.");
            m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
            m_pszExceptionError = NULL;
            return FALSE;
        }

        // Create the module object for this DLL.
        pModuleNew = CreateModule(pModule, pszName);

        // Mark this module as delay-load.
        pModuleNew->m_dwFlags |= DWMF_DELAYLOAD;

        // Add the module to the end of our module linked list.
        if (pModuleLast)
        {
            pModuleLast->m_pNext = pModuleNew;
        }
        else
        {
            if (pModule->m_pDependents)
            {
                pModuleLast = pModule->m_pDependents;
                while (pModuleLast->m_pNext)
                {
                    pModuleLast = pModuleLast->m_pNext;
                }
                pModuleLast->m_pNext = pModuleNew;
            }
            else
            {
                pModule->m_pDependents = pModuleNew;
            }
        }
        pModuleLast = pModuleNew;

        // Get the name table.
        PIMAGE_THUNK_DATA pITDA = NULL, pITDN = (PIMAGE_THUNK_DATA)IDD_VALUE(pIDD, rvaINT);
        if (!pITDN)
        {
            SetModuleError(pModule, 0, "Could not find the section that owns the Delay Import Name Table.");
            m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
            m_pszExceptionError = NULL;
            return FALSE;
        }

        // If the module is bound, then get the bound address table.
        if (pIDD->dwTimeStamp)
        {
            pITDA = (PIMAGE_THUNK_DATA)IDD_VALUE(pIDD, rvaBoundIAT);
        }

        // Find imports.  The 6.0 linker added Delay Load dependencies.  It used
        // file offsets for all values, so we need to pass in our image base to
        // WalkIAT64 so it can subtract it off resulting in an RVA.  The 7.0 linker
        // adds the dlattrRva bit to signify a new format.  Early versions of the
        // 7.0 linker would set the dlattrRva flag, but still use file offsets.
        // This has been since changed.  Now, if the dlattrRva is set, we assume
        // the addresses are already RVAs and we don't subtract off our base
        // address.  This means we will break for modules built with early
        // versions of the 7.0 linker.
        if (m_f64Bit)
        {
            if (!WalkIAT64((PIMAGE_THUNK_DATA64)pITDN, (PIMAGE_THUNK_DATA64)pITDA, pModuleLast,
                           (pIDD->grAttrs & dlattrRva) ? 0 : ((PIMAGE_OPTIONAL_HEADER64)m_pIOH)->ImageBase))
            {
                m_pszExceptionError = NULL;
                return FALSE;
            }
        }
        else if (!WalkIAT32((PIMAGE_THUNK_DATA32)pITDN, (PIMAGE_THUNK_DATA32)pITDA, pModuleLast,
                            (pIDD->grAttrs & dlattrRva) ? 0 : ((PIMAGE_OPTIONAL_HEADER32)m_pIOH)->ImageBase))
        {
            m_pszExceptionError = NULL;
            return FALSE;
        }

        // Increment to the next import module.
        pIDD++;
    }

    m_pszExceptionError = NULL;
    return TRUE;
}

//******************************************************************************
BOOL CSession::BuildExports(CModule *pModule)
{
    // If we already have exports, then bail.  This can happen if a module loaded
    // as a datafile later gets loaded as a real module.
    if (pModule->m_pData->m_pExports)
    {
        return TRUE;
    }

    m_pszExceptionError = "Error processing the module's export table.";

    // Get the Export Image Directory.
    DWORD dwSize = 0;
    PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)GetImageDirectoryEntry(IMAGE_DIRECTORY_ENTRY_EXPORT, &dwSize);

    // If this module has no exports, then just return success.
    if (dwSize == 0)
    {
        m_pszExceptionError = NULL;
        return TRUE;
    }

    // Make sure we were able to locate the image directory.
    if (!pIED)
    {
        SetModuleError(pModule, 0, "Could not find the section that owns the Export Directory.");
        m_dwReturnFlags |= DWRF_FORMAT_NOT_RECOGNIZED;
        m_pszExceptionError = NULL;
        return FALSE;
    }

    // pdwNames is a DWORD array of size pIED->NumberOfNames, which contains VA
    // pointers to all the function name strings. pwOrdinals is a WORD array of
    // size pIED->NumberOfFunctions, which contains all the ordinal values for
    // each function exported by name. pdwNames and pwOrdinals are parallel
    // arrays, meaning that the ordinal in pwOrdinals[x] goes with the function
    // name pointed to by pdwNames[x]. The value used to index these arrays is
    // referred to as the "hint".

    // pdwAddresses is a DWORD array of size pIED->NumberOfFunctions, which
    // contains the entrypoint addresses for all functions exported by the
    // module. Contrary to several PE format documents, this array is *not*
    // parallel with pdwNames and pwOrdinals. The index used for this array is
    // the ordinal value of the function you are interested in, minus the base
    // ordinal specified in pIED->Base. Another common mistake is to assume that
    // pIED->NumberOfFunctions is always equal to pIED->AddressOfNames. If the
    // module exports function by ordinal only, then pIED->NumberOfFunctions
    // will be greater than pIED->NumberOfNames.

    DWORD *pdwNames     = (DWORD*)RVAToAbsolute((DWORD)pIED->AddressOfNames);
    WORD  *pwOrdinals   = (WORD* )RVAToAbsolute((DWORD)pIED->AddressOfNameOrdinals);
    DWORD *pdwAddresses = (DWORD*)RVAToAbsolute((DWORD)pIED->AddressOfFunctions);

    CFunction *pFunctionLast = NULL, *pFunctionNew;

    DWORD dwForwardAddressStart = IOH_VALUE(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    DWORD dwForwardAddressEnd   = dwForwardAddressStart + IOH_VALUE(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);

    // Loop through all the exports.
    for (DWORD dwFunction = 0; dwFunction < pIED->NumberOfFunctions; dwFunction++)
    {
        // Get this function's entrypoint address
        DWORD  dwAddress  = NULL;
        LPCSTR pszFunction = NULL;
        LPCSTR pszForward  = NULL;

        if (pdwAddresses) {
            dwAddress = pdwAddresses[dwFunction];
        }

        // Skip any functions with 0 addresses - they are just space-holders in the array.
        if (dwAddress)
        {
            // Loop through our name list to see if this ordinal is present in the list.
            // If so, then this function is exported by name and ordinal.
            for (DWORD dwHint = 0; dwHint < pIED->NumberOfNames; dwHint++)
            {
                if (pwOrdinals[dwHint] == dwFunction)
                {
                    pszFunction = (LPCSTR)RVAToAbsolute(pdwNames[dwHint]);
                    break;
                }
            }

            // Certain modules, such as KERNEL32.DLL and WSOCK32.DLL, have what are
            // known as forwarded functions.  Forwarded functions are functions that
            // are exported from one module, but the code actually lives in another
            // module.  DW 1.0 checked to see if a function is forwarded by looking
            // at its address pointer.  If the address pointer points to the character
            // immediately following the NULL character in its function name string,
            // then DW assumed the address pointer is really a pointer to a forward
            // string in the string table.  This worked, but was a lucky guess that
            // could fail.  The real way is to check the address to see if it falls
            // within the export directory address range.

            if ((dwAddress >= dwForwardAddressStart) && (dwAddress < dwForwardAddressEnd))
            {
                pszForward = (LPCSTR)RVAToAbsolute(dwAddress);
            }

            // Create a new CFunction object for this export function.
            pFunctionNew = CreateFunction(DWFF_ORDINAL | DWFF_ADDRESS | DWFF_EXPORT | (pszFunction ? DWFF_HINT : 0),
                                          (WORD)(pIED->Base + dwFunction), (WORD)(pszFunction ? dwHint : 0),
                                          pszFunction, (DWORDLONG)dwAddress, pszForward);

            // Add the function to the end of our module's export function linked list
            if (pFunctionLast)
            {
                pFunctionLast->m_pNext = pFunctionNew;
            }
            else
            {
                pModule->m_pData->m_pExports = pFunctionNew;
            }
            pFunctionLast = pFunctionNew;
        }
    }

    m_pszExceptionError = NULL;
    return TRUE;
}

//******************************************************************************
BOOL CSession::CheckForSymbols(CModule *pModule)
{
    m_pszExceptionError = "Error processing the module's debug symbols.";

    // Get the Debug Image Directory.
    DWORD dwSize = 0;
    PIMAGE_DEBUG_DIRECTORY pIDD = (PIMAGE_DEBUG_DIRECTORY)
                                  GetImageDirectoryEntry(IMAGE_DIRECTORY_ENTRY_DEBUG, &dwSize);

    // Clear out our symbol flags just to be safe.
    pModule->m_pData->m_dwSymbolFlags = 0;

    // If the Debug Image Directory size is 0, then we know there
    // is no debug information and we can immediately return TRUE.
    if (!pIDD || (dwSize == 0))
    {
        m_pszExceptionError = NULL;
        return TRUE;
    }

    // For DBG symbols, we can just check the PE file's characteristics. If the
    // IMAGE_FILE_DEBUG_STRIPPED flag is set, there will be a IMAGE_DEBUG_TYPE_MISC
    // block containing the DBG filename.  I have never found a case where a file
    // contains just the IMAGE_FILE_DEBUG_STRIPPED flag or just a DBG MISC block,
    // but not both, so I am assuming they go hand-in-hand.
    if (m_pIFH->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
    {
        pModule->m_pData->m_dwSymbolFlags |= DWSF_DBG;
    }

    // Loop through the array looking to see what types of debug info we may have.
    for (int i = dwSize / sizeof(IMAGE_DEBUG_DIRECTORY) - 1; i >= 0; i--, pIDD++)
    {
        // We only handle blocks that have some data associated with them.
        if (pIDD->SizeOfData && pIDD->PointerToRawData)
        {
            // Check to see if the file pointer is past the end of the file.
            if ((pIDD->PointerToRawData > m_dwSize) ||
                ((pIDD->PointerToRawData + pIDD->SizeOfData) > m_dwSize))
            {
                pModule->m_pData->m_dwSymbolFlags |= DWSF_INVALID;
            }

            switch (pIDD->Type)
            {
                case IMAGE_DEBUG_TYPE_COFF:
                    pModule->m_pData->m_dwSymbolFlags |= DWSF_COFF;
                    break;

                case IMAGE_DEBUG_TYPE_CODEVIEW:

                    // Check for the PDB signature.
                    if ((pIDD->PointerToRawData <= (m_dwSize - 4)) &&
                        (*(DWORD*)((DWORD_PTR)m_lpvFile + (DWORD_PTR)pIDD->PointerToRawData) == PDB_SIGNATURE))
                    {
                        pModule->m_pData->m_dwSymbolFlags |= DWSF_PDB;
                    }

                    // Otherwise, we assume it is plain codeview.
                    else
                    {
                        pModule->m_pData->m_dwSymbolFlags |= DWSF_CODEVIEW;
                    }
                    break;

                case IMAGE_DEBUG_TYPE_FPO:
                    pModule->m_pData->m_dwSymbolFlags |= DWSF_FPO;
                    break;

                case IMAGE_DEBUG_TYPE_MISC:
                    // We always skip MISC - it just points to a IMAGE_DEBUG_MISC
                    // which contains the file name or DBG file name.
                    break;

                case IMAGE_DEBUG_TYPE_EXCEPTION:
                    // What is EXCEPTION?  For now, we just ignore it.
                    break;

                case IMAGE_DEBUG_TYPE_FIXUP:
                    // What is FIXUP?  For now, we just ignore it.
                    break;

                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                    pModule->m_pData->m_dwSymbolFlags |= DWSF_OMAP;
                    break;

                case IMAGE_DEBUG_TYPE_BORLAND:
                    pModule->m_pData->m_dwSymbolFlags |= DWSF_BORLAND;
                    break;

                case IMAGE_DEBUG_TYPE_RESERVED10:
                    // What is RESERVED10?  For now, we just ignore it.
                    break;

                case IMAGE_DEBUG_TYPE_CLSID:
                    // Not sure what this is.  For now, we just ignore it.
                    break;

                case IMAGE_DEBUG_TYPE_UNKNOWN:
                default:
                    pModule->m_pData->m_dwSymbolFlags |= DWSF_UNKNOWN;
            }
        }

#if 0 //{{AFX // For debugging purposes...
        TRACE("---------------------------------------------------------------------\n");
        TRACE("Module:           %s\n", pModule->GetName(false));
        TRACE("Debug Type:       ");
        switch (pIDD->Type)
        {
            case IMAGE_DEBUG_TYPE_UNKNOWN:       TRACE("UNKNOWN\n"); break;
            case IMAGE_DEBUG_TYPE_COFF:          TRACE("COFF\n"); break;
            case IMAGE_DEBUG_TYPE_CODEVIEW:      TRACE("CODEVIEW\n"); break;
            case IMAGE_DEBUG_TYPE_FPO:           TRACE("FPO\n"); break;
            case IMAGE_DEBUG_TYPE_MISC:          TRACE("MISC\n"); break;
            case IMAGE_DEBUG_TYPE_EXCEPTION:     TRACE("EXCEPTION\n"); break;
            case IMAGE_DEBUG_TYPE_FIXUP:         TRACE("FIXUP\n"); break;
            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:   TRACE("OMAP_TO_SRC\n"); break;
            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: TRACE("OMAP_FROM_SRC\n"); break;
            case IMAGE_DEBUG_TYPE_BORLAND:       TRACE("BORLAND\n"); break;
            case IMAGE_DEBUG_TYPE_RESERVED10:    TRACE("RESERVED10\n"); break;
            default: TRACE("%u\n", pIDD->Type);
        }
        TRACE("Characteristics:  0x%08X\n", pIDD->Characteristics);
        TRACE("TimeDateStamp:    0x%08X\n", pIDD->TimeDateStamp);
        TRACE("MajorVersion:     %u\n",     (DWORD)pIDD->MajorVersion);
        TRACE("MinorVersion:     %u\n",     (DWORD)pIDD->MinorVersion);
        TRACE("SizeOfData:       %u\n",     pIDD->SizeOfData);
        TRACE("AddressOfRawData: 0x%08X\n", pIDD->AddressOfRawData);
        TRACE("PointerToRawData: 0x%08X\n", pIDD->PointerToRawData);
        HexDump((DWORD)m_lpvFile, pIDD->PointerToRawData, min(64, pIDD->SizeOfData));
#endif //}}AFX

    }

    m_pszExceptionError = NULL;
    return TRUE;
}

//******************************************************************************
void CSession::VerifyParentImports(CModule *pModule)
{
    CModule *pModuleHead = NULL, *pModuleLast, *pModuleCur;

    // Loop through each of our parent import functions.
    for (CFunction *pImport = pModule->m_pParentImports; pImport;
        pImport = pImport->m_pNext)
    {
        // Mark this parent import function as not resolved before starting search.
        pImport->m_pAssociatedExport = NULL;
        pImport->m_dwFlags &= ~DWFF_RESOLVED;

        // Loop through all our exports, looking for a match with our current import.
        bool fExportsChanged = false;
        for (CFunction *pExport = pModule->m_pData->m_pExports; pExport;
            pExport = pExport->m_pNext)
        {
            // If we have a name, then check for the match by name.
            if (*pImport->GetName())
            {
                if (!strcmp(pImport->GetName(), pExport->GetName()))
                {
                    // We found a match. Link this parent import to its associated
                    // export, flag the export as being called at least once, break
                    // out of loop, and move on to handling our next parent import.
                    pImport->m_pAssociatedExport = pExport;
                    pImport->m_dwFlags |= DWFF_RESOLVED;
                    if (!(pExport->m_dwFlags & DWFF_CALLED_ALO))
                    {
                        pExport->m_dwFlags |= DWFF_CALLED_ALO;
                        fExportsChanged = true;
                    }
                    break;
                }
            }

            // If we don't have a name, then check for the match by ordinal.
            else if (pImport->m_wOrdinal == pExport->m_wOrdinal)
            {
                // We found a match. Link this parent import to its associated
                // export, flag the export as being called at least once, break
                // out of loop, and move on to handling our next parent import.
                pImport->m_pAssociatedExport = pExport;
                pImport->m_dwFlags |= DWFF_RESOLVED;
                if (!(pExport->m_dwFlags & DWFF_CALLED_ALO))
                {
                    pExport->m_dwFlags |= DWFF_CALLED_ALO;
                    fExportsChanged = true;
                }
                break;
            }
        }

        // If we modified an export and we are profiling, then let the UI know about it.
        if (m_pfnProfileUpdate && fExportsChanged && m_pProcess)
        {
            m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_EXPORTS_CHANGED, (DWORD_PTR)pModule, 0);
        }

        // If we are loading a DWI file, we skip the forwarded module check since
        // that information will be loaded by the file.
        if (!(m_dwFlags & DWSF_DWI))
        {
            // Check to see if an export match was found.
            if (pImport->GetAssociatedExport())
            {
                CHAR   szFile[1024];
                LPCSTR pszFunction;
                int    fileLen;
                LPCSTR pszDot, pszFile;

                // If an export was found, check to see if it is a forwarded function.
                // If it is forwarded, then we need to make sure we consider the
                // forwarded module as a new dependent of the current module.
                LPCSTR pszForward = pImport->GetAssociatedExport()->GetExportForwardName();
                if (pszForward)
                {
                    // The forward text is formatted as Module.Function. Look for the dot.
                    pszDot = strchr(pszForward, '.');
                    if (pszDot)
                    {
                        // Compute the file name length.
                        fileLen = min((int)(pszDot - pszForward), (int)sizeof(szFile) - 5);

                        // Copy the file portion of the forward string to our file buffer.
                        // We add 1 because we want the entire name plus a null char copied over.
                        StrCCpy(szFile, pszForward, fileLen + 1);

                        // Store a pointer to function name portion of the forward string.
                        pszFunction = pszDot + 1;
                    }

                    // If no dot was found in the forward string, then something is wrong.
                    else
                    {
                        fileLen = (int)strlen(StrCCpy(szFile, "Invalid", sizeof(szFile)));
                        pszFunction = pszForward;
                    }

                    // Search our local forward module list to see if we have already
                    // created a forward CModoule for this DLL file.
                    for (pModuleLast = NULL, pModuleCur = pModuleHead; pModuleCur;
                        pModuleLast = pModuleCur, pModuleCur = pModuleCur->m_pNext)
                    {
                        // Attempt to locate the dot in the file name.
                        pszDot = strrchr(pszFile = pModuleCur->GetName(false), '.');

                        // If there is a dot and the name portions are equal in length,
                        // then compare just the name portions. If there is no dot,
                        // then just compare the names.  If the compare finds a match,
                        // then this is the module we are looking for.
                        if ((pszDot && ((pszDot - pszFile) == fileLen) && !_strnicmp(pszFile, szFile, fileLen)) ||
                            (!pszDot && !_stricmp(pszFile, szFile)))
                        {
                            break;
                        }
                    }

                    // If we have not created a forward module for this file yet, then
                    // create it now and add it to the end of our list.
                    if (!pModuleCur)
                    {
                        CHAR szPath[DW_MAX_PATH], *pszTemp;

                        // Check to see if we already have a module with this same base name.
                        if (pModuleCur = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_FILE_NO_EXT, (DWORD_PTR)szFile))
                        {
                            // If so, then just store it's path away.
                            StrCCpy(szPath, pModuleCur->GetName(true), sizeof(szPath));
                        }

                        // Otherwise, we need to search for the module.
                        else
                        {
                            // First, we check for a DLL file.
                            StrCCpy(szFile + fileLen, ".DLL", sizeof(szFile) - fileLen);
                            if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                            {
                                // If that fails, then check for and EXE
                                StrCCpy(szFile + fileLen, ".EXE", sizeof(szFile) - fileLen);
                                if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                                {
                                    // If that fails, then check for a SYS file.
                                    StrCCpy(szFile + fileLen, ".SYS", sizeof(szFile) - fileLen);
                                    if (!SearchPathForFile(szFile, szPath, sizeof(szPath), &pszTemp))
                                    {
                                        // If that fails, then we just use the file name without an extension.
                                        szFile[fileLen] = '\0';
                                        StrCCpy(szPath, szFile, sizeof(szPath));
                                    }
                                }
                            }
                        }

                        // Create the module using the complete path.
                        pModuleCur = CreateModule(pModule, szPath);

                        // Mark this module as implicit and forwarded.
                        pModuleCur->m_dwFlags |= (DWMF_FORWARDED | DWMF_IMPLICIT);

                        // Add the new module to our local forward module list.
                        if (pModuleLast)
                        {
                            pModuleLast->m_pNext = pModuleCur;
                        }
                        else
                        {
                            pModuleHead = pModuleCur;
                        }
                    }

                    // Create a new CFunction object for this import function.
                    CFunction *pFunction = CreateFunction(0, 0, 0, pszFunction, 0);

                    // Insert this function object into our forward module's import list.
                    pFunction->m_pNext = pModuleCur->m_pParentImports;
                    pModuleCur->m_pParentImports = pFunction;
                }
            }
            else
            {
                // If we could not find an import/export match, then flag the module
                // as having an export error.
                pModule->m_dwFlags          |= DWMF_MODULE_ERROR;
                pModule->m_pData->m_dwFlags |= DWMF_MODULE_ERROR_ALO;

                // If the module has an error (like file not found), then it will
                // have unresolved externals.  We don't flag this case as
                // DWRF_MISSING_EXPORT since it is really a file not found error.
                if (!pModule->GetErrorMessage())
                {
                    // Walk up the parent list looking for a module that lets
                    // us know what type of dependency this is.  we mostly need
                    // to do this for forwared modules since their parent dragged
                    // them in.
                    for (pModuleCur = pModule; pModuleCur; pModuleCur = pModuleCur->m_pParent)
                    {
                        // If we found a delay-load module, then add this to our flags and bail.
                        if (pModuleCur->m_dwFlags & DWMF_DELAYLOAD)
                        {
                            m_dwReturnFlags |= DWRF_MISSING_DELAYLOAD_EXPORT;
                            break;
                        }
                        if (pModuleCur->m_dwFlags & DWMF_DYNAMIC)
                        {
                            m_dwReturnFlags |= DWRF_MISSING_DYNAMIC_EXPORT;
                            break;
                        }
                    }
                    if (!pModuleCur)
                    {
                        m_dwReturnFlags |= DWRF_MISSING_IMPLICIT_EXPORT;
                    }
                }
            }
        }
    }

    // If we created any forward modules during our entire import verify, then
    // add them to the end of our module's dependent module list.
    if (!(m_dwFlags & DWSF_DWI) && pModuleHead)
    {
        // Walk to end of our module's dependent module list.
        for (pModuleLast = pModule->m_pDependents;
            pModuleLast && pModuleLast->m_pNext;
            pModuleLast = pModuleLast->m_pNext)
        {
        }

        // Add our local list to the end of our module's dependent module list.
        if (pModuleLast)
        {
            pModuleLast->m_pNext = pModuleHead;
        }
        else
        {
            pModule->m_pDependents = pModuleHead;
        }
    }
}

//******************************************************************************
LPCSTR CSession::GetThreadName(CThread *pThread)
{
    // We only get called by main thread.
    static CHAR szBuffer[MAX_THREAD_NAME_LENGTH + 17];

    if (!pThread)
    {
        return "<unknown>";
    }

    // Check to see if thread numbering is enabled.
    if (m_dwProfileFlags & PF_USE_THREAD_INDEXES)
    {
        if (pThread->m_pszThreadName)
        {
            SCPrintf(szBuffer, sizeof(szBuffer), "%u \"%s\"", pThread->m_dwThreadNumber, pThread->m_pszThreadName);
        }
        else
        {
            SCPrintf(szBuffer, sizeof(szBuffer), "%u", pThread->m_dwThreadNumber);
        }

    }
    else
    {
        if (pThread->m_pszThreadName)
        {
            SCPrintf(szBuffer, sizeof(szBuffer), "0x%X \"%s\"", pThread->m_dwThreadId, pThread->m_pszThreadName);
        }
        else
        {
            SCPrintf(szBuffer, sizeof(szBuffer), "0x%X", pThread->m_dwThreadId);
        }
    }

    return szBuffer;
}

//******************************************************************************
LPCSTR CSession::ThreadString(CThread *pThread)
{
    // We only get called by main thread.
    static CHAR szBuffer[MAX_THREAD_NAME_LENGTH + 33];

    // Check to see if the user wants thread information.
    if (m_dwProfileFlags & PF_LOG_THREADS)
    {
        // Build and return thread string.
        SCPrintf(szBuffer, sizeof(szBuffer), " by thread %s", GetThreadName(pThread));
        return szBuffer;
    }

    // Otherwise, return an empty string.
    return "";
}

//******************************************************************************
DWORD CSession::HandleEvent(CEvent *pEvent)
{
    switch (pEvent->GetType())
    {
        case CREATE_PROCESS_DEBUG_EVENT:  return EventCreateProcess(       (CEventCreateProcess*)     pEvent); break;
        case EXIT_PROCESS_DEBUG_EVENT:    return EventExitProcess(         (CEventExitProcess*)       pEvent); break;
        case CREATE_THREAD_DEBUG_EVENT:   return EventCreateThread(        (CEventCreateThread*)      pEvent); break;
        case EXIT_THREAD_DEBUG_EVENT:     return EventExitThread(          (CEventExitThread*)        pEvent); break;
        case LOAD_DLL_DEBUG_EVENT:        return EventLoadDll(             (CEventLoadDll*)           pEvent); break;
        case UNLOAD_DLL_DEBUG_EVENT:      return EventUnloadDll(           (CEventUnloadDll*)         pEvent); break;
        case OUTPUT_DEBUG_STRING_EVENT:   return EventDebugString(         (CEventDebugString*)       pEvent); break;
        case EXCEPTION_DEBUG_EVENT:       return EventException(           (CEventException*)         pEvent); break;
        case RIP_EVENT:                   return EventRip(                 (CEventRip*)               pEvent); break;
        case DLLMAIN_CALL_EVENT:          return EventDllMainCall(         (CEventDllMainCall*)       pEvent); break;
        case DLLMAIN_RETURN_EVENT:        return EventDllMainReturn(       (CEventDllMainReturn*)     pEvent); break;
        case LOADLIBRARY_CALL_EVENT:      return EventLoadLibraryCall(     (CEventLoadLibraryCall*)   pEvent); break;
        case LOADLIBRARY_RETURN_EVENT:    return EventLoadLibraryReturn(   (CEventFunctionReturn*)    pEvent); break;
        case GETPROCADDRESS_CALL_EVENT:   return EventGetProcAddressCall(  (CEventGetProcAddressCall*)pEvent); break;
        case GETPROCADDRESS_RETURN_EVENT: return EventGetProcAddressReturn((CEventFunctionReturn*)    pEvent); break;
        case MESSAGE_EVENT:               return EventMessage(             (CEventMessage*)           pEvent); break;
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventCreateProcess(CEventCreateProcess *pEvent)
{
/*
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
*/
    // Make sure we have a module to be safe (we always should).
    if (!pEvent->m_pModule)
    {
        return DBG_CONTINUE;
    }

    DWORD dwLog = ((pEvent->m_pModule->m_hookStatus == HS_ERROR) ||
                   ((m_dwProfileFlags & PF_HOOK_PROCESS) &&
                    (pEvent->m_pModule->m_hookStatus == HS_NOT_HOOKED))) ? LOG_ERROR : 0;

    Log(dwLog | LOG_BOLD | LOG_TIME_STAMP, pEvent->m_dwTickCount,
        "Started \"%s\" (process 0x%X) at address " HEX_FORMAT "%s.%s\n",
        GET_NAME(pEvent->m_pModule),
        m_pProcess->GetProcessId(),
        pEvent->m_pModule->m_dwpImageBase, ThreadString(pEvent->m_pThread),
        (pEvent->m_pModule->m_hookStatus == HS_SHARED)  ? "  Shared module not hooked."                   :
        (pEvent->m_pModule->m_hookStatus == HS_HOOKED)  ? "  Successfully hooked module."                 :
        (pEvent->m_pModule->m_hookStatus == HS_ERROR)   ? "  Error hooking module, will try again later." :
        (m_dwProfileFlags & PF_HOOK_PROCESS)            ? "  Cannot hook module."                         : "");

    // Add this module to our list.
    AddImplicitModule(pEvent->m_pModule->GetName(true), pEvent->m_pModule->m_dwpImageBase);

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventExitProcess(CEventExitProcess *pEvent)
{
/*
   DWORD dwExitCode;
*/
    Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
        "Exited \"%s\" (process 0x%X) with code %d (0x%X)%s.\n",
        GET_NAME(pEvent->m_pModule), m_pProcess->GetProcessId(),
        pEvent->m_dwExitCode, pEvent->m_dwExitCode, ThreadString(pEvent->m_pThread));

    // Tell the document that we are done profiling.
    if (m_pfnProfileUpdate) //!! do we want to do this in our CProcess destructor.
    { 
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_PROFILE_DONE, 0, 0);
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventCreateThread(CEventCreateThread *pEvent)
{
/*
   HANDLE hThread; //?? close this?
   LPVOID lpThreadLocalBase;
   LPTHREAD_START_ROUTINE lpStartAddress;
*/
    if (m_dwProfileFlags & PF_LOG_THREADS)
    {
        // Display the log.
        Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "Thread %s started in \"%s\" at address " HEX_FORMAT ".\n",
            GetThreadName(pEvent->m_pThread), GET_NAME(pEvent->m_pModule), pEvent->m_dwpStartAddress);
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventExitThread(CEventExitThread *pEvent)
{
/*
   DWORD dwExitCode;
*/
    if (m_dwProfileFlags & PF_LOG_THREADS)
    {
        Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "Thread %s exited with code %d (0x%X).\n",
            GetThreadName(pEvent->m_pThread), pEvent->m_dwExitCode, pEvent->m_dwExitCode);
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventLoadDll(CEventLoadDll *pEvent)
{
/*
   HANDLE hFile;  // We do have to close this handle.
   LPVOID lpBaseOfDll;
   DWORD dwDebugInfoFileOffset;
   DWORD nDebugInfoSize;
   LPVOID lpImageName;
   WORD fUnicode;
*/
    // Make sure we have a module to be safe (we always should).
    if (!pEvent->m_pModule)
    {
        return DBG_CONTINUE;
    }

    // Check to see if this module is our injection module.
    if (pEvent->m_pModule->m_hookStatus == HS_INJECTION_DLL)
    {
        // Remember the address that our injection module loaded at.
        m_dwpDWInjectBase = pEvent->m_pModule->m_dwpImageBase;
        m_dwDWInjectSize  = pEvent->m_pModule->m_dwVirtualSize;

        // We special case our log for the injection module.
        Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "Injected \"%s\" at address " HEX_FORMAT "%s.\n",
            GET_NAME(pEvent->m_pModule), pEvent->m_pModule->m_dwpImageBase, ThreadString(pEvent->m_pThread));
    }

    // Otherwise, it is just a normal module.
    else
    {
        DWORD dwLog = ((pEvent->m_pModule->m_hookStatus == HS_ERROR) ||
                       ((m_dwProfileFlags & PF_HOOK_PROCESS) &&
                        (pEvent->m_pModule->m_hookStatus == HS_NOT_HOOKED))) ? LOG_ERROR : 0;

        // We display "Mapped..." log for data files and "Loaded..." log for executables.
        if (pEvent->m_pModule->m_hookStatus == HS_DATA)
        {
            // Display the module "Mapped..." load event in our log.
            Log(dwLog | LOG_BOLD | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "Mapped \"%s\" as a data file into memory at address " HEX_FORMAT "%s.\n",
                GET_NAME(pEvent->m_pModule), pEvent->m_pModule->m_dwpImageBase, ThreadString(pEvent->m_pThread));
        }
        else
        {
            // Display the module "Loaded..." load event in our log.
            Log(dwLog | LOG_BOLD | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "Loaded \"%s\" at address " HEX_FORMAT "%s.%s\n",
                GET_NAME(pEvent->m_pModule), pEvent->m_pModule->m_dwpImageBase, ThreadString(pEvent->m_pThread),
                (pEvent->m_pModule->m_hookStatus == HS_SHARED)  ? "  Shared module not hooked."                   :
                (pEvent->m_pModule->m_hookStatus == HS_HOOKED)  ? "  Successfully hooked module."                 :
                (pEvent->m_pModule->m_hookStatus == HS_ERROR)   ? "  Error hooking module, will try again later." :
                (m_dwProfileFlags & PF_HOOK_PROCESS)            ? "  Cannot hook module."                         : "");
        }

        // If it is part of a function call, we will add it to the tree later when the
        // function completes and the results are flushed to us.  If it is not part of
        // a function call, then we need to add it now.
        if (!pEvent->m_fLoadedByFunctionCall)
        {
            AddImplicitModule(pEvent->m_pModule->GetName(true), pEvent->m_pModule->m_dwpImageBase);
        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventUnloadDll(CEventUnloadDll *pEvent)
{
/*
   LPVOID lpBaseOfDll;
*/
    // Search for the module that owns this address.
    CModule *pModule = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_EXPLICIT_ONLY | FMF_SIBLINGS | FMF_LOADED | FMF_ADDRESS,
                                  (DWORD_PTR)pEvent->m_dwpImageBase);

    // Make a note that this module is no longer loaded.
    if (pModule)
    {
        pModule->m_pData->m_dwFlags &= ~DWMF_LOADED;
    }

    // Display the log including the module name.
    Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
        "Unloaded \"%s\" at address " HEX_FORMAT "%s.\n",
        GET_NAME(pEvent->m_pModule), pEvent->m_dwpImageBase, ThreadString(pEvent->m_pThread));

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventDebugString(CEventDebugString *pEvent)
{
/*
   LPSTR lpDebugStringData;
   WORD fUnicode;
   WORD nDebugStringLength;
*/

    // If the user has chosen to see debug strings, then log the string.
    if (m_dwProfileFlags & PF_LOG_DEBUG_OUTPUT)
    {
        Log(LOG_DEBUG | LOG_TIME_STAMP, pEvent->m_dwTickCount, "%s", pEvent->m_pszBuffer);
    }
    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventException(CEventException *pEvent)
{
/*
   EXCEPTION_RECORD ExceptionRecord;
   DWORD ExceptionCode;
   DWORD ExceptionFlags;
   struct _EXCEPTION_RECORD *ExceptionRecord;
   PVOID ExceptionAddress;
   DWORD NumberParameters;
   DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
   DWORD fFirstChance;
*/
    // We don't get involved with handling exceptions.  For the most part, we
    // just return DBG_EXCEPTION_NOT_HANDLED and let nature take its course.
    // The only exception we handle differently is a breakpoint.  The loader
    // automatically generates a breakpoint just before the process' entrypoint
    // is called, but after all implicit dependencies have been loaded.  For this
    // breakpoint and any other breakpoints that may be in the code, we just
    // return DBG_CONTINUE to ignore it and continue execution.

    DWORD dwContinue = DBG_EXCEPTION_NOT_HANDLED;

    // We special case breakpoints.
    if (pEvent->m_dwCode == EXCEPTION_BREAKPOINT)
    {
        if (!m_fInitialBreakpoint)
        {
            Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "Entrypoint reached. All implicit modules have been loaded.\n");
            m_fInitialBreakpoint = true;
            return DBG_CONTINUE;
        }

        dwContinue = DBG_CONTINUE;
    }

    // If the user has decided not to show 1st chance exceptions and this is
    // a first chance exception, then bail now.
    if (!(m_dwProfileFlags & PF_LOG_EXCEPTIONS) && pEvent->m_fFirstChance)
    {
        return dwContinue;
    }

    // There are times when our injection code needs to perform an action that
    // might cause a handled exception. We hide those exceptions from the log
    // since we don't want the user to think their application is causing an
    // exception.
    if ((pEvent->m_dwCode == EXCEPTION_ACCESS_VIOLATION) && pEvent->m_fFirstChance &&
        (pEvent->m_dwpAddress >= m_dwpDWInjectBase) &&
        (pEvent->m_dwpAddress < (m_dwpDWInjectBase + (DWORD_PTR)m_dwDWInjectSize)))
    {
        return DBG_EXCEPTION_NOT_HANDLED;
    }

    // Attempt to get a text string for this exception value.
    LPCSTR pszException = "Unknown";
    switch (pEvent->m_dwCode)
    {
        // Common exceptions
        case EXCEPTION_ACCESS_VIOLATION:         pszException = "Access Violation";              break; // STATUS_ACCESS_VIOLATION        
        case EXCEPTION_DATATYPE_MISALIGNMENT:    pszException = "Datatype Misalignment";         break; // STATUS_DATATYPE_MISALIGNMENT   
        case EXCEPTION_BREAKPOINT:               pszException = "Breakpoint";                    break; // STATUS_BREAKPOINT              
        case EXCEPTION_SINGLE_STEP:              pszException = "Single Step";                   break; // STATUS_SINGLE_STEP             
        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:    pszException = "Array Bounds Exceeded";         break; // STATUS_ARRAY_BOUNDS_EXCEEDED   
        case EXCEPTION_FLT_DENORMAL_OPERAND:     pszException = "Float Denormal Operand";        break; // STATUS_FLOAT_DENORMAL_OPERAND  
        case EXCEPTION_FLT_DIVIDE_BY_ZERO:       pszException = "Float Divide by Zero";          break; // STATUS_FLOAT_DIVIDE_BY_ZERO    
        case EXCEPTION_FLT_INEXACT_RESULT:       pszException = "Float Inexact Result";          break; // STATUS_FLOAT_INEXACT_RESULT    
        case EXCEPTION_FLT_INVALID_OPERATION:    pszException = "Float Invalid Operation";       break; // STATUS_FLOAT_INVALID_OPERATION 
        case EXCEPTION_FLT_OVERFLOW:             pszException = "Float Overflow";                break; // STATUS_FLOAT_OVERFLOW          
        case EXCEPTION_FLT_STACK_CHECK:          pszException = "Float Stack Check";             break; // STATUS_FLOAT_STACK_CHECK       
        case EXCEPTION_FLT_UNDERFLOW:            pszException = "Float Underflow";               break; // STATUS_FLOAT_UNDERFLOW         
        case EXCEPTION_INT_DIVIDE_BY_ZERO:       pszException = "Integer Divide by Zero";        break; // STATUS_INTEGER_DIVIDE_BY_ZERO  
        case EXCEPTION_INT_OVERFLOW:             pszException = "Integer Overflow";              break; // STATUS_INTEGER_OVERFLOW        
        case EXCEPTION_PRIV_INSTRUCTION:         pszException = "Privileged Instruction";        break; // STATUS_PRIVILEGED_INSTRUCTION  
        case EXCEPTION_IN_PAGE_ERROR:            pszException = "In Page Error";                 break; // STATUS_IN_PAGE_ERROR           
        case EXCEPTION_ILLEGAL_INSTRUCTION:      pszException = "Illegal Instruction";           break; // STATUS_ILLEGAL_INSTRUCTION     
        case EXCEPTION_NONCONTINUABLE_EXCEPTION: pszException = "Noncontinuable Exception";      break; // STATUS_NONCONTINUABLE_EXCEPTION
        case EXCEPTION_STACK_OVERFLOW:           pszException = "Stack Overflow";                break; // STATUS_STACK_OVERFLOW          
        case EXCEPTION_INVALID_DISPOSITION:      pszException = "Invalid Disposition";           break; // STATUS_INVALID_DISPOSITION     
        case EXCEPTION_GUARD_PAGE:               pszException = "Guard Page";                    break; // STATUS_GUARD_PAGE_VIOLATION    
        case EXCEPTION_INVALID_HANDLE:           pszException = "Invalid Handle";                break; // STATUS_INVALID_HANDLE          
        case DBG_CONTROL_C:                      pszException = "Control-C";                     break;
        case DBG_CONTROL_BREAK:                  pszException = "Control-Break";                 break;
        case STATUS_NO_MEMORY:                   pszException = "No Memory";                     break;



        // Not really sure what these are.
        case DBG_CONTINUE:                       pszException = "Debug Continue";                break;
        case STATUS_SEGMENT_NOTIFICATION:        pszException = "Segment Notification";          break;
        case DBG_TERMINATE_THREAD:               pszException = "Debug Terminate Thread";        break;
        case DBG_TERMINATE_PROCESS:              pszException = "Debug Terminate Process";       break;
        case DBG_EXCEPTION_NOT_HANDLED:          pszException = "Debug Exception Not Handled";   break;
        case STATUS_CONTROL_C_EXIT:              pszException = "Control-C Exit";                break;
        case STATUS_FLOAT_MULTIPLE_FAULTS:       pszException = "Float Multiple Faults";         break;
        case STATUS_FLOAT_MULTIPLE_TRAPS:        pszException = "Float Multiple Traps";          break;
        case STATUS_REG_NAT_CONSUMPTION:         pszException = "Reg Nat Consumption";           break;
        case STATUS_SXS_EARLY_DEACTIVATION:      pszException = "SxS Early Deactivation";        break;
        case STATUS_SXS_INVALID_DEACTIVATION:    pszException = "SxS Invalid Deactivation";      break;

        // Custon exceptions.
        case EXCEPTION_DLL_NOT_FOUND:
        case EXCEPTION_DLL_NOT_FOUND2:           pszException = "DLL Not Found";                 break;
        case EXCEPTION_DLL_INIT_FAILED:          pszException = "DLL Initialization Failed";     break;
        case EXCEPTION_MS_CPP_EXCEPTION:         pszException = "Microsoft C++ Exception";       break;
        case EXCEPTION_MS_DELAYLOAD_MOD:         pszException = "Delay-load Module Not Found";   break;
        case EXCEPTION_MS_DELAYLOAD_PROC:        pszException = "Delay-load Function Not Found"; break;
        case EXCEPTION_MS_THREAD_NAME:           pszException = "Thread was named";              break;
    }

    if (pEvent->m_pModule)
    {
        Log((pEvent->m_fFirstChance ? 0 : LOG_ERROR) | LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "%s chance exception 0x%08X (%s) occurred in \"%s\" at address " HEX_FORMAT "%s.\n",
            pEvent->m_fFirstChance ? "First" : "Second", pEvent->m_dwCode, pszException,
            GET_NAME(pEvent->m_pModule), pEvent->m_dwpAddress, ThreadString(pEvent->m_pThread));
    }
    else
    {
        Log((pEvent->m_fFirstChance ? 0 : LOG_ERROR) | LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "%s chance exception 0x%08X (%s) occurred at address " HEX_FORMAT "%s.\n",
            pEvent->m_fFirstChance ? "First" : "Second", pEvent->m_dwCode, pszException,
            pEvent->m_dwpAddress, ThreadString(pEvent->m_pThread));
    }

    return dwContinue;
}

//******************************************************************************
DWORD CSession::EventRip(CEventRip *pEvent)
{
/*
   DWORD dwError;
   DWORD dwType;
*/
    LPCSTR pszType = "Unknown RIP";
    switch (pEvent->m_dwType)
    {
        case SLE_ERROR:      pszType = "RIP error";       break;
        case SLE_MINORERROR: pszType = "Minor RIP error"; break;
        case SLE_WARNING:    pszType = "RIP warning";     break;
        case 0:              pszType = "RIP";             break;
    }

    Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
        "%s %u occurred%s.\n", pszType, pEvent->m_dwError, ThreadString(pEvent->m_pThread));

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventDllMainCall(CEventDllMainCall *pEvent)
{
    // Build "reason" string.
    CHAR szReason[32];
    switch (pEvent->m_dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS))
            {
                return DBG_CONTINUE;
            }
            StrCCpy(szReason, "DLL_PROCESS_ATTACH", sizeof(szReason));
            break;

        case DLL_PROCESS_DETACH:
            if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS))
            {
                return DBG_CONTINUE;
            }
            StrCCpy(szReason, "DLL_PROCESS_DETACH", sizeof(szReason));
            break;

        case DLL_THREAD_ATTACH:
            if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
            {
                return DBG_CONTINUE;
            }
            StrCCpy(szReason, "DLL_THREAD_ATTACH", sizeof(szReason));
            break;

        case DLL_THREAD_DETACH:
            if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
            {
                return DBG_CONTINUE;
            }
            StrCCpy(szReason, "DLL_THREAD_DETACH", sizeof(szReason));
            break;

        default:
            if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
            {
                return DBG_CONTINUE;
            }
            SCPrintf(szReason, sizeof(szReason), "%u", pEvent->m_dwReason);
            break;
    }

    Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
        "DllMain(" HEX_FORMAT ", %s, " HEX_FORMAT ") in \"%s\" called%s.\n",
        pEvent->m_hInstance, szReason, pEvent->m_lpvReserved, GET_NAME(pEvent->m_pModule),
        ThreadString(pEvent->m_pThread));

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventDllMainReturn(CEventDllMainReturn *pEvent)
{
    if (pEvent->m_pEventDllMainCall)
    {
        // Build "reason" string.
        DWORD dwLog = 0;
        CHAR  szReason[32];
        switch (pEvent->m_pEventDllMainCall->m_dwReason)
        {
            case DLL_PROCESS_ATTACH:
                // We log DllMain(DLL_PROCESS_ATTACH) failures since they are fatal,
                // even if the user doesn't want to see DllMain calls.
                if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS) && pEvent->m_fResult)
                {
                    return DBG_CONTINUE;
                }
                StrCCpy(szReason, "DLL_PROCESS_ATTACH", sizeof(szReason));
                if (!pEvent->m_fResult)
                {
                    dwLog = LOG_ERROR;

                    // Make note that a module failed to load.
                    m_dwReturnFlags |= DWRF_MODULE_LOAD_FAILURE;

                    // If we can find this module in our list, then flag the orignal
                    // instance of it as having an error so it will show up as red
                    // in our list control.  We would also like to flag the module
                    // in our tree control, but don't really know which instance to
                    // flag.  If this module failed to load during a LoadLibrary call
                    // and we are hooking LoadLibrary calls, then we will catch the
                    // error during the LoadLibrary return handler as well, which
                    // will flag the correct tree module in red.  We can check to
                    // see if we are in the middle of a LoadLibrary call by checking
                    // this event's thread's function stack.  If we are not in a
                    // load library call, then this is out only chance to mark
                    // the module as red in the tree, so we just look for the
                    // original instance and flag it.

                    CModule *pModule;
                    if (pEvent->m_pModule &&
                        (pModule = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_PATH,
                                              (DWORD_PTR)pEvent->m_pModule->GetName(true))))
                    {
                        FlagModuleWithError(pModule, pEvent->m_pThread && pEvent->m_pThread->m_pEventFunctionCallHead);
                    }
                }
                break;

            case DLL_PROCESS_DETACH:
                if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_PROCESS_MSGS))
                {
                    return DBG_CONTINUE;
                }
                StrCCpy(szReason, "DLL_PROCESS_DETACH", sizeof(szReason));
                break;

            case DLL_THREAD_ATTACH:
                if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
                {
                    return DBG_CONTINUE;
                }
                StrCCpy(szReason, "DLL_THREAD_ATTACH", sizeof(szReason));
                break;

            case DLL_THREAD_DETACH:
                if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
                {
                    return DBG_CONTINUE;
                }
                StrCCpy(szReason, "DLL_THREAD_DETACH", sizeof(szReason));
                break;

            default:
                if (!(m_dwProfileFlags & PF_LOG_DLLMAIN_OTHER_MSGS))
                {
                    return DBG_CONTINUE;
                }
                SCPrintf(szReason, sizeof(szReason), "%u", pEvent->m_pEventDllMainCall->m_dwReason);
                break;
        }

        Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "DllMain(" HEX_FORMAT ", %s, " HEX_FORMAT ") in \"%s\" returned %u (0x%X)%s.\n",
            pEvent->m_pEventDllMainCall->m_hInstance,
            szReason, pEvent->m_pEventDllMainCall->m_lpvReserved,
            GET_NAME(pEvent->m_pModule), pEvent->m_fResult, pEvent->m_fResult,
            ThreadString(pEvent->m_pThread));
    }
    else
    {
        // We really should never make it here.
        Log((pEvent->m_fResult ? 0 : LOG_ERROR) | LOG_TIME_STAMP, pEvent->m_dwTickCount,
            "DllMain in \"%s\" returned %u%s.\n", GET_NAME(pEvent->m_pModule),
            pEvent->m_fResult, ThreadString(pEvent->m_pThread));
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventLoadLibraryCall(CEventLoadLibraryCall *pEvent)
{
    // Only do the this output if the user has requested to see it.
    if (m_dwProfileFlags & PF_LOG_LOADLIBRARY_CALLS)
    {
        CHAR szBuffer[DW_MAX_PATH + 128];

        if (pEvent->m_pModule)
        {
            Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "%s called from \"%s\" at address " HEX_FORMAT "%s.\n",
                BuildLoadLibraryString(szBuffer, sizeof(szBuffer), pEvent),
                GET_NAME(pEvent->m_pModule), pEvent->m_dwpAddress, ThreadString(pEvent->m_pThread));
        }
        else
        {
            Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "%s called from address " HEX_FORMAT "%s.\n",
                BuildLoadLibraryString(szBuffer, sizeof(szBuffer), pEvent),
                pEvent->m_dwpAddress, ThreadString(pEvent->m_pThread));

        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventLoadLibraryReturn(CEventFunctionReturn *pEvent)
{
    // Only do the this output if the user has requested to see it.
    if (m_dwProfileFlags & PF_LOG_LOADLIBRARY_CALLS)
    {
        CHAR szBuffer[DW_MAX_PATH + 128];

        // Get a pointer to our CEventLoadLibraryCall object.
        CEventLoadLibraryCall *pCall = (CEventLoadLibraryCall*)pEvent->m_pCall;

        if (pEvent->m_fException)
        {
            Log(LOG_ERROR | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "%s caused an exception%s.\n", BuildLoadLibraryString(szBuffer, sizeof(szBuffer), pCall),
                ThreadString(pEvent->m_pThread));
        }
        else if (pEvent->m_dwpResult)
        {
            Log(LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "%s returned " HEX_FORMAT "%s.\n", BuildLoadLibraryString(szBuffer, sizeof(szBuffer), pCall),
                pEvent->m_dwpResult, ThreadString(pEvent->m_pThread));
        }
        else
        {
            LPCSTR pszError = BuildErrorMessage(pEvent->m_dwError, NULL);
            Log(LOG_ERROR | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                "%s returned NULL%s. Error: %s\n", BuildLoadLibraryString(szBuffer, sizeof(szBuffer), pCall),
                ThreadString(pEvent->m_pThread), pszError);
            MemFree((LPVOID&)pszError);
        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventGetProcAddressCall(CEventGetProcAddressCall *pEvent)
{
    // Do nothing. We currently only log the completion of a GetProcAddress call
    // since nothing very exciting usually happens inside the call to make it
    // worth logging two separate lines for a single call:
    //
    //    GetProcAddress() called...
    //    GetProcAddress() returned...
    //
    // There is the chance that the user will GetProcAddress a function that
    // is forwarded to a module that is not currently loaded.  In this one case,
    // the modules needed to make the function work will be loaded while inside
    // the call to GetProcAddress.  I don't think this one rare case justifies
    // wasting two lines of log for every single GetProcAddress call, but if
    // I change my mind, this is the place to log the first of the two lines of log.

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventGetProcAddressReturn(CEventFunctionReturn *pEvent)
{
/*
    DWORD  m_dwAddress;
    DWORD  m_dwModule;
    DWORD  m_dwProcName;
    DWORD  m_dwResult;
    DWORD  m_dwError;
    LPCSTR m_pszProcName;
    BOOL   m_fAllocatedBuffer;
*/
    // Only do the this output if the user has requested to see it.
    if (m_dwProfileFlags & PF_LOG_GETPROCADDRESS_CALLS)
    {
        // Get a pointer to our CEventGetProcAddressCall object.
        CEventGetProcAddressCall *pCall = (CEventGetProcAddressCall*)pEvent->m_pCall;

        // Build the result string.
        DWORD dwLog = 0;
        CHAR  szResult[2048];
        if (pEvent->m_fException)
        {
            SCPrintf(szResult, sizeof(szResult), " at address " HEX_FORMAT " and caused an exception%s.",
                    pEvent->m_pCall->m_dwpAddress, ThreadString(pEvent->m_pThread));
            dwLog = LOG_ERROR;
        }
        else if (pEvent->m_dwpResult)
        {
            SCPrintf(szResult, sizeof(szResult), " at address " HEX_FORMAT " and returned " HEX_FORMAT "%s.",
                    pEvent->m_pCall->m_dwpAddress, pEvent->m_dwpResult,
                    ThreadString(pEvent->m_pThread));
        }
        else
        {
            LPCSTR pszError = BuildErrorMessage(pEvent->m_dwError, NULL);
            SCPrintf(szResult, sizeof(szResult), " at address " HEX_FORMAT " and returned NULL%s. Error: %s",
                    pEvent->m_pCall->m_dwpAddress, ThreadString(pEvent->m_pThread), pszError);
            MemFree((LPVOID&)pszError);
            dwLog = LOG_ERROR;
        }

        if (pEvent->m_pModule)
        {
            if (pCall->m_pModuleArg)
            {
                // If we have a function name, then log the call using it.
                if (pCall->m_pszProcName)
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT " [%s], \"%s\") called from \"%s\"%s\n",
                        pCall->m_dwpModule, GET_NAME(pCall->m_pModuleArg), pCall->m_pszProcName,
                        GET_NAME(pCall->m_pModule), szResult);
                }

                // Otherwise, just use the hex value for the function name.
                else
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT " [%s], " HEX_FORMAT ") called from \"%s\"%s\n",
                        pCall->m_dwpModule, GET_NAME(pCall->m_pModuleArg), pCall->m_dwpProcName,
                        GET_NAME(pCall->m_pModule), szResult);
                }
            }
            else
            {
                // If we have a function name, then log the call using it.
                if (pCall->m_pszProcName)
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT ", \"%s\") called from \"%s\"%s\n",
                        pCall->m_dwpModule, pCall->m_pszProcName, GET_NAME(pCall->m_pModule),
                        szResult);
                }

                // Otherwise, just use the hex value for the function name.
                else
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT ", " HEX_FORMAT ") called from \"%s\"%s\n",
                        pCall->m_dwpModule, pCall->m_dwpProcName, GET_NAME(pCall->m_pModule),
                        szResult);
                }
            }
        }
        else
        {
            if (pCall->m_pModuleArg)
            {
                // If we have a function name, then log the call using it.
                if (pCall->m_pszProcName)
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT " [%s], \"%s\") called%s\n",
                        pCall->m_dwpModule, GET_NAME(pCall->m_pModuleArg), pCall->m_pszProcName,
                        szResult);
                }

                // Otherwise, just use the hex value for the function name.
                else
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT " [%s], " HEX_FORMAT ") called%s\n",
                        pCall->m_dwpModule, GET_NAME(pCall->m_pModuleArg), pCall->m_dwpProcName,
                        szResult);
                }
            }
            else
            {
                // If we have a function name, then log the call using it.
                if (pCall->m_pszProcName)
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT ", \"%s\") called%s\n",
                        pCall->m_dwpModule, pCall->m_pszProcName, szResult);
                }

                // Otherwise, just use the hex value for the function name.
                else
                {
                    Log(dwLog | LOG_TIME_STAMP, pEvent->m_dwTickCount,
                        "GetProcAddress(" HEX_FORMAT ", " HEX_FORMAT ") called%s\n",
                        pCall->m_dwpModule, pCall->m_dwpProcName, szResult);
                }
            }
        }
    }

    return DBG_CONTINUE;
}

//******************************************************************************
DWORD CSession::EventMessage(CEventMessage *pEvent)
{
    if (pEvent->m_dwError)
    {
        LPCSTR pszError = BuildErrorMessage(pEvent->m_dwError, pEvent->m_pszMessage);
        Log(LOG_ERROR | LOG_TIME_STAMP, pEvent->m_dwTickCount, "%s\n", pszError);
        MemFree((LPVOID&)pszError);
    }
    else
    {
        Log(LOG_ERROR | LOG_TIME_STAMP, pEvent->m_dwTickCount, "%s\n", pEvent->m_pszMessage);
    }

    return DBG_CONTINUE;
}

//******************************************************************************
LPSTR CSession::BuildLoadLibraryString(LPSTR pszBuf, int cBuf, CEventLoadLibraryCall *pLLC)
{
    // Check to see if this function is one of two flavors of LoadLibrary()
    if ((pLLC->m_dllMsg == DLLMSG_LOADLIBRARYA_CALL) ||
        (pLLC->m_dllMsg == DLLMSG_LOADLIBRARYW_CALL))
    {
        // If we have a name, then log the call using it.
        if (pLLC->m_pszPath)
        {
            SCPrintf(pszBuf, cBuf, "LoadLibrary%c(\"%s\")",
                    (pLLC->m_dllMsg == DLLMSG_LOADLIBRARYA_CALL) ? 'A' : 'W', pLLC->m_pszPath);
        }

        // Otherwise, just use the hex value for the name.
        else
        {
            SCPrintf(pszBuf, cBuf, "LoadLibrary%c(" HEX_FORMAT ")",
                    (pLLC->m_dllMsg == DLLMSG_LOADLIBRARYA_CALL) ? 'A' : 'W', pLLC->m_dwpPath);
        }
    }

    // Otherwise, it must be one of two flavors of LoadLibraryEx()
    else
    {
        // Build a string based off of the LoadLibraryEx() flags.
        DWORD dwFlags = pLLC->m_dwFlags;
        CHAR  szFlags[128];
        *szFlags = '\0';

        // Check for the DONT_RESOLVE_DLL_REFERENCES flag.
        if (dwFlags & DONT_RESOLVE_DLL_REFERENCES)
        {
            dwFlags &= ~DONT_RESOLVE_DLL_REFERENCES;
            StrCCpy(szFlags, "DONT_RESOLVE_DLL_REFERENCES", sizeof(szFlags));
        }

        // Check for the LOAD_LIBRARY_AS_DATAFILE flag.
        if (dwFlags & LOAD_LIBRARY_AS_DATAFILE)
        {
            dwFlags &= ~LOAD_LIBRARY_AS_DATAFILE;
            if (*szFlags)
            {
                StrCCat(szFlags, " | ", sizeof(szFlags));
            }
            StrCCat(szFlags, "LOAD_LIBRARY_AS_DATAFILE", sizeof(szFlags));
        }

        // Check for the LOAD_WITH_ALTERED_SEARCH_PATH flag.
        if (dwFlags & LOAD_WITH_ALTERED_SEARCH_PATH)
        {
            dwFlags &= ~LOAD_WITH_ALTERED_SEARCH_PATH;
            if (*szFlags)
            {
                StrCCat(szFlags, " | ", sizeof(szFlags));
            }
            StrCCat(szFlags, "LOAD_WITH_ALTERED_SEARCH_PATH", sizeof(szFlags));
        }

        // If no flags were found or we have some bits left over, then append the bits.
        if (!*szFlags || dwFlags)
        {
            if (*szFlags)
            {
                StrCCat(szFlags, " | ", sizeof(szFlags));
            }
            SCPrintfCat(szFlags, sizeof(szFlags), "0x%08X", dwFlags);
        }

        // If we have a name, then log the call using it.
        if (pLLC->m_pszPath)
        {
            SCPrintf(pszBuf, cBuf, "LoadLibraryEx%c(\"%s\", " HEX_FORMAT ", %s)",
                    (pLLC->m_dllMsg == DLLMSG_LOADLIBRARYEXA_CALL) ? 'A' : 'W',
                    pLLC->m_pszPath, pLLC->m_dwpFile, szFlags);
        }

        // Otherwise, just use the hex value for the name.
        else
        {
            SCPrintf(pszBuf, cBuf, "LoadLibraryEx%c(" HEX_FORMAT ", " HEX_FORMAT ", %s)",
                    (pLLC->m_dllMsg == DLLMSG_LOADLIBRARYEXA_CALL) ? 'A' : 'W',
                    pLLC->m_dwpPath, pLLC->m_dwpFile, szFlags);
        }
    }

    return pszBuf;
}

//******************************************************************************
void CSession::FlagModuleWithError(CModule *pModule, bool fOnlyFlagListModule /*=false*/)
{
    if (!fOnlyFlagListModule && !(pModule->m_dwFlags & DWMF_MODULE_ERROR))
    {
        pModule->m_dwFlags       |= DWMF_MODULE_ERROR;
        pModule->m_dwUpdateFlags |= DWUF_TREE_IMAGE;
    }
    if (!(pModule->m_pData->m_dwFlags & DWMF_MODULE_ERROR_ALO))
    {
        pModule->m_pData->m_dwFlags |= DWMF_MODULE_ERROR_ALO;
        pModule->m_dwUpdateFlags    |= DWUF_LIST_IMAGE;
    }

    // Tell our UI to update this module if needed.
    if (m_pfnProfileUpdate && pModule->m_dwUpdateFlags)
    {
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_UPDATE_MODULE, (DWORD_PTR)pModule, 0);
        pModule->m_dwUpdateFlags = 0;
    }
}

//******************************************************************************
void CSession::ProcessLoadLibrary(CEventLoadLibraryCall *pCall)
{
    // Attempt to locate the module that made the call.
    CModule *pParent = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_LOADED | FMF_ADDRESS,
                                  (DWORD_PTR)pCall->m_dwpAddress);

    // LOAD_LIBRARY_AS_DATAFILE implies DONT_RESOLVE_DLL_REFERENCES
    bool fNoResolve = (pCall->m_dwFlags & (DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE)) ? true : false;
    bool fDataFile  = (pCall->m_dwFlags & LOAD_LIBRARY_AS_DATAFILE) ? true : false;

    bool fModifiedPath = false;

    // If the file is a data file, there is a good chance it won't have a path.
    // This is because we don't get a real LOAD_DLL_DEBUG_EVENT event, so we
    // only have the string passed to LoadLibraryEx to go off of.
    CModule *pModule = NULL;
    if (fDataFile && pCall->m_pszPath && !strchr(pCall->m_pszPath, '\\'))
    {
        // First, look to see if we have any loaded modules with this name.
        pModule = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_LOADED | FMF_FILE, (DWORD_PTR)pCall->m_pszPath);
        if (pModule)
        {
            MemFree((LPVOID&)pCall->m_pszPath);
            pCall->m_pszPath = StrAlloc(pModule->GetName(true));
            fModifiedPath = true;
        }

        // If that fails, then search for this module in our search path.
        else
        {
            CHAR szPath[DW_MAX_PATH] = "", *pszFile = NULL;
            if (SearchPathForFile(pCall->m_pszPath, szPath, sizeof(szPath), &pszFile))
            {
                MemFree((LPVOID&)pCall->m_pszPath);
                pCall->m_pszPath = StrAlloc(szPath);
                fModifiedPath = true;
            }
        }
    }

    CEventLoadDll *pDll;

    // Store the LoadLibrary result value.
    DWORD_PTR dwpLoadLibraryResult = pCall->m_pReturn ? pCall->m_pReturn->m_dwpResult : 0;
    bool fFailed = (dwpLoadLibraryResult == 0);

    // Check to see if LoadLibrary failed but we still loaded at least one module.
    if (!dwpLoadLibraryResult && pCall->m_pDllHead)
    {
        // It is possible for LoadLibrary to fail, but still load modules - such as in the case
        // where a module fails to init.  If we failed, we compare the file string of all the modules
        // loaded against the file string passed to LoadLibrary to see if we can find a match.
        // If we find a match, then we assume that this module is the one that LoadLibrary intended to load.
        LPCSTR pszFile = GetFileNameFromPath(pCall->m_pszPath);
        if (pszFile)
        {
            for (pDll = pCall->m_pDllHead; pDll; pDll = pDll->m_pNextDllInFunctionCall)
            {
                if (pDll->m_pModule && pDll->m_pModule->GetName(false) && !_stricmp(pszFile, pDll->m_pModule->GetName(false)))
                {
                    dwpLoadLibraryResult = pDll->m_pModule->m_dwpImageBase;
                    break;
                }
            }
        }
    }

    // This is sort of a hack.  We're about to add a module that was loaded via
    // a LoadLibrary call.  That in turn, will cause us to search for all its
    // dependent modules.  We want the search algorithm to first check the list
    // of pending DLLs that loaded as a result of the LoadLibrary call before
    // searching the default search path.  There is one case in particular that
    // this is useful for.  When LoadLibrary is called with a full path, the OS
    // includes the that path as part of the search algorithm, even if it is not
    // the current directory or program directory.  Since our search algorithm
    // does not know to look in this directory, it would think the file was missing,
    // then later when we are adding the modules in pCall->m_pDllHead list, it
    // will get added to the root.  This hack fixes this case and possibly other
    // cases where a module get's loaded from a place we did not anticipate.
    //
    // NOTE: Do not return from this function without NULLing this pointer.
    //
    m_pEventLoadDllPending = pCall->m_pDllHead;

    // Check to see if LoadLibrary succeeded, or at least found the module it was supposed to load.
    pModule = NULL;
    if (dwpLoadLibraryResult)
    {
        // First, locate the module that the user passed to the call to LoadLibrary.
        // Since the return value from LoadLibrary is really the base address of the
        // module that loaded, we can determine which module it is by comparing the
        // result to each of the loaded module's base addresses.  Once we found the
        // module, we add it as a child module under the caller module, and then
        // change our parent pointer to point to the new module.
        for (pDll = pCall->m_pDllHead; pDll; pDll = pDll->m_pNextDllInFunctionCall)
        {
            if (pDll->m_pModule && (pDll->m_pModule->m_dwpImageBase == dwpLoadLibraryResult))
            {
                if (fModifiedPath)
                {
                    pDll->m_pModule->SetPath(pCall->m_pszPath);
                }
                pModule = AddDynamicModule(pDll->m_pModule->GetName(true), pDll->m_pModule->m_dwpImageBase, fNoResolve, fDataFile, false, false, pParent);
                break;
            }
        }

        // If the module was not found, then it is probably already loaded and this
        // call to LoadLibrary just incremented the module's ref count. We should be
        // able to find this module in our tree somewhere.
        if (!pDll)
        {
            pModule = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_LOADED | FMF_ADDRESS,
                                 dwpLoadLibraryResult);
            if (pModule)
            {
                // Add this duplicate module as a dynamically loaded module under our parent module.
                pModule = AddDynamicModule(pModule->GetName(true), dwpLoadLibraryResult, fNoResolve, fDataFile, false, false, pParent);
            }
        }
    }

    // Otherwise, LoadLibrary failed
    else if (pCall->m_pszPath)
    {
        // Add this duplicate module as a dynamically loaded module under our parent module.
        pModule = AddDynamicModule(pCall->m_pszPath, 0, fNoResolve, fDataFile, false, false, pParent);
    }

    // If LoadLibrary failed, then flag this module as having an error.
    if (fFailed && pModule && !(pModule->m_pData->m_dwFlags & DWMF_ERROR_MESSAGE))
    {
        // Make note that a module failed to load.
        m_dwReturnFlags |= DWRF_MODULE_LOAD_FAILURE;
        
        // Flag the error.
        FlagModuleWithError(pModule);
    }

    // We now add all the other modules loaded as implicit modules under the
    // dynamic module since they were most likely loaded because they are
    // implicit dependencies of the dynamic module.
    for (pDll = pCall->m_pDllHead; pDll; pDll = pDll->m_pNextDllInFunctionCall)
    {
        if (pDll->m_pModule && (pDll->m_pModule->m_dwpImageBase != dwpLoadLibraryResult))
        {
            AddImplicitModule(pDll->m_pModule->GetName(true), pDll->m_pModule->m_dwpImageBase);
        }
    }

    // Make sure to clear m_pEventLoadDllPending.
    m_pEventLoadDllPending = NULL;
}

//******************************************************************************
void CSession::ProcessGetProcAddress(CEventGetProcAddressCall *pCall)
{
    CFunction *pImportLast = NULL, *pImport = NULL;
    CModule   *pModule = NULL, *pCaller = NULL, *pFound = NULL, *pModuleLast = NULL;
    DWORD_PTR  dwpGetProcAddressResult = 0;

    // If we don't have a module name that the function resides in, then we can't do much.
    if (!pCall->m_pModuleArg || !pCall->m_pModuleArg->GetName(true))
    {
        goto ADD_MODULES;
    }

    // Attempt to locate the module that is making the call.  If this fails, we
    // will just get NULL, which will cause us to us to place the module at the root.
    pCaller = FindModule(m_pModuleRoot, FMF_ORIGINAL | FMF_RECURSE | FMF_SIBLINGS | FMF_LOADED | FMF_ADDRESS,
                         (DWORD_PTR)pCall->m_dwpAddress);

    // Store the pending DLL list.  See ProcessLoadLibrary for a detailed comment.
    // NOTE: Do not return from this function without NULLing this pointer.
    m_pEventLoadDllPending = pCall->m_pDllHead;

    // Add the module to our tree - if it already exists, this function will return it to us.
    pModule = AddDynamicModule(pCall->m_pModuleArg->GetName(true), pCall->m_pModuleArg->m_dwpImageBase,
                               false, false, true, false, pCaller);

    if (!pModule)
    {
        goto ADD_MODULES;
    }

    // Get the start of this module's parent import list.
    pImport = pModule->m_pParentImports;

    // Store the GetProcAddress result value.
    dwpGetProcAddressResult = pCall->m_pReturn ? pCall->m_pReturn->m_dwpResult : 0;

    // Check to see if a non-ordinal value was passed to GetProcAddress.
    if (pCall->m_dwpProcName > 0xFFFF)
    {
        // Check to see if this is a valid string.
        if (pCall->m_pszProcName)
        {
            // Search our import list for a dynamic function with this name.
            for (; pImport; pImportLast = pImport, pImport = pImport->m_pNext)
            {
                // If we already have this function in the list, then bail.
                if ((pImport->GetFlags() & DWFF_NAME) && !strcmp(pImport->GetName(), pCall->m_pszProcName))
                {
                    goto ADD_MODULES;
                }
            }
        }

        // Otherwise, this function name is invalid.
        else
        {
            // Search our import list for a dynamic function that is invalid.
            for (; pImport; pImportLast = pImport, pImport = pImport->m_pNext)
            {
                // If we already have an invalid function in the list, then bail.
                if (!(pImport->GetFlags() & (DWFF_NAME | DWFF_ORDINAL)))
                {
                    goto ADD_MODULES;
                }
            }
        }

        // Create the by-name function (even if the function name is NULL).
        pImport = CreateFunction(DWFF_DYNAMIC | (dwpGetProcAddressResult ? DWFF_ADDRESS : 0),
                                 0, 0, pCall->m_pszProcName, (DWORDLONG)dwpGetProcAddressResult);
    }

    // Otherwise, search the import list by ordinal.
    else
    {
        for (; pImport; pImportLast = pImport, pImport = pImport->m_pNext)
        {
            // If we already have this function in the list, then bail.
            if ((pImport->GetFlags() & DWFF_ORDINAL) && ((DWORD_PTR)pImport->m_wOrdinal == pCall->m_dwpProcName))
            {
                goto ADD_MODULES;
            }
        }

        // Create the by-ordinal function.
        pImport = CreateFunction(DWFF_ORDINAL | DWFF_DYNAMIC | (dwpGetProcAddressResult ? DWFF_ADDRESS : 0),
                                 (WORD)pCall->m_dwpProcName, 0, NULL, (DWORDLONG)dwpGetProcAddressResult);
    }

    // Add the function to the end of our list.
    if (pImportLast)
    {
        pImportLast->m_pNext = pImport;
    }
    else
    {
        pModule->m_pParentImports = pImport;
    }

    // Resolve the import.  This usually is just a simple export lookup and
    // and compare for a match.  However, if this function is forwarded to
    // another module, then ResolveDynamicFunction might starts adding modules
    // and more imports to our tree structure.  If that happens, it updates
    // the pModule and pImport variables (they are passed by reference).
    // So, we might get back different pointers then we passed in.
    pModuleLast = pModule;
    ResolveDynamicFunction(pModuleLast, pImport);

    // If GetProcAddress failed and we have not yet marked this module as having an export error,
    // then do so now.
    if ((!dwpGetProcAddressResult || !pImport || !pImport->GetAssociatedExport()) && pModuleLast)
    {
        // Make note that we are missing a dynamic export.
        m_dwReturnFlags |= DWRF_MISSING_DYNAMIC_EXPORT;

        // Flag the export error.
        FlagModuleWithError(pModuleLast);
    }

ADD_MODULES:

    // Loop through all the modules in our pending module list and make sure they are in our tree.
    for (CEventLoadDll *pDll = pCall->m_pDllHead; pDll; pDll = pDll->m_pNextDllInFunctionCall)
    {
        if (pFound = FindModule(pModule, FMF_RECURSE | FMF_PATH, (DWORD_PTR)pDll->m_pModule->GetName(true)))
        {
            MarkModuleAsLoaded(pFound, pDll->m_pModule->m_dwpImageBase, false);
        }
        else
        {
            AddImplicitModule(pDll->m_pModule->GetName(true), pDll->m_pModule->m_dwpImageBase);
        }
    }

    // Make sure to clear m_pEventLoadDllPending.
    m_pEventLoadDllPending = NULL;
}

//******************************************************************************
void CSession::Log(DWORD dwFlags, DWORD dwTickCount, LPCSTR pszFormat, ...)
{
    if (m_pfnProfileUpdate)
    {
        // Do some printf magic on all the args to make a single output string.
        char szBuffer[2 * DW_MAX_PATH];
        va_list pArgs;
        va_start(pArgs, pszFormat);
        _vsntprintf(szBuffer, sizeof(szBuffer), pszFormat, pArgs);
        szBuffer[sizeof(szBuffer) - 1] = '\0';
        va_end(pArgs);

        // Send the string to our document.
        DWPU_LOG_STRUCT dwpuls = { dwFlags, m_pProcess ? (dwTickCount - m_pProcess->GetStartingTime()) : 0 };
        m_pfnProfileUpdate(m_dwpProfileUpdateCookie, DWPU_LOG, (DWORD_PTR)szBuffer, (DWORD_PTR)&dwpuls);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\exe\stdafx.h ===
//******************************************************************************
//
// File:        STDAFX.H
//
// Description: Include file for standard system include files, or project
//              specific include files that are used frequently, but are
//              changed infrequently.  This file is included by STDAFX.CPP to
//              create the precompiled header file DEPENDS.PCH.
//
// Classes:     None
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 10/15/96  stevemil  Created  (version 1.0)
// 07/25/97  stevemil  Modified (version 2.0)
// 06/03/01  stevemil  Modified (version 2.1)
//
//******************************************************************************

#ifndef __STDAFX_H__
#define __STDAFX_H__

#if _MSC_VER > 1000
#pragma once
#endif

// Setting _WIN32_WINNT >= 0x0500 crashes our open dialog. This flag controls
// the size of OPENFILENAME, but since MFC 4.2 (VC 6.0) was built without this
// flag set, the OPENFILENAME structure has the older size (76).  So, when we
// set this flag and include the AFXDLGS.H, we think the classes have a larger
// structure than they really do.
//#if (_WIN32_WINNT < 0x0500)
//#undef _WIN32_WINNT
//#define _WIN32_WINNT 0x0500
//#endif

// Disable level 4 warning C4100: unreferenced formal parameter (harmless warning)
#pragma warning (disable : 4100 )

// Disable level 4 warning C4706: assignment within conditional expression
#pragma warning (disable : 4706 )

#include <afxwin.h>     // MFC core and standard components
#include <afxext.h>     // MFC extensions
#include <afxcview.h>   // CListView and CTreeView
#include <afxcmn.h>     // MFC support for Windows Common Controls
#include <afxpriv.h>    // WM_HELPHITTEST and WM_COMMANDHELP
#include <afxrich.h>    // CRichEditView
#include <shlobj.h>     // SHBrowseForFolder() stuff.
#include <imagehlp.h>   // Image Help is used to undecorate C++ functions
#include <dlgs.h>       // Control IDs for common dialogs
#include <cderr.h>      // CDERR_STRUCTSIZE

#include <htmlhelp.h>   // Needed for MSDN 1.x
#include "vshelp.h"     // Needed for MSDN 2.x

// VC 6.0 and the current (2437) platform SDK have old versions of DELAYIMP.H.
// Once they update it to include version 2.0 of the delay load implementation,
// we can start incluidng it.  Until then, there are two versions of DELAYIMP.H
// that do support version 2.0.  One comes from some internal place in the NT
// build tree (can be found on http://index2), and the other is part of the
// prerelease headers of the platform SDK.  They both are basically the same,
// so we use the one from the SDK. 
//#include <delayimp.h>
#define DELAYLOAD_VERSION 0x200 // This is really only needed when we include a private version of delayimp.h
#include "..\ntinc\dload.h"     // Delay-load macros and structures from prerelease SDK.

#include "..\ntinc\actctx.h" // Side-by-Side stuff taken from the prerelease SDK's WINBASE.H

#include "..\ntinc\ntdll.h"  // NTDLL.DLL defines taken from various DDK headers.

#include "depends.rc2"  // Version strings and defines
#include "resource.h"   // Resource symbols

// MFC 6.0 did not handle the new open/save dialog format, so we had to roll our own.
// MFC 7.0 fixes this.
#if (_MFC_VER < 0x0700)
#define USE_CNewFileDialog
#endif


//******************************************************************************
//***** Global defines
//******************************************************************************

// We trace to a file on 64-bit debug platforms.
#if defined(_DEBUG) && (defined(_IA64_) || defined(_ALPHA64_))
#define USE_TRACE_TO_FILE
#endif

#ifdef USE_TRACE_TO_FILE
#ifdef TRACE
#undef TRACE
#endif
#define TRACE TRACE_TO_FILE
void TRACE_TO_FILE(LPCTSTR pszFormat, ...);
#endif

#define countof(a)            (sizeof(a)/sizeof(*(a)))

#define SIZE_OF_NT_SIGNATURE  sizeof(DWORD)

#define GetFilePointer(hFile) SetFilePointer(hFile, 0, NULL, FILE_CURRENT)


//******************************************************************************
//***** Global defines that are missing from some MSDEV platform headers
//******************************************************************************

// Missing defines from WinNT.h
#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE                3
#endif
#ifndef PROCESSOR_MIPS_R2000
#define PROCESSOR_MIPS_R2000                 2000
#endif
#ifndef PROCESSOR_MIPS_R3000
#define PROCESSOR_MIPS_R3000                 3000
#endif
#ifndef IMAGE_SUBSYSTEM_WINDOWS_OLD_CE_GUI
#define IMAGE_SUBSYSTEM_WINDOWS_OLD_CE_GUI   4
#endif

// Somewhere between WinNT.h ver 85 and WinNT ver 87, these got removed.
#ifndef IMAGE_FILE_MACHINE_R3000_BE
#define IMAGE_FILE_MACHINE_R3000_BE          0x0160
#endif
#ifndef IMAGE_FILE_MACHINE_SH3DSP
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#endif
#ifndef IMAGE_FILE_MACHINE_SH5
#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5
#endif
#ifndef IMAGE_FILE_MACHINE_AM33
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#endif
#ifndef IMAGE_FILE_MACHINE_POWERPCFP
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#endif
#ifndef IMAGE_FILE_MACHINE_TRICORE
#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon
#endif
#ifndef IMAGE_FILE_MACHINE_AMD64
#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)
#endif
#ifndef IMAGE_FILE_MACHINE_M32R
#define IMAGE_FILE_MACHINE_M32R              0x9104  // M32R little-endian
#endif
#ifndef IMAGE_FILE_MACHINE_CEE
#define IMAGE_FILE_MACHINE_CEE               0xC0EE
#endif
#ifndef IMAGE_FILE_MACHINE_EBC
#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code
#endif
#ifndef IMAGE_SUBSYSTEM_EFI_ROM
#define IMAGE_SUBSYSTEM_EFI_ROM              13
#endif
#ifndef IMAGE_SUBSYSTEM_XBOX
#define IMAGE_SUBSYSTEM_XBOX                 14
#endif
#ifndef PROCESSOR_ARCHITECTURE_AMD64
#define PROCESSOR_ARCHITECTURE_AMD64         9
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
#define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10
#endif


// (_WIN32_WINNT >= 0x0500) defines from WinNT.h
#ifndef VER_SUITE_PERSONAL
#define VER_SUITE_PERSONAL                  0x00000200
#endif
#ifndef STATUS_SXS_EARLY_DEACTIVATION
#define STATUS_SXS_EARLY_DEACTIVATION    ((DWORD   )0xC015000FL)    
#endif
#ifndef STATUS_SXS_INVALID_DEACTIVATION
#define STATUS_SXS_INVALID_DEACTIVATION  ((DWORD   )0xC0150010L)    
#endif


// (WINVER >= 0x0500) defines from WinUser.h
#ifndef SM_XVIRTUALSCREEN
#define SM_XVIRTUALSCREEN       76
#endif
#ifndef SM_YVIRTUALSCREEN
#define SM_YVIRTUALSCREEN       77
#endif
#ifndef SM_CXVIRTUALSCREEN
#define SM_CXVIRTUALSCREEN      78
#endif
#ifndef SM_CYVIRTUALSCREEN
#define SM_CYVIRTUALSCREEN      79
#endif

// (_WIN32_WINNT >= 0x0500) defines from CommDlg.h
#ifndef OFN_FORCESHOWHIDDEN
#define OFN_FORCESHOWHIDDEN                  0x10000000
#endif
#ifndef OFN_DONTADDTORECENT
#define OFN_DONTADDTORECENT                  0x02000000
#endif

// Stuff from prerelease WinError.h
#ifndef ERROR_SXS_SECTION_NOT_FOUND
#define ERROR_SXS_SECTION_NOT_FOUND      14000L
#endif
#define SXS_ERROR_FIRST ((INT)((ERROR_SXS_SECTION_NOT_FOUND) / 1000) * 1000)
#define SXS_ERROR_LAST  (SXS_ERROR_FIRST + 999)

#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\ntinc\dload.h ===
// taken from "\\devkits\release\SDK\DAILY\2437.0\Setup\psdk-common.52.cab\delayimp_h_1_____I64.3643236F_FC70_11D3_A536_0090278A1BB8"
//
// DelayImp.h
//
//  define structures and prototypes necessary for delay loading of imports
//
#pragma once
#if !defined(_delayimp_h)
#define _delayimp_h

#if defined(_DELAY_IMP_VER)
#undef _DELAY_IMP_VER
#endif

#define _DELAY_IMP_VER  2

#if defined(__cplusplus)
#define ExternC extern "C"
#else
#define ExternC
#endif

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;
typedef DWORD                       RVA;

typedef struct ImgDelayDescr {
    DWORD           grAttrs;        // attributes
    RVA             rvaDLLName;     // RVA to dll name
    RVA             rvaHmod;        // RVA of module handle
    RVA             rvaIAT;         // RVA of the IAT
    RVA             rvaINT;         // RVA of the INT
    RVA             rvaBoundIAT;    // RVA of the optional bound IAT
    RVA             rvaUnloadIAT;   // RVA of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescr, * PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

enum DLAttr {                   // Delay Load Attributes
    dlattrRva = 0x1,                // RVAs are used instead of pointers
    };

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR              szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

// utility function for calculating the index of the current import
// for all the tables (INT, BIAT, UIAT, and IAT).
__inline unsigned
IndexFromPImgThunkData(PCImgThunkData pitdCur, PCImgThunkData pitdBase) {
    return (unsigned) (pitdCur - pitdBase);
    }

// C++ template utility function for converting RVAs to pointers
//
#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
ExternC
__declspec(allocate(".base"))
extern
IMAGE_DOS_HEADER __ImageBase;
#else
ExternC
extern
IMAGE_DOS_HEADER __ImageBase;
#endif

#if defined(__cplusplus)
template <class X>
X * PFromRva(RVA rva, const X *) {
    return (X*)(PBYTE(&__ImageBase) + rva);
    }
#else
__inline
void *
WINAPI
PFromRva(RVA rva, void *unused) {
    return (PVOID)(&__ImageBase + rva);
    }
#endif

//
// Unload support
//

// routine definition; takes a pointer to a name to unload
//
ExternC
BOOL WINAPI
__FUnloadDelayLoadedDLL2(LPCSTR szDll);

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.
ExternC
extern
PUnloadInfo __puiHead;

//
// Exception information
//
#define FACILITY_VISUALCPP  ((LONG)0x6d)
#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

// utility function for calculating the count of imports given the base
// of the IAT.  NB: this only works on a valid IAT!
__inline unsigned
CountOfImports(PCImgThunkData pitdBase) {
    unsigned        cRet = 0;
    PCImgThunkData  pitd = pitdBase;
    while (pitd->u1.Function) {
        pitd++;
        cRet++;
        }
    return cRet;
    }

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//
ExternC
extern
PfnDliHook   __pfnDliNotifyHook;

ExternC
extern
PfnDliHook   __pfnDliNotifyHook2;

// This is the failure hook, dliNotify = {dliFailLoadLib|dliFailGetProc}
ExternC
extern
PfnDliHook   __pfnDliFailureHook;

ExternC
extern
PfnDliHook   __pfnDliFailureHook2;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\ntinc\actctx.h ===
// taken from "\\devkits\release\SDK\DAILY\2437.0\Uncompressed\Include\prerelease\WinBase.h"
#ifndef ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID

#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID    (0x00000001)
#define ACTCTX_FLAG_LANGID_VALID                    (0x00000002)
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID        (0x00000004)
#define ACTCTX_FLAG_RESOURCE_NAME_VALID             (0x00000008)
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT             (0x00000010)
#define ACTCTX_FLAG_APPLICATION_NAME_VALID          (0x00000020)
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF           (0x00000040)
#define ACTCTX_FLAG_HMODULE_VALID                   (0x00000080)

typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;
#ifdef UNICODE
typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;
#else
typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
#endif // UNICODE

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;
#ifdef UNICODE
typedef ACTCTXW ACTCTX;
typedef PCACTCTXW PCACTCTX;
#else
typedef ACTCTXA ACTCTX;
typedef PCACTCTXA PCACTCTX;
#endif // UNICODE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\devmap\makefile.inc ===
$(O)\dosdev.res: dosdev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\depends\src\ntinc\ntdll.h ===
//******************************************************************************
//
// File:        NTDLL.H
//
// Description: Stuff needed to make calls into NTDLL.DLL.
//
// Classes:     None
//
// Disclaimer:  All source code for Dependency Walker is provided "as is" with
//              no guarantee of its correctness or accuracy.  The source is
//              public to help provide an understanding of Dependency Walker's
//              implementation.  You may use this source as a reference, but you
//              may not alter Dependency Walker itself without written consent
//              from Microsoft Corporation.  For comments, suggestions, and bug
//              reports, please write to Steve Miller at stevemil@microsoft.com.
//
//
// Date      Name      History
// --------  --------  ---------------------------------------------------------
// 07/25/97  stevemil  Created (version 2.0)
//
//******************************************************************************

#ifndef __NTDLL_H__
#define __NTDLL_H__

#if _MSC_VER > 1000
#pragma once
#endif


//******************************************************************************
//***** Stuff from NTDEF.H
//******************************************************************************

#define NTSYSCALLAPI DECLSPEC_IMPORT

typedef LONG NTSTATUS;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }


//******************************************************************************
//***** Stuff from NTOBAPI.H
//******************************************************************************

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define SYMBOLIC_LINK_QUERY (0x0001)

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;


//******************************************************************************
//***** Stuff from NTPSAPI.H
//******************************************************************************

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    ProcessImageFileName,
    ProcessLUIDDeviceMapsEnabled,
    ProcessBreakOnTermination,
    ProcessDebugObjectHandle,
    ProcessDebugFlags,
    ProcessHandleTracing,
    MaxProcessInfoClass             // MaxProcessInfoClass should always be the last enum
    } PROCESSINFOCLASS;


//******************************************************************************
//***** Types
//******************************************************************************

// NtQueryInformationProcess declared in NTPSAPI.H
typedef NTSTATUS (NTAPI *PFN_NtQueryInformationProcess)(
    IN     HANDLE           ProcessHandle,
    IN     PROCESSINFOCLASS ProcessInformationClass,
       OUT PVOID            ProcessInformation,
    IN     ULONG            ProcessInformationLength,
    OUT    PULONG           ReturnLength
);

// NtClose declared in NTOBAPI.H
typedef NTSTATUS (NTAPI *PFN_NtClose)(
    IN     HANDLE Handle
);

// NtOpenDirectoryObject declared in NTOBAPI.H
typedef NTSTATUS (NTAPI *PFN_NtOpenDirectoryObject)(
       OUT PHANDLE            DirectoryHandle,
    IN     ACCESS_MASK        DesiredAccess,
    IN     POBJECT_ATTRIBUTES ObjectAttributes
);

// NtQueryDirectoryObject declared in NTOBAPI.H
typedef NTSTATUS (NTAPI *PFN_NtQueryDirectoryObject)(
    IN     HANDLE  DirectoryHandle,
       OUT PVOID   Buffer,
    IN     ULONG   Length,
    IN     BOOLEAN ReturnSingleEntry,
    IN     BOOLEAN RestartScan,
    IN OUT PULONG  Context,
       OUT PULONG  ReturnLength
);

// NtOpenSymbolicLinkObject declared in NTOBAPI.H
typedef NTSTATUS (NTAPI *PFN_NtOpenSymbolicLinkObject)(
       OUT PHANDLE            LinkHandle,
    IN     ACCESS_MASK        DesiredAccess,
    IN     POBJECT_ATTRIBUTES ObjectAttributes
);

// NtQuerySymbolicLinkObject declared in NTOBAPI.H
typedef NTSTATUS (NTAPI *PFN_NtQuerySymbolicLinkObject)(
    IN     HANDLE          LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
       OUT PULONG          ReturnedLength
);

#endif // __NTDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\diskperf\diskperf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    diskperf.c

Abstract:

    Program to display and/or update the current value of the Diskperf
    driver startup value

Author:

    Bob Watson (a-robw) 4 Dec 92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntconfig.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <regstr.h>  // for REGSTR_VAL_UPPERFILTERS
#include <tchar.h>
#include <locale.h>

#include "diskperf.h"    // include text string id constancts
#pragma warning(disable:4201)
#include <ntdddisk.h>
#pragma warning(pop)
#include <mountmgr.h>

LANGID WINAPI MySetThreadUILanguage(
    WORD wReserved);

#define  SWITCH_CHAR    '-' // is there a system call to get this?
#define  ENABLE_CHAR    'Y' // command will be upcased
#define  DISABLE_CHAR   'N'
#define  ENHANCED_CHAR  'E'

#define  LOCAL_CHANGE   2   // number of commands in a local change command
#define  REMOTE_CHANGE  3   // number of commands in a remote change command

//
//  note these values are arbitrarily based on the whims of the people
//  developing the disk drive drivers that belong to the "Filter" group.
//
#define  TAG_NORMAL     4   // diskperf starts AFTER ftdisk
#define  TAG_ENHANCED   2   // diskperf starts BEFORE ftdisk

#define  IRP_STACK_ENABLED  5 // size of IRP stack when diskperf is enabled
#define  IRP_STACK_DISABLED 4 // size of IRP stack when diskperf is enabled

#define  IRP_STACK_DEFAULT  8 // default IRP stack size in W2K
#define  IRP_STACK_NODISKPERF 7

#define DISKPERF_SERVICE_NAME TEXT("DiskPerf")

LPCTSTR lpwszDiskPerfKey = TEXT("SYSTEM\\CurrentControlSet\\Services\\Diskperf");
LPCTSTR lpwszIOSystemKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\I/O System");
LPCTSTR lpwszOsVersionKey = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
LPCTSTR lpwszBuildNumber = TEXT("CurrentBuildNumber");
LPCTSTR lpwszOsVersion = TEXT("CurrentVersion");

#define ENABLE_DISKDRIVE        0x0001
#define ENABLE_VOLUME           0x0002
#define ENABLE_PERMANENT        0x0004
#define ENABLE_PERMANENT_IOCTL  0x0008

LPCTSTR lpwszDiskDriveKey
    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E967-E325-11CE-BFC1-08002BE10318}");
LPCTSTR lpwszVolumeKey
    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

LPCTSTR lpwszPartmgrKey = TEXT("SYSTEM\\CurrentControlSet\\Services\\Partmgr");
LPCTSTR lpwszEnableCounterValue = TEXT("EnableCounterForIoctl");

ULONG
OpenRegKeys(
    IN LPCTSTR lpszMachine,
    OUT PHKEY hRegistry,
    OUT PHKEY hDiskKey,
    OUT PHKEY hVolumeKey,
    OUT PHKEY hServiceKey
    );

ULONG
SetFilter(
    IN HKEY hKey,
    IN LPTSTR strFilterString,
    IN DWORD dwSize
    );

ULONG
GetFilter(
    IN HKEY hKey,
    OUT LPTSTR strFilterString,
    IN DWORD dwSize
    );

ULONG
CheckFilter(
    IN TCHAR *Buffer
    );

ULONG
GetEnableFlag(
    IN HKEY hDiskKey,
    IN HKEY hVolumeKey
    );

ULONG
AddToFilter(
    IN HKEY hKey
    );

ULONG
RemoveFromFilter(
    IN HKEY hKey
    );

void
PrintStatus(
    IN BOOL bCurrent,
    IN ULONG EnableFlag,
    IN LPCTSTR cMachineName
    );

DWORD __cdecl
Dp_wprintf(
    const wchar_t *format,
    ...
    );

DWORD __cdecl
Dp_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

DWORD __cdecl
Dp_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

BOOL
IsBeyondW2K(
    IN LPCTSTR lpszMachine,
    OUT PDWORD EnableCounter);

ULONG
EnableForIoctl(
    IN LPWSTR lpszMachineName
    );

ULONG
DisableForIoctl(
    IN LPWSTR lpszMachineName,
    IN ULONG Request
    );

#if DBG
void
DbgPrintMultiSz(
    TCHAR *String,
    size_t Size
    );
#endif

#define REG_TO_DP_INDEX(reg_idx)    (DP_LOAD_STATUS_BASE + (\
    (reg_idx == SERVICE_BOOT_START) ? DP_BOOT_START : \
    (reg_idx == SERVICE_SYSTEM_START) ? DP_SYSTEM_START : \
    (reg_idx == SERVICE_AUTO_START) ? DP_AUTO_START : \
    (reg_idx == SERVICE_DEMAND_START) ? DP_DEMAND_START : \
    (reg_idx == SERVICE_DISABLED) ? DP_NEVER_START : DP_UNDEFINED))

#define MAX_MACHINE_NAME_LEN    32

// command line arguments

#define CMD_SHOW_LOCAL_STATUS   1
#define CMD_DO_COMMAND          2

#define ArgIsSystem(arg)   (*(arg) == '\\' ? TRUE : FALSE)

//
//  global buffer for help text display strings
//
#define DISP_BUFF_LEN       256
#define NUM_STRING_BUFFS      2
LPCTSTR BlankString = TEXT(" ");
LPCTSTR StartKey = TEXT("Start");
LPCTSTR TagKey = TEXT("Tag");
LPCTSTR EmptyString = TEXT("");
LPCTSTR LargeIrps = TEXT("LargeIrpStackLocations");

HINSTANCE   hMod = NULL;
DWORD   dwLastError;


LPCTSTR
GetStringResource (
    UINT    wStringId
)
{
    static TCHAR    DisplayStringBuffer[NUM_STRING_BUFFS][DISP_BUFF_LEN];
    static DWORD    dwBuffIndex;
    LPTSTR          szReturnBuffer;

    dwBuffIndex++;
    dwBuffIndex %= NUM_STRING_BUFFS;
    szReturnBuffer = (LPTSTR)&DisplayStringBuffer[dwBuffIndex][0];

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }

    if (hMod) {
        if ((LoadString(hMod, wStringId, szReturnBuffer, DISP_BUFF_LEN)) > 0) {
            return (LPCTSTR)szReturnBuffer;
        } else {
            dwLastError = GetLastError();
            return EmptyString;
        }
    } else {
        return EmptyString;
    }
}
LPCTSTR
GetFormatResource (
    UINT    wStringId
)
{
    static TCHAR   TextFormat[DISP_BUFF_LEN];

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }

    if (hMod) {
        if ((LoadString(hMod, wStringId, TextFormat, DISP_BUFF_LEN)) > 0) {
            return (LPCTSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}

VOID
DisplayChangeCmd (
)
{
    UINT        wID;
    TCHAR       DisplayStringBuffer[DISP_BUFF_LEN];

    if (hMod) {
        if ((LoadString(hMod, DP_TEXT_FORMAT, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
            for (wID=DP_CMD_HELP_START; wID <= DP_CMD_HELP_END; wID++) {
                if ((LoadString(hMod, wID, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
                    Dp_wprintf(DisplayStringBuffer);
                }
            }
        }
    }
}
VOID
DisplayCmdHelp(
)
{
    UINT        wID;
    TCHAR       DisplayStringBuffer[DISP_BUFF_LEN];

    if (hMod) {
        if ((LoadString(hMod, DP_TEXT_FORMAT, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
            for (wID=DP_HELP_TEXT_START; wID <= DP_HELP_TEXT_END; wID++) {
                if ((LoadString(hMod, wID, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
                    Dp_wprintf(DisplayStringBuffer);
                }
            }
        }
    }

    DisplayChangeCmd();
}

ULONG
DisplayStatus (
    LPTSTR lpszMachine
)
{
    ULONG       Status;
    HKEY        hRegistry;
    HKEY        hDiskPerfKey;
    HKEY        hDiskKey;
    HKEY        hVolumeKey;
    DWORD       dwValue, dwValueSize, dwTag;

    TCHAR       cMachineName[MAX_MACHINE_NAME_LEN];
    PTCHAR      pThisWideChar;
    PTCHAR       pThisChar;
    INT         iCharCount;
    DWORD       EnableCounter;

    pThisChar = lpszMachine;
    pThisWideChar = cMachineName;
    iCharCount = 0;

    if (pThisChar) {    // if machine is not NULL, then copy
        while (*pThisChar) {
            *pThisWideChar++ = (TCHAR)(*pThisChar++);
            if (++iCharCount >= MAX_MACHINE_NAME_LEN) break;
        }
        *pThisWideChar = 0;
    }

    if (!lpszMachine) {
        LPTSTR strThisSystem = (LPTSTR) GetStringResource(DP_THIS_SYSTEM);
        if (strThisSystem != NULL) {
            _tcsncpy(cMachineName, strThisSystem, MAX_MACHINE_NAME_LEN);
            cMachineName[MAX_MACHINE_NAME_LEN-1] = 0;
        }
    }

    if (IsBeyondW2K(lpszMachine, &EnableCounter)) {
        if (EnableCounter) {
            PrintStatus(TRUE, ENABLE_PERMANENT_IOCTL, cMachineName);
        }
        else {
            PrintStatus(TRUE, ENABLE_PERMANENT, cMachineName);
        }
        return ERROR_SUCCESS;
    }

    Status = OpenRegKeys(
                lpszMachine,
                &hRegistry,
                &hDiskKey,
                &hVolumeKey,
                &hDiskPerfKey);

    if (Status != ERROR_SUCCESS) {
#if DBG
        fprintf(stderr,
                "DisplayStatus: Cannot open HKLM on target machine: %d\n",
                Status);
#endif
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
        return Status;
    }

    dwTag = GetEnableFlag(hDiskKey, hVolumeKey);
    dwValue = (dwTag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
    dwValueSize = sizeof(dwValue);
    Status = RegQueryValueEx (
                hDiskPerfKey,
                StartKey,
                NULL,
                NULL,
                (LPBYTE)&dwValue,
                &dwValueSize);

    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_START));
        goto DisplayStatusCleanup;
    }

    PrintStatus(TRUE, dwTag, cMachineName);

  DisplayStatusCleanup:
    RegCloseKey(hDiskKey);
    RegCloseKey(hVolumeKey);
    RegCloseKey(hDiskPerfKey);
    RegCloseKey(hRegistry);

    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_STATUS_FORMAT), Status);

    }
    return Status;
}

ULONG
DoChangeCommand (
    LPTSTR lpszCommand,
    LPTSTR lpszMachine
)
{
    // connect to registry on local machine with read/write access
    ULONG       Status;
    HKEY        hRegistry;
    HKEY        hDiskPerfKey;
    HKEY        hDiskKey;
    HKEY        hVolumeKey;
    DWORD       dwValue;

    TCHAR       cMachineName[MAX_MACHINE_NAME_LEN];
    PTCHAR      pThisWideChar;
    PTCHAR       pThisChar;
    INT         iCharCount;
    PTCHAR       pCmdChar;

    HKEY        hIOSystemKey;
    DWORD       dwDisposition;
    DWORD       dwIrpValue;
    ULONG       EnableRequest, DisableRequest;
    ULONG       EnableFlag, EndFlag = 0;
    BOOL        bModified, bIrpStackReg;
    LONG        nIrpStack, nIrpStackReg, nIncrement;
    DWORD       EnableCounter;

    // check command to see if it's valid

    _tcsupr (lpszCommand);

    pCmdChar = lpszCommand;
    dwValue = 0;
    EnableRequest = DisableRequest = 0;

    if (*pCmdChar++ == SWITCH_CHAR ) {
        if (!_tcscmp(pCmdChar, _T("Y")) ||
            !_tcscmp(pCmdChar, _T("YA")) ||
            !_tcscmp(pCmdChar, _T("YALL"))) {
            EnableRequest = ENABLE_DISKDRIVE | ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("N")) ||
            !_tcscmp(pCmdChar, _T("NA")) ||
            !_tcscmp(pCmdChar, _T("NALL")) ) {
            DisableRequest = ENABLE_DISKDRIVE | ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("YD")) ||
            !_tcscmp(pCmdChar, _T("YDISK")) ) {
            EnableRequest = ENABLE_DISKDRIVE;
        }
        else if (!_tcscmp(pCmdChar, _T("YV")) ||
            !_tcscmp(pCmdChar, _T("YVOLUME")) ) {
            EnableRequest = ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("ND")) ||
            !_tcscmp(pCmdChar, _T("NDISK")) ) {
            DisableRequest = ENABLE_DISKDRIVE;
        }
        else if (!_tcscmp(pCmdChar, _T("NV")) ||
            !_tcscmp(pCmdChar, _T("NVOLUME")) ) {
            DisableRequest = ENABLE_VOLUME;
        } else {
            DisplayCmdHelp();
            return ERROR_SUCCESS;
        }
    } else {
        DisplayChangeCmd();
        return ERROR_SUCCESS;
    }

    // if command OK then convert machine to wide string for connection

    pThisChar = lpszMachine;
    pThisWideChar = cMachineName;
    iCharCount = 0;

    if (pThisChar) {
        while (*pThisChar) {
            *pThisWideChar++ = (TCHAR)(*pThisChar++);
            if (++iCharCount >= MAX_MACHINE_NAME_LEN) break;
        }
        *pThisWideChar = 0; // null terminate
    }

    if (lpszMachine == NULL) {
        LPTSTR strThisSystem = (LPTSTR) GetStringResource(DP_THIS_SYSTEM);
        if (strThisSystem != NULL) {
            _tcsncpy (cMachineName, strThisSystem, MAX_MACHINE_NAME_LEN);
            cMachineName[MAX_MACHINE_NAME_LEN-1] = 0;
        }
    }

    if (IsBeyondW2K(lpszMachine, &EnableCounter)) {
        if (EnableRequest != 0) {
            EnableForIoctl(lpszMachine);
            PrintStatus(TRUE, ENABLE_PERMANENT_IOCTL, cMachineName);
        }
        else if (DisableRequest != 0) {
            DisableForIoctl(lpszMachine, DisableRequest);
            PrintStatus(TRUE, ENABLE_PERMANENT, cMachineName);
        }
        return ERROR_SUCCESS;
    }

    // connect to registry
    Status = OpenRegKeys(
                lpszMachine,
                &hRegistry,
                &hDiskKey,
                &hVolumeKey,
                &hDiskPerfKey);

    if (Status != ERROR_SUCCESS) {
#if DBG
        fprintf(stderr,
                "DoChangeCommand: Cannot connect to registry: Status=%d\n",
                Status);
#endif
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
        return Status;
    }

    hIOSystemKey = NULL;
    nIrpStackReg = 0;
    bIrpStackReg = FALSE;       // no registry key prior to this
    Status = RegCreateKeyEx (
                hRegistry,
                lpwszIOSystemKey,
                0L, //Reserved
                NULL,
                0L, // no special options
                KEY_WRITE | KEY_READ, // desired access
                NULL, // default security
                &hIOSystemKey,
                &dwDisposition);
    if (Status != ERROR_SUCCESS) {
        if ((Status == ERROR_ALREADY_EXISTS) &&
            (dwDisposition == REG_OPENED_EXISTING_KEY)) {
            // then this key is already in the registry so this is OK
                Status = ERROR_SUCCESS;
        }
        else {
            Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
            goto DoChangeCommandCleanup;
        }
    }
    if ( (Status == ERROR_SUCCESS) && (dwDisposition == REG_OPENED_EXISTING_KEY)) {
            DWORD dwSize;
            dwSize = sizeof(DWORD);

            Status = RegQueryValueEx (
                        hIOSystemKey,
                        LargeIrps,
                        0L,
                        NULL,
                        (LPBYTE)&dwIrpValue,
                        &dwSize);
            if (Status == ERROR_SUCCESS) {
#if DBG
                fprintf(stderr, "Registry LargeIrpStack=%d\n", dwIrpValue);
#endif
                nIrpStackReg = dwIrpValue;
                bIrpStackReg = TRUE;
            }
    }

    EnableFlag = GetEnableFlag(hDiskKey, hVolumeKey);
#if DBG
    fprintf(stderr, "DoChangeCommand: EnableFlag is %x\n", EnableFlag);
#endif

    bModified = FALSE;

    nIncrement = 0;
    if ( (EnableRequest & ENABLE_DISKDRIVE) &&
        !(EnableFlag & ENABLE_DISKDRIVE) ) {
        // Turn on filter for disk drives
        if (AddToFilter(hDiskKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement++;
        }
    }
    if ( (EnableRequest & ENABLE_VOLUME) &&
        !(EnableFlag & ENABLE_VOLUME) ) {
        // Turn on filter for volumes
        if (AddToFilter(hVolumeKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement++;
        }
    }
    if ( (DisableRequest & ENABLE_DISKDRIVE) &&
         (EnableFlag & ENABLE_DISKDRIVE) ) {
        // Turn off filter for disk drives
        if (RemoveFromFilter(hDiskKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement--;
        }
    }
    if ( (DisableRequest & ENABLE_VOLUME) &&
         (EnableFlag & ENABLE_VOLUME) ) {
        // Turn off filter for volumes
        if (RemoveFromFilter(hVolumeKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement--;
        }
    }

    nIrpStack = 0;
    EndFlag = GetEnableFlag(hDiskKey, hVolumeKey);

    if (bModified) {    // we have modified the registry


        dwValue = (EndFlag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
        Status = RegSetValueEx(
                    hDiskPerfKey,
                    StartKey,
                    0L,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue));
        //
        // First update service registry entries
        //

        if (DisableRequest != 0) {
            nIrpStack = nIrpStackReg + nIncrement;
            if (EndFlag == 0) {
                //
                // Turn off service completely
                //
                // Set Irp stack size to original value or default
                if (nIrpStack < IRP_STACK_NODISKPERF)
                    nIrpStack = IRP_STACK_NODISKPERF;
            }
            else {  // else, there is only one stack left
                if (nIrpStack < IRP_STACK_NODISKPERF+1)
                    nIrpStack = IRP_STACK_NODISKPERF+1;
            }
        }
        else if (EnableRequest != 0) {
            nIrpStack = nIrpStackReg + nIncrement;
            //
            // Set proper Irp stack size
            //
            if (EndFlag == (ENABLE_DISKDRIVE | ENABLE_VOLUME)) {
                if (nIrpStack < IRP_STACK_NODISKPERF+2)    // a value is set
                    nIrpStack = IRP_STACK_NODISKPERF+2;
            }
            else {  // at least one is enabled
                if (nIrpStack < IRP_STACK_NODISKPERF+1)
                    nIrpStack = IRP_STACK_NODISKPERF+1;
            }
        }
    }
    else {
        //
        // No action taken. Should tell the user the state.
        //        
        PrintStatus(TRUE, EndFlag, cMachineName);
        Dp_wprintf(GetFormatResource(DP_NOCHANGE));
    }

#if DBG
    fprintf(stderr, "New LargeIrp is %d\n", nIrpStack);
#endif
    if (hIOSystemKey != NULL && Status == ERROR_SUCCESS) {
        if (bModified) {
            Status = RegSetValueEx (
                        hIOSystemKey,
                        LargeIrps,
                        0L,
                        REG_DWORD,
                        (LPBYTE)&nIrpStack,
                        sizeof(DWORD));
            if (Status == ERROR_SUCCESS) {
                PrintStatus(FALSE, EndFlag, cMachineName);
            }
            else {
                Dp_wprintf(GetFormatResource(DP_UNABLE_MODIFY_VALUE));
            }
        }
        RegCloseKey(hIOSystemKey);
    }

  DoChangeCommandCleanup:
    if (hDiskPerfKey != NULL) {
        RegCloseKey(hDiskPerfKey);
    }
    if (hDiskKey != NULL) {
        RegCloseKey(hDiskKey);
    }
    if (hVolumeKey != NULL) {
        RegCloseKey(hVolumeKey);
    }
    if (hRegistry != NULL) {
        RegCloseKey(hRegistry);
    }
    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_STATUS_FORMAT), Status);
    }
    return Status;
}

ULONG
OpenRegKeys(
    IN LPCTSTR lpszMachine,
    OUT PHKEY hRegistry,
    OUT PHKEY hDiskKey,
    OUT PHKEY hVolumeKey,
    OUT PHKEY hServiceKey
    )
{
    ULONG status;

    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    *hRegistry = NULL;
    status = RegConnectRegistry(
                lpszMachine,
                HKEY_LOCAL_MACHINE,
                hRegistry);
    if (status != ERROR_SUCCESS) {
        *hRegistry = NULL;
        return status;
    }
    if (*hRegistry == NULL)
        return ERROR_INVALID_PARAMETER; // Avoid PREFIX error

    if (hDiskKey) {
        *hDiskKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszDiskDriveKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hDiskKey);
        }
    }
    if (hVolumeKey) {
        *hVolumeKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszVolumeKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hVolumeKey);
        }
    }
    if (hServiceKey) {
        *hServiceKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszDiskPerfKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hServiceKey);
        }
    }
    if ( (status != ERROR_SUCCESS) && (hDiskKey != NULL) ) {
        if ((*hDiskKey != NULL) && (*hDiskKey != INVALID_HANDLE_VALUE)) {
            RegCloseKey(*hDiskKey);
        }
        *hDiskKey = NULL;
    }
    if ( (status != ERROR_SUCCESS) && (hVolumeKey != NULL) ) {
        if ((*hVolumeKey != NULL) && (*hVolumeKey != INVALID_HANDLE_VALUE)) {
            RegCloseKey(*hVolumeKey);
        }
        *hVolumeKey = NULL;
    }
    if ( (status != ERROR_SUCCESS) && (hServiceKey != NULL) ) {
        if ((*hServiceKey != NULL) && (*hServiceKey != INVALID_HANDLE_VALUE)) {
            RegCloseKey(*hServiceKey);
        }
        *hServiceKey = NULL;
    }
    //
    // hRegistry and *hRegistry cannot be NULL here
    //
    if ( (status != ERROR_SUCCESS) && (*hRegistry != INVALID_HANDLE_VALUE)) {
        RegCloseKey(*hRegistry);
        *hRegistry = NULL;
    }
    return status;
}

ULONG
SetFilter(
    IN HKEY hKey,
    IN LPTSTR strFilterString,
    IN DWORD dwSize
    )
{
    ULONG status;
    LONG len;
    DWORD dwType = REG_MULTI_SZ;

    if (hKey == NULL)
        return ERROR_BADKEY;

//
// NOTE: Assumes that strFilterString is always MAX_PATH, NULL padded
//
    len = dwSize / sizeof(TCHAR);
    if (len < 2) {
        dwSize = 2 * sizeof(TCHAR);
#if DBG
        fprintf(stderr, "SetFilter: Length %d dwSize %d\n", len, dwSize);
#endif
    }
    else {  // ensures 2 null character always
        if (strFilterString[len-1] != 0) { // no trailing null
            len += 2;
            strFilterString[len] = 0;
            strFilterString[len+1] = 0;
#if DBG
    fprintf(stderr, "SetFilter: New length(+2) %d\n", len);
#endif
        }
        else if (strFilterString[len-2] != 0) { // only one trailing null
            len += 1;
            strFilterString[len+1] = 0;
#if DBG
            fprintf(stderr, "SetFilter: New length(+1) %d\n", len);
#endif
        }
        dwSize = len * sizeof(TCHAR);
    } 
    if (len <= 2) {
        status = RegDeleteValue(hKey, REGSTR_VAL_UPPERFILTERS);
#if DBG
        fprintf(stderr, "Delete status = %d\n", status);
#endif
        return status;
    }
    status = RegSetValueEx(
                hKey,
                REGSTR_VAL_UPPERFILTERS,
                (DWORD) 0,
                dwType,
                (BYTE*)strFilterString,
                dwSize);

#if DBG
    if (status != ERROR_SUCCESS) {
        _ftprintf(stderr, _T("SetFilter: Cannot query key %s status=%d\n"),
                REGSTR_VAL_UPPERFILTERS, status);
    }
    else {
        fprintf(stderr, "SetFilter: ");
        DbgPrintMultiSz(strFilterString, dwSize);
        fprintf(stderr, "\n");
    }
#endif
    return status;
}

ULONG
GetFilter(
    IN HKEY hKey,
    OUT LPTSTR strFilterString,
    IN DWORD dwSize
    )
// Returns size of strFilterString
{
    ULONG status;

    if (hKey == NULL)
        return ERROR_BADKEY;

    status = RegQueryValueEx(
                hKey,
                REGSTR_VAL_UPPERFILTERS,
                NULL,
                NULL,
                (BYTE*)strFilterString,
                &dwSize);
    if (status != ERROR_SUCCESS) {
#if DBG
        _ftprintf(stderr, _T("GetFilter: Cannot query key %s status=%d\n"),
                REGSTR_VAL_UPPERFILTERS, status);
#endif
        return 0;
    }
#if DBG
    else {
        fprintf(stderr, "GetFilter: ");
        DbgPrintMultiSz(strFilterString, dwSize);
        fprintf(stderr, "\n");
    }
#endif
    return dwSize;
}

ULONG
CheckFilter(TCHAR *Buffer)
{
    TCHAR *string = Buffer;
    ULONG stringLength, diskperfLen, result;

    if (string == NULL)
        return 0;
    stringLength = (ULONG) _tcslen(string);

    diskperfLen = (ULONG) _tcslen(DISKPERF_SERVICE_NAME);

    result = FALSE;
    while(stringLength != 0) {

        if ((diskperfLen == stringLength) && 
            (_tcsicmp(string, DISKPERF_SERVICE_NAME) == 0)) {
#if DBG
            fprintf(stderr, 
                    "CheckFilter: string found at offset %d\n",
                    (string - Buffer));
#endif
            result = TRUE;
            break;
        }
        string += stringLength + 1;
        stringLength = (ULONG) _tcslen(string);
    }
    return result;
}

ULONG
GetEnableFlag(
    IN HKEY hDiskKey,
    IN HKEY hVolumeKey
    )
// Returns the flags indicating what is enabled
{
    ULONG bFlag = 0;
    TCHAR strFilter[MAX_PATH+1] = {0};
    DWORD dwSize;

    dwSize = sizeof(TCHAR) * (MAX_PATH+1);
    if (GetFilter(hDiskKey, strFilter, dwSize) > 0) {
        if (CheckFilter(strFilter))
            bFlag |= ENABLE_DISKDRIVE;
    }
#if DBG
    else
        fprintf(stderr, "GetEnableFlag: No filters for disk drive\n");
#endif

    dwSize = sizeof(TCHAR) * (MAX_PATH+1);
    if (GetFilter(hVolumeKey, strFilter, dwSize) > 0) {
        if (CheckFilter(strFilter))
            bFlag |= ENABLE_VOLUME;
    }
#if DBG
    else
        fprintf(stderr, "GetEnableFlag: No filters for volume\n");
#endif
    return bFlag;
}

ULONG
AddToFilter(
    IN HKEY hKey
    )
{
    TCHAR *string, buffer[MAX_PATH+1];
    ULONG dataLength;
    DWORD dwLength, dwSize;

    dwSize = sizeof(TCHAR) * MAX_PATH;
    RtlZeroMemory(buffer, dwSize + sizeof(TCHAR));
    string = buffer;

    dataLength = GetFilter(hKey, buffer, dwSize);
    dwSize = dataLength;
    if (dwSize > (sizeof(TCHAR) * MAX_PATH)) {      // just in case
        dwSize = sizeof(TCHAR) * MAX_PATH;
    }
#if DBG
    if (dataLength > 0) {
        fprintf(stderr, "AddToFilter: Original string ");
        DbgPrintMultiSz(buffer, dataLength);
        fprintf(stderr, "\n");
    }
    else fprintf(stderr, "AddToFilter: Cannot get original string\n");
#endif
    dataLength = dataLength / sizeof(TCHAR);
    if (dataLength != 0) {
        dataLength -= 1;
    }
    dwLength = (DWORD) _tcslen(DISKPERF_SERVICE_NAME);
    if (dataLength <  (MAX_PATH-dwLength-1)) {
        _tcscpy(&(string[dataLength]), DISKPERF_SERVICE_NAME);
        dwSize += (dwLength+1) * sizeof(TCHAR);
    }

#if DBG
    fprintf(stderr, "AddToFilter: New string ");
    DbgPrintMultiSz(buffer, dataLength + _tcslen(DISKPERF_SERVICE_NAME)+1);
    fprintf(stderr, "\n"); 
#endif
    return SetFilter(hKey, buffer, dwSize);
}

void
PrintStatus(
    IN BOOL bCurrent,
    IN ULONG EnableFlag,
    IN LPCTSTR cMachineName
    )
{
    DWORD       dwValue;
    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];

    dwValue = (EnableFlag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
    if ((EnableFlag & ENABLE_PERMANENT) | (EnableFlag & ENABLE_PERMANENT_IOCTL)) {
        _stprintf(OemDisplayStringBuffer,
                  GetFormatResource(DP_PERMANENT_FORMAT),
                  cMachineName);
        if (EnableFlag & ENABLE_PERMANENT_IOCTL) {
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_IOCTL),
                      cMachineName);
        }
        else {
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_FORMAT1),
                      cMachineName);
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_FORMAT2),
                      cMachineName);
        }
    }
    else  if ( (EnableFlag == (ENABLE_DISKDRIVE | ENABLE_VOLUME)) ||
               (EnableFlag == 0) ) {
        _stprintf(OemDisplayStringBuffer,
                bCurrent ?  GetFormatResource (DP_CURRENT_FORMAT1)
                         :  GetFormatResource (DP_NEW_DISKPERF_STATUS1),
                cMachineName,
                GetStringResource(REG_TO_DP_INDEX(dwValue)));
    }
    else {
        _stprintf (OemDisplayStringBuffer,
                 bCurrent ?  GetFormatResource (DP_CURRENT_FORMAT)
                          :  GetFormatResource (DP_NEW_DISKPERF_STATUS),
                 (EnableFlag  == ENABLE_DISKDRIVE) ?
                 GetStringResource(DP_PHYSICAL) :
                 GetStringResource(DP_LOGICAL),
                 cMachineName,
                 GetStringResource(REG_TO_DP_INDEX(dwValue)));
    }
    Dp_wprintf(OemDisplayStringBuffer);
}

ULONG
RemoveFromFilter(
    IN HKEY hKey
    )
{
    TCHAR *string, buffer[MAX_PATH+1];
    ULONG dataLength, stringLength, diskperfLen, found;
    ULONG removeSize;

    dataLength = sizeof(TCHAR) * (MAX_PATH+1);      // Compute size first
    RtlZeroMemory(buffer, sizeof(TCHAR) * MAX_PATH);
    dataLength = GetFilter(hKey, buffer, dataLength);
    if (dataLength == 0)
        return 0;

#if DBG
    fprintf(stderr, "RemoveFromFilter: Original string ");
    DbgPrintMultiSz(buffer, dataLength);
    fprintf(stderr, "'\n");
#endif

    string = (TCHAR *) buffer;
    dataLength -= sizeof(TCHAR);

    //
    // now, find DiskPerf from the entry to remove it
    //
    stringLength = (ULONG) _tcslen(string);

    diskperfLen = (ULONG) _tcslen(DISKPERF_SERVICE_NAME); // includes NULL
    removeSize = (diskperfLen+1) * sizeof(TCHAR);

#if DBG
    fprintf(stderr, "RemoveFromFilter: diskperfLen=%d removeSize=%d\n",
                    diskperfLen, removeSize);
#endif
    found = FALSE;
    while(stringLength != 0 && !found) {

#if DBG
        fprintf(stderr,
            "RemoveFromFilter: Loop stringLength=%d\n", stringLength);
#endif
        if (diskperfLen == stringLength) {
            if(_tcsicmp(string, DISKPERF_SERVICE_NAME) == 0) {
                //
                // found it, so we will remove it right now
                //
                if (dataLength > removeSize) {
                    RtlCopyMemory(
                        string,
                        string+stringLength+1,
                        dataLength - removeSize);
                    RtlZeroMemory(
                        (PUCHAR)(buffer) + dataLength - removeSize,
                        removeSize);
                }
                else {
                    RtlZeroMemory( buffer, removeSize);
                }
                found = TRUE;
            }
        }
        // else, try the next entry
        string += stringLength + 1;
        stringLength = (ULONG) _tcslen(string);
    }
    dataLength = dataLength + sizeof(TCHAR) - removeSize;
    if (dataLength <= MAX_PATH*sizeof(TCHAR))
        buffer[dataLength/sizeof(TCHAR)] = 0;

#if DBG
    fprintf(stderr, "RemoveFromFilter: New string ");
    DbgPrintMultiSz(buffer, dataLength);
    fprintf(stderr, "\n");
#endif
    return SetFilter(hKey, buffer, dataLength);
}




 /***
 * Dp_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This Dp_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

DWORD __cdecl
Dp_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = Dp_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * Dp_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This Dp_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

DWORD __cdecl
Dp_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = Dp_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


DWORD __cdecl
Dp_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = (DWORD) wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}



#if DBG
void
DbgPrintMultiSz(
    TCHAR *String,
    size_t Size
    )
{
    size_t len;

#if DBG
    fprintf(stderr, "%d ", Size);
#endif
    len = _tcslen(String);
    while (len > 0) {
        _ftprintf(stderr, _T("'%s' "), String);
        String += len+1;
        len = _tcslen(String);
    }
}
#endif


void
SplitCommandLine(
    LPTSTR CommandLine,
    LPTSTR* pArgv
    )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg);
        arg = _tcstok(NULL, _T(" \t"));
    }
}

int 
__cdecl main(
    int argc, 
    char **argv
    )
{
    LPTSTR *targv,*commandLine;
    ULONG  Status = ERROR_SUCCESS;
    int i;

    setlocale(LC_ALL, ".OCP");

    MySetThreadUILanguage(0);

    commandLine = (LPTSTR*)malloc( argc * sizeof(LPTSTR) );
    if (!commandLine)
        exit(1);
    for(i=0;i<argc;i++){
        commandLine[i] = (LPTSTR)malloc( (strlen(argv[i])+1) * sizeof(LPTSTR));
        if (!commandLine[i]) 
            exit(1);
    }

    SplitCommandLine( GetCommandLine(), commandLine );
    targv = commandLine;

    hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;

    // check for command arguments
    
    if (argc == CMD_SHOW_LOCAL_STATUS) {
        Status = DisplayStatus(NULL);
    } else if (argc >= CMD_DO_COMMAND) {
        if (ArgIsSystem(targv[1])) {
            Status = DisplayStatus (targv[1]);
        } else {    // do change command
            if (argc == LOCAL_CHANGE) {
                DoChangeCommand (targv[1], NULL);
            } else if (argc == REMOTE_CHANGE) {
                DoChangeCommand(targv[1], targv[2]);
            } else {
                DisplayChangeCmd();
            }
        }
    } else {
        DisplayCmdHelp();
    }
    Dp_wprintf(_T("\n"));

    for(i=0;i<argc;i++){
        free(commandLine[i]);
        commandLine[i] = NULL;
    }
    free(commandLine);

    return 0;
}

BOOL
IsBeyondW2K(
    IN LPCTSTR lpszMachine,
    OUT PDWORD EnableCounter
    )
{
    OSVERSIONINFO OsVersion;
    HKEY hRegistry, hKey;
    TCHAR szBuildNumber[32];
    TCHAR szVersion[32];
    DWORD dwBuildNumber, dwMajor, status, dwSize;
    BOOL bRet = FALSE;

    *EnableCounter = 0;
    hRegistry = INVALID_HANDLE_VALUE;
    if (lpszMachine != NULL) {
        if (*lpszMachine != 0) {
           status = RegConnectRegistry(
                       lpszMachine,
                       HKEY_LOCAL_MACHINE,
                       &hRegistry);
            if (status != ERROR_SUCCESS)
                return FALSE;
            status = RegOpenKeyEx(
                        hRegistry,
                        lpwszOsVersionKey,
                        (DWORD) 0,
                        KEY_QUERY_VALUE,
                        &hKey);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hRegistry);
                return FALSE;
            }
            dwSize = sizeof(TCHAR) * 32;
            status = RegQueryValueEx(
                        hKey,
                        lpwszBuildNumber,
                        NULL,
                        NULL,
                        (BYTE*)szBuildNumber,
                        &dwSize);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hKey);
                RegCloseKey(hRegistry);
                return FALSE;
            }
            status = RegQueryValueEx(
                       hKey,
                       lpwszOsVersion,
                       NULL,
                       NULL,
                       (BYTE*)szVersion,
                       &dwSize);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hKey);
                RegCloseKey(hRegistry);
                return FALSE;
            }
            RegCloseKey(hKey);
            status = RegOpenKeyEx(
                        hRegistry,
                        lpwszPartmgrKey,
                        (DWORD) 0,
                        KEY_QUERY_VALUE,
                        &hKey);
            if (status == ERROR_SUCCESS) {
                *EnableCounter = 0;
                status = RegQueryValueEx(
                            hKey,
                            lpwszEnableCounterValue,
                            NULL,
                            NULL,
                            (BYTE*) EnableCounter,
                            &dwSize);
                if ((status != ERROR_SUCCESS) || (dwSize != sizeof(DWORD))) {
                    *EnableCounter = 0;
                }
                RegCloseKey(hKey);
            }
            dwBuildNumber = _ttoi(szBuildNumber);
            dwMajor = _ttoi(szVersion);
            if ((dwMajor >= 5) && (dwBuildNumber > 2195)) {
                bRet = TRUE;
                status = RegOpenKeyEx(
                            hRegistry,
                            lpwszPartmgrKey,
                            (DWORD) 0,
                            KEY_QUERY_VALUE,
                            &hKey);
                if (status == ERROR_SUCCESS) {
                    status = RegQueryValueEx(
                                hKey,
                                lpwszEnableCounterValue,
                                NULL,
                                NULL,
                                (BYTE*) EnableCounter,
                                &dwSize);
                    if ((status != ERROR_SUCCESS) || (dwSize != sizeof(DWORD))) {
                        *EnableCounter = 0;
                    }
                    RegCloseKey(hKey);
                }
            }
            if (hRegistry != INVALID_HANDLE_VALUE) {
                RegCloseKey(hRegistry);
            }
        }
    }
    else {
        OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsVersion)) {
            if ((OsVersion.dwMajorVersion >= 5) &&
                (OsVersion.dwMinorVersion > 0) &&
                (OsVersion.dwBuildNumber > 2195))
            return TRUE;
        }
    }
    return FALSE;
}

ULONG
EnableForIoctl(
    IN LPWSTR lpszMachineName
    )
{
    DWORD status;
    HKEY hRegistry, hKey;
    DWORD dwValue = 1;

    hRegistry = NULL;

    status = RegConnectRegistry(
                lpszMachineName,
                HKEY_LOCAL_MACHINE,
                &hRegistry);
    if (status != ERROR_SUCCESS)
        return status;
    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    hKey = NULL;
    status = RegOpenKeyEx(
                hRegistry,
                lpwszPartmgrKey,
                (DWORD) 0,
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hRegistry);
        return status;
    }
    status = RegSetValueEx(
                hKey,
                lpwszEnableCounterValue,
                0L,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);
    return 0;
}

ULONG
DisableForIoctl(
    IN LPWSTR lpszMachineName,
    IN ULONG Request
    )
{
    ULONG nDisk, i;
    SYSTEM_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS status;

    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;

    WCHAR devname[MAX_PATH+1];
    PWCHAR s;

    HANDLE PartitionHandle, MountMgrHandle, VolumeHandle;
    DWORD ReturnedBytes;

    HKEY hRegistry, hKey;

    status = RegConnectRegistry(
                lpszMachineName,
                HKEY_LOCAL_MACHINE,
                &hRegistry);
    if (status != ERROR_SUCCESS)
        return status;
    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    status = RegOpenKeyEx(
                hRegistry,
                lpwszPartmgrKey,
                (DWORD) 0,
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hRegistry);
        return status;
    }
    RegDeleteValue(hKey, lpwszEnableCounterValue);
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);

    if (!(Request & ENABLE_DISKDRIVE)) goto DisableVolume;
    status = NtQuerySystemInformation(SystemDeviceInformation, &DeviceInfo, sizeof(DeviceInfo), NULL);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    nDisk = DeviceInfo.NumberOfDisks;
    // for each physical disk
    for (i = 0; i < nDisk; i++) {

        swprintf(devname, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, devname);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        // opening a partition handle for physical drives
        status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );

        if ( !NT_SUCCESS(status) ) {
            continue;
        }
        // sending IOCTL over to Partition Handle
        if (!DeviceIoControl(PartitionHandle,
                        IOCTL_DISK_PERFORMANCE_OFF,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedBytes,
                        NULL
                        )) {
#if DBG
            printf("IOCTL failed for %ws\n", devname);
#endif
        }

        NtClose(PartitionHandle);
    }

    DisableVolume:
    if (!(Request | ENABLE_VOLUME)) {
        return 0;
    }

    MountMgrHandle = FindFirstVolumeW(devname, MAX_PATH);
    if (MountMgrHandle == NULL) {
#if DBG
        printf("Cannot find first volume\n");
#endif
        return 0;
    }
    i = (ULONG) wcslen(devname);
    if (i > 0) {
        s = (PWCHAR) &devname[i-1];
        if (*s == L'\\') {
            *s = UNICODE_NULL;
        }
    }

    VolumeHandle = CreateFile(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (VolumeHandle != INVALID_HANDLE_VALUE) {
#if DBG
        printf("Opened with success\n");
#endif
        // sending IOCTL over to a volume handle
        if (!DeviceIoControl(VolumeHandle,
               IOCTL_DISK_PERFORMANCE_OFF,
               NULL,
               0,
               NULL,
               0,
               &ReturnedBytes,
               NULL
               )) {
#if DBG
            printf("IOCTL failed for %ws\n", devname);
#endif
        }
       CloseHandle(VolumeHandle);
    }

    while (FindNextVolumeW(MountMgrHandle, devname, MAX_PATH)) {
        i = (ULONG) wcslen(devname);
        if (i > 0) {
            s = (PWCHAR) &devname[i-1];
            if (*s == L'\\') {
                *s = UNICODE_NULL;
            }
        }
        else {
            continue;
        }
        VolumeHandle = CreateFile(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (VolumeHandle != INVALID_HANDLE_VALUE) {
#if DBG
            printf("Opened with success\n");
#endif
            if (!DeviceIoControl(VolumeHandle,
                   IOCTL_DISK_PERFORMANCE_OFF,
                   NULL,
                   0,
                   NULL,
                   0,
                   &ReturnedBytes,
                   NULL
                   )) {
#if DBG
               printf("IOCTL failed for %ws\n", devname);
#endif
           }
           CloseHandle(VolumeHandle);
        }
    }
    FindVolumeClose(MountMgrHandle);
    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  MySetThreadUILanguage
//
//  This routine sets the thread UI language based on the console codepage.
//
//  9-29-00    WeiWu    Created.
//  Copied from Base\Win32\Winnls so that it works in W2K as well
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI MySetThreadUILanguage(
    WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    LCID s_lidSystem = 0;
    ULONG s_uiSysCp = 0;
    ULONG s_uiSysOEMCp = 0;

    ULONG uiUserUICp = 0;
    ULONG uiUserUIOEMCp = 0;
    WCHAR szData[16];
    UNICODE_STRING ucStr;

    LANGID lidUserUI = GetUserDefaultUILanguage();
    LCID lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    UNREFERENCED_PARAMETER(wReserved);

    //
    //  Make sure nobody uses it yet
    //
    ASSERT(wReserved == 0);

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp)
    {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem)
        {
            //
            // Get ANSI CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUICp);

            //
            // Get OEM CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &s_uiSysOEMCp);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }

    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI)
    {
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(&ucStr, szData);
        RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUICp);

        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(&ucStr, szData);
        RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUIOEMCp);
    }

    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp && 
        s_lidSystem != LANG_ARABIC && 
        s_lidSystem != LANG_HEBREW &&
        s_lidSystem != LANG_VIETNAMESE && 
        s_lidSystem != LANG_THAI)
    {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
            (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp))
        {
            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }

    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread)))
    {
        lcidThread = lcidThreadOld;
    }

    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\devmap\devmap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    devmap.c

Abstract:

    Program to launch a command with a different device mapping.

Author:

    02-Oct-1996 Steve Wood (stevewo)

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

UCHAR DeviceNames[ 4096 ];
UCHAR TargetPath[ 4096 ];

typedef struct _DEVICE_LINK {
    PCHAR LinkName;
    ULONG LinkTargetLength;
    PCHAR LinkTarget;
    BOOL ProtectedDevice;
    BOOL RemoveDevice;
} DEVICE_LINK, *PDEVICE_LINK;

ULONG NumberOfDriveLetters;
ULONG NumberOfDevices;
DEVICE_LINK DriveLetters[ 128 ];
DEVICE_LINK Devices[ 128 ];
BOOLEAN CreatePermanentPrivilegeEnabled;
BOOLEAN CreatePermanentPrivilegeWasEnabled;

BOOLEAN
EnableCreatePermanentPrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable create permanent privilege
    //
    Status = RtlAdjustPrivilege( SE_CREATE_PERMANENT_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &CreatePermanentPrivilegeWasEnabled    // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    CreatePermanentPrivilegeEnabled = TRUE;
    return TRUE;
}


void
DisableCreatePermanentPrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_CREATE_PERMANENT_PRIVILEGE,
                        CreatePermanentPrivilegeWasEnabled,
                        FALSE,
                        &CreatePermanentPrivilegeWasEnabled
                      );

    CreatePermanentPrivilegeEnabled = FALSE;
    return;
}



void
Usage( void )
{
    fprintf( stderr, "usage: DEVMAP [-R]\n" );
    fprintf( stderr, "              [-r \"device list\"]\n" );
    fprintf( stderr, "              [-a \"device list\"]\n" );
    fprintf( stderr, "              command line...\n" );
    fprintf( stderr, "where: -R - removes all device definitions\n" );
    fprintf( stderr, "       -r - removes specified device definitions\n" );
    fprintf( stderr, "       -a - adds specified device definitions\n" );
    fprintf( stderr, "       \"device list\" - is a list of one or more blank separated\n" );
    fprintf( stderr, "                         defintions of the form name[=target]\n" );
    fprintf( stderr, "                         If target is not specified for -a then\n" );
    fprintf( stderr, "                         uses the target in effect when DEVMAP\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Examples:\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "    DEVMAP -R -a \"C: D: NUL\" CMD.EXE\n" );
    fprintf( stderr, "    DEVMAP -r \"UNC\" CMD.EXE\n" );
    fprintf( stderr, "    DEVMAP -a \"COM1=\\Device\\Serial8\" CMD.EXE\n" );
    exit( 1 );
}

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    );

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    )
{
    char *s;

    printf( "%s%s = ", Msg, Name );
    s = Target;
    while (*s && cchTarget != 0) {
        if (s > Target) {
            printf( " ; " );
            }
        printf( "%s", s );
        while (*s++) {
            if (!cchTarget--) {
                cchTarget = 0;
                break;
                }
            }
        }
}

PDEVICE_LINK
FindDevice(
    LPSTR Name,
    BOOL fAdd
    )
{
    DWORD i;
    LPSTR NewTarget;
    PDEVICE_LINK p;

    if (fAdd) {
        NewTarget = strchr( Name, '=' );
        if (NewTarget != NULL) {
            *NewTarget++ = '\0';
            }
        }

    for (i=0; i<NumberOfDriveLetters; i++) {
        p = &DriveLetters[ i ];
        if (!_stricmp( p->LinkName, Name )) {
            if (fAdd && NewTarget) {
                p->LinkTargetLength = strlen( NewTarget ) + 2;
                p->LinkTarget = calloc( 1, p->LinkTargetLength );
                if (!p->LinkTarget) {
                    return NULL;
                }
                strcpy( p->LinkTarget, NewTarget );
                }
            return p;
            }
        }

    for (i=0; i<NumberOfDevices; i++) {
        p = &Devices[ i ];
        if (!_stricmp( p->LinkName, Name )) {
            if (fAdd && NewTarget) {
                p->LinkTargetLength = strlen( NewTarget ) + 2;
                p->LinkTarget = calloc( 1, p->LinkTargetLength );
                if (!p->LinkTarget) {
                    return NULL;
                }
                strcpy( p->LinkTarget, NewTarget );
                }
            return p;
            }
        }

    if (fAdd) {
        if (NewTarget != NULL) {
            if (strlen( Name ) == 2 && Name[1] == ':') {
                p = &DriveLetters[ NumberOfDriveLetters++ ];
                }
            else {
                p = &Devices[ NumberOfDevices++ ];
                }

            p->LinkName = Name;
            p->LinkTargetLength = strlen( NewTarget ) + 2;
            p->LinkTarget = calloc( 1, p->LinkTargetLength );
            if (!p->LinkTarget) {
                return NULL;
            }
            strcpy( p->LinkTarget, NewTarget );
            }
        else {
            fprintf( stderr, "DEVMAP: Unable to add '%s' device name without target.\n", Name );
            }
        }
    else {
        fprintf( stderr, "DEVMAP: Unable to remove '%s' device name.\n", Name );
        }

    return NULL;
}

BOOL
CreateSymbolicLink(
    HANDLE DirectoryHandle,
    LPSTR Name,
    LPSTR Target,
    DWORD cchTarget,
    BOOL fVerbose
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING LinkName, LinkTarget;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE LinkHandle;

    RtlInitAnsiString( &AnsiString, Name );
    RtlAnsiStringToUnicodeString( &LinkName, &AnsiString, TRUE );

    AnsiString.Buffer = Target;
    AnsiString.Length = (USHORT)cchTarget - 2;
    AnsiString.MaximumLength = (USHORT)(cchTarget - 1);
    RtlAnsiStringToUnicodeString( &LinkTarget, &AnsiString, TRUE );

    InitializeObjectAttributes( &ObjectAttributes,
                                &LinkName,
                                CreatePermanentPrivilegeEnabled ? OBJ_PERMANENT : 0,
                                DirectoryHandle,
                                NULL
                              );
    Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &LinkTarget
                                       );
    if (NT_SUCCESS( Status )) {
        if (CreatePermanentPrivilegeEnabled) {
            NtClose( LinkHandle );
            }
        return TRUE;
        }
    else {
        if (fVerbose) {
            printf( " (*** FAILED %x ***)", Status );
            }
        return FALSE;
        }
}

int
__cdecl
CompareDeviceLink(
    void const *p1,
    void const *p2
    )
{
    return _stricmp( ((PDEVICE_LINK)p1)->LinkName, ((PDEVICE_LINK)p2)->LinkName );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD cch, i;
    char c, *s;
    BOOL fVerbose;
    BOOL fRemoveAllDevices;
    LPSTR lpCommandLine;
    LPSTR lpRemoveDevices;
    LPSTR lpAddDevices;
    PDEVICE_LINK p;
    char szWindowsDirectory[ MAX_PATH ] = {0};
    char chWindowsDrive;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    if (!GetWindowsDirectory( szWindowsDirectory, sizeof( szWindowsDirectory ) )) {
        return 1;
    }
    chWindowsDrive = (char) toupper( szWindowsDirectory[ 0 ] );
    fVerbose = FALSE;
    fRemoveAllDevices = FALSE;
    lpCommandLine = NULL;
    lpRemoveDevices = NULL;
    lpAddDevices = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch (tolower( c )) {
                    case '?':
                    case 'h':
                        Usage();

                    case 'v':
                        fVerbose = TRUE;
                        break;

                    case 'r':
                        if (c == 'R') {
                            fRemoveAllDevices = TRUE;
                            }
                        else
                        if (--argc) {
                            lpRemoveDevices = *++argv;
                            }
                        else {
                            fprintf( stderr, "DEVMAP: missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;

                    case 'a':
                        if (--argc) {
                            lpAddDevices = *++argv;
                            }
                        else {
                            fprintf( stderr, "DEVMAP: missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;
                    }
                }
            }
        else
        if (lpCommandLine == NULL) {
            lpCommandLine = s;
            break;
            }
        else {
            Usage();
            }
        }

    if (lpCommandLine != NULL) {
        lpCommandLine = strstr( GetCommandLine(), lpCommandLine );
        }

    if (lpCommandLine == NULL) {
        lpCommandLine = "CMD.EXE";
        }


    cch = QueryDosDevice( NULL,
                          DeviceNames,
                          sizeof( DeviceNames )
                        );
    if (cch == 0) {
        fprintf( stderr, "DOSDEV: Unable to query device names - %u\n", GetLastError() );
        exit( 1 );
        }

    s = DeviceNames;
    while (*s) {
        cch = QueryDosDevice( s,
                              TargetPath,
                              sizeof( TargetPath )
                            );
        if (cch == 0) {
            sprintf( TargetPath, "*** unable to query target path - %u ***", GetLastError() );
            }
        else {
            if (strlen( s ) == 2 && s[1] == ':') {
                p = &DriveLetters[ NumberOfDriveLetters++ ];
                if (chWindowsDrive == toupper( *s )) {
                    p->ProtectedDevice = TRUE;
                    }
                }
            else {
                p = &Devices[ NumberOfDevices++ ];
                }

            p->LinkName = s;
            p->LinkTargetLength = cch;
            p->LinkTarget = malloc( cch );
            if (!p->LinkTarget) {
                return 1;
            }
            memmove( p->LinkTarget, TargetPath, cch );
            }

        while (*s++)
            ;
        }

    qsort( DriveLetters,
           NumberOfDriveLetters,
           sizeof( DEVICE_LINK ),
           CompareDeviceLink
         );

    qsort( Devices,
           NumberOfDevices,
           sizeof( DEVICE_LINK ),
           CompareDeviceLink
         );

    if (fVerbose) {
        printf( "Existing Device Names\n" );

        for (i=0; i<NumberOfDriveLetters; i++) {
            p = &DriveLetters[ i ];
            DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( "\n" );
            }

        for (i=0; i<NumberOfDevices; i++) {
            p = &Devices[ i ];
            DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( "\n" );
            }
        }

    if (fRemoveAllDevices) {
        for (i=0; i<NumberOfDriveLetters; i++) {
            DriveLetters[ i ].RemoveDevice = TRUE;
            }
        for (i=0; i<NumberOfDevices; i++) {
            Devices[ i ].RemoveDevice = TRUE;
            }
        }

    while (s = lpRemoveDevices) {
        while (*s && *s != ' ') {
            s++;
            }
        c = *s;
        *s++ = '\0';
        if (p = FindDevice( lpRemoveDevices, FALSE )) {
            p->RemoveDevice = TRUE;
            }
        if (c) {
            lpRemoveDevices = s;
            }
        else {
            lpRemoveDevices = NULL;
            }
        }

    while (s = lpAddDevices) {
        while (*s && *s != ' ') {
            s++;
            }
        c = *s;
        *s++ = '\0';
        if (p = FindDevice( lpAddDevices, TRUE )) {
            p->RemoveDevice = FALSE;
            }

        if (c) {
            lpAddDevices = s;
            }
        else {
            lpAddDevices = NULL;
            }
        }

    if (fVerbose) {
        printf( "Launching '%s' with following Device Names\n", lpCommandLine );
        }
    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    if (!CreateProcess( NULL,
                        lpCommandLine,
                        NULL,
                        NULL,
                        TRUE,
                        CREATE_SUSPENDED,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                      )
       ) {
        fprintf( stderr, "DEVMAP: CreateProcess failed - %u\n", GetLastError() );
        return 1;
        }

    Status = NtCreateDirectoryObject( &DirectoryHandle,
                                      DIRECTORY_ALL_ACCESS,
                                      NULL
                                    );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "DEVMAP: NtCreateDirectoryObject failed - %x\n", Status );
        return 1;
        }

    ProcessDeviceMapInfo.Set.DirectoryHandle = DirectoryHandle;
    Status = NtSetInformationProcess( ProcessInfo.hProcess,
                                      ProcessDeviceMap,
                                      &ProcessDeviceMapInfo.Set,
                                      sizeof( ProcessDeviceMapInfo.Set )
                                    );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "DEVMAP: Set ProcessDeviceMap failed - %x\n", Status );
        exit(1);
        }

    EnableCreatePermanentPrivilege();
    for (i=0; i<NumberOfDriveLetters; i++) {
        p = &DriveLetters[ i ];
        if (!p->RemoveDevice || p->ProtectedDevice) {
            if (fVerbose) {
                DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                if (p->RemoveDevice && p->ProtectedDevice) {
                    printf( "  (*** may not remove boot device)" );
                    }
                }
            CreateSymbolicLink( DirectoryHandle,
                                p->LinkName,
                                p->LinkTarget,
                                p->LinkTargetLength,
                                fVerbose
                              );
            if (fVerbose) {
                printf( "\n" );
                }
            }
        }

    for (i=0; i<NumberOfDevices; i++) {
        p = &Devices[ i ];
        if (!p->RemoveDevice || p->ProtectedDevice) {
            if (fVerbose) {
                DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                }
            CreateSymbolicLink( DirectoryHandle,
                                p->LinkName,
                                p->LinkTarget,
                                p->LinkTargetLength,
                                fVerbose
                              );
            if (fVerbose) {
                printf( "\n" );
                }
            }
        }
    DisableCreatePermanentPrivilege();
    NtClose( DirectoryHandle );

    ResumeThread( ProcessInfo.hThread );
    WaitForSingleObject( ProcessInfo.hProcess, 0xffffffff );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\diff\diff.c ===
/*                                                                                        SORT
*      %Z% %M% %I% %D% %Q%
*
*      Copyright (C) Microsoft Corporation, 1983
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and AT&T, and should be treated as Confidential.
*/

/***    diff - differential file comparison
*
*      MODIFICATION HISTORY
*      M000    18 Apr 83       andyp
*      - 3.0 upgrade.  No changes.
*      M001    22 Mar 84       vich
*      - Don't try to unlink NULL.  Trying to do so doesn't break anything,
*        but it makes kernel debugging a pain due to faults in user mode.
*      M002    ??
*      - added the MSDOS flag.
*      M006    31 Mar 86       craigwi
*      - for the MSDOS version, fixed -b feature so that it ignores all \r
*      M010    15 Dec 86       craigwi
*      - after printing the result, diff aborts with status = 2 if any error
*        occurred on stdout.
*      M013    21 Mar 88       jangr
*      - added -s flag to return SLM specific error statuses:
*        10    files identical
*        11    files different
*        12    other errors
*        13    write error
*      M017    27 Oct 88       alanba
*      - changed messages to not specify using the -h option and giving
*        a clear error message if being executed from within SLM.
*/
/*
*      Uses an algorithm due to Harold Stone, which finds
*      a pair of longest identical subsequences in the two
*      files.
*
*      The major goal is to generate the match vector J.
*      J[i] is the index of the line in file1 corresponding
*      to line i file0. J[i] = 0 if there is no
*      such line in file1.
*
*      Lines are hashed so as to work in core. All potential
*      matches are located by sorting the lines of each file
*      on the hash (called value). In particular, this
*      collects the equivalence classes in file1 together.
*      Subroutine equiv  replaces the value of each line in
*      file0 by the index of the first element of its
*      matching equivalence in (the reordered) file1.
*      To save space equiv squeezes file1 into a single
*      array member in which the equivalence classes
*      are simply concatenated, except that their first
*      members are flagged by changing sign.
*
*      Next the indices that point into member are unsorted into
*      array class according to the original order of file0.
*
*      The cleverness lies in routine stone. This marches
*      through the lines of file0, developing a vector klist
*      of "k-candidates". At step i a k-candidate is a matched
*      pair of lines x,y (x in file0 y in file1) such that
*      there is a common subsequence of lenght k
*      between the first i lines of file0 and the first y
*      lines of file1, but there is no such subsequence for
*      any smaller y. x is the earliest possible mate to y
*      that occurs in such a subsequence.
*
*      Whenever any of the members of the equivalence class of
*      lines in file1 matable to a line in file0 has serial number
*      less than the y of some k-candidate, that k-candidate
*      with the smallest such y is replaced. The new
*      k-candidate is chained (via pred) to the current
*      k-1 candidate so that the actual subsequence can
*      be recovered. When a member has serial number greater
*      that the y of all k-candidates, the klist is extended.
*      At the end, the longest subsequence is pulled out
*      and placed in the array J by unravel.
*
*      With J in hand, the matches there recorded are
*      checked against reality to assure that no spurious
*      matches have crept in due to hashing. If they have,
*      they are broken, and "jackpot " is recorded--a harmless
*      matter except that a true match for a spuriously
*      mated line may now be unnecessarily reported as a change.
*
*      Much of the complexity of the program comes simply
*      from trying to minimize core utilization and
*      maximize the range of doable problems by dynamically
*      allocating what is needed and reusing what is not.
*      The core requirements for problems larger than somewhat
*      are (in words) 2*length(file0) + length(file1) +
*      3*(number of k-candidates installed),  typically about
*      6n words for files of length n.
*/

#include <stdio.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <excpt.h>
#include <process.h>
#include <fcntl.h>
#ifdef _OS2_SUBSYS_
    #define INCL_DOSSIGNALS
    #include <os2.h>
#else
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
/*
 * Signal subtypes for XCPT_SIGNAL
 */
    #define XCPT_SIGNAL                     0xC0010003
    #define XCPT_SIGNAL_INTR        1
    #define XCPT_SIGNAL_KILLPROC    3
    #define XCPT_SIGNAL_BREAK       4
#endif


#define isslash(c)  (c=='/'||c=='\\')
#define DIFFH           "diffh.exe"

#ifndef _MAX_PATH
    #if defined(LFNMAX) && defined(LPNMAX)
        #define _MAX_PATH (LFNMAX + LPNMAX + 1)
    #else
        #define _MAX_PATH (80)
    #endif
#endif
#ifndef _HEAP_MAXREQ
    #define _HEAP_MAXREQ ((~(unsigned int) 0) - (unsigned) 32)
#endif
#define HALFLONG 16
#define low(x)  (x&((1L<<HALFLONG)-1))
#define high(x) (x>>HALFLONG)

struct cand **clist;    /* merely a free storage pot for candidates */
int clistcnt = 0;       /* number of arrays of struct cand in clist */
unsigned clen = 0;      /* total number of struct cand in all clist arrays */

/*
Number of struct cand in one clist array
(the largest power of 2 smaller than (64k / sizeof(struct cand))
is 2^13.  Thus, these gross hacks to make the array references
more efficient, and still permit huge files.
*/
#define CLISTSEG (0x2000)
#define CLISTDIV(x) ((x) >> 13)
#define CLISTMOD(x) ((x) & (CLISTSEG - 1))
#define CLIST(x) (clist[CLISTDIV(x)][CLISTMOD(x)])

PVOID   input[2];

char *inputfile[2];
int  inputfilesize[2];
char *inputfilep[2];
int  inputfileleft[2];

#define EndOfFile(x)    (inputfileleft[x] <= 0)

#define  GetChar(x)  ((char)((inputfileleft[x]--) ?     \
                           (*(inputfilep[x])++)  :  \
                           EOF))



#define SEARCH(c1,k1,y1) (CLIST(c1[k1]).y < y1) ? (k1+1) : search(c1,k1,y1)

#if 0

char
GetChar( int x );

char
GetChar( int x ) {
    if ( inputfileleft[x]-- ) {
        return *(inputfilep[x])++;
    } else {
        return EOF;
    }
}

#endif

struct cand {
    int x;
    int y;
    unsigned pred;
} cand;
struct line {
    int serial;
    int value;
} *file[2], line;


typedef struct _FILEMAP *PFILEMAP;
typedef struct _FILEMAP {
    HANDLE  FileHandle;
    HANDLE  MapHandle;
    DWORD   Access;
    DWORD   Create;
    DWORD   Share;
    PVOID   Base;
    DWORD   Offset;
    DWORD   Size;
    DWORD   Allocated;
} FILEMAP;

PVOID
Open(
    const char *FileName,
    const char *Mode,
    DWORD      Size
    );

int
Close (
      PVOID   Map
      );




/* fn prototypes gen'd from cl -Zg */

DECLSPEC_NORETURN void  done(void);
char  *talloc(unsigned n);
char  *ralloc(char      *p,unsigned n);
void  myfree( char *p );
void  noroom(void);
int   __cdecl  sortcmp(void    const *first, void const *second);
void  unsort(struct  line *f,unsigned l,int  *b);
void  filename(char     * *pa1,char     * *pa2);
void  prepare(int       i,char  *arg);
void  prune(void);
void  equiv(struct      line *a,int     n,struct  line *b,int  m,int  *c);
int  stone(int  *a,unsigned  n,int  *b,unsigned  *c);
unsigned newcand(int  x,int  y,unsigned pred);
int  search(unsigned  *c,int  k,int  y);
void  unravel(unsigned  p);
void  check(char        * *argv);
char *  skipline(int  f);
void  output(char       * *argv);
void  change(int        a,int   b,int  c,int  d);
void  range(int a,int  b,char  *separator);
void  fetch(char *      *f,int  a,int   b, int lb,char  *s);
int   readhash( int f);
void  mesg(char *s,char  *t);
void  SetOutputFile (char *FileName);

unsigned len[2];
struct line *sfile[2];  /*shortened by pruning common prefix and suffix*/
unsigned slen[2];

unsigned int pref, suff; /*length of prefix and suffix*/
int *class;     /*will be overlaid on file[0]*/
int *member;    /*will be overlaid on file[1]*/
unsigned *klist;             /*will be overlaid on file[0] after class*/
int *J;         /*will be overlaid on class*/
char * *ixold;    /*will be overlaid on klist*/
char * *ixnew;    /*will be overlaid on file[1]*/
int opt;        /* -1,0,1 = -e,normal,-f */
int status = 2; /*abnormal status; set to 0/1 just before successful exit */
int anychange = 0;
char *empty = "";
int bflag;
int slmFlag;
FILE*   OutputFile;





char *tempfile; /*used when comparing against std input*/

#ifndef MSDOS
char *dummy;    /*used in resetting storage search ptr*/
#endif
void
done()
{
    if (tempfile != NULL)
        _unlink(tempfile);

    if (OutputFile && OutputFile != stdout) {
        fclose(OutputFile);
    }
    exit(10*slmFlag + status);
}

#define MALLOC(n)               talloc(n)
#define REALLOC(p,n)    ralloc(p,n)
#define FREE(p)                 myfree(p)


// #define DEBUG_MALLOC

#ifdef DEBUG_MALLOC

    #define MALLOC_SIG              0xABCDEF00
    #define FREE_SIG                0x00FEDCBA

typedef struct _MEMBLOCK {
    DWORD   Sig;
} MEMBLOCK, *PMEMBLOCK;

#endif

char *
talloc(
      unsigned n
      )
{

#ifdef DEBUG_MALLOC
    PMEMBLOCK         mem;
    char              DbgB[128];

    //sprintf(DbgB, "MALLOC size %d -> ", n );
    //OutputDebugString( DbgB );

    mem = malloc( n + sizeof(MEMBLOCK)+1 );

    if ( !mem ) {
        noroom();
    }

    mem->Sig = MALLOC_SIG;

    //sprintf(DbgB, "%lX\n", mem );
    //OutputDebugString( DbgB );

    return (char *)((PBYTE)mem + sizeof(MEMBLOCK));

#else
    register char *p;

    p = malloc(++n);
    if (p == NULL) {
        noroom();
    }

    return p;
#endif
}

char *
ralloc(
      char *p,
      unsigned n
      )
{
#ifdef DEBUG_MALLOC
    PMEMBLOCK         mem;
    char              DbgB[128];

    mem = (PMEMBLOCK)((PBYTE)p - sizeof(MEMBLOCK));

    //sprintf(DbgB, "REALLOC: %lX, %d  -> ", mem, n );
    //OutputDebugString( DbgB );

    if ( mem->Sig != MALLOC_SIG ) {
        sprintf(DbgB, "REALLOC ERROR: Reallocating %lX\n", mem );
        OutputDebugString( DbgB );
    }
    mem->Sig = FREE_SIG;
    mem = (PMEMBLOCK)realloc(mem, n + sizeof(MEMBLOCK)+1);
    if (!mem) {
        noroom();
    }

    mem->Sig = MALLOC_SIG;

    //sprintf(DbgB, "%lX\n", mem );
    //OutputDebugString( DbgB );

    return (char *)((PBYTE)mem + sizeof(MEMBLOCK));

#else
    void *pv = realloc(p, ++n);
    if (!pv) {
        noroom();
    }
    return(pv);

#endif
}


void
myfree(
      char *p
      )
{

#ifdef DEBUG_MALLOC
    PMEMBLOCK mem;
    char      DbgB[128];

    mem = (PMEMBLOCK)((PBYTE)p - sizeof(MEMBLOCK));

    //sprintf(DbgB, "FREE: %lX -> ", mem );
    //OutputDebugString( DbgB);

    if ( mem->Sig != MALLOC_SIG ) {
        sprintf(DbgB, "\n\tFREE ERROR: FREEING %lX\n", mem );
        OutputDebugString( DbgB );
    }
    mem->Sig = FREE_SIG;
    free(mem);

    //sprintf(DbgB, "Ok\n", mem );
    //OutputDebugString( DbgB);

#else
    if (p) {
        free(p);
    }
#endif
}



void
noroom()
{

    if (slmFlag == 1) {
        mesg("file too big; do delfile filename/addfile filename, or",empty);
        mesg("reduce the size of the file.",empty);
        done();
    }
    mesg("files too big",empty);    /* end M017 */
    done();
}


int
__cdecl
sortcmp(
       const  void *first,
       const  void *second
       )
{
    struct line *one = (struct line *)first;
    struct line *two = (struct line *)second;

    if (one->value < two->value)
        return -1;
    else if (one->value > two->value)
        return 1;
    else if (one->serial < two->serial)
        return -1;
    else if (one->serial > two->serial)
        return 1;
    else
        return 0;
}

void
unsort(
      struct line *f,
      unsigned l,
      int *b
      )
{
    register int *a;
    register unsigned int i;
    a = (int *)MALLOC((l+1)*sizeof(int));
    if (a) {
        memset(a, 0, (l+1)*sizeof(int));
        for (i=1;i<=l;i++)
            a[f[i].serial] = f[i].value;
        for (i=1;i<=l;i++)
            b[i] = a[i];
        FREE((char *)a);
    }
}

void
filename(
        char **pa1,
        char **pa2
        )
{

    register char *a1, *b1, *a2;
    char buf[BUFSIZ];
    struct _stat stbuf;
    int i, f;

    a1 = *pa1;
    a2 = *pa2;


    if (_stat(a1,&stbuf)!=-1 && ((stbuf.st_mode&S_IFMT)==S_IFDIR)) {
        b1 = *pa1 = MALLOC((unsigned) _MAX_PATH);
        while (*b1++ = *a1++) ;
        if (isslash(b1[-2]))
            b1--;
        else
            b1[-1] = '/';
        a1 = b1;
        if ( a2[1] == ':' ) {
            a2 += 2;
        }
        while (*a1++ = *a2++)
            if (*a2 && !isslash(*a2) && isslash(a2[-1])) /*M002*/
                a1 = b1;
    } else if (a1[0]=='-'&&a1[1]==0&&tempfile==NULL) {
        /*  the signal handling in original source
        **
        **      signal(SIGINT,done);
        **  #ifndef MSDOS
        **      signal(SIGHUP,done);
        **      signal(SIGPIPE,done);
        **      signal(SIGTERM,done);
        **  #endif
        */

        if ((*pa1 = tempfile = _tempnam(getenv("TEMP"), "d")) == NULL) {
            mesg("cannot create temporary file", "");
            done();
        }
        if ((f = _open(tempfile,O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {
            mesg("cannot create ",tempfile);
            done();
        }

        while ((i=_read(0,buf,BUFSIZ))>0)
            _write(f,buf,i);
        _close(f);
    }
}

void
prepare(
       int i,
       char *arg
       )
{

#define CHUNKSIZE   100

    register struct line *p;
    register unsigned j;
    register int h;
    char *c;
    PVOID f;
    unsigned int MaxSize;

    f = Open(arg,"r", 0);

    if (!f) {
        mesg("cannot open ", arg);
        done();
    }

    input[i] = f;

    inputfile[i]     = ((PFILEMAP)f)->Base;
    inputfilesize[i] = ((PFILEMAP)f)->Size;

    inputfilep[i]    = inputfile[i];
    inputfileleft[i] = inputfilesize[i];

    //
    //  Lets assume that lines are 30 characters on average
    //
    MaxSize = inputfilesize[i] / 30;
    p = (struct line *)MALLOC((3+MaxSize)*sizeof(line));
    for (j=0; h=readhash(i);) {
        j++;
        if ( j >= MaxSize ) {
            MaxSize += CHUNKSIZE;
            p = (struct line *)REALLOC((char *)p,(MaxSize+3)*sizeof(line));
        }
        p[j].value = h;
    }
    p = (struct line *)REALLOC((char *)p,(j+3+1)*sizeof(line));

    len[i] = j;
    file[i] = p;
    //Close(input[i]);
}

void
prune()
{
    register unsigned int i,j;
    for (pref=0;pref<len[0]&&pref<len[1]&&
        file[0][pref+1].value==file[1][pref+1].value;
        pref++ ) ;
    for (suff=0;suff<len[0]-pref&&suff<len[1]-pref&&
        file[0][len[0]-suff].value==file[1][len[1]-suff].value;
        suff++) ;
    for (j=0;j<2;j++) {
        sfile[j] = file[j]+pref;
        slen[j] = len[j]-pref-suff;
        for (i=0;i<=slen[j];i++)
            sfile[j][i].serial = i;
    }
}

void
equiv(
     struct line *a,
     int n,
     struct line *b,
     int m,
     int *c
     )
{
    register int i, j;
    i = j = 1;
    while (i<=n && j<=m) {
        if (a[i].value <b[j].value)
            a[i++].value = 0;
        else if (a[i].value == b[j].value)
            a[i++].value = j;
        else
            j++;
    }
    while (i <= n)
        a[i++].value = 0;
    b[m+1].value = 0;
    j = 0;
    while (++j <= m) {
        c[j] = -b[j].serial;
        while (b[j+1].value == b[j].value) {
            j++;
            c[j] = b[j].serial;
        }
    }
    c[j] = -1;
}

char **args;

void
__cdecl
main(
    int argc,
    char **argv
    )
{

    register int k;

    args = argv;

    OutputFile = stdout;        // Init to default

    argc--;
    argv++;

    while (argc > 0 && argv[0][0]=='-') {

        BOOL    Skip = FALSE;

        for (k=1; (!Skip) && argv[0][k]; k++) {

            switch (argv[0][k]) {

                case 'e':
                    opt = -1;
                    break;

                case 'f':
                    opt = 1;
                    break;

                case 'b':
                    bflag = 1;
                    break;

                case 'h':
                    _execvp(DIFFH, args);
                    mesg("cannot run diffh",empty);
                    done();

                case 's':
                    slmFlag = 1;
                    break;

                case 'o':
                    //
                    //  Dirty hack: Redirection is not working, so if
                    //  this flag is present, output goes to
                    //  file.
                    //
                    argc--;
                    argv++;
                    if (argc < 3) {
                        mesg("arg count",empty);
                        done();
                    }
                    SetOutputFile(argv[0]);
                    Skip = TRUE;
                    break;
            }
        }
        argc--;
        argv++;
    }

    if (argc!=2) {
        mesg("arg count",empty);
        done();
    }

#ifndef MSDOS
    dummy = malloc(1);
#endif
    _setmode(_fileno(OutputFile), O_BINARY);
    _setmode(_fileno(stdin),O_TEXT);
    filename(&argv[0], &argv[1]);
    filename(&argv[1], &argv[0]);
    prepare(0, argv[0]);
    prepare(1, argv[1]);
    prune();
    qsort((char *) (sfile[0] + 1), slen[0], sizeof(struct line), sortcmp);
    qsort((char *) (sfile[1] + 1), slen[1], sizeof(struct line), sortcmp);

    member = (int *)file[1];
    equiv(sfile[0], slen[0], sfile[1], slen[1], member);
    member = (int *)REALLOC((char *)member,(slen[1]+2)*sizeof(int));

    class = (int *)file[0];
    unsort(sfile[0], slen[0], class);
    class = (int *)REALLOC((char *)class,(slen[0]+2)*sizeof(int));
    klist = (unsigned *)MALLOC((slen[0]+2)*sizeof(int));
    clist = (struct cand **)MALLOC(sizeof(struct cand *));
    clist[0] = (struct cand *) MALLOC(sizeof(struct cand));
    clistcnt = 1;
    k = stone(class, slen[0], member, klist);
    FREE((char *)member);
    FREE((char *)class);

    J = (int *)MALLOC((len[0]+2)*sizeof(int));

    unravel(klist[k]);
    for (k = 0; k < clistcnt; ++k)
        FREE((char *)(clist[k]));
    FREE((char *)clist);
    FREE((char *)klist);

    ixold = (char **)MALLOC((len[0]+2)*sizeof(char *));
    ixnew = (char **)MALLOC((len[1]+2)*sizeof(char *));
    check(argv);
    output(argv);
    status = anychange;
    Close(input[0]);
    Close(input[1]);

    done();
}

stone(
     int *a,
     unsigned n,
     int *b,
     unsigned *c
     )
{
    register int i, k,y;
    int j, l;
    unsigned oldc, tc;
    int oldl;
    k = 0;
    c[0] = newcand(0,0,0);
    for (i=1; i<=(int)n; i++) {
        j = a[i];
        if (j==0)
            continue;
        y = -b[j];
        oldl = 0;
        oldc = c[0];
        do {
            if (y <= CLIST(oldc).y)
                continue;
            l = SEARCH(c, k, y);
            if (l!=oldl+1)
                oldc = c[l-1];
            if (l<=k) {
                if (CLIST(c[l]).y <= y)
                    continue;
                tc = c[l];
                c[l] = newcand(i,y,oldc);
                oldc = tc;
                oldl = l;
            } else {
                c[l] = newcand(i,y,oldc);
                k++;
                break;
            }
        } while ((y=b[++j]) > 0);
    }
    return(k);
}

unsigned
newcand(
       int x,
       int y,
       unsigned pred
       )
{
    register struct cand *q;


    ++clen;
    if ((int)CLISTDIV(clen) > (clistcnt - 1)) {
        // printf("diff: surpassing segment boundry..\n");
        clist = (struct cand **) REALLOC((char *) clist,
                                         ++clistcnt * sizeof(struct cand *));
        clist[clistcnt-1] = (struct cand *) MALLOC(sizeof(struct cand));
    }
    clist[clistcnt-1] = (struct cand *)
                        REALLOC((char *)(clist[clistcnt-1]),
                                (1 + CLISTMOD(clen)) * sizeof(struct cand));
    q = &CLIST(clen - 1);
    q->x = x;
    q->y = y;
    q->pred = pred;
    return(clen-1);
}

search(
      unsigned *c,
      int k,
      int y
      )
{
    register int i, j;
    int l;
    int t;
    //if(CLIST(c[k]).y<y) /*quick look for typical case*/
    //    return(k+1);
    i = 0;
    j = k+1;
    while ((l=(i+j)/2) > i) {
        t = CLIST(c[l]).y;
        if (t > y)
            j = l;
        else if (t < y)
            i = l;
        else
            return(l);
    }
    return(l+1);
}

void
unravel(
       unsigned p
       )
{
    register unsigned int i;
    register struct cand *q;

    for (i=0; i<=len[0]; i++)
        J[i] =  i<=pref ? i:
                i>len[0]-suff ? i+len[1]-len[0]:
                0;


    for (q=&CLIST(p);q->y!=0;q=&CLIST(q->pred)) {

        J[q->x+pref] = q->y+pref;
    }
}

/* check does double duty:
1.  ferret out any fortuitous correspondences due
to confounding by hashing (which result in "jackpot")
2.  collect random access indexes to the two files */

void
check(
     char **argv
     )
{
    register unsigned int i, j;
    int jackpot;
    char c,d;
    //input[0] = fopen(argv[0],"r");
    //input[1] = fopen(argv[1],"r");

    inputfilep[0] = inputfile[0];
    inputfilep[1] = inputfile[1];

    inputfileleft[0] = inputfilesize[0];
    inputfileleft[1] = inputfilesize[1];

    j = 1;
    ixold[0] = ixnew[0] = 0L;
    ixold[0] = inputfilep[0];
    ixnew[0] = inputfilep[1];
    //ixold[1] = inputfilep[0];
    //ixnew[1] = inputfilep[1];
    jackpot = 0;
    for (i=1;i<=len[0];i++) {
        if (J[i]==0) {
            ixold[i] = skipline(0);
            continue;
        }
        while (j<(unsigned)J[i]) {
            ixnew[j] = skipline(1);
            j++;
        }
        for (;;) {
            c = GetChar(0);
            d = GetChar(1);
            if (bflag && isspace(c) && isspace(d)) {
                do {
                    if (c=='\n') break;
                } while (isspace(c=GetChar(0)));
                do {
                    if (d=='\n') break;
                } while (isspace(d=GetChar(1)));
            }
            if (c!=d) {
                jackpot++;
                J[i] = 0;
                if (c!='\n')
                    skipline(0);
                if (d!='\n')
                    skipline(1);
                break;
            }
            if (c=='\n')
                break;
        }
        ixold[i] = inputfilep[0];
        ixnew[j] = inputfilep[1];
        j++;
    }
    for (;j<=len[1];j++) {
        ixnew[j] = skipline(1);
    }
    //fclose(input[0]);
    //fclose(input[1]);
    /*
    if(jackpot)
            mesg("jackpot",empty);
    */
}

char *
skipline(
        int f
        )
{
    while (GetChar(f) != '\n' )
        ;

    return inputfilep[f];
}

void
output(
      char **argv
      )
{
    int m;
    register int i0, i1, j1;
    int j0;

    input[0] = Open(argv[0],"r", 0);
    input[1] = Open(argv[1],"r", 0);
    m = len[0];
    J[0] = 0;
    J[m+1] = len[1]+1;
    if (opt!=-1) for (i0=1;i0<=m;i0=i1+1) {
            while (i0<=m&&J[i0]==J[i0-1]+1) i0++;
            j0 = J[i0-1]+1;
            i1 = i0-1;
            while (i1<m&&J[i1+1]==0) i1++;
            j1 = J[i1+1]-1;
            J[i1] = j1;
            change(i0,i1,j0,j1);
        } else for (i0=m;i0>=1;i0=i1-1) {
            while (i0>=1&&J[i0]==J[i0+1]-1&&J[i0]!=0) i0--;
            j0 = J[i0+1]-1;
            i1 = i0+1;
            while (i1>1&&J[i1-1]==0) i1--;
            j1 = J[i1-1]+1;
            J[i1] = j1;
            change(i1,i0,j1,j0);
        }
    if (m==0)
        change(1,0,1,len[1]);
}

void
change(
      int a,
      int b,
      int c,
      int d
      )
{
    if (a>b&&c>d)
        return;
    anychange = 1;
    if (opt!=1) {
        range(a,b,",");
        putc(a>b?'a':c>d?'d':'c', OutputFile);
        if (opt!=-1)
            range(c,d,",");
    } else {
        putc(a>b?'a':c>d?'d':'c', OutputFile);
        range(a,b," ");
    }
    putc('\r',OutputFile);
    putc('\n',OutputFile);
    if (opt==0) {
        fetch(ixold,a,b,0,"< ");
        if (a<=b&&c<=d)
            fputs("---\r\n", OutputFile);
    }
    fetch(ixnew,c,d,1,opt==0?"> ":empty);
    if (opt!=0&&c<=d)
        fputs(".",OutputFile);
}


void
range(
     int a,
     int b,
     char *separator
     )
{
    fprintf(OutputFile,"%d", a>b?b:a);
    if (a<b)
        fprintf(OutputFile,"%s%d", separator, b);
}

void
fetch(
     char **f,
     int a,
     int b,
     int lb,
     char *s
     )
{
    register int i, j;
    register int nc;
    register char c;
    char *p;

    UNREFERENCED_PARAMETER( lb );

    for (i=a;i<=b;i++) {
        p = f[i-1];
        nc = (int)(f[i]-f[i-1]);
        fputs(s, OutputFile);
        for (j=0;j<nc;j++) {
            c = *p++;
            if (c == '\n' ) {
                //putc( '\r', OutputFile );
                putc( '\n', OutputFile );
                if ( p >= f[i] ) break;
            } else {
                putc(c, OutputFile);
            }
        }

    }
}

/* hashing has the effect of
* arranging line in 7-bit bytes and then
* summing 1-s complement in 16-bit hunks
*/

readhash(
        int f
        )
{
    register unsigned shift;
    register char t;
    register int space;
    long sum = 1L;

    space = 0;
    if (!bflag) for (shift=0;(t=GetChar(f))!='\n';shift+=7) {
            if (t==(char)EOF && EndOfFile(f) )
                return(0);
            sum += (long)t << (shift%=HALFLONG);
        } else for (shift=0;;) {
            switch (t=GetChar(f)) {
                case '\t':
                case ' ':
                case '\r':
                    space++;
                    continue;
                default:
                    if ( t==(char)EOF && EndOfFile(f) ) {
                        return(0);
                    }
                    if (space) {
                        shift += 7;
                        space = 0;
                    }
                    sum += (long)t << (shift%=HALFLONG);
                    shift += 7;
                    continue;
                case '\n':
                    break;
            }
            break;
        }
    sum = low(sum) + high(sum);
    return((short)low(sum) + (short)high(sum));
}

void
mesg(
    char *s,
    char *t
    )
{
    fprintf(stderr,"diff: %s%s\n",s,t);
}

void
SetOutputFile (
              char *FileName
              )
{
    OutputFile = fopen(FileName, "ab");
    if (!OutputFile) {
        mesg("Unable to open: ", FileName);
        done();
    }

}



PVOID
Open(
    const char *FileName,
    const char *Mode,
    DWORD      Size
    )
{
    PFILEMAP    FileMap = NULL;

    FileMap = (PFILEMAP)malloc(sizeof(FILEMAP));

    if ( FileMap ) {

        FileMap->Access = 0;
        FileMap->Share  = FILE_SHARE_READ | FILE_SHARE_WRITE;

        while ( *Mode ) {

            switch ( *Mode ) {

                case 'r':
                    FileMap->Access |= GENERIC_READ;
                    FileMap->Create = OPEN_EXISTING;
                    break;

                case 'w':
                    FileMap->Access |= GENERIC_WRITE;
                    FileMap->Create = CREATE_ALWAYS;
                    break;

                case 'a':
                    FileMap->Access += GENERIC_WRITE;
                    FileMap->Create = OPEN_ALWAYS;
                    break;

                case '+':
                    FileMap->Access |= (GENERIC_READ | GENERIC_WRITE);
                    break;

                default:
                    break;
            }

            Mode++;
        }

        FileMap->FileHandle = CreateFile(
                                        FileName,
                                        FileMap->Access,
                                        FileMap->Share,
                                        NULL,
                                        FileMap->Create,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );

        if ( FileMap->FileHandle != INVALID_HANDLE_VALUE ) {

            FileMap->Size       = GetFileSize( FileMap->FileHandle, NULL );
            FileMap->Allocated  = (FileMap->Access == GENERIC_READ) ? FileMap->Size : Size;

            FileMap->MapHandle = CreateFileMapping(
                                                  FileMap->FileHandle,
                                                  NULL,
                                                  (FileMap->Access & GENERIC_WRITE) ? PAGE_READWRITE : PAGE_READONLY,
                                                  0,
                                                  (FileMap->Access == GENERIC_READ) ? 0 : (DWORD)Size,
                                                  NULL
                                                  );

            if ( FileMap->MapHandle ) {

                FileMap->Base = MapViewOfFile(
                                             FileMap->MapHandle,
                                             (FileMap->Access & GENERIC_WRITE) ? FILE_MAP_ALL_ACCESS : FILE_MAP_READ,
                                             0,
                                             0,
                                             (FileMap->Access == GENERIC_READ) ? 0 : Size
                                             );

                if ( FileMap->Base ) {

                    if ( FileMap->Create == OPEN_ALWAYS ) {
                        FileMap->Offset = FileMap->Size;
                    }
                    goto Done;
                }

                CloseHandle( FileMap->MapHandle );
            }

            CloseHandle( FileMap->FileHandle );
        }

        free( FileMap );
        FileMap = NULL;
    }

    Done:
    return (PVOID)FileMap;
}


int
Close (
      PVOID   Map
      )
{
    PFILEMAP    FileMap = (PFILEMAP)Map;

    UnmapViewOfFile( FileMap->Base );
    CloseHandle( FileMap->MapHandle );

    if ( FileMap->Access & GENERIC_WRITE ) {

        SetFilePointer( FileMap->FileHandle,
                        FileMap->Size,
                        0,
                        FILE_BEGIN );

        SetEndOfFile( FileMap->FileHandle );
    }

    CloseHandle( FileMap->FileHandle );

    free( FileMap );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dosdev\makefile.inc ===
$(O)\dosdev.res: dosdev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dload\dbghelp.c ===
#include "sdktoolspch.h"
#pragma hdrstop

#include <dbghelp.h>

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(dbghelp)
{
    DLPENTRY(MiniDumpWriteDump)
};

DEFINE_PROCNAME_MAP(dbghelp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dload\sdktoolspch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\diskperf\diskperf.h ===
/*++

    Copyright (c) 1991-1999  Microsoft Corporation

Module:

    diskperf.h

Abstract:

    definitions for diskperf.exe

Revision History:

    9-Dec-92 a-robw (Bob Watson)    Created

--*/
#ifndef _DISKPERF_H_
#define _DISKPERF_H_

#define DP_BOOT_START   0
#define DP_SYSTEM_START 1
#define DP_AUTO_START   2
#define DP_DEMAND_START 3
#define DP_NEVER_START  4
#define DP_UNDEFINED    5

// Dialog Box ID's
#define IDD_DP_EXPLAIN                  101
#define IDD_DP_HELP                     107
#define IDC_STATIC                      -1

//
//  Stringtable String ID's
//

#define DP_START_VALUE          100
#define DP_THIS_SYSTEM          101

#define DP_START_AT_BOOT        102
#define DP_START_AT_START       103
#define DP_START_AUTOMATICALLY  104
#define DP_START_ON_DEMAND      105
#define DP_START_NEVER          106
#define DP_START_UNDEFINED      107
#define DP_LOAD_STATUS_BASE     DP_START_AT_BOOT

#define DP_CMD_HELP_1           201
#define DP_CMD_HELP_2           202
#define DP_CMD_HELP_3           203
#define DP_CMD_HELP_4           204
#define DP_CMD_HELP_5           205
#define DP_CMD_HELP_6           206
#define DP_CMD_HELP_7           207
#define DP_CMD_HELP_8           208
#define DP_CMD_HELP_9           209
#define DP_CMD_HELP_10          210
#define DP_CMD_HELP_11          211
#define DP_CMD_HELP_12          212
#define DP_CMD_HELP_13          213
#define DP_CMD_HELP_14          214
#define DP_CMD_HELP_15          215
#define DP_CMD_HELP_16          216
#define DP_CMD_HELP_START       DP_CMD_HELP_1
#define DP_CMD_HELP_END         DP_CMD_HELP_16

#define DP_HELP_TEXT_1          301
#define DP_HELP_TEXT_2          302
#define DP_HELP_TEXT_3          303
#define DP_HELP_TEXT_4          304
#define DP_HELP_TEXT_5          305
#define DP_HELP_TEXT_6          306
#define DP_HELP_TEXT_7          307
#define DP_HELP_TEXT_8          308
#define DP_HELP_TEXT_9          309
#define DP_HELP_TEXT_10         310
#define DP_HELP_TEXT_11         311
#define DP_HELP_TEXT_12         312
#define DP_HELP_TEXT_13         313
#define DP_HELP_TEXT_START      DP_HELP_TEXT_1
#define DP_HELP_TEXT_END        DP_HELP_TEXT_13

#define DP_CURRENT_FORMAT       401
#define DP_UNABLE_READ_START    402
#define DP_UNABLE_READ_REGISTRY 403
#define DP_UNABLE_CONNECT       404
#define DP_UNABLE_MODIFY_VALUE  405
#define DP_NEW_DISKPERF_STATUS  406
#define DP_REBOOTED             407
#define DP_STATUS_FORMAT        408
#define DP_TEXT_FORMAT          409
#define DP_ENHANCED             410
#define DP_DISCLAIMER           411
#define DP_PHYSICAL             412
#define DP_LOGICAL              413
#define DP_CURRENT_FORMAT1      414
#define DP_NEW_DISKPERF_STATUS1 415
#define DP_NOCHANGE             416
#define DP_PERMANENT_FORMAT     417
#define DP_PERMANENT_FORMAT1    418
#define DP_PERMANENT_FORMAT2    419
#define DP_PERMANENT_IOCTL      420

#endif // _DISKPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dload\imagehlp.c ===
#include "sdktoolspch.h"
#pragma hdrstop

#define _IMAGEHLP_SOURCE_
#include <imagehlp.h>

static
PIMAGE_NT_HEADERS
IMAGEAPI
CheckSumMappedFile (
    PVOID BaseAddress,
    DWORD FileLength,
    PDWORD HeaderSum,
    PDWORD CheckSum
    )
{
    return NULL;
}

static
BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN  HANDLE      FileHandle,
    IN  WORD        TypeFilter,
    OUT PDWORD      CertificateCount,
    IN OUT PDWORD   Indices OPTIONAL,
    IN  DWORD       IndexCount  OPTIONAL
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetCertificateData(
    IN  HANDLE              FileHandle,
    IN  DWORD               CertificateIndex,
    OUT LPWIN_CERTIFICATE   Certificate,
    IN OUT PDWORD           RequiredLength
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   CertificateHeader
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetDigestStream(
    IN      HANDLE  FileHandle,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
MapAndLoad(
    LPSTR ImageName,
    LPSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    )
{
    return FALSE;
}

static
BOOL
StackWalk(
    DWORD                           MachineType,
    HANDLE                          hProcess,
    HANDLE                          hThread,
    LPSTACKFRAME                    StackFrame32,
    LPVOID                          ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE    ReadMemory32,
    PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccess32,
    PGET_MODULE_BASE_ROUTINE        GetModuleBase32,
    PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress32
    )
{
    return FALSE;
}

static
BOOL
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
SymCleanup(
    IN  HANDLE              hProcess
    )
{
    return FALSE;
}

static
LPVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{
    return NULL;
}

static
LPVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return NULL;
}

static
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    )
{
    return 0;
}

static
DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr
    )
{
    return 0;
}

static
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    )
{
    if (ModuleInfo != NULL) {
        DWORD dwSize = ModuleInfo->SizeOfStruct;
        ZeroMemory(ModuleInfo, dwSize);
        ModuleInfo->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULE64  ModuleInfo
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PIMAGEHLP_MODULEW64  ModuleInfo
    )
{
    return FALSE;
}


static
DWORD
IMAGEAPI
SymGetOptions(
    VOID
    )
{
    return 0;
}

static
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD               Address,
    OUT PDWORD              Displacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    )
{
    if (Displacement != NULL) {
        *Displacement = 0;
    }
    if (Symbol != NULL) {
        DWORD dwSize = Symbol->SizeOfStruct;
        ZeroMemory(Symbol, dwSize);
        Symbol->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{
    if (Displacement != NULL) {
        *Displacement = 0;
    }
    if (Symbol != NULL) {
        DWORD dwSize = Symbol->SizeOfStruct;
        ZeroMemory(Symbol, dwSize);
        Symbol->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     InvadeProcess
    )
{
    return FALSE;
}

static
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return FALSE;
}

static
DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return FALSE;
}

static
DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  PMODLOAD_DATA   Data,
    IN  DWORD           Flags
    )
{
    return FALSE;
}

static
DWORD
IMAGEAPI
SymSetOptions(
    DWORD   UserOptions
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL  sym,
    OUT LPSTR             UnDecName,
    OUT DWORD             UnDecNameLength
    )
{
    if (UnDecName != NULL && UnDecNameLength > 0) {
        UnDecName[0] = '\0';
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    if (UnDecName != NULL && UnDecNameLength > 0) {
        UnDecName[0] = '\0';
    }

    return FALSE;
}

static
DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    if (outputString != NULL && maxStringLength > 0) {
        outputString[0] = '\0';
    }

    return FALSE;
}

static
BOOL
UnMapAndLoad(
    PLOADED_IMAGE pLi
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(imagehlp)
{
    DLPENTRY(CheckSumMappedFile)
    DLPENTRY(ImageEnumerateCertificates)
    DLPENTRY(ImageGetCertificateData)
    DLPENTRY(ImageGetCertificateHeader)
    DLPENTRY(ImageGetDigestStream)
    DLPENTRY(MapAndLoad)
    DLPENTRY(StackWalk)
    DLPENTRY(StackWalk64)
    DLPENTRY(SymCleanup)
    DLPENTRY(SymFunctionTableAccess)
    DLPENTRY(SymFunctionTableAccess64)
    DLPENTRY(SymGetModuleBase)
    DLPENTRY(SymGetModuleBase64)
    DLPENTRY(SymGetModuleInfo)
    DLPENTRY(SymGetModuleInfo64)
    DLPENTRY(SymGetModuleInfoW64)
    DLPENTRY(SymGetOptions)
    DLPENTRY(SymGetSymFromAddr)
    DLPENTRY(SymGetSymFromAddr64)
    DLPENTRY(SymInitialize)
    DLPENTRY(SymLoadModule)
    DLPENTRY(SymLoadModule64)
    DLPENTRY(SymLoadModuleEx)
    DLPENTRY(SymSetOptions)
    DLPENTRY(SymUnDName)
    DLPENTRY(SymUnDName64)
    DLPENTRY(UnDecorateSymbolName)
    DLPENTRY(UnMapAndLoad)
};

DEFINE_PROCNAME_MAP(imagehlp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dosdev\dosdev.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    User mode beep program.  This program simply beeps at the frequency
    specified on the command line and for the time specified on the
    command line (in milliseconds).

Author:

    01-Dec-1992 Steve Wood (stevewo)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#define DEVICE_NAME_SIZE  (20 * 1024)
#define TARGET_PATH_SIZE  (20 * 1024)

UCHAR DeviceNames[ DEVICE_NAME_SIZE ];
UCHAR TargetPath[ TARGET_PATH_SIZE ];

typedef struct _DEVICE_LINK {
    PCHAR LinkName;
    ULONG LinkTargetLength;
    PCHAR LinkTarget;
    PCHAR DriveType;
    DWORD LogicalDriveBit;
} DEVICE_LINK, *PDEVICE_LINK;

ULONG NumberOfDriveLetters;
ULONG NumberOfDevices;
DEVICE_LINK DriveLetters[ 4096 ];
DEVICE_LINK Devices[ 4096 ];

void
Usage( void )
{
    fprintf( stderr, "usage: DOSDEV [-a] [-s] [-h] [[-r] [-d [-e]] DeviceName [TargetPath]]\n" );
    exit( 1 );
}

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    );

char *DriveTypes[] = {
    "Unknown",
    "NoRootDir",
    "Removable",
    "Fixed",
    "Remote",
    "CDRom",
    "RamDisk"
};

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    )
{
    char *s;

    printf( "%s%s = ", Msg, Name );
    s = Target;
    while (*s && cchTarget != 0) {
        if (s > Target) {
            printf( " ; " );
            }
        printf( "%s", s );
        while (*s++) {
            if (!cchTarget--) {
                cchTarget = 0;
                break;
                }
            }
        }
}

int
GetSystemPartitionFromRegistry(
    char*  lpSystemPartition
    )

{
    LONG    r;
    HKEY    key;
    DWORD   bytes;

    r = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM\\Setup", 0, KEY_QUERY_VALUE,
                     &key);
    if (r) {
        printf("RegOpenKeyEx failed with %d\n", r);
        return 0;
    }

    bytes = MAX_PATH;
    r = RegQueryValueEx(key, "SystemPartition", NULL, NULL, lpSystemPartition,
                        &bytes);
    RegCloseKey(key);
    if (r) {
        printf("RegQueryValueEx failed with %d\n", r);
        return 0;
    }

    return 1;
}

int
__cdecl
CompareDeviceLink(
    const void *p1,
    const void *p2
    )
{
    return _stricmp( ((PDEVICE_LINK)p1)->LinkName, 
                     ((PDEVICE_LINK)p2)->LinkName );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD cch, i;
    char c, *s;
    char RootDir[ 4 ];
    DWORD dwFlags;
    DWORD UnknownLogicalDrives;
    BOOL fShowOnlyDrives, fSystemPartition;
    LPSTR lpDeviceName;
    LPSTR lpTargetPath;
    PDEVICE_LINK p;
    char systemBuffer[MAX_PATH];

    lpDeviceName = NULL;
    lpTargetPath = NULL;
    fShowOnlyDrives = TRUE;
    fSystemPartition = FALSE;
    dwFlags = 0;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch (tolower( c )) {
                    case '?':
                    case 'h':
                        Usage();

                    case 'e':
                        dwFlags |= DDD_EXACT_MATCH_ON_REMOVE;
                        break;

                    case 'd':
                        dwFlags |= DDD_REMOVE_DEFINITION;
                        break;

                    case 'r':
                        dwFlags |= DDD_RAW_TARGET_PATH;
                        break;

                    case 'a':
                        fShowOnlyDrives = FALSE;
                        break;

                    case 's':
                        fSystemPartition = TRUE;
                        dwFlags |= DDD_RAW_TARGET_PATH;
                        break;
                    }
                }
            }
        else
        if (lpDeviceName == NULL) {
            lpDeviceName = s;
            }
        else
        if (lpTargetPath == NULL) {
            lpTargetPath = s;
            }
        else {
            Usage();
            }
        }

    if (fSystemPartition) {
        lpTargetPath = systemBuffer;
        if (!GetSystemPartitionFromRegistry(lpTargetPath)) {
            exit( 1 );
            }
        }

    if (lpDeviceName == NULL && lpTargetPath == NULL) {
        cch = QueryDosDevice( NULL,
                              DeviceNames,
                              sizeof( DeviceNames )
                            );
        if (cch == 0) {
            fprintf( stderr, "DOSDEV: Unable to query device names - %u\n", GetLastError() );
            exit( 1 );
            }

        s = DeviceNames;
        while (*s) {
            cch = QueryDosDevice( s,
                                  TargetPath,
                                  sizeof( TargetPath )
                                );
            if (cch == 0) {
                sprintf( TargetPath, "*** unable to query target path - %u ***", GetLastError() );
                }
            else {
                if (strlen( s ) == 2 && s[1] == ':') {
                    p = &DriveLetters[ NumberOfDriveLetters++ ];

                    sprintf( RootDir, "%s\\", s );
                    p->DriveType = DriveTypes[ GetDriveType( RootDir ) ];
                    p->LogicalDriveBit = 1 << (s[0] - 'A');
                    }
                else {
                    p = &Devices[ NumberOfDevices++ ];
                    }

                p->LinkName = s;
                p->LinkTargetLength = cch;
                p->LinkTarget = malloc( cch + 1 );
                memmove( p->LinkTarget, TargetPath, cch );
                }

            while (*s++)
                ;
            }

        qsort( &DriveLetters[0],
               NumberOfDriveLetters,
               sizeof( DEVICE_LINK ),
               CompareDeviceLink
             );

        UnknownLogicalDrives = GetLogicalDrives();
        for (i=0; i<NumberOfDriveLetters; i++) {
            p = &DriveLetters[ i ];
            DisplayDeviceTarget( "", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( " [%s]", p->DriveType );
            if (UnknownLogicalDrives & p->LogicalDriveBit) {
                UnknownLogicalDrives ^= p->LogicalDriveBit;
                }
            else {
                printf( " *** LOGICAL DRIVE BIT NOT SET ***" );
                }
            printf( "\n" );
            }

        if (UnknownLogicalDrives) {
            for (i=0; i<26; i++) {
                if (UnknownLogicalDrives & (1 << i)) {
                    printf( "%c: = *** LOGICAL DRIVE BIT SET BUT NO DRIVE LETTER ***\n",
                            'A' + i
                          );
                    }
                }
            }

        if (!fShowOnlyDrives) {
            printf( "\n" );
            qsort( &Devices[0],
                   NumberOfDevices,
                   sizeof( DEVICE_LINK ),
                   CompareDeviceLink
                 );

            for (i=0; i<NumberOfDevices; i++) {
                p = &Devices[ i ];
                DisplayDeviceTarget( "", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                printf( "\n" );
                }
            }

        exit( 0 );
        }

    if (lpDeviceName == NULL) {
        Usage();
        }
    else
    if (!(dwFlags & DDD_REMOVE_DEFINITION) && lpTargetPath == NULL) {
        Usage();
        }

    cch = QueryDosDevice( lpDeviceName,
                          TargetPath,
                          sizeof( TargetPath )
                        );
    if (cch != 0) {
        DisplayDeviceTarget( "Current definition: ", lpDeviceName, TargetPath, cch );
        printf( "\n" );
        }

    if (!DefineDosDevice( dwFlags, lpDeviceName, lpTargetPath )) {
        fprintf( stderr,
                 "DOSDEV: Unable to %s device name %s - %u\n",
                 (dwFlags & DDD_REMOVE_DEFINITION) ? "delete"
                                                   : "define",

                 lpDeviceName,
                 GetLastError()
               );
        }
    else {
        cch = QueryDosDevice( lpDeviceName,
                              TargetPath,
                              sizeof( TargetPath )
                            );
        if (cch != 0) {
            DisplayDeviceTarget( "Current definition: ", lpDeviceName, TargetPath, cch );
            printf( "\n" );
            }
        else {
            printf( "%s deleted.\n", lpDeviceName );
            }
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\drivemap\drivemap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    drivemap.c

Abstract:

    User mode program to determine which ide/scsi device each drive letter is
    connected to.

Author:

    01-Nov-1995 Peter Wieland (peterwie)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include <winioctl.h>
#include <ntddscsi.h>

#define NUM_DRIVES          26  // 26 drive letters
#define MAX_FLOPPY_OFFSET   1

#define DRIVE_NAME_BUFFER_SIZE  32

enum    {UNKNOWN = 0, FLOPPY, SCSI, IDE};

void processDevice(DWORD driveLetterOffset);

int __cdecl main(int argc, char *argv[])    {

    DWORD   dwT, i, Index;

    dwT = GetLogicalDrives();

    if(dwT == 0)    {
        printf("Error getting device letters (%d)\n", GetLastError());
        exit(-2);
    }

    Index = 1;

    for( i = 0; i < NUM_DRIVES; i++ ) {
        if(Index & dwT) {
            processDevice(i);
        }
        Index <<= 1;
    }

    return 0;
}

//
// processDevice(driveLetterOffset);
//  in:     driveLetterOffset - offset of the drive letter relative to 'A'
//

void processDevice(DWORD driveLetterOffset)     {

    LPTSTR          next;
    char            chBuf[ DRIVE_NAME_BUFFER_SIZE ];

    HANDLE          hDevice = INVALID_HANDLE_VALUE;
    SCSI_ADDRESS           scsiAddress;
    DISK_CONTROLLER_NUMBER atAddress;
    DWORD           dwSize;
    UCHAR           diskType = UNKNOWN;
    DWORD           offset = driveLetterOffset;

    // only do processing on drive letters

    try {
        _snprintf(
            chBuf, (sizeof(chBuf) / sizeof(chBuf[0])),
            "\\\\.\\%c:", ('A' + offset)
            );

        // Check if drive letter is 'A' or 'B'
        if(offset <= MAX_FLOPPY_OFFSET)	{
            diskType = FLOPPY;
            hDevice = INVALID_HANDLE_VALUE;
            goto typeKnown;
        }

        hDevice = CreateFile(chBuf,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if(hDevice == INVALID_HANDLE_VALUE)     {
//              printf("Error opening device %s (%d)\n", 
//                           chBuf, GetLastError());
            leave;
        }

        // send down the scsi query first (yes, i'm biased)
        if(!DeviceIoControl(hDevice,
                            IOCTL_SCSI_GET_ADDRESS,
                            NULL,
                            0,
                            &scsiAddress,
                            sizeof(SCSI_ADDRESS),
                            &dwSize,
                            NULL))  {

            // if the ioctl was invalid, then we don't know the disk type yet,
            // so just keep going
            // if there was another error, skip to the next device
            if(GetLastError() != ERROR_INVALID_FUNCTION)    {
                leave;
            }

        } else	{
            // if the ioctl was valid, then we're a scsi device (or a scsiport
            // controlled device in the case of atapi) - go on to the end
            diskType = SCSI;
            goto typeKnown;
        }

        if(!DeviceIoControl(hDevice,
                            IOCTL_DISK_CONTROLLER_NUMBER,
                            NULL,
                            0,
                            &atAddress,
                            sizeof(DISK_CONTROLLER_NUMBER),
                            &dwSize,
                            NULL)) {
            // if the ioctl was invalid, then we still don't know the
            // disk type - continue on.

            if(GetLastError() != ERROR_INVALID_FUNCTION) leave;

        } else {

            // if the ioctl was valid, then we're an IDE device

            diskType = IDE;
            goto typeKnown;

        }

        diskType = UNKNOWN;

typeKnown:
        printf("%s -> ", chBuf);

        switch(diskType)    {
            case FLOPPY:
                printf("Floppy drive\n");
                break;

            case SCSI:
                printf("Port %d, Path %d, Target %d, Lun %d\n",
                    scsiAddress.PortNumber,
                    scsiAddress.PathId,
                    scsiAddress.TargetId,
                    scsiAddress.Lun);
                break;

            case IDE:
                printf("Controller %d, Disk %d\n",
                    atAddress.ControllerNumber,
                    atAddress.DiskNumber);
                break;

            default:
                printf("Unknown\n");
                break;
        }
    } finally {

        // close the file handle if we've opened it
        if(hDevice != INVALID_HANDLE_VALUE) CloseHandle(hDevice);
        }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dumpclip\dumpclip.c ===
#include <windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>

__cdecl
main (c, v)
int c;
char *v[];
{
    HANDLE hMem;
    LPSTR lpMem;
    FILE *OutputFile;

    if (c <= 1) {
        OutputFile = stdout;
        }
    else
    if (c == 2) {
        OutputFile = fopen( v[1], "w" );
        if (OutputFile == NULL) {
            fprintf( stderr, "DUMPCLIP: unable to open destination file '%s' (%u)\n", v[1], GetLastError() );
            return 1;
            }
        }

    if (!OpenClipboard( NULL )) {
        fprintf( stderr, "DUMPCLIP: unable to open clipboard (%u)\n", GetLastError() );
        return 1;
        }

    _setmode( _fileno( OutputFile ), _O_BINARY );
    hMem = GetClipboardData( CF_OEMTEXT );
    if (hMem != NULL) {
        lpMem = GlobalLock( hMem );
        if (lpMem) {
            fprintf( OutputFile, "%s", lpMem );
            }
        GlobalUnlock( hMem );
        }
    else {
        fprintf( stderr, "DUMPCLIP: unable to get clipboard data as text (%u)\n", GetLastError() );
        }

    CloseClipboard();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\du\du.c ===
// du - simple disk usage program

// If UNICODE/_UNICODE is turned on, we need to link with
// wsetargv.lib (not setargv.lib) and with UMENTRY=wmain
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <tchar.h>
#include <wchar.h>
#include <string.h>
#include <process.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <locale.h>
#include <windows.h>

typedef struct USESTAT USESTAT;
typedef struct EXTSTAT EXTSTAT;
typedef USESTAT *PUSESTAT;

struct USESTAT {
    DWORDLONG    cchUsed;                    // bytes used in all files
    DWORDLONG    cchAlloc;                   // bytes allocated in all files
    DWORDLONG    cchCompressed;              // compressed bytes in all files
    DWORDLONG    cchDeleted;                 // bytes in deleted files
    DWORDLONG    cFile;                      // number of files
    };

struct EXTSTAT {
    EXTSTAT *Next;
    TCHAR *Extension;
    USESTAT Stat;
};

EXTSTAT *ExtensionList = NULL;
int ExtensionCount = 0;

#define CLEARUSE(use)                                   \
        {   (use).cchUsed       = (DWORDLONG)0;         \
            (use).cchAlloc      = (DWORDLONG)0;         \
            (use).cchDeleted    = (DWORDLONG)0;         \
            (use).cchCompressed = (DWORDLONG)0;         \
            (use).cFile         = (DWORDLONG)0;         \
        }


#define ADDUSE(sum,add)                                 \
        {   (sum).cchUsed       += (add).cchUsed;       \
            (sum).cchAlloc      += (add).cchAlloc;      \
            (sum).cchDeleted    += (add).cchDeleted;    \
            (sum).cchCompressed += (add).cchCompressed; \
            (sum).cFile         += (add).cFile;         \
        }

#define DWORD_SHIFT     (sizeof(DWORD) * 8)

#define SHIFT(c,v)      {c--; v++;}


DWORD  gdwOutputMode;
HANDLE ghStdout;

int cDisp;                              //  number of summary lines displayed
BOOL fExtensionStat = FALSE;            //  TRUE gather statistics by extension
BOOL fNodeSummary = FALSE;              //  TRUE => only display top-level
BOOL fShowDeleted = FALSE;              //  TRUE => show deleted files information
BOOL fThousandSeparator = TRUE;         //  TRUE => use thousand separator in output
BOOL fShowCompressed = FALSE;           //  TRUE => show compressed file info
BOOL fSubtreeTotal = FALSE;             //  TRUE => show info in subtree total form (add from bottom up)
BOOL fUnc = FALSE;                      //  Set if we're checking a UNC path.
TCHAR *pszDeleted = TEXT("deleted\\*.*");
TCHAR *pszWild = TEXT("*.*");

long        bytesPerAlloc;
int         bValidDrive;
DWORDLONG   totFree;
DWORDLONG   totDisk;

TCHAR  buf[MAX_PATH];
TCHAR  root[] = TEXT("?:\\");

USESTAT DoDu (TCHAR *dir);
void TotPrint (PUSESTAT puse, TCHAR *p);

TCHAR ThousandSeparator[8];

TCHAR *
FormatFileSize(
    DWORDLONG FileSize,
    TCHAR *FormattedSize,
    ULONG Width
    )
{

    TCHAR Buffer[ 100 ];
    TCHAR *s, *s1;
    ULONG DigitIndex, Digit;
    ULONG nThousandSeparator;
    DWORDLONG Size;

    nThousandSeparator = _tcslen(ThousandSeparator);
    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    Size = FileSize;
    while (Size != 0) {
        Digit = (ULONG)(Size % 10);
        Size = Size / 10;
        *--s = (TCHAR)(TEXT('0') + Digit);
        if ((++DigitIndex % 3) == 0 && fThousandSeparator) {
            // If non-null Thousand separator, insert it.
            if (nThousandSeparator) {
                s -= nThousandSeparator;
                _tcsncpy(s, ThousandSeparator, nThousandSeparator);
            }
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    }
    else
    if (fThousandSeparator && !_tcsncmp(s, ThousandSeparator, nThousandSeparator)) {
        s += nThousandSeparator;
    }

    Size = _tcslen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        _tcscpy( s1, s );
    } else {
        _tcscpy( FormattedSize, s );
    }

    return FormattedSize;
}


#ifdef UNICODE
int __cdecl wmain(int c, wchar_t **v, wchar_t **envp)
#else
int __cdecl main(int c, char *v[])
#endif
{
    int         tenth, pct;
    int         bValidBuf;
    DWORDLONG   tmpTot, tmpFree;
    DWORD       cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    USESTAT     useTot, useTmp;
    TCHAR       Buffer[MAX_PATH];
    TCHAR       *p;
    UINT Codepage;
    char achCodepage[6] = ".OCP";

    ghStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleMode(ghStdout, &gdwOutputMode);
    gdwOutputMode &= ~ENABLE_PROCESSED_OUTPUT;

    /*
     * This is mainly here as a good example of how to set a character-mode
     * application's codepage.
     * This affects C-runtime routines such as mbtowc(), mbstowcs(), wctomb(),
     * wcstombs(), mblen(), _mbstrlen(), isprint(), isalpha() etc.
     * To make sure these C-runtimes come from msvcrt.dll, use TARGETLIBS in
     * the sources file, together with TARGETTYPE=PROGRAM (and not UMAPPL?)
     */
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%3.4d", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    SHIFT (c, v);

    if (GetLocaleInfo(GetUserDefaultLCID(),
                      LOCALE_STHOUSAND,
                      Buffer,
                      sizeof(ThousandSeparator)/sizeof(TCHAR))) {
#ifdef UNICODE
        _tcscpy(ThousandSeparator, Buffer);
#else
        CharToOemA(Buffer, ThousandSeparator);
#endif
    }
    else {
        _tcscpy(ThousandSeparator, TEXT(","));
    }

    while (c && (**v == TEXT('/') || **v == TEXT('-')))
    {
        if (!_tcscmp (*v + 1, TEXT("e"))) {
            fExtensionStat = TRUE;
        } else
        if (!_tcscmp (*v + 1, TEXT("s")))
            fNodeSummary = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("d")))
            fShowDeleted = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("p")))
            fThousandSeparator = FALSE;
        else
        if (!_tcscmp (*v + 1, TEXT("c")))
                fShowCompressed = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("t")))
                fSubtreeTotal = TRUE;
        else
        {
            _fputts( TEXT("Usage: DU [/e] [/d] [/p] [/s] [/c] [/t] [dirs]\n")
                     TEXT("where:\n")
                     TEXT("       /e - displays information by extension.\n")
                     TEXT("       /d - displays informations about [deleted] subdirectories.\n")
                     TEXT("       /p - displays numbers plainly, without thousand separators.\n")
                     TEXT("       /s - displays summary information only.\n")
                     TEXT("       /c - displays compressed file information.\n")
                     TEXT("       /t - displays information in subtree total form.\n"),
                     stderr);
            exit (1);
        }
        SHIFT (c, v);
    }

    if (c == 0)
    {
        GetCurrentDirectory( MAX_PATH, (LPTSTR)buf );

        root[0] = buf[0];
        if( bValidDrive = GetDiskFreeSpace( root,
                                            &cSecsPerClus,
                                            &cBytesPerSec,
                                            &cFreeClus,
                                            &cTotalClus ) == TRUE )
        {
            bytesPerAlloc = cBytesPerSec * cSecsPerClus;
            totFree       = (DWORDLONG)bytesPerAlloc * cFreeClus;
            totDisk       = (DWORDLONG)bytesPerAlloc * cTotalClus;
        }
        useTot = DoDu (buf);
        if (fNodeSummary)
            TotPrint (&useTot, buf);
    }
    else
    {
        CLEARUSE (useTot);

        while (c)
        {
            LPTSTR FilePart;

            bValidBuf = GetFullPathName( *v, MAX_PATH, buf, &FilePart);

            if ( bValidBuf )
            {
                if ( buf[0] == TEXT('\\') ) {

                    fUnc        = TRUE;
                    bValidDrive = TRUE;
                    bytesPerAlloc = 1;
                } else {
                    root[0] = buf[0];
                    if( bValidDrive = GetDiskFreeSpace( root,
                                                        &cSecsPerClus,
                                                        &cBytesPerSec,
                                                        &cFreeClus,
                                                        &cTotalClus ) == TRUE)
                    {
                        bytesPerAlloc = cBytesPerSec * cSecsPerClus;
                        totFree       = (DWORDLONG)bytesPerAlloc * cFreeClus;
                        totDisk       = (DWORDLONG)bytesPerAlloc * cTotalClus;
                    } else
                        _tprintf (TEXT("Invalid drive or directory %s\n"), *v );
                }

                if( bValidDrive && (GetFileAttributes( buf ) & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
                {
                    useTmp = DoDu (buf);
                    if (fNodeSummary)
                        TotPrint (&useTmp, buf);
                    ADDUSE (useTot, useTmp);
                }
            }
            else
                _tprintf (TEXT("Invalid drive or directory %s\n"), *v );
            SHIFT (c, v);
        }
    }

    if (cDisp != 0)
    {
        if (cDisp > 1)
            TotPrint (&useTot, TEXT("Total"));

        /* quick full-disk test */
        if ( !fUnc ) {
            if (totFree == 0)
                _putts (TEXT("Disk is full"));
            else
            {
                tmpTot = (totDisk + 1023) / 1024;
                tmpFree = (totFree + 1023) / 1024;
                pct = (DWORD)(1000 * (tmpTot - tmpFree) / tmpTot);
                tenth = pct % 10;
                pct /= 10;

                // Disable processing so Middle Dot won't beep
                // Middle Dot 0x2022 aliases to ^G when using Raster Fonts
                SetConsoleMode(ghStdout, gdwOutputMode);
                _tprintf(TEXT("%s/"), FormatFileSize( totDisk-totFree, Buffer, 0 ));
                _tprintf(TEXT("%s "), FormatFileSize( totDisk, Buffer, 0 ));
                // Re-enable processing so newline works
                SetConsoleMode(ghStdout, gdwOutputMode | ENABLE_PROCESSED_OUTPUT);

                _tprintf (TEXT("%d.%d%% of disk in use\n"), pct, tenth);
            }
        }
    }

    if (fExtensionStat) {
        int i;

        _tprintf( TEXT("\n") );
        for (i = 0; i < ExtensionCount; i++) {
            TotPrint( &ExtensionList[i].Stat, ExtensionList[i].Extension );
        }
    }
    return( 0 );
}

int __cdecl ExtSearchCompare( const void *Key, const void *Element)
{
    return _tcsicmp( (TCHAR *)Key, ((EXTSTAT *) Element)->Extension );
}

int __cdecl ExtSortCompare( const void *Element1, const void *Element2)
{
    return _tcsicmp( ((EXTSTAT *) Element1)->Extension, ((EXTSTAT *) Element2)->Extension );
}

#define MYMAKEDWORDLONG(h,l) (((DWORDLONG)(h) << DWORD_SHIFT) + (DWORDLONG)(l))
#define FILESIZE(wfd)        MYMAKEDWORDLONG((wfd).nFileSizeHigh, (wfd).nFileSizeLow)
#define ROUNDUP(m,n)         ((((m) + (n) - 1) / (n)) * (n))

// Count the number of useable characters remaining in a null terminated string
// s of buffer length cch beyond and including a point specified by p

#define REMAINING_STRING(s, cch, p) (cch - (p - s) - 1)

USESTAT DoDu (TCHAR *dir)
{
    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    USESTAT use, DirUse;

    TCHAR pszSearchName[MAX_PATH];
    TCHAR *pszFilePart;

    DWORDLONG compressedSize;
    DWORD compHi, compLo;

    SIZE_T remaining;

    CLEARUSE(use);

    // Make a copy of the incoming directory name and append a trailing
    // slash if necessary. pszFilePart will point to the char just after
    // the slash, making it easy to build fully qualified filenames.
    //
    // Slap a null at the end of the string since strncpy doesn't.

    _tcsncpy(pszSearchName, dir, sizeof(pszSearchName)/sizeof(TCHAR) - 1);
    pszSearchName[sizeof(pszSearchName)/sizeof(TCHAR) - 1] = TEXT('\0');
    pszFilePart = pszSearchName + _tcslen(pszSearchName);

    remaining = REMAINING_STRING(pszSearchName,
                                 sizeof(pszSearchName)/sizeof(TCHAR),
                                 pszFilePart);

    if (pszFilePart > pszSearchName)
    {

        if (pszFilePart[-1] != TEXT('\\') && pszFilePart[-1] != TEXT('/'))
        {
            // Give up if we don't have enough string left

            if (!remaining) {

                return (use);
            }
            
            *pszFilePart++ = TEXT('\\');
            remaining -= 1;
        }
    }

    if (fShowDeleted &&
        remaining >= _tcslen(pszDeleted)) {

        // First count the size of all the files in the current deleted tree

        _tcscpy(pszFilePart, pszDeleted);

        hFind = FindFirstFile(pszSearchName, &wfd);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    use.cchDeleted += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                }
            } while (FindNextFile(hFind, &wfd));

            FindClose(hFind);
        }
    }

    // Give up if we can't put the wild chars at the end

    if (remaining < _tcslen(pszWild)) {

        return(use);
    }

    // Then count the size of all the file in the current tree.

    _tcscpy(pszFilePart, pszWild);

    hFind = FindFirstFile(pszSearchName, &wfd);
    
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                use.cchUsed += FILESIZE( wfd );
                use.cchAlloc += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                use.cFile++;

                compressedSize = FILESIZE(wfd);

                if (fShowCompressed && (wfd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED))
                {
                    _tcscpy(pszFilePart, wfd.cFileName);
                    compLo = GetCompressedFileSize(pszSearchName, &compHi);

                    if (compLo != (DWORD)-1 || GetLastError() == 0) {
                        compressedSize = MYMAKEDWORDLONG(compHi, compLo);
                    }
                }

                use.cchCompressed += compressedSize;

                //
                //  Accrue statistics by extension
                //

                if (fExtensionStat) {
                    TCHAR Ext[_MAX_EXT];
                    EXTSTAT *ExtensionStat;

                    _tsplitpath( wfd.cFileName, NULL, NULL, NULL, Ext );

                    while (TRUE) {

                        //
                        //  Find extension in list
                        //

                        ExtensionStat =
                            (EXTSTAT *) bsearch( Ext, ExtensionList,
                                                 ExtensionCount, sizeof( EXTSTAT ),
                                                 ExtSearchCompare );

                        if (ExtensionStat != NULL) {
                            break;
                        }

                        //
                        //  Extension not found, go add one and resort
                        //

                        ExtensionCount++;
                        {
                            void *pv = realloc( ExtensionList, sizeof( EXTSTAT ) * ExtensionCount);
                            if (pv) {
                                ExtensionList = (EXTSTAT *)pv;
                            } else {
                                _putts (TEXT("Out of memory"));
                            }
                        }

                        ExtensionList[ExtensionCount - 1].Extension = _tcsdup( Ext );
                        CLEARUSE( ExtensionList[ExtensionCount - 1].Stat );
                        qsort( ExtensionList, ExtensionCount, sizeof( EXTSTAT ), ExtSortCompare );
                    }

                    ExtensionStat->Stat.cchUsed += FILESIZE( wfd );
                    ExtensionStat->Stat.cchAlloc += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                    ExtensionStat->Stat.cchCompressed += compressedSize;
                    ExtensionStat->Stat.cFile++;
                }
            }

        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    if (!fNodeSummary && !fSubtreeTotal)
        TotPrint (&use, dir);

    // Now, do all the subdirs and return the current total.

    _tcscpy(pszFilePart, pszWild);
    hFind = FindFirstFile(pszSearchName, &wfd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                _tcsicmp (wfd.cFileName, TEXT("deleted")) &&
                _tcscmp  (wfd.cFileName, TEXT(".")) &&
                _tcscmp  (wfd.cFileName, TEXT("..")) &&
                remaining >= _tcslen(wfd.cFileName))
            {
                _tcscpy(pszFilePart, wfd.cFileName);

                DirUse = DoDu(pszSearchName);

                ADDUSE(use, DirUse);
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    if (fSubtreeTotal)
        TotPrint(&use, dir);
    
    return(use);
}


void TotPrint (PUSESTAT puse, TCHAR *p)
{
    static BOOL fFirst = TRUE;
    TCHAR  Buffer[MAX_PATH];
    TCHAR  *p1;

    if (fFirst) {
        //              XXX,XXX,XXX,XXX  XXX,XXX,XXX,XXX    xx,xxx,xxx    name
        _tprintf( TEXT("           Used        Allocated  %s%s     Files\n"),
                fShowCompressed ? TEXT("     Compressed  ") : TEXT(""),
        //                              XXX,XXX,XXX,XXX
                fShowDeleted ? TEXT("        Deleted  ") : TEXT("")
        //                           XXX,XXX,XXX,XXX
              );
        fFirst = FALSE;
    }

    // Disable processing so Middle Dot won't beep
    // Middle Dot 0x2022 aliases to ^G when using Raster Fonts
    SetConsoleMode(ghStdout, gdwOutputMode);
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cchUsed, Buffer, 15 ));
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cchAlloc, Buffer, 15 ));
    if (fShowCompressed) {
        _tprintf(TEXT("%s  "), FormatFileSize( puse->cchCompressed, Buffer, 15 ));
    }
    if (fShowDeleted) {
        _tprintf(TEXT("%s  "), FormatFileSize( puse->cchDeleted, Buffer, 15 ));
    }
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cFile, Buffer, 10 ));
    _tprintf(TEXT("%s"),p);
    // Re-enable processing so newline works
    SetConsoleMode(ghStdout, gdwOutputMode | ENABLE_PROCESSED_OUTPUT);
    _tprintf(TEXT("\n"));

    cDisp++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dumppo\dumppo.c ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1988-1991      **/
/*****************************************************************/

#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

PROCESSOR_POWER_POLICY      PAc, PDc, PCurrent;
SYSTEM_POWER_POLICY         Ac, Dc, Current;
SYSTEM_POWER_CAPABILITIES   Cap;
SYSTEM_POWER_STATUS         PS;
ADMINISTRATOR_POWER_POLICY  Admin;
SYSTEM_BATTERY_STATE        Batt;

typedef
VOID
(*PCUR_PRINT)(
    IN PVOID Context
    );

typedef
VOID
(*PCUR_ASSIGN)(
    PUCHAR      Variable,
    PUCHAR      Value
    );

ULONG                       CurType;
POWER_INFORMATION_LEVEL     CurInfo;
PVOID                       CurContext;
ULONG                       CurContextSize;
PCUR_PRINT                  CurPrint;
PCUR_ASSIGN                 CurAssign;
PUCHAR                      CurDesc;

PUCHAR                      CurValue;
BOOLEAN                     ItemUpdated;
BOOLEAN                     CurValueIsNumeric;

BOOLEAN                     Verbose1;
BOOLEAN                     Verbose2;



PUCHAR szBool[] = { "FALSE", "TRUE" };


typedef struct {
    ULONG   Flags;
    PUCHAR  String;
} DEFBITS, *PDEFBITS;

DEFBITS ActFlags[] = {
    POWER_ACTION_QUERY_ALLOWED,     "QueryApps",
    POWER_ACTION_UI_ALLOWED,        "UIAllowed",
    POWER_ACTION_OVERRIDE_APPS,     "OverrideApps",
    POWER_ACTION_DISABLE_WAKES,     "DisableWakes",
    POWER_ACTION_CRITICAL,          "Critical",
    0, NULL
    };

DEFBITS PsBatteryFlagBits[] = {
    BATTERY_FLAG_HIGH,              "high",
    BATTERY_FLAG_LOW,               "low",
    BATTERY_FLAG_CRITICAL,          "critical",
    BATTERY_FLAG_CHARGING,          "charing",
    0, NULL
    };




PUCHAR
ActionS(
    IN POWER_ACTION Act
    )
{
    static char line[50];
    PCHAR       p;

    switch (Act) {
        case PowerActionNone:          p = "None";          break;
        case PowerActionSleep:         p = "Sleep";         break;
        case PowerActionHibernate:     p = "Hibernate";     break;
        case PowerActionShutdown:      p = "Shutdown";      break;
        case PowerActionShutdownReset: p = "ShutdownReset"; break;
        case PowerActionShutdownOff:   p = "ShutdownOff";   break;
        default:
            sprintf(line, "Unknown action %x", Act);
            p = line;
            break;
    }

    return p;
}

PUCHAR
SysPower(
    IN SYSTEM_POWER_STATE   State
    )
{
    static char line[50];
    PCHAR       p;

    switch (State) {
        case PowerSystemUnspecified:    p = "Unspecified";      break;
        case PowerSystemWorking:        p = "Working";          break;
        case PowerSystemSleeping1:      p = "S1";               break;
        case PowerSystemSleeping2:      p = "S2";               break;
        case PowerSystemSleeping3:      p = "S3";               break;
        case PowerSystemHibernate:      p = "S4 - hibernate";   break;
        case PowerSystemShutdown:       p = "Shutdown";         break;
        default:
            sprintf(line, "Unknown power state %x", State);
            p = line;
            break;
    }

    return p;
}

PUCHAR
DynamicThrottle(
    IN  UCHAR   Throttle
    )
{
    static char line[50];
    PCHAR       p;

    switch (Throttle) {
        case PO_THROTTLE_NONE:      p = "None";         break;
        case PO_THROTTLE_CONSTANT:  p = "Constant";     break;
        case PO_THROTTLE_DEGRADE:   p = "Degrade";      break;
        case PO_THROTTLE_ADAPTIVE:  p = "Adaptive";     break;
        default:
            sprintf(line,"Unknown Dynamic Throttle state %x", Throttle);
            p = line;
            break;
    }
    return p;
}

PUCHAR
MicroSeconds(
    IN  ULONG   Time
    )
{
    static char line[256];
    PCHAR       p;
    ULONG       MicroSeconds;
    ULONG       MilliSeconds;
    ULONG       Seconds;
    ULONG       Minutes;
    ULONG       Hours;
    ULONG       Days;

    MicroSeconds = Time % 1000;
    MilliSeconds = Time / 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes      = Seconds / 60;
    Seconds      = Seconds % 60;

    Hours        = Minutes / 60;
    Minutes      = Minutes % 60;

    Days         = Hours / 24;
    Hours        = Hours % 24;

    if (Hours) {

        sprintf(
            line,
            "%d [%2d:%2d %ds %dms %dus]",
            Time,
            Hours,
            Minutes,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (Minutes) {

        sprintf(
            line,
            "%d [0:%2d %ds %dms %dus]",
            Time,
            Minutes,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (Seconds) {

        sprintf(
            line,
            "%d [%ds %dms %dus]",
            Time,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (MilliSeconds) {

        sprintf(
            line,
            "%d [%dms %dus]",
            Time,
            MilliSeconds,
            MicroSeconds
            );

    } else {

        sprintf(
            line,
            "%d [%dus]",
            Time,
            MicroSeconds
            );

    }
    p = line;
    return p;
}

VOID
GetBits (
    IN PUCHAR   Dest,
    IN ULONG    Flags,
    IN PDEFBITS DefBits
    )
{
    UCHAR   c;
    ULONG   i;

    c = 0;

    *Dest = 0;
    for (i=0; DefBits[i].Flags; i++) {
        if (Flags & DefBits[i].Flags) {
            if (c) {
                *Dest = c;
                Dest += 1;
            }
            strcpy(Dest, DefBits[i].String);
            Dest += strlen(DefBits[i].String);
            c  = '|';
        }
    }
}

VOID
PrintPowerStatus (
    VOID
    )
{
    ULONG   i;
    PUCHAR  Ls;
    UCHAR   Bf[200];

    switch (PS.ACLineStatus) {
        case AC_LINE_OFFLINE:       Ls = "off line";        break;
        case AC_LINE_ONLINE:        Ls = "on line";         break;
        case AC_LINE_BACKUP_POWER:  Ls = "backup power";    break;
        case AC_LINE_UNKNOWN:       Ls = "unknown";         break;
        default:                    Ls = "**invalid**";     break;
    }

    strcpy (Bf, "unkown");
    if (PS.BatteryFlag != BATTERY_FLAG_UNKNOWN) {
        GetBits(Bf, PS.BatteryFlag, PsBatteryFlagBits);
    }

    printf ("Win32 System power status\n"
            "AC line status..........: %s\n",   Ls);
    printf ("Battery flag............: %s\n",   Bf);
    printf ("Battery life percent....: %d\n",   PS.BatteryLifePercent);
    printf ("Battery full life time..: %d\n\n",   PS.BatteryFullLifeTime);
}

VOID
PrintBattStatus (
    VOID
    )
{
    ULONG   i;
    PUCHAR  Ls;
    UCHAR   Bf[200];

    printf ("AC on line..............: %s\n",   szBool[Batt.AcOnLine]);
    printf ("Battery present ........: %s\n",   szBool[Batt.BatteryPresent]);
    printf ("Charging................: %s\n",   szBool[Batt.Charging]);
    printf ("Discharging.............: %s\n",   szBool[Batt.Discharging]);
    printf ("Max Capacity............: %d\n",   Batt.MaxCapacity);
    printf ("Remaining Capacity......: %d",     Batt.RemainingCapacity);
    if (Batt.MaxCapacity) {
        printf (" %d%%\n", Batt.RemainingCapacity * 100 / Batt.MaxCapacity);
    } else {
        printf (" (divide by zero)%%\n");
    }

    printf ("Rate....................: %d\n",   Batt.Rate);
    printf ("Estimated time..........: %d\n",   Batt.EstimatedTime);
    printf ("Default alert 1 & 2.....: %d %d\n\n",Batt.DefaultAlert1, Batt.DefaultAlert2);
}

BOOLEAN
streql (
    PUCHAR  p1,
    PUCHAR  p2
    )
{
    return strcmp(p1, p2) == 0;
}

PUCHAR
_strtok (
    PUCHAR  Start
    )
{
    static PUCHAR   Location;
    PUCHAR          p;


    if (Start) {
        Location = Start;
    }

    for (p = Location; *p  &&  *p <'a' && *p >'z'; p++) ;
    if (!*p) {
        return NULL;
    }

    Start = p;
    for (; *p && *p >= 'a'  &&  *p <= 'z'; p++) ;
    if (*p) {
        *p++ = 0;
    }
    Location = p;
    return Start;
}


VOID
PrintCap (
    PVOID   Context
    )
{
    ULONG   i;

    puts   ("System power capabilties");
    printf ("Power Button Present....: %s\n",   szBool[Cap.PowerButtonPresent]);
    printf ("Sleep Button Present....: %s\n",   szBool[Cap.SleepButtonPresent]);
    printf ("Lid Present.............: %s\n",   szBool[Cap.LidPresent]);
    printf ("System states supported.: %s%s%s%s%s\n",
            Cap.SystemS1 ? "S1 " : "",
            Cap.SystemS2 ? "S2 " : "",
            Cap.SystemS3 ? "S3 " : "",
            Cap.SystemS4 ? "S4 " : "",
            Cap.SystemS5 ? "S5 " : ""
            );
    printf ("Hiber file reserved.....: %s\n",   szBool[Cap.HiberFilePresent]);
    printf ("Thermal control.........: %s\n",   szBool[Cap.ThermalControl]);
    printf ("CPU Throttle control....: %s\n",   szBool[Cap.ProcessorThrottle]);
    printf ("Processor min throttle..: %d\n",   Cap.ProcessorMinThrottle);
    printf ("Processor max throttle..: %d\n",   Cap.ProcessorMaxThrottle);
    printf ("Some disk will spindown.: %s\n", szBool[Cap.DiskSpinDown]);
    printf ("System batteries present: %s %s\n",
            szBool[Cap.SystemBatteriesPresent],
            Cap.BatteriesAreShortTerm ? "- short term" : ""
            );
    printf ("System batteries scale..: ");
    for (i=0; i<3; i++) {
        printf ("(G:%d C:%d) ",
            Cap.BatteryScale[i].Granularity,
            Cap.BatteryScale[i].Capacity
            );
    }
    printf ("\n"
            "Ac on line wake ability.: %s\n",   SysPower(Cap.AcOnLineWake));
    printf ("Lid wake ability........: %s\n",   SysPower(Cap.SoftLidWake));
    printf ("RTC wake ability........: %s\n",   SysPower(Cap.RtcWake));
    printf ("Min device wake.........: %s\n",   SysPower(Cap.MinDeviceWakeState));
    printf ("Default low latency wake: %s\n\n",   SysPower(Cap.DefaultLowLatencyWake));
}

PUCHAR
Action (
    IN PBOOLEAN CapFlag,
    IN PPOWER_ACTION_POLICY Act
    )
{
    static UCHAR text[200];
    PUCHAR  p;
    UCHAR   c;
    ULONG   i;

    p = text;

    if (CapFlag && !*CapFlag) {
        strcpy(p, "Disabled ");
        p += strlen("Disabled ");
    }

    strcpy(p, ActionS(Act->Action));
    p+=strlen(ActionS(Act->Action));
    if (Act->Action != PowerActionNone  &&  Act->Flags) {
        c = '(';
        for (i=0; ActFlags[i].Flags; i++) {
            if (Act->Flags & ActFlags[i].Flags) {
                p += sprintf (p, "%c%s", c, ActFlags[i].String);
                c  = '|';
            }
        }
        p += sprintf (p, ")");
    }

    if (Act->EventCode) {
        p += sprintf (p, "-Code=%x", Act->EventCode);
    }

    return text;
}

VOID
SetAction (
    IN PPOWER_ACTION_POLICY Action
    )
{
    PUCHAR  p;
    POWER_ACTION    Act;
    ULONG           Flags;


    Flags = 0;
    p = _strtok (CurValue);
    if (streql(p, "none")) {                    Act = PowerActionNone;
    } else if (streql(p, "sleep")) {            Act = PowerActionSleep;
    } else if (streql(p, "hiber")) {            Act = PowerActionHibernate;
    } else if (streql(p, "shutdown")) {         Act = PowerActionShutdown;
    } else if (streql(p, "shutdownreset")) {    Act = PowerActionShutdownReset;
    } else if (streql(p, "shutdownoff")) {      Act = PowerActionShutdownOff;
    } else {
        printf ("Unknown power action '%s'.\n", p);
        puts   ("use: doze, sleep, shutdown, shutdownreset, shutdownoff");
        exit (1);
    }

    while (p = _strtok(NULL)) {
        if (streql(p, "qapp")) {                    Flags |= POWER_ACTION_QUERY_ALLOWED;
        } else if (streql(p, "ui")) {               Flags |= POWER_ACTION_UI_ALLOWED;
        } else if (streql(p, "override")) {         Flags |= POWER_ACTION_OVERRIDE_APPS;
        } else if (streql(p, "disablewake")) {      Flags |= POWER_ACTION_DISABLE_WAKES;
        } else if (streql(p, "critical")) {         Flags |= POWER_ACTION_CRITICAL;
        } else {
            printf ("Unknown power action '%s'.\n", p);
            puts   ("use: qapp, io, override, disablewake, critical");
            exit (1);
        }
    }

    Action->Action = Act;
    Action->Flags  = Flags;
}


VOID
SetSysPower (
    IN PSYSTEM_POWER_STATE SysPower
    )
{
    PUCHAR      p;

    p = CurValue;
    if (streql(p, "s0")) {          *SysPower = PowerSystemWorking;
    } else if (streql(p, "s1")) {   *SysPower = PowerSystemSleeping1;
    } else if (streql(p, "s2")) {   *SysPower = PowerSystemSleeping2;
    } else if (streql(p, "s3")) {   *SysPower = PowerSystemSleeping3;
    } else if (streql(p, "s4")) {   *SysPower = PowerSystemHibernate;
    } else {
        printf ("Unknown system power state '%s'.  Use S0,S1,S2,S3 or S4\n", p);
        exit (1);
    }
}

VOID
SetPolicyCount(
    IN PULONG Variable
    )
{
    ULONG   local;
    if (!CurValueIsNumeric) {
        printf("'%s' is not numeric\n", CurValue);
        exit(1);
    }
    local = atol(CurValue);
    if (local > 3) {
        puts("PolicyCount can only be in the range 0 to 3\n");
        exit(1);
    }
    *Variable = local;
}

VOID
SetDynamicThrottle(
    IN PUCHAR Variable
    )
{
    ULONG   local;
    PUCHAR  p;

    p = CurValue;
    if (streql(p,"none")) {             *Variable = PO_THROTTLE_NONE;
    } else if (streql(p,"constant")) {  *Variable = PO_THROTTLE_CONSTANT;
    } else if (streql(p,"degrade")) {   *Variable = PO_THROTTLE_DEGRADE;
    } else if (streql(p,"degraded")) {  *Variable = PO_THROTTLE_DEGRADE;
    } else if (streql(p,"adaptive")) {  *Variable = PO_THROTTLE_ADAPTIVE;
    } else {
        printf("Unknown Dynamic Throttle state %s\n", CurValue);
        exit(1);
    }
}

VOID
SetCStates(
    IN  PPROCESSOR_POWER_POLICY Pol
    )
{
    PUCHAR  p;

    p = CurValue;
    if (streql(p,"true")) {

        Pol->DisableCStates = 1;

    } else {

        Pol->DisableCStates = 0;

    }
}

VOID
SetPercentage (
    IN PUCHAR Variable
    )
{
    PUCHAR  p;

    if (!CurValueIsNumeric) {

        for (p = CurValue; *p; p++) {
            if (*p == '%') {
                *p = '\0';
            }
        }
        CurValueIsNumeric = TRUE;
        for (p = CurValue; *p; p++) {
            if (*p < '0'  ||  *p > '9') {
                CurValueIsNumeric = FALSE;
            }
        }
        if (!CurValueIsNumeric) {
            printf ("'%s' is not numeric\n", CurValue);
            exit (1);
        }
    }
    *Variable = (UCHAR) atol(CurValue);
}


VOID
SetValue (
    IN PULONG Variable
    )
{
    if (!CurValueIsNumeric) {
        printf ("'%s' is not numeric\n", CurValue);
        exit (1);
    }

    *Variable = atol(CurValue);
}

VOID
SetBool (
    IN PBOOLEAN Variable
    )
{
    BOOLEAN     State;

    State = 99;
    if (CurValueIsNumeric) {
        State = (BOOLEAN)atol(CurValue);
    } else {
        if (streql(CurValue, "true")) {           State = TRUE;
        } else if (streql(CurValue, "false")) {   State = FALSE;
        }
    }

    if (State != FALSE && State != TRUE) {
        printf ("'%s' is not boolean\n", CurValue);
        exit (1);
    }

    *Variable = State;
}

VOID
SetField(
    IN  PPROCESSOR_POWER_POLICY Pol,
    IN  ULONG                   Index,
    IN  PUCHAR                  What
    )
{
    BOOLEAN     State;

    State = 99;
    if (CurValueIsNumeric) {

        State = (BOOLEAN)atol(CurValue);

    } else {

        if (streql(CurValue, "true")) {           State = TRUE;
        } else if (streql(CurValue, "false")) {   State = FALSE;
        }

    }

    if (State != FALSE && State != TRUE) {
        printf ("'%s' is not boolean\n", CurValue);
        exit (1);
    }

    if (streql(What,"allowpromotion")) {        Pol->Policy[Index].AllowPromotion = State;
    } else if (streql(What,"allowdemotion")) {  Pol->Policy[Index].AllowDemotion  = State;
    }

}


VOID
PrintPol (
    IN PSYSTEM_POWER_POLICY Pol
    )
{
    BOOLEAN     AnySleep;
    ULONG       i;
    UCHAR       text[200];
    PUCHAR      p;

    if (Pol->Revision != 1) {
        puts ("** revision not 1**");
    }

    AnySleep = Cap.SystemS1 || Cap.SystemS2 || Cap.SystemS3 || Cap.SystemS4;

    printf ("Power button.........: %s\n",  Action(&Cap.PowerButtonPresent, &Pol->PowerButton));
    printf ("Sleep button.........: %s\n",  Action(&Cap.SleepButtonPresent, &Pol->SleepButton));
    printf ("Lid close............: %s\n",  Action(&Cap.LidPresent, &Pol->LidClose));
    printf ("Lid open wake........: %s\n",  SysPower(Pol->LidOpenWake));

    printf ("Idle.................: %s\n", Action(&AnySleep, &Pol->Idle));
    printf ("Settings.............: Timeout=%d, Sensitivity=%d\n",
             Pol->IdleTimeout,
             Pol->IdleSensitivity
             );

    printf ("Min sleep state......: %s\n", SysPower(Pol->MinSleep));
    printf ("Max sleep state......: %s\n", SysPower(Pol->MaxSleep));
    printf ("Reduced latency.sleep: %s\n", SysPower(Pol->ReducedLatencySleep));
    printf ("WinLogonFlags........: %x\n", Pol->WinLogonFlags);
    printf ("DynamicThrottle......: %s\n", DynamicThrottle(Pol->DynamicThrottle));
    printf ("Doze S4 timeout......: %d\n", Pol->DozeS4Timeout);

    printf ("Battery broadcast res: %d\n", Pol->BroadcastCapacityResolution);
    for (i=0; i < NUM_DISCHARGE_POLICIES; i++) {
        printf ("Battery discharge %d..: ", i);
        p = "Disabled";
        if (!Cap.SystemBatteriesPresent && Pol->DischargePolicy[i].Enable) {
            p = "No battery, but enable is set";
        }
        if (Cap.SystemBatteriesPresent && Pol->DischargePolicy[i].Enable) {
            sprintf (text, "%d, %s, Min=%s",
                Pol->DischargePolicy[i].BatteryLevel,
                Action (NULL, &Pol->DischargePolicy[i].PowerPolicy),
                SysPower(Pol->DischargePolicy[i].MinSystemState)
                );
            p = text;
        }
        printf ("%s\n", p);
    }

    printf ("Video  timeout.......: %d\n", Pol->VideoTimeout);
    printf ("Hard disk timeout....: %d\n", Pol->SpindownTimeout);
    printf ("Optimize for power...: %s\n", szBool[Pol->OptimizeForPower]);
    printf ("Fan throttle toler...: %d\n", Pol->FanThrottleTolerance);
    printf ("Forced throttle......: %d%% %s\n",
             Pol->ForcedThrottle,
             Pol->ForcedThrottle == 100 ? "(off)" : "(on)"
             );
    printf ("Min throttle.........: %d%%\n", Pol->MinThrottle);
    printf ("Over throttle act....: %s\n", Action (NULL, &Pol->OverThrottled));
    printf ("\n");
}


VOID
PrintPPol (
    IN PPROCESSOR_POWER_POLICY Pol
    )
{
    ULONG       i;
    UCHAR       text[200];
    PUCHAR      p;

    if (Pol->Revision != 1) {

        puts ("** revision not 1**");

    }

    printf ("Dynamic Throttle.....: %s\n",  DynamicThrottle(Pol->DynamicThrottle) );
    printf ("Disable CStates......: %s\n",  szBool[Pol->DisableCStates] );
    printf ("\n");
    for (i = 0; i < Pol->PolicyCount; i++) {

        printf ("C%x Processor Power Policy\n",  (i+1) );
        printf ("   Allow Demotion....: %s\n",  szBool[Pol->Policy[i].AllowDemotion]);
        printf ("   Allow Promotion...: %s\n",  szBool[Pol->Policy[i].AllowPromotion]);
        printf ("   Demote Percent....: %d%%\n", Pol->Policy[i].DemotePercent);
        printf ("   Promote Percent...: %d%%\n", Pol->Policy[i].PromotePercent);
        printf ("   Demote Limit......: %s\n",  MicroSeconds(Pol->Policy[i].DemoteLimit) );
        printf ("   Promote Limit.....: %s\n",  MicroSeconds(Pol->Policy[i].PromoteLimit) );
        printf ("   Time Check........: %s\n",  MicroSeconds(Pol->Policy[i].TimeCheck) );
        printf ("\n");
    }
    printf ("\n");
}

VOID
PrintAdmin (
    PVOID   Context
    )
{
    printf ("Min sleep state......: %s\n", SysPower(Admin.MinSleep));
    printf ("Max sleep state......: %s\n", SysPower(Admin.MaxSleep));
    printf ("Min video timeout....: %d\n", Admin.MinVideoTimeout);
    printf ("Max video timeout....: %d\n", Admin.MaxVideoTimeout);
    printf ("Min spindown timeout.: %d\n", Admin.MinSpindownTimeout);
    printf ("Max spindown timeout.: %d\n", Admin.MaxSpindownTimeout);
}

VOID
AssignSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PSYSTEM_POWER_POLICY    Pol;
    PUCHAR                  p;

    if (!CurContext) {
        puts(
            "must select one of:\n"
            "   ac          - the system power policy while on AC\n"
            "   dc          - the system power policy while on DC\n"
            "   pac         - the processor power policy while on AC\n"
            "   pdc         - the processor power policy while on DC\n"
            "   cap         - the system capabilities\n"
            "   admin       - the admin policy\n"
            "before assigning settings"
            );
        exit (1);
    }

    CurValue = Value;
    if (!*CurValue) {
        printf ("null settings not allowed\n");
        exit (1);
    }

    CurValueIsNumeric = TRUE;
    for (p = Value; *p; p++) {
        if (*p < '0'  ||  *p > '9') {
            CurValueIsNumeric = FALSE;
        }
    }

    ItemUpdated = TRUE;
    CurAssign (Variable, Value);
}

VOID
AssignPolicySetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PSYSTEM_POWER_POLICY    Pol;

    Pol = (PSYSTEM_POWER_POLICY) CurContext;

    // set policy
    if (streql(Variable, "pbutt")) {                 SetAction(&Pol->PowerButton);
    } else if (streql(Variable, "sbutt")) {          SetAction(&Pol->SleepButton);
    } else if (streql(Variable, "lidclose")) {       SetAction(&Pol->LidClose);
    } else if (streql(Variable, "idle")) {           SetAction(&Pol->Idle);
    } else if (streql(Variable, "idlesense")) {      SetValue((PULONG)&Pol->IdleSensitivity);
    } else if (streql(Variable, "idletimeout")) {    SetValue(&Pol->IdleTimeout);
    } else if (streql(Variable, "minsleep")) {       SetSysPower(&Pol->MinSleep);
    } else if (streql(Variable, "maxsleep")) {       SetSysPower(&Pol->MaxSleep);
    } else if (streql(Variable, "reducedsleep")) {   SetSysPower(&Pol->ReducedLatencySleep);
    } else if (streql(Variable, "s4timeout")) {      SetValue(&Pol->DozeS4Timeout);
    } else if (streql(Variable, "videotimeout")) {   SetValue(&Pol->VideoTimeout);
    } else if (streql(Variable, "disktimeout")) {    SetValue(&Pol->SpindownTimeout);
    } else if (streql(Variable, "optpower")) {       SetBool(&Pol->OptimizeForPower);
    } else if (streql(Variable, "fantol")) {         SetValue((PULONG)&Pol->FanThrottleTolerance);
    } else if (streql(Variable, "minthrot")) {       SetValue((PULONG)&Pol->MinThrottle);
    } else if (streql(Variable, "forcethrot")) {     SetValue((PULONG)&Pol->ForcedThrottle);
    } else if (streql(Variable, "overthrot")) {      SetAction(&Pol->OverThrottled);
    } else {
        puts (
              "Variable not:\n"
              "  pbutt, sbutt, lidclose\n"
              "  idle, idlesense, idletime\n"
              "  minsleep, maxsleep, reducedsleep, s4timeout\n"
              "  videotimeout, disktimeout, optpower\n"
              "  optpower, fantol, minthrot, forcethrot, overthrot"
             );
        exit   (1);
    }

}

VOID
AssignPPolicySetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PPROCESSOR_POWER_POLICY Pol;

    Pol = (PPROCESSOR_POWER_POLICY) CurContext;
    if (streql(Variable,"policycount")) {               SetPolicyCount(&(Pol->PolicyCount));
    } else if (streql(Variable,"dynamicthrottle")) {    SetDynamicThrottle(&(Pol->DynamicThrottle));
    } else if (streql(Variable,"disablecstates")) {     SetCStates(Pol);
    } else if (streql(Variable,"c1allowpromotion")) {   SetField(Pol,0,"allowpromotion");
    } else if (streql(Variable,"c1allowdemotion")) {    SetField(Pol,0,"allowdemotion");
    } else if (streql(Variable,"c1demotepercent")) {    SetPercentage(&(Pol->Policy[0].DemotePercent));
    } else if (streql(Variable,"c1promotepercent")) {   SetPercentage(&(Pol->Policy[0].PromotePercent));
    } else if (streql(Variable,"c1demotelimit")) {      SetValue(&(Pol->Policy[0].DemoteLimit));
    } else if (streql(Variable,"c1promotelimit")) {     SetValue(&(Pol->Policy[0].PromoteLimit));
    } else if (streql(Variable,"c1timecheck")) {        SetValue(&(Pol->Policy[0].TimeCheck));
    } else if (streql(Variable,"c2allowpromotion")) {   SetField(Pol,1,"allowpromotion");
    } else if (streql(Variable,"c2allowdemotion")) {    SetField(Pol,1,"allowdemotion");
    } else if (streql(Variable,"c2demotepercent")) {    SetPercentage(&(Pol->Policy[1].DemotePercent));
    } else if (streql(Variable,"c2promotepercent")) {   SetPercentage(&(Pol->Policy[1].PromotePercent));
    } else if (streql(Variable,"c2demotelimit")) {      SetValue(&(Pol->Policy[1].DemoteLimit));
    } else if (streql(Variable,"c2promotelimit")) {     SetValue(&(Pol->Policy[1].PromoteLimit));
    } else if (streql(Variable,"c2timecheck")) {        SetValue(&(Pol->Policy[1].TimeCheck));
    } else if (streql(Variable,"c3allowpromotion")) {   SetField(Pol,2,"allowpromotion");
    } else if (streql(Variable,"c3allowdemotion")) {    SetField(Pol,2,"allowdemotion");
    } else if (streql(Variable,"c3demotepercent")) {    SetPercentage(&(Pol->Policy[2].DemotePercent));
    } else if (streql(Variable,"c3promotepercent")) {   SetPercentage(&(Pol->Policy[2].PromotePercent));
    } else if (streql(Variable,"c3demotelimit")) {      SetValue(&(Pol->Policy[2].DemoteLimit));
    } else if (streql(Variable,"c3promotelimit")) {     SetValue(&(Pol->Policy[2].PromoteLimit));
    } else if (streql(Variable,"c3timecheck")) {        SetValue(&(Pol->Policy[2].TimeCheck));
    } else {
        puts(
             "Variable not:\n"
             "  policycount        - number of elements in policy\n"
             "  dynamicthrottle    - which throttle policy to use\n"
             "  disablecstates     - disable cstates if true\n"
             "  cXallowpromotion   - allow promotion from state X\n"
             "  cXallowdemotion    - allow demotion from state X\n"
             "  cXdemotepercent    - set demote percent for state X\n"
             "  cXpromotepercent   - set promote percent for state X\n"
             "  cXdemotelimit      - set demote limit for state X\n"
             "  cXpromotelimit     - set promote limit for state X\n"
             "  cXtimecheck        - set time check interval for state X"
             "     where X = <1,2,3>\n"
            );
        exit(1);
    }
}

VOID
AssignCurrentSetting(
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    if (CurInfo == ProcessorPowerPolicyCurrent) {

        puts(
            "PCurrent is only intended for use in displaying the current processor\n"
            "power policy. You must use 'pac' or 'pdc' to actually set policy."
            );

    } else if (CurInfo == SystemPowerPolicyCurrent) {

        puts(
            "Current is only intended for use in displaying the current system\n"
            "power policy. You muse use 'ac' or 'dc' to actually set policy."
            );

    } else {

        puts( 
            "Unknown setting."
            );

    }
    exit(1);
}

VOID
AssignAdminSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    if (streql(Variable, "minsleep")) {              SetSysPower(&Admin.MinSleep);
    } else if (streql(Variable, "maxsleep")) {       SetSysPower(&Admin.MaxSleep);
    } else if (streql(Variable, "minvideo")) {       SetValue(&Admin.MinVideoTimeout);
    } else if (streql(Variable, "maxvideo")) {       SetValue(&Admin.MaxVideoTimeout);
    } else if (streql(Variable, "mindisk")) {        SetValue(&Admin.MinSpindownTimeout);
    } else if (streql(Variable, "maxdisk")) {        SetValue(&Admin.MaxSpindownTimeout);
    } else {
        puts(
             "Variable not:\n"
             "  minsleep, maxsleep\n"
             "  minvideo, maxvideo, mindisk, maxdisk"
            );
        exit   (1);
    }
}


VOID
AssignCapSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    // set capability
    if (streql(Variable, "pbutt")) {                 SetBool(&Cap.PowerButtonPresent);
    } else if (streql(Variable, "sbutt")) {          SetBool(&Cap.SleepButtonPresent);
    } else if (streql(Variable, "lid")) {            SetBool(&Cap.LidPresent);
    } else if (streql(Variable, "s1")) {             SetBool(&Cap.SystemS1);
    } else if (streql(Variable, "s2")) {             SetBool(&Cap.SystemS2);
    } else if (streql(Variable, "s3")) {             SetBool(&Cap.SystemS3);
    } else if (streql(Variable, "s4")) {             SetBool(&Cap.SystemS4);
    } else if (streql(Variable, "s5")) {             SetBool(&Cap.SystemS5);
    } else if (streql(Variable, "batt")) {           SetBool(&Cap.SystemBatteriesPresent);
    } else if (streql(Variable, "shortterm")) {      SetBool(&Cap.BatteriesAreShortTerm);
    } else if (streql(Variable, "acwake")) {         SetSysPower(&Cap.AcOnLineWake);
    } else if (streql(Variable, "lidwake")) {        SetSysPower(&Cap.SoftLidWake);
    } else if (streql(Variable, "rtcwake")) {        SetSysPower(&Cap.RtcWake);
    } else if (streql(Variable, "lowlat")) {         SetSysPower(&Cap.DefaultLowLatencyWake);
    } else {
        puts (
              "Variable not:\n"
              "  pbutt, sbutt, lid, s1, s2, s3, s4, s5\n"
              "  batt, shortterm, acwake, lidwake, rtcwak, lowlat"
             );
        exit   (1);
    }
}


#define SEL_NONE        0
#define SEL_AC          1
#define SEL_DC          2
#define SEL_CAP         3
#define SEL_ADMIN       4
#define SEL_PAC         5
#define SEL_PDC         6
#define SEL_CURRENT     7
#define SEL_PCURRENT    8

VOID
SelectItem(
    IN ULONG    Type
    )
{
    NTSTATUS            Status;

    if (CurType) {
        if (ItemUpdated) {
            if (Verbose2) {
                printf ("%s being set as:\n", CurDesc);
                CurPrint (CurContext);
            }

            Status = NtPowerInformation (
                        CurInfo,
                        CurContext,
                        CurContextSize,
                        CurContext,
                        CurContextSize
                        );

            if (!NT_SUCCESS(Status)) {
                printf ("NtPowerInformation failed with %x\n", Status);
            }

        }

        puts (CurDesc);
        CurPrint (CurContext);
    }

    switch (Type) {
        case SEL_NONE:
            CurPrint = NULL;
            CurAssign = NULL;
            CurContext = NULL;
            break;

        case SEL_AC:
            CurPrint        = PrintPol;
            CurInfo         = SystemPowerPolicyAc;
            CurContext      = &Ac;
            CurContextSize  = sizeof(SYSTEM_POWER_POLICY);
            CurAssign       = AssignPolicySetting;
            CurDesc         = "AC power policy";
            break;

        case SEL_DC:
            CurPrint        = PrintPol;
            CurInfo         = SystemPowerPolicyDc;
            CurContext      = &Dc;
            CurContextSize  = sizeof(SYSTEM_POWER_POLICY);
            CurAssign       = AssignPolicySetting;
            CurDesc         = "DC power policy";
            break;

        case SEL_CURRENT:
            CurPrint        = PrintPol;
            CurInfo         = SystemPowerPolicyCurrent;
            CurContext      = &Current;
            CurContextSize  = sizeof(SYSTEM_POWER_POLICY);
            CurAssign       = AssignCurrentSetting;
            CurDesc         = "Current power policy";
            break;

        case SEL_PAC:
            CurPrint        = PrintPPol;
            CurInfo         = ProcessorPowerPolicyAc;
            CurContext      = &PAc;
            CurContextSize  = sizeof(PROCESSOR_POWER_POLICY);
            CurAssign       = AssignPPolicySetting;
            CurDesc         = "AC processor power policy";
            break;

        case SEL_PDC:
            CurPrint        = PrintPPol;
            CurInfo         = ProcessorPowerPolicyDc;
            CurContext      = &PDc;
            CurContextSize  = sizeof(PROCESSOR_POWER_POLICY);
            CurAssign       = AssignPPolicySetting;
            CurDesc         = "DC processor power policy";
            break;

        case SEL_PCURRENT:
            CurPrint        = PrintPPol;
            CurInfo         = ProcessorPowerPolicyCurrent;
            CurContext      = &PCurrent;
            CurContextSize  = sizeof(PROCESSOR_POWER_POLICY);
            CurAssign       = AssignCurrentSetting;
            CurDesc         = "Current processor power policy";
            break;

        case SEL_CAP:
            CurPrint        = PrintCap;
            CurInfo         = SystemPowerCapabilities,
            CurContext      = &Cap;
            CurContextSize  = sizeof(SYSTEM_POWER_CAPABILITIES);
            CurAssign       = AssignCapSetting;
            CurDesc         = "power capabilties";
            break;

        case SEL_ADMIN:
            CurPrint        = PrintAdmin;
            CurInfo         = AdministratorPowerPolicy;
            CurContext      = &Admin;
            CurContextSize  = sizeof(ADMINISTRATOR_POWER_POLICY);
            CurAssign       = AssignAdminSetting;
            CurDesc         = "Admin policy overrides";
            break;
    }

    CurType = Type;
    ItemUpdated = FALSE;
}


VOID
UpdateAdmin (
    VOID
    )
{
    ADMINISTRATOR_POWER_POLICY   AdminPolicy;
    NTSTATUS                     Status;


    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                NULL,
                0,
                &AdminPolicy,
                sizeof (AdminPolicy)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading admin policy %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                &AdminPolicy,
                sizeof (AdminPolicy),
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error writing admin policy %x\n", Status);
        exit (1);
    }
}



VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    NTSTATUS                    Status;
    PUCHAR                      p, p1;
    BOOLEAN                     Result;
    HANDLE                      hToken;
    TOKEN_PRIVILEGES            tkp;

    if (argc < 2) {
        puts ("dumppo: cap ps bs admin ac dc current pac pdc pcurrent");
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerCapabilities,
                NULL,
                0,
                &Cap,
                sizeof (Cap)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading power capabilities %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                NULL,
                0,
                &Admin,
                sizeof (Admin)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading admin power overrides %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerPolicyAc,
                NULL,
                0,
                &Ac,
                sizeof (Ac)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading AC policies %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerPolicyDc,
                NULL,
                0,
                &Dc,
                sizeof (Dc)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading DC policies %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerPolicyCurrent,
                NULL,
                0,
                &Current,
                sizeof (Current)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading Current policies %x\n", Status);
        exit (1);
    }

    Result = (BOOLEAN)GetSystemPowerStatus (&PS);
    if (!Result) {
        printf ("False returned from GetSystemPowerStatus %x\n", GetLastError());
        exit (1);
    }

    Status = NtPowerInformation (
                SystemBatteryState,
                NULL,
                0,
                &Batt,
                sizeof (Batt)
                );
    if (!NT_SUCCESS(Status)) {
        printf ("Error reading system battery status %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                ProcessorPowerPolicyAc,
                NULL,
                0,
                &PAc,
                sizeof (PAc)
                );
    if (!NT_SUCCESS(Status)) {
        printf ("Error reading processor AC policy %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation(
                ProcessorPowerPolicyDc,
                NULL,
                0,
                &PDc,
                sizeof (PDc)
                );
    if (!NT_SUCCESS(Status)) {
        printf("Error reading processor DC policy %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation(
                ProcessorPowerPolicyCurrent,
                NULL,
                0,
                &PCurrent,
                sizeof (PCurrent)
                );
    if (!NT_SUCCESS(Status)) {
        printf("Error reading processor Current policy %x\n", Status);
        exit (1);
    }

    //
    // Upgra