NG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      30 * MinOutWidth * MinOutHeight * 9 / 8,  // LONG MinBitsPerSecond;
      30 * MaxOutWidth * MaxOutHeight * 9 / 8 //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0, 0, 0, 0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0, 0, 0, 0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 9 / 8 * 30L,         //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,         //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,     //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         9,                          //    WORD       biBitCount;
         0x39555659,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 9 / 8,//    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatYUY2 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0x32595559, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIASUBTYPE_YUY2
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } }  //FORMAT_VideoInfo
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      4,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      30 * MinOutWidth * MinOutHeight * 2,  // LONG MinBitsPerSecond;
      30 * MaxOutWidth * MaxOutHeight * 2 //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      {0,0,0,0},    //    RECT            rcSource;          // The bit we really want to use
      {0,0,0,0},    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,         //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,     //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         0x32595559,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO2 StreamFormat2YUY2 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO2 ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0x32595559, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIASUBTYPE_YUY2
         { 0xf72a76A0, 0xeb0a, 0x11d0, { 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba } }  //FORMAT_VideoInfo2
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2 }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      4,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      30 * MinOutWidth * MinOutHeight * 2,  // LONG MinBitsPerSecond;
      30 * MaxOutWidth * MaxOutHeight * 2 //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER2 (default format)
   {
      {0,0,0,0},    //    RECT            rcSource;          // The bit we really want to use
      {0,0,0,0},    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,         //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,     //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
#if 0
		//TODO video memory must be available for interlacing to work
		KS_INTERLACE_IsInterlaced |		//		DWORD		dwInterlaceFlags
#else
			KS_INTERLACE_1FieldPerSample 
			//| KS_INTERLACE_Field1First
			//| KS_INTERLACE_FieldPatField1Only
			| KS_INTERLACE_FieldPatBothRegular
			| KS_INTERLACE_DisplayModeBobOnly,
			//| KS_INTERLACE_DisplayModeBobOrWeave,
#endif
											//		use AMINTERLACE_* defines. Reject connection if undefined bits are not 0   		
											//		AMINTERLACE_IsInterlaced            
											//		AMINTERLACE_1FieldPerSample         
											//		AMINTERLACE_Field1First             
											//		AMINTERLACE_UNUSED                  
											//		AMINTERLACE_FieldPatternMask        
											//		AMINTERLACE_FieldPatField1Only      
											//		AMINTERLACE_FieldPatField2Only      
											//		AMINTERLACE_FieldPatBothRegular     
											//		AMINTERLACE_FieldPatBothIrregular   
											//		AMINTERLACE_DisplayModeMask         
											//		AMINTERLACE_DisplayModeBobOnly      
											//		AMINTERLACE_DisplayModeWeaveOnly    
											//		AMINTERLACE_DisplayModeBobOrWeave 
											//
		0,									//		DWORD		dwCopyProtectFlags
											//		use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0 
											//		AMCOPYPROTECT_RestrictDuplication
											//
		4,									//		DWORD		dwPictAspectRatioX
											//		X dimension of picture aspect ratio, e.g. 16 for 16x9 display
											//
		3,									//		DWORD		dwPictAspectRatioY
											//		Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
		0,									//		DWORD		dwReserved1
		0,									//		DWORD		dwReserved2


      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         0x32595559,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatYVYU =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0x55595659, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIASUBTYPE_YVYU
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } } //FORMAT_VideoInfo
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      4,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      30 * 80 * 40 * 2,  // LONG MinBitsPerSecond;
      30 * 720 * 480 * 2 //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,         //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,         //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,     //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         0x55595659,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatUYVY =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0x59565955, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIASUBTYPE_UYVY
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } } //FORMAT_VideoInfo
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      4,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      30 * MinOutWidth * MinOutHeight * 2,  // LONG MinBitsPerSecond;
      30 * MaxOutWidth * MaxOutHeight * 2 //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,         //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,     //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         0x59565955,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\vidch.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Vidch.h 1.14 1998/05/11 23:59:58 tomz Exp $

#ifndef __VXDVIDCH_H
#define __VXDVIDCH_H

extern "C" {
   #include "strmini.h"
   #include "ksmedia.h"
}

#include "mytypes.h"
#include "pisces.h"
#include "vidchifc.h"

typedef enum  { Closed, Open, Created, Started, Paused } StreamState;
typedef enum { Single, Paired } StreamType;
void GetRequestedSize2( const KS_VIDEOINFOHEADER2 &vidHdr, MSize &size );
void GetRequestedSize( const KS_VIDEOINFOHEADER &vidHdr, MSize &size );

extern PHW_STREAM_REQUEST_BLOCK StreamIdxToSrb[];

/* Class: VideoChannel
 * Purpose: The base class to be used in the BtPisces capture VxD. Used for
 *   processing user requests ( comes from the device class, goes to capture
 *   chip class )
 * Attributes:
 * Methods
 */
class VideoChannel
{
   protected:

      BtPisces  *Digitizer_;

      SRBQueue  Requests_;

      KS_VIDEOINFOHEADER        VidHeader_;
      KS_VIDEOINFOHEADER2        VidHeader2_;
      // this seems to be the most convenient place for the original copy
      // other option is to make SetVidHdr() virtual and move this member into
      // the PairedChannels
      KS_VIDEOINFOHEADER        OrigVidHeader_;
      KS_VIDEOINFOHEADER2        OrigVidHeader2_;

		BOOL					m_bIsVideoInfo2;

      DWORD               FieldType_;
      VidBufQueue         BufQue_;

      VideoChanIface      Caller_;

      DWORD               dwBufferOffset_;

      HANDLE              hMasterClock;

      KSSTATE             KSState_;

      LONG                TimePerFrame_;

      VideoStream         Stream_;
      Field              *OurField_;

      StreamState         State_;
      bool                NeedNotification_;

      virtual  void Interrupt( PVOID pTag, bool skipped );
               void CheckNotificationNeed();

      static void STREAMAPI TimeStamp( PHW_STREAM_REQUEST_BLOCK pSrb );
      static void STREAMAPI TimeStampVBI( PHW_STREAM_REQUEST_BLOCK pSrb );

      PVOID pStrmEx_; 

   public:

      PHW_STREAM_REQUEST_BLOCK  pSRB_;

#ifdef ENABLE_DDRAW_STUFF
	// Kernel DDraw interface
	BOOL                        bKernelDirectDrawRegistered;
	HANDLE                      hUserDirectDrawHandle;       // DD itself
	HANDLE                      hKernelDirectDrawHandle;
	BOOL                        bPreEventOccurred;
	BOOL                        bPostEventOccurred;
#endif


		BOOL	IsVideoInfo2() { return m_bIsVideoInfo2; }
      PVOID GetStrmEx() 
      {
         DEBUG_ASSERT(pStrmEx_ != 0);
         return pStrmEx_;
      }
      VOID SetStrmEx(PVOID pv) 
      {
         DEBUG_ASSERT(pv != 0);
         pStrmEx_ = pv;
      }
      
      BOOL bIsVBI();
      BOOL bIsVideo();

      VOID ResetCounters();

      virtual ErrorCode OpenChannel();
      virtual ErrorCode CloseChannel();
      virtual ErrorCode SetFormat( ColFmt );
              ColFmt    GetFormat();
      virtual ErrorCode SetDigitalWindow( MRect &r );
      virtual ErrorCode SetAnalogWindow( MRect &r );
      virtual ErrorCode Create();
      virtual void      Start();
      virtual ErrorCode Stop();
      virtual ErrorCode Pause();

              StreamState GetState();
              KSSTATE     GetKSState();
              void        SetKSState( KSSTATE st );
                    
              VideoStream GetStreamID();

              void        SetClockMaster( HANDLE h );
              
              //LONGLONG    GetFramesNo();
              
              LONG      GetTimePerFrame();
              void      SetTimePerFrame( LONG time );

              void      SetInterrupt( bool state );
              void      SetCallback( ChanIface *cb );

      virtual StreamType GetStreamType();

      virtual  void AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb );
      virtual  bool RemoveSRB( PHW_STREAM_REQUEST_BLOCK pSrb );
      virtual  void ChangeNotification( PHW_STREAM_REQUEST_BLOCK pSrb );

      virtual void AddBuffer( PVOID );

              void SetSRB( PHW_STREAM_REQUEST_BLOCK srb );
              PHW_STREAM_REQUEST_BLOCK GetSRB();

              void SetVidHdr( const KS_VIDEOINFOHEADER &rVidHdr );
              void SetVidHdr2( const KS_VIDEOINFOHEADER2 &rVidHdr );
              PKS_VIDEOINFOHEADER GetVidHdr();
              KS_VIDEOINFOHEADER2* GetVidHdr2();

              void SetBufPitch( DWORD dwP );

              void  SetDefaultQue()
              { Digitizer_->SetBufQuePtr( *OurField_, &BufQue_ ); }

              void SetPaired( bool p = false );

              void IntNotify( PVOID pTag, bool skipped );

              bool IsOpen();
              void SetOpen();
              void SetClose();

      void Init( BtPisces *const pCapChip );

      VideoChannel( VideoStream aStrm );
      virtual ~VideoChannel();

      friend class VideoChanIface;

      // placement new
      void *operator new( size_t, void *buf ) { return buf; }
      void operator delete( void *, size_t ) {}
};

/* Class: PairedVideoChannels
 * Purpose: Implements basic functionality of paired video channels
 */
template <class ParentChan>
class PairedVideoChannels : public ParentChan
{
   typedef ParentChan Parent;
   public:
      VideoChannel &slave;

      PairedVideoChannels( VideoStream st, VideoChannel &chan );

      virtual ErrorCode Create();
      virtual void      Start();
      virtual ErrorCode Stop();
      virtual ErrorCode Pause();

      virtual StreamType GetStreamType();
};

template <class ParentChan>
inline PairedVideoChannels<ParentChan>::PairedVideoChannels( VideoStream st, VideoChannel &chan )
   : ParentChan( st ), slave( chan )
{}

/* Class: InterVideoChannel
 * Purpose: The base class to be used in the BtPisces capture VxD. Used for
 *   processing user requests ( comes from the device class, goes to capture
 *   chip class )
 * Attributes:
 * Methods
 */
class InterVideoChannel : public PairedVideoChannels<VideoChannel>
{
   typedef PairedVideoChannels<VideoChannel> Parent;

   public:
      virtual ErrorCode Create();
      virtual void      AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb );
      InterVideoChannel( VideoStream aStrm, VideoChannel &chan );
      virtual  void Interrupt( PVOID pTag, bool skipped );
};

inline InterVideoChannel::InterVideoChannel( VideoStream aStrm, VideoChannel &chan )
   : Parent( aStrm, chan )
{}

/* Class: AlterVideoChannel
 * Purpose: The base class to be used in the BtPisces capture VxD. Used for
 *   processing user requests ( comes from the device class, goes to capture
 *   chip class )
 * Attributes:
 * Methods
 */
template <class ParentChan>
class AlterVideoChannel : public PairedVideoChannels<ParentChan>
{
   typedef PairedVideoChannels<ParentChan> Parent;

   int toggle_;

   public:
      virtual ErrorCode Create();
      virtual void      AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb );
      virtual  bool     RemoveSRB( PHW_STREAM_REQUEST_BLOCK pSrb );
      AlterVideoChannel( VideoStream aStrm, VideoChannel &chan );
};

/* Class: VBIChannel
 * Purpose: Implements functionality for the VBI field
 */
class VBIChannel : public VideoChannel
{
   typedef VideoChannel Parent;

   // Channel Change information

   public:
      bool  Dirty_;
      KS_TVTUNER_CHANGE_INFO   TVTunerChangeInfo_;
      KS_VBIINFOHEADER         VBIInfoHeader_;

      virtual  void Interrupt( PVOID pTag, bool skipped );
      virtual  void ChangeNotification( PHW_STREAM_REQUEST_BLOCK pSrb );
      VBIChannel( VideoStream aStrm );
      void SetVBIInfHdr( const KS_VBIINFOHEADER &vbiHdr );
};

/* Class: VBIAlterChannel
 * Purpose: Implements alternating VBI fields
 */

class VBIAlterChannel : public AlterVideoChannel<VBIChannel>
{
   typedef AlterVideoChannel<VBIChannel> Parent;

   public:
      void SetVidHdr( const KS_DATAFORMAT_VBIINFOHEADER &df );
      void SetVidHdr2( const KS_DATAFORMAT_VBIINFOHEADER &df );
      VBIAlterChannel( VideoStream aStrm, VBIChannel &chan );
};

inline VBIChannel::VBIChannel( VideoStream aStrm ) : VideoChannel( aStrm ),
   Dirty_( false )
{}

inline void DumpVbiInfoHeader( const KS_VBIINFOHEADER &vbiHdr )
{
   // typedef struct tagKS_VBIINFOHEADER {
   //     ULONG       StartLine;              // inclusive
   //     ULONG       EndLine;                // inclusive
   //     ULONG       SamplingFrequency;      // Hz.
   //     ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
   //     ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
   //     ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
   //     ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
   //     ULONG       VideoStandard;          // KS_AnalogVideoStandard*
   //     ULONG       SamplesPerLine;
   //     ULONG       StrideInBytes;          // May be > SamplesPerLine
   //     ULONG       BufferSize;             // Bytes
   // } KS_VBIINFOHEADER, *PKS_VBIINFOHEADER;

   DebugOut((0, "KS_VBIINFOHEADER at address %x\n", &vbiHdr));
   DUMP(vbiHdr.StartLine);
   DUMP(vbiHdr.EndLine);
   DUMP(vbiHdr.SamplingFrequency);
   DUMP(vbiHdr.MinLineStartTime);
   DUMP(vbiHdr.MaxLineStartTime);
   DUMP(vbiHdr.ActualLineStartTime);
   DUMP(vbiHdr.ActualLineEndTime);
   DUMP(vbiHdr.VideoStandard);
   DUMP(vbiHdr.SamplesPerLine);
   DUMP(vbiHdr.StrideInBytes);
   DUMP(vbiHdr.BufferSize);
}
inline void VBIChannel::SetVBIInfHdr( const KS_VBIINFOHEADER &vbiHdr )
{
   VBIInfoHeader_ = vbiHdr;
}

inline VBIAlterChannel::VBIAlterChannel( VideoStream aStrm, VBIChannel &chan )
   : AlterVideoChannel<VBIChannel>( aStrm, chan )
{}

template <class ParentChan>
inline AlterVideoChannel<ParentChan>::AlterVideoChannel( VideoStream aStrm, VideoChannel &chan )
   : Parent( aStrm, chan ), toggle_( 0 )
{}

inline void VideoChannel::SetSRB( PHW_STREAM_REQUEST_BLOCK srb )
{
   pSRB_ = srb;
}


/* Method: AlterVideoChannel::AddSRB
 * Purpose: This method dispatches the SRB to the next appropriate channel
 * Input: pSrb:
 */
template <class ParentChan>
void AlterVideoChannel<ParentChan>::AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   if ( !toggle_ ) {
      // first buffer goes to the slave channel as it comes out of the
      // decoder first
      DebugOut((1, "slave.AddSRB(%x)\n", pSrb));
      slave.AddSRB( pSrb );
   } else {
      DebugOut((1, "parent.AddSRB(%x)\n", pSrb));
      Parent::AddSRB( pSrb );
   }
   toggle_++;
   toggle_ %= 2;
}

/* Method: AlterVideoChannel::RemoveSRB
 * Purpose: Just calls into each channel in hope one of them will find the SRB
 * Input: pSRB
 * Output: None
 */
template <class ParentChan>
bool AlterVideoChannel<ParentChan>::RemoveSRB( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   // one or the other will pick it up
   
   bool b1 = slave.RemoveSRB( pSrb );
   bool b2 = Parent::RemoveSRB( pSrb );

   if( !b1 && !b2 )
   {
      DebugOut((1, "AlterVideoChannel<ParentChan>::RemoveSRB - RemoveSRB failed\n"));
   }
   return ( b1 || b2 );
}

/* Method: AlterVideoChannel::Create
 * Purpose: Sets the slave video params and calls into parent to do the work
 * Input: pSRB
 * Output: None
 */
template <class ParentChan>
ErrorCode AlterVideoChannel<ParentChan>::Create()
{
   slave.SetVidHdr( VidHeader_ );
   return Parent::Create();
}

inline PHW_STREAM_REQUEST_BLOCK VideoChannel::GetSRB()
{
   return pSRB_;
}

inline void DumpVideoInfoHeader(const KS_VIDEOINFOHEADER &rVidHdr)
{
   DebugOut((0, "-----------------------------------------\n"));
   DebugOut((0, "setting KS_VIDEOINFOHEADER\n"));
   DebugOut((0, "-----------------------------------------\n"));
   DebugOut((0, "rcSource (%d,%d,%d,%d)\n",
      rVidHdr.rcSource.left, 
      rVidHdr.rcSource.top,
      rVidHdr.rcSource.right, 
      rVidHdr.rcSource.bottom));

   DebugOut((0, "rcTarget (%d,%d,%d,%d)\n",
      rVidHdr.rcTarget.left, 
      rVidHdr.rcTarget.top,
      rVidHdr.rcTarget.right, 
      rVidHdr.rcTarget.bottom));

   DebugOut((0, "dwBitRate (%u)\n", rVidHdr.dwBitRate));
   DebugOut((0, "dwBitErrorRate (%u)\n", rVidHdr.dwBitErrorRate));
   DebugOut((0, "bmiHeader\n"));
   DebugOut((0, "   biSize (%d)\n", rVidHdr.bmiHeader.biSize));
   DebugOut((0, "   biWidth (%d)\n", rVidHdr.bmiHeader.biWidth));
   DebugOut((0, "   biHeight (%d)\n", rVidHdr.bmiHeader.biHeight));
   DebugOut((0, "   biPlanes (%d)\n", rVidHdr.bmiHeader.biPlanes));
   DebugOut((0, "   biBitCount (%d)\n", rVidHdr.bmiHeader.biBitCount));
   DebugOut((0, "   biCompression (%d)\n", rVidHdr.bmiHeader.biCompression));
   DebugOut((0, "   biSizeImage (%d)\n", rVidHdr.bmiHeader.biSizeImage));
   DebugOut((0, "   biXPelsPerMeter (%d)\n", rVidHdr.bmiHeader.biXPelsPerMeter));
   DebugOut((0, "   biYPelsPerMeter (%d)\n", rVidHdr.bmiHeader.biYPelsPerMeter));
   DebugOut((0, "   biClrUsed (%d)\n", rVidHdr.bmiHeader.biClrUsed));
   DebugOut((0, "   biClrImportant (%d)\n", rVidHdr.bmiHeader.biClrImportant));
}

inline void VideoChannel::SetVidHdr( const KS_VIDEOINFOHEADER &rVidHdr )
{
   // DumpVideoInfoHeader(rVidHdr);

	m_bIsVideoInfo2 = FALSE;
   VidHeader_ = rVidHdr;
   // save this for paired channels
   OrigVidHeader_ = rVidHdr;
}
                                   
inline void VideoChannel::SetVidHdr2( const KS_VIDEOINFOHEADER2 &rVidHdr )
{
   // DumpVideoInfoHeader(rVidHdr);

	m_bIsVideoInfo2 = TRUE;
   VidHeader2_ = rVidHdr;
   // save this for paired channels
   OrigVidHeader2_ = rVidHdr;
}
                                   
inline PKS_VIDEOINFOHEADER VideoChannel::GetVidHdr()
{
   return &VidHeader_;
}

inline KS_VIDEOINFOHEADER2* VideoChannel::GetVidHdr2()
{
   return &VidHeader2_;
}

inline void VideoChannel::SetBufPitch( DWORD dwP )
{
   Digitizer_->SetBufPitch( dwP, *OurField_ );
}

inline bool VideoChannel::IsOpen()
{
   return State_ >= Open;
}

inline void VideoChannel::SetOpen()
{
   State_ = Open;
}

inline void VideoChannel::SetClose()
{
   State_ = Closed;
}

inline void VideoChannel::Init( BtPisces *const pCapChip )
{
   Digitizer_ = pCapChip;
}

inline StreamState VideoChannel::GetState()
{
    return State_;
}

inline VideoStream VideoChannel::GetStreamID()
{
   return OurField_->GetStreamID();
}

inline void VideoChannel::SetPaired( bool p )
{
   OurField_->SetPaired( p );
}

inline void VideoChannel::SetClockMaster( HANDLE h )
{
   DebugOut((1, "SetClockMaster(%x)\n", h ));
   hMasterClock = h;
}

inline KSSTATE VideoChannel::GetKSState()
{
   return KSState_;
}

inline void    VideoChannel::SetKSState( KSSTATE st )
{
   KSState_ = st;
}

#if 0
inline LONGLONG VideoChannel::GetFramesNo()
{
   LONGLONG PicNumber, DropCnt;
   OurField_->GetCounters( PicNumber, DropCnt );
   return PicNumber;
}
#endif

inline LONG VideoChannel::GetTimePerFrame()
{
   return OurField_->GetStandardTiming();
}

inline void VideoChannel::SetTimePerFrame( LONG time )
{
   TimePerFrame_ = time;
   OurField_->SetStandardTiming( time );
}

inline void VideoChannel::IntNotify( PVOID pTag, bool skipped )
{
   Caller_.Notify( pTag, skipped );
}

inline void VideoChannel::SetInterrupt( bool state )
{
   OurField_->Interrupt_ = state;
}

inline void VideoChannel::SetCallback( ChanIface *cb )
{
   OurField_->SetCallback( cb );
}

#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
inline VideoChannel::VideoChannel( VideoStream aStrm ) :
   NeedNotification_( false ), BufQue_(), Caller_( this ), Stream_( aStrm ),
   OurField_( NULL ), State_( Closed ), pSRB_( NULL ), VidHeader_(), Requests_(),
   dwBufferOffset_( 0 ), hMasterClock( NULL ), TimePerFrame_( 333667 )
{
	m_bIsVideoInfo2 = FALSE;

#ifdef ENABLE_DDRAW_STUFF
	bKernelDirectDrawRegistered = FALSE;
	hUserDirectDrawHandle = NULL;    
	hKernelDirectDrawHandle = NULL;
	bPreEventOccurred = FALSE;
	bPostEventOccurred = FALSE;
#endif

   // VS_Field1 is defined as 0
   FieldType_ = aStrm & 0x01 ? KS_VIDEO_FLAG_FIELD2 : KS_VIDEO_FLAG_FIELD1;
}

template <class ParentChan>
StreamType PairedVideoChannels<ParentChan>::GetStreamType()
{
   return Paired;
}

/* Method: PairedVideoChannel::Create
 * Purpose: Creates both streams
 * Input: None
 * Output: None
 */
template <class ParentChan>
ErrorCode PairedVideoChannels<ParentChan>::Create()
{
   if ( slave.Create() == Success ) {
      Digitizer_->SetPlanarAdjust( 0 );
      return Parent::Create();
   }
   return Fail;
}

/* Method: PairedVideoChannels::Start
 * Purpose: Starts both channels
 * Input: None
 * Output: None
 */
template <class ParentChan>
void PairedVideoChannels<ParentChan>::Start()
{
   slave.Start();
   Parent::Start();
}

/* Method: PairedVideoChannels::Stop
 * Purpose: Stops both channels
 * Input: None
 * Output: None
 */
template <class ParentChan>
ErrorCode PairedVideoChannels<ParentChan>::Stop()
{
   slave.Stop();
   Parent::Stop();
   return Success;
}

/* Method: PairedVideoChannels::Pause
 * Purpose: Pauses both channels
 * Input: None
 * Output: None
 */
template <class ParentChan>
ErrorCode PairedVideoChannels<ParentChan>::Pause()
{
   if ( bIsVBI() )
   {
      Digitizer_->PairedPause( (VBIEStartLocation + DistBetweenProgs) );
   }
   else
   {
      Digitizer_->PairedPause( (EvenStartLocation + DistBetweenProgs) );
   }
   State_ = Paused;
   return Success;
}

#endif __VXDVIDCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\dbg.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    dbg.h

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

   

--*/
#ifndef _DBG_INC
#define _DBG_INC


//
// Various definitions
//

#if DBG

#define _DRIVERNAME_        "MSDV"

// PnP: loading, power state, surprise removal, device SRB
#define TL_PNP_MASK         0x0000000F
#define TL_PNP_INFO         0x00000001
#define TL_PNP_TRACE        0x00000002
#define TL_PNP_WARNING      0x00000004
#define TL_PNP_ERROR        0x00000008

// Connection, plug and 61883 info (get/set)
#define TL_61883_MASK       0x000000F0
#define TL_61883_INFO       0x00000010
#define TL_61883_TRACE      0x00000020
#define TL_61883_WARNING    0x00000040
#define TL_61883_ERROR      0x00000080

// Data
#define TL_CIP_MASK         0x00000F00
#define TL_CIP_INFO         0x00000100
#define TL_CIP_TRACE        0x00000200
#define TL_CIP_WARNING      0x00000400
#define TL_CIP_ERROR        0x00000800

// AVC commands
#define TL_FCP_MASK         0x0000F000
#define TL_FCP_INFO         0x00001000
#define TL_FCP_TRACE        0x00002000
#define TL_FCP_WARNING      0x00004000
#define TL_FCP_ERROR        0x00008000

// Stream (data intersection, open/close, stream state (get/set))
#define TL_STRM_MASK        0x000F0000
#define TL_STRM_INFO        0x00010000
#define TL_STRM_TRACE       0x00020000
#define TL_STRM_WARNING     0x00040000
#define TL_STRM_ERROR       0x00080000

// clock and clock event
#define TL_CLK_MASK         0x00F00000
#define TL_CLK_INFO         0x00100000
#define TL_CLK_TRACE        0x00200000
#define TL_CLK_WARNING      0x00400000
#define TL_CLK_ERROR        0x00800000


extern ULONG DVTraceMask;
extern ULONG DVAssertLevel;


#define TRAP                    DbgBreakPoint();

#define TRACE( l, x )                       \
    if( (l) & DVTraceMask ) {              \
        KdPrint( (_DRIVERNAME_ ": ") );     \
        KdPrint( x );                       \
    }

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT( exp ) \
    if (DVAssertLevel && !(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else  // #if DBG

#define TRAP  

#define TRACE( l, x )

#endif  // #if DBG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\inc\winme\61883.h ===
/*++
Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    61883.h

Abstract:

    The public header for clients of the 61883 Class.

Author:

    WGJ
    PSB

--*/

//
// Class GUID
//
// {7EBEFBC0-3200-11d2-B4C2-00A0C9697D07}
DEFINE_GUID(GUID_61883_CLASS, 0x7ebefbc0, 0x3200, 0x11d2, 0xb4, 0xc2, 0x0, 0xa0, 0xc9, 0x69, 0x7d, 0x7);

//
// IOCTL Definitions
//
#define IOCTL_61883_CLASS                       CTL_CODE(            \
                                                FILE_DEVICE_UNKNOWN, \
                                                0x91,                \
                                                METHOD_IN_DIRECT,    \
                                                FILE_ANY_ACCESS      \
                                                )


//
// Current 61883 DDI Version
//
#define CURRENT_61883_DDI_VERSION               0x1

//
// INIT_61883_HEADER Macro
//
#define INIT_61883_HEADER( Av61883, Request )             \
        (Av61883)->Function = Request;                    \
        (Av61883)->Version = CURRENT_61883_DDI_VERSION;

//
// 61883 I/O Request Functions
//
enum {

    Av61883_GetUnitInfo,
    Av61883_SetUnitInfo,

    NotSupported0,
    Av61883_GetPlugHandle,
    Av61883_GetPlugState,
    Av61883_Connect,
    Av61883_Disconnect,

    Av61883_AttachFrame,
    Av61883_CancelFrame,
    Av61883_Talk,
    Av61883_Listen,
    Av61883_Stop,

    Av61883_SendFcpRequest,
    Av61883_GetFcpResponse,

    NotSupported1,

    Av61883_MAX
};

//
// Plug States
//
#define CMP_PLUG_STATE_IDLE                 0
#define CMP_PLUG_STATE_READY                1
#define CMP_PLUG_STATE_SUSPENDED            2
#define CMP_PLUG_STATE_ACTIVE               3

//
// Connect Speeds (not the same as 1394 speed flags!!)
//
#define CMP_SPEED_S100                      0x00
#define CMP_SPEED_S200                      0x01
#define CMP_SPEED_S400                      0x02

//
// CIP Frame Flags
//
#define CIP_VALIDATE_FIRST_SOURCE           0x00000001
#define CIP_VALIDATE_ALL_SOURCE             0x00000002
#define CIP_STRIP_SOURCE_HEADER             0x00000004
#define CIP_USE_SOURCE_HEADER_TIMESTAMP     0x00000008
#define CIP_DV_STYLE_SYT                    0x00000010
#define CIP_AUDIO_STYLE_SYT                 0x00000020

//
// CIP Status Codes
//
#define CIP_STATUS_SUCCESS                  0x00000000
#define CIP_STATUS_CORRUPT_FRAME            0x00000001
#define CIP_STATUS_FIRST_FRAME              0x00000002

//
// Plug Type
//
typedef enum {
    CMP_PlugOut = 0,
    CMP_PlugIn
} CMP_PLUG_TYPE;

//
// Connect Type
//
typedef enum {
    CMP_Broadcast = 0,
    CMP_PointToPoint
} CMP_CONNECT_TYPE;

//
// Client Request Structures
//

//
// GetUnitInfo nLevel's
//
#define GET_UNIT_INFO_IDS               0x00000001      // Retrieves IDs of Unit
#define GET_UNIT_INFO_CAPABILITIES      0x00000002      // Retrieves Capabilities of Unit

typedef struct _GET_UNIT_IDS {

    //
    // UniqueID
    OUT LARGE_INTEGER       UniqueID;
    //
    // VendorID
    //
    OUT ULONG               VendorID;

    //
    // ModelID
    //
    OUT ULONG               ModelID;

    //
    // VendorText Length
    //
    OUT ULONG               ulVendorLength;

    //
    // VendorText String
    //
    OUT PWSTR               VendorText;

    //
    // ModelText Length
    //
    OUT ULONG               ulModelLength;

    //
    // ModelText String
    //
    OUT PWSTR               ModelText;

} GET_UNIT_IDS, *PGET_UNIT_IDS;

typedef struct _GET_UNIT_CAPABILITIES {

    //
    // Number of Output Plugs supported by device
    //
    OUT ULONG               NumOutputPlugs;

    //
    // Number of Input Plugs supported by device
    //
    OUT ULONG               NumInputPlugs;

    //
    // MaxDataRate
    //
    OUT ULONG               MaxDataRate;

    //
    // CTS Flags
    //
    OUT ULONG               CTSFlags;

    //
    // Hardware Flags
    //
    OUT ULONG               HardwareFlags;

} GET_UNIT_CAPABILITIES, *PGET_UNIT_CAPABILITIES;

//
// GetUnitInfo
//
typedef struct _GET_UNIT_INFO {

    IN ULONG                nLevel;

    IN OUT PVOID            Information;

} GET_UNIT_INFO, *PGET_UNIT_INFO;

//
// SetUnitInfo
//
typedef struct _SET_UNIT_INFO {

    IN ULONG                nLevel;

    IN OUT PVOID            Information;

} SET_UNIT_INFO, *PSET_UNIT_INFO;

//
// GetPlugHandle
//
typedef struct _CMP_GET_PLUG_HANDLE {

    //
    // Requested Plug Number
    //
    IN ULONG                PlugNum;

    //
    // Requested Plug Type
    //
    IN CMP_PLUG_TYPE        Type;

    //
    // Returned Plug Handle
    //
    OUT HANDLE              hPlug;

} CMP_GET_PLUG_HANDLE, *PCMP_GET_PLUG_HANDLE;

//
// GetPlugState
//
typedef struct _CMP_GET_PLUG_STATE {

    //
    // Plug Handle
    //
    IN HANDLE               hPlug;

    //
    // Current State
    //
    OUT ULONG               State;

    //
    // Current Data Rate
    //
    OUT ULONG               DataRate;

    //
    // Current Payload Size
    //
    OUT ULONG               Payload;

    //
    // Number of Broadcast Connections
    //
    OUT ULONG               BC_Connections;

    //
    // Number of Point to Point Connections
    //
    OUT ULONG               PP_Connections;

} CMP_GET_PLUG_STATE, *PCMP_GET_PLUG_STATE;

//
// CipDataFormat
//
typedef struct _CIP_DATA_FORMAT {

    //
    // FMT and FDF either known, or discovered
    // via AV/C command
    //
    UCHAR                   FMT;
    UCHAR                   FDF_hi;
    UCHAR                   FDF_mid;
    UCHAR                   FDF_lo;

    //
    // SPH as defined by IEC-61883
    //
    BOOLEAN                 bHeader;

    //
    // QPC as defined by IEC-61883
    //
    UCHAR                   Padding;

    //
    // DBS as defined by IEC-61883
    //
    UCHAR                   BlockSize;

    //
    // FN as defined by IEC-61883
    //
    UCHAR                   Fraction;

    //
    // BlockPeriod - TX Only
    //
    ULONG                   BlockPeriod;

} CIP_DATA_FORMAT, *PCIP_DATA_FORMAT;

//
// Connect
//
typedef struct _CMP_CONNECT {

    //
    // Output Plug Handle
    //
    IN HANDLE               hOutputPlug;

    //
    // Input Plug Handle
    //
    IN HANDLE               hInputPlug;

    //
    // Requested Connect Type
    //
    IN CMP_CONNECT_TYPE     Type;

    //
    // Requested Data Format - TX Only
    //
    IN CIP_DATA_FORMAT      Format;

    //
    // Returned Connect Handle
    //
    OUT HANDLE              hConnect;

} CMP_CONNECT, *PCMP_CONNECT;

//
// Disconnect
//
typedef struct _CMP_DISCONNECT {

    //
    // Connect Handle to Disconnect
    //
    IN HANDLE               hConnect;

} CMP_DISCONNECT, *PCMP_DISCONNECT;

//
// CIP Frame typedef
//
typedef struct _CIP_FRAME CIP_FRAME, *PCIP_FRAME;

//
// ValidateInfo Struct. returned on pfnValidate.
//
typedef struct _CIP_VALIDATE_INFO {

    //
    // Connection Handle
    //
    HANDLE                  hConnect;

    //
    // Validate Context
    //
    PVOID                   Context;

    //
    // TimeStamp for current source packet
    //
    CYCLE_TIME              TimeStamp;

    //
    // Packet offset for current source packet
    //
    PUCHAR                  Packet;

} CIP_VALIDATE_INFO, *PCIP_VALIDATE_INFO;

//
// NotifyInfo Struct. returned on pfnNotify
//
typedef struct _CIP_NOTIFY_INFO {

    //
    // Connection Handle
    //
    HANDLE                  hConnect;

    //
    // Notify Context
    //
    PVOID                   Context;

    //
    // Frame
    //
    PCIP_FRAME              Frame;

} CIP_NOTIFY_INFO, *PCIP_NOTIFY_INFO;

//
// Validate & Notify Routines
//
typedef
ULONG
(*PCIP_VALIDATE_ROUTINE) (
    IN PCIP_VALIDATE_INFO   ValidateInfo
    );

typedef
ULONG
(*PCIP_NOTIFY_ROUTINE) (
    IN PCIP_NOTIFY_INFO     NotifyInfo
    );

//
// CIP Frame Struct
//
struct _CIP_FRAME {

    IN PCIP_FRAME               pNext;              // chain multiple frames together

    IN ULONG                    Flags;              //specify flag options

    IN PCIP_VALIDATE_ROUTINE    pfnValidate;        //backdoor

    IN PVOID                    ValidateContext;

    IN PCIP_NOTIFY_ROUTINE      pfnNotify;          //completion

    IN PVOID                    NotifyContext;

    OUT CYCLE_TIME              Timestamp;

    OUT ULONG                   Status;

    IN OUT PUCHAR               Packet;             //the locked buffer 
};

//
// CIP Attach Frame Structure
//
typedef struct _CIP_ATTACH_FRAME {

    HANDLE                  hConnect;           // Connect Handle

    ULONG                   FrameLength;        // Frame Length

    ULONG                   SourceLength;       // Source Length

    PCIP_FRAME              Frame;              // Frame

} CIP_ATTACH_FRAME, *PCIP_ATTACH_FRAME;

//
// CIP Cancel Frame Structure
//
typedef struct _CIP_CANCEL_FRAME {

    IN HANDLE               hConnect;

    IN PCIP_FRAME           Frame;

} CIP_CANCEL_FRAME, *PCIP_CANCEL_FRAME;

//
// CIP Talk Structure
//
typedef struct _CIP_TALK {

    //
    // Connect Handle
    //
    IN HANDLE               hConnect;

} CIP_TALK, *PCIP_TALK;

//
// CIP Listen Structure
//
typedef struct _CIP_LISTEN {

    //
    // Connect Handle
    //
    IN HANDLE               hConnect;

} CIP_LISTEN, *PCIP_LISTEN;

//
// CIP Stop Structure
//
typedef struct _CIP_STOP {

    //
    // Connect Handle
    //
    IN HANDLE               hConnect;

} CIP_STOP, *PCIP_STOP;

//
// FCP Frame Format
//
typedef struct _FCP_FRAME {
    UCHAR               ctype:4;
    UCHAR               cts:4;
    UCHAR               payload[511];
} FCP_FRAME, *PFCP_FRAME;

//
// FCP Request Structure
//
typedef struct _FCP_Request {
    IN ULONG            Length;
    IN PFCP_FRAME       Frame;
} FCP_REQUEST, *PFCP_REQUEST;

//
// FCP Response Structure
//
typedef struct _FCP_Response {
    IN OUT ULONG        Length;
    IN OUT PFCP_FRAME   Frame;
} FCP_RESPONSE, *PFCP_RESPONSE;

//
// Av61883 Struct
//
typedef struct _AV_61883_REQUEST {

    //
    // Requested Function
    //
    ULONG       Function;

    //
    // Selected DDI Version
    //
    ULONG       Version;

    //
    // Flags
    //
    ULONG       Flags;

    union {

        GET_UNIT_INFO               GetUnitInfo;
        SET_UNIT_INFO               SetUnitInfo;

        CMP_GET_PLUG_HANDLE         GetPlugHandle;
        CMP_GET_PLUG_STATE          GetPlugState;
        CMP_CONNECT                 Connect;
        CMP_DISCONNECT              Disconnect;

        CIP_ATTACH_FRAME            AttachFrame;
        CIP_CANCEL_FRAME            CancelFrame;
        CIP_TALK                    Talk;
        CIP_LISTEN                  Listen;
        CIP_STOP                    Stop;

        FCP_REQUEST                 Request;
        FCP_RESPONSE                Response;
    };
} AV_61883_REQUEST, *PAV_61883_REQUEST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvfmt.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    msdvfmt.h

Abstract:

    Header file for DV format data.

Last changed by:
    
$Author::                $

Environment:

    Kernel mode only

Revision History:

$Revision::                    $
$Date::                        $

--*/




#ifndef _DVFORMAT_INC
#define _DVFORMAT_INC


// ****************
// Support switches
// ****************

//
// Differnt level of WDM supports may use different API
//
// e.g. MmGetSystemAddressForMdl (win9x) 
//          Return NULL for Win9x; bugcheck for Win2000 if NULL would have returned.
//
//      MmGetSystemAddressForMdlSafe (win2000)
//          Not supported in Win9x or Millen
//
// #define USE_WDM110  // Define this if WDM1.10 is used; e.g. Win2000 code base // Define in SOURCES if needed


//
// Turn this on to support HD DVCR 
//#define MSDV_SUPPORT_HD_DVCR

//
// Turn this on to support SDL DVCR 
//
#define MSDV_SUPPORT_SDL_DVCR


//
// Turn on this switch to support bus reset KS event
// #define MSDVDV_SUPPORT_BUSRESET_EVENT


//
// Turn this define to extract timecode from a video frame
// Advantage: faster turn around compare to an AVC status command
// #define MSDV_SUPPORT_EXTRACT_SUBCODE_DATA


//
// To get recorded date and time
// #define MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

//
// Mute audio when in pause state while transmitting to DV
#define MSDV_SUPPORT_MUTE_AUDIO

//
// Support getting regitry value for this device
// WORKITEM: enable this for Whistler
// #define READ_CUTOMIZE_REG_VALUES

//
// Support wait  a little until transport state control command is stabled before return
//
// #define SUPPORT_XPRT_STATE_WAIT_FOR_STABLE


//
// Support IQulityControl for the in pin
//
#define SUPPORT_QUALITY_CONTROL

//
// Suppoprt wait to preroll data at the RUN state
//
#define SUPPORT_PREROLL_AT_RUN_STATE

//
// Support a change in KsProxy to return "not ready" while transmitioning into the PAUSE state
//
#define SUPPORT_KSPROXY_PREROLL_CHANGE

//
// Support using AVC connect info for device to device connection
//
// #define SUPPORT_NEW_AVC

//
// Support Optimizing number of AVC Command retries for non-compliant devices
//
#define SUPPORT_OPTIMIZE_AVCCMD_RETRIES

typedef struct _DV_FORMAT_INFO {
    
    // 2nd quadlet of the CIP header
    //    cipQuad[0]            = 10:[FMT]
    //    cipQuad[1]            = 50/60:STYPE:00
    //    cipQuad[2]+cipQuad[3] = SYT
    UCHAR cipQuad[4];    
    //
    // Holds the number of DIF sequences per vid format
    //
    ULONG ulNumOfDIFSequences;

    //
    // Number of receiving buffers
    //
    ULONG ulNumOfRcvBuffers;

    //
    // Number of transmitting buffers
    //
    ULONG ulNumOfXmtBuffers;

    //
    // Holds DV (audio and video) frame size
    //
    ULONG ulFrameSize;

    //
    // Approximate time per frame
    //
    ULONG ulAvgTimePerFrame;

    //
    // Number of source packet per frame
    //
    ULONG ulSrcPackets;

    //
    // Maximun number of source packets per frame
    //
    ULONG ulMaxSrcPackets;
  
    //
    // Holds the number of quadlets in each data block
    //
    ULONG DataBlockSize;  // 00(256),01(01)...,ff(255) quadlets

    //
    // Holds the number of data blocks into which a source packet is divided.
    //
    ULONG FractionNumber;  // 00(not divided), 01 (2 DataBlks), 10 (4), 11 (8)

    //
    // Quadlet padding count (0..7)
    //
    ULONG QuadPadCount;

    //
    // SourcePacketHeader: 0 (FALSE); else (TRUE)
    //
    ULONG SrcPktHeader; 

} DV_FORMAT_INFO, *PDV_FORMAT_INFO;


//
// DV format tables
//


typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;



// All CIP sizes are in quads. The upper third byte is the size.
#define CIP_HDR_FMT_DV                   0x00
#define CIP_HDR_FMT_DVCPRO               0x1e


//
// 1394 stuff
//
#define SPEED_100_INDEX                     0
#define SPEED_200_INDEX                     1
#define SPEED_400_INDEX                     2


#define CIP_DBS_SD_DVCR                   120       // quadlets in a data block of the SD DVCR; BlueBook Part 2
#define CIP_DBS_HD_DVCR                   240       // quadlets in a data block of the HD DVCR; BlueBook Part 3
#define CIP_DBS_SDL_DVCR                   60       // quadlets in a data block of the SDL DVCR; BlueBook Part 5

#define CIP_FN_SD_DVCR                      0       // Data blocks in a source pacaket of SD DVCR; BlueBook Part 2
#define CIP_FN_HD_DVCR                      0       // Data blocks in a source pacaket of HD DVCR; BlueBook Part 3
#define CIP_FN_SDL_DVCR                     0       // Data blocks in a source pacaket of SDL DVCR; BlueBook Part 5


#define MAX_FCP_PAYLOAD_SIZE              512


// CIP header definition:

// FMT: "Blue book" Part 1, page 25, Table 3; DVCR:000000
#define FMT_DVCR             0x80  // 10:FMT(00:0000)
#define FMT_DVCR_CANON       0x20  // 10:FMT(00:0000); but Canon return 00:FMT(10:0000)
#define FMT_MPEG             0xa0  // 10:FMT(10:0000)

// FDF
#define FDF0_50_60_MASK      0x80
#define FDF0_50_60_PAL       0x80
#define FDF0_50_60_NTSC      0x00

#define FDF0_STYPE_MASK      0x7c
#define FDF0_STYPE_SD_DVCR   0x00  // STYPE: 000:00
#define FDF0_STYPE_SDL_DVCR  0x04  // STYPE: 000:01
#define FDF0_STYPE_HD_DVCR   0x08  // STYPE: 000:10
#define FDF0_STYPE_SD_DVCPRO 0x78  // STYPE: 111:10


//
// FCP and AVCC stuff.  Used in conjunction with defs in 1394.h
//

// DVCR:
#define SUBUNIT_TYPE_CAMCORDER           4
#define SUBUNIT_ID_CAMCORDER             0

#define DIF_SEQS_PER_NTSC_FRAME         10   // SDDV
#define DIF_SEQS_PER_PAL_FRAME          12   // SDDV

#define DIF_SEQS_PER_NTSC_FRAME_SDL      5   // SDLDV
#define DIF_SEQS_PER_PAL_FRAME_SDL       6   // SDLDV

#define DIF_SEQS_PER_NTSC_FRAME_HD      10   // HDDV: same as SDDV but source packet is twice as big
#define DIF_SEQS_PER_PAL_FRAME_HD       12   // HDDV: same as SDDV but source packet is twice as big

#define SRC_PACKETS_PER_NTSC_FRAME     250
#define SRC_PACKETS_PER_PAL_FRAME      300

#define MAX_SRC_PACKETS_PER_NTSC_FRAME 267  // packets for a NTSC DV frame; "about" 29.97 FPS
#define MAX_SRC_PACKETS_PER_PAL_FRAME  320  // packets for a PAL DV frame; exactly 25FPS

#define MAX_SRC_PACKETS_PER_NTSC_FRAME_PAE 100  // SRC_PACKETS_PER_NTSC_FRAME/5
#define MAX_SRC_PACKETS_PER_PAL_FRAME_PAE  120  // SRC_PACKETS_PER_PAL_FRAME/5

#define FRAME_SIZE_SD_DVCR_NTSC     120000
#define FRAME_SIZE_SD_DVCR_PAL      144000

#define FRAME_SIZE_HD_DVCR_NTSC     240000
#define FRAME_SIZE_HD_DVCR_PAL      288000

#define FRAME_SIZE_SDL_DVCR_NTSC     60000
#define FRAME_SIZE_SDL_DVCR_PAL      72000

#define FRAME_TIME_NTSC             333667   // "about" 29.97
#define FRAME_TIME_PAL              400000   // exactly 25
 
#define PCR_OVERHEAD_ID_SDDV        0xf      // 480; delays caused by IEEE 1394 bus parmeters
#define PCR_PAYLOAD_SDDV            (CIP_DBS_SD_DVCR + 2)    // 120 * 4 + 2 * 4 = 480 + 8 = 488; 488/4 = 122 quadlet
#define PCR_PAYLOAD_HDDV            (CIP_DBS_HD_DVCR + 2)    // 240 * 4 + 2 * 4 = 960 + 8 = 968; 968/4 = 242 quadlets
#define PCR_PAYLOAD_SDLDV           (CIP_DBS_SDL_DVCR + 2)   //  60 * 4 + 2 * 4 = 240 + 8 = 248; 248/4 =  62 quadlets


//
// These definition and macros are used to calculate the picture numbers.
// With OHCI spec, the data is returned with the 16bit Cycle time, which includes
// 3 bits of SecondCount and 13 bits of the CycleCount.  This "timer" will wrap in 8 seconds.
//
#define TIME_PER_CYCLE     1250   // One 1394 cycle; unit = 100 nsec
#define CYCLES_PER_SECOND  8000
#define MAX_SECOND_COUNTS     7   // The returned CycleTime contains 3 bits of SecondCount; that is 0..7
#define MAX_CYCLES        (MAX_SECOND_COUNTS + 1) * CYCLES_PER_SECOND    // 0..MAX_CYCLES-1
#define MAX_CYCLES_TIME   (MAX_CYCLES * TIME_PER_CYCLE)                  // unit = 100nsec

#define VALIDATE_CYCLE_COUNTS(CT) ASSERT(CT.CL_SecondCount <= 7 && CT.CL_CycleCount < CYCLES_PER_SECOND && CT.CL_CycleOffset == 0);

#define CALCULATE_CYCLE_COUNTS(CT) (CT.CL_SecondCount * CYCLES_PER_SECOND + CT.CL_CycleCount);

#define CALCULATE_DELTA_CYCLE_COUNT(prev, now) ((now > prev) ? now - prev : now + MAX_CYCLES - prev)

//
// Return avg time per frame in the unit of 100 nsec; 
// for calculation accuracy using only integer calculation, 
// we should do do multimplcation before division.
// That is why the application can request to get numerator and denominator separately.
// 
#define GET_AVG_TIME_PER_FRAME(format)       ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? (1001000/3)  : FRAME_TIME_PAL)
#define GET_AVG_TIME_PER_FRAME_NUM(format)   ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? 1001000      : 400000)
#define GET_AVG_TIME_PER_FRAME_DENOM(format) ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? 3            : 1)


#define GET_NUM_PACKETS_PER_FRAME(format)       ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? 4004/15 /* 100100/375 */ : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_NUM(format)   ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? 4004                     : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_DENOM(format) ((format == FMT_IDX_SD_DVCR_NTSC || format == FMT_IDX_SDL_DVCR_NTSC) ? 15                       : 1)


//
// Data buffers
//
#define DV_NUM_OF_RCV_BUFFERS               16  // Same as number of transmit buffer

#define NUM_BUF_ATTACHED_THEN_ISOCH         4   // number of buffers attached before streaming and also as the water mark.
#define NUM_BUFFER_BEFORE_TRANSMIT_BEGIN    (NUM_BUF_ATTACHED_THEN_ISOCH + 1)  // One extra to avoid repeat frame
#define DV_NUM_EXTRA_USER_XMT_BUFFERS      12   // Extra user buffers that the data source can send to us as a read ahead.
#define DV_NUM_OF_XMT_BUFFERS               (NUM_BUF_ATTACHED_THEN_ISOCH + DV_NUM_EXTRA_USER_XMT_BUFFERS)




//
// The "signature" of the header section of Seq0 of incoming source packets:
//
// "Blue" book, Part2, 11.4 (page 50); Figure 66, table 36 (page 111)
//
// ID0 = {SCT2,SCT1,SCT0,RSV,Seq3,Seq2,Seq1,Seq0} 
//
//     SCT2-0 = {0,0,0} = Header Section Type
//     RSV    = {1}
//     Seq3-0 = {1,1,1,1} for NoInfo or {0,0,0,} for Sequence 0
//
// ID1 = {DSeq3-0, 0, RSV, RSV, RSV} 
//     DSeq3-0 = {0, 0, 0, 0} = Beginning of a DV frame
//
// ID2 = {DBN7,DBN6,DBN5,DBN4,DBN3,DBN2,DBN1,DBN0}
//     DBB7-0 = {0,0,0,0,0,0,0,0,0} = Beginning of a DV frame
//

#define DIF_BLK_ID0_SCT_MASK       0xe0 // 11100000b; Section Type (SCT)2-0 are all 0's for the Header section
#define DIF_BLK_ID1_DSEQ_MASK      0xf0 // 11110000b; DIF Sequence Number(DSEQ)3-0 are all 0's 
#define DIF_BLK_ID2_DBN_MASK       0xff // 11111111b; Data Block Number (DBN)7-0 are all 0's 

#define DIF_HEADER_DSF             0x80 // 10000000b; DSF=0; 10 DIF Sequences (525-60)
                                        //            DSF=1; 12 DIF Sequences (625-50)

#define DIF_HEADER_TFn             0x80 // 10000000b; TFn=0; DIF bloick of area N are transmitted in the current DIF sequence.
                                        //            TFn=1; DIF bloick of area N are NOT transmitted in the current DIF sequence.

//
// AV/C command response data definition
//
#define AVC_DEVICE_TAPE_REC 0x20  // 00100:000
#define AVC_DEVICE_CAMERA   0x38  // 00111:000
#define AVC_DEVICE_TUNER    0x28  // 00101:000


//
// GUID definitions for pins and DV format types.
//

// DV vid only output pin
#define STATIC_PINNAME_DV_VID_OUTPUT \
    0x5b21c540L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c540-7aee-11d1-883b-006097f05c70", PINNAME_DV_VID_OUTPUT);
#define PINNAME_DV_VID_OUTPUT DEFINE_GUIDNAMED(PINNAME_DV_VID_OUTPUT)
#define PINNAME_VID_OUT PINNAME_DV_VID_OUTPUT

// DV A/V output pin
#define STATIC_PINNAME_DV_AV_OUTPUT \
    0x5b21c541L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c540-7aee-11d1-883b-006097f05c70", PINNAME_DV_AV_OUTPUT);
#define PINNAME_DV_AV_OUTPUT DEFINE_GUIDNAMED(PINNAME_DV_AV_OUTPUT)
#define PINNAME_AV_OUTPUT PINNAME_DV_AV_OUTPUT


// DV A/V input pin
#define STATIC_PINNAME_DV_AV_INPUT \
    0x5b21c543L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c543-7aee-11d1-883b-006097f05c70", PINNAME_DV_AV_INPUT);
#define PINNAME_DV_AV_INPUT DEFINE_GUIDNAMED(PINNAME_DV_AV_INPUT)
#define PINNAME_AV_INPUT PINNAME_DV_AV_INPUT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\inc\timebomb.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:       timebomb.c
//
//--------------------------------------------------------------------------

//
//  -- Add these lines after the #include's in the file that handles DriverEntry:
//
//      #ifdef TIME_BOMB
//      #include "..\..\inc\timebomb.c"
//      #endif
//
//  -- Add the following lines to the beginning of DriverEntry:
//
//      #ifdef TIME_BOMB
//      if (HasEvaluationTimeExpired()) {
//          return STATUS_EVALUATION_EXPIRATION;
//      }
//      #endif
//
//  -- If you want to override the default expiration value of 31 days after
//     compile, define the constant DAYS_UNTIL_EXPIRATION before you include
//     timebomb.c
//
//  -- Add -DTIME_BOMB to the $(C_DEFINES) line in the sources file.  If you haven't
//     already done so, you may also want to add -DDEBUG_LEVEL=DEBUGLVL_TERSE.
//
//  -- "Cleanly" recompile your binary with 'build -cZ'
//
//  -- NOTE: This uses the __DATE__ preprocessor directive which inserts a _very_
//           clear-text string into the binary which is easily modifiable with a
//           hex editor.  Suggestions on making this more secure are welcome.
//


#if !defined(_KSDEBUG_)
#include <ksdebug.h>
#endif

#ifndef DAYS_UNTIL_EXPIRATION
#define DAYS_UNTIL_EXPIRATION   31  // default
#endif

typedef enum {
    Jan=1,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec
} MONTH;

MONTH GetMonthFromDateString
(
    char *_BuildDate_
)
{
    MONTH BuildMonth = (MONTH)0;

    ASSERT(_BuildDate_);

    switch (_BuildDate_[0]) {
        case 'A':
            if (_BuildDate_[1] == 'u') {
                BuildMonth = Aug;
            }
            else {
                BuildMonth = Apr;
            }
            break;
        case 'D':
            BuildMonth = Dec;
            break;
        case 'F':
            BuildMonth = Feb;
            break;
        case 'J':
            if (_BuildDate_[1] == 'u') {
                if (_BuildDate_[2] == 'l') {
                    BuildMonth = Jul;
                } else {
                    BuildMonth = Jun;
                }
            } else {
                BuildMonth = Jan;
            }
            break;
        case 'M':
            if (_BuildDate_[2] == 'r') {
                BuildMonth = Mar;
            }
            else {
                BuildMonth = May;
            }
            break;
        case 'N':
            BuildMonth = Nov;
            break;
        case 'O':
            BuildMonth = Oct;
            break;
        case 'S':
            BuildMonth = Sep;
            break;
        default:
            ASSERT(0);
            break;
    }

    return BuildMonth;
}

BOOL HasEvaluationTimeExpired()
{
    //  Get the time that this file was compiled
    char            _BuildDate_[] = __DATE__;
    CSHORT          BuildYear,
                    BuildMonth,
                    BuildDay,
                    ThousandsDigit,
                    HundredsDigit,
                    TensDigit,
                    Digit;
    ULONG           BuildDays,
                    CurrentDays;
    LARGE_INTEGER   CurrentSystemTime;
    TIME_FIELDS     CurrentSystemTimeFields;

    //  Convert _BuildDate_ into something a little more palatable
    // TRACE(TL_PNP_WARNING,("Driver Build Date: %s",_BuildDate_));

    BuildMonth = GetMonthFromDateString(_BuildDate_);

    //  Compensate for a ' ' in the tens digit
    if ( (_BuildDate_[4] >= '0') && (_BuildDate_[4] <= '9') ) {
        TensDigit = _BuildDate_[4] - '0';
    } else {
        TensDigit = 0;
    }
    Digit     = _BuildDate_[5] - '0';
    BuildDay  = (TensDigit * 10) + Digit;

    ThousandsDigit = _BuildDate_[7] - '0';
    HundredsDigit  = _BuildDate_[8] - '0';
    TensDigit      = _BuildDate_[9] - '0';
    Digit          = _BuildDate_[10] - '0';
    BuildYear      = (ThousandsDigit * 1000) + (HundredsDigit * 100) + (TensDigit * 10) + Digit;

    //  Get the current system time and convert to local time
    KeQuerySystemTime( &CurrentSystemTime ); // returns GMT
    RtlTimeToTimeFields( &CurrentSystemTime, &CurrentSystemTimeFields );

    //  For now, only let this binary float for 31 days
    BuildDays = (BuildYear * 365) +
                (BuildMonth * 31) +
                 BuildDay;
    CurrentDays = (CurrentSystemTimeFields.Year * 365) +
                  (CurrentSystemTimeFields.Month * 31) +
                   CurrentSystemTimeFields.Day;

    // TRACE(TL_PNP_WARNING, ("CurrentDays: %d  BuildDays: %d",CurrentDays, BuildDays) );
    if (CurrentDays > BuildDays + DAYS_UNTIL_EXPIRATION) {
        // TRACE(TL_PNP_WARNING, ("Evaluation period expired!") );
        return TRUE;
    }
    else {
        // TRACE(TL_PNP_WARNING, ("Evaluation days left: %d", (BuildDays + 31) - CurrentDays) );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvavc.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MsdvAvc.c

Abstract:

    Interface code with for issuing external device control commands.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "msdvfmt.h"
#include "msdvdef.h"
#include "MsdvUtil.h"
#include "MsdvAvc.h"

#include "EDevCtrl.h"

#define ALWAYS_SET_N_GET_RAW_AVC


PAVCCmdEntry
DVCRFindCmdEntryCompleted(
    PDVCR_EXTENSION pDevExt,
    DVCR_AVC_COMMAND idxDVCRCmd,
    BYTE OpCodeToMatch,
    AvcCommandType cmdTypeToMatch
    );
NTSTATUS 
DVGetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );
NTSTATUS 
DVSetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVGetExtTransportProperty(    
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVSetExtTransportProperty( 
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVGetTimecodeReaderProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );
NTSTATUS 
DVMediaSeekingProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVCRFindCmdEntryCompleted)
     // #pragma alloc_text(PAGE, DVIssueAVCCommand)
     #pragma alloc_text(PAGE, DVGetExtDeviceProperty)
     #pragma alloc_text(PAGE, DVSetExtDeviceProperty)
     #pragma alloc_text(PAGE, DVGetExtTransportProperty)
     #pragma alloc_text(PAGE, DVSetExtTransportProperty)
     #pragma alloc_text(PAGE, DVGetTimecodeReaderProperty)
     #pragma alloc_text(PAGE, DVMediaSeekingProperty)
     #pragma alloc_text(PAGE, DVGetDeviceProperty)
     #pragma alloc_text(PAGE, DVSetDeviceProperty)
#endif
#endif

KSFCP_PACKET  DVcrAVCCmdTable[] = {
//                                                      ctype             subunitaddr       opcode    operands
  {  DV_UNIT_INFO,              -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x30, 0xff, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_SUBUNIT_INFO,           -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x31, 0x07, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_CONNECT_AV_MODE,        -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x20, 0xf0, 0xff, 0xff, 0x20, 0x20}
 ,{  DV_VEN_DEP_CANON_MODE,     -1, 0, CMD_STATUS,   7, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x00, 0x00, 0x00, 0x85, 0x00, 0x10, 0x08, 0xff}
 ,{  DV_VEN_DEP_DVCPRO,         -1, 0, CMD_STATUS,   7, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x00, 0x00, 0x80, 0x45, 0x82, 0x48, 0xff, 0xff}
 ,{  DV_IN_PLUG_SIGNAL_FMT,     -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x19, 0x00, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_OUT_PLUG_SIGNAL_FMT,    -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x18, 0x00, 0xff, 0xff, 0xff, 0xff}

 
 ,{ VCR_TIMECODE_SEARCH,        -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x51, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_TIMECODE_READ,          -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x51, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_ATN_SEARCH,             -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x52, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_ATN_READ,               -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x52, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_RTC_SEARCH,             -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x57, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_RTC_READ,               -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x57, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_OPEN_MIC_CLOSE,         -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x00}
 ,{ VCR_OPEN_MIC_READ,          -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x01}
 ,{ VCR_OPEN_MIC_WRITE,         -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x03}
 ,{ VCR_OPEN_MIC_STATUS,        -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x60, 0xff}

 ,{ VCR_READ_MIC,               -1, 0, CMD_CONTROL, -1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x61}

 ,{ VCR_WRITE_MIC,              -1, 0, CMD_CONTROL, -1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x62}

 ,{ VCR_OUTPUT_SIGNAL_MODE,     -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x78, 0xff}
 ,{ VCR_INPUT_SIGNAL_MODE,      -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x79, 0xff}

 ,{ VCR_LOAD_MEDIUM_EJECT,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc1, 0x60}

 ,{ VCR_RECORD,                 -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc2, 0x75}
 ,{ VCR_RECORD_PAUSE,           -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc2, 0x7d}

 ,{ VCR_PLAY_FORWARD_STEP,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x30}  // 00=AVC, 20=VCR, c3=Opcode, 30=Operand[0]
 ,{ VCR_PLAY_FORWARD_SLOWEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x31}  
 ,{ VCR_PLAY_FORWARD_SLOWEST2,  -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x33}  
 ,{ VCR_PLAY_FORWARD_FASTEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x3f}

 ,{ VCR_PLAY_REVERSE_STEP,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x40} 
 ,{ VCR_PLAY_REVERSE_SLOWEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x41}
 ,{ VCR_PLAY_REVERSE_SLOWEST2,  -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x43}
 ,{ VCR_PLAY_REVERSE_FASTEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x4f}
 
 ,{ VCR_PLAY_FORWARD,           -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x75}  
 ,{ VCR_PLAY_FORWARD_PAUSE,     -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x7d}

 ,{ VCR_WIND_STOP,              -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x60}
 ,{ VCR_WIND_REWIND,            -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x65}
 ,{ VCR_WIND_FAST_FORWARD,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x75}

 ,{ VCR_TRANSPORT_STATE,        -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0xd0, 0x7f}
 ,{ VCR_TRANSPORT_STATE_NOTIFY, -1, 0, CMD_NOTIFY,   1, AVC_CTYPE_NOTIFY, UNIT_TYPE_ID_VCR, 0xd0, 0x7f}


 ,{ VCR_MEDIUM_INFO,            -1, 0, CMD_STATUS,   2, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0xda, 0x7f,0x7f}

 ,{ VCR_RAW_AVC,                 1, 0, CMD_CONTROL | CMD_STATUS | CMD_NOTIFY | CMD_SPEC_INQ | CMD_GEN_INQ, 0}

};



void
DVCRXlateGetMediumInfo(
    PMEDIUM_INFO pMediumInfo,
    PBYTE pbOperand0,
    PBYTE pbOperand1
    )
{
    switch(*pbOperand0) {

    // Support for DigitalHi8; if we get this query, we treat DHi8 as a mini DV tape.
    case 0x12:  // DHi8

    case 0x31:// DVCR standard cassette
    case 0x32:// DVCR small cassette
    case 0x33:// DVCR medium cassette
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_DVC;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x22: // VHS cassette
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_VHS;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x23:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_VHSC;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x60:
        pMediumInfo->MediaPresent  = FALSE;
        pMediumInfo->MediaType     = ED_MEDIA_NOT_PRESENT;
        pMediumInfo->RecordInhibit = TRUE;  // Cannot record if there is no tape.
        break;
    case 0x7e:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_UNKNOWN;
        pMediumInfo->RecordInhibit = TRUE;  // Actually cannot be determined
    break;
    default:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_UNKNOWN;
        pMediumInfo->RecordInhibit = TRUE;
        break;
    }

    // Reset command opcode/operands
    *pbOperand0 = 0x7f;
    *pbOperand1 = 0x7f;
}

void
DVCRXlateGetTransportState(
    PTRANSPORT_STATE pXPrtState,
    PBYTE pbOpcode,
    PBYTE pbOperand0
    )
{

    TRACE(TL_FCP_TRACE,("\'DVCRXlateGetTransportState: OpCode %x, Operand %x\n", *pbOpcode, *pbOperand0));

    switch(*pbOpcode) {

    case OPC_LOAD_MEDIUM:
        pXPrtState->Mode = ED_MEDIA_UNLOAD;
        ASSERT(*pbOperand0 == 0x60);
        break;

    case OPC_RECORD:
        pXPrtState->Mode = ED_MODE_RECORD;
        switch(*pbOperand0) {
        case 0x75: // RECORD
            pXPrtState->State = ED_MODE_RECORD;
            break;
        case 0x7d: // RECORD_FREEZE
            pXPrtState->State = ED_MODE_RECORD_FREEZE;
            break;
        default:
            ASSERT(FALSE && "OPC_RECORD: Operand0 undefined!");
            break;
        }
        break;

    case OPC_PLAY:
        pXPrtState->Mode = ED_MODE_PLAY;
        switch(*pbOperand0) {
        case 0x30:  // NEXT FRAME
            pXPrtState->State = ED_MODE_STEP_FWD;
            break;
        case 0x31:  // SLOWEST FORWARD
        case 0x32:  // SLOW FORWARD 6        
        case 0x33:  // SLOW FORWARD 5
        case 0x34:  // SLOW FORWARD 4
        case 0x35:  // SLOW FORWARD 3
        case 0x36:  // SLOW FORWARD 2
        case 0x37:  // SLOW FORWARD 1
            pXPrtState->State = ED_MODE_PLAY_SLOWEST_FWD;
            break;
        case 0x38:  // PLAY FORWARD 1
            pXPrtState->State = ED_MODE_PLAY;
            break;
        case 0x39:  // FAST FORWARD 1
        case 0x3a:  // FAST FORWARD 2
        case 0x3b:  // FAST FORWARD 3
        case 0x3c:  // FAST FORWARD 4
        case 0x3d:  // FAST FORWARD 5
        case 0x3e:  // FAST FORWARD 6
        case 0x3f:  // FASTEST FORWARD
            pXPrtState->State = ED_MODE_PLAY_FASTEST_FWD;
            break;
        case 0x40:  // PREVIOUS FRAME
            pXPrtState->State = ED_MODE_STEP_REV;
            break;
        case 0x41:  // SLOWEST REVERSE
        case 0x42:  // SLOW REVERSE 6
        case 0x43:  // SLOW REVERSE 5 
        case 0x44:  // SLOW REVERSE 4 
        case 0x45:  // SLOW REVERSE 3
        case 0x46:  // SLOW REVERSE 2 
        case 0x47:  // SLOW REVERSE 1 
            pXPrtState->State = ED_MODE_PLAY_SLOWEST_REV;
            break;
        case 0x48:  // X1 REVERSE
        case 0x65:  // REVERSE 
            pXPrtState->State = ED_MODE_REV_PLAY;
            break;
        case 0x49:  // FAST REVERSE 1
        case 0x4a:  // FAST REVERSE 2
        case 0x4b:  // FAST REVERSE 3
        case 0x4c:  // FAST REVERSE 4
        case 0x4d:  // FAST REVERSE 5
        case 0x4e:  // FAST REVERSE 6
        case 0x4f:  // FASTEST REVERSE
            pXPrtState->State = ED_MODE_PLAY_FASTEST_REV;
            break;
        case 0x75:  // FORWARD
            pXPrtState->State = ED_MODE_PLAY;
            break;
        case 0x6d:  // REVERSE PAUSE
        case 0x7d:  // FORWARD PAUSE
            pXPrtState->State = ED_MODE_FREEZE;
            break;
        default:
            pXPrtState->State = 0;
            ASSERT(FALSE && "OPC_PLAY: Operand0 undefined!");
            break;
        }
        break;

    case OPC_WIND:
        //pXPrtState->Mode = ED_MODE_WIND;
        switch(*pbOperand0) {
        case 0x45:  // HIGH SPEED REWIND
            pXPrtState->State = ED_MODE_REW_FASTEST;
            break;
        case 0x60:  // STOP
            pXPrtState->State = ED_MODE_STOP;
            break;
        case 0x65:  // REWIND
            pXPrtState->State = ED_MODE_REW;
            break;
        case 0x75:  // FAST FORWARD
            pXPrtState->State = ED_MODE_FF;
            break;
        default:
            TRACE(TL_FCP_ERROR,("DVCRXlateGetTransportState:  OPC_WIND with unknown operand0 %x\n", *pbOperand0));            
            break;
        }
        // Thre is not a state defined for WIND
        pXPrtState->Mode = pXPrtState->State;
        break;

    case OPC_TRANSPORT_STATE:  // As a result of the notify command
        break;

    default:
        ASSERT(FALSE && "OpCode undefined!");
        break;
    }

    // Reset command opcode/operands
    *pbOpcode   = 0xd0;
    *pbOperand0 = 0x7f;
}


void
DVCRXlateGetIOSignalMode(
    PULONG pIOSignalMode,
    PBYTE pbOperand0
    )
{

    switch(*pbOperand0) {
    // Sony's digital Hi8 can take analog 8MM tape and output DV signal.
    case 0x06:  // Analog 8mm NTSC
    case 0x0e:  // Analog Hi8 NTSC
        TRACE(TL_FCP_WARNING,("\'***** Signal mode:%x (8MM NTSC)\n", *pbOperand0)); 
    case 0x00:  // SD 525-60
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_525_60_SD;
        break;
    case 0x04:  // SDL 525-60
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_525_60_SDL;
        break;
    // Sony's digital Hi8 can take analog 8MM tape and output DV signal.
    case 0x86:  // Analog 8mm PAL
    case 0x8e:  // Analog Hi8 PAL
        TRACE(TL_FCP_WARNING,("\'***** Signal mode:%x (8MM PAL)\n", *pbOperand0)); 
    case 0x80:  // SD 625-50
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_625_50_SD;
        break;
    case 0x84:  // SDL 625-50
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_625_50_SDL;
        break;
    default:
        // This driver does not understand other format; 
        TRACE(TL_FCP_WARNING,("***** Unknown signal mode:%x\n", *pbOperand0));         
        ASSERT(FALSE && "Unknown IoSignal!");
        break;
    }

    // Reset command opcode/operands
    *pbOperand0 = 0xff;
}

NTSTATUS
DVCRXlateRawAVC(
    PAVCCmdEntry pCmdEntry,
    PVOID     pProperty
    )
{
    PAVC_COMMAND_IRB pAvcIrb = pCmdEntry->pAvcIrb;
    UCHAR ucRespCode = pAvcIrb->ResponseCode;   
    NTSTATUS  Status;
    PUCHAR   pbRtnBuf;
    //PKSPROPERTY_EXTDEVICE_S pExtDeviceProperty;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    PKSPROPERTY_TIMECODE_S pTmCdReaderProperty;

    if(STATUS_SUCCESS != pCmdEntry->Status) {
        TRACE(TL_FCP_ERROR,("\'** DVCRXlateRawAVC: Status:%x ** \n", pCmdEntry->Status));
        return pCmdEntry->Status;
    }


    switch (pCmdEntry->idxDVCRCmd) {
    case DV_UNIT_INFO:       
        pbRtnBuf = (PBYTE) pProperty;        
        memcpy(pbRtnBuf, pAvcIrb->Operands+1, 4);
        break;
    case DV_SUBUNIT_INFO:
    case DV_IN_PLUG_SIGNAL_FMT:
    case DV_OUT_PLUG_SIGNAL_FMT:
        pbRtnBuf = (PBYTE) pProperty;
        memcpy(pbRtnBuf, pAvcIrb->Operands+1, 4);
        break;
     // special case, return the response code in the first byte
    case DV_CONNECT_AV_MODE:
        pbRtnBuf = (PBYTE) pProperty;
        pbRtnBuf[0] = ucRespCode;
        memcpy(&pbRtnBuf[1], pAvcIrb->Operands, 5);        
        break;
     // special case, return the response code in the first byte
    case DV_VEN_DEP_CANON_MODE:
        pbRtnBuf = (PBYTE) pProperty;
        pbRtnBuf[0] = ucRespCode;
        memcpy(&pbRtnBuf[1], pAvcIrb->Operands, 7);        
        break;
    case VCR_TIMECODE_READ:
        pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pProperty;
        if(pAvcIrb->Operands[1] == 0xff || 
           pAvcIrb->Operands[2] == 0xff || 
           pAvcIrb->Operands[3] == 0xff || 
           pAvcIrb->Operands[4] == 0xff )  {
            TRACE(TL_FCP_WARNING,("\'TimeCodeRead: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
            // Even though command succeded, but the data is not valid!
            Status = STATUS_UNSUCCESSFUL;
        } else {
            // bswap them.
            pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                (((DWORD) pAvcIrb->Operands[4]) << 24) |
                (((DWORD) pAvcIrb->Operands[3]) << 16) |
                (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                 ((DWORD) pAvcIrb->Operands[1]);
             TRACE(TL_FCP_TRACE,("\'TimeCodeRead: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
        }
        break;
    case VCR_ATN_READ:
        pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pProperty;
          if(pAvcIrb->Operands[1] == 0x00 && 
           pAvcIrb->Operands[2] == 0x00 && 
           pAvcIrb->Operands[3] == 0x00 )  {
            // Even though command succeded, but the data is not valid!
            Status = STATUS_UNSUCCESSFUL;
        } else {
            pTmCdReaderProperty->TimecodeSamp.dwUser = 
                pAvcIrb->Operands[1] & 0x01;  // Get the Blank flag
             // bswap them.
            pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                ( (((DWORD) pAvcIrb->Operands[3]) << 16) |
                  (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                  (((DWORD) pAvcIrb->Operands[1]))
                ) >> 1;
        }
        break;
    case VCR_INPUT_SIGNAL_MODE:
    case VCR_OUTPUT_SIGNAL_MODE:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetIOSignalMode(&pXPrtProperty->u.SignalMode, &pAvcIrb->Operands[0]);
        break;
    case VCR_TRANSPORT_STATE:
    case VCR_TRANSPORT_STATE_NOTIFY:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetTransportState(&pXPrtProperty->u.XPrtState, &pAvcIrb->Opcode, &pAvcIrb->Operands[0]);
        break;
    case VCR_MEDIUM_INFO:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetMediumInfo(&pXPrtProperty->u.MediumInfo, &pAvcIrb->Operands[0], &pAvcIrb->Operands[1]);
        break;
    case VCR_RAW_AVC:
        // Do nothing.
        break;
     default:
        // No translation necessary
         TRACE(TL_FCP_TRACE,("\'No tranlsation: pCmdEntry:%x; idx:%d\n", pCmdEntry, pCmdEntry->idxDVCRCmd));
        break;
    }

    return pCmdEntry->Status;
}



PAVCCmdEntry
DVCRFindCmdEntryCompleted(
    PDVCR_EXTENSION pDevExt,
    DVCR_AVC_COMMAND idxDVCRCmd,
    BYTE OpCodeToMatch,
    AvcCommandType cmdTypeToMatch
    )
/*++

Routine Description:

Arguments:

Return Value:

    PLIST_ENTRY

--*/
{
    LIST_ENTRY   *pEntry;
    KIRQL         OldIrql;

    PAGED_CODE();

    //
    // Special case:
    //
    //     ATN:       Status 01 20 52; Control 00 20 52
    //     (resp)            0c 20 52          0f 20 52   (CtrlInterim)
    //
    //     XPrtState: Status 01 20 d0;  Notify 03 20 d0
    //     (resp)            0c 20 xx          0f 20 xx xx (NotifyInterim)      
    //
    // Summary: if we keep cmdType and OpCode, it is unique.
    //
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    pEntry = pDevExt->AVCCmdList.Flink;
    while(pEntry != &pDevExt->AVCCmdList) {       
        PAVCCmdEntry pCmdEntry = (PAVCCmdEntry)pEntry;

        if (pCmdEntry->idxDVCRCmd == idxDVCRCmd) {
            //
            //  We only fetch if it is completed!       
            //
            if(pCmdEntry->cmdState != CMD_STATE_ISSUED) {
                if (pCmdEntry->cmdType == cmdTypeToMatch) {
                    // Control/GenInq/SpecInq: OpCode and Operand[n] remina unchanged.
                    if (pCmdEntry->OpCode == OpCodeToMatch) {
                        TRACE(TL_FCP_TRACE,("\'DVCRFindCmdEntryCompleted: (1) Found pCmdEntry:%x (%x, %x, %x)\n", 
                            pCmdEntry, pCmdEntry->pAvcIrb, cmdTypeToMatch, OpCodeToMatch));

                        RemoveEntryList(&pCmdEntry->ListEntry);  pDevExt->cntCommandQueued--;
                        InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership

                        // pIrp should be NULL (completed).
                        if(pCmdEntry->pIrp) {
                            TRACE(TL_FCP_ERROR,("\'*** FindCmdEntry: pCmdEntry:%x; pIrp:%x not completed\n", pCmdEntry, pCmdEntry->pIrp));
                        } 

                        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

                        return pCmdEntry;  // Found
                    } 

                } else {
                    TRACE(TL_FCP_TRACE,("\'DVCRFindCmdEntryCompleted: cmdType %x != %x\n", pCmdEntry->cmdType, cmdTypeToMatch));
                }
            }
            else {
                TRACE(TL_FCP_TRACE,("\'DVCRFindCmdEntryCompleted: (0) Skip %x not completed (%x, %x) match entry %x\n", 
                        pCmdEntry, cmdTypeToMatch, OpCodeToMatch));                
            }
        }

        pEntry = pEntry->Flink;
    }

    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

    TRACE(TL_FCP_TRACE,("\'DVCRFindCmdEntryCompleted: (a) No match\n"));                
    return NULL; // No match
}


void
DVAVCCmdResetAfterBusReset(
    PDVCR_EXTENSION pDevExt
    )
/*++

Routine Description:

Arguments:

Return Value:

    Nothing

--*/
{
    KIRQL        OldIrql;

    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    TRACE(TL_FCP_TRACE,("\'Flush AVCCmd: <enter> AVCCmd [completed %d]; CmdList:%x\n", pDevExt->cntCommandQueued, pDevExt->AVCCmdList));

    // Clear the command list
    while (!IsListEmpty(&pDevExt->AVCCmdList)) {

        PAVCCmdEntry pCmdEntry = (PAVCCmdEntry)RemoveHeadList(&pDevExt->AVCCmdList); pDevExt->cntCommandQueued--;
        InitializeListHead(&pCmdEntry->ListEntry);
        TRACE(TL_FCP_TRACE,("\'Flush AVCCmd: Completed:%d; pCmdEntry:%x; cmdState:%d; cmdSt:%x\n", 
            pDevExt->cntCommandQueued, pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status));

        switch(pCmdEntry->cmdState) {
        case CMD_STATE_ISSUED:
        case CMD_STATE_RESP_INTERIM:  // AVC.sys may still has it!
            TRACE(TL_FCP_WARNING,("BusReset: AbortAVC: IoCancelIrp(%x)!\n", pCmdEntry->pIrp));
            ASSERT(pCmdEntry->pIrp != NULL);
            IoCancelIrp(pCmdEntry->pIrp);    // Calls DVIssueAVCCommandCR() with pIrp->Cancel
            break;

        // Completed command
        case CMD_STATE_UNDEFINED:
            TRACE(TL_FCP_ERROR,("DVAVCCmdResetAfterBusReset: Unexpected CMD state %d; pCmdEntry %x\n", pCmdEntry->cmdState, pCmdEntry));
        case CMD_STATE_RESP_ACCEPTED:
        case CMD_STATE_RESP_REJECTED:
        case CMD_STATE_RESP_NOT_IMPL:
        case CMD_STATE_ABORTED:
            break;      

        default:
            TRACE(TL_FCP_ERROR,("DVAVCCmdResetAfterBusReset: Unknown CMD state %d; pCmdEntry %x\n", pCmdEntry->cmdState, pCmdEntry));
            ASSERT(FALSE && "Unknown cmdState\n");
            break;
        }

        // We are guaranteed at this point that no one needs the
        // results anymore so we will free the resources.
        ExFreePool(pCmdEntry->pAvcIrb);
        ExFreePool(pCmdEntry);
    }

    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

#if DBG
    if(pDevExt->cntCommandQueued != 0) {
        TRACE(TL_FCP_ERROR,("\'Flush AVCCmd: <exit> AVCCmd [completed %d]; CmdList:%x\n", pDevExt->cntCommandQueued, pDevExt->AVCCmdList));
        ASSERT(pDevExt->cntCommandQueued == 0 && "All commands should be cancelled or completed.");
    }
#endif
}

NTSTATUS
DVIssueAVCCommandCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PAVCCmdEntry pCmdEntry
    )
/*++

Routine Description:

    This is the completion routine for the AVC command when it is completed which imply that 
    the interim response will not be called here.

Arguments:
    Note: pCmdEntry cannot be used if pIrp->Cancel.

Return Value:

    Always STATUS_MORE_PROCESSING_REQUIRED.
    Note: the real return is in pCmdEntry->Status.

--*/
{
    KIRQL oldIrql;

    if (!pIrp->Cancel) {

        PDVCR_EXTENSION pDevExt = pCmdEntry->pDevExt;
        BOOL bSignalInterimCotrolCompleted = FALSE;
        BOOL bSignalInterimNotifyCompleted = FALSE;
        PKSEVENT_ENTRY   pEvent;


        // Serialize AVC command response processing
        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &oldIrql);

        ASSERT(pCmdEntry->pIrp == pIrp);
        pCmdEntry->pIrp = NULL; // don't need this anymore

        // Check if it's worthwhile to examine the response buffer
        if (STATUS_SUCCESS == pIrp->IoStatus.Status) {

            PAVC_COMMAND_IRB pAvcIrb = pCmdEntry->pAvcIrb;

            // Check Opcode for return state
            switch(pAvcIrb->ResponseCode) {
            case AVC_RESPONSE_NOTIMPL:
                pCmdEntry->cmdState = CMD_STATE_RESP_NOT_IMPL;
                pCmdEntry->Status   = STATUS_NOT_SUPPORTED;  // -> ERROR_NOT_SUPPORTED
                break;

            case AVC_RESPONSE_ACCEPTED:
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        bSignalInterimCotrolCompleted = TRUE;
                        TRACE(TL_FCP_TRACE,("--> Accept: control interim\n"));
                    } else {
                        TRACE(TL_FCP_ERROR,("\'ACCEPT: Invalid cmdType:%d; pCmdExtry %x\n", pCmdEntry->cmdType, pCmdEntry));
                        ASSERT(pCmdEntry->cmdType == AVC_CTYPE_CONTROL && "Accept+Interim but not control cmd");
                    }
                } 
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // -> NOERROR
                break;

            case AVC_RESPONSE_REJECTED:
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        TRACE(TL_FCP_TRACE,("--> Reject: control interim\n"));
                        bSignalInterimCotrolCompleted = TRUE;
                    } else if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                        TRACE(TL_FCP_TRACE,("--> Reject: notify interim\n"));
                        bSignalInterimNotifyCompleted = TRUE;                  
                    } else {
                        TRACE(TL_FCP_ERROR,("REJECT: Invalid cmdType:%d; pCmdExtry %x\n", pCmdEntry->cmdType, pCmdEntry));
                        ASSERT((pCmdEntry->cmdType == AVC_CTYPE_CONTROL || pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) && "Reject+Interim but not control or notify cmd");
                    }
                }
                pCmdEntry->cmdState = CMD_STATE_RESP_REJECTED;
                pCmdEntry->Status   = STATUS_REQUEST_NOT_ACCEPTED;  // ERROR_REQ_NOT_ACCEPTED
                break;

            case AVC_RESPONSE_IN_TRANSITION:
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // -> NOERROR
                break;

            case AVC_RESPONSE_STABLE: // == AVC_RESPONSE_IMPLEMENTED:
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // ->  NOERROR
                break;

            case AVC_RESPONSE_CHANGED:
#if DBG
                if(pCmdEntry->cmdState != CMD_STATE_RESP_INTERIM) {
                   TRACE(TL_FCP_ERROR,("Err: Changed; pCmdExtry:%x; cmdState:%d\n", pCmdEntry, pCmdEntry->cmdState));
                   ASSERT(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM);
                }
#endif
                if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                    TRACE(TL_FCP_TRACE,("--> Changed: for notify interim\n"));
                     bSignalInterimNotifyCompleted = TRUE;                  
                } else {
                    TRACE(TL_FCP_ERROR,("pCmdExtry %x\n", pCmdEntry));
                    ASSERT(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY && "Changed but not notify cmd!");
                }
 
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // ->  NOERROR
                break;

            // AVC.sys should never return this response !!
            case AVC_RESPONSE_INTERIM:              
                ASSERT( pAvcIrb->ResponseCode != AVC_RESPONSE_INTERIM && "CmpRoutine should not has this response!");
                pCmdEntry->cmdState = CMD_STATE_RESP_INTERIM;
                pCmdEntry->Status   = STATUS_MORE_ENTRIES;   // ov.Internal 
                break;
        
            default:
                TRACE(TL_FCP_ERROR,("pCmdEntry%x; State:%d; pAvcIrb:%x; RespCode:%x\n", pCmdEntry, pCmdEntry->cmdState, pAvcIrb, pAvcIrb->ResponseCode));
                ASSERT(FALSE && "Undefined cmdState");
                pCmdEntry->cmdState = CMD_STATE_UNDEFINED;
                pCmdEntry->Status   = STATUS_NOT_SUPPORTED;   // ov.Internal 
                break;
            }

#if DBG
            if(pCmdEntry->cmdState != CMD_STATE_UNDEFINED) {
                TRACE(TL_FCP_WARNING,("\'     AVCRsp: %d:[%.2x %.2x %.2x %.2x]:[%.2x %.2x %.2x %.2x]; cmdSt:%d; St:%x\n",
                    pAvcIrb->OperandLength+3,  // Resp+SuID+OpCd+Opr[]
                    pAvcIrb->ResponseCode,
                    pAvcIrb->SubunitAddr[0],
                    pAvcIrb->Opcode,
                    pAvcIrb->Operands[0],
                    pAvcIrb->Operands[1],
                    pAvcIrb->Operands[2],
                    pAvcIrb->Operands[3],
                    pAvcIrb->Operands[4],
                    pCmdEntry->cmdState,
                    pCmdEntry->Status
                    ));
            }
#endif
        } else {

            // Irp returns ERROR !!
            if (STATUS_BUS_RESET == pIrp->IoStatus.Status || STATUS_REQUEST_ABORTED == pIrp->IoStatus.Status) {
                TRACE(TL_FCP_WARNING,("Bus-Reset or abort (IoStatus.St:%x); pDevRemoved:%d; pCmdEntry:%x; OpC:%x\n", pIrp->IoStatus.Status, pDevExt->bDevRemoved, pCmdEntry, pCmdEntry->OpCode));
                // ASSERT only if it was an ABORT while device was NOTt removed.
                // ASSERT((pIrp->IoStatus.Status == STATUS_BUS_RESET || pDevExt->bDevRemoved) && "Device not removed but command was aborting ?");
                // Busreset while there is an interim pending, signal its client to wake up 
                // and get the "final" (busreset) result.
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        TRACE(TL_FCP_TRACE,("\'--> BusRest: for control interim\n"));
                        bSignalInterimCotrolCompleted = TRUE;
                    } else if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                        TRACE(TL_FCP_TRACE,("\'--> BusRest: for notify interim\n"));
                        bSignalInterimNotifyCompleted = TRUE;                  
                    } 
                }
            }
            else {
                TRACE(TL_FCP_WARNING,("\'IOCTL_AVC_CLASS Failed, pIrp->IoStatus.Status:%x\n", pIrp->IoStatus.Status));
            }

            pCmdEntry->cmdState = CMD_STATE_ABORTED;
            // If the command was timeout, the application may want to try the command again.
            // It is other abort, it might be caused by busreset or dev removal.
            if(pIrp->IoStatus.Status == STATUS_TIMEOUT)
                pCmdEntry->Status = pIrp->IoStatus.Status;
            else if (pIrp->IoStatus.Status == STATUS_DEVICE_DATA_ERROR)  // ERROR_CRC
                pCmdEntry->Status = pIrp->IoStatus.Status;
            else
                pCmdEntry->Status = STATUS_REQUEST_ABORTED;  // -> ERROR_REQUERT_ABORT
        }

        //
        // If suceeded, translate the AVC response to COM property. if not 
        //    interim's final reponse.
        //    raw AVC command response
        //
        if(STATUS_SUCCESS == pCmdEntry->Status &&
           !bSignalInterimNotifyCompleted &&
           !bSignalInterimCotrolCompleted &&
           pCmdEntry->idxDVCRCmd != VCR_RAW_AVC
            )
            DVCRXlateRawAVC(
                pCmdEntry, 
                pCmdEntry->pProperty
                );


        // Signal a KS event to inform its client that the final response 
        // has returned and come and get it.
        if(bSignalInterimNotifyCompleted) {
            pEvent = NULL;

            // There might be multiple instances/threads of IAMExtTransport instance with the same KS event.
            // There is only one device so they all enabled event are singalled.
            do {
                if(pEvent = StreamClassGetNextEvent((PVOID) pDevExt, 0, \
                    (GUID *)&KSEVENTSETID_EXTDEV_Command, KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY, pEvent)) {            
                    // Make sure the right event and then signal it
                    if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY) {
                        StreamClassDeviceNotification(SignalDeviceEvent, pDevExt, pEvent);
                        TRACE(TL_FCP_WARNING,("\'->Signal NOTIFY_INTERIM ready; pEvent:%x, EventId %d.\n", pEvent, pEvent->EventItem->EventId));
                    }          
                }  
            } while (pEvent != NULL);

        } else if(bSignalInterimCotrolCompleted) {
            pEvent = NULL;

            // There might be multiple instances/threads of IAMExtTransport instance with the same KS event.
            // There is only one device so they all enabled event are singalled.
            do {
                if(pEvent = StreamClassGetNextEvent((PVOID) pDevExt, 0, \
                    (GUID *)&KSEVENTSETID_EXTDEV_Command, KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY, pEvent)) {
                    // Make sure the right event and then signal it
                    if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY) {
                        StreamClassDeviceNotification(SignalDeviceEvent, pDevExt, pEvent);
                        TRACE(TL_FCP_WARNING,("\'->Signal CONTROL_INTERIM ready; pEvent:%x, EventId %d.\n", pEvent, pEvent->EventItem->EventId));
                    }          
                }
            } while (pEvent != NULL);
        }

        // Check that the command entry is ours only to process 
        // When a command is completed, it will be added to the list and therefore not empty.
        // It is designed to be added to the list in this completino routine.
        if (!IsListEmpty(&pCmdEntry->ListEntry)) {
            if(bSignalInterimNotifyCompleted || bSignalInterimCotrolCompleted) {
                // If final reponse is returned, we need to keep them in the list.
                TRACE(TL_FCP_TRACE,("\'Final response is completed; stay in the list\n"));
                KeReleaseSpinLock(&pDevExt->AVCCmdLock, oldIrql);
            }
            else {
                // This is a undefined path!!!
                // The command entry can only be in the list if it is interim of anykind.
                // If it is an interim, it will not be removed in the completion routine.
                ASSERT(FALSE && "Cannot complete an interim in CR\n");
            }
        }
        else {
            // This means that we have completed, but the code that issued the
            // command is still executing, and hasn't had a chance to look at
            // the results yet. Put this in the command list as a signal that
            // we have completed and updated the command state, but are not
            // planning to free the command resources.
            InsertTailList(&pDevExt->AVCCmdList, &pCmdEntry->ListEntry); pDevExt->cntCommandQueued++;
            TRACE(TL_FCP_TRACE,("\'Command completed and Queued(%d); pCmdEntry:%x.\n", pDevExt->cntCommandQueued, pCmdEntry));
            KeReleaseSpinLock(&pDevExt->AVCCmdLock, oldIrql);    
        }
    }
    else {
        TRACE(TL_FCP_WARNING,("DVIssueAVCCommandCR: pCmdEntry:%x; pIrp:%x cancelled\n", pCmdEntry, pIrp));
    }

    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // DVIssueAVCCommandCR

NTSTATUS  
DVIssueAVCCommand (
    IN PDVCR_EXTENSION pDevExt, 
    IN AvcCommandType cType,
    IN DVCR_AVC_COMMAND idxAVCCmd,
    IN PVOID pProperty
    )
/*++

Routine Description:

    Issue a FCP/AVC command.

Arguments:
    

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS      Status; 
    PAVCCmdEntry pCmdEntry;
    PAVC_COMMAND_IRB  pAvcIrb; 
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
    ULONGLONG tmStart;
    DWORD dwElapsed;
    KIRQL OldIrql;
    LIST_ENTRY   *pEntry;

    PAGED_CODE();   
 

    if(pDevExt->bDevRemoved)
        return STATUS_DEVICE_NOT_CONNECTED; // ERROR_NOT_READY

    //
    // Validate Command type; the command type that each entry of the command table support.
    //
    switch(cType) {
    case AVC_CTYPE_CONTROL:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_CONTROL) != CMD_CONTROL)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_STATUS:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_STATUS) != CMD_STATUS)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_SPEC_INQ:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_SPEC_INQ) != CMD_SPEC_INQ) 
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_GEN_INQ:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_GEN_INQ) != CMD_GEN_INQ)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_NOTIFY:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_NOTIFY) != CMD_NOTIFY)
           return STATUS_NOT_SUPPORTED;
        break;
    default:
        TRACE(TL_FCP_ERROR,("DVIssueAVCCommand: Unknown or invalid cmdType: idx %d, ctype (%02x) not supported; (%02x %02x %02x) %d:[%.8x]\n",
            idxAVCCmd,
            cType,
            DVcrAVCCmdTable[idxAVCCmd].CType,
            DVcrAVCCmdTable[idxAVCCmd].SubunitAddr,
            DVcrAVCCmdTable[idxAVCCmd].Opcode,
            DVcrAVCCmdTable[idxAVCCmd].OperandLength,
            (DWORD) *(&DVcrAVCCmdTable[idxAVCCmd].Operands[0])
            ));
        return STATUS_NOT_SUPPORTED;
    }

    // Restrict only one command to be active at any time.
    // "Active" mean, it is in the process of issuing the command to the device 
    // and is awaiting its first response.
    // Even though there is only one device but there might be mulitple thread isssuing
    // AVC commands at the same time.  By design, application should serialize their command
    // but they may not know what COM interface will result in an AVC command.  In addition,
    // this driver itsefl may issue command to the device.  So flow control become necessary.

    KeWaitForSingleObject( &pDevExt->hMutexIssueAVCCmd, Executive, KernelMode, FALSE, 0 );    

    // Check one more time for device removal
    if(pDevExt->bDevRemoved) {
        KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 
        TRACE(TL_FCP_WARNING,("** AVC command but device is removed!\n"));
        return STATUS_DEVICE_NOT_CONNECTED; // ERROR_NOT_READY
    }


    // Most device cannot keep two command of same cmdType and OpCode at the same time
    // Go thru list of queued (already issues) command, and search for a possible conflict.
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    pEntry = pDevExt->AVCCmdList.Flink;

    while(pEntry != &pDevExt->AVCCmdList) {       
        pCmdEntry = (PAVCCmdEntry)pEntry;

        // Skip the one that is already completed (many differnt command state).
        if(pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED ||
           pCmdEntry->cmdState == CMD_STATE_RESP_REJECTED ||
           pCmdEntry->cmdState == CMD_STATE_RESP_NOT_IMPL || 
           pCmdEntry->cmdState == CMD_STATE_ABORTED) {           
            TRACE(TL_FCP_WARNING,("\'---- pCmdEntry:%x; cmdType:%x; OpCode:%x; completed.\n", pCmdEntry, pCmdEntry->cmdType, pCmdEntry->OpCode));        
        // Find a matching cmdType and OpCode.
        } else if(pCmdEntry->cmdType == cType && 
            pCmdEntry->OpCode == DVcrAVCCmdTable[idxAVCCmd].Opcode) {
            // Conflict, return error.
            TRACE(TL_FCP_ERROR,("----  Conflict pCmdEntry:%x; Current: cmdType:%x, OpCode:%x; rtn STATUS_DEVICE_NOT_READY\n", 
                pCmdEntry, cType, DVcrAVCCmdTable[idxAVCCmd].Opcode));
            // ASSERT(FALSE && "Conflict: duplicate CMD.");
            KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
            KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 
            // ERROR_NOT_READY; device not ready for another command
            return STATUS_DEVICE_NOT_READY;  
        }
        pEntry = pEntry->Flink;
    }
    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

    // Create an AVC IRB and initialize it -
    if(!(pAvcIrb = (AVC_COMMAND_IRB *) ExAllocatePool(NonPagedPool, sizeof(AVC_COMMAND_IRB)))) {
        KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));
    pAvcIrb->Function = AVC_FUNCTION_COMMAND;

    //
    // Set the retry and timeout flag and value.  These are adjusted (tuned) to 
    // some DV device that may not be "semi"-compliant (may take several reteies and 
    // may take more than 100msec)..
    //     
    pAvcIrb->RetryFlag   = 1;   // Set to 1 in order to set Retries.
    pAvcIrb->Retries     = (UCHAR) pDevExt->AVCCmdRetries;

    // - set the AVC command type (Control, Status, Notify, General Inquiry, Specific Inquiry)
    pAvcIrb->CommandType = cType;

    // - override the subunit address in the avc unit driver (if it even has one for us)
    pAvcIrb->SubunitAddrFlag = 1;
    pAvcIrb->SubunitAddr = &DVcrAVCCmdTable[idxAVCCmd].SubunitAddr;
    pAvcIrb->Opcode = DVcrAVCCmdTable[idxAVCCmd].Opcode;

    // - include alternate opcodes for the transport state opcode
    if (pAvcIrb->Opcode == OPC_TRANSPORT_STATE) {
        pAvcIrb->AlternateOpcodesFlag = 1;
        pAvcIrb->AlternateOpcodes = pDevExt->TransportModes;
    }

    // - set up the operand list
    pAvcIrb->OperandLength = DVcrAVCCmdTable[idxAVCCmd].OperandLength;
    ASSERT(pAvcIrb->OperandLength <= MAX_AVC_OPERAND_BYTES);
    RtlCopyMemory(pAvcIrb->Operands, DVcrAVCCmdTable[idxAVCCmd].Operands, pAvcIrb->OperandLength);

    // Create an Irp and initialize it
    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE))) {
        ExFreePool(pAvcIrb);  pAvcIrb = NULL;
        KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Create an AVC Command entry and initialize it
    if(!(pCmdEntry = (AVCCmdEntry *) ExAllocatePool(NonPagedPool, sizeof(AVCCmdEntry)))) {
        ExFreePool(pAvcIrb);  pAvcIrb = NULL;
        IoFreeIrp(pIrp);  pIrp = NULL;
        KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pCmdEntry, sizeof(AVCCmdEntry));
    pCmdEntry->pDevExt      = pDevExt;  // So we can access pDevExt->AVCCmdList;
    pCmdEntry->pProperty    = pProperty;
    pCmdEntry->cmdState     = CMD_STATE_ISSUED;
    pCmdEntry->Status       = STATUS_UNSUCCESSFUL;
    pCmdEntry->cmdType      = cType;
    pCmdEntry->OpCode       = DVcrAVCCmdTable[idxAVCCmd].Opcode;
    pCmdEntry->idxDVCRCmd   = idxAVCCmd;
    pCmdEntry->pAvcIrb      = pAvcIrb;
    pCmdEntry->pIrp         = pIrp;
    InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership

    TRACE(TL_FCP_WARNING,("\'>>>> AVCCmd: %d:[%.2x %.2x %.2x %.2x]:[%.2x %.2x %.2x %.2x]\n",                  
        pAvcIrb->OperandLength+3,  // Resp+SuID+OpCd+Opr[]
        cType,
        pAvcIrb->SubunitAddr[0],
        pAvcIrb->Opcode,
        pAvcIrb->Operands[0],
        pAvcIrb->Operands[1],
        pAvcIrb->Operands[2],
        pAvcIrb->Operands[3],
        pAvcIrb->Operands[4]
        ));

    // Finish initializing the Irp
    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_AVC_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAvcIrb;

    IoSetCompletionRoutine(pIrp, DVIssueAVCCommandCR, pCmdEntry, TRUE, TRUE, TRUE);

    pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    // Used to monitor response time of an AVC command    
    tmStart = GetSystemTime();

    // Now make the call
    // If encounter an interim response, STATUS_PENDING will be returned.    
    Status = 
        IoCallDriver(
            pDevExt->pBusDeviceObject, 
            pIrp
            );

    dwElapsed = (DWORD) ((GetSystemTime() - tmStart)/10000); // Convert 100nsec unit to msec

#if DBG
    if(dwElapsed > MAX_RESPONSE_TIME_FOR_ALERT) {    
        // NON-compliant behaviour
        TRACE(TL_FCP_WARNING,("** ST:%x; AVC Cmd took %d msec to response; CmdType:%d; OpCd:%x\n", Status, dwElapsed, cType, DVcrAVCCmdTable[idxAVCCmd].Opcode));
    } else {
        TRACE(TL_FCP_TRACE,("** ST:%x; AVC Cmd took %d msec to response; CmdType:%d; OpCd:%x\n", Status, dwElapsed, cType, DVcrAVCCmdTable[idxAVCCmd].Opcode));
    }
#endif
   
#ifdef SUPPORT_OPTIMIZE_AVCCMD_RETRIES
    //
    // Collect statistics of AVC command response time during driver loading phase
    // 
    if(!pDevExt->DrvLoadCompleted) {
        if(dwElapsed > pDevExt->AVCCmdRespTimeMax)
            pDevExt->AVCCmdRespTimeMax = dwElapsed;
        if(dwElapsed < pDevExt->AVCCmdRespTimeMin)
            pDevExt->AVCCmdRespTimeMin = dwElapsed;
        pDevExt->AVCCmdRespTimeSum += dwElapsed;
        pDevExt->AVCCmdCount++;
    }
#endif

    // Interim response...
    if (STATUS_PENDING == Status) {      

        // WORKITEM: control command can be in interim for a while!!!
        // Some DV will return interim but it will completed it with a change quickly.
        if(cType == AVC_CTYPE_CONTROL) {
#define MSDV_WAIT_CONTROL_CMD_INTERIM   300
            TRACE(TL_FCP_WARNING,("\'!!!!!!!!!!!  Control Interim-- Wait %d msec !!!!!!!!\n", MSDV_WAIT_CONTROL_CMD_INTERIM));
            DVDelayExecutionThread(MSDV_WAIT_CONTROL_CMD_INTERIM);
#if DBG
            if(DVTraceMask & TL_FCP_TRACE) {
                ASSERT(!IsListEmpty(&pCmdEntry->ListEntry) && "Control Cmd was interim after wait.");
            }
#endif
        }

        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);

        // Check that the Irp didn't complete between the return of IoCallDriver and now
        if (IsListEmpty(&pCmdEntry->ListEntry)) {
            // Enter INTERIM state
            pCmdEntry->cmdState = CMD_STATE_RESP_INTERIM;
            // Return STATUS_MORE_ENTRIES to inform caller that the command is pending.
            pCmdEntry->Status   = STATUS_MORE_ENTRIES;   // xlate to ERROR_MORE_DATA; No yet done with this command so keep the entry in the list

            // We have submitted a control or notify command, and have gotten
            // an Interim response. Put the command in the list so it can be
            // tracked for possible cancellation, and as an indication to the
            // completion routine that we won't be releasing any resources here.
            InsertTailList(&pDevExt->AVCCmdList, &pCmdEntry->ListEntry); pDevExt->cntCommandQueued++;
            pCmdEntry->pProperty = NULL;    // won't be using this, so get rid of it
            TRACE(TL_FCP_TRACE,("\'->AVC command Irp is pending!\n"));
            KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
            KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 
            return pCmdEntry->Status;

        } else {
            // Although IoCallDriver indicated that the command was pending,
            // it has since been completed. The completion routine saw that
            // the command entry had not yet been added to the command list,
            // so put it there to let us know that we need to retain control
            // and free the resources.
            //
            // Temporarily change the status so the cleanup code path will
            // be followed.
            TRACE(TL_FCP_TRACE,("\'-> Cmd Rtns Pending but completed; treat as non-pending! ST:%x\n", pCmdEntry->Status));
            Status = STATUS_SUCCESS;
        }

        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
    } 

    // Status from IoCallDriver can return:
    //    STATUS_PENDING (process above)  // If control, we wait and see if it get completed (risky!!)
    //    STATUS_TIMEOUT 
    //    STATUS_SUCCESS

    if(STATUS_PENDING != Status) {
        // The completion routine is usually the only one that frees the Irp. Is
        // it possible that the completion routine never got called? This will let
        // us know, since the completion routine will always make sure that the
        // command entry's Irp pointer is cleared.
        if(pCmdEntry->pIrp) {
            // If for some reason the completion routine never got called, free the Irp
            if(pCmdEntry->pIrp)
                IoFreeIrp(pCmdEntry->pIrp);
            pCmdEntry->pIrp = NULL;
        }
    }

    //
    // pCmdEntry->Status is the command response Status set in the completion routine, which can be
    //    STATUS_SUCCESS
    //    STATUS_REQ_NOT_ACCEP
    //    STATUS_NOT_SUPPORTED
    //    STATUS_MORE_ENTRIES    // Should not happen!!
    //    STATUS_REQUEST_ABORTED
    //

    // One possible valid command from IoCallDriver is STATUS_TIMEOUT, and
    // this shoull be returned, anything else we will get the status from pCmdEntry->Status
    // which was set in the completion routine.
    if (Status != STATUS_TIMEOUT) 
        Status = pCmdEntry->Status;  // This Status is being returned from this functino

    // Desiding if leaving the command response (entry) in the command list

#ifndef ALWAYS_SET_N_GET_RAW_AVC
    // Not if it is an (1) interim (all STATUS_MORE_ENTRIES); or (2) suceeded RAW AVC response
    if(STATUS_MORE_ENTRIES == Status ||
       VCR_RAW_AVC == pCmdEntry->idxDVCRCmd && STATUS_SUCCESS == Status) {
#else
    // Do not remove entrim response or any RAW AVC command response
    if(STATUS_MORE_ENTRIES == Status ||
       VCR_RAW_AVC == pCmdEntry->idxDVCRCmd) {
#endif
        TRACE(TL_FCP_WARNING,("\'Status:%x; Do not remove (1) interim response or (2) raw AVC command\n", Status));
    } 
    // Else we are done!
    else {
        // It's time to clean up the command
        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
        if (!IsListEmpty(&pCmdEntry->ListEntry)) {
            RemoveEntryList(&pCmdEntry->ListEntry); pDevExt->cntCommandQueued--;
            InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership
        }
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

        // Free the resources
        ExFreePool(pCmdEntry);
        ExFreePool(pAvcIrb);
    }  // else

#if DBG
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_FCP_WARNING,("\'**** DVIssueAVCCmd (exit): St:%x; pCmdEntry:%x; cmdQueued:%d\n", Status, pCmdEntry, pDevExt->cntCommandQueued));
    }
#endif

    KeReleaseMutex(&pDevExt->hMutexIssueAVCCmd, FALSE); 

    return Status;
}



#ifndef OATRUE
#define OATRUE (-1)
#endif
#ifndef OAFALSE
#define OAFALSE (0)
#endif

NTSTATUS 
DVGetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Get external device property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTDEVICE_S pExtDeviceProperty;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTDEVICE_S)); 

    pExtDeviceProperty = (PKSPROPERTY_EXTDEVICE_S) pSPD->PropertyInfo;    // pointer to the data

  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_EXTDEVICE_ID:
        if(pDevExt->ulVendorID) {
            // It was not bswap in the monolithic version so for competibility,
            // we will not bswap this.
            pExtDeviceProperty->u.NodeUniqueID[0] = pDevExt->UniqueID.LowPart; 
            pExtDeviceProperty->u.NodeUniqueID[1] = pDevExt->UniqueID.HighPart;
            // TRACE(TL_FCP_WARNING,("Vid:%x; Mid:%x\n", bswap(pDevExt->ulVendorID) >> 8, pDevExt->ulModelID ));
            TRACE(TL_FCP_WARNING,("\'Low:%x; High:%x of UniqueID\n", pDevExt->UniqueID.LowPart, pDevExt->UniqueID.HighPart ));
            Status = STATUS_SUCCESS;
        } else {
            TRACE(TL_FCP_ERROR,("Failed: Vid:%x; Mid:%x\n", bswap(pDevExt->ulVendorID) >> 8, pDevExt->ulModelID ));
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

    case KSPROPERTY_EXTDEVICE_VERSION:
        // AV/C VCR Subunit Specification 2.0.1
        wcscpy(pExtDeviceProperty->u.pawchString, L"2.0.1");  
        Status = STATUS_SUCCESS;
        break;

    case KSPROPERTY_EXTDEVICE_POWER_STATE:       
        switch(pDevExt->PowerState) {
        case PowerDeviceD3:
            pExtDeviceProperty->u.PowerState  = ED_POWER_OFF; 
            break;
        case PowerDeviceD2:
        case PowerDeviceD1:
            pExtDeviceProperty->u.PowerState  = ED_POWER_STANDBY; 
            break;
        default:
        case PowerDeviceD0:
            pExtDeviceProperty->u.PowerState  = ED_POWER_ON; 
            break;
        }
        Status = STATUS_SUCCESS;        
        break;        


    case KSPROPERTY_EXTDEVICE_PORT:
        pExtDeviceProperty->u.DevPort  = DEV_PORT_1394; 
        Status = STATUS_SUCCESS;        
        break;        

    case KSPROPERTY_EXTDEVICE_CAPABILITIES:


        if((GetSystemTime() - pDevExt->tmLastFormatUpdate) > FORMAT_UPDATE_INTERVAL) {
            // Refresh mode of operation whenever capabilities is queried
            // since the mode of operation might have changed and is returned..
            DVGetDevModeOfOperation(pDevExt);

            // Since format can dynamically change, we will query new format here.
            // Note: during data intersection, we compare FrameSize and that is 
            // format related.

            if(!DVGetDevSignalFormat(pDevExt, KSPIN_DATAFLOW_OUT,0)) {
                // If querying its format has failed, we cannot open this stream.
                TRACE(TL_FCP_WARNING,("SRB_GET_DATA_INTERSECTION:Failed getting signal format.\n"));
            }

            // Update system time to reflect last update
            pDevExt->tmLastFormatUpdate = GetSystemTime();  
        }

        // Can record only in VCR mode and has input plug(s).
        pExtDeviceProperty->u.Capabilities.CanRecord  = ((pDevExt->ulDevType == ED_DEVTYPE_VCR) ? (pDevExt->NumInputPlugs > 0 ? OATRUE : OAFALSE): OAFALSE);
        pExtDeviceProperty->u.Capabilities.CanRecordStrobe  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.HasAudio   = OATRUE;         
        pExtDeviceProperty->u.Capabilities.HasVideo   = OATRUE;        
        pExtDeviceProperty->u.Capabilities.UsesFiles  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.CanSave    = OAFALSE;
        pExtDeviceProperty->u.Capabilities.DeviceType = pDevExt->ulDevType;        
        pExtDeviceProperty->u.Capabilities.TCRead     = OATRUE;        
        pExtDeviceProperty->u.Capabilities.TCWrite    = OAFALSE; // DV decided        
        pExtDeviceProperty->u.Capabilities.CTLRead    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.IndexRead  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.Preroll    = 0L;      // NOT implemented, supposely can reg in INF and then read from registry       
        pExtDeviceProperty->u.Capabilities.Postroll   = 0L;      // NOT implemented, supposely can reg in INF and then read from registry 
        pExtDeviceProperty->u.Capabilities.SyncAcc    = ED_CAPABILITY_UNKNOWN;       
        pExtDeviceProperty->u.Capabilities.NormRate   = ((pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC) ? ED_RATE_2997 : ED_RATE_25);
        pExtDeviceProperty->u.Capabilities.CanPreview = OAFALSE;    // View what is in the bus or tape
        pExtDeviceProperty->u.Capabilities.CanMonitorSrc = OATRUE;  // ViewFinder
        pExtDeviceProperty->u.Capabilities.CanTest    = OAFALSE;    // To see if a function is iplemented
        pExtDeviceProperty->u.Capabilities.VideoIn    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.AudioIn    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.Calibrate  = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.SeekType   = ED_CAPABILITY_UNKNOWN;  

        TRACE(TL_FCP_INFO,("\'DVCRGetExtDeviceProperty: DeviceType %x\n", pExtDeviceProperty->u.Capabilities.DeviceType));

        Status = STATUS_SUCCESS;               
        break;
       
    default:
        Status = STATUS_NOT_SUPPORTED;        
        break;
    }

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTDEVICE_S) : 0);

    return Status;
}




NTSTATUS 
DVSetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Set external device property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTDEVICE_S pExtDeviceProperty;

    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTDEVICE_S)); 

    pExtDeviceProperty = (PKSPROPERTY_EXTDEVICE_S) pSPD->PropertyInfo;    // pointer to the data

  
    switch (pSPD->Property->Id) {
    default:
        Status = STATUS_NOT_SUPPORTED;        
        break;
    }

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTDEVICE_S) : 0);
 
    return Status;
}

NTSTATUS 
DVGetExtTransportProperty(    
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Get external transport property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS 

--*/
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_STATUS;
    BOOL bHasTape = pDevExt->bHasTape;

    PAVCCmdEntry  pCmdEntry;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTXPORT_S)); 

    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pSPD->PropertyInfo;    // pointer to the data
    *pulActualBytesTransferred = 0;


    switch (pSPD->Property->Id) {
    case KSPROPERTY_EXTXPORT_CAPABILITIES:
        return STATUS_NOT_IMPLEMENTED;

    case KSPROPERTY_RAW_AVC_CMD:
        pCmdEntry = DVCRFindCmdEntryCompleted( 
            pDevExt, 
            VCR_RAW_AVC,
            DVcrAVCCmdTable[VCR_RAW_AVC].Opcode,
            DVcrAVCCmdTable[VCR_RAW_AVC].CType
            );

        if(pCmdEntry) {
            PAVC_COMMAND_IRB pAvcIrb;

            pAvcIrb = pCmdEntry->pAvcIrb;
            ASSERT(pAvcIrb);
#ifndef ALWAYS_SET_N_GET_RAW_AVC
            // Only successful response has a valid response to return
            if (pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED) {
#else
            // Any of these response codes has a response to return, 
            // include "reject", "not implemented" response code
            if (pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED ||
                pCmdEntry->cmdState == CMD_STATE_RESP_REJECTED ||
                pCmdEntry->cmdState == CMD_STATE_RESP_NOT_IMPL ||
                pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
#endif
                // bytes for operands plus response, subunit addr, and opcode
                pXPrtProperty->u.RawAVC.PayloadSize = pAvcIrb->OperandLength + 3;
                pXPrtProperty->u.RawAVC.Payload[0] = pAvcIrb->ResponseCode;
                pXPrtProperty->u.RawAVC.Payload[1] = pAvcIrb->SubunitAddr[0];
                pXPrtProperty->u.RawAVC.Payload[2] = pAvcIrb->Opcode;                
                RtlCopyMemory(&pXPrtProperty->u.RawAVC.Payload[3], pAvcIrb->Operands, pAvcIrb->OperandLength);

                TRACE(TL_FCP_WARNING,("\'RawAVCResp: pEntry:%x; State:%x; Status:%x; Sz:%d; Rsp:%x;SuId:%x;OpCd:%x; Opr:[%x %x %x %x]\n",
                    pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status,
                    pXPrtProperty->u.RawAVC.PayloadSize,
                    pXPrtProperty->u.RawAVC.Payload[0],
                    pXPrtProperty->u.RawAVC.Payload[1],
                    pXPrtProperty->u.RawAVC.Payload[2],
                    pXPrtProperty->u.RawAVC.Payload[3],
                    pXPrtProperty->u.RawAVC.Payload[4],
                    pXPrtProperty->u.RawAVC.Payload[5],
                    pXPrtProperty->u.RawAVC.Payload[6]
                    )); 

                // Final Status
#ifndef ALWAYS_SET_N_GET_RAW_AVC
                Status = pCmdEntry->Status;
#else           
                // If not success, bytes transferred and data will not returned!
                Status = STATUS_SUCCESS;  
#endif
                *pulActualBytesTransferred = sizeof (KSPROPERTY_EXTXPORT_S);
            } else {
                TRACE(TL_FCP_ERROR,("\'RawAVCResp: Found; but pCmdEntry:%x, unexpected cmdState:%d; ST:%x\n", pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status));
                //ASSERT(pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED && "Unexpected command state\n");
                if(pCmdEntry->Status == STATUS_TIMEOUT)
                    Status = STATUS_TIMEOUT;  // if timeout, application may want to try again.
                else
                    Status = STATUS_REQUEST_ABORTED;
                *pulActualBytesTransferred = 0;
            }

            // pIrp is NULL if it has been completed.
            if(pCmdEntry->pIrp) {
                TRACE(TL_FCP_ERROR,("RawAVCResp: pCmdEntry %x; ->pIrp:%x not completd yet!\n", pCmdEntry, pCmdEntry->pIrp));
                ASSERT(pCmdEntry->pIrp == NULL && "pIrp is not completed!");
                IoCancelIrp(pCmdEntry->pIrp);
            }
            // Not used in the completion routine if pIrp->Cancel
            ExFreePool(pCmdEntry);
            ExFreePool(pAvcIrb);
        }
        else {
            TRACE(TL_FCP_ERROR,("\'RAW_AVC_CMD, did not find a match[%x]!\n", 
                *((DWORD *) &DVcrAVCCmdTable[VCR_RAW_AVC].CType) )); 
            *pulActualBytesTransferred = 0;
            Status = STATUS_NOT_FOUND;  // ERROR_MR_MID_NOT_FOUND
        }
        return Status;

    case KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE: // MPEG, D-VHS, Analog VHS etc.
        idxDVCRCmd = VCR_INPUT_SIGNAL_MODE;
        break;
    case KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE: // MPEG, D-VHS, Analog VHS etc.
        idxDVCRCmd = VCR_OUTPUT_SIGNAL_MODE;
        break;
    case KSPROPERTY_EXTXPORT_MEDIUM_INFO:       // cassettte_type and tape_grade_and_write_protect
        idxDVCRCmd = VCR_MEDIUM_INFO;
        break;  
    case KSPROPERTY_EXTXPORT_STATE: 
        idxDVCRCmd = VCR_TRANSPORT_STATE;        
        break; 

    case KSPROPERTY_EXTXPORT_STATE_NOTIFY: 
        // Get final result from previous set command
        pCmdEntry = DVCRFindCmdEntryCompleted( 
            pDevExt, 
            VCR_TRANSPORT_STATE_NOTIFY,
            DVcrAVCCmdTable[VCR_TRANSPORT_STATE_NOTIFY].Opcode,
            DVcrAVCCmdTable[VCR_TRANSPORT_STATE_NOTIFY].CType
            );

        if(pCmdEntry) {
            PAVC_COMMAND_IRB pAvcIrb;

            pAvcIrb = pCmdEntry->pAvcIrb;
            ASSERT(pCmdEntry->pAvcIrb);

            TRACE(TL_FCP_WARNING,("\'->Notify Resp: pCmdEntry:%x; pIrb:%x; %d:[%.2x %.2x %.2x %.2x]\n",
                pCmdEntry, pAvcIrb,
                pAvcIrb->OperandLength + 3,
                pAvcIrb->ResponseCode,
                pAvcIrb->SubunitAddr[0],
                pAvcIrb->Opcode,
                pAvcIrb->Operands[0]
                )); 

            if(pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED)
                Status = 
                    DVCRXlateRawAVC(
                        pCmdEntry, 
                        pXPrtProperty
                        );

            // pIrp is NULL if it has been completed.
            if(pCmdEntry->pIrp) {
                TRACE(TL_FCP_ERROR,("XPrtNotifyResp: pCmdEntry %x; ->pIrp:%x not completed; IoCancelIrp(pIrp)\n", pCmdEntry, pCmdEntry->pIrp));
                IoCancelIrp(pCmdEntry->pIrp);
            }
            // These two are not touched in the CompletionRoutine if pIrp->Cancel
            ExFreePool(pCmdEntry);
            ExFreePool(pAvcIrb);

            *pulActualBytesTransferred = STATUS_SUCCESS == Status ? sizeof (KSPROPERTY_EXTXPORT_S) : 0;
        }
        else {
            TRACE(TL_FCP_ERROR,("EXTXPORT_STATE_NOTIFY: no match!\n"));
            *pulActualBytesTransferred = 0;
            Status = STATUS_NOT_FOUND;  // ERROR_MR_MID_NOT_FOUND
        }
        return Status;

    default:
        TRACE(TL_FCP_ERROR,("DVCRGetExtTransportProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED;                
    }


    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pXPrtProperty);
    TRACE(TL_FCP_TRACE,("\'DVCRGetExtTransportProperty: idxDVCRCmd %d, cmdType %d, Status %x\n", idxDVCRCmd, cType, Status)); 
    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTXPORT_S) : 0);


    if(STATUS_SUCCESS == Status &&
       idxDVCRCmd == VCR_MEDIUM_INFO) {

        // Update Media info
        pDevExt->bHasTape        = pXPrtProperty->u.MediumInfo.MediaPresent;
        pDevExt->bWriteProtected = pXPrtProperty->u.MediumInfo.RecordInhibit;

        TRACE(TL_FCP_TRACE,("\'bHasTape: IN(%d):OUT(%d), ulDevType %d\n", bHasTape, pDevExt->bHasTape, pDevExt->ulDevType));        
    }
 
    return Status;
}




NTSTATUS 
DVSetExtTransportProperty( 
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Set external transport property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferr

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_CONTROL;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTXPORT_S)); 

    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pSPD->PropertyInfo;    // pointer to the data    
    *pulActualBytesTransferred = 0;

    switch (pSPD->Property->Id) {

    case KSPROPERTY_EXTXPORT_STATE: 
     
         switch (pXPrtProperty->u.XPrtState.Mode) {
// RECORD
         case ED_MODE_RECORD:
             idxDVCRCmd = VCR_RECORD;
             break;
         case ED_MODE_RECORD_FREEZE:
             idxDVCRCmd = VCR_RECORD_PAUSE;
             break;

// PLAY
         case ED_MODE_STEP_FWD:
             idxDVCRCmd = VCR_PLAY_FORWARD_STEP;
             break;
         case ED_MODE_PLAY_SLOWEST_FWD:
             // DVCPRO does not seem to support the standard play slow fwd so this is an alternate
             if(pDevExt->bDVCPro)
                 idxDVCRCmd = VCR_PLAY_FORWARD_SLOWEST2;
             else
                 idxDVCRCmd = VCR_PLAY_FORWARD_SLOWEST;
             break;
         case ED_MODE_PLAY_FASTEST_FWD:
             idxDVCRCmd = VCR_PLAY_FORWARD_FASTEST;
             break;

         case ED_MODE_STEP_REV:
             idxDVCRCmd = VCR_PLAY_REVERSE_STEP;
             break;
         case ED_MODE_PLAY_SLOWEST_REV:
             // DVCPRO does not seem to support the standard play slow rev so this is an alternate
             if(pDevExt->bDVCPro)
                 idxDVCRCmd = VCR_PLAY_REVERSE_SLOWEST2;
             else
                 idxDVCRCmd = VCR_PLAY_REVERSE_SLOWEST;
             break;
         case ED_MODE_PLAY_FASTEST_REV:
             idxDVCRCmd = VCR_PLAY_REVERSE_FASTEST;
             break;

         case ED_MODE_PLAY:
             idxDVCRCmd = VCR_PLAY_FORWARD;
             break;
         case ED_MODE_FREEZE:
             idxDVCRCmd = VCR_PLAY_FORWARD_PAUSE;
             break;


// WIND
         case ED_MODE_STOP:
             idxDVCRCmd = VCR_WIND_STOP;
             break;
         case ED_MODE_FF:
             idxDVCRCmd = VCR_WIND_FAST_FORWARD;
             break;
         case ED_MODE_REW:
             idxDVCRCmd = VCR_WIND_REWIND;
             break;


         default:
             TRACE(TL_FCP_ERROR,("XPrtState.Mode %d not supported\n", pXPrtProperty->u.XPrtState.Mode));        
             return STATUS_NOT_SUPPORTED; 
         }
         break;

    case KSPROPERTY_EXTXPORT_STATE_NOTIFY: 
        idxDVCRCmd = VCR_TRANSPORT_STATE_NOTIFY;
        cType = AVC_CTYPE_NOTIFY;        
        TRACE(TL_FCP_TRACE,("\'->Notify XPrt State Cmd issued.\n"));
        break; 

    case KSPROPERTY_EXTXPORT_LOAD_MEDIUM:  
        idxDVCRCmd = VCR_LOAD_MEDIUM_EJECT;
        break;

    case KSPROPERTY_EXTXPORT_TIMECODE_SEARCH: 
        idxDVCRCmd = VCR_TIMECODE_SEARCH;
        TRACE(TL_FCP_WARNING,("\'KSPROPERTY_EXTXPORT_TIMECODE_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED; 
        
    case KSPROPERTY_EXTXPORT_ATN_SEARCH: 
        idxDVCRCmd = VCR_ATN_SEARCH;
        TRACE(TL_FCP_WARNING,("\'KSPROPERTY_EXTXPORT_ATN_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED; 
        
    case KSPROPERTY_EXTXPORT_RTC_SEARCH: 
        idxDVCRCmd = VCR_RTC_SEARCH;
        TRACE(TL_FCP_WARNING,("\'KSPROPERTY_EXTXPORT_RTC_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED;         

    case KSPROPERTY_RAW_AVC_CMD:
        idxDVCRCmd = VCR_RAW_AVC;   
        if(pXPrtProperty->u.RawAVC.PayloadSize <= MAX_FCP_PAYLOAD_SIZE) { 

            DVcrAVCCmdTable[idxDVCRCmd].CType = pXPrtProperty->u.RawAVC.Payload[0];
            DVcrAVCCmdTable[idxDVCRCmd].SubunitAddr = pXPrtProperty->u.RawAVC.Payload[1];
            DVcrAVCCmdTable[idxDVCRCmd].Opcode = pXPrtProperty->u.RawAVC.Payload[2];
            DVcrAVCCmdTable[idxDVCRCmd].OperandLength = pXPrtProperty->u.RawAVC.PayloadSize - 3;
            RtlCopyMemory(DVcrAVCCmdTable[idxDVCRCmd].Operands, pXPrtProperty->u.RawAVC.Payload + 3, DVcrAVCCmdTable[idxDVCRCmd].OperandLength);

            // extract command type; for RAW AVC, it can be anything.
            cType = pXPrtProperty->u.RawAVC.Payload[0];

            TRACE(TL_FCP_WARNING,("\'DVCRSetExtTransportProperty: Set*, cType %x, PayLoadSize %d, PayLoad %x %x %x %x\n",
                cType,
                pXPrtProperty->u.RawAVC.PayloadSize,
                pXPrtProperty->u.RawAVC.Payload[0],
                pXPrtProperty->u.RawAVC.Payload[1],
                pXPrtProperty->u.RawAVC.Payload[2],
                pXPrtProperty->u.RawAVC.Payload[3]
                )); 

        } else {
            Status = STATUS_INVALID_PARAMETER;
            *pulActualBytesTransferred = 0;
            return Status;
        }
        break;

    default:
        TRACE(TL_FCP_ERROR,("DVCRSetExtTransportProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED; 
    }

    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pXPrtProperty);

#ifdef SUPPORT_XPRT_STATE_WAIT_FOR_STABLE
#ifdef READ_CUTOMIZE_REG_VALUES


    // Wait for the transport state change to be stablized.
    // This is only necessary for DV camcorder that reject (or not accept) command following
    // a transport state change.  Most of application will issue a transport state control
    // command follows by a query transport state status command.  The later command usually
    // failed.  A wait will allow some time for the transport mechanism to stablized and therefore
    // accepting command again.  This ought to be done in a registry set in an INF file.
    if(STATUS_SUCCESS == Status &&
          (KSPROPERTY_EXTXPORT_STATE == pSPD->Property->Id ||
             (VCR_RAW_AVC == pSPD->Property->Id && cType == AVC_CTYPE_CONTROL && 
                 (pXPrtProperty->u.RawAVC.Payload[2] == OPC_RECORD ||
                  pXPrtProperty->u.RawAVC.Payload[2] == OPC_PLAY ||
                  pXPrtProperty->u.RawAVC.Payload[2] == OPC_WIND
                 )           
             )
          )
      ) { 

#define MAX_XPRT_WAIT 5000
        if(pDevExt->XprtStateChangeWait > MAX_XPRT_WAIT)
            pDevExt->XprtStateChangeWait = MAX_XPRT_WAIT;

        if(pDevExt->XprtStateChangeWait > 0) {
            TRACE(TL_FCP_WARNING,("^^^^^^ Delay %d msec for Xprt state to stablized!^^^^^^\n", pDevExt->XprtStateChangeWait));
            DVDelayExecutionThread(pDevExt->XprtStateChangeWait);
        }
    }
#endif
#endif

    TRACE(TL_FCP_TRACE,("\'DVCRSetExtTransportProperty: idxDVCRCmd %d, Status %x\n", idxDVCRCmd, Status));
    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (PKSPROPERTY_EXTXPORT_S) : 0);

    return Status;
}

NTSTATUS 
DVGetTimecodeReaderProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_TIMECODE_S pTmCdReaderProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;


    PAGED_CODE();

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TIMECODE_S)); 

    pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pSPD->PropertyInfo;    // pointer to the data
    *pulActualBytesTransferred = 0;
  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_TIMECODE_READER:
        idxDVCRCmd = VCR_TIMECODE_READ;
#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
        // There can only be one active stream.
        if(pDevExt->cndStrmOpen == 1 &&            
           pDevExt->paStrmExt[pDevExt->idxStreamNumber]->StreamState == KSSTATE_RUN) {

            if(pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bTimecodeUpdated) {
                // Once it is read, it is stale.
                pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bTimecodeUpdated = FALSE;

                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames = 
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[0]) << 24) |
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[1]) << 16) |
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[2]) <<  8) |
                     ((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[3]);

                *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);
                return STATUS_SUCCESS;
            }
            else {
                TRACE(TL_FCP_TRACE,("\'bTimecode stale, issue AVC command to read it.\n"));
            }
        }
#endif
        break;

    case KSPROPERTY_ATN_READER:
        idxDVCRCmd = VCR_ATN_READ;
#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA

        // There can only be one active stream.
        if(pDevExt->cndStrmOpen == 1 && 
           pDevExt->paStrmExt[pDevExt->idxStreamNumber]->StreamState == KSSTATE_RUN) {

            if(pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bATNUpdated) {
                // Once it is read, it is stale.
                pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bATNUpdated = FALSE;

                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames = 
                    pDevExt->paStrmExt[pDevExt->idxStreamNumber]->AbsTrackNumber >> 1;
                pTmCdReaderProperty->TimecodeSamp.dwUser = 
                    pDevExt->paStrmExt[pDevExt->idxStreamNumber]->AbsTrackNumber & 0x00000001;

                *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);            
                return STATUS_SUCCESS;
            }
            else {
                TRACE(TL_FCP_WARNING,("\'bATN stale, issue AVC command to read it.\n"));
            }
        }
#endif
        break;

    case KSPROPERTY_RTC_READER:
        idxDVCRCmd = VCR_RTC_READ;
        break;

    default:
        TRACE(TL_FCP_ERROR,("DVCRGetTimecodeReaderProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED; 
    }

    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            idxDVCRCmd, 
            (PVOID) pTmCdReaderProperty
            );  

    TRACE(TL_FCP_TRACE,("\'DVCRGetTimecodeReaderProperty: idxDVCRCmd %d, Status %x\n", idxDVCRCmd, Status));     

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);
 
    return Status;
}

NTSTATUS 
DVMediaSeekingProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID * pTimeFormatGuid;
    KSMULTIPLE_ITEM * pMultipleItem;

    PAGED_CODE();


    *pulActualBytesTransferred = 0;
  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_MEDIASEEKING_FORMATS:
        // Its is KSMULTIPLE_ITEM so it is a two step process to return the data:
        // (1) return size in pActualBytesTransferred with STATUS_BUFFER_OVERFLOW
        // (2) 2nd time to get its actual data.
        if(pSPD->PropertyOutputSize == 0) {
            *pulActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            Status = STATUS_BUFFER_OVERFLOW;
        
        } else if(pSPD->PropertyOutputSize >= (sizeof(KSMULTIPLE_ITEM) + sizeof(GUID))) {
            pMultipleItem = (KSMULTIPLE_ITEM *) pSPD->PropertyInfo;    // pointer to the data
            pMultipleItem->Count = 1;
            pMultipleItem->Size  = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            pTimeFormatGuid = (GUID *) (pMultipleItem + 1);    // pointer to the data
            memcpy(pTimeFormatGuid, &KSTIME_FORMAT_MEDIA_TIME, sizeof(GUID));
            *pulActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            Status = STATUS_SUCCESS;         

        } else {
            TRACE(TL_FCP_ERROR,("DVCRMediaSeekingProperty: KSPROPERTY_MEDIASEEKING_FORMAT; STATUS_INVALID_PARAMETER\n"));
            Status = STATUS_INVALID_PARAMETER;
        }  
        break;

    default:
        TRACE(TL_FCP_ERROR,("\'DVCRMediaSeekingProperty:Not supported ID %d\n", pSPD->Property->Id));
        return STATUS_NOT_SUPPORTED;         
    }

    return Status;
}



NTSTATUS
DVGetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handles Get operations for all adapter properties.

Arguments:   

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;

    PAGED_CODE();


    if (IsEqualGUID (&PROPSETID_EXT_DEVICE, &pSPD->Property->Set)) {
        Status = 
            DVGetExtDeviceProperty(              
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_EXT_TRANSPORT, &pSPD->Property->Set)) {
        Status = 
            DVGetExtTransportProperty(
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_TIMECODE_READER, &pSPD->Property->Set)) {
        Status = 
            DVGetTimecodeReaderProperty(
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&KSPROPSETID_MediaSeeking, &pSPD->Property->Set)) {

        Status = 
            DVMediaSeekingProperty(                
                pDevExt,
                pSPD, 
                pulActualBytesTransferred
                ); 
        
    } else {
        //
        // We should never get here
        //
        Status = STATUS_NOT_SUPPORTED;
        TRACE(TL_FCP_ERROR,("get unknown property\n"));
        ASSERT(FALSE);
    }

    return Status;
}



NTSTATUS
DVSetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,  
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytetransferred
    )
/*++

Routine Description:

    Handles Set operations for all adapter properties.

Arguments:

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PAGED_CODE();


    if (IsEqualGUID (&PROPSETID_EXT_DEVICE, &pSPD->Property->Set)) {
        Status = 
            DVSetExtDeviceProperty(
                pDevExt,
                pSPD,
                pulActualBytetransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_EXT_TRANSPORT, &pSPD->Property->Set)) {
        Status = 
            DVSetExtTransportProperty(
                pDevExt,
                pSPD,
                pulActualBytetransferred
                );
    } 
    else {
        Status = STATUS_NOT_SUPPORTED;

        //
        // We should never get here
        //
        TRACE(TL_FCP_ERROR,("set unknown property\n"));
        ASSERT(FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvdef.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000 

Module Name:

    msdvdef.h

Abstract:

    Header file for all of msdv (digital camcorder)

Last changed by:
    
    $Author::                $

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#ifndef _DVCRDEF_INC
#define _DVCRDEF_INC

//
// Allocate memory with 'Msdv' tag
//

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#undef ExAllocatePool
#define ExAllocatePool(type, size) ExAllocatePoolWithTag (type, size, 'vdsM')


//
// Need to reference this in PSTRMEX
//
typedef struct _DVCR_EXTENSION;



// 
// The index MUST match 
//
typedef enum {

    FMT_IDX_SD_DVCR_NTSC = 0,
    FMT_IDX_SD_DVCR_PAL,

#ifdef MSDV_SUPPORT_HD_DVCR
    FMT_IDX_HD_DVCR_NTSC,
    FMT_IDX_HD_DVCR_PAL,
#endif

#ifdef MSDV_SUPPORT_SDL_DVCR
    FMT_IDX_SDL_DVCR_NTSC,
    FMT_IDX_SDL_DVCR_PAL,
#endif

} FMT_INDEX, *PFMT_INDEX;


//
// Trasnmit thread valid states
//

typedef enum  {
    THD_RUNNING     = 0x01,  
    THD_HALT        = 0x02,  
    THD_TERMINATE   = 0x04,     
} XMT_THREAD_STATE, * PXMT_THREAD_STATE;


#if DBG
//
// Collect statistic for real time data transmission 
//
#define MAX_STAT_DURATION        60  // Seconds
#define MAX_XMT_FRAMES_TRACED    30 * MAX_STAT_DURATION  // Max number of entries

typedef struct _XMT_FRAME_STAT {
    KSSTATE StreamState;

    LONG cntSRBReceived;             // Accumulative SRVB received.
    LONG cntSRBPending;              // Number of SRB not yet completed.
    LONG cntSRBQueued;               // SRB Queued
    LONG cntDataAttached;            // Data attached

    LONGLONG FrameSlot;              // Real time
    ULONGLONG tmStreamTime;          // Stream time of the "FrameSlot"

    DWORD DropCount;                 // Accumulative drop count

    DWORD FrameNumber;               // Actual frame number transmitted; (==FrameSlot: ontime); (<FrameSlot: late)
    DWORD OptionsFlags;
    ULONGLONG tmPresentation;        // Actual frame's presentation time
    CYCLE_TIME tsTransmitted;        // Frame actually transmitted (1394 CycleTime)

} XMT_FRAME_STAT, *PXMT_FRAME_STAT;

#endif

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//
 
typedef struct _STREAMEX {

    //
    // Point to pSrb->HwDeviceExtension
    // 
    struct _DVCR_EXTENSION * pDevExt;

    //
    // Cache pSrb->StreamObject:
    //     ->HwStreamExtension  (pStrmExt)
    //     ->StreamNumber
    //     ->HwDeviceExtension  (pDevExt)
    //
    PHW_STREAM_OBJECT  pStrmObject;      

    //
    //  ->NumberOfPossibleInstances;
    //  ->DataFlow;
    //
    PHW_STREAM_INFORMATION pStrmInfo;
    
    //
    // Holds current stream state
    //
    KSSTATE StreamState;

    //
    // Holds previous stream state; use to determine the state transition.
    //
    KSSTATE StreamStatePrevious;

    //
    // Holds whether or not the dvcr is listening or receiving
    //
    // TRUE:  successful REQUEST_ISOCH_LISTEN and REQUEST_ISOCH_TALK
    // FALSE: successful INIT and REQUEST_ISOCH_STOP
    //
    BOOLEAN bIsochIsActive;  // Close associated with StreamState

    //
    // Set to TRUE when receiving KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM for SRB_WRITE_DATA
    // For SRB_WRITE_DATA only since then this driver servers as a renderer.
    //
    BOOL      bEOStream;  

    //
    // Count number of SRB_READ/WRITE_DATA received since last transiting to PAUSE state from STOP
    //
    LONGLONG  cntSRBReceived;

    //
    // Statistic of the frame information since last start stream
    // PictureNumber = FramesProcessed + FramesDropped + cndSRBCancelled.
    //    
    LONGLONG  FramesProcessed;   // Frame sent (including repeated)
    LONGLONG  FramesDropped;     // SRB not sent
    LONGLONG  PictureNumber;     // Number of SRB_XXX_DATA made it to or from 1394 bus

    //
    // Count number of SRB_READ/WRITE_DATA that was incompleted and cancelled
    //
    LONGLONG  cntSRBCancelled;

    //
    // Count and list for the detach list
    //
    LONG       cntDataDetached;
    LIST_ENTRY DataDetachedListHead;


#if DBG
    //
    // Count number of SRB awaiting completion
    //
    LONG       cntSRBPending;       
#endif

    //
    // Count and list for the SRB list
    //
    LONG       cntSRBQueued;        // Used only with SRB_WRITE_DATA
    LIST_ENTRY SRBQueuedListHead;   // Used only with SRB_WRITE_DATA


    //
    // Count and list for the attach list
    //
    LONG       cntDataAttached;
    LIST_ENTRY DataAttachedListHead;


    //
    // Lock to serialize attach and detach of list
    //
    KSPIN_LOCK * DataListLock;

#if DBG
    KSPIN_LOCK * DataListLockSave;
#endif


    //
    // The stream time (master clock or not) is "almost" or near 0 
    // when setting to RUN state and start increment.
    //
    ULONGLONG CurrentStreamTime;


    //
    // Keep track of the last system time when the stream time was updated.
    // This is used to calibrate the current stream time when it is queries.
    //
    ULONGLONG LastSystemTime;

    //
    // Holds the master clock
    //
    HANDLE hMyClock;       // If set, we can be a clock provider.
    HANDLE hMasterClock;   // If set, we are the master clock.
    HANDLE hClock;         // If set, other device on the same graph is the master clock.


    //
    // Since GetSystemTime() can be called at DISPATCH level so make sure the variable that it used is in nonpaged pool
    //
    HW_TIME_CONTEXT  TimeContext;


    //
    // 2nd CIP Quadlet: 01:Fmt, 50/60:STYPE:RSv, SYT
    //
    BYTE cipQuad2[4];

#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
    //
    // Timecode, RecDate and RecTime are all in pack format (4 bytes)
    //
    BOOL bATNUpdated;
    DWORD AbsTrackNumber; // LSB:BlankField   

    BOOL bTimecodeUpdated;
    BYTE Timecode[4];     // hh:mm:ss,ff
#endif

    //
    // This mutex is used to synchronize 
    //     1. Transitioning to STOP state
    //     2. Receiving and attaching a media sample 
    //     3. Canceling a media sample
    //
    KMUTEX * hStreamMutex;

    //
    // Counter used to indicate starting of an work item to cancel; this is a token and it is either 0 or 1.
    //
    LONG lStartIsochToken;


    //***********************
    // Apply to transmit only
    //***********************

    //
    // Data ready dispatch thread's object: used to wait for thread to terminate.
    //
    PVOID  pAttachFrameThreadObject; 

    //
    // Current tansmit thread state
    //
    XMT_THREAD_STATE XmtState;

    //
    // This mutex is used to synchronize attaching transmit buffer among
    //     1. Attach frame thread (System thread - PSCreateSystemThread())     
    //     2. Other services (that request attach frame thread to halt)
    //         2a. Cancel attached buffer and then SRBs (Workitem, system thread)
    //         2b. Power state change (PnP irp, system thread)
    //         2c. Surprise removal (PnP irp, system thread)
    //
    KMUTEX * XmtThreadMutex;

    //
    // Set (TRUE) this flag only once per transition from STOP state.  
    // It is reset (FALSE) after OpenStream or into STOP state.
    //
    BOOL bXmtThreadStarted;

    //
    // Set when the system is to be terminated.
    // 
    BOOL   bTerminateThread;

    //
    // Used to signal the termination of a system thread so we can dereference its thread object. 
    //
    KEVENT  hThreadEndEvent;     

    //
    // Signal to run the attach frame thread; when non-signal, thread is in the halt state.
    //
    KEVENT  hRunThreadEvent;    // Signal when thread is running

    //
    // Signal arrival of a SRB so it can be processed in the case we are repeating frame.
    //
    KEVENT hSrbArriveEvent;

#ifdef SUPPORT_PREROLL_AT_RUN_STATE
    //
    // Support wait in get RUN state to "simulate" preroll behaviour
    //
    KEVENT hPreRollEvent;

    //
    // Set when preroll WFSO for the above event is completed (signal or timeout).
    // It is reset (FALSE) initially or transitioning into STOP state.
    //
    BOOL bPrerollCompleted;  

#endif

#ifdef SUPPORT_NEW_AVC
    //
    // Used to indicate a device to device connection
    //
    BOOL  bDV2DVConnect; 
#endif

    //
    // The input and output plug of this stream (point-to-point connection).
    //
    HANDLE  hOutputPcr;   // DV or PC's oPCR[0]
    HANDLE  hInputPcr;    // DV or PC's iPCR[0]

    //
    // The connection handle from 61883.sys.
    //
    HANDLE  hConnect;     // Connect handle

#ifdef NT51_61883 // This is needed starting with 61883.sys in Whistler
    //
    // Cyclic cycle count of last DV frame
    //
    ULONG  CycleCount16bits;
#endif  // NT51_61883


#if DBG
    LONG lPrevCycleCount;
    LONG lTotalCycleCount;
    ULONG lFramesAccumulatedRun;
    ULONG lFramesAccumulatedPaused;
    LONG lDiscontinuityCount;
#endif

    //
    // Discontinuity is introduced when traistioning from RUN->PAUSE->RUN.
    // The stream time will not increment in PAUSE state but system time (1394 CycleTime) does.
    //
    BOOL  b1stNewFrameFromPauseState;

    //
    // Use to mark the tick count when the stream start running.
    // It is later used to calculate current stream time and dropped frames.
    //
    ULONGLONG  tmStreamStart;
#if DBG
    ULONGLONG tmStreamPause;  // When it is set to PAUSE state
#endif

    //
    // Counter used to indicate starting of an work item to cancel; this is a token and it is either 0 or 1.
    //
    LONG lCancelStateWorkItem;

    //
    // Use to indicate aborting a stream.
    //
    BOOL bAbortPending;

    //
    // Hold the work item
    //
#ifdef USE_WDM110  // Win2000 code base
    PIO_WORKITEM       pIoWorkItem;
#else
    WORK_QUEUE_ITEM    IoWorkItem;
#endif

    //
    // TO singal that an work item is completed.
    //
    KEVENT hCancelDoneEvent;

    //
    // A timer and Dpc objects to periodically check for expired clock events.
    //
    KDPC  * DPCTimer;
    KTIMER  * Timer;
    BOOL  bTimerEnabled;


#if DBG
    //
    // Used to keep track of transmission statistics
    //
    PXMT_FRAME_STAT paXmtStat;
    ULONG ulStatEntries;
#endif

#ifdef SUPPORT_QUALITY_CONTROL
    //
    // Use for keeping track of quality control
    //
    KSQUALITY KSQuality;
#endif

} STREAMEX, *PSTREAMEX;



    
//
// Device Extension for our  Desktop Camera Driver
//
typedef struct _DVCR_EXTENSION {  

    LONG cndStrmOpen;
    ULONG idxStreamNumber;  // Index of current stream
    //
    // Can have only 1 Stream active at any time.
    // (Stream Class will allocate the stream extension at SRB_OPENSTREAM)    
    //
    PSTREAMEX    paStrmExt[3]; // We support three pins

    //
    // Holds the video format index; it's either PAL or NTSC.  Default is NTSC.
    //
    FMT_INDEX VideoFormatIndex;

    // 
    // Current Device Power State
    //
    DEVICE_POWER_STATE PowerState;

    //
    // Contain a table for the support formats
    //
    ULONG                 ulNumOfStreamSupported;
    HW_STREAM_INFORMATION * paCurrentStrmInfo;

    // 
    // TRUE only after SRB_SURPRISE_REMOVAL; 
    //
    BOOL bDevRemoved;  

    //
    // The list of AVC commands that have been issued
    //
    LIST_ENTRY AVCCmdList;

    // Number of completed commands waiting to be removed from the list
    // This includes:
    //     Command response has returned and processed in the completion routine
    //     Interim response awaiting final response
    LONG  cntCommandQueued;

    //
    // Protection for command processing
    //
    KSPIN_LOCK AVCCmdLock;

    //
    // The counted list of possible opcode values on response from Transport State status or notify
    //
    UCHAR TransportModes[5];    // 0x4, [0xC1, 0xC2, 0xC3, 0xC4]

    //
    // The device type (and its capabilities) cannot be determined until a tape is in    
    //
    ULONG      ulDevType;    // 0: undetermined, ED_DEVTYPE_CAMERA or ED_DEVTYPE_VCR
    BOOL       bHasTape;
    BOOL       bWriteProtected;
    BOOL       bDVCPro;


    //
    // Save Unit capabilities:
    //    Speed 
    //    Vendor and Model IDs
    //
    ULONG      NumOutputPlugs;
    ULONG      NumInputPlugs;
    ULONG      HardwareFlags;  // detect PAE: AV_HOST_DMA_DOUBLE_BUFFERING_ENABLED 

    ULONG      MaxDataRate;
    ULONG      ulVendorID;
    ULONG      ulModelID;

    LARGE_INTEGER  UniqueID;

    //
    // The DV's plug handles/PCRs (assume [0])
    //
    HANDLE hOPcrDV;
    HANDLE hIPcrDV;

#ifdef NT51_61883
    //
    // PC local oPCR
    //
    HANDLE  hOPcrPC;    // PC's local oPCR
#if 0                   // Not used since DV does not intiate DV to PC connection.
    HANDLE  hIPcrPC;    // PC's local iPCR
#endif

    //
    // Isochronous parameters obtained from 61883;
    // They are used for making isoch connection.
    //
    UNIT_ISOCH_PARAMS  UnitIoschParams;
#endif

    //
    // Holds the Device Object of our parent (1394 bus driver)
    //
    PDEVICE_OBJECT pBusDeviceObject;  // IoCallDriver()

    //
    // Holds my Physical Device Object
    // pass it in PnP API, such as IoOpenDeviceRegistryKey()
    //
    PDEVICE_OBJECT pPhysicalDeviceObject;

    //
    // Serialize in the event of getting two consecutive SRB_OPEN_STREAMs
    //
    KMUTEX hMutex;


#ifdef READ_CUTOMIZE_REG_VALUES
#if 0  // Not used in millennium; needed to do frame accurated recording.
    //
    // Registry values used to achieve frame accurate recording
    //
    BOOL  bATNSearch;        // Support ATN search (or Timecode search)
    BOOL  bSyncRecording;    // Synchronize stream state with record/pause transport state
    DWORD tmMaxDataSync;     // Time it take to sync to DV camcorder
    DWORD fmPlayPs2RecPs;    // Switch from PLAY_PAUSE to RECORD_PAUSE (unit=frames)
    DWORD fmStop2RecPs;      // Switch from STOP to RECORD_PAUSE (unit=frames)
    DWORD tmRecPs2Rec;       // Time to switch from RECORD_PAUSE to RECORD
#endif
    ULONG  XprtStateChangeWait;
#endif


    //
    // Since the signal format can dynamically changing, we will query 
    // the device for the currect format whevever we are asked for doing 
    // data intersection (note doing it in open is not enough!).
    // Instead of doing it always (since there could be a lot of data
    // intersection), we only query current format in a regular interval.
    //
    ULONGLONG tmLastFormatUpdate;

    //
    // Flow control for AVC command
    //
    KMUTEX  hMutexIssueAVCCmd;

#ifdef SUPPORT_OPTIMIZE_AVCCMD_RETRIES
    //
    // AVC Command retry count (default is 9 (avc.sys))
    //
    ULONG AVCCmdRetries;  // This is retry count not the total count

    //
    // Collect statistis of AVC command response time during driver load time.
    //
    BOOL  DrvLoadCompleted;   // Collect statistic until loading of driver is completed.  
    DWORD AVCCmdRespTimeMax;  // msec unit
    DWORD AVCCmdRespTimeMin;  // msec unit
    DWORD AVCCmdRespTimeSum;  // msec unit
    DWORD AVCCmdCount;  
#endif

} DVCR_EXTENSION, *PDVCR_EXTENSION;



//
// Used to queue a SRB
//

typedef struct _SRB_ENTRY {
    LIST_ENTRY                ListEntry;
    PHW_STREAM_REQUEST_BLOCK  pSrb; 
    BOOL                      bStale;  // TRUE if it is marked stale but is the only Srb in the SrbQ
    // Audio Mute indication; a frame could be repeatedly transmitted and its mute flag should be set only once.
    //
    BOOL                      bAudioMute;
#if DBG
    ULONG SrbNum;
#endif
} SRB_ENTRY, *PSRB_ENTRY;



//
// Valid data entry states for a data request and they
// can be Or'ed to show their data path.
//
// Examples of different possible code path: 
//
//    (A) Prepared->Attached->Callback->Completed_SRB 
//    (B) Prepared->Callback->Attached->Completed_SRB
//    (C) Prepared->Attached->Cancelled->Completed_SRB
//

enum DATA_ENTRY_STATE {
    DE_PREPARED               = 0x01,
    DE_IRP_ATTACHED_COMPLETED = 0x02,
    DE_IRP_CALLBACK_COMPLETED = 0x04,  
    DE_IRP_SRB_COMPLETED      = 0x08,
    DE_IRP_ERROR              = 0x10,    
    DE_IRP_CANCELLED          = 0x20,    
};

#define IsStateSet(state, bitmask) ((state & (bitmask)) == bitmask)



//
// This is the context used to attach a frame 
//

typedef struct _SRB_DATA_PACKET {
    // Build list
    LIST_ENTRY                  ListEntry;

    // 
    // Keep track of data entry state
    //
    enum DATA_ENTRY_STATE       State;

    PHW_STREAM_REQUEST_BLOCK    pSrb;  
    KSSTATE                     StreamState;  // StreamState when it was attached
    PSTREAMEX                   pStrmExt;  // Can get this from pSrb, here for convenience only!


    // Used to send 61883 request
    PIRP                        pIrp;     // Use to attach and release.

    PCIP_FRAME                  Frame;
    PVOID                       FrameBuffer;

    //
    // Add debug related info here
    //
    LONGLONG                    FrameNumber;

    // Use to send 61883 AV data request
    AV_61883_REQUEST            AVReq;

} SRB_DATA_PACKET, *PSRB_DATA_PACKET;





#define MASK_AUX_50_60_BIT  0x00200000  // bit 5 of PC3 of both AAuxSrc and VAAuxSrc is the NTSC/PAL bit


//
// Wait time constants
//
#define DV_AVC_CMD_DELAY_STARTUP                       500   // MSec
#define DV_AVC_CMD_DELAY_INTER_CMD                      20   // MSec
#define DV_AVC_CMD_DELAY_DVCPRO                        500   // MSec

#define FORMAT_UPDATE_INTERVAL                   100000000   // 10 seconds

//
// Default AVC Command settings
//
#define MAX_RESPONSE_TIME_FOR_ALERT                    100   // msec

//
// The timeout value is set to give device sufficient time to response
// to an AVC command following a transport state change.  It is based
// on trials of many camcorder (Sharp, Sony, Panasonic, Samsung..etc.)
// to come to this value.  The biggest delay (timeout) is from issuing
// of PLAY command follow by REWIND command.  Some test value:
// 
//     Hitachi
//     JVC DVL9600:      Stop->PLAY: delay is less than 300msec (Known issue: no image if play graph before play tape!)
//     Panasonic MX2000: Stop->PLAY:2339; ->Rewind:3767 msec
//     Samsung VP-D55:   Does not support XPrt State status command and will always
//                       timeout its suqsequent command following XPrtState change
//     Sharp VL-WDW450U: Stop->PLAY:3514; ->Rewind:6120 msec  
//           VL-PD3F:    Stop->PLAY:3293; ->Rewind:6404 msec
//     Sony DCR-TRV10:   Stop->PLAY:3617; ->Rewind:5323 msec 
//          DA1:         Non-compliant (Retry is 0!)
//          DA2:         No transport state change.        
//

#define MAX_AVC_CMD_RETRIES      ((DEFAULT_AVC_RETRIES + 1) * 7 - 1)  // Retries counts 

 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvavc.h ===
/*++

Module Name:

    MsdvAvc.h

Abstract:

    Header file for MsdvAvc.c.

Author:   

    Yee J. Wu 27-July-99

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef _MSDVAVC_INC
#define _MSDVAVC_INC

#include "XPrtDefs.h"  // WdmCap directory; derived from DShow's edevdefs.h
#include "EDevCtrl.h"  // External Device COM interface structures




// 
// The index MUST match DVcrAVCCmdTable[]
//
typedef enum {

    DV_UNIT_INFO = 0
    ,DV_SUBUNIT_INFO
    ,DV_CONNECT_AV_MODE

	,DV_VEN_DEP_CANON_MODE    // Vendor denpendent mode of operation for Canon DV that does not support ConnectDV
    ,DV_VEN_DEP_DVCPRO        // Vendor depend cmd to detect DVC PRO tape format

    ,DV_IN_PLUG_SIGNAL_FMT
    ,DV_OUT_PLUG_SIGNAL_FMT   // to determine if it is a PAL or NTSC

    ,VCR_TIMECODE_SEARCH 
    ,VCR_TIMECODE_READ

    ,VCR_ATN_SEARCH 
    ,VCR_ATN_READ

    ,VCR_RTC_SEARCH 
    ,VCR_RTC_READ

    ,VCR_OPEN_MIC_CLOSE
    ,VCR_OPEN_MIC_READ
    ,VCR_OPEN_MIC_WRITE
    ,VCR_OPEN_MIC_STATUS

    ,VCR_READ_MIC

    ,VCR_WRITE_MIC

    ,VCR_OUTPUT_SIGNAL_MODE
    ,VCR_INPUT_SIGNAL_MODE

    ,VCR_LOAD_MEDIUM_EJECT

    ,VCR_RECORD
    ,VCR_RECORD_PAUSE

    ,VCR_PLAY_FORWARD_STEP
    ,VCR_PLAY_FORWARD_SLOWEST
    ,VCR_PLAY_FORWARD_SLOWEST2
    ,VCR_PLAY_FORWARD_FASTEST

    ,VCR_PLAY_REVERSE_STEP
    ,VCR_PLAY_REVERSE_SLOWEST
    ,VCR_PLAY_REVERSE_SLOWEST2
    ,VCR_PLAY_REVERSE_FASTEST

    ,VCR_PLAY_FORWARD
    ,VCR_PLAY_FORWARD_PAUSE

    ,VCR_WIND_STOP
    ,VCR_WIND_REWIND
    ,VCR_WIND_FAST_FORWARD

    ,VCR_TRANSPORT_STATE
    ,VCR_TRANSPORT_STATE_NOTIFY

    ,VCR_MEDIUM_INFO

    ,VCR_RAW_AVC
    
} DVCR_AVC_COMMAND, *PDVCR_AVC_COMMAND;



#define MAX_FCP_PAYLOAD_SIZE 512

//
// CTYPE definitions (in bit-map form... should correlate with AvcCommandType from avc.h)
//
typedef enum {
    CMD_CONTROL  = 0x01
   ,CMD_STATUS   = 0x02
   ,CMD_SPEC_INQ = 0x04
   ,CMD_NOTIFY   = 0x08
   ,CMD_GEN_INQ  = 0x10
} BITMAP_CTYPE;

typedef enum {
    CMD_STATE_UNDEFINED   
   ,CMD_STATE_ISSUED 
   ,CMD_STATE_RESP_ACCEPTED
   ,CMD_STATE_RESP_REJECTED
   ,CMD_STATE_RESP_NOT_IMPL           
   ,CMD_STATE_RESP_INTERIM
   ,CMD_STATE_ABORTED
} AVC_CMD_STATE, *PAVC_CMD_STATE;


// An AVC command entry 
typedef struct _AVC_CMD_ENTRY {
    LIST_ENTRY      ListEntry;
    PDVCR_EXTENSION pDevExt;        
    PIRP            pIrp;           // The Irp associated with this command
    PAVC_COMMAND_IRB pAvcIrb;       // points to the AVC command information
	PVOID           pProperty;      // Data from/to COM interface
    DVCR_AVC_COMMAND idxDVCRCmd;    // Used to check for RAW AVC command, which requires special processing
    AVC_CMD_STATE   cmdState;       // Issuing, interim, completed
    NTSTATUS        Status;         // To save the results of response parsing
    AvcCommandType  cmdType;        // Type of command: Control, Status. Notify, Gen or Spec Inquery
    BYTE            OpCode;         // Since the opcode in response frame of TRANSITION and STABLE can be different from the COMMAND frame
    BYTE            Reserved[3];    // Pack to DWORD
} AVCCmdEntry, *PAVCCmdEntry;



#define CMD_IMPLEMENTED       1
#define CMD_NOT_IMPLEMENTED   0
#define CMD_UNDETERMINED      0xffffffff   // -1


typedef struct {    
    DVCR_AVC_COMMAND command; // VCR_PLAY_FORWARD
    LONG   lCmdImplemented;   // 1:Implemented, 0:NotImpelemnted; -1:UnDetermined

    ULONG  ulRespFlags;       // DVCR_AVC_SEND

    ULONG  ulCmdSupported;    // one or more of constants defined in BITMAP_CTYPE

    LONG   OperandLength;      // -1 = variable length

    BYTE   CType;
    BYTE   SubunitAddr;
    BYTE   Opcode;

    BYTE   Operands[MAX_AVC_OPERAND_BYTES];

} KSFCP_PACKET, *PKSFCP_PACKET;



#define OPC_TIMECODE          0x51
#define OPC_OPEN_MIC          0x60
#define OPC_READ_MIC          0x61
#define OPC_WRITE_MIC         0x62
#define OPC_INPUT_SIGNAL_MODE 0x79
#define OPC_LOAD_MEDIUM       0xc1
#define OPC_RECORD            0xc2
#define OPC_PLAY              0xc3
#define OPC_WIND              0xc4
#define OPC_TRANSPORT_STATE   0xd0
#define OPC_MEDIUM_INFO       0xda




#define UNIT_TYPE_ID_VCR      0x20  // VCR    00100:000; 00100 == 4 == VCR,    000 == instancve number
#define UNIT_TYPE_ID_CAMERA   0x38  // Camera 00111:000; 00111 == 7 == Camera, 000 == instancve number
#define UNIT_TYPE_ID_DV       0xff  // DV UNIT as a whole


// Vendor IDs that require special treatments
#define VENDOR_ID_MASK        0x00ffffff
#define VENDORID_CANON        0x85   //  VEN_85   : Vendor Dependent command for ModeOfOperation
#define VENDORID_PANASONIC    0x8045 //  VEN_8045 : DVCPRO?
#define VENDORID_SAMSUNG      0xf0   //  VEN_f0   : exception for AVC Command Retries




#endif


NTSTATUS  
DVIssueAVCCommand (
    IN PDVCR_EXTENSION pDevExt, 
    IN AvcCommandType cType,
    IN DVCR_AVC_COMMAND idxAVCCmd,
    IN PVOID pProperty
    );


void
DVAVCCmdResetAfterBusReset(
    PDVCR_EXTENSION pDevExt
    );


NTSTATUS
DVGetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPDesc,
    OUT PULONG pulActualBytetransferred
    );


NTSTATUS
DVSetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,  
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytetransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvguts.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MsdvGuts.h

Abstract:

    Header file MsdvGuts.c

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/


//
// Device SRB
//

NTSTATUS
DVInitializeDevice(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    IN PAV_61883_REQUEST pAVReq
    );

NTSTATUS
DVInitializeCompleted(
    IN PDVCR_EXTENSION  pDevExt
    );

NTSTATUS
DVGetStreamInfo(
    IN PDVCR_EXTENSION        pDevExt,
    IN ULONG                  ulBytesToTransfer, 
    IN PHW_STREAM_HEADER      pStreamHeader,       
    IN PHW_STREAM_INFORMATION pStreamInfo
    );

BOOL 
DVVerifyDataFormat(
    PKSDATAFORMAT  pKSDataFormatToVerify, 
    ULONG          StreamNumber,
    ULONG          ulSupportedFrameSize,
    HW_STREAM_INFORMATION * paCurrentStrmInfo	
    );

NTSTATUS
DVGetDataIntersection(
    IN  ULONG          ulStreamNumber,
    IN  PKSDATARANGE   pDataRange,
    OUT PVOID          pDataFormatBuffer,
    IN  ULONG          ulSizeOfDataFormatBuffer,
    IN  ULONG          ulSupportedFrameSize,
    OUT ULONG          *pulActualBytesTransferred,
    HW_STREAM_INFORMATION * paCurrentStrmInfo
#ifdef SUPPORT_NEW_AVC            
    ,IN HANDLE hPlug
#endif
    );

NTSTATUS
DVOpenStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    );

NTSTATUS
DVCloseStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    );

NTSTATUS
DVChangePower(
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST pAVReq,
    DEVICE_POWER_STATE NewPowerState
    );

NTSTATUS
DVSurpriseRemoval(
    PDVCR_EXTENSION pDevExt,
    PAV_61883_REQUEST  pAVReq
    );

NTSTATUS
DVProcessPnPBusReset(
    PDVCR_EXTENSION pDevExt
    );

NTSTATUS
DVUninitializeDevice(
    IN PDVCR_EXTENSION  pDevExt
    );

//
// Stream SRB
//

NTSTATUS
DVGetStreamState(
    PSTREAMEX  pStrmExt,
    PKSSTATE   pStreamState,
    PULONG     pulActualBytesTransferred
    );

NTSTATUS
DVStreamingStop( 
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq
    );

NTSTATUS
DVStreamingStart( 
    KSPIN_DATAFLOW   ulDataFlow,
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt
    );

NTSTATUS
DVSetStreamState(
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq,
    KSSTATE          StreamState
    );

NTSTATUS 
DVGetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DVSetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOL
DVAbortStream(
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX pStrmExt
    );

NTSTATUS
DVStopCancelDisconnect(
    PSTREAMEX  pStrmExt
);

VOID
DVCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    );

VOID
DVCancelAllPackets(
    IN PSTREAMEX        pStrmExt,
    IN PDVCR_EXTENSION  pDevExt
    );

VOID
DVTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS 
DVOpenCloseMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    );

NTSTATUS 
DVIndicateMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    );

VOID
DVRcvDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
DVRcvControlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID 
StreamClockRtn(
    IN PHW_TIME_CONTEXT TimeContext
    );

VOID
DVSignalClockEvent(
    IN PKDPC Dpc,
    IN PSTREAMEX  pStrmExt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2    
    );

NTSTATUS 
DVEventHandler(
    IN PHW_EVENT_DESCRIPTOR pEventDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvguts.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSDVGuts.c

Abstract:

    Main service functions.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"

#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "ksguid.h"

#include "msdvfmt.h"  // Before msdvdefs.h
#include "msdvdef.h"

#include "MSDVGuts.h"
#include "MsdvUtil.h"
#include "MsdvAvc.h"

#include "XPrtDefs.h"
#include "EDevCtrl.h"

//
// Define formats supported
//
#include "avcstrm.h"
#include "strmdata.h"

#if DBG
extern ULONG DVDebugXmt;        // this is defined in msdvuppr.c
#endif

NTSTATUS
DVGetDevInfo(
    IN PDVCR_EXTENSION  pDevExt,
    IN PAV_61883_REQUEST  pAVReq
    );
VOID 
DVIniStrmExt(
    PHW_STREAM_OBJECT  pStrmObject,
    PSTREAMEX          pStrmExt,
    PDVCR_EXTENSION    pDevExt,
    const PALL_STREAM_INFO   pStream
    );
NTSTATUS 
DVStreamGetConnectionProperty (
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX          pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    );
NTSTATUS
DVGetDroppedFramesProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    );

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVGetDevInfo)
     #pragma alloc_text(PAGE, DVInitializeDevice)
     #pragma alloc_text(PAGE, DVGetStreamInfo)
     #pragma alloc_text(PAGE, DVVerifyDataFormat)
     #pragma alloc_text(PAGE, DVGetDataIntersection)
     #pragma alloc_text(PAGE, DVIniStrmExt)
     #pragma alloc_text(PAGE, DVOpenStream)
     #pragma alloc_text(PAGE, DVCloseStream)
     #pragma alloc_text(PAGE, DVChangePower)
     #pragma alloc_text(PAGE, DVSurpriseRemoval)
     #pragma alloc_text(PAGE, DVProcessPnPBusReset)
     #pragma alloc_text(PAGE, DVUninitializeDevice)
     #pragma alloc_text(PAGE, DVGetStreamState)
     #pragma alloc_text(PAGE, DVStreamingStop)
     #pragma alloc_text(PAGE, DVStreamingStart)
     #pragma alloc_text(PAGE, DVSetStreamState)
     #pragma alloc_text(PAGE, DVStreamGetConnectionProperty)
     #pragma alloc_text(PAGE, DVGetDroppedFramesProperty)
     #pragma alloc_text(PAGE, DVGetStreamProperty)
     #pragma alloc_text(PAGE, DVSetStreamProperty)
     #pragma alloc_text(PAGE, DVCancelAllPackets)
     #pragma alloc_text(PAGE, DVOpenCloseMasterClock)
     #pragma alloc_text(PAGE, DVIndicateMasterClock)
#endif
#endif

DV_FORMAT_INFO DVFormatInfoTable[] = {

//
// SD DVCR
//
    { 
        {
            FMT_DVCR,
            FDF0_50_60_NTSC,
            0,
            0
        },
        DIF_SEQS_PER_NTSC_FRAME,
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,
        FRAME_SIZE_SD_DVCR_NTSC,
        FRAME_TIME_NTSC,
        SRC_PACKETS_PER_NTSC_FRAME,
        MAX_SRC_PACKETS_PER_NTSC_FRAME,
        CIP_DBS_SD_DVCR,
        CIP_FN_SD_DVCR,
        0,
        FALSE,                    // Source packet header
    },
    {
        {
            FMT_DVCR,
            FDF0_50_60_PAL,
            0,
            0
        },
        DIF_SEQS_PER_PAL_FRAME,
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,
        FRAME_SIZE_SD_DVCR_PAL,
        FRAME_TIME_PAL,
        SRC_PACKETS_PER_PAL_FRAME,
        MAX_SRC_PACKETS_PER_PAL_FRAME,
        CIP_DBS_SD_DVCR,
        CIP_FN_SD_DVCR,
        0,
        FALSE,                   // Source packet header
    },

#ifdef SUPPORT_HD_DVCR

//
// HD DVCR
//
    { 
        {
            FMT_DVCR,
            FDF0_50_60_NTSC,
            0,
            0
        },
        DIF_SEQS_PER_NTSC_FRAME_HD, 
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,            
        FRAME_SIZE_HD_DVCR_NTSC,
        FRAME_TIME_NTSC,
        SRC_PACKETS_PER_NTSC_FRAME,
        MAX_SRC_PACKETS_PER_NTSC_FRAME,
        CIP_DBS_HD_DVCR,
        CIP_FN_HD_DVCR,
        0,
        FALSE,    // Source packet header
    },
    {
        {
            FMT_DVCR,
            FDF0_50_60_PAL,
            0,
            0
        },
        DIF_SEQS_PER_PAL_FRAME_HD,
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,
        FRAME_SIZE_HD_DVCR_PAL,
        FRAME_TIME_PAL,
        SRC_PACKETS_PER_PAL_FRAME,
        MAX_SRC_PACKETS_PER_PAL_FRAME,
        CIP_DBS_HD_DVCR,
        CIP_FN_HD_DVCR,
        0,
        FALSE,    // Source packet header
    },
#endif

#ifdef MSDV_SUPPORT_SDL_DVCR
//
// SDL DVCR
//
    { 
        {
            FMT_DVCR,
            FDF0_50_60_NTSC,
            0,
            0
        },
        DIF_SEQS_PER_NTSC_FRAME_SDL,  
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,            
        FRAME_SIZE_SDL_DVCR_NTSC,
        FRAME_TIME_NTSC,
        SRC_PACKETS_PER_NTSC_FRAME,
        MAX_SRC_PACKETS_PER_NTSC_FRAME,
        CIP_DBS_SDL_DVCR,
        CIP_FN_SDL_DVCR,
        0,
        FALSE,    // Source packet header
    },
    {
        {
            FMT_DVCR,
            FDF0_50_60_PAL,
            0,
            0
        },
        DIF_SEQS_PER_PAL_FRAME_SDL,
        DV_NUM_OF_RCV_BUFFERS,
        DV_NUM_OF_XMT_BUFFERS,
        FRAME_SIZE_SDL_DVCR_PAL,
        FRAME_TIME_PAL,
        SRC_PACKETS_PER_PAL_FRAME,
        MAX_SRC_PACKETS_PER_PAL_FRAME,
        CIP_DBS_SDL_DVCR,
        CIP_FN_SDL_DVCR,
        0,
        FALSE,    // Source packet header
    },

#endif  // Not implemented.
};


#define MSDV_FORMATS_SUPPORTED        (SIZEOF_ARRAY(DVFormatInfoTable))



VOID
DVIniDevExtStruct(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo    
    )
/*++

Routine Description:

    Initialiaze the device extension structure.

--*/
{
    ULONG            i;


    RtlZeroMemory( pDevExt, sizeof(DVCR_EXTENSION) );

    //
    // Cache what are in ConfigInfo in device extension
    //
    pDevExt->pBusDeviceObject      = pConfigInfo->PhysicalDeviceObject;      // IoCallDriver()
    pDevExt->pPhysicalDeviceObject = pConfigInfo->RealPhysicalDeviceObject;  // Used in PnP API

    //
    // Allow only one stream open at a time to avoid cyclic format
    //
    pDevExt->cndStrmOpen = 0;

    //
    // Serialize in the event of getting two consecutive SRB_OPEN_STREAMs
    //
    KeInitializeMutex( &pDevExt->hMutex, 0);  // Level 0 and in Signal state

    //
    // Initialize our pointer to stream extension
    //
    for (i=0; i<DV_STREAM_COUNT; i++) {
        pDevExt->paStrmExt[i] = NULL;  
    }

    //
    // Bus reset, surprise removal 
    //
    pDevExt->bDevRemoved = FALSE;

    pDevExt->PowerState = PowerDeviceD0;
    
    //
    // External device control (AV/C commands)
    // 
    KeInitializeSpinLock( &pDevExt->AVCCmdLock );  // To guard the count  

    pDevExt->cntCommandQueued   = 0; // Cmd that is completed its life cycle waiting to be read (most for RAW_AVC's Set/Read model)

    InitializeListHead(&pDevExt->AVCCmdList);      

    // Initialize the list of possible opcode values of the response
    // from a Transport State status or notify command. The first item
    // is the number of values that follow.
    ASSERT(sizeof(pDevExt->TransportModes) == 5);
    pDevExt->TransportModes[0] = 4;
    pDevExt->TransportModes[1] = 0xC1;
    pDevExt->TransportModes[2] = 0xC2;
    pDevExt->TransportModes[3] = 0xC3;
    pDevExt->TransportModes[4] = 0xC4;

#ifdef SUPPORT_OPTIMIZE_AVCCMD_RETRIES
    // Set to default values used by avc.sys
    pDevExt->AVCCmdRetries = DEFAULT_AVC_RETRIES;

    pDevExt->DrvLoadCompleted  = FALSE;
    pDevExt->AVCCmdRespTimeMax = 0;
    pDevExt->AVCCmdRespTimeMin = DEFAULT_AVC_TIMEOUT * (DEFAULT_AVC_RETRIES+1) / 10000;
    pDevExt->AVCCmdRespTimeSum = 0;
    pDevExt->AVCCmdCount       = 0;
#endif

    // AVC Command flow control
    KeInitializeMutex(&pDevExt->hMutexIssueAVCCmd, 0);
}


NTSTATUS
DVGetDevInfo(
    IN PDVCR_EXTENSION  pDevExt,
    IN PAV_61883_REQUEST  pAVReq
    )
/*++

Routine Description:

    Issue AVC command to determine basic device information and cache them in the device extension.

--*/
{
    NTSTATUS    Status;
    BYTE                   bAvcBuf[MAX_FCP_PAYLOAD_SIZE];  // For issue AV/C command within this module
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;                  // Point to bAvcBuf;

    PAGED_CODE();

    //
    // Get unit's capabilities such as 
    //     Number of input/output plugs, data rate
    //     UniqueID, VendorID and ModelID
    //

    if(!NT_SUCCESS(
        Status = DVGetUnitCapabilities(
            pDevExt
            ))) {
         TRACE(TL_PNP_ERROR,("Av61883_GetUnitCapabilities Failed = 0x%x\n", Status));
         return Status;
    }

#ifdef NT51_61883
    //
    // Set to create local plug in exclusive address mode:  
    //      This is needed for device that does not support CCM, such as DV.
    //
    // PBinder:  the problem is that you cannot expose a global plug (all nodes on the bus can see it), 
    // since they have no knowledge of what that plug is used for (mpeg2/dv/audio/etc). 
    // so instead, you must create a plug in an exclusive address range. this means that only the device 
    // that you loaded for will see the plug. this means that if you had two pc's and a dv camcorder, 
    // on both pc's, you'll have a plug you created for the dv camcorder, but the pc's will not be able 
    // to see the plug you created, only the dv camcorder.  Keep in mind, this should only be used for 
    // devices that do not support some mechanism of determining what plug to use (such as ccm). 
    // so for any device that just goes out and uses plug #0, this must be enabled.
    //

    if(!NT_SUCCESS(
        Status = DVSetAddressRangeExclusive( 
            pDevExt
            ))) {        
        return Status;
    }
#endif  // NT51_61883

    //
    // Get DV's oPCR[0]
    //
    if(pDevExt->NumOutputPlugs) {
        if(!NT_SUCCESS(
            Status = DVGetDVPlug( 
                pDevExt,
                CMP_PlugOut,
                0,           // Plug [0]
                &pDevExt->hOPcrDV
                ))) {        
            return Status;
        }
    } 
    else {

        pDevExt->hOPcrDV = NULL;  // Redundant since we Zero the whole DeviceExtension


        TRACE(TL_PNP_ERROR,("\'No output plug!\n"));
        // 
        // This is bad!  We cannot even stream from this DV device.
        //
    }

    //
    // Get DV's iPCR
    //
    if(pDevExt->NumInputPlugs) {
        if(!NT_SUCCESS(
            Status = DVGetDVPlug( 
                pDevExt,
                CMP_PlugIn,
                0,           // Plug [0]
                &pDevExt->hIPcrDV
                ))) {        
            return Status;
        }
    }
    else {

        pDevExt->hIPcrDV = NULL;  // Redundant since we Zero the whole DeviceExtension

        TRACE(TL_PNP_ERROR,("\'No input plug!\n"));
        // 
        // Some PAL camcorder has no DVIN plug; we will refuse to make PC->DV connection.
        //
    }

#if 0  // Device control can still work!
    // 
    // Need plug to stream DV (either direction)
    //
    if(   pDevExt->hOPcrDV == NULL
       && pDevExt->hIPcrDV == NULL) {

        TRACE(TL_PNP_ERROR,("\'No input or output plug; return STATUS_INSUFFICIENT_RESOURCES!\n"));
        // 
        // Cannot stream
        //
        return = STATUS_INSUFFICIENT_RESOUCES;
    }
#endif


    // 
    // Subunit_Info : VCR or camera
    //

    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            DV_SUBUNIT_INFO, 
            (PVOID) bAvcBuf
            );

    if(STATUS_SUCCESS == Status) {
        TRACE(TL_PNP_WARNING|TL_FCP_WARNING,("\'DVGetDevInfo: Status %x DV_SUBUNIT_INFO (%x %x %x %x)\n", 
            Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3]));

        // Support DV (Camera+DVCR), DVCR, or analog-DV converter
        if(   bAvcBuf[0] != AVC_DEVICE_TAPE_REC 
           && bAvcBuf[1] != AVC_DEVICE_TAPE_REC
           && bAvcBuf[2] != AVC_DEVICE_TAPE_REC
           && bAvcBuf[3] != AVC_DEVICE_TAPE_REC)
        {
            TRACE(TL_PNP_ERROR,("DVGetDevInfo:Device supported: %x, %x; (VCR %x, Camera %x)\n",
                bAvcBuf[0], bAvcBuf[1], AVC_DEVICE_TAPE_REC, AVC_DEVICE_CAMERA));
            
            return STATUS_NOT_SUPPORTED;  // We only support unit with a tape subunit
        }
        else {
            // DVCR..
        }
    } else {
        TRACE(TL_PNP_ERROR,("DVGetDevInfo: DV_SUBUNIT_INFO failed, Status %x\n", Status));
        //
        // Cannot open this device if it does not support manadatory AVC SUBUnit status command.
        // However, we are making an exception for the DV converter box (will return TIMEOUT).
        //

        // Has our device gone away?
        if (   STATUS_IO_DEVICE_ERROR == Status 
            || STATUS_REQUEST_ABORTED == Status)
            return Status;       
    }


    //
    // Medium_Info: MediaPresent, MediaType, RecordInhibit
    //
    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) bAvcBuf;
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            VCR_MEDIUM_INFO, 
            (PVOID) pXPrtProperty
            );

    if(STATUS_SUCCESS == Status) {
        pDevExt->bHasTape = pXPrtProperty->u.MediumInfo.MediaPresent;
        TRACE(TL_PNP_WARNING|TL_FCP_WARNING,("\'DVGetDevInfo: Status %x HasTape %s, VCR_MEDIUM_INFO (%x %x %x %x)\n", 
            Status, pDevExt->bHasTape ? "Yes" : "No", bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3]));
    } else {
        pDevExt->bHasTape = FALSE;
        TRACE(TL_PNP_ERROR,("DVGetDevInfo: VCR_MEDIUM_INFO failed, Status %x\n", Status));

        // Has our device gone away?
        if (   STATUS_IO_DEVICE_ERROR == Status
            || STATUS_REQUEST_ABORTED == Status)
            return Status;
    }


    //
    // If this is a Panasonic AVC device, we will detect if it is a DVCPro format; 
    // This needs to be called before MediaFormat
    //
    if(pDevExt->ulVendorID == VENDORID_PANASONIC) {
        DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
        DVGetDevIsItDVCPro(
            pDevExt
            );
    }


    //
    // Medium format: NTSC or PAL
    //
    pDevExt->VideoFormatIndex = FMT_IDX_SD_DVCR_NTSC;  // Default
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    if(!DVGetDevSignalFormat(
        pDevExt,
        KSPIN_DATAFLOW_OUT,
        0)) {
        TRACE(TL_PNP_ERROR,("\'!!! Cannot determine IN/OUTPUT SIGNAL MODE!!!! Driver abort !!!\n"));
        return STATUS_UNSUCCESSFUL; // STATUS_NOT_SUPPORTED;
    } else {
        if(   pDevExt->VideoFormatIndex != FMT_IDX_SD_DVCR_NTSC 
           && pDevExt->VideoFormatIndex != FMT_IDX_SD_DVCR_PAL
           && pDevExt->VideoFormatIndex != FMT_IDX_SDL_DVCR_NTSC
           && pDevExt->VideoFormatIndex != FMT_IDX_SDL_DVCR_PAL
           ) {
            TRACE(TL_PNP_ERROR,("**** Format idx %d not supported by this driver ***\n", pDevExt->VideoFormatIndex));
            ASSERT(pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC \
                || pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_PAL \
                || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC \
                || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_PAL \
                );
            return STATUS_UNSUCCESSFUL; // STATUS_NOT_SUPPORTED;
        }
    }

    //
    // Mode of Operation: 0(Undetermined), Camera or VCR
    //
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    DVGetDevModeOfOperation(
        pDevExt
        );

         
    return STATUS_SUCCESS; // Status;
}



NTSTATUS
DVInitializeDevice(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    IN PAV_61883_REQUEST  pAVReq
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

--*/

{
    int i;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Initialize the device extension structure
    //
    DVIniDevExtStruct(
        pDevExt,
        pConfigInfo
        );

#ifdef READ_CUTOMIZE_REG_VALUES
    //
    // Get values from this device's own registry 
    //
    DVGetPropertyValuesFromRegistry(
        pDevExt
        );
#endif

    //
    // Query device information at the laod time:
    //    Subunit
    //    Unit Info
    //    Mode of operation
    //    NTSC or PAL
    //    Speed
    //    oPCR/iPCR
    //
    Status = 
        DVGetDevInfo(
            pDevExt,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_PNP_ERROR,("\'DVGetDevInfo failed %x\n", Status));
        // While driver is loading, the device could be unplug.
        // In this case, the AVC command can return STATUS_REQUEST_ABORTED.
        // In DvGetDevInfo may then return STATUS_NOT_SUPPORTED or STATUS_UNSUCCESSFUL.
        // We will then return this status to indicate loading failure.
#if 0 // DBG
        if(Status != STATUS_REQUEST_ABORTED && !NT_SUCCESS(Status)) {
            ASSERT(NT_SUCCESS(Status) && "DVGetDevInfo failed");
        }
#endif
        return Status;
    }


#ifdef NT51_61883

    //
    // Get Unit isoch parameters
    //
    if(!NT_SUCCESS(
        Status = DVGetUnitIsochParam(
            pDevExt, 
            &pDevExt->UnitIoschParams
            )))
        return Status;


    //
    // Create a local output plug.  This plug is used to updated isoch
    // resource used when connection was made. 
    //
    if(!NT_SUCCESS(
        Status = DVCreateLocalPlug(
            pDevExt, 
            CMP_PlugOut,
            0,                   // Plug number
            &pDevExt->hOPcrPC
            )))
        return Status;

#endif


    //
    // Note: Must do ExAllocatePool after DVIniDevExtStruct() since ->paCurrentStrmInfo is initialized.
    // Since the format that this driver support is known when this driver is known,'
    // the stream information table need to be custonmized.  Make a copy and customized it.
    //

    //
    // Set the size of the stream inforamtion structure that we returned in SRB_GET_STREAM_INFO
    //
        
    pDevExt->paCurrentStrmInfo = (HW_STREAM_INFORMATION *) 
        ExAllocatePool(NonPagedPool, sizeof(HW_STREAM_INFORMATION) * DV_STREAM_COUNT);

    if(!pDevExt->paCurrentStrmInfo) 
        return STATUS_INSUFFICIENT_RESOURCES;   
        
    pConfigInfo->StreamDescriptorSize = 
        (DV_STREAM_COUNT * sizeof(HW_STREAM_INFORMATION)) +      // number of stream descriptors
        sizeof(HW_STREAM_HEADER);                                // and 1 stream header

    // Make a copy of the default stream information
    for(i = 0; i < DV_STREAM_COUNT; i++ ) 
        pDevExt->paCurrentStrmInfo[i] = DVStreams[i].hwStreamInfo;          

    // Set AUDIO AUX to reflect: NTSC/PAL, consumer DV or DVCPRO
    if(pDevExt->bDVCPro) {
        // Note: there is no DVInfo in VideoInfoHeader but there is for the iAV streams.
        SDDV_IavPalStream.DVVideoInfo.dwDVAAuxSrc  = AAUXSRC_SD_PAL_DVCPRO;
        SDDV_IavPalStream.DVVideoInfo.dwDVAAuxSrc1 = AAUXSRC_SD_PAL_DVCPRO | AAUXSRC_AMODE_F;
        SDDV_IavPalStream.DVVideoInfo.dwDVVAuxSrc  = VAUXSRC_DEFAULT | AUXSRC_PAL | AUXSRC_STYPE_SD_DVCPRO;

        SDDV_IavNtscStream.DVVideoInfo.dwDVAAuxSrc = AAUXSRC_SD_NTSC_DVCPRO;
        SDDV_IavNtscStream.DVVideoInfo.dwDVAAuxSrc1= AAUXSRC_SD_NTSC_DVCPRO | AAUXSRC_AMODE_F;
        SDDV_IavNtscStream.DVVideoInfo.dwDVVAuxSrc = VAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD_DVCPRO;

    } else {
        // This might be necessary for the 2nd instance of MSDV (1st:DVCPRO; 2nd:DVSD)
        SDDV_IavPalStream.DVVideoInfo.dwDVAAuxSrc  = AAUXSRC_SD_PAL;
        SDDV_IavPalStream.DVVideoInfo.dwDVAAuxSrc1 = AAUXSRC_SD_PAL  | AAUXSRC_AMODE_F;
        SDDV_IavPalStream.DVVideoInfo.dwDVVAuxSrc  = VAUXSRC_DEFAULT | AUXSRC_PAL | AUXSRC_STYPE_SD;

        SDDV_IavNtscStream.DVVideoInfo.dwDVAAuxSrc = AAUXSRC_SD_NTSC;
        SDDV_IavNtscStream.DVVideoInfo.dwDVAAuxSrc1= AAUXSRC_SD_NTSC | AAUXSRC_AMODE_F;
        SDDV_IavNtscStream.DVVideoInfo.dwDVVAuxSrc = VAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD;
    }


    // Initialize last time format was updated
    pDevExt->tmLastFormatUpdate = GetSystemTime(); 


    TRACE(TL_PNP_WARNING,("\'#### %s%s:%s:%s PhyDO %x, BusDO %x, DevExt %x, FrmSz %d; StrmIf %d\n", 
        (pDevExt->ulDevType == ED_DEVTYPE_VCR ? "DVCR" : (pDevExt->ulDevType == ED_DEVTYPE_CAMERA ? "Camera" : "Tuner?")),
        pDevExt->bDVCPro ? "(DVCPRO)":"",
        (pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC)? "SD:NTSC" : (pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_PAL || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_PAL) ? "PAL" : "MPEG_TS?",
        (pDevExt->ulDevType == ED_DEVTYPE_VCR && pDevExt->NumInputPlugs > 0) ? "CanRec" : "NotRec",
        pDevExt->pPhysicalDeviceObject, 
        pDevExt->pBusDeviceObject, 
        pDevExt,  
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize,
        pConfigInfo->StreamDescriptorSize
        ));
    
    return STATUS_SUCCESS;
}

NTSTATUS
DVInitializeCompleted(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

--*/

{
    PAGED_CODE();


#ifdef SUPPORT_OPTIMIZE_AVCCMD_RETRIES

    //
    // Determine retries 
    //
    pDevExt->DrvLoadCompleted = TRUE;

    if((pDevExt->AVCCmdRespTimeSum / pDevExt->AVCCmdCount) > 
       (DEFAULT_AVC_TIMEOUT * DEFAULT_AVC_RETRIES / 10000)) {
        // If every AVC command was timed out, do not bother to retry.
        pDevExt->AVCCmdRetries = 0;
    } else {

#if 0
        // Some camcorders do not queue up comand so follow a transport
        // state change, it will not accept any AVC command until transport
        // state is in the stable state.  So further delay is needed.

        if(
          // Exception for Samsung; always timeout following XPrt command
          // Or maybe it does not support transport state status command!
          pDevExt->ulVendorID == VENDORID_SAMSUNG                  
          ) {
            TRACE(TL_PNP_ERROR,("Samsung DV device: use default AVC setting.\n"));
        } else {
            pDevExt->AVCCmdRetries = MAX_AVC_CMD_RETRIES;
        }
#endif
    }

    TRACE(TL_PNP_ERROR,("AVCCMd Response Time: pDevExt:%x; Range (%d..%d); Avg %d/%d = %d; Retries:%d\n",
        pDevExt,
        pDevExt->AVCCmdRespTimeMin,
        pDevExt->AVCCmdRespTimeMax,
        pDevExt->AVCCmdRespTimeSum,
        pDevExt->AVCCmdCount,
        pDevExt->AVCCmdRespTimeSum / pDevExt->AVCCmdCount,
        pDevExt->AVCCmdRetries
        ));
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
DVGetStreamInfo(
    IN PDVCR_EXTENSION        pDevExt,
    IN ULONG                  ulBytesToTransfer, 
    IN PHW_STREAM_HEADER      pStreamHeader,       
    IN PHW_STREAM_INFORMATION pStreamInfo
    )

/*++

Routine Description:

    Returns the information of all streams that are supported by the driver

--*/

{
    ULONG i;

    PAGED_CODE();


    //
    // Make sure we have enough space to return our stream informations
    //
    if(ulBytesToTransfer < sizeof (HW_STREAM_HEADER) + sizeof(HW_STREAM_INFORMATION) * DV_STREAM_COUNT ) {
        TRACE(TL_PNP_ERROR,("\'DVGetStrmInfo: ulBytesToTransfer %d ?= %d\n",  
            ulBytesToTransfer, sizeof(HW_STREAM_HEADER) + sizeof(HW_STREAM_INFORMATION) * DV_STREAM_COUNT ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize stream header:
    //   Device properties
    //   Streams
    //

    RtlZeroMemory(pStreamHeader, sizeof(HW_STREAM_HEADER));

    pStreamHeader->NumberOfStreams           = DV_STREAM_COUNT;
    pStreamHeader->SizeOfHwStreamInformation = sizeof(HW_STREAM_INFORMATION);

    pStreamHeader->NumDevPropArrayEntries    = NUMBER_VIDEO_DEVICE_PROPERTIES;
    pStreamHeader->DevicePropertiesArray     = (PKSPROPERTY_SET) VideoDeviceProperties;

    pStreamHeader->NumDevEventArrayEntries   = NUMBER_VIDEO_DEVICE_EVENTS;
    pStreamHeader->DeviceEventsArray         = (PKSEVENT_SET) VideoDeviceEvents;


    TRACE(TL_PNP_TRACE,("\'DVGetStreamInfo: StreamPropEntries %d, DevicePropEntries %d\n",
        pStreamHeader->NumberOfStreams, pStreamHeader->NumDevPropArrayEntries));


    //
    // Initialize the stream structure.
    //
    for( i = 0; i < DV_STREAM_COUNT; i++ )
        *pStreamInfo++ = pDevExt->paCurrentStrmInfo[i];

    //
    //
    // store a pointer to the topology for the device
    //        
    pStreamHeader->Topology = &Topology;


    return STATUS_SUCCESS;
}


BOOL 
DVVerifyDataFormat(
    PKSDATAFORMAT  pKSDataFormatToVerify, 
    ULONG          StreamNumber,
    ULONG          ulSupportedFrameSize,
    HW_STREAM_INFORMATION * paCurrentStrmInfo    
    )
/*++

Routine Description:

    Checks the validity of a format request by walking through the array of 
    supported KSDATA_RANGEs for a given stream.

Arguments:

     pKSDataFormat - pointer of a KS_DATAFORMAT_VIDEOINFOHEADER structure.
     StreamNumber - index of the stream being queried / opened.

Return Value:

     TRUE if the format is supported
     FALSE if the format cannot be suppored

--*/
{
    PKSDATAFORMAT  *pAvailableFormats;
    int            NumberOfFormatArrayEntries;
    int            j;
     
    PAGED_CODE();

    //
    // Make sure the stream index is valid (0..DV_STREAM_COUNT-1)
    //
    if(StreamNumber >= DV_STREAM_COUNT) {
        return FALSE;
    }

    //
    // How many formats does this stream support?
    //
    NumberOfFormatArrayEntries = paCurrentStrmInfo[StreamNumber].NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //
    pAvailableFormats = paCurrentStrmInfo[StreamNumber].StreamFormatsArray;
    
    
    //
    // Walk the array, searching for a match
    //
    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {
        
        //
        // Check supported sample size (== frame size). e.g. SD and SDL have different sample size.
        //
        if( (*pAvailableFormats)->SampleSize != ulSupportedFrameSize) {
            TRACE(TL_STRM_TRACE,("\'  StrmNum %d, %d of %d formats, SizeToVerify %d *!=* SupportedSampleSize %d\n", 
                StreamNumber,
                j+1, NumberOfFormatArrayEntries, 
                (*pAvailableFormats)->SampleSize,  
                ulSupportedFrameSize));
            continue;
        }

        if (!DVCmpGUIDsAndFormatSize(
                 pKSDataFormatToVerify, 
                 *pAvailableFormats,
                 TRUE, // Compare subformat
                 FALSE /* CompareFormatSize */ )) {
            continue;
        }

        //
        // Additional verification test
        //
        if(IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
            // Make sure 
            if( ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage !=
                ulSupportedFrameSize) {
                TRACE(TL_STRM_WARNING,("VIDEOINFO: biSizeToVerify %d != Supported %d\n",
                    ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage,
                    ulSupportedFrameSize
                    ));
                continue;
            } else {
                TRACE(TL_STRM_TRACE,("VIDOINFO: **** biSizeToVerify %d == Supported %d\n",
                    ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage,
                    ulSupportedFrameSize
                    ));
            }
#ifdef SUPPORT_NEW_AVC 
        } else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_DVINFO) ||
                   IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_DV_AVC)
            ) {
#else
        } else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_DVINFO)) {
#endif

            // Test 50/60 bit
            if((((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc & MASK_AUX_50_60_BIT) != 
               (((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc    & MASK_AUX_50_60_BIT)  ||
               (((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc & MASK_AUX_50_60_BIT) != 
               (((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc    & MASK_AUX_50_60_BIT) ) {

                TRACE(TL_STRM_WARNING,("VerifyFormat failed: ASrc: %x!=%x (MSDV);or VSrc: %x!=%x\n",                    
                 ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc, 
                    ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc,
                 ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc,
                    ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc
                     ));

                continue;

            } 

#if 0
            // Make sure the verified format's sample size is supported by the device
            if(ulSupportedFrameSize != ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DataRange.SampleSize) {
                TRACE(TL_STRM_WARNING,("\'SupportedFrameSize %d != SampleSize:%d\n", 
                    ulSupportedFrameSize, ((PKS_DATARANGE_DVVIDEO)pKSDataFormatToVerify)->DataRange.SampleSize));
                continue;
            }
#endif

            TRACE(TL_STRM_TRACE,("\'DVINFO: dwDVAAuxCtl %x, Supported %x\n", 
                ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc,
                ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc
                ));

            TRACE(TL_STRM_TRACE,("\'DVINFO: dwDVVAuxSrc %x, Supported %x\n", 
                ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc,
                ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc
                ));

        }
        else {
            continue;
        }


        return TRUE;
    }

    return FALSE;
} 




NTSTATUS
DVGetDataIntersection(
    IN  ULONG          ulStreamNumber,
    IN  PKSDATARANGE   pDataRange,
    OUT PVOID          pDataFormatBuffer,
    IN  ULONG          ulSizeOfDataFormatBuffer,
    IN  ULONG          ulSupportedFrameSize,
    OUT ULONG          *pulActualBytesTransferred,
    HW_STREAM_INFORMATION * paCurrentStrmInfo
#ifdef SUPPORT_NEW_AVC            
    ,IN HANDLE hPlug
#endif
    )
/*++

Routine Description:

    Called to get a DATAFORMAT from a DATARANGE.

--*/
{
    BOOL                        bMatchFound = FALSE;
    ULONG                       ulFormatSize;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    PAGED_CODE();

    
    
    //
    // Check that the stream number is valid
    //
    if(ulStreamNumber >= DV_STREAM_COUNT) {
        TRACE(TL_STRM_ERROR,("\'DVCRFormatFromRange: ulStreamNumber %d >= DV_STREAM_COUNT %d\n", ulStreamNumber, DV_STREAM_COUNT)); 
        return STATUS_NOT_SUPPORTED;
    }


    // Number of format this stream supports
    ulNumberOfFormatArrayEntries = paCurrentStrmInfo[ulStreamNumber].NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //
    pAvailableFormats = paCurrentStrmInfo[ulStreamNumber].StreamFormatsArray;


    //
    // Walk the formats supported by the stream searching for a match
    // Note: DataIntersection is really enumerating supported MediaType only!
    //       SO matter compare format is NTSC or PAL, we need suceeded both;
    //       however, we will copy back only the format is currently supported (NTSC or PAL).
    //
    for(j = 0; j < ulNumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if(!DVCmpGUIDsAndFormatSize(pDataRange, *pAvailableFormats, FALSE, TRUE)) {
            TRACE(TL_STRM_TRACE,("\'DVCmpGUIDsAndFormatSize failed!\n"));
            continue;
        }

        //
        // Check supported sample size (== frame size).
        //
        if( (*pAvailableFormats)->SampleSize != ulSupportedFrameSize) {
            TRACE(TL_STRM_TRACE,("\'  StrmNum %d, %d of %d formats, SizeToVerify %d *!=* SupportedSampleSize %d\n", 
                ulStreamNumber,
                j+1, ulNumberOfFormatArrayEntries, 
                (*pAvailableFormats)->SampleSize,  
                ulSupportedFrameSize));
            continue;
        }

         
        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if(IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
         
            PKS_DATARANGE_VIDEO pDataRangeVideoToVerify = (PKS_DATARANGE_VIDEO) pDataRange;
            PKS_DATARANGE_VIDEO pDataRangeVideo         = (PKS_DATARANGE_VIDEO) *pAvailableFormats;

#if 0
            //
            // Check that the other fields match
            //
            if ((pDataRangeVideoToVerify->bFixedSizeSamples      != pDataRangeVideo->bFixedSizeSamples)
                || (pDataRangeVideoToVerify->bTemporalCompression   != pDataRangeVideo->bTemporalCompression) 
                || (pDataRangeVideoToVerify->StreamDescriptionFlags != pDataRangeVideo->StreamDescriptionFlags) 
                || (pDataRangeVideoToVerify->MemoryAllocationFlags  != pDataRangeVideo->MemoryAllocationFlags) 
#ifdef COMPARE_CONFIG_CAP
                || (RtlCompareMemory (&pDataRangeVideoToVerify->ConfigCaps,
                    &pDataRangeVideo->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))
#endif
                    )   {

                TRACE(TL_STRM_TRACE,("\'DVFormatFromRange: *!=* bFixSizeSample (%d %d) (%d %d) (%d %d) (%x %x)\n",
                    pDataRangeVideoToVerify->bFixedSizeSamples,      pDataRangeVideo->bFixedSizeSamples,
                    pDataRangeVideoToVerify->bTemporalCompression ,  pDataRangeVideo->bTemporalCompression,
                    pDataRangeVideoToVerify->StreamDescriptionFlags, pDataRangeVideo->StreamDescriptionFlags,
                    pDataRangeVideoToVerify->ConfigCaps.VideoStandard, pDataRangeVideo->ConfigCaps.VideoStandard 
                    ));
                    
                continue;
            } else {
                TRACE(TL_STRM_TRACE,("\'DVFormatFromRange: == bFixSizeSample (%d %d) (%d %d) (%d %d) (%x %x)\n",
                    pDataRangeVideoToVerify->bFixedSizeSamples,      pDataRangeVideo->bFixedSizeSamples,
                    pDataRangeVideoToVerify->bTemporalCompression ,  pDataRangeVideo->bTemporalCompression,
                    pDataRangeVideoToVerify->StreamDescriptionFlags, pDataRangeVideo->StreamDescriptionFlags,
                    pDataRangeVideoToVerify->ConfigCaps.VideoStandard, pDataRangeVideo->ConfigCaps.VideoStandard 
                    ));
            }
           
#endif
            bMatchFound = TRUE;            
            ulFormatSize = sizeof (KSDATAFORMAT) + 
                KS_SIZE_VIDEOHEADER (&pDataRangeVideo->VideoInfoHeader);
            
            if(ulSizeOfDataFormatBuffer == 0) {

                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;

                return STATUS_BUFFER_OVERFLOW;
            }


            // Caller wants the full data format
            if(ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("VIDEOINFO: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n",ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            // KS_DATAFORMAT_VIDEOINFOHEADER
            //    KSDATAFORMAT            DataFormat;
            //    KS_VIDEOINFOHEADER      VideoInfoHeader;                
            RtlCopyMemory(
                &((PKS_DATAFORMAT_VIDEOINFOHEADER)pDataFormatBuffer)->DataFormat,
                &pDataRangeVideo->DataRange, 
                sizeof (KSDATAFORMAT));

            // This size is differnt from our data range size which also contains ConfigCap
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

            RtlCopyMemory(
                &((PKS_DATAFORMAT_VIDEOINFOHEADER) pDataFormatBuffer)->VideoInfoHeader,
                &pDataRangeVideo->VideoInfoHeader,  
                KS_SIZE_VIDEOHEADER (&pDataRangeVideo->VideoInfoHeader));

            TRACE(TL_STRM_TRACE,("\'DVFormatFromRange: Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d, biSizeImage.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer,
                ((PKS_DATAFORMAT_VIDEOINFOHEADER) pDataFormatBuffer)->VideoInfoHeader.bmiHeader.biSizeImage));

            return STATUS_SUCCESS;

        } else if (IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_DVINFO)) {
            // -------------------------------------------------------------------
            // Specifier FORMAT_DVInfo for KS_DATARANGE_DVVIDEO
            // -------------------------------------------------------------------

            // MATCH FOUND!
            bMatchFound = TRUE;            

            ulFormatSize = sizeof(KS_DATARANGE_DVVIDEO);

            if(ulSizeOfDataFormatBuffer == 0) {
                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;
                return STATUS_BUFFER_OVERFLOW;
            }
            
            // Caller wants the full data format
            if (ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("\'DVINFO: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n", ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            RtlCopyMemory(
                pDataFormatBuffer,
                *pAvailableFormats, 
                (*pAvailableFormats)->FormatSize); 

            
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

            TRACE(TL_STRM_TRACE,("\'** DVFormatFromRange: (DVINFO) Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer));

            return STATUS_SUCCESS;

#ifdef SUPPORT_NEW_AVC            
        } else if (IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_DV_AVC)) {
            // -------------------------------------------------------------------
            // Specifier FORMAT_DVInfo for KS_DATARANGE_DVVIDEO
            // -------------------------------------------------------------------

            // MATCH FOUND!
            bMatchFound = TRUE;            

            ulFormatSize = sizeof(KS_DATARANGE_DV_AVC);

            if(ulSizeOfDataFormatBuffer == 0) {
                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;
                return STATUS_BUFFER_OVERFLOW;
            }
            
            // Caller wants the full data format
            if (ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("\'** DV_AVC: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n", ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            RtlCopyMemory(
                pDataFormatBuffer,
                *pAvailableFormats, 
                (*pAvailableFormats)->FormatSize); 
            
            ((KS_DATAFORMAT_DV_AVC *)pDataFormatBuffer)->ConnectInfo.hPlug = hPlug;

            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

            TRACE(TL_STRM_TRACE,("\'*** DVFormatFromRange: (DV_AVC) Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer));

            return STATUS_SUCCESS;

#endif // SUPPORT_NEW_AVC 
        }         
        else {
            TRACE(TL_STRM_ERROR,("\'Invalid Specifier, No match !\n"));
            return STATUS_NO_MATCH;
        }

    } // End of loop on all formats for this stream
    
    if(!bMatchFound) {

        TRACE(TL_STRM_TRACE,("\'DVFormatFromRange: No Match! StrmNum %d, pDataRange %x\n", ulStreamNumber, pDataRange));
    }

    return STATUS_NO_MATCH;         
}



VOID 
DVIniStrmExt(
    PHW_STREAM_OBJECT  pStrmObject,
    PSTREAMEX          pStrmExt,
    PDVCR_EXTENSION    pDevExt,
    const PALL_STREAM_INFO   pStream
    )
/*++

Routine Description:

    Initialize stream extension strcuture.

--*/
{

    PAGED_CODE();


    RtlZeroMemory( pStrmExt, sizeof(STREAMEX) );

    pStrmExt->bEOStream     = TRUE;       // Stream has not started yet!

    pStrmExt->pStrmObject   = pStrmObject;
    pStrmExt->StreamState   = KSSTATE_STOP;
    pStrmExt->pDevExt       = pDevExt;

    pStrmExt->hMyClock      = 0;
    pStrmExt->hMasterClock  = 0;
    pStrmExt->hClock        = 0;


//
// Aplly to both IN/OUT data flow
//
    //
    // Init isoch resources
    //
    pStrmExt->CurrentStreamTime = 0;  

    pStrmExt->cntSRBReceived  = 0;  // number of SRB_READ/WRITE_DATA
    pStrmExt->cntSRBCancelled = 0;  // number of SRB_READ/WRITE_DATA cancelled
    

    pStrmExt->FramesProcessed = 0;
    pStrmExt->PictureNumber   = 0;
    pStrmExt->FramesDropped   = 0;   


#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
    //
    // Subcode data that can be extract from a DV frame
    //

    pStrmExt->AbsTrackNumber = 0;
    pStrmExt->bATNUpdated    = FALSE;

    pStrmExt->Timecode[0] = 0;
    pStrmExt->Timecode[1] = 0;
    pStrmExt->Timecode[2] = 0;
    pStrmExt->Timecode[3] = 0;
    pStrmExt->bTimecodeUpdated = FALSE;
#endif

    //
    //  Flow control and queue management
    //

    pStrmExt->lStartIsochToken = 0;

    pStrmExt->pAttachFrameThreadObject = NULL;

    pStrmExt->cntSRBQueued = 0;                        // SRB_WRITE_DATA only
    InitializeListHead(&pStrmExt->SRBQueuedListHead);  // SRB_WRITE_DATA only

    pStrmExt->cntDataDetached = 0;
    InitializeListHead(&pStrmExt->DataDetachedListHead);

    pStrmExt->cntDataAttached = 0;
    InitializeListHead(&pStrmExt->DataAttachedListHead);

    pStrmExt->b1stNewFrameFromPauseState = TRUE;  // STOP State-> RUN will have discontinuity

    //
    // Work item variables use to cancel all SRBs
    //
    pStrmExt->lCancelStateWorkItem = 0;
    pStrmExt->bAbortPending = FALSE;
#ifdef USE_WDM110
    pStrmExt->pIoWorkItem = NULL;
#endif

   
    //
    // Cache the pointer
    // What in DVStreams[] are READONLY
    //
    pStrmExt->pStrmInfo = &pStream->hwStreamInfo;

    pStrmObject->ReceiveDataPacket    = (PVOID) pStream->hwStreamObject.ReceiveDataPacket;
    pStrmObject->ReceiveControlPacket = (PVOID) pStream->hwStreamObject.ReceiveControlPacket;
    pStrmObject->Dma                          = pStream->hwStreamObject.Dma;
    pStrmObject->Pio                          = pStream->hwStreamObject.Pio;
    pStrmObject->StreamHeaderWorkspace        = pStream->hwStreamObject.StreamHeaderWorkspace;
    pStrmObject->StreamHeaderMediaSpecific    = pStream->hwStreamObject.StreamHeaderMediaSpecific;
    pStrmObject->HwClockObject                = pStream->hwStreamObject.HwClockObject;
    pStrmObject->Allocator                    = pStream->hwStreamObject.Allocator;
    pStrmObject->HwEventRoutine               = pStream->hwStreamObject.HwEventRoutine;

}



NTSTATUS
DVOpenStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    )

/*++

Routine Description:

    Verify the OpenFormat and then allocate PC resource needed for this stream.
    The isoch resource, if needed, is allocated when streaming is transition to PAUSE state.

--*/

{
    NTSTATUS         Status = STATUS_SUCCESS;
    PSTREAMEX        pStrmExt;
    PDVCR_EXTENSION  pDevExt;
    ULONG            idxStreamNumber;
    KSPIN_DATAFLOW   DataFlow;
    PIRP             pIrp;
    FMT_INDEX        VideoFormatIndexLast;  // Last format index; used to detect change.
#ifdef SUPPORT_NEW_AVC
    AVCCONNECTINFO * pAvcConnectInfo;
#endif


    PAGED_CODE();

    
    pDevExt  = (PDVCR_EXTENSION) pStrmObject->HwDeviceExtension;
    pStrmExt = (PSTREAMEX)       pStrmObject->HwStreamExtension;

    idxStreamNumber =            pStrmObject->StreamNumber;

    TRACE(TL_STRM_TRACE,("\'DVOpenStream: pStrmObject %x, pOpenFormat %x, cntOpen %d, idxStream %d\n", pStrmObject, pOpenFormat, pDevExt->cndStrmOpen, idxStreamNumber));

    //
    // Only one string can be open at any time to prevent cyclin connection
    //
    if(pDevExt->cndStrmOpen > 0) {
        TRACE(TL_STRM_WARNING,("\'DVOpenStream: %d stream open already; failed hr %x\n", pDevExt->cndStrmOpen, Status));
        return STATUS_UNSUCCESSFUL;
    }

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // If a user switch from Camera to VCR mode very quickly (passing the OFF position), 
    // the driver may not be relaoded to detect correct mode of operation.
    // It is safe to redetect here.
    // Note: MSDV does return all the stream info for both input and output pin format.
    //
    DVGetDevModeOfOperation(pDevExt);


    //
    // WARNING: !! we advertise both input and output pin regardless of its mode of operation,
    // but Camera does not support input pin so open should failed!
    // If a VCR does not have input pin should fail as well.
    //
    // Ignore checking for ED_DEVTYOPE_UNKNOWN (most likely a hardware decoder box)
    //
    if((pDevExt->ulDevType == ED_DEVTYPE_CAMERA || 
        (pDevExt->ulDevType == ED_DEVTYPE_VCR && pDevExt->NumInputPlugs == 0))
        && idxStreamNumber == 2) {
        TRACE(TL_STRM_ERROR,("\'OpenStream failed: Camera or VCR (0 inpin).\n"));
        Status =  STATUS_UNSUCCESSFUL;
        goto AbortOpenStream;
    }


    ASSERT(idxStreamNumber < DV_STREAM_COUNT);
    ASSERT(pDevExt->paStrmExt[idxStreamNumber] == NULL);  // Not yet open!

    //
    // Initialize the stream extension structure
    //
    DVIniStrmExt(
         pStrmObject, 
         pStrmExt,
         pDevExt,
         &DVStreams[idxStreamNumber]
         );

    // Sony's NTSC can play PAL tape and its plug will change its supported format accordingly.
    //
    // Query video format (NTSC/PAL) supported.
    // Compare with its default (set at load time or last opensteam),
    // if difference, change our internal video format table.
    //

    DataFlow= pDevExt->paCurrentStrmInfo[idxStreamNumber].DataFlow;

    VideoFormatIndexLast = pDevExt->VideoFormatIndex;
    if(!DVGetDevSignalFormat(
            pDevExt,
            DataFlow,
            pStrmExt
            )) {
            // If querying its format has failed, we cannot open this stream.
            TRACE(TL_STRM_ERROR,("\'OpenStream failed:cannot determine signal mode (NTSC/PAL, SD.SDL).\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto AbortOpenStream;
    }


    //
    // Check the video data format is okay.
    //
    if(!DVVerifyDataFormat(
            pOpenFormat, 
            idxStreamNumber,
            DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize,
            pDevExt->paCurrentStrmInfo
            ) ) { 
        TRACE(TL_STRM_ERROR,("\'DVOpenStream: AdapterVerifyFormat failed.\n"));        
        Status = STATUS_INVALID_PARAMETER;
        goto AbortOpenStream;
    }

           
    //
    // Initialize events used for synchronization
    //

#ifdef SUPPORT_PREROLL_AT_RUN_STATE
    KeInitializeEvent(&pStrmExt->hPreRollEvent,    NotificationEvent, FALSE);  // Non-signal; Satisfy multple thread; manual reset
    pStrmExt->bPrerollCompleted = FALSE;
#endif
    KeInitializeEvent(&pStrmExt->hSrbArriveEvent,  NotificationEvent, FALSE);  // Non-signal; Satisfy multiple thread; manual reset
    KeInitializeEvent(&pStrmExt->hCancelDoneEvent, NotificationEvent, TRUE);   // Signal!

    //
    // Synchronize attaching frame thread and other critical operations:
    //     (1) power off/on; and 
    //     (2) surprise removal
    //
    if(KSPIN_DATAFLOW_IN == DataFlow) {
        // NonSignal when halting; initially halt until some frames have arrived.
        KeInitializeEvent(&pStrmExt->hRunThreadEvent,  NotificationEvent, FALSE);  pStrmExt->XmtState = THD_HALT;  // Initial state
        pStrmExt->bXmtThreadStarted = FALSE;  // Set (TRUE) on the 1st time SetEvent on hRunThreadEvent.
    }


    //
    // Alloccate synchronization structures for flow control and queue management
    //

    if(!(pStrmExt->XmtThreadMutex = (KMUTEX *) ExAllocatePool(NonPagedPool, sizeof(KMUTEX)))) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeMutex( pStrmExt->XmtThreadMutex, 0);      // Level 0 and in Signal state
    
    if(!(pStrmExt->hStreamMutex = (KMUTEX *) ExAllocatePool(NonPagedPool, sizeof(KMUTEX)))) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeMutex( pStrmExt->hStreamMutex, 0);      // Level 0 and in Signal state

    if(!(pStrmExt->DataListLock = (KSPIN_LOCK *) ExAllocatePool(NonPagedPool, sizeof(KSPIN_LOCK)))) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeSpinLock(pStrmExt->DataListLock);
#if DBG
    pStrmExt->DataListLockSave = pStrmExt->DataListLock;
#endif

    //
    // Allocate resource for timer DPC
    //

    if(!(pStrmExt->DPCTimer = (KDPC *) ExAllocatePool(NonPagedPool, sizeof(KDPC)))) {  
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }

    if(!(pStrmExt->Timer = (KTIMER *) ExAllocatePool(NonPagedPool, sizeof(KTIMER)))) {  
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }

    //
    // Set a timer to periodically check for expired clock events.
    // This timer is active only in RUN state and if we are the clock provider.
    //
    KeInitializeDpc(
        pStrmExt->DPCTimer,
        DVSignalClockEvent,
        pStrmExt
        );
    KeInitializeTimer(
        pStrmExt->Timer
        );
    pStrmExt->bTimerEnabled = FALSE;


#ifdef SUPPORT_NEW_AVC
    if(IsEqualGUID (&pOpenFormat->Specifier, &KSDATAFORMAT_SPECIFIER_DV_AVC)) {
     
        pAvcConnectInfo = &((KS_DATAFORMAT_DV_AVC *) pOpenFormat)->ConnectInfo;
        if(DataFlow == KSPIN_DATAFLOW_OUT) {
            // DV1(that is us) (oPCR) -> DV2 (iPCR)
            pStrmExt->hOutputPcr = pDevExt->hOPcrDV;         // DV1's oPCR
            pStrmExt->hInputPcr  = pAvcConnectInfo->hPlug;   // DV2's iPCR
            TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV1 (oPCR:%x) -> DV2 (iPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hOutputPcr, pStrmExt->hInputPcr));
        } else {
            // DV1(that is us) (iPCR) <- DV2 (oPCR)
            pStrmExt->hOutputPcr = pAvcConnectInfo->hPlug;   // DV2's oPCR
            pStrmExt->hInputPcr  = pDevExt->hIPcrDV;         // DV1's iPCR
            TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV1 (iPCR:%x) <- DV2 (oPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hInputPcr, pStrmExt->hOutputPcr));
        }

        pStrmExt->bDV2DVConnect = TRUE;

    } else {

        if(DataFlow == KSPIN_DATAFLOW_OUT) {
            // DV1(that is us) (oPCR) -> PC (iPCR)
            pStrmExt->hOutputPcr = pDevExt->hOPcrDV;
            pStrmExt->hInputPcr  = 0; // We do not create local iPCR
            TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV (oPCR:%x) -> PC (iPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hOutputPcr, pStrmExt->hInputPcr));

        } else {
            // DV1(that is us) (iPCR) <- PC (oPCR)
            pStrmExt->hOutputPcr = pDevExt->hOPcrPC;
            pStrmExt->hInputPcr  = pDevExt->hIPcrDV;
            TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV (iPCR:%x) <- PC (oPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hInputPcr, pStrmExt->hOutputPcr));
        }

        pStrmExt->bDV2DVConnect = FALSE;
    }
#else
    if(DataFlow == KSPIN_DATAFLOW_OUT) {
        // DV1(that is us) (oPCR) -> PC (iPCR)
        pStrmExt->hOutputPcr = pDevExt->hOPcrDV;
        pStrmExt->hInputPcr  = 0; // We do not create local iPCR
        TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV (oPCR:%x) -> PC (iPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hOutputPcr, pStrmExt->hInputPcr));

    } else {
        // DV1(that is us) (iPCR) <- PC (oPCR)
        pStrmExt->hOutputPcr = pDevExt->hOPcrPC;
        pStrmExt->hInputPcr  = pDevExt->hIPcrDV;
        TRACE(TL_STRM_WARNING,("\'!!!!! (pStrmExt:%x) DV (iPCR:%x) <- PC (oPCR:%x) !!!!!\n\n", pStrmExt, pStrmExt->hInputPcr, pStrmExt->hOutputPcr));
    }
#endif

    IoFreeIrp(pIrp); pIrp = NULL;


#if DBG
    // Allocate buffer to keep statistic of transmitted buffers.
    pStrmExt->paXmtStat = (XMT_FRAME_STAT *) 
        ExAllocatePool(NonPagedPool, sizeof(XMT_FRAME_STAT) * MAX_XMT_FRAMES_TRACED);

    if(!pStrmExt->paXmtStat) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;         
    }
    pStrmExt->ulStatEntries = 0;
#endif

    //
    // Pre-allcoate resource (Lists)
    //
    if(!NT_SUCCESS(
        Status = DvAllocatePCResource(
            DataFlow,
            pStrmExt
            ))) {
        goto AbortOpenStream; 
    }


    //
    //  Cache it and reference when pDevExt is all we have, 
    //  such as BusReset and SurprieseRemoval
    //
    pDevExt->idxStreamNumber = idxStreamNumber;  // index of current active stream; work only if there is only one active stream at any time.
    pDevExt->paStrmExt[idxStreamNumber] = pStrmExt;

    //
    // In the future, a DV can be unplug and plug back in, 
    // and restore its state if the application is not yet closed.
    //
    pDevExt->bDevRemoved    = FALSE;

    //
    // No one else can open another stream (inout or output) unitil this is release.
    // This is done to avoid cyclic graph.
    //
    pDevExt->cndStrmOpen++;    
    ASSERT(pDevExt->cndStrmOpen == 1);  // Only one can be open at any time.
    
    TRACE(TL_STRM_WARNING,("\'OpenStream: %d stream open, idx %d, Status %x, pStrmExt %x, pDevExt %x\n", 
        pDevExt->cndStrmOpen, pDevExt->idxStreamNumber, Status, pStrmExt, pDevExt));     
    TRACE(TL_STRM_WARNING,("\' #OPEN_STREAM#: Status %x, idxStream %d, pDevExt %x, pStrmExt %x\n", 
        Status, idxStreamNumber, pDevExt, pStrmExt));

    return Status;

AbortOpenStream:       

    if(pIrp) {
        IoFreeIrp(pIrp);  pIrp = NULL;        
    }

    if(pStrmExt->DataListLock) {
        ExFreePool(pStrmExt->DataListLock); pStrmExt->DataListLock = NULL;
    }

    if(pStrmExt->XmtThreadMutex) {
        ExFreePool(pStrmExt->XmtThreadMutex); pStrmExt->XmtThreadMutex = NULL;
    }

    if(pStrmExt->hStreamMutex) {
        ExFreePool(pStrmExt->hStreamMutex); pStrmExt->hStreamMutex = NULL;
    }

    if(pStrmExt->DPCTimer) {
        ExFreePool(pStrmExt->DPCTimer); pStrmExt->DPCTimer = NULL;
    }

    if(pStrmExt->Timer) {
        ExFreePool(pStrmExt->Timer); pStrmExt->Timer = NULL;
    }

#if DBG
    if(pStrmExt->paXmtStat) {
        ExFreePool(pStrmExt->paXmtStat); pStrmExt->paXmtStat = NULL;
    }
#endif

    TRACE(TL_STRM_WARNING,("\'#OPEN_STREAM# failed!: Status %x, idxStream %d, pDevExt %x, pStrmExt %x\n", 
        Status, idxStreamNumber, pDevExt, pStrmExt));

    return Status;
}


NTSTATUS
DVCloseStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    )

/*++

Routine Description:

    Called when an CloseStream Srb request is received

--*/

{
    ULONG             i;
    PSTREAMEX         pStrmExt;
    PDVCR_EXTENSION   pDevExt;
    ULONG             idxStreamNumber;   


    PAGED_CODE();

    
    pDevExt  = (PDVCR_EXTENSION) pStrmObject->HwDeviceExtension;
    pStrmExt = (PSTREAMEX)       pStrmObject->HwStreamExtension;

    idxStreamNumber =            pStrmObject->StreamNumber;


    TRACE(TL_STRM_WARNING,("\'DVCloseStream: >> pStrmExt %x, pDevExt %x\n", pStrmExt, pDevExt));    


    //
    // If the stream isn't open, just return
    //
    if(pStrmExt == NULL) {
        ASSERT(pStrmExt && "CloseStream but pStrmExt is NULL!");   
        return STATUS_SUCCESS;  // ????
    }

    //
    // Wait until the pending work item is completed.  
    //
    TRACE(TL_STRM_WARNING,("\'CloseStream: pStrmExt->lCancelStateWorkItem:%d\n", pStrmExt->lCancelStateWorkItem)); 
    KeWaitForSingleObject( &pStrmExt->hCancelDoneEvent, Executive, KernelMode, FALSE, 0 );


    // Cancel should have been done when we are in PAUSE state.
    // But if an application is close, it might not transtioning into PAUSE state.
    if(pStrmExt->bTimerEnabled) {
         TRACE(TL_STRM_WARNING,("\'*** (CloseStream) CancelTimer *\n"));
         KeCancelTimer(
            pStrmExt->Timer
            );
         pStrmExt->bTimerEnabled = FALSE;
    }


    //
    // If talking or listening (i.e. streaming), stop it!
    // In case of system shutdown while streaming or application crash
    //

    DVStopCancelDisconnect(
        pStrmExt
        );

    //
    // Free all allocated PC resoruce
    //
    DvFreePCResource(
        pStrmExt
        );

    ASSERT(pStrmExt->cntDataDetached == 0 && IsListEmpty(&pStrmExt->DataDetachedListHead) && "Detach List not empty!");
    ASSERT(pStrmExt->cntDataAttached == 0 && IsListEmpty(&pStrmExt->DataAttachedListHead) && "Attach List not empty!");
    ASSERT(pStrmExt->cntSRBQueued    == 0 && IsListEmpty(&pStrmExt->SRBQueuedListHead)    && "SrbQ List not empty!");


    // Terminate the system thread that is used for attaching frame for transmit to DV
    if(
          KSPIN_DATAFLOW_IN == pStrmExt->pStrmInfo->DataFlow
       && !pStrmExt->bTerminateThread
       && pStrmExt->pAttachFrameThreadObject
      ) { 
        DVTerminateAttachFrameThread(pStrmExt);
        pStrmExt->pAttachFrameThreadObject = NULL;
        TRACE(TL_STRM_WARNING,("** DVCloseStream: thread terminated!\n"));
    }



#if DBG
    // Print this only if the debug flag is set.
    if(pStrmExt->paXmtStat) {
        if(DVDebugXmt) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("Data transmission statistics: (%s %s); (Pause:%d; Run:%d); hMasterClk:%x; hClock:%x\n\n", 
                __DATE__, __TIME__, pStrmExt->lFramesAccumulatedPaused, 
                pStrmExt->lFramesAccumulatedRun, pStrmExt->hMasterClock, pStrmExt->hClock));
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("ST \tSrbRcv \tSrbQ \tSrbPend \tAttached \tSlot \ttmStream \tDrop \tSrb# \tFlags \ttmPres \tSCnt \tCyCnt \tCyOfst\n"));
            for(i=0; i < pStrmExt->ulStatEntries; i++) {
                TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("%d \t%d \t%d \t%d \t%d \t%d \t%d \t%d \t%d \t%x \t%d \t%d \t%d \t%d\n",
                    pStrmExt->paXmtStat[i].StreamState,
                    pStrmExt->paXmtStat[i].cntSRBReceived,
                    pStrmExt->paXmtStat[i].cntSRBQueued,
                    pStrmExt->paXmtStat[i].cntSRBPending,
                    pStrmExt->paXmtStat[i].cntDataAttached,
                    (DWORD) pStrmExt->paXmtStat[i].FrameSlot,
                    (DWORD) pStrmExt->paXmtStat[i].tmStreamTime, // /10000,
                    pStrmExt->paXmtStat[i].DropCount,
                    pStrmExt->paXmtStat[i].FrameNumber,
                    (DWORD) pStrmExt->paXmtStat[i].OptionsFlags,
                    (DWORD) pStrmExt->paXmtStat[i].tmPresentation, // /10000,
                    pStrmExt->paXmtStat[i].tsTransmitted.CL_SecondCount,
                    pStrmExt->paXmtStat[i].tsTransmitted.CL_CycleCount,
                    pStrmExt->paXmtStat[i].tsTransmitted.CL_CycleOffset                 
                ));
            }
        }

        ExFreePool(pStrmExt->paXmtStat); pStrmExt->paXmtStat = NULL;
    }
#endif

    //
    //  Find the matching stream extension and invalidate it.
    //
    for (i=0; i<DV_STREAM_COUNT; i++) {

        if(pStrmExt == pDevExt->paStrmExt[i]) {
            ASSERT(!pDevExt->paStrmExt[i]->bAbortPending && "Cannot close a stream when abort is pending"); 
            pDevExt->paStrmExt[i] = NULL;
            break;
        }
    }

    // Release this count so other can open.   
    pDevExt->cndStrmOpen--;
    ASSERT(pDevExt->cndStrmOpen == 0);

    TRACE(TL_STRM_WARNING,("\'DVCloseStream: %d stream; AQD [%d:%d:%d]\n", 
        pDevExt->cndStrmOpen,
        pStrmExt->cntDataAttached,
        pStrmExt->cntSRBQueued,
        pStrmExt->cntDataDetached
        ));

#if DBG
    ASSERT(pStrmExt->DataListLockSave == pStrmExt->DataListLock);
#endif
    if(pStrmExt->DataListLock) {
        ExFreePool(pStrmExt->DataListLock); pStrmExt->DataListLock = NULL;
    }

    if(pStrmExt->XmtThreadMutex) {
        ExFreePool(pStrmExt->XmtThreadMutex); pStrmExt->XmtThreadMutex = NULL;
    }

    if(pStrmExt->hStreamMutex) {
        ExFreePool(pStrmExt->hStreamMutex); pStrmExt->hStreamMutex = NULL;
    }

    if(pStrmExt->DPCTimer) {
        ExFreePool(pStrmExt->DPCTimer); pStrmExt->DPCTimer = NULL;
    }

    if(pStrmExt->Timer) {
        ExFreePool(pStrmExt->Timer); pStrmExt->Timer = NULL;
    }


    //
    // Done with stream extention.  Will be invalid from this point on.
    //
#if 0
    RtlZeroMemory(pStrmExt, sizeof(STREAMEX));
#endif
    return STATUS_SUCCESS;
}


NTSTATUS
DVChangePower(
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST pAVReq,
    DEVICE_POWER_STATE NewPowerState
    )
/*++

Routine Description:

    Process changing this device's power state.  

--*/
{
    ULONG i;   
    NTSTATUS Status;

    PAGED_CODE();


    // 
    //    D0: Device is on and can be streaming.
    //    D1,D2: not supported.
    //    D3: Device is off and can not streaming. The context is lost.  
    //        Power can be removed from the device.
    //        When power is back on, we will get a bus reset.
    //

    TRACE(TL_PNP_WARNING,("\'PowrSt: %d->%d; (d0:[1:On],D3[4:off])\n", pDevExt->PowerState, NewPowerState));

    Status = STATUS_SUCCESS;

    if(pDevExt->PowerState == NewPowerState) {
        TRACE(TL_PNP_WARNING,("\'ChangePower: same power state!\n"));
        return STATUS_SUCCESS;
    }

    switch (NewPowerState) {
    case PowerDeviceD3:  // Power OFF   
        // We are at D0 and ask to go to D3: save state, stop streaming and Sleep
        if( pDevExt->PowerState == PowerDeviceD0)  {

            pDevExt->PowerState = NewPowerState;

            // For a supported power state change
            for (i=0; i<DV_STREAM_COUNT; i++) {
                if(pDevExt->paStrmExt[i]) {
                    TRACE(TL_PNP_WARNING,("\'D0->D3 (PowerOff), pStrmExt:%x; StrmSt:%d; IsochActive:%d; SrbQ:%d\n", 
                        pDevExt->paStrmExt[i], pDevExt->paStrmExt[i]->StreamState, pDevExt->paStrmExt[i]->bIsochIsActive, pDevExt->paStrmExt[i]->cntSRBQueued));

                    //
                    // Halt attach frame thread if it is an input pin
                    //
                    if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) 
                        DVSetXmtThreadState(pDevExt->paStrmExt[i], THD_HALT);


                    if(pDevExt->paStrmExt[i]->bIsochIsActive) {
                        // Stop isoch but do not change the streaming state
                        TRACE(TL_PNP_WARNING,("\'ChangePower: Stop isoche; StrmSt:%d\n", pDevExt->paStrmExt[i]->StreamState)); 
                        DVStreamingStop(
                            pDevExt->paStrmExt[i], 
                            pDevExt, 
                            pAVReq
                            ) ;
                    }

                    // Complete all the pending events so that the downstream 
                    // filter (Video render) can release this buffer from AdviseTime() event.
                    // However, not sure why this is necessary since the lower filter 
                    // will get a PAUSE() or STOP() from the filter manager.  In such                    
                    DVSignalClockEvent(0, pDevExt->paStrmExt[i], 0, 0); 
                }
            }
        }
        else {
            TRACE(TL_PNP_WARNING,("\'ChangePower: unsupported %d -> %d; (do nothing!).\n", pDevExt->PowerState, DevicePowerState));           
        }
        break;

    case PowerDeviceD0:  // Powering ON (waking up)
        if( pDevExt->PowerState == PowerDeviceD3) {

            // Set PowerState change and then Signal PowerOn event
            pDevExt->PowerState = NewPowerState; 

            // For a supported power state change
            for (i=0; i<DV_STREAM_COUNT; i++) {
                if(pDevExt->paStrmExt[i]) {
                    TRACE(TL_PNP_WARNING,("\'D3->D0 (PowerOn), pStrmExt:%x; StrmSt:%d; IsochActive:%d; SrbQ:%d\n", 
                        pDevExt->paStrmExt[i], pDevExt->paStrmExt[i]->StreamState, pDevExt->paStrmExt[i]->bIsochIsActive, pDevExt->paStrmExt[i]->cntSRBQueued));
                    if(!pDevExt->paStrmExt[i]->bIsochIsActive) {
                        TRACE(TL_PNP_WARNING,("\'ChangePower: StrmSt:%d; Start isoch\n", pDevExt->paStrmExt[i]->StreamState)); 
                        // Start isoch depending on streaming state for DATAFLOW_IN/OUT
                        if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
                            if(pDevExt->paStrmExt[i]->StreamState == KSSTATE_PAUSE ||
                                pDevExt->paStrmExt[i]->StreamState == KSSTATE_RUN) {                             
                                DVStreamingStart(
                                    pDevExt->paStrmExt[i]->pStrmInfo->DataFlow, 
                                    pDevExt->paStrmExt[i], 
                                    pDevExt
                                    ) ;
                            }
                        }
                        else if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
                            if(pDevExt->paStrmExt[i]->StreamState == KSSTATE_RUN) {                             
                                DVStreamingStart(
                                    pDevExt->paStrmExt[i]->pStrmInfo->DataFlow, 
                                    pDevExt->paStrmExt[i], 
                                    pDevExt
                                    ) ;
                            }
                        }                    
                    }  // IsochActive
#if 1  // Clear any buffer queued in the downstream.
                    // Complete all the pending events so that the downstream 
                    // filter (Video render) can release this buffer from AdviseTime() event.
                    // However, not sure why this is necessary since the lower filter 
                    // will get a PAUSE() or STOP() from the filter manager.  In such                    
                    DVSignalClockEvent(0, pDevExt->paStrmExt[i], 0, 0); 
#endif

                    //
                    // Resume attaching frame operation
                    //
                    if(
                          pDevExt->paStrmExt[i]->pAttachFrameThreadObject  // If thread is created!
                       && !pDevExt->paStrmExt[i]->bTerminateThread         // Not terminated abnormally
                       && pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN
                      ) {
                        // Resume if it was started before power state change.
                        if(pDevExt->paStrmExt[i]->bXmtThreadStarted)
                            KeSetEvent(&pDevExt->paStrmExt[i]->hRunThreadEvent, 0 ,FALSE);
                    }
                }
            }
        }
        else {
            TRACE(TL_PNP_WARNING,("\'ChangePower: supported %d -> %d; (do nothing!).\n", pDevExt->PowerState, DevicePowerState));           
        }
        break;

    // These state are not supported.
    case PowerDeviceD1:
    case PowerDeviceD2:               
    default:
        TRACE(TL_PNP_WARNING,("\'ChangePower: unsupported %d to %d (do nothing).\n", pDevExt->PowerState, DevicePowerState));
        Status = STATUS_SUCCESS; // STATUS_INVALID_PARAMETER;
        break;
    }
           

    if(Status == STATUS_SUCCESS) 
        pDevExt->PowerState = NewPowerState;         
    else 
        Status = STATUS_NOT_IMPLEMENTED;

    TRACE(TL_PNP_WARNING,("\'DVChangePower: Exiting; Status:%x\n", Status));

    return STATUS_SUCCESS;     
}


NTSTATUS
DVSurpriseRemoval(
    PDVCR_EXTENSION pDevExt,
    PAV_61883_REQUEST  pAVReq
    )

/*++

Routine Description:

    Response to SRB_SURPRISE_REMOVAL.

--*/

{
    ULONG i;
    KIRQL    oldIrql;
    PKSEVENT_ENTRY   pEvent = NULL;

    PAGED_CODE();

    //
    // ONLY place this flag is set to TRUE.
    // Block incoming read although there might still in the process of being attached
    //
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &oldIrql);            
    pDevExt->bDevRemoved = TRUE;
    KeReleaseSpinLock(&pDevExt->AVCCmdLock, oldIrql);


    //
    // Now Stop the stream and clean up
    //

    for(i=0; i < DV_STREAM_COUNT; i++) {
        
        if(pDevExt->paStrmExt[i] != NULL) {

            TRACE(TL_PNP_WARNING,("\' #SURPRISE_REMOVAL# StrmNum %d, pStrmExt %x, Attached %d\n", 
                i, pDevExt->paStrmExt[i], pDevExt->paStrmExt[i]->cntDataAttached));

            // Signal this event so SRB can complete.
            if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN ) {

                //
                // Imply EOStream! so the data source will stop sending us data.
                //
                KeAcquireSpinLock( pDevExt->paStrmExt[i]->DataListLock, &oldIrql);             
                if(!pDevExt->paStrmExt[i]->bEOStream)
                    pDevExt->paStrmExt[i]->bEOStream = TRUE;
                //
                // Signal EOStream
                //
                StreamClassStreamNotification(
                    SignalMultipleStreamEvents,
                    pDevExt->paStrmExt[i]->pStrmObject,
                    (GUID *)&KSEVENTSETID_Connection_Local,
                    KSEVENT_CONNECTION_ENDOFSTREAM
                    );
                TRACE(TL_PNP_WARNING,("\'Signal KSEVENT_CONNECTION_ENDOFSTREAM\n"));

                KeReleaseSpinLock( pDevExt->paStrmExt[i]->DataListLock, oldIrql); 

                //
                // Make sure that attach frame is either in halt state or terminated to preceed.
                //

                DVSetXmtThreadState(pDevExt->paStrmExt[i], THD_TERMINATE);
            }

            //
            // Abort stream; stop and cancel pending data request
            //
            TRACE(TL_PNP_WARNING,("\'DVSurpriseRemoval: AbortStream enter...\n"));
            if(!DVAbortStream(pDevExt, pDevExt->paStrmExt[i])) {
                TRACE(TL_PNP_ERROR,("\'DVSurpriseRemoval: AbortStream failed\n"));
            }

            //
            // Adter surprise removal, all call to lower stack will be returned
            // with error.  Let's disconnect if it is connected.
            //

            //
            // Disable the timer
            //
            if(pDevExt->paStrmExt[i]->bTimerEnabled) {
                KeCancelTimer(
                    pDevExt->paStrmExt[i]->Timer
                    );
                pDevExt->paStrmExt[i]->bTimerEnabled = FALSE;
            }

            //
            // Wait until the pending work item is completed.  
            //
            TRACE(TL_PNP_WARNING,("\'SupriseRemoval: Wait for CancelDoneEvent <entering>; lCancelStateWorkItem:%d\n", pDevExt->paStrmExt[i]->lCancelStateWorkItem));
            KeWaitForSingleObject( &pDevExt->paStrmExt[i]->hCancelDoneEvent, Executive, KernelMode, FALSE, 0 );
            TRACE(TL_PNP_WARNING,("\'SupriseRemoval: Wait for CancelDoneEvent <exited>...\n"));
        }
    }


    // Signal KSEvent that device is removed.
    // After this SRb, there will be no more Set/Get property Srb into this driver.
    // By notifying the COM I/F, it will wither signal application that device is removed and
    // return ERROR_DEVICE_REMOVED error code for subsequent calls.

    // There might be multiple instances/threads of IAMExtTransport instance with the same KS event.
    // There is only one device so they all enabled event are singalled.
    do {
        if(pEvent = StreamClassGetNextEvent((PVOID) pDevExt, 0, \
            (GUID *)&KSEVENTSETID_EXTDEV_Command, KSEVENT_EXTDEV_NOTIFY_REMOVAL, pEvent)) {            
            // Make sure the right event and then signal it
            if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_NOTIFY_REMOVAL) {
                StreamClassDeviceNotification(SignalDeviceEvent, pDevExt, pEvent);
                TRACE(TL_PNP_WARNING,("\'->Signal NOTIFY_REMOVAL; pEvent:%x, EventId %d.\n", pEvent, pEvent->EventItem->EventId));
            }          
        }  
    } while (pEvent != NULL);

    //
    // Since we may not get the busreset, let's go ahead and cancel all pending device control
    //
    DVAVCCmdResetAfterBusReset(pDevExt);

#ifdef NT51_61883
    //
    // Delete plug; 61883 will not accept 61883 request after surprise removal is processed.
    //
    if(pDevExt->hOPcrPC) {
        // Do not care about return status since we are being unloaded.
        DVDeleteLocalPlug( 
            pDevExt,
            pDevExt->hOPcrPC
            );
        pDevExt->hOPcrPC = NULL;
    }
#endif
   
    TRACE(TL_PNP_WARNING,("\'SurpriseRemoval exiting.\n"));
    return STATUS_SUCCESS;
}


// Return code is basically return in pSrb->Status.
NTSTATUS
DVProcessPnPBusReset(
    PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    Process a bus reset.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/
{   
#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT
    PKSEVENT_ENTRY   pEvent;
#endif

    PAGED_CODE();


    TRACE(TL_PNP_WARNING,("\'DVProcessPnPBusReset: >>\n"));
    
#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT
    //
    // Signal (if enabled) busreset event to let upper layer know that a busreset has occurred.
    //
    pEvent = NULL;
    pEvent = 
        StreamClassGetNextEvent(
            (PVOID) pDevExt,
            0, 
            (GUID *)&KSEVENTSETID_EXTDEV_Command,
            KSEVENT_EXTDEV_COMMAND_BUSRESET,
            pEvent
            );

    if(pEvent) {
        //
        // signal the event here
        //    
        if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_BUSRESET) {
            StreamClassDeviceNotification(
                SignalDeviceEvent,
                pDevExt,
                pEvent
                );        

            TRACE(TL_PNP_WARNING,("\'DVProcessPnPBusReset: Signal BUSRESET; EventId %d.\n", pEvent->EventItem->EventId));
        }
    }
#endif   

    //
    // Reset pending count and AVC command that is in Interim
    //
    DVAVCCmdResetAfterBusReset(pDevExt);


    //
    // Can we return anything other than SUCCESS ?
    //
    return STATUS_SUCCESS;
}   


NTSTATUS
DVUninitializeDevice(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

Arguments:

    Srb - Pointer to stream request block
'
Return Value:

    Nothing

--*/
{
    PAGED_CODE();

    TRACE(TL_PNP_WARNING,("\'DVUnInitialize: enter with DeviceExtension=0x%8x\n", pDevExt));

    //
    // Clear all pending AVC command entries.
    //
    DVAVCCmdResetAfterBusReset(pDevExt);


    // Free stream information allocated
    if(pDevExt->paCurrentStrmInfo) {
        ExFreePool(pDevExt->paCurrentStrmInfo);
        pDevExt->paCurrentStrmInfo = NULL;
    }

#ifdef NT51_61883
    if(pDevExt->hOPcrPC) {
        // Do not care about return status since we are being unloaded.
        DVDeleteLocalPlug( 
            pDevExt,
            pDevExt->hOPcrPC
            );
        pDevExt->hOPcrPC = NULL;
    }
#endif

    TRACE(TL_PNP_WARNING,("\'DVUnInitialize: Rest of allocated resources freed.\n"));

    return STATUS_SUCCESS;
}


//*****************************************************************************
//*****************************************************************************
// S T R E A M    S R B
//*****************************************************************************
//*****************************************************************************


NTSTATUS
DVGetStreamState(
    PSTREAMEX  pStrmExt,
    PKSSTATE   pStreamState,
    PULONG     pulActualBytesTransferred
    )
/*++

Routine Description:

    Gets the current state of the requested stream

--*/
{

    PAGED_CODE();

    if(!pStrmExt) {
        TRACE(TL_STRM_ERROR,("\'GetStreamState: pStrmExt is NULL; STATUS_UNSUCCESSFUL\n"));
        return STATUS_UNSUCCESSFUL;        
    }

    *pStreamState = pStrmExt->StreamState;
    *pulActualBytesTransferred = sizeof (KSSTATE);

    TRACE(TL_STRM_TRACE,("\'GetStreamState: %d (was %d)\n", pStrmExt->StreamState, pStrmExt->StreamStatePrevious));

    if(pStrmExt->StreamState == KSSTATE_PAUSE) {

        // One way to preroll is to delay when querying getting into the PAUSE state.
        // However, this routine is never executed!  So we move this section of code
        // to the thread.
#ifdef SUPPORT_PREROLL_AT_RUN_STATE
        if(   pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN
           && pStrmExt->bPrerollCompleted   == FALSE
           && pStrmExt->StreamStatePrevious == KSSTATE_ACQUIRE  // Preroll only for STOP/ACQUIRE->PAUSE state
          ) {
            // Simulate preroll at the RUN state
            // We do this only when we are the clock provider to avoid dropping frame
#define PREROLL_WAITTIME 2000000
            //
            // Do preroll only if we are the master clock
            //
            if(pStrmExt->hMasterClock) {

                NTSTATUS StatusWait;
                LARGE_INTEGER DueTime;                 
                DueTime = RtlConvertLongToLargeInteger(-((LONG) PREROLL_WAITTIME));

                StatusWait =  // Can only return STATUS_SUCCESS (signal) or STATUS_TIMEOUT
                    KeWaitForSingleObject( 
                        &pStrmExt->hPreRollEvent,
                        Executive,
                        KernelMode,          // Cannot return STATUS_USER_APC
                        FALSE,               // Cannot be alerted STATUS_ALERTED
                        &DueTime);

                TRACE(TL_STRM_WARNING,("\'GetState: *Preroll*, waited %d msec; waitStatus:%x; srbRcved:%d\n", 
                     (DWORD) ((GetSystemTime() - pStrmExt->tmStreamPause)/10000), StatusWait,
                    (DWORD) pStrmExt->cntSRBReceived));
            }

            //
            // Serialize attach, cancel and state change
            //
            KeWaitForSingleObject( pStrmExt->hStreamMutex, Executive, KernelMode, FALSE, 0 );

            // Preroll is completed.
            pStrmExt->bPrerollCompleted = TRUE;                

            //
            // Start the thread when it has at least "sufficient" sample(s) or timed out
            //
            if(pStrmExt->cntSRBReceived >= 1)          // At least one sample!
                KeSetEvent(&pStrmExt->hRunThreadEvent, 0 ,FALSE);

            KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 

        }
#endif
        // A very odd rule:
        // When transitioning from stop to pause (and run->pause), DShow tries to preroll
        // the graph.  Capture sources can't preroll (there is no data until 
        // capture begin/run state), and indicate this by returning 
        // VFW_S_CANT_CUE (Map by KsProxy) in user mode.  To indicate this
        // condition from drivers, they must return ERROR_NO_DATA_DETECTED
        if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT)            
            return STATUS_NO_DATA_DETECTED;        
        else 
            return STATUS_SUCCESS;
    } else 
        return STATUS_SUCCESS;
}

NTSTATUS
DVStreamingStop( 
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq
    )
/*++
Routine Description:

    Transitioning from any state to ->STOP state.
    Stops the video stream and cleans up all the descriptors;
    
++*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    PIRP pIrp;
    KIRQL oldIrql;

    PAGED_CODE();

#ifdef SUPPORT_NEW_AVC
    // No need to do CIP if it is device to device connection
    if(pStrmExt->bDV2DVConnect) {
        if(pStrmExt->bIsochIsActive)
            pStrmExt->bIsochIsActive = FALSE;
        return STATUS_SUCCESS;
    }
#endif

    //
    // Stop isoch listen or talk
    // Note: streaming and stream state can be separate; e.g. SURPRISE_REMOVAL, 
    //       we will stop stream but stream state does note get changed by this SRB.
    //

    if(pStrmExt->bIsochIsActive && pStrmExt->hConnect) {
       
        if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
            return STATUS_INSUFFICIENT_RESOURCES;              

        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        INIT_61883_HEADER(pAVReq, Av61883_Stop);
        pAVReq->Stop.hConnect = pStrmExt->hConnect;

        if(!NT_SUCCESS(
            Status = DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                ))) {

            TRACE(TL_61883_ERROR|TL_STRM_ERROR,("\'Av61883_Stop Failed; Status:%x\n", Status));
#if 1
            KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
            pStrmExt->bIsochIsActive = FALSE;  // Set it.  If this fail, it is a lower stack problem!
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
            ASSERT(NT_SUCCESS(Status) && "Av61883_Stop failed!");
            Status = STATUS_SUCCESS;
#endif
        } else {
            KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
            pStrmExt->bIsochIsActive = FALSE;
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
        }

        IoFreeIrp(pIrp);

        TRACE(TL_STRM_WARNING,("\'StreamingSTOPped; AQD [%d:%d:%d]\n", 
            pStrmExt->cntDataAttached,
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached
            ));
    }

    return Status;
}


NTSTATUS
DVStreamingStart(
    KSPIN_DATAFLOW  ulDataFlow,
    PSTREAMEX       pStrmExt,
    PDVCR_EXTENSION pDevExt
    )
/*++
Routine Description:

    Tell device to start streaming.

++*/
{  
    PIRP         pIrp;
    NTSTATUS     Status;
    PAV_61883_REQUEST  pAVReq;
#if DBG
    ULONGLONG tmStart = GetSystemTime();
#endif


    PAGED_CODE();

#ifdef SUPPORT_NEW_AVC
    // No need to do CIP if it is device to device connection
    if(pStrmExt->bDV2DVConnect) {
        if(!pStrmExt->bIsochIsActive)
            pStrmExt->bIsochIsActive = TRUE;
        return STATUS_SUCCESS;
    }
#endif


    // NOTE: MUTEX is not needed since we are not staring isoch while attaching data.
    // This call is not reentry!!



    // Since it take time to activate isoch transfer, 
    // this synchronous function might get call again.
    // Need to start streaming only once.
    if(InterlockedExchange(&pStrmExt->lStartIsochToken, 1) == 1) {        
        TRACE(TL_STRM_WARNING,("\'lStartIsochToken taken already; return STATUS_SUCCESS\n"));
        return STATUS_SUCCESS;
    } 

#if DBG
    // Can stream only if in power on state.
    if(pDevExt->PowerState != PowerDeviceD0) {
        TRACE(TL_STRM_ERROR,("\'StreamingStart: PowerSt:%d; StrmSt:%d\n", pDevExt->PowerState, pStrmExt->StreamState));
        ASSERT(pDevExt->PowerState == PowerDeviceD0 && "Power state must be ON to start streaming!");
    }
#endif

    if(pStrmExt->bIsochIsActive) {
        TRACE(TL_STRM_WARNING,("\nIsoch already active!\n"));
        InterlockedExchange(&pStrmExt->lStartIsochToken, 0);
        return STATUS_SUCCESS;
    }
    else 
    if(!pStrmExt->hConnect) {
        TRACE(TL_STRM_WARNING,("hConnect=0, Cannot start isoch!\n"));
        InterlockedExchange(&pStrmExt->lStartIsochToken, 0);
        return STATUS_INVALID_PARAMETER;
    }
    else {
       
        if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) {
            InterlockedExchange(&pStrmExt->lStartIsochToken, 0);
            return STATUS_INSUFFICIENT_RESOURCES;            
        }

        if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE))) {
            InterlockedExchange(&pStrmExt->lStartIsochToken, 0);
            ExFreePool(pAVReq);  pAVReq = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        if(ulDataFlow == KSPIN_DATAFLOW_OUT) {
            INIT_61883_HEADER(pAVReq, Av61883_Listen);
            pAVReq->Listen.hConnect = pStrmExt->hConnect;
        } else {
            INIT_61883_HEADER(pAVReq, Av61883_Talk);
            pAVReq->Talk.hConnect = pStrmExt->hConnect;
        }

        TRACE(TL_STRM_WARNING,("\'StreamingSTART; flow %d; AQD [%d:%d:%d]\n", 
            ulDataFlow, 
            pStrmExt->cntDataAttached,
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached
            ));

        if(NT_SUCCESS(
            Status = DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                ))) {
            pStrmExt->bIsochIsActive = TRUE;
            TRACE(TL_STRM_WARNING,("\'Av61883_%s; Status %x; Streaming...; took:%d (msec)\n", 
                (ulDataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status, 
                (DWORD) ((GetSystemTime() - tmStart)/10000) ));
        }
        else {
            TRACE(TL_61883_ERROR|TL_STRM_ERROR,("Av61883_%s; failed %x; pAVReq:%x\n", (ulDataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status, pAVReq));
            // ASSERT(NT_SUCCESS(Status) && "Start isoch failed!");
        }

        ExFreePool(pAVReq);  pAVReq = NULL;
        IoFreeIrp(pIrp);  pIrp = NULL;
    }

    InterlockedExchange(&pStrmExt->lStartIsochToken, 0);

    return Status;
}



NTSTATUS
DVSetStreamState(
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq,
    KSSTATE          StreamState
    )
/*++

Routine Description:

    Set to a new stream state.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    
    PAGED_CODE();

    if(!pStrmExt)  
        return STATUS_UNSUCCESSFUL;          

    TRACE(TL_STRM_WARNING,("\'** (%x) Set StrmST from %d to %d; PowerSt:%d (1/On;4/Off]); SrbRcved:%d\n",
        pStrmExt, pStrmExt->StreamState, StreamState, pDevExt->PowerState, (DWORD) pStrmExt->cntSRBReceived ));

#if DBG
    if(StreamState == KSSTATE_RUN) {
        ASSERT(pDevExt->PowerState == PowerDeviceD0 && "Cannot set to RUN while power is off!");
    }
#endif
    switch(StreamState) {

    case KSSTATE_STOP:
      
        if(pStrmExt->StreamState != KSSTATE_STOP) { 
     
            KeWaitForSingleObject( pStrmExt->hStreamMutex, Executive, KernelMode, FALSE, 0 );

            //
            // Cancel request (DISPATCH level) may come before setting to STOP state.
            //
            // Once this is set, data stream will reject SRB_WRITE/READ_DATA
            pStrmExt->StreamStatePrevious = pStrmExt->StreamState;  // Cache previous stream state.
            pStrmExt->StreamState = KSSTATE_STOP;

            // If stop, must be EOStream; but not vice versa.
            if(!pStrmExt->bEOStream) {
                pStrmExt->bEOStream = TRUE;
            }

            KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 

            //
            // If there is a cancel event, we must wait for it to complete.
            //

            TRACE(TL_STRM_WARNING,("\'KSSTATE_STOP: pStrmExt->lCancelStateWorkItem:%d\n", pStrmExt->lCancelStateWorkItem)); 
            KeWaitForSingleObject( &pStrmExt->hCancelDoneEvent, Executive, KernelMode, FALSE, 0 );
            ASSERT(pStrmExt->lCancelStateWorkItem == 0 && "KSSTATE_STOP while there is an active CancelStateWorkItem");
            
            //
            // Stop stream, cacel data requests, terminate thread and disconnect.
            // This routine must suceeded in setting to STOP state
            //
            if(!NT_SUCCESS(
                Status = DVStopCancelDisconnect(
                    pStrmExt
                    ))) {
                Status = STATUS_SUCCESS;  // Cannot fail setting to stop state.
            }

            //
            // Set (TRUE) on the 1st time SetEvent on hRunThreadEvent.
            //

            pStrmExt->bXmtThreadStarted = FALSE; 
#ifdef SUPPORT_PREROLL_AT_RUN_STATE                
            pStrmExt->bPrerollCompleted = FALSE;  // Reset for next preroll
#endif
            
        }

        break;

    case KSSTATE_ACQUIRE:
        //
        // This is a KS only state, that has no correspondence in DirectShow
        // It is our opportunity to allcoate resoruce (isoch bandwidth and program PCR (make connection)).
        //

        if(pStrmExt->StreamState == KSSTATE_STOP) { 

            //
            // Create a dispatch thread to attach frame to transmit to DV
            // This is create the first time transitioning from STOP->ACQUIRE state
            //

            if(
                  KSPIN_DATAFLOW_IN == pStrmExt->pStrmInfo->DataFlow
               && pStrmExt->pAttachFrameThreadObject == NULL 
              ) {

                //
                // Create a system thread for attaching data (for transmit to DV only).
                //
                if(!NT_SUCCESS(
                    Status = DVCreateAttachFrameThread(
                        pStrmExt
                        ))) {
                    // Note that intially hConnect is NULL.
                    break;  // Cannot attach frame without this thread.
                }
            }

            //
            // Make connection
            //
            Status = 
                DVConnect(
                    pStrmExt->pStrmInfo->DataFlow,
                    pDevExt,
                    pStrmExt,
                    pAVReq
                    );

            if(!NT_SUCCESS(Status)) {

                TRACE(TL_STRM_ERROR,("\'Acquire failed; ST %x\n", Status));

                //
                // Change to generic insufficient resource status.
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // Note: even setting to this state failed, KSSTATE_PAUSE will still be called;
                // Since hConnect is NULL, STATUS_INSUFFICIENT_RESOURCES will be returned.
                //
            } else {

                //
                // Verify connection by query the plug state
                //            
                DVGetPlugState(
                    pDevExt,
                    pStrmExt,
                    pAVReq
                    );
            }
        }

        break;

    case KSSTATE_PAUSE:                   

           
        if(pStrmExt->StreamState == KSSTATE_ACQUIRE || 
           pStrmExt->StreamState == KSSTATE_STOP)   {  

#ifdef SUPPORT_NEW_AVC
            if(!pStrmExt->bDV2DVConnect && pStrmExt->hConnect == NULL) {
#else
            if(pStrmExt->hConnect == NULL) {
#endif
                TRACE(TL_STRM_ERROR,("\'hConnect is NULL; STATUS_INSUFFICIENT_RESOURCES\n"));
                // Cannot stream without connection!
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // Reset when transition from STOP to PAUSE state
            //

            // The system time (1394 CycleTime) will continue while setting
            // from RUN to PAUSE state.  
            pStrmExt->b1stNewFrameFromPauseState = TRUE;

#ifdef SUPPORT_QUALITY_CONTROL
            // +: late; -: early
            pStrmExt->KSQuality.DeltaTime = 0; // On time
            // Percentage * 10 of frame transmitted
            pStrmExt->KSQuality.Proportion = 1000;  // 100% sent
            pStrmExt->KSQuality.Context = /* NOT USED */ 0; 
#endif

            pStrmExt->CurrentStreamTime = 0;

            pStrmExt->FramesProcessed = 0;
            pStrmExt->PictureNumber   = 0;
            pStrmExt->FramesDropped   = 0;

            pStrmExt->cntSRBReceived  = 0;
            pStrmExt->cntSRBCancelled = 0;  // number of SRB_READ/WRITE_DATA cancelled
            pStrmExt->bEOStream       = FALSE;
#if DBG
            //
            // Initialize the debug log structure.
            //
            if(pStrmExt->paXmtStat) {
                pStrmExt->ulStatEntries   = 0;
                pStrmExt->lFramesAccumulatedPaused = 0;
                pStrmExt->lFramesAccumulatedRun    = 0;
                RtlZeroMemory(pStrmExt->paXmtStat, sizeof(XMT_FRAME_STAT) * MAX_XMT_FRAMES_TRACED);
            }
#endif

            //
            // Reset this event in case graph is restarted.
            // This evant will wait for enough buffers before start attaching frame for transmit
            //
            if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {

#ifdef SUPPORT_PREROLL_AT_RUN_STATE                
                KeClearEvent(&pStrmExt->hPreRollEvent);
#if DBG
                pStrmExt->tmStreamPause = GetSystemTime();
#endif
#ifdef SUPPORT_KSPROXY_PREROLL_CHANGE
                pStrmExt->StreamStatePrevious = pStrmExt->StreamState;  // Cache previous stream state.
                pStrmExt->StreamState = StreamState;
#ifdef SUPPORT_NEW_AVC
                if(pStrmExt->bDV2DVConnect)
                    return STATUS_SUCCESS;
                else {
#endif  // SUPPORT_NEW_AVC
                    TRACE(TL_STRM_WARNING,("\'Set to KSSTATE_PAUSE; return STATUS_ALERTED\n"));
                    // We want to preroll.
                    return STATUS_ALERTED; 
#ifdef SUPPORT_NEW_AVC
                }
#endif  // SUPPORT_NEW_AVC
#endif  // SUPPORT_KSPROXY_PREROLL_CHANGE
#endif  // SUPPORT_PREROLL_AT_RUN_STATE
            }

        } else if (pStrmExt->StreamState == KSSTATE_RUN) {

            // The system time (1394 CycleTime) will continue while setting
            // from RUN to PAUSE state.  
            pStrmExt->b1stNewFrameFromPauseState = TRUE;

            //
            // Stop only if listening; for talking, the "pause" frame will be repeated
            //
            if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT) {               
                // stop the stream internally inside 1394 stack
                DVStreamingStop(
                    pStrmExt,
                    pDevExt,
                    pAVReq
                    );
            } else {
                // Talk will continue.
                //    Do not stop isoch talk until stop state.
            }

            //
            // StreamTime pauses, so pause checking for expired clock events.
            // Resume if we enter RUN state again.
            //
            if(pStrmExt->bTimerEnabled) {
                TRACE(TL_STRM_TRACE,("\'*** (RUN->PAUSE) CancelTimer *********************************************...\n"));               
                KeCancelTimer(
                    pStrmExt->Timer
                    );
                pStrmExt->bTimerEnabled = FALSE;

                //
                // Complete any pending clock events
                //
                DVSignalClockEvent(0, pStrmExt, 0, 0);
            }
        }
        break;
                    
    case KSSTATE_RUN:

        if(pStrmExt->StreamState != KSSTATE_RUN) { 

            TRACE(TL_STRM_WARNING,("\'*RUN: hClock %x; hMasterClk %x; cntAttached:%d; StrmTm:%d\n", pStrmExt->hClock, pStrmExt->hMasterClock, pStrmExt->cntDataAttached, (DWORD) (pStrmExt->CurrentStreamTime/10000) ));

#ifdef SUPPORT_KSPROXY_PREROLL_CHANGE
            KeWaitForSingleObject( pStrmExt->hStreamMutex, Executive, KernelMode, FALSE, 0 );
            // Preroll is completed when entering RUN state for sure.
            pStrmExt->bPrerollCompleted = TRUE;
            KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 
#endif

#if DBG
            if(!pStrmExt->hMasterClock && !pStrmExt->hClock)
                TRACE(TL_STRM_WARNING,("\'KSSTATE_RUN: no clock so free flowing!\n"));
#endif            

            // Use to mark the tick count when the stream start running.
            // It is later used to calculate current stream time and dropped frames.
            pStrmExt->tmStreamStart = GetSystemTime();
            pStrmExt->LastSystemTime = pStrmExt->tmStreamStart;


            // We start the timer to signal clock event only if we are the clock provider.
            // The interval is set to half of a DV frame time.
            if(pStrmExt->hMasterClock) {
                LARGE_INTEGER DueTime;

                DueTime = RtlConvertLongToLargeInteger(-((LONG) DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame/2));
                TRACE(TL_STRM_WARNING,("\'*** ScheduleTimer (RUN) ***\n"));
                KeSetTimerEx(
                    pStrmExt->Timer,
                    DueTime,
                    DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame/20000,  // Repeat every 40 MilliSecond
                    pStrmExt->DPCTimer
                    );
                pStrmExt->bTimerEnabled = TRUE;
            }

            if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT) {

                // Start isoch listen; isoch talk will be start in the dispatch thread in either PAUSE or RUN state.
                // VfW application may use only one buffer!  61883 is attaching the descriptor list 
                // not this subunit driver so so it is ok to start streaming immediately without checking 
                // number of buffers attached.
                Status = 
                    DVStreamingStart(
                        pStrmExt->pStrmInfo->DataFlow,
                        pStrmExt,
                        pDevExt
                        );         
            }
#ifdef SUPPORT_PREROLL_AT_RUN_STATE
            else {  // KSPIN_DATAFLOW_IN
               //
               // This is a special condition (with PREROLL):
               //     1. timeout on preroll (and is now in the RUN state), and
               //     2. no media sample
               // This will cause attach frame in the HALT state; so we will signal
               // it upon receiving 1st media sample; then attach frame can run.
               //
               if(   pStrmExt->cntSRBReceived    >= 1
                  && pStrmExt->bXmtThreadStarted == FALSE)
               {
                   KeSetEvent(&pStrmExt->hRunThreadEvent, 0 ,FALSE);
                   TRACE(TL_STRM_WARNING, ("Special Cond: HALT state, ->RUN state with some sample(s)."));
               }
           }
#endif
        }

        break;
                    
    default:
                    
        TRACE(TL_STRM_ERROR,("\'SetStreamState:  unknown state = %x\n",StreamState));
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    // Be sure to save the state of the stream.
    TRACE(TL_STRM_WARNING,("\'DVSetStreamState: (%x)  from %d -> %d, Status %x\n", pStrmExt, pStrmExt->StreamState, StreamState, Status));

    if(Status == STATUS_SUCCESS) {
        pStrmExt->StreamStatePrevious = pStrmExt->StreamState;  // Cache previous stream state.
        pStrmExt->StreamState = StreamState;
    }

    return Status;
}



NTSTATUS 
DVStreamGetConnectionProperty (
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handles KS_PROPERTY_CONNECTION* request.  For now, only ALLOCATORFRAMING and
    CONNECTION_STATE are supported.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    TRACE(TL_STRM_TRACE,("\'DVStreamGetConnectionProperty:  entered ...\n"));

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        if (pDevExt != NULL && pDevExt->cndStrmOpen)  {
            PKSALLOCATOR_FRAMING pFraming = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            
#ifdef SUPPORT_NEW_AVC 
            if(pStrmExt->bDV2DVConnect) {
                // No framing required.
                pFraming->RequirementsFlags = 0;
                pFraming->PoolType = DontUseThisType;
                pFraming->Frames = 0;
                pFraming->FrameSize = 0;
                pFraming->FileAlignment = 0; 
                pFraming->Reserved = 0;
            } else {
#endif
            pFraming->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            pFraming->PoolType = NonPagedPool;

            pFraming->Frames = \
                (pDevExt->paStrmExt[pDevExt->idxStreamNumber]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT ? \
                DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfRcvBuffers : \
                 DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfXmtBuffers);

            // Note:  we'll allocate the biggest frame.  We need to make sure when we're
            // passing the frame back up we also set the number of bytes in the frame.
            pFraming->FrameSize = DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize;
            pFraming->FileAlignment = 0; // FILE_LONG_ALIGNMENT;
            pFraming->Reserved = 0;
#ifdef SUPPORT_NEW_AVC 
            }
#endif
            *pulActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);

            TRACE(TL_STRM_TRACE,("\'AllocFraming: cntStrmOpen:%d; VdoFmtIdx:%d; Frames %d; size:%d\n", \
                pDevExt->cndStrmOpen, pDevExt->VideoFormatIndex, pFraming->Frames, pFraming->FrameSize));
        } else {
            TRACE(TL_STRM_WARNING,("\'AllocFraming: pDevExt:%x; cntStrmOpen:%d\n", pDevExt, pDevExt->cndStrmOpen));
            Status = STATUS_INVALID_PARAMETER;
        }
        break;
        
    default:
        *pulActualBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    TRACE(TL_STRM_TRACE,("\'DVStreamGetConnectionProperty:  exit.\n"));
    return Status;
}


NTSTATUS
DVGetDroppedFramesProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    )
/*++

Routine Description:

    Return the dropped frame information while captureing.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
  
    PAGED_CODE();

    switch (pSPD->Property->Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
         {

         PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
                     (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;
         
         pDroppedFrames->AverageFrameSize = DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulFrameSize;

         if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {     
             // This is the picture number that MSDV is actually sending, and in a slow harddisk case,
             // it will be greater than (FramesProcessed + FramesDropped) considering repeat frame.
             pDroppedFrames->PictureNumber = pStrmExt->PictureNumber;
             pDroppedFrames->DropCount     = pStrmExt->FramesDropped; // pStrmExt->PictureNumber - pStrmExt->FramesProcessed;    // For transmit, this value includes both dropped and repeated.

         } else {
             pDroppedFrames->PictureNumber = pStrmExt->PictureNumber;         
             pDroppedFrames->DropCount     = pStrmExt->FramesDropped;    // For transmit, this value includes both dropped and repeated.
         }

         TRACE(TL_STRM_TRACE,("\'hMasClk:%x; *DroppedFP: Pic#(%d), Drp(%d); tmCurStream:%d\n", 
             pStrmExt->hMasterClock, 
             (LONG) pDroppedFrames->PictureNumber, (LONG) pDroppedFrames->DropCount,
             (DWORD) (pStrmExt->CurrentStreamTime/10000)
             ));
               
         *pulBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
         Status = STATUS_SUCCESS;

         }
         break;

    default:
        *pulBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    return Status;
}

#ifdef SUPPORT_QUALITY_CONTROL
NTSTATUS
DVGetQualityControlProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    )
/*++

Routine Description:

    Return the dropped frame information while captureing.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
  
    PAGED_CODE();

    switch (pSPD->Property->Id) {

    case KSPROPERTY_STREAM_QUALITY:
        if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {     

            PKSQUALITY pKSQuality = (PKSQUALITY) pSPD->PropertyInfo;

            // Quality control only 
            if(pStrmExt->StreamState == KSSTATE_STOP || pStrmExt->StreamState == KSSTATE_ACQUIRE) {
                *pulBytesTransferred = 0;
                Status = STATUS_UNSUCCESSFUL;  // Data is not ready
                ASSERT(pSPD->Property->Id == KSPROPERTY_STREAM_QUALITY);
                break;                
            }
            /*
            log.Init_Quality(KSPROPERTY_QUALITY_REPORT, fSuccess);
            log.LogInt("Proportion", ksQuality.Proportion,
                "Indicates the percentage of frames currently being received which are actually being used. "
                " This is expressed in units of 0.1 of a percent, where 1000 is optimal.");
            log.LogLONGLONG("DeltaTime", ksQuality.DeltaTime,
                "Indicates the delta in native units (as indicated by the Interface) from optimal time at which "
                "the frames are being delivered, where a positive number means too late, and a negative number means too early. "
                "Zero indicate a correct delta.");
            log.LogPVOID("pvContext", ksQuality.Context,
                "Context parameter which could be a pointer to the filter pin interface used to "
                "locate the source of the complaint in the graph topology.");
            */
            pKSQuality->DeltaTime  = pStrmExt->KSQuality.DeltaTime;
            pKSQuality->Proportion = pStrmExt->KSQuality.Proportion;
            pKSQuality->Context    = 0;  // Not used!
            TRACE(TL_STRM_WARNING,("\'Get QualityControl: Context:%x; DeltaTime:%d; Proportion:%d\n", 
                pKSQuality->Context, (DWORD) pKSQuality->DeltaTime, pKSQuality->Proportion));
            Status = STATUS_SUCCESS;
            *pulBytesTransferred = sizeof(KSQUALITY);
         
         } else {
            *pulBytesTransferred = 0;
            Status = STATUS_NOT_SUPPORTED;       
         }
         break;
    default:
        *pulBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    return Status;
}
#endif // SUPPORT_QUALITY_CONTROL


#ifdef SUPPORT_NEW_AVC
NTSTATUS
DVGetPinProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    )
/*++

Routine Description:

    Return the dropped frame information while captureing.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPIN_MEDIUM pPinMediums;
    KSMULTIPLE_ITEM * pMultipleItem;
    ULONG idxStreamNumber;
    ULONG ulMediumsSize;
  
    PAGED_CODE();

    switch (pSPD->Property->Id) {

    case KSPROPERTY_PIN_MEDIUMS:
        if(!pStrmExt->pStrmObject) {         
            *pulBytesTransferred = 0;
            return STATUS_UNSUCCESSFUL;
        }

        idxStreamNumber = pStrmExt->pStrmObject->StreamNumber;
        ulMediumsSize = DVStreams[idxStreamNumber].hwStreamInfo.MediumsCount * sizeof(KSPIN_MEDIUM);

        TRACE(TL_STRM_WARNING,("\'KSPROPERTY_PIN_MEDIUMS: idx:%d; MediumSize:%d\n", idxStreamNumber, ulMediumsSize));

        // Its is KSMULTIPLE_ITEM so it is a two step process to return the data:
        // (1) return size in pActualBytesTransferred with STATUS_BUFFER_OVERFLOW
        // (2) 2nd time to get its actual data.
        if(pSPD->PropertyOutputSize == 0) {
            *pulBytesTransferred = sizeof(KSMULTIPLE_ITEM) + ulMediumsSize;
            Status = STATUS_BUFFER_OVERFLOW;          
        } else if(pSPD->PropertyOutputSize >= (sizeof(KSMULTIPLE_ITEM) + ulMediumsSize)) {
            pMultipleItem = (KSMULTIPLE_ITEM *) pSPD->PropertyInfo;    // pointer to the data
            pMultipleItem->Count = DVStreams[idxStreamNumber].hwStreamInfo.MediumsCount;
            pMultipleItem->Size  = sizeof(KSMULTIPLE_ITEM) + ulMediumsSize;
            pPinMediums = (PKSPIN_MEDIUM) (pMultipleItem + 1);    // pointer to the data
            memcpy(pPinMediums, DVStreams[idxStreamNumber].hwStreamInfo.Mediums, ulMediumsSize);
            *pulBytesTransferred = sizeof(KSMULTIPLE_ITEM) + ulMediumsSize;
            Status = STATUS_SUCCESS;         

        } else {
            TRACE(TL_STRM_ERROR,("DVCRMediaSeekingProperty: KSPROPERTY_MEDIASEEKING_FORMAT; STATUS_INVALID_PARAMETER\n"));
            Status = STATUS_INVALID_PARAMETER;
        }  
        break;

    default:
        *pulBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    return Status;
}
#endif 

NTSTATUS
DVGetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Routine to process property request

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PAGED_CODE();

    TRACE(TL_STRM_TRACE,("\'DVGetStreamProperty:  entered ...\n"));

    if(IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {

        Status = 
            DVStreamGetConnectionProperty (
                pSrb->HwDeviceExtension,
                (PSTREAMEX) pSrb->StreamObject->HwStreamExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {

        Status = 
            DVGetDroppedFramesProperty (
                pSrb->HwDeviceExtension,
                (PSTREAMEX) pSrb->StreamObject->HwStreamExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
#ifdef SUPPORT_QUALITY_CONTROL
    else if (IsEqualGUID (&KSPROPSETID_Stream, &pSPD->Property->Set)) {

        Status = 
            DVGetQualityControlProperty (
                pSrb->HwDeviceExtension,
                (PSTREAMEX) pSrb->StreamObject->HwStreamExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
#endif
#ifdef SUPPORT_NEW_AVC
    else if (IsEqualGUID (&KSPROPSETID_Pin, &pSPD->Property->Set)) {

        Status = 
            DVGetPinProperty (
                pSrb->HwDeviceExtension,
                (PSTREAMEX) pSrb->StreamObject->HwStreamExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
#endif    
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}


NTSTATUS 
DVSetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Routine to process set property request

--*/

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PAGED_CODE();

    TRACE(TL_STRM_WARNING,("\'DVSetStreamProperty:  entered ...\n"));

    return STATUS_NOT_SUPPORTED;

}



NTSTATUS
DVCancelOnePacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PSRB_DATA_PACKET pSrbDataPacket    
    )
/*++

Routine Description:

    Completion routine for detach an isoch descriptor associate with a pending read SRB.
    Will cancel the pending SRB here if detaching descriptor has suceeded.

--*/
{
    PSTREAMEX        pStrmExt;
    PLONG            plSrbUseCount;
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel;
    KIRQL oldIrql;



    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        TRACE(TL_STRM_ERROR,("CancelOnePacketCR: Srb:%x failed pIrp->Status %x\n", pSrbDataPacket->pSrb, pIrp->IoStatus.Status));
        IoFreeIrp(pIrp);  // Allocated locally 
        return STATUS_MORE_PROCESSING_REQUIRED;        
    }


    pStrmExt = pSrbDataPacket->pStrmExt;


    //
    // Add this to the attached list
    //
    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

    // while it is being cancelled, it was completed ?
    if(pStrmExt->cntDataAttached <= 0) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'DVCancelOnePacketCR:pStrmExt:%x, pSrbDataPacket:%x, AQD[%d:%d:%d]\n", \
            pStrmExt, pSrbDataPacket, 
            pStrmExt->cntDataAttached,
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached
            ));
        ASSERT(pStrmExt->cntDataAttached > 0);
        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 
        IoFreeIrp(pIrp);  // Allocated locally        
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pSrbToCancel = pSrbDataPacket->pSrb;  // Offload pSrb so this list entry can be inserted to available list.
    plSrbUseCount = (PLONG) pSrbDataPacket->pSrb->SRBExtension;
  
    // Remove from attached and add it to the detach list
    RemoveEntryList(&pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached--; (*plSrbUseCount)--;

#if DBG
    // Detect if 61883 is starve.  This cause discontinuity.
    // This can happen for many valid reasons (slow system).
    // An assert is added to detect other unknown reason.
    if(pStrmExt->cntDataAttached == 0 && pStrmExt->StreamState == KSSTATE_RUN) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\n**** 61883 starve in RUN state (cancel); AQD[%d:%d:%d]\n\n", 
            pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
        ));
        // ASSERT(pStrmExt->cntDataAttached > 0 && "61883 is starve at RUN state!!");
    }
#endif

    ASSERT(pStrmExt->cntDataAttached >= 0);
    ASSERT(*plSrbUseCount >= 0);
    
    InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;
    pSrbDataPacket->State |= DE_IRP_CANCELLED;


    // 
    // Complete this Srb if its refCount is 0.
    // 
    if(*plSrbUseCount == 0) {
        PDVCR_EXTENSION  pDevExt;

        pDevExt = pStrmExt->pDevExt;
        pSrbToCancel->Status = (pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED);
        pSrbToCancel->CommandData.DataBufferArray->DataUsed = 0;
        pSrbToCancel->ActualBytesTransferred                = 0;
        pStrmExt->cntSRBCancelled++;  // RefCnt is 0, and cancelled.
        TRACE(TL_CIP_TRACE,("\'DVCancelOnePacketCR: Srb:%x cancelled; St:%x; cntCancel:%d\n", pSrbToCancel, pSrbToCancel->Status, pStrmExt->cntSRBCancelled));        

        StreamClassStreamNotification(StreamRequestComplete, pSrbToCancel->StreamObject, pSrbToCancel);  
        pSrbDataPacket->State |= DE_IRP_SRB_COMPLETED;  pSrbDataPacket->pSrb = NULL;
#if DBG
        pStrmExt->cntSRBPending--;
#endif
       
    }
    else {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'DVCancelOnePacketCR: Srb:%x; RefCnt:%d; not completed!\n", pSrbDataPacket->pSrb, *plSrbUseCount));
    }

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
    IoFreeIrp(pIrp);  // Allocated locally 

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
DVStopCancelDisconnect(
    PSTREAMEX  pStrmExt
)
/*++

Routine Description:

   Stop a stream, cacel all pening data requests, terminate system thread, and disconnect.

--*/
{
    AV_61883_REQUEST * pAVReq;
    
    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)) )) 
        return STATUS_INSUFFICIENT_RESOURCES;              


    //
    // Halt attach transmit frame thread so we can safely cancel packets.
    //
    if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {

        //
        // Make sure that attach frame is either in halt state or terminated to preceed.
        //

        DVSetXmtThreadState(pStrmExt, THD_HALT);
    }


    //
    // Set stream state and the work item thread can both call this routine.
    // Use a mutex to synchronize them.
    //
    KeWaitForSingleObject( pStrmExt->hStreamMutex, Executive, KernelMode, FALSE, 0 );


    //
    // Stop the 1394 isoch data transfer; Stream state is unchanged.
    //
    DVStreamingStop(
        pStrmExt,
        pStrmExt->pDevExt,
        pAVReq
        );

    ExFreePool(pAVReq);  pAVReq = NULL;

    //
    // Cancel all packets
    //
    DVCancelAllPackets(
        pStrmExt,
        pStrmExt->pDevExt
        );

    //
    // If the device is removed, terminate the system thread for attach frame.
    // 
    if(   pStrmExt->pDevExt->bDevRemoved
       && KSPIN_DATAFLOW_IN == pStrmExt->pStrmInfo->DataFlow
       && !pStrmExt->bTerminateThread
       && pStrmExt->pAttachFrameThreadObject
      ) {
        DVTerminateAttachFrameThread(pStrmExt);
        pStrmExt->pAttachFrameThreadObject = NULL;
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("** DVStopCancelDisconnect: AttachFrameThread terminated;\n"));
    }


    //
    // Break the connection so 61883 will free isoch resource   
    //
    // Disconnect only if there is no more pending buffer attached.
    // This is required since hConnect is required to perform buffer operation, including cancel.
    //
    if(pStrmExt->cntDataAttached == 0) {
        DVDisconnect(
            pStrmExt->pStrmInfo->DataFlow,
            pStrmExt->pDevExt,
            pStrmExt
            );
    } else {
        TRACE(TL_STRM_ERROR,("Cannot disconnect while there are pending data! pStrmExt:%x\n", pStrmExt));        
        ASSERT(pStrmExt->cntDataAttached == 0 && "Cannot disconnect while pending data.");
    }

    
    KeReleaseMutex(pStrmExt->hStreamMutex, FALSE);

    return STATUS_SUCCESS;
}


void
DVCancelSrbWorkItemRoutine(
#ifdef USE_WDM110  // Win2000 code base
    // Extra parameter if using WDM10
    PDEVICE_OBJECT DeviceObject,
#endif
    PSTREAMEX  pStrmExt
    )
/*++

Routine Description:

   This work item routine will stop streaming and cancel all SRBs.   

--*/
{
    NTSTATUS Status;


    PAGED_CODE();

    TRACE(TL_STRM_WARNING,("\'CancelWorkItem: StreamState:%d; lCancel:%d\n", 
        pStrmExt->StreamState, pStrmExt->lCancelStateWorkItem));

    ASSERT(pStrmExt->lCancelStateWorkItem == 1);
#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pStrmExt->pIoWorkItem);
#endif

   
    //
    // Stop the stream and cancel all pending requests.
    //
    Status = DVStopCancelDisconnect(pStrmExt);

    //
    // Canceling is in theory done!
    //
    InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 0); 
    KeSetEvent(&pStrmExt->hCancelDoneEvent, 0, FALSE);  pStrmExt->bAbortPending = FALSE;


    if(!NT_SUCCESS(Status)) {
        TRACE(TL_STRM_ERROR,("Workitem: DVStopCancelDisconnect Failed\n"));
        // Terminate work item but does not terminate this thread due to failure.
        goto DVAbortWorkItemRoutine;           
    } 


    // If the device is removed, terminate the system thread that is used 
    // for attaching frame for transmit to DV
    if(   pStrmExt->pDevExt->bDevRemoved
       && KSPIN_DATAFLOW_IN == pStrmExt->pStrmInfo->DataFlow
       && !pStrmExt->bTerminateThread
       && pStrmExt->pAttachFrameThreadObject
      ) {

        DVTerminateAttachFrameThread(pStrmExt);
        pStrmExt->pAttachFrameThreadObject = NULL;
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("** WortItemRoutine: thread terminated;\n"));
    }

DVAbortWorkItemRoutine:
;
#ifdef USE_WDM110  // Win2000 code base
    // Release work item and release the cancel token
    IoFreeWorkItem(pStrmExt->pIoWorkItem);  pStrmExt->pIoWorkItem = NULL; 
#endif
}


BOOL
DVAbortStream(
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX pStrmExt
    )
/*++

Routine Description:

   Start a work item to abort streaming.

--*/
{
    KIRQL OldIrql;


    //
    // Claim this token; only one abort streaming per STOP->PAUSE transition.
    //
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql); 
    if(pStrmExt->lCancelStateWorkItem == 1) {
        TRACE(TL_STRM_TRACE,("\'Cancel work item is already issued.\n"));
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
        return FALSE;
    } 

    if(pStrmExt->StreamState == KSSTATE_STOP) {
        TRACE(TL_STRM_ERROR,("Already in KSSTATE_STOP state, no cancel work item!\n"));
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
        return FALSE;
    } 

    //
    // Non-signal this event so other thread depending on the completion will wait.
    //
    pStrmExt->lCancelStateWorkItem = 1;  
    KeClearEvent(&pStrmExt->hCancelDoneEvent);  pStrmExt->bAbortPending = TRUE;

    TRACE(TL_STRM_WARNING,("\'DVAbortStream is issued; lCancelStateWorkItem:%d\n", pStrmExt->lCancelStateWorkItem));

    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

    //
    // If we are not running at DISPATFCH level or higher, we abort the stream without scheduleing
    // a work item; else schedule a work item is necessary.
    //
    if (KeGetCurrentIrql() <= APC_LEVEL) { 
        DVStopCancelDisconnect(pStrmExt);
        InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 0); 
        KeSetEvent(&pStrmExt->hCancelDoneEvent, 0, FALSE);   pStrmExt->bAbortPending = FALSE;
        return TRUE;
    }


#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pStrmExt->pIoWorkItem == NULL);  // Have not yet queued work item.

    // We will queue work item to stop and cancel all SRBs
    if(pStrmExt->pIoWorkItem = IoAllocateWorkItem(pDevExt->pBusDeviceObject)) { 

        IoQueueWorkItem(
            pStrmExt->pIoWorkItem,
            DVCancelSrbWorkItemRoutine,
            DelayedWorkQueue, // CriticalWorkQueue 
            pStrmExt
            );

#else  // Win9x code base
    ExInitializeWorkItem( &pStrmExt->IoWorkItem, DVCancelSrbWorkItemRoutine, pStrmExt);
    if(TRUE) {

        ExQueueWorkItem( 
            &pStrmExt->IoWorkItem,
            DelayedWorkQueue // CriticalWorkQueue 
            ); 
#endif

        TRACE(TL_STRM_WARNING,("\'CancelWorkItm queued; SrbRcv:%d;Pic#:%d;Prc:%d;;Drop:%d;Cncl:%d; AQD [%d:%d:%d]\n",
            (DWORD) pStrmExt->cntSRBReceived,
            (DWORD) pStrmExt->PictureNumber,
            (DWORD) pStrmExt->FramesProcessed, 
            (DWORD) pStrmExt->FramesDropped,
            (DWORD) pStrmExt->cntSRBCancelled,
            pStrmExt->cntDataAttached,
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached
            ));

    } 
#ifdef USE_WDM110  // Win2000 code base
    else {
        InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 0); 
        KeSetEvent(&pStrmExt->hCancelDoneEvent, 0, FALSE);   pStrmExt->bAbortPending = FALSE;
        ASSERT(pStrmExt->pIoWorkItem && "IoAllocateWorkItem failed.\n");
        return FALSE;
    }
#endif

    return TRUE;
}


VOID
DVCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
/*++

Routine Description:

   Search pending read lists for the SRB to be cancel.  If found cancel it.   

--*/
{
    PDVCR_EXTENSION pDevExt;
    PSTREAMEX pStrmExt;
    KIRQL OldIrql;


                                                                                                              
    pDevExt = (PDVCR_EXTENSION) pSrbToCancel->HwDeviceExtension; 
               
    // Cannot cancel device Srb.
    if ((pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        TRACE(TL_CIP_ERROR|TL_STRM_ERROR,("\'DVCancelOnePacket: Device SRB %x; cannot cancel!\n", pSrbToCancel));
        ASSERT((pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) == SRB_HW_FLAGS_STREAM_REQUEST );
        return;
    }         
        
    // Can try to cancel a stream Srb and only if the stream extension still around.
    pStrmExt = (PSTREAMEX) pSrbToCancel->StreamObject->HwStreamExtension;

    if(pStrmExt == NULL) {
        TRACE(TL_CIP_ERROR|TL_STRM_ERROR,("DVCancelOnePacket: pSrbTocancel %x but pStrmExt %x\n", pSrbToCancel, pStrmExt));
        ASSERT(pStrmExt && "Stream SRB but stream extension is NULL\n");
        return;
    }

    // We can only cancel SRB_READ/WRITE_DATA SRB
    if((pSrbToCancel->Command != SRB_READ_DATA) && (pSrbToCancel->Command != SRB_WRITE_DATA)) {
        TRACE(TL_CIP_ERROR|TL_STRM_ERROR,("DVCancelOnePacket: pSrbTocancel %x; Command:%d not SRB_READ,WRITE_DATA\n", pSrbToCancel, pSrbToCancel->Command));
        return;
    }

    TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("\'DVCancelOnePacket: KSSt %d; Srb:%x; AQD[%d:%d:%d]\n",
        pStrmExt->StreamState, pSrbToCancel, pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached));

   
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    //
    // If device is removed, the surprise removal routine will do the cancelling.
    //
    if(!pDevExt->bDevRemoved) {
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
        // We will start an work item to stop streaming if we ever get an cancel Srb.
        if(!DVAbortStream(pDevExt, pStrmExt)) {
            TRACE(TL_STRM_WARNING,("\'CancelOnePacket: pSrb:%x; AbortStream not taken!\n", pSrbToCancel));
        }
    } else {
        TRACE(TL_STRM_WARNING,("\'CancelOnePacket: DevRemoved; pSrb:%x; AbortStream not taken!\n", pSrbToCancel));
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
    }
}



VOID
DVCancelAllPackets(
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    Cancel all packet when This is where most of the interesting Stream requests come to us

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrb;
    PSRB_DATA_PACKET pSrbDataPacket;
    PAV_61883_REQUEST   pAVReq;
    PSRB_ENTRY       pSrbEntry;
    NTSTATUS         Status;

    PIRP               pIrp;
    PLIST_ENTRY        pEntry;    
    PIO_STACK_LOCATION NextIrpStack;
    KIRQL oldIrql;



    PAGED_CODE();

#if DBG
    if(pStrmExt->StreamState != KSSTATE_STOP) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("DVCancelAllPackets: Enter; pStrmExt:%x; StrmSt:%d; IsochActive:%d\n", 
            pStrmExt, pStrmExt->StreamState, pStrmExt->bIsochIsActive));
    }
#endif

    //
    // Detached request only if not streaming
    //

    // Note: no need to spin lock this if isoch has stopped.
    if(!pStrmExt->bIsochIsActive) {

        PLONG plSrbUseCount;

        TRACE(TL_STRM_WARNING,("\'CancelAll: AQD: [%d:%d:%d]; DataAttachedListHead:%x\n",  
            pStrmExt->cntDataAttached, 
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached,
            pStrmExt->DataAttachedListHead
            )); 

        //
        // Cancel buffer(s) that are still attached.
        //

        KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

        pEntry = pStrmExt->DataAttachedListHead.Flink;
        while(pEntry != &pStrmExt->DataAttachedListHead) {        

            ASSERT(pStrmExt->cntDataAttached > 0 && "List and cntAttached out of sync!");

            // Get an irp and detached the buffer        
            if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))  {
                KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
                return;            
            }

            pSrbDataPacket = CONTAINING_RECORD(pEntry, SRB_DATA_PACKET, ListEntry);

#if DBG
            //
            // Cannot cancel if it has not complete the attaching process!
            //
            if(!IsStateSet(pSrbDataPacket->State, DE_IRP_ATTACHED_COMPLETED)) {
                TRACE(TL_STRM_ERROR,("Cancel (unattached) entry; pStrmExt:%x; pSrbDataPacket:%x\n", pStrmExt, pSrbDataPacket)); 
            }
#endif

            pEntry = pEntry->Flink;  // Next since this may get changed in the completion routine

            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

            //
            // Since the entry is added before it has been attached completed.
            // (This is done because the attach request to 61883 cannot guarantee its
            // completion order in either its attach completion routine or completion callback.)
            // Cancel only if it has complete the attach else we wait.
            //
            while (
                !IsStateSet(pSrbDataPacket->State, DE_IRP_ATTACHED_COMPLETED) &&   // Attached, or 
                !IsStateSet(pSrbDataPacket->State, DE_IRP_ERROR)                   // attach error
                    ) {
                // Not knowing when this will finished so we wait just a little (1 msec).  It is simpler
                // than having wait on event since cancelling is NOT time critical.
                DVDelayExecutionThread(1);  // Wait a little (This is simpler than adding another event!)
            }

            //
            // If it has been completed, then we should not need to cancel it!
            if(IsStateSet(pSrbDataPacket->State, DE_IRP_CALLBACK_COMPLETED)) {
                TRACE(TL_STRM_ERROR,("Already completed while trying to cancel it! %x\n", pSrbDataPacket));
                KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
                continue;
            }


            pSrb = pSrbDataPacket->pSrb;
            ASSERT(pSrbDataPacket->pSrb);
            plSrbUseCount = (PLONG) pSrb->SRBExtension;
            pAVReq = &pSrbDataPacket->AVReq;


            RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
            INIT_61883_HEADER(pAVReq, Av61883_CancelFrame);

            pAVReq->CancelFrame.hConnect     = pStrmExt->hConnect;
            pAVReq->CancelFrame.Frame        = pSrbDataPacket->Frame;
            TRACE(TL_CIP_TRACE,("\'Canceling AttachList: pSrb %x, AvReq %x; UseCount %d\n", pSrb, pAVReq, *plSrbUseCount));
            ASSERT(pSrbDataPacket->Frame);

            NextIrpStack = IoGetNextIrpStackLocation(pIrp);
            NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
            NextIrpStack->Parameters.Others.Argument1 = pAVReq;

            IoSetCompletionRoutine( 
                pIrp,
                DVCancelOnePacketCR,
                pSrbDataPacket,
                TRUE,
                TRUE,
                TRUE
                );

            Status = 
                IoCallDriver(
                    pDevExt->pBusDeviceObject,
                    pIrp
                    );


            ASSERT(Status == STATUS_PENDING || Status == STATUS_SUCCESS); 

            KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
        }

#if DBG
        if(pStrmExt->cntDataAttached != 0) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'DVCancelAllPackets: cntDataAttached:%d !!\n", pStrmExt->cntDataAttached));
            ASSERT(pStrmExt->cntDataAttached == 0);
        }
#endif

        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
        
        //
        // Cancel SRB that are still the SrbQ; this applies only to SRB_WRITE_DATA
        //
        pEntry = pStrmExt->SRBQueuedListHead.Flink;
        while(pEntry != &pStrmExt->SRBQueuedListHead) {  

            pSrbEntry = CONTAINING_RECORD(pEntry, SRB_ENTRY, ListEntry);
            plSrbUseCount = (PLONG) pSrbEntry->pSrb->SRBExtension;

            pEntry = pEntry->Flink;  // Next since this may get changed if removed

            TRACE(TL_CIP_TRACE,("\'DVCnclAllPkts (SrbQ): cntQ:%d; pSrb:%x; UseCnt:%d (=? 1)\n", pStrmExt->cntSRBQueued, pSrbEntry->pSrb, *plSrbUseCount));
            if(*plSrbUseCount == 1) {
                RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;  // Remove from queueed.
                pStrmExt->cntSRBCancelled++;
                pSrbEntry->pSrb->Status = (pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED);
                pSrbEntry->pSrb->CommandData.DataBufferArray->DataUsed = 0;
                pSrbEntry->pSrb->ActualBytesTransferred                = 0;
                TRACE(TL_STRM_WARNING,("\'Cancel queued SRB: pSRB:%x, Status:%x; cntSrbCancelled:%d\n", pSrbEntry->pSrb, pSrbEntry->pSrb->Status, pStrmExt->cntSRBCancelled));
                StreamClassStreamNotification(StreamRequestComplete, pSrbEntry->pSrb->StreamObject, pSrbEntry->pSrb);
#if DBG
                pStrmExt->cntSRBPending--;
#endif
                ExFreePool(pSrbEntry);
            } else {
                TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\'NOT Cancel queued SRB: pSRB:%x, Status:%x; *plSrbUseCount:%d, cntSrbCancelled:%d\n", pSrbEntry->pSrb, pSrbEntry->pSrb->Status, *plSrbUseCount, pStrmExt->cntSRBCancelled));
                ASSERT(*plSrbUseCount == 0 && "Still in use ?");
                break;  // Still in used.  Perhaps, free it in TimeoutHandler() or CancelOnePacket()
            }
        }
#if DBG
        if(pStrmExt->cntSRBQueued != 0 || !IsListEmpty(&pStrmExt->SRBQueuedListHead)) {
            TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\'DVCancelAllPackets: cntSRBQueued:%d !! Empty?%d\n", pStrmExt->cntSRBQueued, IsListEmpty(&pStrmExt->SRBQueuedListHead)));
            ASSERT(pStrmExt->cntSRBQueued == 0);
        }
#endif
    } 
    else {
        TRACE(TL_STRM_ERROR,("\'IsochActive; cannot cancel! cntSrbQ:%d; cntAttached:%d.\n", pStrmExt->cntSRBQueued, pStrmExt->cntDataAttached));
        ASSERT(pStrmExt->bIsochIsActive == FALSE);
    }   


    TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("CancelAll; Exiting AQD: [%d:%d:%d]; DataAttachedListHead:%x\n",
            pStrmExt->cntDataAttached, 
            pStrmExt->cntSRBQueued,
            pStrmExt->cntDataDetached,
            pStrmExt->DataAttachedListHead));
}


VOID
DVTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    This routine is called when a packet has been in the minidriver too long.
    It can only valid if we are it wa a streaming packet and in PAUSE state;
    else we have a problem!

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    //
    // Note:
    //    Called from StreamClass at DisptchLevel
    //    

    //
    // We only expect stream SRB, but not device SRB.  
    //

    if ( (pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        TRACE(TL_PNP_ERROR,("TimeoutHandler: Device SRB %x (cmd:%x) timed out!\n", pSrb, pSrb->Command));
        return;
    } else {

        //
        // pSrb->StreamObject (and pStrmExt) only valid if it is a stream SRB
        //
        PSTREAMEX pStrmExt;

        pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;

        if(!pStrmExt) {
            TRACE(TL_PNP_ERROR,("TimeoutHandler: Stream SRB %x timeout with pStrmExt %x\n", pSrb, pStrmExt));
            ASSERT(pStrmExt);
            return;
        }

        TRACE(TL_STRM_TRACE,("\'TimeoutHandler: KSSt %d; Srb:%x (cmd:%x); AQD[%d:%d:%d]\n",
            pStrmExt->StreamState, pSrb, pSrb->Command, pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached));

 
        //
        // Stream SRB (esp the data SRB) can time out if there is not 
        // data on the bus; however, it can only happen while in PAUSE 
        // or RUN state when attaching data SRB is valid.
        //
        if(pStrmExt->StreamState != KSSTATE_PAUSE &&
           pStrmExt->StreamState != KSSTATE_RUN) {
            TRACE(TL_PNP_ERROR|TL_STRM_ERROR,("\'TmOutHndlr:(Irql:%d) Srb %x (cmd:%x); %s, pStrmExt %x, AQD [%d:%d:%d]\n", 
                KeGetCurrentIrql(),
                pSrb, pSrb->Command, 
                pStrmExt->StreamState == KSSTATE_RUN   ? "RUN" : 
                pStrmExt->StreamState == KSSTATE_PAUSE ? "PAUSE":
                pStrmExt->StreamState == KSSTATE_STOP  ? "STOP": "Unknown",
                pStrmExt,
                pStrmExt->cntDataAttached,
                pStrmExt->cntSRBQueued,
                pStrmExt->cntDataDetached
                ));   
        }

        //
        // Reset Timeout counter, or we are going to get this call immediately.
        //

        pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
    }
}

NTSTATUS 
DVEventHandler(
    IN PHW_EVENT_DESCRIPTOR pEventDescriptor
    )
/*++

Routine Description:

    This routine is called to process events.

--*/
{

    PSTREAMEX  pStrmExt;

    if(IsEqualGUID (&KSEVENTSETID_Clock, pEventDescriptor->EventEntry->EventSet->Set)) {
        if(pEventDescriptor->EventEntry->EventItem->EventId == KSEVENT_CLOCK_POSITION_MARK) {
            if(pEventDescriptor->Enable) {
                // Note: According to the DDK, StreamClass queues pEventDescriptor->EventEntry, and dellaocate
                // every other structures, including the pEventDescriptor->EventData.
                if(pEventDescriptor->StreamObject) { 
                    PKSEVENT_TIME_MARK  pEventTime;

                    pStrmExt = (PSTREAMEX) pEventDescriptor->StreamObject->HwStreamExtension;
                    pEventTime = (PKSEVENT_TIME_MARK) pEventDescriptor->EventData;
                    // Cache the event data (Specified in the ExtraEntryData of KSEVENT_ITEM)
                    RtlCopyMemory((pEventDescriptor->EventEntry+1), pEventDescriptor->EventData, sizeof(KSEVENT_TIME_MARK));
                    TRACE(TL_STRM_TRACE,("\'CurrentStreamTime:%d, MarkTime:%d\n", (DWORD) pStrmExt->CurrentStreamTime, (DWORD) pEventTime->MarkTime));
                }
            } else {
               // Disabled!
                TRACE(TL_STRM_TRACE,("\'KSEVENT_CLOCK_POSITION_MARK disabled!\n"));            
            }
            return STATUS_SUCCESS;
        }
    } else if(IsEqualGUID (&KSEVENTSETID_Connection, pEventDescriptor->EventEntry->EventSet->Set)) {
        TRACE(TL_STRM_WARNING,("\'Connection event: pEventDescriptor:%x; id:%d\n", pEventDescriptor, pEventDescriptor->EventEntry->EventItem->EventId));

        pStrmExt = (PSTREAMEX) pEventDescriptor->StreamObject->HwStreamExtension;
        if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
            if(pEventDescriptor->EventEntry->EventItem->EventId == KSEVENT_CONNECTION_ENDOFSTREAM) {
                if(pEventDescriptor->Enable) {
                    TRACE(TL_STRM_TRACE,("\'KSEVENT_CONNECTION_ENDOFSTREAM enabled!\n"));
                } else {
                    TRACE(TL_STRM_TRACE,("\'KSEVENT_CONNECTION_ENDOFSTREAM disabled!\n"));            
                }
                return STATUS_SUCCESS;
            }
        }
    }

    TRACE(TL_STRM_ERROR,("\'NOT_SUPPORTED event: pEventDescriptor:%x\n", pEventDescriptor));
    ASSERT(FALSE && "Event not advertised and not supported!");

    return STATUS_NOT_SUPPORTED;
}

VOID
DVSignalClockEvent(
    IN PKDPC Dpc,
    IN PSTREAMEX  pStrmExt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 
)
/*++

Routine Description:

    This routine is called when we are the clock provider and when our clock "tick".  
    Find a pending clock event, signal it if it has expired.

--*/
{
    PKSEVENT_ENTRY pEvent, pLast;
    ULONGLONG tmStreamTime;
#if DBG
    ULONG EventPendings = 0;
#endif

    pEvent = NULL;
    pLast = NULL;


    //
    // A clock tick for DV is one frame time.  For better precision, 
    // we calculate current stream time with an offset from the last system time being queried.
    // We also add a max latency of one frame for decoding a DV frame.
    //
    tmStreamTime = 
        pStrmExt->CurrentStreamTime + 
        (GetSystemTime() - pStrmExt->LastSystemTime) + 
        DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame;  // Allow one frame of latency

    while(( 
        pEvent = StreamClassGetNextEvent(
            pStrmExt->pDevExt,
            pStrmExt->pStrmObject,
            (GUID *)&KSEVENTSETID_Clock,
            KSEVENT_CLOCK_POSITION_MARK,
            pLast )) 
        != NULL ) {

#if DBG
        EventPendings++;
#endif

        if (
            // For real time capture (DV->PC), signal every frame. 
            // No frame that is produce can be "early" and requires AdviseTime().
            pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT ||
                pStrmExt->bEOStream 
            || (pStrmExt->StreamState != KSSTATE_RUN)            // If not in RUN state, Data should be completed.
            || pStrmExt->pDevExt->PowerState != PowerDeviceD0    // If not power ON, data should be completed.
            || ((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime <= (LONGLONG) tmStreamTime ) {
            TRACE(TL_STRM_TRACE,("\'PowerSt:%d (ON:1?); StrmSt:%d; Clock event %x with id %d; Data:%x; \ttmMark\t%d \ttmCurrentStream \t%d; Notify!\n", 
                pStrmExt->pDevExt->PowerState, pStrmExt->StreamState,
                pEvent, KSEVENT_CLOCK_POSITION_MARK, (PKSEVENT_TIME_MARK)(pEvent +1),
                (DWORD) (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime), (DWORD) tmStreamTime));
            ASSERT( ((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime > 0 );

            //
            // signal the event here
            //
            StreamClassStreamNotification(
                SignalStreamEvent,
                pStrmExt->pStrmObject,
                pEvent
                );
#if DBG
            if(pStrmExt->bEOStream) {
                TRACE(TL_STRM_WARNING,("\'bEOStream: Clock event %x with id %d; Data:%x; \ttmMark \t%d \ttmCurStream \t%d\n", 
                    pEvent, KSEVENT_CLOCK_POSITION_MARK, (PKSEVENT_TIME_MARK)(pEvent +1),
                    (DWORD) (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime), (DWORD) tmStreamTime));
            }
#endif
        } else {
            TRACE(TL_STRM_WARNING,("\'PowerST:%d; StrmST:%d; AQD[%d:%d:%d]; Still early! ClockEvent: \tMarkTime \t%d \ttmStream \t%d \tdetla \t%d\n",
                pStrmExt->pDevExt->PowerState, pStrmExt->StreamState,
                pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached,
                (DWORD) (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime), (DWORD) tmStreamTime,
                (DWORD) ((((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime) - tmStreamTime)
                ));

        }
        pLast = pEvent;
    }

#if DBG
    if(EventPendings == 0) {
        TRACE(TL_STRM_TRACE,("\'No event pending; PowerSt:%d (ON:1?); StrmSt:%d; AQD[%d:%d:%d]\n", 
            pStrmExt->pDevExt->PowerState, pStrmExt->StreamState, 
            pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
        ));
    }
#endif

}


VOID 
StreamClockRtn(
    IN PHW_TIME_CONTEXT TimeContext
    )
/*++

Routine Description:

    This routine is called whenever someone in the graph wants to know what time it is, and we are the Master Clock.

--*/
{
    PDVCR_EXTENSION    pDevExt;
    PHW_STREAM_OBJECT  pStrmObj;
    PSTREAMEX          pStrmExt;
    
    // Call at dispatch level

    pDevExt  = (PDVCR_EXTENSION) TimeContext->HwDeviceExtension;
    pStrmObj = TimeContext->HwStreamObject;
    if(pStrmObj)
        pStrmExt = pStrmObj->HwStreamExtension;
    else 
        pStrmExt = 0;

    if(!pDevExt || !pStrmExt) {
        ASSERT(pDevExt && pStrmExt);
        return;
    }


    switch (TimeContext->Function) {
    
    case TIME_GET_STREAM_TIME:

        //
        // How long since the stream was first set into the run state?
        //
        ASSERT(pStrmExt->hMasterClock && "We are not master clock but we were qureied?");

        TimeContext->SystemTime = GetSystemTime();

        if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
            if(pStrmExt->StreamState == KSSTATE_RUN)  { // Stream time is only meaningful in RUN state
                if(TimeContext->SystemTime >= pStrmExt->LastSystemTime)
                    TimeContext->Time = 
                        pStrmExt->CurrentStreamTime + (TimeContext->SystemTime - pStrmExt->LastSystemTime); 
                else {
                    TimeContext->Time = pStrmExt->CurrentStreamTime;
                    TRACE(TL_STRM_WARNING,("\'Clock went backward? %d -> %d\n", (DWORD) (TimeContext->SystemTime/10000), (DWORD) (pStrmExt->LastSystemTime/10000) ));
                    // ASSERT(TimeContext->SystemTime >= pStrmExt->LastSystemTime);
                }
        
                // Make current stream time one frame behind
                if(TimeContext->Time > DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame)
                    TimeContext->Time = TimeContext->Time - DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame;
                else 
                    TimeContext->Time = 0;
            } else  {
                if(pStrmExt->FramesProcessed > 0)
                    TimeContext->Time = pStrmExt->CurrentStreamTime;
                else
                    TimeContext->Time = 0;  // if get queried at the PAUSE state.
            }
           
        } else {

            if(pStrmExt->StreamState == KSSTATE_RUN) {
#ifdef NT51_61883
                // Can advance at most MAX_CYCLES_TIME (supported by 1394 OHCI).
                if((TimeContext->SystemTime - pStrmExt->LastSystemTime) > MAX_CYCLES_TIME)
                    TimeContext->Time = pStrmExt->CurrentStreamTime + MAX_CYCLES_TIME;
#else
                // Cannot advance more than one frame time.
                if((TimeContext->SystemTime - pStrmExt->LastSystemTime) >= DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame)
                    TimeContext->Time = pStrmExt->CurrentStreamTime + DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame;
#endif  // NT51_61883
                else 
                    TimeContext->Time = 
                        pStrmExt->CurrentStreamTime + (TimeContext->SystemTime - pStrmExt->LastSystemTime); 

                // Necessary tuning ?
                //     Make current stream time one frame behind so that the downstream filter 
                //     can render the data promptly instead of discarding it if it is late.
                if(TimeContext->Time > DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame)
                    TimeContext->Time = TimeContext->Time - DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame;
                else 
                    TimeContext->Time = 0;                

            } else {
                if(pStrmExt->FramesProcessed > 0)
                    TimeContext->Time = pStrmExt->CurrentStreamTime;
                else
                    TimeContext->Time = 0;
            }
        }
        TRACE(TL_STRM_TRACE,("\'TIME_GET_STREAM_TIME: ST:%d; Frame:%d; tmSys:%d; tmStream:%d msec\n", 
            pStrmExt->StreamState,
            (DWORD) pStrmExt->PictureNumber,
            (DWORD)(TimeContext->SystemTime/10000), (DWORD)(TimeContext->Time/10000)));  
        break;
   
    default:
        ASSERT(TimeContext->Function == TIME_GET_STREAM_TIME && "Unsupport clock func");
        break;
    } // switch TimeContext->Function
}



NTSTATUS 
DVOpenCloseMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    )
/*++

Routine Description:

    We can be a clock provider.

--*/
{

    PAGED_CODE();

    // Make sure the stream exist.
    if(pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR,("\'DVOpenCloseMasterClock: stream is not yet running.\n"));
        ASSERT(pStrmExt);
        return  STATUS_UNSUCCESSFUL;
    } 

    TRACE(TL_STRM_TRACE,("\'DVOpenCloseMasterClock: pStrmExt %x; hMyClock:%x->%x\n", 
        pStrmExt, pStrmExt->hMyClock, hMasterClockHandle));

    if(hMasterClockHandle) {
        // Open master clock
        ASSERT(pStrmExt->hMyClock == NULL && "OpenMasterClk while hMyClock is not NULL!");
        pStrmExt->hMyClock = hMasterClockHandle;
    } else {
        // Close master clock
        ASSERT(pStrmExt->hMyClock && "CloseMasterClk while hMyClock is NULL!");
        pStrmExt->hMyClock = NULL;
    }
    return STATUS_SUCCESS;
}


NTSTATUS 
DVIndicateMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hIndicateClockHandle
    )
/*++

Routine Description:

    Compare the indicate clock handle with my clock handle.
    If the same, we are the master clock; else, other device is 
    the master clock.

    Note: either hMasterClock or hClock can be set.

--*/
{
    PAGED_CODE();

    // Make sure the stream exist.
    if (pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR,("DVIndicateMasterClock: stream is not yet running.\n"));
        ASSERT(pStrmExt);
        return STATUS_UNSUCCESSFUL;
    }

    TRACE(TL_STRM_TRACE,("\'*>IndicateMasterClk[Enter]: pStrmExt:%x; hMyClk:%x; IndMClk:%x; pClk:%x, pMClk:%x\n",
        pStrmExt, pStrmExt->hMyClock, hIndicateClockHandle, pStrmExt->hClock, pStrmExt->hMasterClock));

    // it not null, set master clock accordingly.    
    if(hIndicateClockHandle == pStrmExt->hMyClock) {
        pStrmExt->hMasterClock = hIndicateClockHandle;
        pStrmExt->hClock       = NULL;
    } else {
        pStrmExt->hMasterClock = NULL;
        pStrmExt->hClock       = hIndicateClockHandle;
    }

    TRACE(TL_STRM_TRACE,("\'<*IndicateMasterClk[Exit]: hMyClk:%x; IndMClk:%x; pClk:%x; pMClk:%x\n",
        pStrmExt->hMyClock, hIndicateClockHandle, pStrmExt->hClock, pStrmExt->hMasterClock));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvlowr.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSDVLowr.c

Abstract:

    Interface code with 61883 or 1394 class driver.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "dbg.h"
#include "msdvfmt.h"
#include "msdvdef.h"
#include "MSDVUtil.h"
#include "MSDVGuts.h"
#include "XPrtDefs.h"
#include "EDevCtrl.h"


extern DV_FORMAT_INFO  DVFormatInfoTable[];
extern const GUID KSEVENTSETID_Connection_Local;


//
// Simple function prototype
//
VOID
DVSRBRead(
    IN PKSSTREAM_HEADER pStrmHeader,
    IN ULONG            ulFrameSize,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb        // needs Srb->Status 
    );
NTSTATUS
DVAttachWriteFrame(
    IN PSTREAMEX  pStrmExt
    );
VOID
DVFormatAttachFrame(
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt,    
    IN PAV_61883_REQUEST   pAVReq,
    IN PHW_STREAM_REQUEST_BLOCK       pSrb,
    IN PSRB_DATA_PACKET pSrbDataPacket,
    IN ULONG            ulSourceLength,    // Packet length in bytes
    IN ULONG            ulFrameSize,
    IN PVOID            pFrameBuffer
    );


#if DBG
ULONG cntInvSrcPkt = 0;
#endif
#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVSRBRead)
     #pragma alloc_text(PAGE, DVFormatAttachFrame)
     #pragma alloc_text(PAGE, DVAttachFrameThread)
     #pragma alloc_text(PAGE, DVTerminateAttachFrameThread)
     #pragma alloc_text(PAGE, DVAttachWriteFrame)
     #pragma alloc_text(PAGE, DVFormatAttachFrame)
#endif
#endif

ULONG
DVReadFrameValidate(           
    IN PCIP_VALIDATE_INFO     pInfo
    )
/*++

Routine Description:

   Used to detect the start of a DV frame.  A DV frame is started with a header section.

Return

    0  verified
    1: invallid

--*/
{
    if(pInfo->Packet) {        

        //
        // Detect header 0 signature.
        //
        if(
             (pInfo->Packet[0] & DIF_BLK_ID0_SCT_MASK)  == 0 
          && (pInfo->Packet[1] & DIF_BLK_ID1_DSEQ_MASK) == 0 
          && (pInfo->Packet[2] & DIF_BLK_ID2_DBN_MASK)  == 0 
          ) {

// 
// This can be used to detect dynamic format change if this function is called 
// to check for data packets always.  This may require setting this flag:
//     CIP_VALIDATE_ALL_SOURCE instead of CIP_VALIDATE_FIRST_SOURCE
//
#if 0 // DBG


            PSRB_DATA_PACKET pSrbDataPacket = pInfo->Context;
            PSTREAMEX        pStrmExt       = pSrbDataPacket->pStrmExt;          
            PDVCR_EXTENSION  pDevExt        = pStrmExt->pDevExt;

            if((pInfo->Packet[0] & DIF_HEADER_DSF) == 0) {
                // Indicate a 10 DIF sequences include in a video frame (525-60)/NTSC.
                if(
                     pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_PAL 
                  || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_PAL
                  ) { 
                    // Dynamic format changes!!
                    TRACE(TL_STRM_ERROR|TL_CIP_WARNING,("Detect dynamic format change PAL -> NTSC!\n"));
                }
            } else {
                // Indicate a 12 DIF sequences include in a video frame (625-50)/PAL.
                if(
                     pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC 
                  || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC
                  ) { 
                    // Dynamic format changes!!
                    TRACE(TL_STRM_ERROR|TL_CIP_WARNING,("Detect dynamic format change NTSC -> PAL!\n"));
                }
            }
#endif
            
            // Check TF1, TF2, and  TF3:  1: not transmitted; 0:transmitted
            // TF1:Audio; TF2:Video; TF3:Subcode; they all need to be 0 to be valid.
            if(
                 (pInfo->Packet[5] & DIF_HEADER_TFn) 
              || (pInfo->Packet[6] & DIF_HEADER_TFn) 
              || (pInfo->Packet[7] & DIF_HEADER_TFn) 
              ) {
                TRACE(TL_STRM_ERROR|TL_CIP_WARNING,("\'%d inv src pkts; [%x %x %d %x], [%x   %x %x %x]\n", 
                    cntInvSrcPkt,
                    pInfo->Packet[0],
                    pInfo->Packet[1],
                    pInfo->Packet[2],
                    pInfo->Packet[3],
                    pInfo->Packet[4],
                    pInfo->Packet[5],
                    pInfo->Packet[6],
                    pInfo->Packet[7]
                    ));
                // Valid header but DIF block for this area is not transmitted.
                // Some DV (such as DVCPro) may wait untill its "mecha and servo" to be stable to make these valid.
                // This should happen if a graph is in run state before a tape is played (and stablized).
                return 1;
            }

#if DBG
            if(cntInvSrcPkt > 0) {
                TRACE(TL_CIP_TRACE,("\'%d inv src pkts; [%x %x %d %x] [%x %x %x %x]\n", 
                    cntInvSrcPkt,
                    pInfo->Packet[0],
                    pInfo->Packet[1],
                    pInfo->Packet[2],
                    pInfo->Packet[3],
                    pInfo->Packet[4],
                    pInfo->Packet[5],
                    pInfo->Packet[6],
                    pInfo->Packet[7]
                    )); 
                cntInvSrcPkt = 0;  // Reset
            }
#endif
            return 0;
        }
        else {
#if DBG

            //
            // To detect invalid src pkt sequence;
            // If it exceeded the number of source packet per frame, we need to know about it.
            //

            PSRB_DATA_PACKET pSrbDataPacket = pInfo->Context;
            PSTREAMEX        pStrmExt       = pSrbDataPacket->pStrmExt;          
            PDVCR_EXTENSION  pDevExt        = pStrmExt->pDevExt;

            if(++cntInvSrcPkt >= DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets) {            
                TRACE(TL_CIP_TRACE,("(%d) Invalid SrcPkt >= max inv src pkt %d; ID0,1,2 = [%x %x %x]\n",
                    cntInvSrcPkt,
                    DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets,
                    pInfo->Packet[0], pInfo->Packet[1], pInfo->Packet[2]
                    )); 

                if(DVTraceMask & TL_CIP_TRACE) {
                    ASSERT(cntInvSrcPkt < DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets);
                }
                cntInvSrcPkt = 0;  // Reset
            }
            else {
                TRACE(TL_CIP_INFO,("(%d) Invalid SrcPktSeq; ID0,1,2 = [%x,%x,%x]\n", 
                    cntInvSrcPkt, pInfo->Packet[0], pInfo->Packet[1], pInfo->Packet[2] )); 
            }
#endif
            return 1;
        }
    }
    else {
        TRACE(TL_CIP_WARNING, ("\'Validate: invalid SrcPktSeq; Packet %x\n", pInfo->Packet)); 
        return 1;
    }
} // DVReadFrameValidate


#if DBG
LONGLONG    PreviousPictureNumber;
LONGLONG    PreviousTime;
CYCLE_TIME  PreviousTimestamp;
#endif


ULONG
DVCompleteSrbRead(
    PCIP_NOTIFY_INFO     pInfo
    )
/*++

Routine Description:

    61883 has completed receiving data and callback to us to complete.   

--*/
{
    PSRB_DATA_PACKET            pSrbDataPacket;
    PHW_STREAM_REQUEST_BLOCK    pSrb; 
    PKSSTREAM_HEADER            pStrmHeader;
    PDVCR_EXTENSION             pDevExt;
    PSTREAMEX                   pStrmExt;  
    LONGLONG                    LastPictureNumber;
    PUCHAR                      pFrameBuffer;
    KIRQL oldIrql;
    PKS_FRAME_INFO  pFrameInfo; // For VidOnly pin only 
#if DBG
    PXMT_FRAME_STAT pXmtStat;
#endif


    // Callback and might be at the DISPATCH_LEVEL
    // The caller might have acquired spinlock as well!

    pSrbDataPacket = pInfo->Context;

    if(!pSrbDataPacket) {     
        ASSERT(pSrbDataPacket && "Context is NULL!");
        return 1;
    }

    pStrmExt = pSrbDataPacket->pStrmExt; 
    
    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

#if DBG
    // Once it is completed by 61883, it becomes non-cancellable.
    if(!pStrmExt->bIsochIsActive) {   
        TRACE(TL_CIP_WARNING,("CompleteSrbRead: bIsochActive:%d; pSrbDataPacket:%x\n", pStrmExt->bIsochIsActive, pSrbDataPacket));        
    }
#endif

    pSrb     = pSrbDataPacket->pSrb;  ASSERT(pSrbDataPacket->pSrb);
    pDevExt  = pStrmExt->pDevExt;
    pFrameBuffer = (PUCHAR) pSrbDataPacket->FrameBuffer;
    pStrmHeader = pSrb->CommandData.DataBufferArray;  ASSERT(pStrmHeader->Size >= sizeof(KSSTREAM_HEADER));

    //
    // Check CIP_STATUS_* from 61883
    //    
    // CIP_STATUS_CORRUPT_FRAME (0x00000001)  // isoch header or cip header was incorrect
    if(pSrbDataPacket->Frame->Status & CIP_STATUS_CORRUPT_FRAME) {
        TRACE(TL_STRM_WARNING|TL_CIP_TRACE,("\'CIP_STATUS_CORRUPT_FRAME\n"));
        pStrmHeader->OptionsFlags = 0;
        pSrb->Status = STATUS_SUCCESS;  // Success but no data !
        pStrmHeader->DataUsed = 0;
        pStrmExt->PictureNumber++;  pStrmExt->FramesProcessed++;
    }
    else
    // CIP_STATUS_SUCCESS       (0x00000000)  // 0 so cannot do bitwise operation!!
    // CIP_STATUS_FIRST_FRAME   (0x00000002)  // First attached frame to 61883
    if(pSrbDataPacket->Frame->Status == CIP_STATUS_SUCCESS ||
       (pSrbDataPacket->Frame->Status & CIP_STATUS_FIRST_FRAME))   {

        // Only increment FramesProcessed if it is a valid frame;
        pStrmExt->FramesProcessed++;

        pSrb->Status              = STATUS_SUCCESS;
        pStrmHeader->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;
        pStrmHeader->DataUsed     = DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize;


        // Put in Timestamp info depending on clock provider            
        pStrmHeader->PresentationTime.Numerator   = 1;
        pStrmHeader->PresentationTime.Denominator = 1;

        if(pStrmExt->hMasterClock || pStrmExt->hClock) {

            pStrmHeader->Duration = 
                DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame;

            pStrmHeader->OptionsFlags |= 
                (KSSTREAM_HEADER_OPTIONSF_TIMEVALID |     // pStrmHeader->PresentationTime.Time is valid
                 KSSTREAM_HEADER_OPTIONSF_DURATIONVALID); 
        }
        //
        // Only if there is a clock, presentation time and drop frames information are set.
        //  Acoording to DDK:
        //  The PictureNumber member count represents the idealized count of the current picture, 
        //  which is calculated in one of two ways: 
        // ("Other" clock) Measure the time since the stream was started and divide by the frame duration. 
        // (MasterClock) Add together the count of frames captured and the count of frame dropped. 
        //

        // Other device (audio?) is the clock provider
        if(pStrmExt->hClock) {

            pStrmExt->TimeContext.HwDeviceExtension = (struct _HW_DEVICE_EXTENSION *) pDevExt; 
            pStrmExt->TimeContext.HwStreamObject    = pStrmExt->pStrmObject;
            pStrmExt->TimeContext.Function          = TIME_GET_STREAM_TIME;
            pStrmExt->TimeContext.Time              = 0;
            pStrmExt->TimeContext.SystemTime        = 0;

            StreamClassQueryMasterClockSync(
                pStrmExt->hClock,
                &(pStrmExt->TimeContext) 
                );

            pStrmHeader->PresentationTime.Time = pStrmExt->CurrentStreamTime = pStrmExt->TimeContext.Time;

            // Calculate picture number and dropped frame;
            // For NTSC, it could be 267 or 266 packet time per frame. Since integer calculation will round, 
            // we will add a packet time (TIME_PER_CYCLE = 125 us = 1250 100nsec) to that.This is only used for calculation.
            LastPictureNumber = pStrmExt->PictureNumber;  
            pStrmExt->PictureNumber = 
                1 +   // Picture number start with 1.
                (pStrmHeader->PresentationTime.Time + TIME_PER_CYCLE)
                * (LONGLONG) GET_AVG_TIME_PER_FRAME_DENOM(pStrmExt->pDevExt->VideoFormatIndex) 
                / (LONGLONG) GET_AVG_TIME_PER_FRAME_NUM(pStrmExt->pDevExt->VideoFormatIndex);

            // Detect discontinuity
            if(pStrmExt->PictureNumber > LastPictureNumber+1) {
                pStrmHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;  // If there is a skipped frame, set the discontinuity flag
                TRACE(TL_CIP_WARNING,("\'Discontinuity: LastPic#:%d; Pic#%d; PresTime:%d;\n", (DWORD) LastPictureNumber, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmHeader->PresentationTime.Time));
            }

            // Detect if picture number did not progress.
            // This could be due to two frame being completely very close to each other.
            if(pStrmExt->PictureNumber <= LastPictureNumber) {
                TRACE(TL_CIP_WARNING,("\'hClock:Same pic #:(%d->%d); tmPres:(%d->%d); (%d:%d:%d) -> (%d:%d:%d); AQD[%d:%d:%d]\n", 
                    (DWORD) PreviousPictureNumber,
                    (DWORD) pStrmExt->PictureNumber, 
                    (DWORD) PreviousTime,
                    (DWORD) pStrmHeader->PresentationTime.Time,
                    PreviousTimestamp.CL_SecondCount, PreviousTimestamp.CL_CycleCount, PreviousTimestamp.CL_CycleOffset,
                    pSrbDataPacket->Frame->Timestamp.CL_SecondCount,
                    pSrbDataPacket->Frame->Timestamp.CL_CycleCount,
                    pSrbDataPacket->Frame->Timestamp.CL_CycleOffset,
                    pStrmExt->cntDataAttached,
                    pStrmExt->cntSRBQueued,
                    pStrmExt->cntDataDetached
                    ));

                pStrmExt->PictureNumber = LastPictureNumber + 1;  // Picture number must progress !!!!
            }
#if DBG
            PreviousPictureNumber = pStrmExt->PictureNumber;
            PreviousTime          = pStrmHeader->PresentationTime.Time;
            PreviousTimestamp = pSrbDataPacket->Frame->Timestamp;
#endif
            pStrmExt->FramesDropped = pStrmExt->PictureNumber - pStrmExt->FramesProcessed;

        // This subunit driver is a Master clock
        } else if (pStrmExt->hMasterClock) {
#ifdef NT51_61883
            ULONG  ulDeltaCycleCounts;

            // No drop frame for PAUSE->RUN transition
            if(pStrmExt->b1stNewFrameFromPauseState) { 

                pStrmHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;            
                pStrmExt->b1stNewFrameFromPauseState = FALSE;                  

            } else {           
                ULONG ulCycleCount16bits;

                // Calculate skipped 1394 cycle from the returned CycleTime
                VALIDATE_CYCLE_COUNTS(pSrbDataPacket->Frame->Timestamp);
                ulCycleCount16bits = CALCULATE_CYCLE_COUNTS(pSrbDataPacket->Frame->Timestamp);
                ulDeltaCycleCounts = CALCULATE_DELTA_CYCLE_COUNT(pStrmExt->CycleCount16bits, ulCycleCount16bits); 

                // Adjust to max allowable gap to the max elapsed time of the CycleTime returned by OHCI 1394.
                if(ulDeltaCycleCounts > MAX_CYCLES)  
                    ulDeltaCycleCounts = MAX_CYCLES;  // Wrap around
    
                //
                // There are two cases for drop frames: 
                //    (1) Starve of buffer; or,
                //    (2) no data (blank tape or tape is not playing)
                //

                // For case (1), 61883 returns CIP_STATUS_FIRST_FRAME.  
                if(pSrbDataPacket->Frame->Status & CIP_STATUS_FIRST_FRAME)   {
                    // Use cycle count to calculate drop frame.  We substract 1 from the MaxSrcPacket on purpose to avoid truncating. 
                    // The max range is MAX_CYCLE (8 * 8000 = 64000 cycles)
                    //    64000 * 125 * 3 / 100100 = 239.76
                    //    64000 / 266 = 240
                    //    64000 / 267 = 239
                    if(ulDeltaCycleCounts >= (DVFormatInfoTable[pDevExt->VideoFormatIndex].ulMaxSrcPackets - 1)) {
                        ULONG ulFrameElapsed = ulDeltaCycleCounts / (DVFormatInfoTable[pDevExt->VideoFormatIndex].ulMaxSrcPackets - 1);
                        pStrmExt->FramesDropped += (ulFrameElapsed - 1);  // There is a valid frame that is not dropped.
                     } 
                    
                    TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("CIP_STATUS_FIRST_FRAME: Drop:%d; Processed:%d\n", (DWORD) pStrmExt->FramesDropped, pStrmExt->FramesProcessed )); 
                    pStrmHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;            

                } else {
                    // Ignore all "drop frames" in the "no data" case
                    // pStrmExt->FramesDropped += 0;
                }            
            }

            // If we are the clock provider, the stream time is based on sample number * AvgTimePerFrame
            pStrmExt->PictureNumber = pStrmExt->FramesProcessed + pStrmExt->FramesDropped;

            pStrmHeader->PresentationTime.Time = pStrmExt->CurrentStreamTime = 
                pStrmExt->PictureNumber 
                * (LONGLONG) GET_AVG_TIME_PER_FRAME_NUM(pStrmExt->pDevExt->VideoFormatIndex)
                / (LONGLONG) GET_AVG_TIME_PER_FRAME_DENOM(pStrmExt->pDevExt->VideoFormatIndex); 

            // Use to adjust the queried stream time
            pStrmExt->LastSystemTime = GetSystemTime();

            // Cache current CycleCount
            pStrmExt->CycleCount16bits = CALCULATE_CYCLE_COUNTS(pSrbDataPacket->Frame->Timestamp);

#if DBG
            // First frame or skipped frame
            if(pStrmExt->PictureNumber <= 1 ||
               pStrmExt->PictureNumber <= PreviousPictureNumber ||
               ulDeltaCycleCounts > DVFormatInfoTable[pDevExt->VideoFormatIndex].ulMaxSrcPackets
               )
                TRACE(TL_CIP_WARNING,("\'hMasterClock: Same pic #:(%d->%d); tmPres:(%d->%d); (%d:%d:%d) -> (%d:%d:%d); AQD[%d:%d:%d]\n", 
                    (DWORD) PreviousPictureNumber,
                    (DWORD) pStrmExt->PictureNumber, 
                    (DWORD) PreviousTime,
                    (DWORD) pStrmHeader->PresentationTime.Time,
                    PreviousTimestamp.CL_SecondCount, PreviousTimestamp.CL_CycleCount, PreviousTimestamp.CL_CycleOffset,
                    pSrbDataPacket->Frame->Timestamp.CL_SecondCount,
                    pSrbDataPacket->Frame->Timestamp.CL_CycleCount,
                    pSrbDataPacket->Frame->Timestamp.CL_CycleOffset,
                    pStrmExt->cntDataAttached,
                    pStrmExt->cntSRBQueued,
                    pStrmExt->cntDataDetached
                    ));

            PreviousPictureNumber = pStrmExt->PictureNumber;
            PreviousTime          = pStrmHeader->PresentationTime.Time;
            PreviousTimestamp = pSrbDataPacket->Frame->Timestamp;
#endif


#else   // NT51_61883
            // This is the old way when 61883 was not returning the correct CycleTime.
            pStrmHeader->PresentationTime.Time = pStrmExt->CurrentStreamTime;            
            pStrmExt->LastSystemTime = GetSystemTime();  // Use to adjust the queried stream time
            pStrmExt->CurrentStreamTime += DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame;
#endif  // NT51_61883

        // no Clock so "free flowing!"
        } else {
            pStrmHeader->PresentationTime.Time = 0;
            pStrmHeader->Duration = 0;  // No clock so not valid.
            pStrmExt->PictureNumber++;
            TRACE(TL_CIP_TRACE,("\'No clock: PicNum:%d\n", (DWORD) pStrmExt->PictureNumber));
        }
    }
    else {
        // 61883 has not defined this new status at this time!
        // Do not know what to do so we will complete it with 0 length for now.
        pStrmHeader->OptionsFlags = 0;
        pSrb->Status = STATUS_SUCCESS;
        pStrmHeader->DataUsed = 0;
        pStrmExt->PictureNumber++;  pStrmExt->FramesProcessed++;
        TRACE(TL_STRM_WARNING|TL_CIP_ERROR,("pSrbDataPacket:%x; unexpected Frame->Status %x\n", pSrbDataPacket, pSrbDataPacket->Frame->Status));
        ASSERT(FALSE && "Unknown pSrbDataPacket->Frame->Status");
    }

    // For VidOnly which uses VideoInfoHeader and has 
    // an extended frame information (KS_FRAME_INFO) appended to KSSTREAM_HEADER
    if( pDevExt->idxStreamNumber == 0 &&
        (pStrmHeader->Size >= (sizeof(KSSTREAM_HEADER) + sizeof(PKS_FRAME_INFO)))
        ) {
        pFrameInfo = (PKS_FRAME_INFO) (pStrmHeader + 1);
        pFrameInfo->ExtendedHeaderSize = sizeof(KS_FRAME_INFO);
        pFrameInfo->PictureNumber = pStrmExt->PictureNumber;
        pFrameInfo->DropCount     = pStrmExt->FramesDropped;
        pFrameInfo->dwFrameFlags  = 
            KS_VIDEO_FLAG_FRAME |     // Complete frame
            KS_VIDEO_FLAG_I_FRAME;    // Every DV frame is an I frame
    }

#if DBG
    // Validate that the data is return in the right sequence
    if(pSrbDataPacket->FrameNumber != pStrmExt->FramesProcessed) {
        TRACE(TL_STRM_WARNING|TL_CIP_ERROR,("\'pSrbDataPacket:%x; Status:%x; Out of Sequence %d != %d; (Dropped:%x)\n", 
                pSrbDataPacket, pSrbDataPacket->Frame->Status, 
                (DWORD) pSrbDataPacket->FrameNumber, (DWORD) pStrmExt->FramesProcessed,
                (DWORD) pStrmExt->FramesDropped
                ));
    };
#endif


#if DBG
    // Collect transmit buffer statistics    
    if(pStrmExt->ulStatEntries < MAX_XMT_FRAMES_TRACED) {
        pXmtStat = pStrmExt->paXmtStat + pStrmExt->ulStatEntries;
    
        pXmtStat->StreamState    = pStrmExt->StreamState;

        pXmtStat->cntSRBReceived = (LONG) pStrmExt->cntSRBReceived;
        pXmtStat->cntSRBPending  = (LONG) pStrmExt->cntSRBPending;
        pXmtStat->cntSRBQueued   = (LONG) pStrmExt->cntSRBQueued;
        pXmtStat->cntDataAttached= pStrmExt->cntDataAttached;

        pXmtStat->FrameSlot      = (DWORD) pStrmExt->PictureNumber;
        pXmtStat->tmStreamTime   = pStrmExt->CurrentStreamTime;

        pXmtStat->DropCount      = (DWORD) pStrmExt->FramesDropped;

        pXmtStat->FrameNumber    = (DWORD) pSrbDataPacket->FrameNumber;
        pXmtStat->OptionsFlags   = pSrb->CommandData.DataBufferArray->OptionsFlags;
        pXmtStat->tmPresentation = pSrb->CommandData.DataBufferArray->PresentationTime.Time;

        pXmtStat->tsTransmitted= pSrbDataPacket->Frame->Timestamp;

        pStrmExt->ulStatEntries++;
    }
    
#endif


    //
    // Mark completion is called.
    //
    pSrbDataPacket->State |= DE_IRP_CALLBACK_COMPLETED;

    //
    // Attached->Completed or Completed->Attached.
    //
    if(IsStateSet(pSrbDataPacket->State, DE_IRP_ATTACHED_COMPLETED)) {

        //
        // Recycle it back to the detach list
        //
        RemoveEntryList(&pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached--;  ASSERT(pStrmExt->cntDataAttached >= 0);
        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;

#if DBG
        // Detect if 61883 is starve.  This cause discontinuity.
        // This can happen for many valid reasons (slow system).
        // An assert is added to detect other unknown reason.
        if(pStrmExt->cntDataAttached == 0 && pStrmExt->StreamState == KSSTATE_RUN) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\n**** 61883 starved in RUN state (read); AQD[%d:%d:%d]\n\n", 
                pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
            ));
            // ASSERT(pStrmExt->cntDataAttached > 0 && "61883 is starve at RUN state!!");
        }
#endif

        //
        // Complete this Srb
        //

        StreamClassStreamNotification(StreamRequestComplete, pStrmExt->pStrmObject, pSrbDataPacket->pSrb );  
        pSrbDataPacket->State |= DE_IRP_SRB_COMPLETED;  pSrbDataPacket->pSrb = NULL;

#if DBG
        pStrmExt->cntSRBPending--;
#endif

    } else {

        TRACE(TL_STRM_WARNING,("CompleteSrbRead: pSrbDataPacket:%x; Completed before attach.\n", pSrbDataPacket));

    }

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 

    return 0;
} // DVCompleteSrbRead


NTSTATUS
DVAttachFrameCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PSRB_DATA_PACKET pSrbDataPacket    
    )
/*++

Routine Description:

    Completion routine for attaching a frame for transmitting.
    Apply to attaching listen and talk frame.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrb;
    PSTREAMEX       pStrmExt;
    PLONG plSrbUseCount; // When this count is 0, it can be completed.
    KIRQL oldIrql;


    pStrmExt = pSrbDataPacket->pStrmExt;
    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

    pSrb = pSrbDataPacket->pSrb;

    // This entry is be already attached before IoCallDriver.
    // This is done this way because this buffer could be filled and 
    // completed before the attach completion routine (here) is called.
    // If it is completed and callback is called, 
    // pSrbDataPacket->pSrb has been set to NULL.
    // In the error case, pSrbDataPacket->pSrb should not be NULL.
    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        if(pSrbDataPacket->pSrb == NULL) {
            // PBinder told me that this cannot happen.
            // A buffer is completed (pSRb set to NULL), and still return with an error!
            ASSERT(pSrbDataPacket->pSrb);
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);   
            return STATUS_MORE_PROCESSING_REQUIRED;      
        }
        pSrbDataPacket->State |= DE_IRP_ERROR;

        plSrbUseCount = (PLONG) (pSrb->SRBExtension);
        (*plSrbUseCount) --;  // -- for being remove from queue
        ASSERT(*plSrbUseCount >= 0);

        TRACE(TL_CIP_ERROR,("DVAttachFrameCR: pSrb:%x; pSrb->Status:%x; failed pIrp->Status %x; UseCnt:%d\n", pSrb, pSrb->Status, pIrp->IoStatus.Status, *plSrbUseCount));   
        ASSERT(NT_SUCCESS(pIrp->IoStatus.Status) && "DVAttachFrameCR");
        // Complete this SRB only if the count is 0.
        if(*plSrbUseCount == 0 && pSrb->Status != STATUS_CANCELLED) {
            pSrb->Status = pIrp->IoStatus.Status;
            pSrb->CommandData.DataBufferArray->DataUsed = 0;

            // Complete SRB
            StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrbDataPacket->pSrb);
            pSrbDataPacket->State |= DE_IRP_SRB_COMPLETED;  pSrbDataPacket->pSrb = NULL;
#if DBG
            pStrmExt->cntSRBPending--;
#endif            
        }

        // Recycle list
        RemoveEntryList(&pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached--; ASSERT(pStrmExt->cntDataAttached >= 0);
        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;

#if DBG
        // Detect if 61883 is starve.  This cause discontinuity.
        // This can happen for many valid reasons (slow system).
        // An assert is added to detect other unknown reason.
        if(!pStrmExt->bEOStream && pStrmExt->cntDataAttached == 0 && pStrmExt->StreamState == KSSTATE_RUN) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\n**** 61883 starve in RUN state (AttachCR); AQD[%d:%d:%d]\n\n", 
                pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
            ));
            if (pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
                // ASSERT(pStrmExt->cntDataAttached > 0 && "61883 is starve at RUN state!!");
            }
        }
#endif

        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);   
        return STATUS_MORE_PROCESSING_REQUIRED;        
    }


    //
    // Mark attached buffer completed.
    //
    pSrbDataPacket->State |= DE_IRP_ATTACHED_COMPLETED;


    //
    // Special case: Completed and then Attached.
    //
    if(IsStateSet(pSrbDataPacket->State, DE_IRP_CALLBACK_COMPLETED)) {

        //
        // Recycle it back to the detach list
        //
        RemoveEntryList(&pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached--;  ASSERT(pStrmExt->cntDataAttached >= 0);
        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;

#if DBG
        // Detect if 61883 is starve.  This cause discontinuity.
        // This can happen for many valid reasons (slow system).
        // An assert is added to detect other unknown reason.
        if(!pStrmExt->bEOStream && pStrmExt->cntDataAttached == 0 && pStrmExt->StreamState == KSSTATE_RUN) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\n**** 61883 starve in RUN state (AttachCR); AQD[%d:%d:%d]\n\n", 
                pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
            ));
            if (pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
                // ASSERT(pStrmExt->cntDataAttached > 0 && "61883 is starve at RUN state!!");
            }
        }
#endif

        //
        // Complete this Srb
        //
        StreamClassStreamNotification(StreamRequestComplete, pStrmExt->pStrmObject, pSrbDataPacket->pSrb); 
        pSrbDataPacket->State |= DE_IRP_SRB_COMPLETED;  pSrbDataPacket->pSrb = NULL;

#if DBG
        pStrmExt->cntSRBPending--;
#endif

        TRACE(TL_STRM_WARNING,("AttachFrameCR: pSrbDataPacket:%x; completed before DttachFrameCR.\n", pSrbDataPacket));
    }


    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

    TRACE(TL_CIP_INFO,("\'DVAttachFrameCR: pSrb:%x; AttachCnt:%d\n", pSrb, pStrmExt->cntDataAttached));  

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
DVSRBRead(
    IN PKSSTREAM_HEADER pStrmHeader,
    IN ULONG            ulFrameSize,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb        // needs Srb->Status 
    )
/*++

Routine Description:

    Called when an Read Data Srb request is received

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          Status;
    PSRB_DATA_PACKET  pSrbDataPacket;
    PAV_61883_REQUEST   pAVReq;
    PLONG               plSrbUseCount;
    PIO_STACK_LOCATION  NextIrpStack;
    ULONG               ulSrcPktLen;    // Packet length in bytes
    PVOID               pFrameBuffer;



    PAGED_CODE();


    //
    // Some validation
    //
    if(pStrmHeader->FrameExtent < ulFrameSize) {
        TRACE(TL_CIP_WARNING,("\'SRBRead: FrmExt %d < FrmSz %d\n", pStrmHeader->FrameExtent, ulFrameSize));
#ifdef SUPPORT_NEW_AVC
        if(pStrmExt->bDV2DVConnect) {
            pSrb->Status = STATUS_SUCCESS;  // Testing...
        } else {
#endif
        ASSERT(pStrmHeader->FrameExtent >= ulFrameSize);
        pSrb->Status = STATUS_INVALID_PARAMETER;  
#ifdef SUPPORT_NEW_AVC
        }
#endif
        goto ExitReadStreamError;
    }


    //
    // Make sure that there is enough entry
    //
    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
    if(IsListEmpty(&pStrmExt->DataDetachedListHead)) {
        //
        // This can happen only if the upper layer send down more than what we preallocated.        
        // In this case, we will expand the list.
        //
        if(!(pSrbDataPacket = ExAllocatePool(NonPagedPool, sizeof(SRB_DATA_PACKET)))) {
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);        
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitReadStreamError;
        }
        RtlZeroMemory(pSrbDataPacket, sizeof(SRB_DATA_PACKET));
        if(!(pSrbDataPacket->Frame = ExAllocatePool(NonPagedPool, sizeof(CIP_FRAME)))) {
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);        
            ExFreePool(pSrbDataPacket);
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitReadStreamError;            
        }
        if(!(pSrbDataPacket->pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE))) {
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);        
            ExFreePool(pSrbDataPacket->Frame);  pSrbDataPacket->Frame = 0;
            ExFreePool(pSrbDataPacket); pSrbDataPacket = 0;
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitReadStreamError; 
        }
        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;
        TRACE(TL_CIP_WARNING,("\'Add one node to DetachList\n"));     
    }

    // Get a a nonpaged system-space virtual address for the buffer
    // This could fail it there is not enough system resource (MDL).
#ifdef USE_WDM110   // Win2000
    //
    // Driver verifier flag to use this but if this is used, this driver will not load for Millen!!!
    //
    pFrameBuffer = MmGetSystemAddressForMdlSafe(pSrb->Irp->MdlAddress, NormalPagePriority);
#else    // Win9x
    pFrameBuffer = MmGetSystemAddressForMdl    (pSrb->Irp->MdlAddress);
#endif
    if(pFrameBuffer == NULL) {
        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);        

        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        ASSERT(FALSE && "DVFormatAttachFrame() insufficient resource!");
        goto ExitReadStreamError;
    }

    pSrbDataPacket = (PSRB_DATA_PACKET) RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
    plSrbUseCount = (PLONG) (pSrb->SRBExtension); (*plSrbUseCount) = 0; // Not in a queue so 0.  
    pAVReq = &pSrbDataPacket->AVReq;


    ulSrcPktLen = \
        (DVFormatInfoTable[pDevExt->VideoFormatIndex].DataBlockSize << 2) * \
            (1 << DVFormatInfoTable[pDevExt->VideoFormatIndex].FractionNumber);  

    //
    // Format an attach frame request
    //
    DVFormatAttachFrame(
        pStrmExt->pStrmInfo->DataFlow,
        pStrmExt,
        pAVReq,
        pSrb,
        pSrbDataPacket,
        ulSrcPktLen,
        ulFrameSize,
        pFrameBuffer
        );

    // Completion callback can be called before the attach frame completion routine;
    // Add this to the attached list now; if it ever failed, it will be removed in the completion routine.
    InsertTailList(&pStrmExt->DataAttachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached++;
    (*plSrbUseCount) ++;  // ++ for being in queue
    ASSERT(*plSrbUseCount > 0);

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);        


    NextIrpStack = IoGetNextIrpStackLocation(pSrbDataPacket->pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pSrbDataPacket->AVReq;

    IoSetCompletionRoutine(
        pSrbDataPacket->pIrp, 
        DVAttachFrameCR, 
        pSrbDataPacket, 
        TRUE, 
        TRUE, 
        TRUE
        );

    // Must set to _PENDING or MediaSample will return empty KSSTREAM_HEADER    
    pSrb->Status = STATUS_PENDING;
    pSrbDataPacket->pIrp->IoStatus.Status = STATUS_SUCCESS;  // Initialize it 

    Status = IoCallDriver( pStrmExt->pDevExt->pBusDeviceObject, pSrbDataPacket->pIrp);

    ASSERT(Status == STATUS_PENDING || Status == STATUS_SUCCESS);

    return;

ExitReadStreamError:

    StreamClassStreamNotification(          
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb 
        );
#if DBG
    pStrmExt->cntSRBPending--;
#endif
}


ULONG
DVCompleteSrbWrite(
    PCIP_NOTIFY_INFO     pInfo
    )
/*++

Routine Description:

    This fucntion is called when 61883 has completed transmitting a frame.

--*/
{
    PSRB_DATA_PACKET          pSrbDataPacket ;
    PHW_STREAM_REQUEST_BLOCK  pSrb; 
    NTSTATUS                  Status = STATUS_SUCCESS; 
    PDVCR_EXTENSION           pDevExt;
    PSTREAMEX                 pStrmExt;  
    PLONG plSrbUseCount; // When this count is 0, it can be completed.
    KIRQL oldIrql;
#if DBG
    LONG lCycleCountElapsed;
    PXMT_FRAME_STAT pXmtStat;
#endif



    // Callback and in DISPATCH_LEVEL
    // Caller might have acquired SpinLock as well!
    pSrbDataPacket = pInfo->Context;

    if(!pSrbDataPacket) {
        ASSERT(pSrbDataPacket);
        return 1;
    }


    pStrmExt = pSrbDataPacket->pStrmExt;
    ASSERT(pStrmExt);

    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

    ASSERT(pSrbDataPacket->pSrb);

    pSrb     = pSrbDataPacket->pSrb;

    pDevExt  = pStrmExt->pDevExt;
    plSrbUseCount = (PLONG) pSrb->SRBExtension;

    // Check return Status
    if(!NT_SUCCESS(pSrbDataPacket->Frame->Status)) {        
        TRACE(TL_CIP_ERROR,("\'DVCompleteSrbWrite: %d: Frame->Status %x\n", (DWORD) pSrbDataPacket->FrameNumber, pSrbDataPacket->Frame->Status));
        ASSERT(NT_SUCCESS(pSrbDataPacket->Frame->Status));
        pSrb->Status = STATUS_UNSUCCESSFUL;            
    }
    else {
        pSrb->Status = STATUS_SUCCESS;
    }

    (*plSrbUseCount) --;          // This count need to be 0 before the SRB is completed.
    ASSERT(*plSrbUseCount >= 0);

#if DBG
    if(pSrbDataPacket->StreamState == KSSTATE_PAUSE) {
        pStrmExt->lPrevCycleCount = pSrbDataPacket->Frame->Timestamp.CL_CycleCount;
        pStrmExt->lTotalCycleCount = 0;
        pStrmExt->lFramesAccumulatedRun = 0;
        pStrmExt->lFramesAccumulatedPaused++;

    } else if(pSrbDataPacket->StreamState == KSSTATE_RUN) {

        if((LONG) pSrbDataPacket->Frame->Timestamp.CL_CycleCount > pStrmExt->lPrevCycleCount) 
            lCycleCountElapsed = pSrbDataPacket->Frame->Timestamp.CL_CycleCount - pStrmExt->lPrevCycleCount;
        else
            lCycleCountElapsed = pSrbDataPacket->Frame->Timestamp.CL_CycleCount + 8000 - pStrmExt->lPrevCycleCount;

        if(lCycleCountElapsed <= (LONG) DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets) {
            TRACE(TL_CIP_WARNING, ("\'#### CycleCounts between frames %d <= expected %d + empty pkt?\n", 
                lCycleCountElapsed,
                DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets
                ));
        }

        pStrmExt->lTotalCycleCount += lCycleCountElapsed;
        pStrmExt->lFramesAccumulatedRun++;

        TRACE(TL_CIP_TRACE,("\'%d) Attached:%d; pSrb:%x; FmSt:%x; CyTm:[SC:%d:CC:%d]; CyclElaps:%d; fps:%d/%d\n",
            (DWORD) pSrbDataPacket->FrameNumber,
            pStrmExt->cntDataAttached,
            pSrb,
            pSrbDataPacket->Frame->Status,
            pSrbDataPacket->Frame->Timestamp.CL_SecondCount,
            pSrbDataPacket->Frame->Timestamp.CL_CycleCount,
            lCycleCountElapsed,
            pStrmExt->lTotalCycleCount,
            (DWORD) pStrmExt->lFramesAccumulatedRun
            ));

        pStrmExt->lPrevCycleCount = pSrbDataPacket->Frame->Timestamp.CL_CycleCount;
    } else {
        TRACE(TL_CIP_ERROR,("\'This data was attached at %d state ?????\n", pSrbDataPacket->StreamState));
    }


#endif

    TRACE(TL_CIP_INFO,("\'%d) FmSt %x; Cnt %d; CyTm:[%d:%d:%d]; PrevCyclCnt:%d\n", 
        (DWORD) pSrbDataPacket->FrameNumber,
        pSrbDataPacket->Frame->Status,
        *plSrbUseCount,
        pSrbDataPacket->Frame->Timestamp.CL_SecondCount,
        pSrbDataPacket->Frame->Timestamp.CL_CycleCount,
        pSrbDataPacket->Frame->Timestamp.CL_CycleOffset,
        pStrmExt->lPrevCycleCount
        ));    

    TRACE(TL_CIP_INFO,("\'DVCompleteSrbWrite: Frm:%d; Attached:%d; cntUse:%d, Srb:%x; FrmSt:%x; CyclElaps:%d\n",
        (DWORD) pSrbDataPacket->FrameNumber,
        pStrmExt->cntDataAttached,
        *plSrbUseCount,
        pSrb,
        pSrbDataPacket->Frame->Status,
        lCycleCountElapsed
        ));


    //
    // Mark completion is called.
    //
    pSrbDataPacket->State |= DE_IRP_CALLBACK_COMPLETED;


    //
    // Attached->Completed or Completed->Attached.
    //
    if(IsStateSet(pSrbDataPacket->State, DE_IRP_ATTACHED_COMPLETED)) {

        //
        // Recycle it back to the detach list
        //
        RemoveEntryList(&pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached--;  ASSERT(pStrmExt->cntDataAttached >= 0);
        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;

#if DBG
        // Detect if 61883 is starve.  This cause discontinuity.
        // This can happen for many valid reasons (slow system).
        // An assert is added to detect other unknown reason.
        if(!pStrmExt->bEOStream && pStrmExt->cntDataAttached == 0 && pStrmExt->StreamState == KSSTATE_RUN) {
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\n**** 61883 starve in RUN state (write);AQD[%d:%d:%d]\n\n", 
                pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached
            ));
            if (pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
                // ASSERT(pStrmExt->cntDataAttached > 0 && "61883 is starve at RUN state!!");
            }
        }
#endif

        // Complete this SRB only if the count is 0.
        if(*plSrbUseCount == 0) {

            TRACE(TL_CIP_TRACE,("\'------------ Srb:%x completing..----------------\n", pSrb));
            // Frame that possibly made it to the device
            pStrmExt->FramesProcessed++;
            pSrb->CommandData.DataBufferArray->DataUsed = DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize;

            StreamClassStreamNotification(StreamRequestComplete, pStrmExt->pStrmObject, pSrbDataPacket->pSrb );  
            pSrbDataPacket->State |= DE_IRP_SRB_COMPLETED;  pSrbDataPacket->pSrb = NULL;
#if DBG
            pStrmExt->cntSRBPending--;
#endif
        }

    } else {

        TRACE(TL_STRM_WARNING,("CompleteSrbWrite: pSrbDataPacket:%x; Completed before attach.\n", pSrbDataPacket));

    }


#if DBG
    // Collect transmit buffer statistics
    if((pStrmExt->lFramesAccumulatedPaused + pStrmExt->lFramesAccumulatedRun) <= MAX_XMT_FRAMES_TRACED) {
        pXmtStat = pStrmExt->paXmtStat + (pStrmExt->lFramesAccumulatedPaused + pStrmExt->lFramesAccumulatedRun - 1);
        pXmtStat->tsTransmitted  = pSrbDataPacket->Frame->Timestamp;
        if(pSrbDataPacket->Frame->Timestamp.CL_CycleCount == 0) {
            TRACE(TL_CIP_WARNING,("\'PAUSE:%d; RUN:%d; %d:%d\n", pStrmExt->lFramesAccumulatedPaused, pStrmExt->lFramesAccumulatedRun,
                pSrbDataPacket->Frame->Timestamp.CL_SecondCount, pSrbDataPacket->Frame->Timestamp.CL_CycleCount));
        }        
    }
#endif


    // Signal that all SRBs have been attached and transmitted.
    if(pStrmExt->bEOStream) {
        if(pStrmExt->cntDataAttached == 0 && pStrmExt->cntSRBQueued == 0) {

            //
            // Signal any pending clock events
            //
            DVSignalClockEvent(0, pStrmExt, 0, 0);

            //
            // No data request queued or pending; it is time to signal EOStream to 
            // trigger EC_COMPLETE.
            //
            StreamClassStreamNotification(
                SignalMultipleStreamEvents,
                pStrmExt->pStrmObject,
                (GUID *)&KSEVENTSETID_Connection_Local,
                KSEVENT_CONNECTION_ENDOFSTREAM
                ); 

            TRACE(TL_CIP_WARNING,("\'*-*-* EOStream Signalled: pSrb:%x completed; AQD [%d:%d:%d]; Took %d msec;\n", 
                pSrb, pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached,
                (DWORD) ((GetSystemTime() - pStrmExt->tmStreamStart)/(ULONGLONG) 10000)));
        }
        else {
            TRACE(TL_CIP_TRACE,("\'   *EOStream: pSrb:%x completed; cntAttached:%d; cntSRBQ:%d\n", pSrb, (DWORD) pStrmExt->cntDataAttached, (DWORD) pStrmExt->cntSRBQueued));
        }
    } 


    //
    // If we are not in the ending situtation (EOS pr Stop state) and number of
    // attach data request is below a threashold, we singal an event to the
    // code that does "throttle" to quickly attach another frame.
    //

    if(!pStrmExt->bEOStream || 
       (pStrmExt->bEOStream && pStrmExt->cntSRBQueued > 0)) {

        if(pStrmExt->StreamState != KSSTATE_STOP && 
           pStrmExt->cntDataAttached < NUM_BUF_ATTACHED_THEN_ISOCH) {
            KeSetEvent(&pStrmExt->hSrbArriveEvent, 0, FALSE);
            TRACE(TL_CIP_WARNING,("Threadshold:.AQD:[%d %d %d] < %d\n",
                pStrmExt->cntDataAttached,
                pStrmExt->cntSRBQueued,
                pStrmExt->cntDataDetached,
                NUM_BUF_ATTACHED_THEN_ISOCH
                ));
        }
    }

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 

    return 0;
} // DVCompleteSrbWrite



NTSTATUS
DVAttachWriteFrame(
    IN PSTREAMEX  pStrmExt
    )
/*++

Routine Description:

    Prepare and submit a frame to 61883 for transmit.   

--*/
{
    KIRQL   oldIrql;
    PSRB_DATA_PACKET pSrbDataPacket;
    PSRB_ENTRY  pSrbEntry;
#if DBG
    ULONG  SrbNumCache;  // Cache the SRB number of tracking purpose
    PXMT_FRAME_STAT pXmtStat;
#endif
    PHW_STREAM_REQUEST_BLOCK pSrb;
    PHW_STREAM_REQUEST_BLOCK pSrbNext; 
    PVOID               pFrameBuffer;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS Status;
    PLONG plSrbUseCount; // When this count is 0, it can be completed.
    ULONG  ulSrcPktLen;
    LARGE_INTEGER Timeout;  


    PAGED_CODE();


    // Serialize setting state to STOP
    if(pStrmExt->StreamState != KSSTATE_PAUSE && 
       pStrmExt->StreamState != KSSTATE_RUN) {

        TRACE(TL_CIP_WARNING,("\'DVAttachWriteFrame: StreamState:%d; no attach! Wait!\n", pStrmExt->StreamState));              
        Timeout.HighPart = -1;
        Timeout.LowPart  = (ULONG)(-1 * DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame); 
        KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
        return STATUS_SUCCESS; 
    }


    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);

    if(IsListEmpty(&pStrmExt->SRBQueuedListHead) ||
       IsListEmpty(&pStrmExt->DataDetachedListHead) ) {              
        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
#if DBG        
        if(!pStrmExt->bEOStream) {
            TRACE(TL_CIP_WARNING,("\'StrmSt:%d; DetachList or SrbQ empty: EOStream:%d; AQD [%d:%d:%d]; Wait one frame time.\n", 
                pStrmExt->StreamState,
                pStrmExt->bEOStream,
                pStrmExt->cntDataAttached,
                pStrmExt->cntSRBQueued,
                pStrmExt->cntDataDetached
                ));
        }
#endif
        Timeout.HighPart = -1;
        Timeout.LowPart  = (ULONG)(-1 * DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame); 
        KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
        // SRB is queued so it is OK. We will process that later.
        // This is usually cause by receiving more than what we pre-allocate.
        return STATUS_SUCCESS; 
    }


    // KSSTATE_PAUSE: "reuse" head of the SrbQ.
    // KSSTATE_RUN:   "remove" a Srb from the queue.

      
    // Get NEXT(SrbQ) and determine if it needs to be removed.
    pSrbEntry = (PSRB_ENTRY) pStrmExt->SRBQueuedListHead.Flink; pSrb = pSrbEntry->pSrb; plSrbUseCount = (PLONG) pSrb->SRBExtension;
    ASSERT(*plSrbUseCount >= 0);
#if DBG
    SrbNumCache = pSrbEntry->SrbNum;
#endif

    // Get a a nonpaged system-space virtual address for the buffer
    // This could fail it there is not enough system resource (MDL).
#ifdef USE_WDM110 // Win2000
    //
    // Driver verifier flag to use this but if this is used, this driver will not load for Millen!!!
    //
    pFrameBuffer = MmGetSystemAddressForMdlSafe(pSrb->Irp->MdlAddress, NormalPagePriority);
#else
    pFrameBuffer = MmGetSystemAddressForMdl    (pSrb->Irp->MdlAddress);
#endif
    if(pFrameBuffer == NULL) {      
        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
        ASSERT(FALSE && "Insufficient MDL\n");
        return STATUS_INSUFFICIENT_RESOURCES; 
    }

    // Only in RUN state, the stream time in the Srb is considered and Srbs in the SrbQ will be dequeued.
    if(pStrmExt->StreamState == KSSTATE_RUN) {

#define ALLOWABLE_TIMING_LATENCY TIME_PER_CYCLE

        // Presentation time is honor only if we are the master clock.
        if(pStrmExt->hMasterClock) {

            LONGLONG tmExpectedFrame;


            if(   pStrmExt->pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_PAL 
               || pStrmExt->pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_PAL
               )
                tmExpectedFrame = pStrmExt->PictureNumber * (LONGLONG) FRAME_TIME_PAL;
            else {
                tmExpectedFrame = (pStrmExt->PictureNumber * (LONGLONG) 1000 * (LONGLONG) 1001 ) / (LONGLONG) 3;  // trouble NTSC!
                // Adjustment for rounding
                if((pStrmExt->PictureNumber % 3) == 1)
                    tmExpectedFrame++;
            }

            // Use to adjust the querued stream time.
            pStrmExt->LastSystemTime = GetSystemTime();

            // There are three situations about the NEXT(SrbQ) comparing with tmExpectedFrame:            
            //    1. Early; 2. OnTime; 3.Late
            //
            //                  tmExpectedFrame
            //                        |
            // 3>------------2>-----------------1>---------------
            //    3.Late     |   2.On  Time     |  1.Early
            //               |    x   |   x     |
            //  where "x" is the allowable latency (for calculation rounding)
            //
            // Note: allow TIME_PER_CYCLE latency                 
/*Early*/   
/*N+1/++*/  if((tmExpectedFrame + ALLOWABLE_TIMING_LATENCY) <= pSrb->CommandData.DataBufferArray->PresentationTime.Time) { 
            // FUTURE: if a frame arrive sooner than expected, do not remove SrbQ; 
            // instead, repeat until passing its "scheduled departure".

                // Remove NEXT(SrbQ) only if bEOStream
                if(pStrmExt->bEOStream) {
                    TRACE(TL_CIP_TRACE,("\'EOStream=== Srb:%x; (SrbNum:%d ?= PicNum:%d) cntSrbQ:%d; Attach:%d ===\n", 
                        pSrb, pSrbEntry->SrbNum, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->cntSRBQueued, (DWORD) pStrmExt->cntDataAttached));
                    RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                    ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it! 
                }                         
                TRACE(TL_CIP_TRACE,("\'** Repeat: pSrb:%x; RefCnt:%d; cntSrbQ:%d; PicNum:%d; Drp:%d; PresTime:%d >= CurTime:%d\n", 
                    pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->FramesDropped, 
                    (DWORD) (pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000), (DWORD) tmExpectedFrame/10000));                

/*OnTime*/  } else 
/* N */     if((tmExpectedFrame - ALLOWABLE_TIMING_LATENCY) <= pSrb->CommandData.DataBufferArray->PresentationTime.Time) {
            // ON-TIME: may exactly matching or due to integer calculation, within one frame time.
            // Dequeue if there are more than one Srb in the queue. 
#if DBG
                // Detect if a pSrb is used more than once
                if((*plSrbUseCount) > 1) {                   
                    TRACE(TL_CIP_TRACE,("\'* Go: pSrb:%x; RefCnt:%d; cntSrbQ:%d; PicNum:%d; Drp:%d; PresTime:%d >= CurTime:%d\n", 
                        pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->FramesDropped, 
                        (DWORD) (pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000), (DWORD) tmExpectedFrame/10000)); 
                }
#endif
                if(pStrmExt->bEOStream) {
                // Remove NEXT(SrbQ) only if there are more than one SRB or bEOStream
                    TRACE(TL_CIP_TRACE,("\'EOStream=== Srb:%x; (SrbNum:%d ?= PicNum:%d) cntSrbQ:%d; Attach:%d ===\n", 
                        pSrb, pSrbEntry->SrbNum, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->cntSRBQueued, (DWORD) pStrmExt->cntDataAttached));
                    RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                    ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it! 
                // Remove SRB if more than one SRBs in Q and there is not a discontinuity, or end of stream.
                } else if(pStrmExt->cntSRBQueued > 1) {
                    LONGLONG tmExpectedNextFrame = tmExpectedFrame + DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame;

                    pSrbNext = ((SRB_ENTRY *) (pSrbEntry->ListEntry.Flink))->pSrb;                        

                    // Next SRB has the next presentation time
                    // May add this check as well: (but check Presentation time is more reliable)
                    //    pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY
/* N,N+1 */         if((tmExpectedNextFrame + ALLOWABLE_TIMING_LATENCY) > pSrbNext->CommandData.DataBufferArray->PresentationTime.Time) { 

                        TRACE(TL_CIP_TRACE,("\'=== Srb:%x; (SrbNum:%d ?= PicNum:%d) cntSrbQ:%d; Attach:%d ===\n", 
                           pSrb, pSrbEntry->SrbNum, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->cntSRBQueued, (DWORD) pStrmExt->cntDataAttached));
                        RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                        ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it! 

/* N, N+2/++ */     } else {
                        TRACE(TL_CIP_TRACE,("\'=== GO(Stale=TRUE) Srb:%x; (SrbNum:%d ?= PicNum:%d) Attach:%d ==\n", 
                            pSrb, pSrbEntry->SrbNum, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->cntDataAttached));
                        // Mark this stale and be remove as soon as another is attached.
                    }                       
                } 
                else {
                    TRACE(TL_CIP_TRACE,("\'=== GO(Stale=TRUE) Srb:%x; (SrbNum:%d ?= PicNum:%d) Attach:%d ==\n", 
                        pSrb, pSrbEntry->SrbNum, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->cntDataAttached));
                    // Mark this stale and be remove as soon as another is attached.
                    pSrbEntry->bStale = TRUE;
                }

                 // CLOCK: tick when a frame is transmitted.   
        
            // LATE: this is dropped until there is only one Srb in the SrbQ.
            // WORKITEM: we may need to implement IQualityManagement to inform application to read ahead.
/*Late*/    } 
/*N-1*/     else {

                if(pStrmExt->cntSRBQueued > 1) {

                    pSrbNext = ((SRB_ENTRY *) (pSrbEntry->ListEntry.Flink))->pSrb;                        

                    // Next SRB has the next presentation time; it can be:
                    // Current time is N
                    // Current frame is late (N-1 or N-2..) and we have more than one Srb in the queue; 
                    // check next frame:
                    //     (N?)
                    // N-2, N-1, N  late more than one frame; (Next frame is also late; dequeu and not transmit; "catch up" case.)
                    // N-1, N       late one frame; (Next frame is on time; dequeu this frame) <-- Normal case
                    // N-1, N+1     late one frame, but next frame is not N+1; (Next frame is early; *current frame will be repeated*) 
                    // 
                    // May add this check this as well: (but check Presentation time is more reliable)
                    //    pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY
                    //
                    // ******************************************************************************************************
                    // If next frame is earlier than current stream time, "repeat" current stale frame; else we need to "catch up"!
                    // ******************************************************************************************************     
/* N-1++, N */      if((tmExpectedFrame + ALLOWABLE_TIMING_LATENCY) > pSrbNext->CommandData.DataBufferArray->PresentationTime.Time) {

                        TRACE(TL_CIP_TRACE,("\'*** Stale(not Sent): pSrb:%x; RefCnt:%d; cntSrbQ:%d; cntAtt:%d; PicNum:%d; Drp:%d; PTm:%d < ExpTm:%d\n", 
                            pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, pStrmExt->cntDataAttached, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->FramesDropped, 
                            (DWORD) (pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000), (DWORD) (tmExpectedFrame/10000) )); 

                        // Never been attached; remove late entry
                        RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                        ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it!

                        if(*plSrbUseCount == 0) {
                            // If no reference to is, complete this.
                            pSrb->Status = STATUS_SUCCESS;  // It is not a failure but late; maybe other status to indicate "non-fatal" late status..
                            pSrb->CommandData.DataBufferArray->DataUsed = 0;
                            StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
#if DBG
                            pStrmExt->cntSRBPending--;
#endif
                        }
                       
                        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

                        // Since SrbQ is not empty and this is a stale frame, call recursively to get to next frame.
                        // Only possible error is if there is not sufficient resource (esp MDL)
                        // then, we bail out by self terminating this thread.
                        if(STATUS_INSUFFICIENT_RESOURCES == 
                           DVAttachWriteFrame(pStrmExt)) {
                            TRACE(TL_CIP_ERROR,("DVAttachWriteFrame: STATUS_INSUFFICIENT_RESOURCES\n")); 
                            return STATUS_INSUFFICIENT_RESOURCES;
                        } else {
                            return STATUS_SUCCESS;  // SUCESS unless there is another status to indicate "non-fatal" late.
                        }
/*N-2++, N-1++*/    } else {
                        pSrbEntry->bStale = TRUE;
                    }
                }
                else {
                    // EOStream and is a stale stream, it is the last element in SrbQ.
                    // Remove it.
                    if(pStrmExt->bEOStream) {
                        TRACE(TL_CIP_TRACE,("\'*** Stale(bEOStream): pSrb:%x; RefCnt:%d; cntSrbQ:%d; cntAtt:%d; PicNum:%d; Drp:%d; PTm:%d < ExpTm:%d\n", 
                            pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, pStrmExt->cntDataAttached, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->FramesDropped, 
                            (DWORD) (pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000), (DWORD) (tmExpectedFrame/10000) )); 

                        RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                        ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it!
                        if(*plSrbUseCount == 0) {
                            // If no reference to is, complete this.
                            pSrb->Status = STATUS_SUCCESS;  // It is not a failure but late; maybe other status to indicate "non-fatal" late status..
                            pSrb->CommandData.DataBufferArray->DataUsed = 0;
                            StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
#if DBG
                            pStrmExt->cntSRBPending--;
#endif
                        }
                       
                        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

                        // Update current stream time
                        pStrmExt->CurrentStreamTime = tmExpectedFrame;

                        return STATUS_SUCCESS;  // SUCESS unless there is another status to indicate "non-fatal" late.
                    }

                    TRACE(TL_CIP_TRACE,("\'*** Stale(Sent): pSrb:%x; RefCnt:%d; cntSrbQ:%d; cntAtt:%d; PicNum:%d; Drp:%d; PTm:%d < ExpTm:%d\n", 
                        pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, pStrmExt->cntDataAttached, (DWORD) pStrmExt->PictureNumber, (DWORD) pStrmExt->FramesDropped, 
                        (DWORD) (pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000), (DWORD) (tmExpectedFrame/10000) )); 

                    // If this is stale and this is the only frame in SrbQ, Xmt it
                }

                // If late, this frame is always drop.
                pStrmExt->FramesDropped++;
            } 

            // Update current stream time
            pStrmExt->CurrentStreamTime = tmExpectedFrame;

        } // if(pStrmExt->hMasterClock)
        else {
            // Not the master clock, no "pacing" so always dequeu (SrbQ) and transmit 
            // as long as there is one Srb in the queue.
            if(pStrmExt->cntSRBQueued > 1 || pStrmExt->bEOStream) {
                RemoveEntryList(&pSrbEntry->ListEntry); pStrmExt->cntSRBQueued--; (*plSrbUseCount)--;
                ExFreePool(pSrbEntry);  pSrbEntry = NULL;  // Removed so free it!
            }
            TRACE(TL_CIP_TRACE,("\'* GO: (NoClock) pSrb:%x; RefCnt:%d; cntSrbQ:%d; PicNum:%d;\n", pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued, (DWORD) pStrmExt->PictureNumber));
        } // if(pStrmExt->hMasterClock)


        // pStrmExt->FramesProcessed is updated when a frame has been transmitted in the notify routine.
        // **** THIS IS THE CLOCK TICK ****
        pStrmExt->PictureNumber++;  // After tmExpectedFrame is calculated; Another frame to be attached
        if(pStrmExt->hMasterClock) {
#ifdef SUPPORT_QUALITY_CONTROL
            // +: late; -: early
            pStrmExt->KSQuality.DeltaTime = pStrmExt->CurrentStreamTime - pSrb->CommandData.DataBufferArray->PresentationTime.Time;
            // Percentage * 10 of frame transmitted
            pStrmExt->KSQuality.Proportion = (ULONG) 
                ((pStrmExt->PictureNumber - pStrmExt->FramesDropped) * 1000 / pStrmExt->PictureNumber);
            pStrmExt->KSQuality.Context = /* NOT USED */ 0; 
#define MIN_ATTACH_BUFFER  3
            // This is where we may want to signal that we are near Famine!!
            if (pStrmExt->KSQuality.DeltaTime > 
                (DV_NUM_OF_XMT_BUFFERS - MIN_ATTACH_BUFFER) * DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame) {
                TRACE(TL_CIP_TRACE,("\'QualityControl: pic#%d; drop:%d; Prop:%d; DeltaTime:%d (Srb.tmPres:%d, tmStream:%d)\n",
                    (DWORD) pStrmExt->PictureNumber, 
                    (DWORD) pStrmExt->FramesDropped,
                    pStrmExt->KSQuality.Proportion,
                    (DWORD) pStrmExt->KSQuality.DeltaTime/10000,
                    (DWORD) pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000,
                    (DWORD) pStrmExt->CurrentStreamTime/10000                    
                    ));
            }
#endif
        }
    }  // KSSTATE_RUN

#if DBG
    // Collect transmit buffer statistics    
    if(pStrmExt->ulStatEntries < MAX_XMT_FRAMES_TRACED) {
        pXmtStat = pStrmExt->paXmtStat + pStrmExt->ulStatEntries;
    
        pXmtStat->StreamState    = pStrmExt->StreamState;

        pXmtStat->cntSRBReceived = (LONG) pStrmExt->cntSRBReceived;
        pXmtStat->cntSRBPending  = (LONG) pStrmExt->cntSRBPending;
        pXmtStat->cntSRBQueued   = (LONG) pStrmExt->cntSRBQueued;
        pXmtStat->cntDataAttached= pStrmExt->cntDataAttached;

        pXmtStat->FrameSlot      = (DWORD) pStrmExt->PictureNumber;
        pXmtStat->tmStreamTime   = pStrmExt->CurrentStreamTime;

        pXmtStat->DropCount      = (DWORD) pStrmExt->FramesDropped;

        pXmtStat->FrameNumber    = SrbNumCache;
        pXmtStat->OptionsFlags   = pSrb->CommandData.DataBufferArray->OptionsFlags;
        pXmtStat->tmPresentation = pSrb->CommandData.DataBufferArray->PresentationTime.Time;

        // get the actual CyclTime when the frame is transmitted in the completion routine.

        pStrmExt->ulStatEntries++;
    }
    
#endif

#ifdef MSDV_SUPPORT_MUTE_AUDIO
    // pSrbEntry could have been freed; if it has not and useCnt>1, then it could be a repeat frame.
    if(pSrbEntry && (*plSrbUseCount) > 1) {  
        // Set it only once
        if(!pSrbEntry->bAudioMute)
            pSrbEntry->bAudioMute = 
                DVMuteDVFrame(pStrmExt->pDevExt, pFrameBuffer, TRUE);
    }
#endif
 


    // Get a data packet node as the context and list node

    pSrbDataPacket = (PSRB_DATA_PACKET) RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
    
    ulSrcPktLen = \
        (DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].DataBlockSize << 2) * \
            (1 << DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].FractionNumber);  

    // Format an attach frame request
    DVFormatAttachFrame(
        pStrmExt->pStrmInfo->DataFlow,
        pStrmExt,
        &pSrbDataPacket->AVReq,
        pSrb,
        pSrbDataPacket,
        ulSrcPktLen,
        DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulFrameSize,
        pFrameBuffer
        );

    TRACE(TL_CIP_INFO,("\'------ New>> UseCnt:%d; pAVReq:%x; Srb:%x; DtaPkt:%x; AQD [%d:%d:%d]\n",
        *plSrbUseCount,
        &pSrbDataPacket->AVReq, 
        pSrb, 
        pSrbDataPacket,
        pStrmExt->cntDataAttached,
        pStrmExt->cntSRBQueued,
        pStrmExt->cntDataDetached
        ));
 
    // Add this to the attached list
    InsertTailList(&pStrmExt->DataAttachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataAttached++;
    (*plSrbUseCount) ++;  // ++ for being in queue
    ASSERT(*plSrbUseCount > 0);        

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 

    NextIrpStack = IoGetNextIrpStackLocation(pSrbDataPacket->pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pSrbDataPacket->AVReq;

    IoSetCompletionRoutine(
        pSrbDataPacket->pIrp, 
        DVAttachFrameCR, 
        pSrbDataPacket, 
        TRUE, 
        TRUE, 
        TRUE
        );

    pSrbDataPacket->pIrp->IoStatus.Status = STATUS_SUCCESS;  // Initialize it to something

    Status = IoCallDriver( pStrmExt->pDevExt->pBusDeviceObject, pSrbDataPacket->pIrp);

    ASSERT(Status == STATUS_PENDING || Status == STATUS_SUCCESS);

    if(!NT_SUCCESS(Status)) {
        // put the resource back!
        TRACE(TL_CIP_ERROR,("DVAttachWriteFrame: Failed to attach; St:%x\n", Status));
        ASSERT(FALSE && "Failed to attach a Xmt frame.");
    }


    //
    // This is our throttle that regulate data attach to DV:
    //
    // This function is called by the attach thread which is running in an infinite loop.
    // This function need to utilize the buffer that it receive and its repeat mechanism to 
    // regulate the incoming buffer from client and outgoing buffer attach to 1394 stadck for transmit.
    // One way is to wait while there is certain number of frame already attach.

    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
    if(!pStrmExt->bEOStream &&
        // Need to keep NUM_BUF_ATTACHED_THEN_ISOCH buffer attached at all time to keep 61883 isoch xmt going.
       (pStrmExt->StreamState == KSSTATE_RUN   && pStrmExt->cntDataAttached >  NUM_BUF_ATTACHED_THEN_ISOCH || 
        pStrmExt->StreamState == KSSTATE_PAUSE && pStrmExt->cntDataAttached >= NUM_BUF_ATTACHED_THEN_ISOCH )
        ) {
        NTSTATUS StatusDelay = STATUS_SUCCESS;
#if DBG
        ULONGLONG tmStart = GetSystemTime();
        TRACE(TL_CIP_TRACE,("\'[Pic# %d]; SrbNum:%d; Dropped:%d; pSrb:%x; StrmSt:%d; EOS:%d; AQD:[%d;%d;%d]; ",  
            (DWORD) pStrmExt->PictureNumber, SrbNumCache, (DWORD) pStrmExt->FramesDropped, pSrb, pStrmExt->StreamState, pStrmExt->bEOStream,
            pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued, pStrmExt->cntDataDetached));
#endif
        Timeout.HighPart = -1;
        Timeout.LowPart  = (ULONG)(-1 * DVFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].ulAvgTimePerFrame * \
            (pStrmExt->StreamState == KSSTATE_PAUSE ? 1 : (pStrmExt->cntDataAttached - NUM_BUF_ATTACHED_THEN_ISOCH))) ; 

        // Wait the full time until we are very low in SrbQ or Attached buffers.
        if(pStrmExt->cntSRBQueued <= 1 && pStrmExt->cntDataAttached <= NUM_BUF_ATTACHED_THEN_ISOCH) {

            // Signal (instead of delay thread) when a new frame arrive (or signal by CR when pipeline is low)
            KeClearEvent(&pStrmExt->hSrbArriveEvent);

            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); // Guard against pStrmExt->cntSRBQueued

            // Down to one frame so we will wait for an event and will be signalled 
            // when a new frame has arrived, or
            // when number of attach buffer is below the minimum.

            StatusDelay = 
                KeWaitForSingleObject(
                    &pStrmExt->hSrbArriveEvent, 
                    Executive, 
                    KernelMode, 
                    FALSE, 
                    &Timeout
                    );
        } 
        else {
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 
            // Wait for frame(s) to be delivered; this is our throttle..
            // The timeout period can be one or up to 
            // (pStrmExt->cntDataAttached - NUM_BUF_ATTACHED_THEN_ISOCH) frames
            KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
        }

#if DBG
        TRACE(TL_CIP_TRACE,("\'Wait(ST:%x) %d nsec!\n", StatusDelay, (DWORD) ((GetSystemTime() - tmStart)/10)));
#endif
    } else {
        KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 
    }

    return Status;
}


VOID
DVFormatAttachFrame(
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt,    
    IN PAV_61883_REQUEST   pAVReq,
    IN PHW_STREAM_REQUEST_BLOCK       pSrb,
    IN PSRB_DATA_PACKET pSrbDataPacket,
    IN ULONG            ulSourceLength,    // Packet length in bytes
    IN ULONG            ulFrameSize,        // Buffer size; may contain one or multiple source packets
    IN PVOID            pFrameBuffer
    )
/*++

Routine Description:

    Format an attach frame request.

--*/
{

    ASSERT(pSrb);


    //
    // Setup PSRB_DATA_PACKET, except its Frame structure (PCIP_APP_FRAME)
    //

    InitializeListHead(&pSrbDataPacket->ListEntry);

    pSrbDataPacket->State       = DE_PREPARED;   // Initial state of a resued DataEntry (start over!)

    pSrbDataPacket->pSrb        = pSrb;
    pSrbDataPacket->StreamState = pStrmExt->StreamState;    // StreamState when this buffer is attached.
    pSrbDataPacket->pStrmExt    = pStrmExt;
    pSrbDataPacket->FrameBuffer = pFrameBuffer;

    ASSERT(pSrbDataPacket->FrameBuffer != NULL);

    pSrbDataPacket->Frame->pNext           = NULL;
    pSrbDataPacket->Frame->Status          = 0;
    pSrbDataPacket->Frame->Packet          = (PUCHAR) pFrameBuffer;

    if(DataFlow == KSPIN_DATAFLOW_OUT) {
        pSrbDataPacket->FrameNumber            = pStrmExt->cntSRBReceived;
#ifdef NT51_61883

        // This is needed since we have an old 61883.h in Lab06 (according to include path, anyway).
        // Remove this when 61883.h is updated.
#ifndef CIP_RESET_FRAME_ON_DISCONTINUITY
#define CIP_RESET_FRAME_ON_DISCONTINUITY    0x00000040
#endif

        //
        // Set CIP_USE_SOURCE_HEADER_TIMESTAMP to get 25 bit CycleTime from source packet header (13CycleCount:12CycleOffset)
        // Do not set this to get 16 bit CycleTime from isoch packet (3 SecondCount:13CycleCount)
        // 
        pSrbDataPacket->Frame->Flags           =   CIP_VALIDATE_FIRST_SOURCE         // Verify the start of a DV frame
                                                 | CIP_RESET_FRAME_ON_DISCONTINUITY; // No partial frame
#else
        pSrbDataPacket->Frame->Flags           = 0;
#endif
        pSrbDataPacket->Frame->pfnValidate     = DVReadFrameValidate;                // use to validate the 1st source packet
        pSrbDataPacket->Frame->ValidateContext = pSrbDataPacket;
        pSrbDataPacket->Frame->pfnNotify       = DVCompleteSrbRead;
    } 
    else {
        pSrbDataPacket->FrameNumber            = pStrmExt->FramesProcessed;
        pSrbDataPacket->Frame->Flags           = CIP_DV_STYLE_SYT;
        pSrbDataPacket->Frame->pfnValidate     = NULL;
        pSrbDataPacket->Frame->ValidateContext = NULL;
        pSrbDataPacket->Frame->pfnNotify       = DVCompleteSrbWrite;
    }
    pSrbDataPacket->Frame->NotifyContext       = pSrbDataPacket;

    //
    // Av61883_AttachFrames
    //
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_AttachFrame);
    pAVReq->AttachFrame.hConnect     = pStrmExt->hConnect;
    pAVReq->AttachFrame.FrameLength  = ulFrameSize;
    pAVReq->AttachFrame.SourceLength = ulSourceLength;
    pAVReq->AttachFrame.Frame        = pSrbDataPacket->Frame;

    ASSERT(pStrmExt->hConnect);
    ASSERT(pSrbDataPacket->Frame);
}

void
DVSetXmtThreadState(
    PSTREAMEX  pStrmExt,
    XMT_THREAD_STATE  RequestState
) 
/*++

Routine Description:

    Set to a new transmit thread state (running, halt, or terminate). 

--*/ 
{
    if(
        pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN &&
        !pStrmExt->bTerminateThread
      ) {


        if(pStrmExt->XmtState == RequestState) {
            TRACE(TL_STRM_WARNING,("Same state %d -> %d\n", pStrmExt->XmtState, RequestState));
            return;
        }

        //
        // The thread could be parked at the halt state.  In order to transitioning into
        // run state, we need to signal the halt event and then terminate this thread.
        //

        if(pStrmExt->XmtState == THD_HALT &&
           RequestState       == THD_TERMINATE) {

            //
            // Mark that this thread will be terminated.
            //

            pStrmExt->bTerminateThread = TRUE;

            //
            // This thread might in the the halt state.  Signal it so it can be terminated.
            // 

            KeSetEvent(&pStrmExt->hRunThreadEvent, 0, FALSE);

            pStrmExt->XmtState = THD_TERMINATE;
            TRACE(TL_STRM_WARNING,("Halt -> TERMINATE\n"));

            return;
        }

        //
        // Synchonize attach frame with other externial requests.  External thread should
        // first acquire this mutext, set service request, and then release this mutex.
        //

        KeWaitForSingleObject( pStrmExt->XmtThreadMutex, Executive, KernelMode, FALSE, 0);
  
        if(RequestState == THD_HALT) {

            //
            // Non-signal this event to put this thread in the Halt state
            // 

            KeClearEvent(&pStrmExt->hRunThreadEvent);

            pStrmExt->XmtState = THD_HALT;

            TRACE(TL_STRM_WARNING,("-->HALTING\n"));


        } else if (RequestState == THD_TERMINATE) {

            //
            // Mark that this thread will be terminated.
            //

            pStrmExt->bTerminateThread = TRUE;

            pStrmExt->XmtState = THD_TERMINATE;

            TRACE(TL_STRM_WARNING,("-->TERMINATE\n"));

        } else {

            ASSERT(FALSE && "Unexpected thread state change!");
        }

        //
        // Release mutex so other thread can request service
        // 

        KeReleaseMutex(pStrmExt->XmtThreadMutex, FALSE);
    }
}

#define PREROLL_WAITTIME 2000000

VOID
DVAttachFrameThread(
    IN PSTREAMEX pStrmExt
    )  
/*++

Routine Description:

    This is a system thread to attach frame for transmit.

--*/    
{
    NTSTATUS  Status;   
    PDVCR_EXTENSION pDevExt;
    KIRQL OldIrql;
#ifdef SUPPORT_PREROLL_AT_RUN_STATE
    NTSTATUS StatusWFSO;              // return status for WaitForSingleObject()
    LARGE_INTEGER PrerollTimeout;     // Timeout for preroll
#endif

    PAGED_CODE();


#ifdef SUPPORT_PREROLL_AT_RUN_STATE
    PrerollTimeout = RtlConvertLongToLargeInteger(-((LONG) PREROLL_WAITTIME));  
#endif

    pDevExt = pStrmExt->pDevExt;

    //
    // Pump up the priority since we are dealing with real time data
    //

    KeSetPriorityThread(KeGetCurrentThread(), 
#if 1
            LOW_REALTIME_PRIORITY
#else
            HIGH_PRIORITY
#endif
            );

    while (!pStrmExt->bTerminateThread) {

        //
        // Synchonize attach frame with other externial requests.  External thread should
        // first acquire this mutext, set service request, and then release this mutex.
        //

        KeWaitForSingleObject( pStrmExt->XmtThreadMutex, Executive, KernelMode, FALSE, 0);

        //
        // Requested to be terminated by other thread while in above WFSO()?
        //

        if(pStrmExt->bTerminateThread) {
            KeReleaseMutex(pStrmExt->XmtThreadMutex, FALSE);
            goto ThreadTherminating;
        }


        //
        // Has other thread put in a request to put this thread in the HALT state?
        //

        KeWaitForSingleObject( &pStrmExt->hRunThreadEvent, Executive, KernelMode, FALSE, 0);

        //
        // Set (TRUE) this flag only once to indicate this thread has started.
        //

        if(!pStrmExt->bXmtThreadStarted)
            pStrmExt->bXmtThreadStarted = TRUE;

        //
        // Requested to be terminated by other thread while in above WFSO() or HALT state?
        //

        if(pStrmExt->bTerminateThread) {
            KeReleaseMutex(pStrmExt->XmtThreadMutex, FALSE);
            goto ThreadTherminating;
        }

        //
        // Update thread state
        //

        ASSERT(pStrmExt->XmtState != THD_TERMINATE);   // Should terminate instead of coming here!
        ASSERT(pStrmExt->cntSRBReceived > 0);          // Cannot run without data!

#if DBG
        if(pStrmExt->XmtState == THD_HALT) {
            TRACE(TL_STRM_WARNING,("HALT to RUNNING\n"));
        }
#endif
        pStrmExt->XmtState = THD_RUNNING;


        //
        //  Attach write frame(s)
        //

        Status = 
            DVAttachWriteFrame(
                pStrmExt);
    
        if(STATUS_INSUFFICIENT_RESOURCES == Status) {
            TRACE(TL_STRM_ERROR,("STATUS_INSUFFICIENT_RESOURCES while attaching write frame.\n")); 
            pStrmExt->bTerminateThread = TRUE;
            KeReleaseMutex(pStrmExt->XmtThreadMutex, FALSE);
            goto ThreadTherminating;
        }

        //
        // Start Isoch_Talk once we have enough buffers attached.  This number of attached buffer
        // will ensure that there are sufficent buffers for lower stack (61883.sys) to start
        // isoch data transfer.  It is simliar to the preroll that we are doing above.
        // Note: for trasnmit, the data transmission can start in either PAUSE or RUN state.
        //
        if(           
              !pStrmExt->bIsochIsActive  
           && (   pStrmExt->StreamState == KSSTATE_PAUSE 
               || pStrmExt->StreamState == KSSTATE_RUN
              ) 
           && pStrmExt->cntDataAttached >= NUM_BUF_ATTACHED_THEN_ISOCH
          ) { 

            Status = 
                DVStreamingStart(
                    pStrmExt->pStrmInfo->DataFlow,
                    pStrmExt,
                    pDevExt
                    );
        }

        //
        // Release mutex so other thread can request service
        // 

        KeReleaseMutex(pStrmExt->XmtThreadMutex, FALSE);
    }


ThreadTherminating:

    TRACE(TL_STRM_WARNING,("\'*** ThreadTerminating... AQD [%d:%d:%d]\n", 
        pStrmExt->cntDataAttached, 
        pStrmExt->cntSRBQueued,
        pStrmExt->cntDataDetached
        ));

    KeSetEvent(&pStrmExt->hThreadEndEvent, 0, FALSE);  // Signal it to inform requester that this thread is about to be terminated.

    Status = PsTerminateSystemThread(STATUS_SUCCESS);  // Must be called at PASSIVE_LEVEL
    // End of this thread!
}



VOID
DVTerminateAttachFrameThread(
    IN PSTREAMEX  pStrmExt
    )
/*++

Routine Description:

    To terminate the system thread.  It waits for an event that is triggered
    right before PsTerminateSystemThread() is called.

--*/ 
{

    PAGED_CODE();

    TRACE(TL_CIP_WARNING,("\'DVTerminateAttachFrameThread enter\n"));

    //
    // Wake up the DataReady thread and terminate it if not already done so.
    //
    ASSERT(pStrmExt->bIsochIsActive == FALSE && "Terminate therad while IsochActive!");


    //
    // This function can be called from either CloseStrean or SurpriseRemoval;
    // When a DV is surprise removal, this function may get called from both functions.
    // Assuming StreamClass is serializing these two functions, no need to serialize it locally.
    //
    if(pStrmExt->bTerminateThread) {
        TRACE(TL_CIP_ERROR,("DVTerminateAttachFrameThread: Thread already terminated. Was surprise removed?\n"));
        return;
    }

    //
    // Terminate this attach frame thread.
    //

    DVSetXmtThreadState(pStrmExt, THD_TERMINATE);


    KeWaitForSingleObject(               
        &pStrmExt->hThreadEndEvent,
         Executive,
         KernelMode,
         FALSE,
         NULL
         );

    TRACE(TL_STRM_WARNING,("\'Thread terminated!\n"));

    ObDereferenceObject(
         &pStrmExt->pAttachFrameThreadObject
             );

    TRACE(TL_STRM_WARNING,("\'ObDereferenceObject done!\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvuppr.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSDVUppr.c

Abstract:

    Interface code with stream class driver.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "msdvfmt.h"
#include "msdvdef.h"
#include "MsdvGuts.h"  // Function prototypes
#include "MsdvAvc.h"
#include "MsdvUtil.h"

#include "EDevCtrl.h"

#ifdef TIME_BOMB
#include "..\..\inc\timebomb.c"
#endif

// global flag for debugging.  Inlines are defined in dbg.h.  The debug level is set for
// minimal amount of messages.
#if DBG

#define DVTraceMaskCheckIn  TL_PNP_ERROR | TL_STRM_ERROR | TL_61883_ERROR

#define DVTraceMaskDefault  TL_PNP_ERROR   | TL_PNP_WARNING \
                          | TL_61883_ERROR | TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  \
                          | TL_STRM_ERROR  | TL_STRM_WARNING \
                          | TL_CLK_ERROR

#define DVTraceMaskDebug  TL_PNP_ERROR  | TL_PNP_WARNING \
                          | TL_61883_ERROR| TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  | TL_FCP_WARNING \
                          | TL_STRM_ERROR | TL_STRM_WARNING \
                          | TL_CLK_ERROR


#ifdef USE_WDM110   // Win2000 code base
ULONG  DVTraceMask    = DVTraceMaskCheckIn | TL_FCP_ERROR;
#else
ULONG  DVTraceMask    = DVTraceMaskCheckIn;
#endif

ULONG  DVAssertLevel  = 1;  // Turn on assert (>0)
ULONG  DVDebugXmt     = 0;  // Debug data transfer flag; (> 0) to turn it on.

#endif


extern DV_FORMAT_INFO        DVFormatInfoTable[];

//
// Function prototypes
//
VOID
DVRcvStreamDevicePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );
VOID
DVSRBRead(
    IN PKSSTREAM_HEADER pStrmHeader,
    IN ULONG            ulFrameSize,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb        // needs Srb->Status 
    );
NTSTATUS
DVAttachWriteFrame(
    IN PSTREAMEX  pStrmExt
    );
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    ); 

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVRcvStreamDevicePacket)
     #pragma alloc_text(PAGE, DVRcvControlPacket)
     #pragma alloc_text(PAGE, DVRcvDataPacket)
     // #pragma alloc_text(INIT, DriverEntry)
#endif
#endif


VOID
DVRcvStreamDevicePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    This is where most of the interesting Stream requests come to us

--*/
{
    PDVCR_EXTENSION     pDevExt;  
    PAV_61883_REQUEST      pAVReq;
    PIO_STACK_LOCATION  pIrpStack;


    PAGED_CODE();


    //
    // Get these extensions from a SRB
    //
    pDevExt = (PDVCR_EXTENSION) pSrb->HwDeviceExtension; 
    pAVReq  = (PAV_61883_REQUEST) pSrb->SRBExtension;       // Use in IrpSync is OK, 
                             
#if DBG
    if(pSrb->Command != SRB_INITIALIZE_DEVICE && // PowerState is initialize in this SRB so ignore it.
       pDevExt->PowerState != PowerDeviceD0) {
        TRACE(TL_PNP_WARNING,("RcvDevPkt; pSrb:%x; Cmd:%x; Dev is OFF state\n", pSrb, pSrb->Command));
    }
#endif

    TRACE(TL_PNP_TRACE,("\'DVRcvStreamDevicePacket: pSrb %x, Cmd %d, pdevExt %x\n", pSrb, pSrb->Command, pDevExt));

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

    case SRB_INITIALIZE_DEVICE:

        ASSERT(((PPORT_CONFIGURATION_INFORMATION) pSrb->CommandData.ConfigInfo)->HwDeviceExtension == pDevExt);
        pSrb->Status = 
            DVInitializeDevice(
                (PDVCR_EXTENSION) ((PPORT_CONFIGURATION_INFORMATION)pSrb->CommandData.ConfigInfo)->HwDeviceExtension,
                pSrb->CommandData.ConfigInfo,
                pAVReq
                );
        break;



    case SRB_INITIALIZATION_COMPLETE:

        //
        // Stream class has finished initialization.  Get device interface registry value/
        //
        DVInitializeCompleted(
            (PDVCR_EXTENSION) pSrb->HwDeviceExtension); 
        break;


    case SRB_GET_STREAM_INFO:

        //
        // this is a request for the driver to enumerate requested streams
        //
        pSrb->Status = 
            DVGetStreamInfo(
                pDevExt,
                pSrb->NumberOfBytesToTransfer,
                &pSrb->CommandData.StreamBuffer->StreamHeader,
                &pSrb->CommandData.StreamBuffer->StreamInfo
                );
        break;



    case SRB_GET_DATA_INTERSECTION:

        // Since format can dynamically change, we will query new format here.
        // Note: during data intersection, we compare FrameSize and that is 
        // format related.

        if((GetSystemTime() - pDevExt->tmLastFormatUpdate) > FORMAT_UPDATE_INTERVAL) {

            // Get mode of operation (Camera or VCR)
            DVGetDevModeOfOperation(pDevExt);

            if(!DVGetDevSignalFormat(pDevExt, KSPIN_DATAFLOW_OUT,0)) {
                // If querying its format has failed, we cannot open this stream.
                TRACE(TL_STRM_WARNING,("SRB_GET_DATA_INTERSECTION:Failed getting signal format.\n"));
            }
        
            // Update system time to reflect last update
            pDevExt->tmLastFormatUpdate = GetSystemTime();              
        }

        pSrb->Status = 
            DVGetDataIntersection(
                pSrb->CommandData.IntersectInfo->StreamNumber,
                pSrb->CommandData.IntersectInfo->DataRange,
                pSrb->CommandData.IntersectInfo->DataFormatBuffer,
                pSrb->CommandData.IntersectInfo->SizeOfDataFormatBuffer,
                DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize,
                &pSrb->ActualBytesTransferred,
                pDevExt->paCurrentStrmInfo
#ifdef SUPPORT_NEW_AVC            
                ,pDevExt->paCurrentStrmInfo[pSrb->CommandData.IntersectInfo->StreamNumber].DataFlow == KSPIN_DATAFLOW_OUT ? pDevExt->hOPcrDV : pDevExt->hIPcrDV
#endif
                );          
        break;



    case SRB_OPEN_STREAM:

        //
        // Serialize SRB_OPEN/CLOSE_STREAMs
        //
        KeWaitForSingleObject( &pDevExt->hMutex, Executive, KernelMode, FALSE, 0 );

        pSrb->Status = 
            DVOpenStream(
                pSrb->StreamObject,
                pSrb->CommandData.OpenFormat,
                pAVReq
                );

        KeReleaseMutex(&pDevExt->hMutex, FALSE);
        break;



    case SRB_CLOSE_STREAM:

        //
        // Serialize SRB_OPEN/CLOSE_STREAMs
        //
        KeWaitForSingleObject( &pDevExt->hMutex, Executive, KernelMode, FALSE, 0 );

        pSrb->Status = 
            DVCloseStream(
                pSrb->StreamObject,
                pSrb->CommandData.OpenFormat,
                pAVReq
                );
        KeReleaseMutex(&pDevExt->hMutex, FALSE);
        break;



    case SRB_GET_DEVICE_PROPERTY:

        pSrb->Status = 
            DVGetDeviceProperty(
                pDevExt,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
        break;

        
    case SRB_SET_DEVICE_PROPERTY:

        pSrb->Status = 
            DVSetDeviceProperty(
                pDevExt,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
        break;



    case SRB_CHANGE_POWER_STATE:
            
        pIrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

        if(pIrpStack->MinorFunction == IRP_MN_SET_POWER) {
            pSrb->Status = 
                DVChangePower(
                    (PDVCR_EXTENSION) pSrb->HwDeviceExtension,
                    pAVReq,
                    pSrb->CommandData.DeviceState
                    );
        } else 
        if(pIrpStack->MinorFunction == IRP_MN_QUERY_POWER) {
            TRACE(TL_PNP_WARNING,("IRP_MN_QUERY_POWER: PwrSt:%d\n", pDevExt->PowerState)); 
            pSrb->Status = STATUS_SUCCESS;
        }
        else {
            TRACE(TL_PNP_WARNING,("NOT_IMPL POWER_STATE MinorFunc:%d\n", pIrpStack->MinorFunction)); 
            pSrb->Status = STATUS_NOT_IMPLEMENTED; 
        }

        break;


    case SRB_UNKNOWN_DEVICE_COMMAND:

        //
        // We might be interested in unknown commands if they pertain
        // to bus resets.  Bus resets are important cuz we need to know
        // what the current generation count is.
        //
        pIrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

        if(pIrpStack->MajorFunction == IRP_MJ_PNP) {
            if(pIrpStack->MinorFunction == IRP_MN_BUS_RESET) {
            
                DVProcessPnPBusReset(
                    pDevExt
                    );
                
                //  Always success                
                pSrb->Status = STATUS_SUCCESS;
            }        
            else  {
                /* Known: IRP_MN_QUERY_PNP_DEVICE_STATE */
                TRACE(TL_PNP_WARNING,("\'DVRcvStreamDevicePacket: NOT_IMPL; IRP_MJ_PNP IRP_MN_:%x\n",
                    pIrpStack->MinorFunction
                    )); 
                // Canot return STATUS_NOT_SUPPORTED for PNP irp or device will not load.
                pSrb->Status = STATUS_NOT_IMPLEMENTED; 
            } 
        }
        else {
            TRACE(TL_PNP_WARNING,("\'DVRcvStreamDevicePacket: NOT_IMPL; IRP_MJ_ %x; IRP_MN_:%x\n",
                pIrpStack->MajorFunction,
                pIrpStack->MinorFunction
                ));
            // Canot return STATUS_NOT_SUPPORTED for PNP irp or device will not load.
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }
        break;


    case SRB_SURPRISE_REMOVAL:

        TRACE(TL_PNP_WARNING,("\' #SURPRISE_REMOVAL# pSrb %x, pDevExt %x\n", pSrb, pDevExt));
        pSrb->Status = 
             DVSurpriseRemoval(
                 pDevExt,
                 pAVReq
                 );
        break;            


        
    case SRB_UNINITIALIZE_DEVICE:

        TRACE(TL_PNP_WARNING,("\' #UNINITIALIZE_DEVICE# pSrb %x, pDevExt %x\n", pSrb, pDevExt));                   
        pSrb->Status = 
            DVUninitializeDevice(
                (PDVCR_EXTENSION) pSrb->HwDeviceExtension
                );          
        break;           


    default:
            
        TRACE(TL_PNP_WARNING,("\'DVRcvStreamDevicePacket: Unknown or unprocessed SRB cmd 0x%x\n", pSrb->Command));

        //
        // this is a request that we do not understand.  Indicate invalid
        // command and complete the request
        //

        pSrb->Status = STATUS_NOT_IMPLEMENTED; // SUPPORTED;
    }

    //
    // NOTE:
    //
    // all of the commands that we do, or do not understand can all be completed
    // synchronously at this point, so we can use a common callback routine here.
    // If any of the above commands require asynchronous processing, this will
    // have to change
    //
#if DBG
    if (pSrb->Status != STATUS_SUCCESS && 
        pSrb->Status != STATUS_NOT_SUPPORTED &&
        pSrb->Status != STATUS_NOT_IMPLEMENTED &&
        pSrb->Status != STATUS_BUFFER_TOO_SMALL &&
        pSrb->Status != STATUS_BUFFER_OVERFLOW &&
        pSrb->Status != STATUS_NO_MATCH
        && pSrb->Status != STATUS_TIMEOUT
        ) {
        TRACE(TL_PNP_WARNING,("\'pSrb->Command (%x) ->Status:%x\n", pSrb->Command, pSrb->Status));
    }
#endif

    if(STATUS_PENDING != pSrb->Status) {

        StreamClassDeviceNotification(
            DeviceRequestComplete,
            pSrb->HwDeviceExtension,
           pSrb
           );
    } 
    else {

        // Pending pSrb which will be completed asynchronously
        // Does StreamClass allow device SRB to be in the pending state?
        TRACE(TL_PNP_WARNING,("\'DVReceiveDevicePacket:Pending pSrb %x\n", pSrb));
    }
}


VOID
DVRcvControlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Called with packet commands that control the video stream

--*/
{
    PAV_61883_REQUEST   pAVReq;
    PSTREAMEX        pStrmExt;
    PDVCR_EXTENSION  pDevExt;


    PAGED_CODE();

    //
    // Get these three extension from SRB
    //
    pAVReq   = (PAV_61883_REQUEST) pSrb->SRBExtension;  // This is OK to be used us IrpSync operation
    pDevExt  = (PDVCR_EXTENSION) pSrb->HwDeviceExtension;
    pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;      // Only valid in SRB_OPEN/CLOSE_STREAM

    ASSERT(pStrmExt && pDevExt && pAVReq);

    //
    // Default to success
    //
    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

    case SRB_GET_STREAM_STATE:

        pSrb->Status =
            DVGetStreamState( 
                pStrmExt,
                &(pSrb->CommandData.StreamState),
                &(pSrb->ActualBytesTransferred)
                );
        break;
            
    case SRB_SET_STREAM_STATE:
            
        pSrb->Status =
            DVSetStreamState(
                pStrmExt,
                pDevExt,
                pAVReq,
                pSrb->CommandData.StreamState   // Target KSSTATE
               );       
        break;

        
    case SRB_GET_STREAM_PROPERTY:

        pSrb->Status =
            DVGetStreamProperty( 
                pSrb 
                );
        break;


    case SRB_SET_STREAM_PROPERTY:

        pSrb->Status =        
            DVSetStreamProperty( 
                pSrb 
                );
        break;

    case SRB_OPEN_MASTER_CLOCK:
    case SRB_CLOSE_MASTER_CLOCK:

        //
        // This stream is being selected to provide a Master clock.
        //
        pSrb->Status =
            DVOpenCloseMasterClock(                 
                pStrmExt, 
                pSrb->Command == SRB_OPEN_MASTER_CLOCK ? pSrb->CommandData.MasterClockHandle: NULL);
        break;

    case SRB_INDICATE_MASTER_CLOCK:

        //
        // Assigns a clock to a stream.
        //
        pSrb->Status = 
            DVIndicateMasterClock(
                pStrmExt, 
                pSrb->CommandData.MasterClockHandle);
        break;

    case SRB_PROPOSE_DATA_FORMAT:
    
        //
        // The SRB_PROPOSE_DATA_FORMAT command queries the minidriver
        // to determine if the minidriver can change the format of a 
        // particular stream. If the minidriver is able to switch the 
        // stream to the specified format, STATUS_SUCCESS is returned. 
        // Note that this function only proposes a new format, but does
        // not change it. 
        //
        // The CommandData.OpenFormat passes the format to validate.
        // If the minidriver is able to accept the new format, at some 
        // later time the class driver may send the minidriver a format 
        // change, which is indicated by an OptionsFlags flag in a 
        // KSSTREAM_HEADER structure. 
        //
 
        TRACE(TL_STRM_INFO,("\'DVRcvControlPacket: SRB_PROPOSE_DATA_FORMAT\n"));
        if(!DVVerifyDataFormat(
            pSrb->CommandData.OpenFormat, 
            pSrb->StreamObject->StreamNumber,
            DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize,
            pDevExt->paCurrentStrmInfo
            ))  {
            TRACE(TL_STRM_WARNING,("\'DVRcvControlPacket: AdapterVerifyFormat failed.\n"));
            pSrb->Status = STATUS_NO_MATCH;
        }
        break;

    case SRB_PROPOSE_STREAM_RATE:
        pSrb->Status = STATUS_NOT_IMPLEMENTED; // if returned STATUS_NOT_SUPPORTED, it will send EOStream.
        TRACE(TL_STRM_TRACE,("\'SRB_PROPOSE_STREAM_RATE: NOT_IMPLEMENTED!\n"));
        break;
    case SRB_BEGIN_FLUSH:
        pSrb->Status = STATUS_NOT_SUPPORTED;
        TRACE(TL_STRM_TRACE,("\'SRB_BEGIN_FLUSH: NOT_SUPPORTED!\n"));
        break;
    case SRB_END_FLUSH:
        pSrb->Status = STATUS_NOT_SUPPORTED;
        TRACE(TL_STRM_TRACE,("\'SRB_END_FLUSH: NOT_SUPPORTED!\n"));
        break;
    default:

        //
        // invalid / unsupported command. Fail it as such
        //
        TRACE(TL_STRM_WARNING,("\'DVRcvControlPacket: unknown cmd = %x\n",pSrb->Command));
            pSrb->Status = STATUS_NOT_IMPLEMENTED; // SUPPORTED;
    }

    TRACE(TL_STRM_TRACE,("\'DVRcvControlPacket: Command %x, ->Status %x, ->CommandData %x\n",
         pSrb->Command, pSrb->Status, &(pSrb->CommandData.StreamState) ));

    StreamClassStreamNotification(          
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb);
}




VOID
DVRcvDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called with video data packet commands

--*/

{
    PSTREAMEX       pStrmExt;
    PDVCR_EXTENSION pDevExt;

    
    PAGED_CODE();

    pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;  
    pDevExt  = (PDVCR_EXTENSION) pSrb->HwDeviceExtension;

#if DBG
    if(pDevExt->PowerState != PowerDeviceD0) {
        TRACE(TL_STRM_WARNING|TL_PNP_WARNING,("\'SRB_READ/WRITE; PowerSt:OFF; pSrb:%x\n", pSrb));
    }
#endif

    // The stream has to be open before we can do anything.
    if (pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("DVRcvDataPacket: stream not opened for SRB %x. kicking out...\n", pSrb->Command));
        pSrb->Status = STATUS_UNSUCCESSFUL;
        pSrb->CommandData.DataBufferArray->DataUsed = 0;
        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
        return;        
    }


    //
    // Serialize attach, cancel and state change
    //
    KeWaitForSingleObject( pStrmExt->hStreamMutex, Executive, KernelMode, FALSE, 0 );


    TRACE(TL_CIP_TRACE,("\'XXX_DATA(%d, %d);Srb:%x;Flg:%x;FExt:%d:%d\n", 
        (DWORD) pStrmExt->cntSRBReceived, 
        (DWORD) pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000,
        pSrb, 
        pSrb->CommandData.DataBufferArray->OptionsFlags,
        pSrb->CommandData.DataBufferArray->FrameExtent,
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize
        ));

    //
    // determine the type of packet.
    //
    pSrb->Status = STATUS_SUCCESS;

#if DBG
    pStrmExt->cntSRBPending++;
#endif

    switch (pSrb->Command) {

    case SRB_READ_DATA:

        // Rule: 
        // Only accept read requests when in either the Pause or Run
        // States.  If Stopped, immediately return the SRB.

        if (pStrmExt->lCancelStateWorkItem) {
            // TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\'SRB_READ_DATA: Abort while getting SRB_READ_DATA!\n"));                        
            // ASSERT(pStrmExt->lCancelStateWorkItem == 0 && "Encounter SRB_READ_DATA while aborting or aborted.\n");
            pSrb->Status = (pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED);
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            break; 

        } else if( pStrmExt->StreamState == KSSTATE_STOP       ||
            pStrmExt->StreamState == KSSTATE_ACQUIRE    ||
            pStrmExt->hConnect == NULL                  ||    
            pDevExt->bDevRemoved 
            ) {
            TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\'SRB_READ_DATA: (DV->) State %d, bDevRemoved %d\n", pStrmExt->StreamState, pDevExt->bDevRemoved));            
            pSrb->Status = (pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED);
            pSrb->CommandData.DataBufferArray->DataUsed = 0;

            break;
  
        } else {

            TRACE(TL_STRM_INFO|TL_CIP_INFO,("\'SRB_READ_DATA pSrb %x, pStrmExt %x\n", pSrb, pStrmExt));
            pStrmExt->cntSRBReceived++;

            // Set state thread in halt while while Read/Write SRB is being processed
            DVSRBRead(
                pSrb->CommandData.DataBufferArray,
                DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize,
                pDevExt,
                pStrmExt,
                pSrb
                );

            KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 
            
            // Note: This SRB will be completed asynchronously.

            return;
        }
            
        break;
            
    case SRB_WRITE_DATA:

        if( pStrmExt->StreamState == KSSTATE_STOP       ||
            pStrmExt->StreamState == KSSTATE_ACQUIRE    ||
#ifdef SUPPORT_NEW_AVC
            (pStrmExt->hConnect == NULL && !pStrmExt->bDV2DVConnect) ||
#else
            pStrmExt->hConnect == NULL                  ||
#endif
            pDevExt->bDevRemoved     
            ) {
            pSrb->Status = (pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED);
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'SRB_WRITE_DATA: (DV->) State %d, bDevRemoved %d; Status:%x\n", pStrmExt->StreamState, pDevExt->bDevRemoved, pSrb->Status));
            break;  // Complete SRB with error status
            
        } else {

            KIRQL  oldIrql;
            PLONG plSrbUseCount; // When this count is 0, it can be completed.

            TRACE(TL_STRM_INFO|TL_CIP_INFO,("\'SRB_WRITE_DATA pSrb %x, pStrmExt %x\n", pSrb, pStrmExt));

            //
            // Process EOSream frame separately
            //
            if(pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
                TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'*** EOStream: ST:%d; bIsochIsActive:%d; Wait (cndAttached:%d+cndSRQ:%d) to complete......\n", \
                    pStrmExt->StreamState, pStrmExt->bIsochIsActive, pStrmExt->cntDataAttached, pStrmExt->cntSRBQueued));        
                pStrmExt->bEOStream = TRUE;
                KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql); 
                pSrb->Status = STATUS_SUCCESS;
                break;

            } else if(pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
                TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'DVRcvDataPacket:KSSTREAM_HEADER_OPTIONSF_TYPECHANGED.\n"));
                pSrb->CommandData.DataBufferArray->DataUsed = 0;
                // May need to compare the data format; instead of return STATUS_SUCCESS??
                pSrb->Status = STATUS_SUCCESS; // May need to check the format when dynamic format change is allowed.
                break;  

#ifdef SUPPORT_NEW_AVC
            } else if(pStrmExt->bDV2DVConnect) {
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.DataBufferArray->DataUsed = 0;
                TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'SRB_WRITE_DATA: [DV2DV] (pStrmExt:%x), pSrb:%x, FrameExt:%d\n", 
                    pStrmExt, pSrb, pSrb->CommandData.DataBufferArray->FrameExtent));
                break;              
#endif                
            } else {

                PSRB_ENTRY  pSrbEntry;

                //
                // Validation
                //
                if(pSrb->CommandData.DataBufferArray->FrameExtent < DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize) {
                    TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\' FrameExt %d < FrameSize %d\n", pSrb->CommandData.DataBufferArray->FrameExtent, DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize));
                    ASSERT(pSrb->CommandData.DataBufferArray->FrameExtent >= DVFormatInfoTable[pDevExt->VideoFormatIndex].ulFrameSize);
                    pSrb->Status = STATUS_INVALID_PARAMETER;  
                    break;  // Complete SRB with error status                 
                }

                //
                // Dynamically allocate a SRB_ENTRY and append it to SRBQueue
                //
                if(!(pSrbEntry = ExAllocatePool(NonPagedPool, sizeof(SRB_ENTRY)))) {
                    pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
                    pSrb->CommandData.DataBufferArray->DataUsed = 0;
                    break;  // Complete SRB with error status
                }

#if DBG
                if(pStrmExt->bEOStream) {
                    TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("\'SRB_WRITE_DATA: pSrb:%x after EOStream!\n", pSrb));
                }
#endif

                //
                // For statistics
                //
                pStrmExt->cntSRBReceived++;

                //
                // Save SRB and add it to SRB queue
                // No need for spin lock since StreamClass will serialize it for us.
                //
                pSrb->Status = STATUS_PENDING;
                pSrbEntry->pSrb = pSrb; pSrbEntry->bStale = FALSE; pSrbEntry->bAudioMute  = FALSE;
#if DBG
                pSrbEntry->SrbNum = (ULONG) pStrmExt->cntSRBReceived -1;
#endif
                //
                // Note: plSrbUseCount is initialize to 1
                // When it is insert: ++
                // When it is removed: --
                // when this count is 0; it can be completed.
                //
                plSrbUseCount = (PLONG) pSrb->SRBExtension; *plSrbUseCount = 1;  // Can be completed if this is 0

                KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql); 
                InsertTailList(&pStrmExt->SRBQueuedListHead, &pSrbEntry->ListEntry); pStrmExt->cntSRBQueued++;
                TRACE(TL_CIP_INFO,("\'%d) Fresh Srb:%x; RefCnt:%d; cntSrbQ:%d\n", (DWORD) pStrmExt->cntSRBReceived, pSrb, *plSrbUseCount, pStrmExt->cntSRBQueued));
                KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

#ifndef SUPPORT_PREROLL_AT_RUN_STATE
                //
                // Start the thread when it has at least one sample.
                //
                if(pStrmExt->cntSRBReceived == 1) 
                    KeSetEvent(&pStrmExt->hRunThreadEvent, 0 ,FALSE);

                // Will set this event in the preroll state.
#else
                //
                // This is a special condition (with PREROLL):
                //     1. timeout on preroll (and is now in the RUN state), and
                //     2. no media sample
                // This will cause attach frame in the HALT state; so we will signal
                // it upon receiving 1st media sample; then attach frame can run.
                //

                if(   pStrmExt->cntSRBReceived    == 1 
                   && pStrmExt->bPrerollCompleted == TRUE
                   && pStrmExt->bXmtThreadStarted == FALSE)
                {
                    KeSetEvent(&pStrmExt->hRunThreadEvent, 0 ,FALSE);
                    TRACE(TL_STRM_WARNING, ("Special Cond: RUN, HALT, 1st sample."));
                }
#endif

#ifdef SUPPORT_PREROLL_AT_RUN_STATE
                // We can operate "smoothly" if we have N media samples.
                if(pStrmExt->cntSRBReceived == NUM_BUFFER_BEFORE_TRANSMIT_BEGIN) {
                    KeSetEvent(&pStrmExt->hPreRollEvent, 0, FALSE);
                }
#endif
                if(pStrmExt->pAttachFrameThreadObject) {
                    // Signal that a new frame has arrived.
                    KeSetEvent(&pStrmExt->hSrbArriveEvent, 0, FALSE);
                }
                else {
                    TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("\'No thread to attach frame ?\n"));
                }
            }            

            KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 

            return;  // Note: This SRB will be completed asynchronously.
        }

        break;  // Complete SRB with error status 

    default:
        //
        // invalid / unsupported command. Fail it as such
        //
        pSrb->Status = STATUS_NOT_SUPPORTED;
        break;
    }   

    KeReleaseMutex(pStrmExt->hStreamMutex, FALSE); 


    ASSERT(pSrb->Status != STATUS_PENDING);

    // Finally, send the srb back up ...
    StreamClassStreamNotification( 
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb );
#if DBG
    pStrmExt->cntSRBPending--;
#endif
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This where life begins for a driver.  The stream class takes care
    of alot of stuff for us, but we still need to fill in an initialization
    structure for the stream class and call it.

Arguments:

    Context1 - DriverObject
    Context2 - RegistryPath

Return Value:

    The function value is the final status from the initialization operation.

--*/
{

    HW_INITIALIZATION_DATA HwInitData;


    TRACE(TL_PNP_ERROR,("<<<<<<< MSDV.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        TRACE(TL_PNP_ERROR, ("Evaluation period expired!") );
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("DVTraceMask=0x%.8x = 0x[7][6][5][4][3][2][1][0] where\n", DVTraceMask));
    TRACE(TL_PNP_ERROR,("\n"));
    TRACE(TL_PNP_ERROR,("PNP:   [0]:Loading, power state, surprise removal, device SRB..etc.\n"));
    TRACE(TL_PNP_ERROR,("61883: [1]:Plugs, connection, CMP info and call to 61883.\n"));
    TRACE(TL_PNP_ERROR,("CIP:   [2]:Isoch data transfer.\n"));
    TRACE(TL_PNP_ERROR,("AVC:   [3]:AVC commands.\n"));
    TRACE(TL_PNP_ERROR,("Stream:[4]:Data intersec, open/close,.state, property etc.\n"));
    TRACE(TL_PNP_ERROR,("Clock: [5]:Clock (event and signal)etc.\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("dd msdv!DVTraceMask L1\n"));
    TRACE(TL_PNP_ERROR,("e msdv!DVTraceMask <new value> <enter>\n"));
    TRACE(TL_PNP_ERROR,("<for each nibble: ERROR:8, WARNING:4, TRACE:2, INFO:1, MASK:f>\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n\n"));


    //
    // Fill in the HwInitData structure    
    //
    RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);
    HwInitData.HwInterrupt              = NULL;

    HwInitData.HwReceivePacket          = DVRcvStreamDevicePacket;
    HwInitData.HwRequestTimeoutHandler  = DVTimeoutHandler; 
    HwInitData.HwCancelPacket           = DVCancelOnePacket;
    HwInitData.DeviceExtensionSize      = sizeof(DVCR_EXTENSION);   // Per device

    //
    // The ULONG is used in SRB_WRITE_DATA to keep track of 
    // number of times the same SRB was attached for transmit.
    // 
    // Data SRB: ULONG is used (< sizeof(AV_61883_REQ)
    // DeviceControl or StreamControl Srb: AV_61883_REQ is used.
    HwInitData.PerRequestExtensionSize  = sizeof(AV_61883_REQUEST);    // Per SRB
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX);         // Per pin/stream
    HwInitData.FilterInstanceExtensionSize = 0;

    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = sizeof(ULONG) - 1;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    return StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvutil.h ===
//
// Copyright (C) Microsoft Corporation, 1999 - 2000  
//
// MsdvUtil.h
//


VOID
DVDelayExecutionThread(
    ULONG ulDelayMSec
    );

NTSTATUS
DVSubmitIrpSynchWithTimeout(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq,
    IN ULONG             ulTimeoutMSec
    );

NTSTATUS
DVSubmitIrpSynch(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq
    );

//
// Related to DeviceControl
//

NTSTATUS
DVGetUnitCapabilities(
    IN OUT PDVCR_EXTENSION   pDevExt
    );

BOOL
DVGetDevModeOfOperation(   
    IN OUT PDVCR_EXTENSION  pDevExt
    );

BOOL
DVGetDevIsItDVCPro(   
    IN OUT PDVCR_EXTENSION  pDevExt
    );

BOOL
DVGetDevSignalFormat(
    IN PDVCR_EXTENSION  pDevExt,
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt
    );

BOOL 
DVCmpGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    IN BOOL fCompareSubformat,
    IN BOOL fCompareFormatSize
    );

NTSTATUS
DvAllocatePCResource(
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt
    );

NTSTATUS
DvFreePCResource(
    IN PSTREAMEX        pStrmExt
    );

NTSTATUS
DVGetDVPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
   );

#ifdef NT51_61883
NTSTATUS
DVSetAddressRangeExclusive( 
    IN PDVCR_EXTENSION  pDevExt
   );

NTSTATUS
DVGetUnitIsochParam( 
    IN PDVCR_EXTENSION  pDevExt,
    OUT UNIT_ISOCH_PARAMS  * pUnitIoschParams
    );

NTSTATUS
DVCreateLocalPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
    );

NTSTATUS
DVDeleteLocalPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN HANDLE PlugHandle
    );
#endif

NTSTATUS
DVGetPlugState(
    IN PDVCR_EXTENSION   pDevExt,
    IN PSTREAMEX         pStrmExt,
    IN PAV_61883_REQUEST pAVReq
    );

VOID
DVAttachFrameThread(
    IN PSTREAMEX pStrmExt
    );

NTSTATUS
DVCreateAttachFrameThread(
    PSTREAMEX  pStrmExt
    );

VOID
DVTerminateAttachFrameThread(
    IN PSTREAMEX  pStrmExt
    );

void
DVSetXmtThreadState(
    PSTREAMEX  pStrmExt,
    XMT_THREAD_STATE  RequestState
);

NTSTATUS
DVConnect(
    IN KSPIN_DATAFLOW    ulDataFlow,
    IN PDVCR_EXTENSION   pDevExt,
    IN PSTREAMEX         pStrmExt,
    IN PAV_61883_REQUEST pAVReq
    );

NTSTATUS
DVDisconnect(
    IN KSPIN_DATAFLOW   ulDataFlow,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt
    );

ULONGLONG 
GetSystemTime(
    );


#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
VOID
DVCRExtractTimecodeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    );
#endif

#ifdef MSDV_SUPPORT_EXTRACT_DV_DATE_TIME
VOID
DVCRExtractRecDateAndTimeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    );
#endif

#ifdef MSDV_SUPPORT_MUTE_AUDIO
BOOL
DVMuteDVFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN OUT PUCHAR      pFrameBuffer,
    IN BOOL            bMute     // TRUE to mute; FALSE to un-Mute
    );
#endif

BOOL
DVGetPropertyValuesFromRegistry(
    IN PDVCR_EXTENSION  pDevExt
    );

BOOL
DVSetPropertyValuesToRegistry(	
    PDVCR_EXTENSION  pDevExt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\strmdata.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001  

Module Name:

    StrmData.h

Abstract:

    Header file for supporting SD DV over 1394;

Last changed by:
    
    Author:      Yee J. Wu

--*/

#ifndef _DVSTRM_INC
#define _DVSTRM_INC

#define STATIC_KSCATEGORY_RENDER_EXTERNAL \
    0xcc7bfb41L, 0xf175, 0x11d1, 0xa3, 0x92, 0x00, 0xe0, 0x29, 0x1f, 0x39, 0x59
DEFINE_GUIDSTRUCT("cc7bfb41-f175-11d1-a392-00e0291f3959", KSCATEGORY_RENDER_EXTERNAL);
#define KSCATEGORY_RENDER_EXTERNAL DEFINE_GUIDNAMED(KSCATEGORY_RENDER_EXTERNAL)

// stream topology stuff
static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,             // Output pin
    STATIC_KSCATEGORY_CAPTURE,           // Output pin
    STATIC_KSCATEGORY_RENDER,            // Input pin
    STATIC_KSCATEGORY_RENDER_EXTERNAL,   // Input pin
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,        // CategoriesCount
    Categories,                  // Categories
    0,                           // TopologyNodesCount
    NULL,                        // TopologyNodes
    0,                           // TopologyConnectionsCount
    NULL,                        // TopologyConnections
    NULL,                        // TopologyNodesNames
    0,                           // Reserved
};
    
#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif  
#define FOURCC_DVSD        mmioFOURCC('d', 'v', 's', 'd')
#define FOURCC_DVSL        mmioFOURCC('d', 'v', 's', 'l')
#define FOURCC_DVHD        mmioFOURCC('d', 'v', 'h', 'd')


#undef D_X_NTSC
#undef D_Y_NTSC
#undef D_X_NTSC_MIN
#undef D_Y_NTSC_MIN
#undef D_X_PAL
#undef D_Y_PAL
#undef D_X_PAL_MIN
#undef D_Y_PAL_MIN

#define D_X_NTSC            720
#define D_Y_NTSC            480
#define D_X_NTSC_MIN        360
#define D_Y_NTSC_MIN        240

#define D_X_PAL                720
#define D_Y_PAL                576
#define D_X_PAL_MIN            360
#define D_Y_PAL_MIN            288


// ------------------------------------------------------------------------
// External Device PROPERTY
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(ExternalDeviceProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_CAPABILITIES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_PORT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ), 
    
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_POWER_STATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),    

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_ID,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_VERSION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};



DEFINE_KSPROPERTY_TABLE(ExternalTransportProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_CAPABILITIES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_LOAD_MEDIUM,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_MEDIUM_INFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_STATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        // If this is an asychronous operation, we need to set and then get in separate calls.
        KSPROPERTY_EXTXPORT_STATE_NOTIFY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),


    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_ATN_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_RTC_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    //
    // Allow any RAW AVC to go through including Vendor dependent
    //
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_RAW_AVC_CMD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};


DEFINE_KSPROPERTY_TABLE(TimeCodeReaderProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TIMECODE_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_ATN_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_RTC_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


DEFINE_KSPROPERTY_TABLE(MediaSeekingProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        // Corresponding to IMediaSeeking::IsFormatSupported()
        KSPROPERTY_MEDIASEEKING_FORMATS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData; MULTIPLE_ITEM, 2 step process to get data
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
   ),
};

KSPROPERTY_SET    VideoDeviceProperties[] =
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_EXT_DEVICE,                   // Set
        SIZEOF_ARRAY(ExternalDeviceProperties),         // PropertiesCount
        ExternalDeviceProperties,                       // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_EXT_TRANSPORT,                // Set
        SIZEOF_ARRAY(ExternalTransportProperties),      // PropertiesCount
        ExternalTransportProperties,                    // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_TIMECODE_READER,              // Set
        SIZEOF_ARRAY(TimeCodeReaderProperties),         // PropertiesCount
        TimeCodeReaderProperties,                       // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_MediaSeeking,                    // Set
        SIZEOF_ARRAY(MediaSeekingProperties),         // PropertiesCount
        MediaSeekingProperties,                       // PropertyItem
        0,                                            // FastIoCount
        NULL                                          // FastIoTable
    ),
};

#define NUMBER_VIDEO_DEVICE_PROPERTIES (SIZEOF_ARRAY(VideoDeviceProperties))


// ------------------------------------------------------------------------
// External Device Events
// ------------------------------------------------------------------------

KSEVENT_ITEM ExtDevCommandItm[] = 
{
    {
        KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },    

    {
        KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },

#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT    
    // Application cares about this since AVC command will be ABORTED!
    {
        KSEVENT_EXTDEV_COMMAND_BUSRESET,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },
#endif

    // Tell client this device is being removed.
    {
        KSEVENT_EXTDEV_NOTIFY_REMOVAL,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },
};

// define event set related with streams
KSEVENT_SET VideoDeviceEvents[] =
{
    {
        &KSEVENTSETID_EXTDEV_Command,
        SIZEOF_ARRAY(ExtDevCommandItm),
        ExtDevCommandItm,
    },
};

#define NUMBER_VIDEO_DEVICE_EVENTS (SIZEOF_ARRAY(VideoDeviceEvents))


// ------------------------------------------------------------------------
// Stream Property sets for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

#ifdef SUPPORT_QUALITY_CONTROL
DEFINE_KSPROPERTY_TABLE(VideoStreamQualityControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_STREAM_QUALITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSQUALITY),                      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};
#endif

#ifdef SUPPORT_NEW_AVC
DEFINE_KSPROPERTY_TABLE(VideoStreamStreamAllocatorStatusProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_STREAMALLOCATOR_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSSTREAMALLOCATOR_STATUS),       // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0,                                      // SerializedSize
    ),
};


DEFINE_KSPROPERTY_TABLE(VideoStreamMediumsProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_PIN_MEDIUMS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData; MULTIPLE_ITEM, 2 step process to get data
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0,                                      // SerializedSize
    ),
};
#endif

KSPROPERTY_SET    VideoStreamProperties[] =
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#ifdef SUPPORT_NEW_AVC 
    // Apply only to INPIN????
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_StreamAllocator,                   // Set
        SIZEOF_ARRAY(VideoStreamStreamAllocatorStatusProperties),     // PropertiesCount
        VideoStreamStreamAllocatorStatusProperties,     // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Pin,                               // Set
        SIZEOF_ARRAY(VideoStreamMediumsProperties),     // PropertiesCount
        VideoStreamMediumsProperties,                   // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#endif
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

KSPROPERTY_SET    VideoStreamPropertiesInPin[] =
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#ifdef SUPPORT_QUALITY_CONTROL
    // Apply only to INPIN
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Stream,                            // Set
        SIZEOF_ARRAY(VideoStreamQualityControlProperties),  // PropertiesCount
        VideoStreamQualityControlProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#endif
#ifdef SUPPORT_NEW_AVC 
    // Apply only to INPIN
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_StreamAllocator,                   // Set
        SIZEOF_ARRAY(VideoStreamStreamAllocatorStatusProperties),     // PropertiesCount
        VideoStreamStreamAllocatorStatusProperties,     // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ), 
    
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Pin,                               // Set
        SIZEOF_ARRAY(VideoStreamMediumsProperties),     // PropertiesCount
        VideoStreamMediumsProperties,                   // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#endif
};

#define NUMBER_VIDEO_STREAM_PROPERTIES_INPIN (SIZEOF_ARRAY(VideoStreamPropertiesInPin))
// ----------------------------------------------------------------------
// Stream events
// ------------------------------------------------------------------------


// FORMAT_DVInfo
//
// Create a local copy of this GUID and make sure that it is not in the PAGED segment
//
const
GUID
KSEVENTSETID_Connection_Local = {STATICGUIDOF(KSEVENTSETID_Connection)};

const
GUID
KSEVENTSETID_Clock_Local = {STATICGUIDOF(KSEVENTSETID_Clock)};

// Isoch transmit End of stream event item
KSEVENT_ITEM EndOfStreamEventItm[] = 
{
    {
        KSEVENT_CONNECTION_ENDOFSTREAM,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

// Clock event item
KSEVENT_ITEM ClockEventItm[] =
{
    {
        KSEVENT_CLOCK_POSITION_MARK,        // position mark event supported
        sizeof (KSEVENT_TIME_MARK),         // requires this data as input
        sizeof (KSEVENT_TIME_MARK),         // allocate space to copy the data
        NULL,
        NULL,
        NULL
    },
};

KSEVENT_SET ClockEventSet[] =
{
    {
        &KSEVENTSETID_Clock,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    }
};


// define event set related with streams

// Output pin event set
KSEVENT_SET StreamEventsOutPin[] =
{
    {
        &KSEVENTSETID_Clock_Local,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    },
};

// Input pin events set
KSEVENT_SET StreamEventsInPin[] =
{
    {
        &KSEVENTSETID_Connection_Local, 
        SIZEOF_ARRAY(EndOfStreamEventItm),
        EndOfStreamEventItm,
    },
    {
        &KSEVENTSETID_Clock_Local,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    },
};

#define NUMBER_STREAM_EVENTS_OUT_PIN (SIZEOF_ARRAY(StreamEventsOutPin))
#define NUMBER_STREAM_EVENTS_IN_PIN (SIZEOF_ARRAY(StreamEventsInPin))




// ----------------------------------------------------------------------
// Stream data ranges
// ------------------------------------------------------------------------

//
// AAUX Source Pack:
// (SDDV_NTSC)
// PC4: d1 1101 0001 [EF:1:On];[TC:1:50/15us];[SMP:010:32KHz];[QU:001:12bit-nonlinear];
//*PC3: c0 1100 0000 [ML:1:NotMulti-language];[50/60:0:NTSC];[STYPE:0000:SD]
// PC2: 30 0011 0000 [SM:0:Multiple-Stereo];[CHN:01:two channels per an audio block];[PA:1:independent channel];[AudMode:0000:...]
// PC1: cf 1100 1111 [LF:1:Unlocked];[AFSize:1111:???]
//
// (SDDV_PAL)
//*PC3: c0 1110 0000 [ML:1:NotMulti-language];[50/60:1:PAL];[STYPE:0000:SD]
//

#define AAUXSRC_DEFAULT         0xd1c030cf   // ox PC4:PC3:PC2:PC1

#define AAUXSRC_AMODE_F         0x00000f00   // Set the AUDIO MODE of the 2nd AAUXSRC to 1111


#define AUXSRC_NTSC             0x00000000
#define AUXSRC_PAL              0x00200000
#define AUXSRC_STYPE_SD         0x00000000
#define AUXSRC_STYPE_SD_DVCPRO  0x000e0000
#define AUXSRC_STYPE_SDL        0x00010000
#define AUXSRC_STYPE_HD         0x00020000




#define AAUXSRC_SD_NTSC         AAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD        // 0xd1c030cf 
#define AAUXSRC_SD_PAL          AAUXSRC_DEFAULT | AUXSRC_PAL  | AUXSRC_STYPE_SD        // 0xd1e030d0

#define AAUXSRC_SD_NTSC_DVCPRO  AAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD_DVCPRO // 0xd1de30cf 
#define AAUXSRC_SD_PAL_DVCPRO   AAUXSRC_DEFAULT | AUXSRC_PAL  | AUXSRC_STYPE_SD_DVCPRO // 0xd1fe30d0 

#define AAUXSRC_SDL_NTSC        AAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SDL       // 0xd1c130cf 
#define AAUXSRC_SDL_PAL         AAUXSRC_DEFAULT | AUXSRC_PAL  | AUXSRC_STYPE_SDL       // 0xd1e130d0

#define AAUXSRC_HD_NTSC         AAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_HD        // 0xd1c230cf 
#define AAUXSRC_HD_PAL          AAUXSRC_DEFAULT | AUXSRC_PAL  | AUXSRC_STYPE_HD        // 0xd1e230d0
 

//
// AAUX Source Control
//
// PC4:ff:1111 1111 [1];[Genere:111 1111:NoInfo]
// PC3:a0:1010 0000 [DRF:1:Forward direction];[Speed:010 0000:normal recording]
// PC2:cf:1100 1111 [RecSt:1:NoRecStPt];[RedEd:1:NoRecEdPt];[RecMode:001:Original];[InsCh:111:NoInfo]
// PC1:3f:0011 1111 [CMGS:00:CopyGMS];[ISR:11:NoInfo];[CMP:11:NoInfo];[SS:11:NoInfo]

#define AAUXSRCCTL_DEFAULT      0xffa0cf3f    // ox PC4:PC3:PC2:PC1

//
// VAUX Source
//
// PC4:ff [TunderCat:1111 1111:NoInfo]
// PC3:00 [SrcCode:00:Camera];[50/60:0:NTSC];[STYPE:0000:SD]
// PC2:ff [BW:1:Color];[EN:ColorFrameEnable:1:Invalid];[CLF:11:"Invalid"];[TV Ch:1111:NoInfo]
// PC1:ff:[TCChannel:1111 1111:NoInfo]

#define VAUXSRC_DEFAULT         0xff00ffff    // ox PC4:PC3:PC2:PC1

//
// VAUX Source Control
//
// PC4:ff 1111 1111 [1];[Genere:111 1111:NoInfo]
// PC3:fc 1111 1100 [FF:1:BothFields];[FS:1:Field1];[FC:1:DiffPic];[IL:1:Interlaced];
//                  [ST:1:1001/60 or 1/50];[SC:1:NotStillPic];[BCSYS:00:type0]
// PC2:c8 1100 1000 [RecSt:1:NoRecStPt];[1];[RecMode:001:Original];[1];[DISP:000:(4:3) full fmt]
// PC1:3f:0011 1111 [CMGS:00:CopyGMS];[ISR:11:NoInfo];[CMP:11:NoInfo];[SS:11:NoInfo]

#define VAUXSRCCTL_DEFAULT_EIA  0xfffcc83f    // for NTSC(?) 
#define VAUXSRCCTL_DEFAULT_ETS  0xfffdc83f    // for PAL (?) 


// SD DV VidOnly NTSC Stream
KS_DATARANGE_VIDEO SDDV_VidOnlyNTSCStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),    // FormatSize
        0,                              // Flags
        FRAME_SIZE_SD_DVCR_NTSC,        // SampleSize
        0,                              // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_NTSC_M,      // AnalogVideoStandard
        D_X_NTSC, D_Y_NTSC,         // InputSize, (the inherent size of the incoming signal
                                    //             with every digitized pixel unique)
        D_X_NTSC_MIN, D_Y_NTSC_MIN, // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_NTSC, D_Y_NTSC,         // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_NTSC_MIN, D_Y_NTSC_MIN,     // MinOutputSize, smallest bitmap stream can produce
        D_X_NTSC, D_Y_NTSC,                // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units// MinFrameInterval, 100 nS units
        333667,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SD_DVCR_NTSC * 8)*30,  // MinBitsPerSecond;
        (FRAME_SIZE_SD_DVCR_NTSC * 8)*30,  // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, //D_X_NTSC,D_Y_NTSC,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SD_DVCR_NTSC * 8 * 30),    //    DWORD           dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        333667,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_NTSC,                       //    LONG       biWidth;
        D_Y_NTSC,                       //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSD,                //    DWORD      biCompression;
        FRAME_SIZE_SD_DVCR_NTSC,    //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};

// SD DV VidOnly PAL Stream
KS_DATARANGE_VIDEO SDDV_VidOnlyPALStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),   // FormatSize
        0,                             // Flags
        FRAME_SIZE_SD_DVCR_PAL,        // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,    // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_PAL_B,        // AnalogVideoStandard
        D_X_PAL, D_Y_PAL,            // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_PAL, D_Y_PAL,           // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinOutputSize, smallest bitmap stream can produce
        D_X_PAL, D_Y_PAL,            // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        400000,         // MinFrameInterval, 100 nS units
        400000,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SD_DVCR_PAL * 8)*25,  // MinBitsPerSecond;
        (FRAME_SIZE_SD_DVCR_PAL * 8)*25,  // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, // D_X_PAL,D_Y_PAL,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SD_DVCR_PAL * 8 * 25),  //    DWORD   dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        400000,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_PAL,                        //    LONG       biWidth;
        D_Y_PAL,                        //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSD,                //    DWORD      biCompression;
        FRAME_SIZE_SD_DVCR_PAL,     //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};

#ifdef MSDV_SUPPORT_SDL_DVCR
// SDL DV VidOnly NTSC Stream
KS_DATARANGE_VIDEO SDLDV_VidOnlyNTSCStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),    // FormatSize
        0,                              // Flags
        FRAME_SIZE_SDL_DVCR_NTSC,       // SampleSize
        0,                              // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSL,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_NTSC_M,      // AnalogVideoStandard
        D_X_NTSC, D_Y_NTSC,         // InputSize, (the inherent size of the incoming signal
                                    //             with every digitized pixel unique)
        D_X_NTSC_MIN, D_Y_NTSC_MIN, // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_NTSC, D_Y_NTSC,         // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_NTSC_MIN, D_Y_NTSC_MIN,     // MinOutputSize, smallest bitmap stream can produce
        D_X_NTSC, D_Y_NTSC,                // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units// MinFrameInterval, 100 nS units
        333667,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SDL_DVCR_NTSC * 8)*30,  // MinBitsPerSecond;
        (FRAME_SIZE_SDL_DVCR_NTSC * 8)*30,  // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, //D_X_NTSC,D_Y_NTSC,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SDL_DVCR_NTSC * 8 * 30),    //    DWORD           dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        333667,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_NTSC,                       //    LONG       biWidth;
        D_Y_NTSC,                       //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSL,                //    DWORD      biCompression;
        FRAME_SIZE_SDL_DVCR_NTSC,   //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};

// SDL DV VidOnly PAL Stream
KS_DATARANGE_VIDEO SDLDV_VidOnlyPALStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),   // FormatSize
        0,                             // Flags
        FRAME_SIZE_SDL_DVCR_PAL,        // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSL,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,    // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_PAL_B,        // AnalogVideoStandard
        D_X_PAL, D_Y_PAL,            // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_PAL, D_Y_PAL,           // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinOutputSize, smallest bitmap stream can produce
        D_X_PAL, D_Y_PAL,            // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        400000,         // MinFrameInterval, 100 nS units
        400000,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SDL_DVCR_PAL * 8)*25,  // MinBitsPerSecond;
        (FRAME_SIZE_SDL_DVCR_PAL * 8)*25,  // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, // D_X_PAL,D_Y_PAL,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SDL_DVCR_PAL * 8 * 25),  //    DWORD   dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        400000,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_PAL,                        //    LONG       biWidth;
        D_Y_PAL,                        //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSL,                //    DWORD      biCompression;
        FRAME_SIZE_SDL_DVCR_PAL,    //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};

#endif // MSDV_SUPPORT_SDL_DVCR


// SD DV IAV NTSC Stream
#ifdef SUPPORT_NEW_AVC
KS_DATARANGE_DV_AVC
SDDV_IavNtscStreamAVC =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DV_AVC),  // FormatSize
        0,                             // Flags
        FRAME_SIZE_SD_DVCR_NTSC,       // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,       
        // Indicate that an AVC structure is included and this is used for direct DV to DV connection. 
        STATIC_KSDATAFORMAT_SPECIFIER_DV_AVC,  // STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },

    // DVINFO
    // Note: audio is set for 32khz
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SD_NTSC,               // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        AAUXSRC_SD_NTSC | AAUXSRC_AMODE_F, // DWORD dwDVAAuxSrc1;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD, // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_EIA,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
};

// SDL DV IAV PAL Stream
KS_DATARANGE_DV_AVC 
SDDV_IavPalStreamAVC =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DV_AVC), // FormatSize
        0,                             // Flags
        FRAME_SIZE_SD_DVCR_PAL,        // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        // Indicate that an AVC structure is included and this is used for direct DV to DV connection.
        STATIC_KSDATAFORMAT_SPECIFIER_DV_AVC,  // STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },
    
    // DVINFO
    // Note: Audio is set for 32khz.
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SD_PAL,                // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        AAUXSRC_SD_PAL | AAUXSRC_AMODE_F, // DWORD dwDVAAuxSrc1;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_PAL | AUXSRC_STYPE_SD,  // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_ETS,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
};

#endif

// SD DV IAV NTSC Stream
KS_DATARANGE_DVVIDEO 
SDDV_IavNtscStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DVVIDEO), // FormatSize
        0,                             // Flags
        FRAME_SIZE_SD_DVCR_NTSC,       // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO, // DV to DShow filter connection
    },

    // DVINFO
    // Note: audio is set for 32khz
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SD_NTSC,               // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        AAUXSRC_SD_NTSC | AAUXSRC_AMODE_F, // DWORD dwDVAAuxSrc1;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SD, // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_EIA,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
};

// SDL DV IAV PAL Stream
KS_DATARANGE_DVVIDEO 
SDDV_IavPalStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DVVIDEO), // FormatSize
        0,                             // Flags
        FRAME_SIZE_SD_DVCR_PAL,        // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO, // DV to DShow filter connection
    },
    
    // DVINFO
    // Note: Audio is set for 32khz.
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SD_PAL,                // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        AAUXSRC_SD_PAL | AAUXSRC_AMODE_F, // DWORD dwDVAAuxSrc1;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_PAL | AUXSRC_STYPE_SD,  // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_ETS,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
};


#ifdef MSDV_SUPPORT_SDL_DVCR

// SDL DV IAV NTSC Stream
KS_DATARANGE_DVVIDEO SDLDV_IavNtscStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DVVIDEO), // FormatSize
        0,                             // Flags
        FRAME_SIZE_SDL_DVCR_NTSC,      // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSL,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO, 
    },

    // DVINFO
    // Note: audio is set for 32khz
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SDL_NTSC,              // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq; SDL only have 5 dif seqs..
        0x0,                           // DWORD dwDVAAuxSrc1; 
        0x0,                           // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_NTSC | AUXSRC_STYPE_SDL,  // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_EIA,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
};


// SDL DV VidOnly NTSC Stream
KS_DATARANGE_DVVIDEO SDLDV_IavPalStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_DVVIDEO), // FormatSize
        0,                             // Flags
        FRAME_SIZE_SDL_DVCR_PAL,       // SampleSize
        0,                             // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED, 
        STATIC_KSDATAFORMAT_SUBTYPE_DVSL,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO, 
    },
    
    // DVINFO
    // Note: Audio is set for 32khz.
    {
        //for 1st 5/6 DIF seq.
        AAUXSRC_SDL_PAL,               // DWORD dwDVAAuxSrc;
        AAUXSRCCTL_DEFAULT,            // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq; SDL only have 5 dif seqs..
        0x0,                           // DWORD dwDVAAuxSrc1; 
        0x0,                           // DWORD dwDVAAuxCtl1;
        //for video information
        VAUXSRC_DEFAULT | AUXSRC_PAL | AUXSRC_STYPE_SDL,  // DWORD dwDVVAuxSrc;
        VAUXSRCCTL_DEFAULT_ETS,        // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
};
#endif // MSDV_SUPPORT_SDL_DVCR


//
// A device cannot support all these formats at the same time.  All 
// formats are advertise since the "current format" of the device can 
// dynamically changing (NTSC/PAL or SD/SDL); however, duraing data 
// intersection and stram opening, only the currently support format 
// will be accepted.
//

PKSDATAFORMAT DVCRStream0Formats[] = 
{
    (PKSDATAFORMAT) &SDDV_VidOnlyNTSCStream,
    (PKSDATAFORMAT) &SDDV_VidOnlyPALStream,
#ifdef MSDV_SUPPORT_SDL_DVCR
    (PKSDATAFORMAT) &SDLDV_VidOnlyNTSCStream,
    (PKSDATAFORMAT) &SDLDV_VidOnlyPALStream,
#endif
};

#define NUM_DVCR_STREAM0_FORMATS  (SIZEOF_ARRAY(DVCRStream0Formats))

PKSDATAFORMAT DVCRStream1Formats[] = 
{
#ifdef SUPPORT_NEW_AVC
    (PKSDATAFORMAT) &SDDV_IavNtscStreamAVC,   // DV to DV connection
    (PKSDATAFORMAT) &SDDV_IavPalStreamAVC,    // DV to DV connection
#endif
    (PKSDATAFORMAT) &SDDV_IavNtscStream,
    (PKSDATAFORMAT) &SDDV_IavPalStream,
#ifdef MSDV_SUPPORT_SDL_DVCR
    (PKSDATAFORMAT) &SDLDV_IavNtscStream,
    (PKSDATAFORMAT) &SDLDV_IavPalStream,
#endif
};

#define NUM_DVCR_STREAM1_FORMATS  (SIZEOF_ARRAY(DVCRStream1Formats))


//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

// If the minidriver does not specify a medium, 
// the class driver uses the KSMEDIUMSETID_Standard, 
// KSMEDIUM_TYPE_ANYINSTANCE medium as the default. 

KSPIN_MEDIUM DVVidonlyMediums[] =
{
    { STATIC_KSMEDIUMSETID_Standard,     0, 0 },  
};
#define NUM_VIDONLY_MEDIUMS (SIZEOF_ARRAY(DVVidonlyMediums))

KSPIN_MEDIUM DVIavMediums[] =
{
#ifdef SUPPORT_NEW_AVC
    { STATIC_KSMEDIUMSETID_1394SerialBus, 1394, 0 },  // ID=1394 (?); Flag=?
#endif
    { STATIC_KSMEDIUMSETID_Standard,      0, 0 },
};
#define NUM_IAV_MEDIUMS (SIZEOF_ARRAY(DVIavMediums))


static GUID guidPinCategoryCapture  = {STATIC_PINNAME_VIDEO_CAPTURE};

static GUID guidPinNameDVVidOutput  = {STATIC_PINNAME_DV_VID_OUTPUT};
static GUID guidPinNameDVAVOutput   = {STATIC_PINNAME_DV_AV_OUTPUT};
static GUID guidPinNameDVAVInput    = {STATIC_PINNAME_DV_AV_INPUT};


ALL_STREAM_INFO DVStreams [] = 
{
    // -----------------------------------------------------------------
    // Stream 0, DV coming from the camcorder
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_OUT,                             // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM0_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream0Formats,                             // StreamFormatsArray
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
        VideoStreamProperties,                          // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_OUT_PIN,                   // NumStreamEventArrayEntries
        StreamEventsOutPin,                             // StreamEventsArray
        &guidPinCategoryCapture,                        // Category
        &guidPinNameDVVidOutput,                        // Name
        NUM_VIDONLY_MEDIUMS,                            // Mediums count
        DVVidonlyMediums,                               // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        0,                                              // StreamNumber
        0,                                              // HwStreamExtension
        DVRcvDataPacket,                                // ReceiveDataPacket
        DVRcvControlPacket,                             // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) StreamClockRtn,        // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        sizeof(KS_FRAME_INFO),                          // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        DVEventHandler,                                 // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },
    },

    // -----------------------------------------------------------------
    // Stream 1, DV coming from the camcorder (interleaved format)
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_OUT,                             // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM1_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream1Formats,                             // StreamFormatsArrayf
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
        VideoStreamProperties,                          // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_OUT_PIN,                   // NumStreamEventArrayEntries
        StreamEventsOutPin,                             // StreamEventsArray
        &guidPinCategoryCapture,                        // Category
        &guidPinNameDVAVOutput,                         // Name
        NUM_IAV_MEDIUMS,                                // Mediums count
        DVIavMediums,                                   // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        1,                                              // StreamNumber
        0,                                              // HwStreamExtension
        DVRcvDataPacket,                                // ReceiveDataPacket
        DVRcvControlPacket,                             // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) StreamClockRtn,        // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        DVEventHandler,                                 // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },    
    },
 

    // -----------------------------------------------------------------
    // Stream 2, DV flows out of the adapter (interleaved)
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_IN,                              // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM1_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream1Formats,                             // StreamFormatsArray
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES_INPIN,           // NumStreamPropArrayEntries
        VideoStreamPropertiesInPin,                     // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_IN_PIN,                    // NumStreamEventArrayEntries
        StreamEventsInPin,                              // StreamEventsArray
        NULL,                                           // Category
        &guidPinNameDVAVInput,                          // Name
        NUM_IAV_MEDIUMS,                                // Mediums count
        DVIavMediums,                                   // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof( HW_STREAM_OBJECT ),
        2,                                              // StreamNumber
        0,                                              // HwStreamExtension
        DVRcvDataPacket,                                // ReceiveDataPacket
        DVRcvControlPacket,                             // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) StreamClockRtn,        // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
#ifdef SUPPORT_NEW_AVC
        // Testing: Input pin as the allocator.
        TRUE,                                           // Allocator
#else
        FALSE,                                          // Allocator  
#endif
        DVEventHandler,                                 // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        }
    }
};

#define DV_STREAM_COUNT        (SIZEOF_ARRAY(DVStreams))


#endif  // _DVSTRM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\msdv\msdvutil.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSDVUtil.c

Abstract:

    Provide utility functions for MSDV.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "msdvfmt.h"
#include "msdvdef.h"
#include "MsdvAvc.h"
#include "MsdvUtil.h"  

#include "XPrtDefs.h"

#if 0  // Enable later
#ifdef ALLOC_PRAGMA
     #pragma alloc_text(PAGE, DVDelayExecutionThread)
     #pragma alloc_text(PAGE, DVGetUnitCapabilities)
     // Local variables might paged out but the called might use it in DISPATCH level!
     // #pragma alloc_text(PAGE, DVGetDevModeOfOperation)
     // #pragma alloc_text(PAGE, DVGetDevIsItDVCPro)
     // #pragma alloc_text(PAGE, DVGetDevSignalFormat)
     #pragma alloc_text(PAGE, DvAllocatePCResource)
     #pragma alloc_text(PAGE, DvFreePCResource)
     #pragma alloc_text(PAGE, DVGetPlugState)
     #pragma alloc_text(PAGE, DVConnect)
     #pragma alloc_text(PAGE, DVDisconnect)
#endif
#endif

extern DV_FORMAT_INFO DVFormatInfoTable[];

VOID
DVDelayExecutionThread(
    ULONG ulDelayMSec
    )
/*
    Device might need a "wait" in between AV/C commands.
*/
{
    PAGED_CODE();

    if (ulDelayMSec)
    {
        LARGE_INTEGER tmDelay;   

        TRACE(TL_PNP_TRACE,("\'DelayExeThrd: %d MSec\n",  ulDelayMSec));
    
        tmDelay.LowPart  =  (ULONG) (-1 * ulDelayMSec * 10000);
        tmDelay.HighPart = -1;
        KeDelayExecutionThread(KernelMode, FALSE, &tmDelay);
    }
}


NTSTATUS
DVIrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          Event
    )
{
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // DVIrpSynchCR


NTSTATUS
DVSubmitIrpSynch(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq
    )
{
    NTSTATUS            Status;
    KEVENT              Event;
    PIO_STACK_LOCATION  NextIrpStack;
  

    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAVReq;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        DVIrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->pBusDeviceObject,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_TRACE,("\'Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("\'Irp has returned; IoStatus==Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    return Status;
} // DVSubmitIrpSynchAV



BOOL
DVGetDevModeOfOperation(   
    IN PDVCR_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];

    PAGED_CODE();
   
    //
    // Use ConnectAV STATUS cmd to determine mode of operation,
    // except for some Canon DVs that it requires its vendor specific command
    //    
    
    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            DV_CONNECT_AV_MODE, 
            (PVOID) bAvcBuf
            ); 

    TRACE(TL_FCP_TRACE,("\'DV_CONNECT_AV_MODE: St:%x,  %x %x %x %x : %x %x %x %x\n",
        Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7]));

    if(Status == STATUS_SUCCESS) {
        if(bAvcBuf[0] == 0x0c) {
            if(bAvcBuf[1] == 0x00 &&
               bAvcBuf[2] == 0x38 &&
               bAvcBuf[3] == 0x38) {
                pDevExt->ulDevType = ED_DEVTYPE_CAMERA;  
            } else {
                pDevExt->ulDevType = ED_DEVTYPE_VCR;  
            } 
        } 
    } else if(pDevExt->ulVendorID == VENDORID_CANON) {
        // Try a vendor dependent command if it is a Canon AV device.
        Status = 
            DVIssueAVCCommand(
                pDevExt, 
                AVC_CTYPE_STATUS, 
                DV_VEN_DEP_CANON_MODE, 
                (PVOID) bAvcBuf
                ); 

        TRACE(TL_FCP_WARNING,("\'DV_VEN_DEP_CANON_MODE: Status %x,  %x %x %x %x : %x %x %x %x  %x %x\n",
            Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7], bAvcBuf[8], bAvcBuf[9]));

        if(Status == STATUS_SUCCESS) {
            if(bAvcBuf[0] == 0x0c) {
                if(bAvcBuf[7] == 0x38) {
                    pDevExt->ulDevType = ED_DEVTYPE_CAMERA;  
                } else 
                if(bAvcBuf[7] == 0x20) {
                    pDevExt->ulDevType = ED_DEVTYPE_VCR;  
                } 
            }
        }
    }

    if(Status != STATUS_SUCCESS) {
        pDevExt->ulDevType = ED_DEVTYPE_UNKNOWN;
        TRACE(TL_FCP_ERROR,("\'DV_CONNECT_AV_MODE: Status %x, DevType %x,  %x %x %x %x : %x %x %x %x : %x %x\n",
             Status, pDevExt->ulDevType, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7], bAvcBuf[8], bAvcBuf[9]));
    }

    TRACE(TL_FCP_WARNING,("\'%s; NumOPlg:%d; NumIPlg:%d\n", 
        pDevExt->ulDevType == ED_DEVTYPE_CAMERA ? "Camera" : pDevExt->ulDevType == ED_DEVTYPE_VCR ? "VTR" : "Unknown",
        pDevExt->NumOutputPlugs, pDevExt->NumInputPlugs));
              
    return TRUE;
}


BOOL
DVGetDevIsItDVCPro(   
    IN PDVCR_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];

    PAGED_CODE();    

    //
    // Use Panasnoic's vendor dependent command to determine if the system support DVCPro
    //    
    
    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            DV_VEN_DEP_DVCPRO, 
            (PVOID) bAvcBuf
            );

    pDevExt->bDVCPro = Status == STATUS_SUCCESS;
    
    TRACE(TL_FCP_WARNING,("\'DVGetDevIsItDVCPro? %s; Status %x,  %x %x %x %x : %x %x %x %x\n",
        pDevExt->bDVCPro ? "Yes":"No",
        Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7]));

    return pDevExt->bDVCPro;
}


// The retries might be redundant since AVC.sys and 1394.sys retries.
// For device that TIMEOUT an AVC command, we will only try it once.
#define GET_MEDIA_FMT_MAX_RETRIES 10  

BOOL
DVGetDevSignalFormat(
    IN PDVCR_EXTENSION pDevExt,
    IN KSPIN_DATAFLOW  DataFlow,
    IN PSTREAMEX       pStrmExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];
    LONG lRetries = GET_MEDIA_FMT_MAX_RETRIES;

    PAGED_CODE();

    //
    // Respone of Input/output signal mode is used to determine plug signal format:
    //
    //     FMT: 
    //         DVCR 10:00 0000 = 0x80; Canon returns 00:100000 (0x20)
    //             50/60: 0:NTSC/60; 1:PAL/50
    //             STYPE:
    //                 SD: 00000  (DVCPRO:11110)
    //                 HD: 00010
    //                 SDL:00001
    //             00:
    //             SYT:
    //         MPEG 10:10 0000 = 0xa0
    //             TSF:0:NotTimeShifted; 1:Time shifted
    //             000 0000 0000 0000 0000 0000
    //
    // If this command failed, we can use Input/Output Signal Mode subunit command
    // to determine signal format.
    // 

    do {
        RtlZeroMemory(bAvcBuf, sizeof(bAvcBuf));
        Status = 
            DVIssueAVCCommand(
                pDevExt, 
                AVC_CTYPE_STATUS, 
                pStrmExt == NULL ? DV_OUT_PLUG_SIGNAL_FMT : (DataFlow == KSPIN_DATAFLOW_OUT ? DV_OUT_PLUG_SIGNAL_FMT : DV_IN_PLUG_SIGNAL_FMT),
                (PVOID) bAvcBuf
                );  
        
        // 
        // Camcorders that has problem with this command:
        //
        // Panasonic's DVCPRO: if power on while connected to PC, it will 
        // reject this command with (STATUS_REQUEST_NOT_ACCEPTED)
        // so we will retry up to 10 time with .5 second wait between tries.
        //
        // JVC: returns STATUS_NOT_SUPPORTED.
        //
        // SONY DV Decoder Box: return STATUS_TIMEOUT or STATUS_REQUEST_ABORTED 
        //
        
        if(STATUS_REQUEST_ABORTED == Status)
            return FALSE;
        else if(STATUS_SUCCESS == Status)
            break;  // Normal case.
        else if(STATUS_NOT_SUPPORTED == Status || STATUS_TIMEOUT == Status) {
            TRACE(TL_FCP_WARNING | TL_PNP_WARNING,("SignalFormat: Encountered a known failed status:%x; no more retry\n", Status));
            break;  // No need to retry
        } else {
            if(Status == STATUS_REQUEST_NOT_ACCEPTED) {
                // If device is not accepting command and return this status, retry.
                if(lRetries > 0) {
                    TRACE(TL_FCP_WARNING | TL_PNP_WARNING,("\'ST:%x; Retry getting signal mode; wait...\n", Status));
                    DVDelayExecutionThread(DV_AVC_CMD_DELAY_DVCPRO);        
                }
            }
        }       

    } while (--lRetries >= 0); 



    if(NT_SUCCESS(Status)) {

        switch(bAvcBuf[0]) {

        case FMT_DVCR:
        case FMT_DVCR_CANON:  // Workaround for buggy Canon Camcorders
            switch(bAvcBuf[1] & FDF0_STYPE_MASK) {
            case FDF0_STYPE_SD_DVCR:
            case FDF0_STYPE_SD_DVCPRO:                
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? FMT_IDX_SD_DVCR_PAL : FMT_IDX_SD_DVCR_NTSC);
                if(pStrmExt)
                    RtlCopyMemory(&pStrmExt->cipQuad2[0], &bAvcBuf[0], 4);
                break;
#ifdef MSDV_SUPPORT_HD_DVCR
            case FDF0_STYPE_HD_DVCR:
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? FMT_IDX_HD_DVCR_PAL : FMT_IDX_HD_DVCR_NTSC);
                if(pStrmExt)
                    RtlCopyMemory(&pStrmExt->cipQuad2[0], &bAvcBuf[0], 4);
                break;
#endif
#ifdef MSDV_SUPPORT_SDL_DVCR
            case FDF0_STYPE_SDL_DVCR:
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? FMT_IDX_SDL_DVCR_PAL : FMT_IDX_SDL_DVCR_NTSC);
                if(pStrmExt)
                    RtlCopyMemory(&pStrmExt->cipQuad2[0], &bAvcBuf[0], 4);
                break;     
#endif                
            default:  // Unknown format
                Status = STATUS_UNSUCCESSFUL;              
                break;
            }   
            break;
#ifdef MSDV_SUPPORT_MPEG2TS
        case FMT_MPEG:
            pDevExt->VideoFormatIndex = FMT_IDX_MPEG2TS;
            if(pStrmExt)
                RtlCopyMemory(&pStrmExt->cipQuad2[0], &bAvcBuf[0], 4);
            break;
#endif
        default:
            Status = STATUS_UNSUCCESSFUL;
        }  

        if(NT_SUCCESS(Status)) {
            TRACE(TL_FCP_WARNING,("\'ST:%x; PlugSignal:FMT[%x %x %x %x]; VideoFormatIndex;%d\n", Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2] , bAvcBuf[3], pDevExt->VideoFormatIndex)); 
            return TRUE;  // Success
        }
    }
    TRACE(TL_FCP_WARNING,("\'ST:%x; PlugSignal:FMT[%x %x %x %x]\n", Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2] , bAvcBuf[3], pDevExt->VideoFormatIndex)); 

    //
    // If "recommended" unit input/output plug signal status command fails,
    // try "manadatory" input/output signal mode status command.
    // This command may failed some device if its tape is not playing for
    // output signal mode command.
    //

    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            DataFlow == KSPIN_DATAFLOW_OUT ? VCR_OUTPUT_SIGNAL_MODE : VCR_INPUT_SIGNAL_MODE,
            (PVOID) bAvcBuf
            );             

    if(STATUS_SUCCESS == Status) {

        PKSPROPERTY_EXTXPORT_S pXPrtProperty;

        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) bAvcBuf;
        TRACE(TL_FCP_WARNING,("\'** MediaFormat: Retry %d mSec; ST:%x; SignalMode:%dL\n", 
            (GET_MEDIA_FMT_MAX_RETRIES - lRetries) * DV_AVC_CMD_DELAY_DVCPRO, Status, pXPrtProperty->u.SignalMode - ED_BASE));

        switch(pXPrtProperty->u.SignalMode) {
        case ED_TRANSBASIC_SIGNAL_525_60_SD:
            pDevExt->VideoFormatIndex = FMT_IDX_SD_DVCR_NTSC;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR; // 0x80 
                if(pDevExt->bDVCPro)
                    pStrmExt->cipQuad2[1] = FDF0_50_60_NTSC | FDF0_STYPE_SD_DVCPRO; // 0x78 = NTSC(0):STYPE(11110):RSV(00)
                else
                    pStrmExt->cipQuad2[1] = FDF0_50_60_NTSC | FDF0_STYPE_SD_DVCR;   // 0x00 = NTSC(0):STYPE(00000):RSV(00)            
            }
            break;
        case ED_TRANSBASIC_SIGNAL_625_50_SD:
            pDevExt->VideoFormatIndex = FMT_IDX_SD_DVCR_PAL;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR;  // 0x80
                if(pDevExt->bDVCPro)
                    pStrmExt->cipQuad2[1] = FDF0_50_60_PAL | FDF0_STYPE_SD_DVCPRO; // 0xf8 = PAL(1):STYPE(11110):RSV(00)
                else
                    pStrmExt->cipQuad2[1] = FDF0_50_60_PAL | FDF0_STYPE_SD_DVCR;   // 0x80 = PAL(1):STYPE(00000):RSV(00)             
            }
            break;
#ifdef MSDV_SUPPORT_SDL_DVCR
        case ED_TRANSBASIC_SIGNAL_525_60_SDL:
            pDevExt->VideoFormatIndex = FMT_IDX_SDL_DVCR_NTSC;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR; // 0x80 
                pStrmExt->cipQuad2[1] = FDF0_50_60_NTSC | FDF0_STYPE_SDL_DVCR;   
            }
            break;
        case ED_TRANSBASIC_SIGNAL_625_50_SDL:
            pDevExt->VideoFormatIndex = FMT_IDX_SDL_DVCR_PAL;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR;  // 0x80
                pStrmExt->cipQuad2[1] = FDF0_50_60_PAL | FDF0_STYPE_SDL_DVCR;  
            }
            break;
#endif
        default:
            TRACE(TL_FCP_ERROR,("\'Unsupported SignalMode:%dL", pXPrtProperty->u.SignalMode - ED_BASE));
            ASSERT(FALSE && "Unsupported IoSignal! Refuse to load.");
            return FALSE;
            break;
        }
    } 

    // WORKITEM Sony HW CODEC does not response to any AVC command.
    // We are making an exception here to load it.
    if(Status == STATUS_TIMEOUT) {
        Status = STATUS_SUCCESS;
    }

    // We must know the signal format!!  If this failed, the driver will either:
    //    fail to load, or fail to open an stream
    ASSERT(Status == STATUS_SUCCESS && "Failed to get media signal format!\n");

#if DBG
    if(pStrmExt)  {
        // Note: bAvcBuf[0] is operand[1] == 10:fmt
        TRACE(TL_FCP_WARNING,("\'** MediaFormat: St:%x; idx:%d; CIP:[FMT:%.2x(%s); FDF:[%.2x(%s,%s):SYT]\n",
            Status,
            pDevExt->VideoFormatIndex,
            pStrmExt->cipQuad2[0],
            pStrmExt->cipQuad2[0] == FMT_DVCR ? "DVCR" : pStrmExt->cipQuad2[0] == FMT_MPEG ? "MPEG" : "Fmt:???",
            pStrmExt->cipQuad2[1],
            (pStrmExt->cipQuad2[1] & FDF0_50_60_MASK) == FDF0_50_60_PAL ? "PAL" : "NTSC",
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SD_DVCR ?   "SD" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SDL_DVCR ?  "SDL" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_HD_DVCR ?   "HD" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SD_DVCPRO ? "DVCPRO" : "DV:????"
            ));
    } else
        TRACE(TL_FCP_WARNING|TL_CIP_WARNING,("\'** MediaFormat: St:%x; use idx:%d\n", Status, pDevExt->VideoFormatIndex));

#endif

    return STATUS_SUCCESS == Status;
}



BOOL 
DVCmpGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    IN BOOL fCompareSubformat,
    IN BOOL fCompareFormatSize
    )
/*++

Routine Description:

    Checks for a match on the three GUIDs and FormatSize

Arguments:

    IN pDataRange1
    IN pDataRange2

Return Value:

    TRUE if all elements match
    FALSE if any are different

--*/

{
    return (
        IsEqualGUID (
            &pDataRange1->MajorFormat, 
            &pDataRange2->MajorFormat) &&
        (fCompareSubformat ?
        IsEqualGUID (
            &pDataRange1->SubFormat, 
            &pDataRange2->SubFormat) : TRUE) &&
        IsEqualGUID (
            &pDataRange1->Specifier, 
            &pDataRange2->Specifier) &&
        (fCompareFormatSize ? 
                (pDataRange1->FormatSize == pDataRange2->FormatSize) : TRUE ));
}


NTSTATUS
DvAllocatePCResource(
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt  // Note that pStrmExt can be NULL!
    )
{

    PSRB_DATA_PACKET pSrbDataPacket;
    PDVCR_EXTENSION  pDevExt;
    ULONG             i, j;

    PAGED_CODE();


    //
    // Pre-allcoate PC resource
    //
    pDevExt = pStrmExt->pDevExt;
    for(i=0; i < (DataFlow == KSPIN_DATAFLOW_OUT ? \
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfRcvBuffers : \
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfXmtBuffers); i++) {

        if(!(pSrbDataPacket = ExAllocatePool(NonPagedPool, sizeof(SRB_DATA_PACKET)))) {

            for(j = 0; j < i; j++) {
                pSrbDataPacket = (PSRB_DATA_PACKET) \
                    RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
                ExFreePool(pSrbDataPacket->Frame);  pSrbDataPacket->Frame = NULL;
                IoFreeIrp(pSrbDataPacket->pIrp);  pSrbDataPacket->pIrp = NULL;
                ExFreePool(pSrbDataPacket);   pSrbDataPacket = NULL;               
                ASSERT(pStrmExt->cntDataDetached >= 0);
            }
            return STATUS_NO_MEMORY;            
        }

        RtlZeroMemory(pSrbDataPacket, sizeof(SRB_DATA_PACKET));
        pSrbDataPacket->State = DE_IRP_SRB_COMPLETED;  // Initial state.

        if(!(pSrbDataPacket->Frame = ExAllocatePool(NonPagedPool, sizeof(CIP_FRAME)))) {
            ExFreePool(pSrbDataPacket);  pSrbDataPacket = NULL;

            for(j = 0; j < i; j++) {
                pSrbDataPacket = (PSRB_DATA_PACKET) \
                    RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
                ExFreePool(pSrbDataPacket->Frame);  pSrbDataPacket->Frame = NULL;
                IoFreeIrp(pSrbDataPacket->pIrp);  pSrbDataPacket->pIrp = NULL;
                ExFreePool(pSrbDataPacket);  pSrbDataPacket = NULL; 
            }
            return STATUS_NO_MEMORY;            
        }

        if(!(pSrbDataPacket->pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE))) {
            ExFreePool(pSrbDataPacket->Frame); pSrbDataPacket->Frame = NULL;
            ExFreePool(pSrbDataPacket);  pSrbDataPacket = NULL;

            for(j = 0; j < i; j++) {
                pSrbDataPacket = (PSRB_DATA_PACKET) \
                    RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
                ExFreePool(pSrbDataPacket->Frame);  pSrbDataPacket->Frame = NULL;
                IoFreeIrp(pSrbDataPacket->pIrp);  pSrbDataPacket->pIrp = NULL;
                ExFreePool(pSrbDataPacket);  pSrbDataPacket = NULL; 
            }
            return STATUS_INSUFFICIENT_RESOURCES;              
        }

        InsertTailList(&pStrmExt->DataDetachedListHead, &pSrbDataPacket->ListEntry); pStrmExt->cntDataDetached++;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DvFreePCResource(
    IN PSTREAMEX        pStrmExt
    )
{
    PSRB_DATA_PACKET pSrbDataPacket;
    KIRQL oldIrql;

    PAGED_CODE();

    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
    while(!IsListEmpty(&pStrmExt->DataDetachedListHead)) {
        pSrbDataPacket = (PSRB_DATA_PACKET)
            RemoveHeadList(
                &pStrmExt->DataDetachedListHead
                );

        ExFreePool(pSrbDataPacket->Frame);
        pSrbDataPacket->Frame = NULL;
        IoFreeIrp(pSrbDataPacket->pIrp);
        pSrbDataPacket->pIrp = NULL;
        ExFreePool(pSrbDataPacket);

        pStrmExt->cntDataDetached--;

        ASSERT(pStrmExt->cntDataDetached >= 0);
    }
    ASSERT(pStrmExt->cntDataDetached == 0);
    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

    return STATUS_SUCCESS;
}

NTSTATUS
DVGetUnitCapabilities(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    Get the targe device's unit capabilities
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES
    status return from 61883.

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;
    GET_UNIT_IDS * pUnitIds;
    GET_UNIT_CAPABILITIES * pUnitCaps;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query device's capability
    //
    if(!(pUnitIds = (GET_UNIT_IDS *) ExAllocatePool(NonPagedPool, sizeof(GET_UNIT_IDS)))) {
        IoFreeIrp(pIrp); pIrp = NULL;
        ExFreePool(pAVReq); pAVReq = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Query device's capability
    //
    if(!(pUnitCaps = (GET_UNIT_CAPABILITIES *) ExAllocatePool(NonPagedPool, sizeof(GET_UNIT_CAPABILITIES)))) {
        IoFreeIrp(pIrp); pIrp = NULL;
        ExFreePool(pAVReq); pAVReq = NULL;
        ExFreePool(pUnitIds);  pUnitIds = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetUnitInfo);
    pAVReq->GetUnitInfo.nLevel   = GET_UNIT_INFO_IDS;

    RtlZeroMemory(pUnitIds, sizeof(GET_UNIT_IDS));
    pAVReq->GetUnitInfo.Information = (PVOID) pUnitIds;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("\'Av61883_GetUnitInfo (IDS) Failed = 0x%x\n", Status));
        pDevExt->UniqueID.QuadPart = 0;
        pDevExt->ulVendorID = 0;
        pDevExt->ulModelID  = 0;
    }
    else {
        pDevExt->UniqueID   = pUnitIds->UniqueID;
        pDevExt->ulVendorID = pUnitIds->VendorID;
        pDevExt->ulModelID  = pUnitIds->ModelID;

        TRACE(TL_61883_WARNING,("\'UniqueId:(%x:%x); VID:%x; MID:%x\n", 
            pDevExt->UniqueID.LowPart, pDevExt->UniqueID.HighPart, 
            pUnitIds->VendorID,
            pUnitIds->ModelID
            ));
    }


    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetUnitInfo);
    pAVReq->GetUnitInfo.nLevel = GET_UNIT_INFO_CAPABILITIES; 

    RtlZeroMemory(pUnitCaps, sizeof(GET_UNIT_CAPABILITIES));
    pAVReq->GetUnitInfo.Information = (PVOID) pUnitCaps;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_GetUnitInfo (CAPABILITIES) Failed = 0x%x\n", Status));
        pDevExt->MaxDataRate    = 0;
        pDevExt->NumOutputPlugs = 0;
        pDevExt->NumInputPlugs  = 0;
        pDevExt->HardwareFlags  = 0;
    }
    else {
        pDevExt->MaxDataRate     = pUnitCaps->MaxDataRate;
        pDevExt->NumOutputPlugs = pUnitCaps->NumOutputPlugs;
        pDevExt->NumInputPlugs  = pUnitCaps->NumInputPlugs;
        pDevExt->HardwareFlags  = pUnitCaps->HardwareFlags;
    }

#if DBG
    if(   pDevExt->NumOutputPlugs == 0
       || pDevExt->NumInputPlugs == 0)
    {
        TRACE(TL_PNP_WARNING|TL_61883_WARNING,("\'Watch out! NumOPlug:%d; NumIPlug:%d\n", pDevExt->NumOutputPlugs, pDevExt->NumInputPlugs));
    }
#endif

    TRACE(TL_61883_WARNING,("\'UnitCaps:%s OutP:%d; InP:%d; MDRt:%s; HWFlg:%x; CtsF:%x; HwF:%x\n", 
         (pUnitCaps->HardwareFlags & AV_HOST_DMA_DOUBLE_BUFFERING_ENABLED) ? "*PAE*;":"",
         pUnitCaps->NumOutputPlugs,
         pUnitCaps->NumInputPlugs,
         pUnitCaps->MaxDataRate == 0 ? "S100": pUnitCaps->MaxDataRate == 1? "S200" : "S400 or +",   
         pUnitCaps->HardwareFlags,
         pUnitCaps->CTSFlags,
         pUnitCaps->HardwareFlags
         ));      

    ExFreePool(pUnitIds);   pUnitIds = NULL;
    ExFreePool(pUnitCaps);  pUnitCaps = NULL;
    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
DVGetDVPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
   )
/*++

Routine Description:

    Get the targe device's plug handle
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES
    status return from 61883.

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugHandle);
    pAVReq->GetPlugHandle.PlugNum = PlugNum;
    pAVReq->GetPlugHandle.hPlug   = 0;
    pAVReq->GetPlugHandle.Type    = PlugType;

    if(NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        *pPlugHandle = pAVReq->GetPlugHandle.hPlug;
        TRACE(TL_61883_WARNING,("\'Created h%sPlugDV[%d]=%x\n", PlugType == CMP_PlugIn ? "I" : "O", PlugNum, *pPlugHandle));
    } else {
        TRACE(TL_61883_ERROR,("\'Created h%sPlugDV[%d] failed; Status:%x\n", PlugType == CMP_PlugIn ? "I" : "O", PlugNum, Status));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


#ifdef NT51_61883

NTSTATUS
DVSetAddressRangeExclusive( 
    IN PDVCR_EXTENSION  pDevExt
   )
/*++

Routine Description:

    Set this mode so that our local plug will be created in address exclusive mode.
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;
    SET_CMP_ADDRESS_TYPE SetCmpAddress;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_SetUnitInfo);
    pAVReq->SetUnitInfo.nLevel   = SET_CMP_ADDRESS_RANGE_TYPE;
    SetCmpAddress.Type = CMP_ADDRESS_TYPE_EXCLUSIVE;
    pAVReq->SetUnitInfo.Information = (PVOID) &SetCmpAddress;

    if(!NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        TRACE(TL_61883_ERROR,("\'SET_CMP_ADDRESS_RANGE_TYPE Failed:%x\n", Status));
    } else {
        TRACE(TL_61883_TRACE,("\'SET_CMP_ADDRESS_RANGE_TYPE suceeded.\n"));
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
DVGetUnitIsochParam( 
    IN PDVCR_EXTENSION  pDevExt,
    OUT UNIT_ISOCH_PARAMS  * pUnitIoschParams
   )
/*++

Routine Description:

    Create an enumated local PC PCR
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Get Unit isoch parameters
    //
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetUnitInfo);
    pAVReq->GetUnitInfo.nLevel   = GET_UNIT_INFO_ISOCH_PARAMS;

    RtlZeroMemory(pUnitIoschParams, sizeof(UNIT_ISOCH_PARAMS));
    pAVReq->GetUnitInfo.Information = (PVOID) pUnitIoschParams;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_GetUnitInfo Failed:%x\n", Status));
        Status = STATUS_UNSUCCESSFUL;  // Cannot stream without this!
    }

    TRACE(TL_61883_WARNING,("\'IsochParam: RxPkt:%d, RxDesc:%d; XmPkt:%d, XmDesc:%d\n", 
        pUnitIoschParams->RX_NumPackets,
        pUnitIoschParams->RX_NumDescriptors,
        pUnitIoschParams->TX_NumPackets,
        pUnitIoschParams->TX_NumDescriptors
        ));

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
DVSetUnitIsochParams( 
    IN PDVCR_EXTENSION  pDevExt,
    IN UNIT_ISOCH_PARAMS  *pUnitIoschParams
   )
/*++

Routine Description:

    Set AV unit's isoch parameters via 61883.
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_SetUnitInfo);
    pAVReq->SetUnitInfo.nLevel   = SET_UNIT_INFO_ISOCH_PARAMS;
    pAVReq->SetUnitInfo.Information = (PVOID) pUnitIoschParams;
    if(!NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        TRACE(TL_61883_ERROR,("DVSetUnitIsochParams: Av61883_SetUnitInfo Failed:%x\n", Status));
    }

    TRACE(TL_61883_WARNING,("\'UnitIsochParams: Set: RxPkt:%d, RxDesc:%d; XmPkt:%d, XmDesc:%d\n", 
        pUnitIoschParams->RX_NumPackets,
        pUnitIoschParams->RX_NumDescriptors,
        pUnitIoschParams->TX_NumPackets,
        pUnitIoschParams->TX_NumDescriptors
        ));

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
DVMakeP2PConnection( 
    IN PDVCR_EXTENSION  pDevExt,
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX  pStrmExt
   )
/*++

Routine Description:

    Make a point to point connection .
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_Connect);
    pAVReq->Connect.Type = CMP_PointToPoint;  // !!

    pAVReq->Connect.hOutputPlug      = pStrmExt->hOutputPcr;
    pAVReq->Connect.hInputPlug       = pStrmExt->hInputPcr;

    // see which way we the data will flow...
    if(DataFlow == KSPIN_DATAFLOW_OUT) {

        // Other parameters !!

    } else {

        pAVReq->Connect.Format.FMT       = pStrmExt->cipQuad2[0];  // From AV/C in/outpug plug signal format status cmd
        // 00 for NTSC, 80 for PAL; set the 50/60 bit       
        pAVReq->Connect.Format.FDF_hi    = pStrmExt->cipQuad2[1];  // From AV/C in/outpug plug signal format status cmd   

        //
        // 16bit SYT field = 4BitCycleCount:12BitCycleOffset;
        // Will be set by 61883
        //
        pAVReq->Connect.Format.FDF_mid   = 0;  
        pAVReq->Connect.Format.FDF_lo    = 0;

        //
        // Constants depend on the A/V data format (in or out plug format)
        //
        pAVReq->Connect.Format.bHeader   = (BOOL) DVFormatInfoTable[pDevExt->VideoFormatIndex].SrcPktHeader;
        pAVReq->Connect.Format.Padding   = (UCHAR) DVFormatInfoTable[pDevExt->VideoFormatIndex].QuadPadCount;
        pAVReq->Connect.Format.BlockSize = (UCHAR) DVFormatInfoTable[pDevExt->VideoFormatIndex].DataBlockSize; 
        pAVReq->Connect.Format.Fraction  = (UCHAR) DVFormatInfoTable[pDevExt->VideoFormatIndex].FractionNumber;
    }

    // Set this so that 61883 can know it is NTSC or PAL;
    // For read: It is needed so 61883 can preallocate just-enough packets
    //           so that data can return in a much regular interval.
    if(   pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC 
       || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC)
        pAVReq->Connect.Format.BlockPeriod = 133466800; // nano-sec
    else
        pAVReq->Connect.Format.BlockPeriod = 133333333; // nano-sec

    TRACE(TL_61883_WARNING,("\'cipQuad2[0]:%x, cipQuad2[1]:%x, cipQuad2[2]:%x, cipQuad2[3]:%x\n", 
        pStrmExt->cipQuad2[0],
        pStrmExt->cipQuad2[1],
        pStrmExt->cipQuad2[2],
        pStrmExt->cipQuad2[3]
        ));


    TRACE(TL_61883_WARNING,("\'Connect:oPcr:%x->iPcr:%x; cipQuad2[%.2x:%.2x:%.2x:%.2x]\n", 
        pAVReq->Connect.hOutputPlug,
        pAVReq->Connect.hInputPlug,
        pAVReq->Connect.Format.FMT,
        pAVReq->Connect.Format.FDF_hi,
        pAVReq->Connect.Format.FDF_mid,
        pAVReq->Connect.Format.FDF_lo
        ));

    TRACE(TL_61883_WARNING,("\'        BlkSz %d; SrcPkt %d; AvgTm %d, BlkPrd %d\n", 
        pAVReq->Connect.Format.BlockSize,
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulSrcPackets,
        DVFormatInfoTable[pDevExt->VideoFormatIndex].ulAvgTimePerFrame,
        (DWORD) pAVReq->Connect.Format.BlockPeriod
        ));

    if(NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        TRACE(TL_61883_WARNING,("\'hConnect:%x\n", pAVReq->Connect.hConnect));
        ASSERT(pAVReq->Connect.hConnect != NULL);
        pStrmExt->hConnect = pAVReq->Connect.hConnect;
    } 
    else {
        TRACE(TL_61883_ERROR,("Av61883_Connect Failed; Status:%x\n", Status));
        ASSERT(!NT_SUCCESS(Status) && "DisConnect failed");        
        pStrmExt->hConnect = NULL;
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}

NTSTATUS
DVCreateLocalPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
   )
/*++

Routine Description:

    Create an enumated local PC PCR
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Need to correctly update Overhead_ID and payload fields of PC's own oPCR
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_CreatePlug);

    pAVReq->CreatePlug.PlugNum   = PlugNum;
    pAVReq->CreatePlug.hPlug     = NULL;

    pAVReq->CreatePlug.Context   = NULL;
    pAVReq->CreatePlug.pfnNotify = NULL;
    pAVReq->CreatePlug.PlugType  = PlugType;

    //
    // Initialize oPCR values to default values using SDDV signal mode 
    // with speed of 100Mbps data rate
    //

    pAVReq->CreatePlug.Pcr.oPCR.OnLine     = 0;  // We are not online so we cannot be programmed.
    pAVReq->CreatePlug.Pcr.oPCR.BCCCounter = 0;
    pAVReq->CreatePlug.Pcr.oPCR.PPCCounter = 0;
    pAVReq->CreatePlug.Pcr.oPCR.Channel    = 0;

    pAVReq->CreatePlug.Pcr.oPCR.DataRate   = CMP_SPEED_S100;
    pAVReq->CreatePlug.Pcr.oPCR.OverheadID = PCR_OVERHEAD_ID_SDDV;
    pAVReq->CreatePlug.Pcr.oPCR.Payload    = PCR_PAYLOAD_SDDV;

    if(NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        *pPlugHandle    = pAVReq->CreatePlug.hPlug;
        TRACE(TL_61883_WARNING,("\'Created h%sPlugPC[%d]=%x\n", PlugType == CMP_PlugIn ? "I" : "O", PlugNum, *pPlugHandle));
    } else {
        TRACE(TL_61883_ERROR,("\'Created h%sPlugPC[%d] failed; Status:%x\n", pAVReq->CreatePlug.PlugType == CMP_PlugIn ? "I" : "O", PlugNum, Status));
        Status = STATUS_INSUFFICIENT_RESOURCES;  // No plug!
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
DVDeleteLocalPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN HANDLE PlugHandle
   )
/*++

Routine Description:

    Delete an enumated local PC PCR
 
Arguments:

Return Value:

    Nothing

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) {  
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Delete our local oPCR 
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_DeletePlug);
    pAVReq->DeletePlug.hPlug = PlugHandle;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_DeletePlug Failed = 0x%x\n", Status));        
        // Do not care if this result in error.
    } else {
        TRACE(TL_61883_WARNING,("\'Av61883_DeletePlug: Deleted!\n", pDevExt->hOPcrPC)); 
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}
#endif

NTSTATUS
DVGetPlugState(
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PAV_61883_REQUEST   pAVReq
    )
/*++

Routine Description:

    Ask 61883.sys for the plug state.
 
Arguments:

Return Value:

    Nothing

--*/
{
    PIRP      pIrp;
    NTSTATUS  Status = STATUS_SUCCESS;
   
    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;    

    //
    // Query oPCR plug state
    //
    if(pStrmExt->hOutputPcr) {
        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        INIT_61883_HEADER(pAVReq, Av61883_GetPlugState);
        pAVReq->GetPlugState.hPlug = pStrmExt->hOutputPcr;

        Status = 
            DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                );

        if(!NT_SUCCESS(Status)) {
            TRACE(TL_61883_ERROR,("Av61883_GetPlugState Failed %x\n", Status));
            goto ExitGetState;
        }
        else {

            TRACE(TL_61883_WARNING,("\'PlgState:(oPCR:%x): State %x; DRate %d; Payld %d; BCCnt %d; PPCnt %d\n", 
                pAVReq->GetPlugState.hPlug,
                pAVReq->GetPlugState.State,
                pAVReq->GetPlugState.DataRate,
                pAVReq->GetPlugState.Payload,
                pAVReq->GetPlugState.BC_Connections,
                pAVReq->GetPlugState.PP_Connections
                ));
        }
    }

    //
    // Query iPCR plug state
    //
    if(pStrmExt->hInputPcr) {
        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        INIT_61883_HEADER(pAVReq, Av61883_GetPlugState);
        pAVReq->GetPlugState.hPlug = pStrmExt->hInputPcr;

        Status = 
            DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                );

        if(!NT_SUCCESS(Status)) {

            TRACE(TL_61883_ERROR,("Av61883_GetPlugState Failed %x\n", Status));
            goto ExitGetState;
        }
        else {

            TRACE(TL_61883_WARNING,("\'PlugState(iPCR:%x): State %x; DRate %d; Payld %d; BCCnt %d; PPCnt %d\n", 
                pAVReq->GetPlugState.hPlug,
                pAVReq->GetPlugState.State,
                pAVReq->GetPlugState.DataRate,
                pAVReq->GetPlugState.Payload,
                pAVReq->GetPlugState.BC_Connections,
                pAVReq->GetPlugState.PP_Connections
                ));
        }
    }

ExitGetState:
    IoFreeIrp(pIrp);
    return Status;
}


NTSTATUS
DVCreateAttachFrameThread(
    PSTREAMEX  pStrmExt
    )
/*++

Routine Description:

    Create a system thread for attaching data (for transmiut to DV only).
 
Arguments:

Return Value:

    STATUS_SUCCESS or
    return status from PsCreateSystemThread

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hAttachFrameThread;

    Status =  
        PsCreateSystemThread(
            &hAttachFrameThread,
            (ACCESS_MASK) 0,
            NULL,
            (HANDLE) 0,
            NULL,
            DVAttachFrameThread,
            pStrmExt
            );

    if(!NT_SUCCESS(Status)) {
        pStrmExt->bTerminateThread = TRUE;
        TRACE(TL_CIP_ERROR|TL_FCP_ERROR,("\'PsCreateSystemThread() failed %x\n", Status));
        ASSERT(NT_SUCCESS(Status));

    }
    else {
        pStrmExt->bTerminateThread = FALSE;  // Just started!
        Status = 
            ObReferenceObjectByHandle(
            hAttachFrameThread,
            THREAD_ALL_ACCESS,
            NULL,
            KernelMode,
            &pStrmExt->pAttachFrameThreadObject,
            NULL
            );

         TRACE(TL_CIP_WARNING|TL_PNP_WARNING,("\'ObReferenceObjectByHandle() St %x; Obj %x\n", Status, pStrmExt->pAttachFrameThreadObject));
         ZwClose(hAttachFrameThread);

         // To signl end of an event
         KeInitializeEvent(&pStrmExt->hThreadEndEvent, NotificationEvent, FALSE);  // Non-signal
    }

    return Status;
}

NTSTATUS
DVConnect(
    IN KSPIN_DATAFLOW   ulDataFlow,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PAV_61883_REQUEST   pAVReq
    )
/*++

Routine Description:

    Ask 61883.sys to allocate isoch bandwidth and program PCR.
 
Arguments:

Return Value:

    STATUS_SUCCESS
    other Status from calling other routine.

--*/
{
    NTSTATUS  Status;
  

    PAGED_CODE();

    ASSERT(pStrmExt->hConnect == NULL);

    //
    // Do not reconnect.  61883 should handle all the necessary CMP reconnect.
    //
    if(pStrmExt->hConnect) {
        return STATUS_SUCCESS;
    }


#ifdef SUPPORT_NEW_AVC
    //
    // For Device to device connection, we only connect if we are the data producer (oPCR)
    //

    TRACE(TL_61883_WARNING,("\'[pStrmExt:%x]: %s PC (oPCR:%x, iPCR:%x); DV (oPCR:%x;  iPCR:%x)\n",
        pStrmExt, 
        ulDataFlow == KSPIN_DATAFLOW_OUT ? "OutPin" : "InPin",
        pDevExt->hOPcrPC, 0,
        pDevExt->hOPcrDV, pDevExt->hIPcrDV       
        ));

    if(
       pStrmExt->bDV2DVConnect &&
       (pStrmExt->hOutputPcr != pDevExt->hOPcrDV)) {
        TRACE(TL_61883_WARNING,("\'** pStrmExt:%x not data producer!\n\n", pStrmExt));

        return STATUS_SUCCESS;
    }
#endif


#ifdef NT51_61883
    //
    // Set Unit isoch parameters:
    // The number of packets is depending on two factors:
    // For a PAE system, number of packets cannnot be bigger than 64k/480 = 133
    // For capture, number of packets should not be bigger than max packets to construct a DV buffer.
    // This is needed to avoid completing two buffers in the same descriptor and can cause glitched
    // in the "real time" playback of the data, esp the audio.
    //
    if(pDevExt->HardwareFlags & AV_HOST_DMA_DOUBLE_BUFFERING_ENABLED) {  
        // PAE system
        pDevExt->UnitIoschParams.RX_NumPackets = 
        // pDevExt->UnitIoschParams.TX_NumPackets = // Use the default set by 61883
            ((pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC) ? 
             MAX_SRC_PACKETS_PER_NTSC_FRAME_PAE : MAX_SRC_PACKETS_PER_PAL_FRAME_PAE);
    } else {
        pDevExt->UnitIoschParams.RX_NumPackets = 
        // pDevExt->UnitIoschParams.TX_NumPackets = // Use the default set by 61883
            ((pDevExt->VideoFormatIndex == FMT_IDX_SD_DVCR_NTSC || pDevExt->VideoFormatIndex == FMT_IDX_SDL_DVCR_NTSC) ? 
             MAX_SRC_PACKETS_PER_NTSC_FRAME     : MAX_SRC_PACKETS_PER_PAL_FRAME);
    }

    if(!NT_SUCCESS(
        Status = DVSetUnitIsochParams(
            pDevExt,
            &pDevExt->UnitIoschParams
            ))) {
        return Status;
    }

#endif  // NT51_61883

    //
    // Make a point to point connection
    //
    Status = 
        DVMakeP2PConnection(
            pDevExt,
            ulDataFlow,
            pStrmExt
            );

    return Status;
}




NTSTATUS
DVDisconnect(
    IN KSPIN_DATAFLOW   ulDataFlow,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt
    )
/*++

Routine Description:

    Ask 61883.sys to free isoch bandwidth and program PCR.
    
Arguments:

Return Value:

    Nothing

--*/
{
    PIRP     pIrp;
    NTSTATUS Status = STATUS_SUCCESS;
    PAV_61883_REQUEST   pAVReq;

    PAGED_CODE();

    //
    // Use the hPlug to disconnect
    //
    if(pStrmExt->hConnect) {

        if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST))))
            return STATUS_INSUFFICIENT_RESOURCES;                    

        if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE))) {
            ExFreePool(pAVReq);  pAVReq = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        INIT_61883_HEADER(pAVReq, Av61883_Disconnect);
        pAVReq->Disconnect.hConnect = pStrmExt->hConnect;
        ASSERT(pStrmExt->hConnect);
        
        if(!NT_SUCCESS(
            Status = DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                ))) {
            // This could be caused that the connection was not P2P, and 
            // it tried to disconnect.
            TRACE(TL_61883_ERROR,("\'Disconnect hConnect:%x failed; ST %x; AvReq->ST %x\n", pStrmExt->hConnect, Status, pAVReq->Flags  ));
            // ASSERT(NT_SUCCESS(Status) && "DisConnect failed");
        } else {
            TRACE(TL_61883_TRACE,("\'Disconnect suceeded; ST %x; AvReq->ST %x\n", Status, pAVReq->Flags  ));
        }

        IoFreeIrp(pIrp);  pIrp = NULL;
        ExFreePool(pAVReq); pAVReq = NULL;

        TRACE(TL_61883_WARNING,("\'DisConn %s St:%x; Stat: SRBCnt:%d; [Pic# =? Prcs:Drp:Cncl:Rpt] [%d ?=%d+%d+%d+%d]\n", 
            ulDataFlow  == KSPIN_DATAFLOW_OUT ? "[OutPin]" : "[InPin]",
            Status, 
            (DWORD) pStrmExt->cntSRBReceived,
            (DWORD) pStrmExt->PictureNumber,
            (DWORD) pStrmExt->FramesProcessed, 
            (DWORD) pStrmExt->FramesDropped,
            (DWORD) pStrmExt->cntSRBCancelled,  // number of SRB_READ/WRITE_DATA cancelled
            (DWORD) (pStrmExt->PictureNumber - pStrmExt->FramesProcessed - pStrmExt->FramesDropped - pStrmExt->cntSRBCancelled)
            ));
#if DBG
    if(DVFormatInfoTable[pDevExt->VideoFormatIndex].SrcPktHeader) {
        ULONG ulElapsed = (DWORD) ((GetSystemTime() - pStrmExt->tmStreamStart)/(ULONGLONG) 10000);
        TRACE(TL_61883_WARNING,("\'****-* TotalSrcPkt:%d; DisCont:%d; Elapse:%d msec; DataRate:%d bps *-****\n", \
            pStrmExt->lTotalCycleCount, pStrmExt->lDiscontinuityCount,
            ulElapsed,
            pStrmExt->lTotalCycleCount * 188 * 1000 / ulElapsed * 8
            )); 
    }
#endif

        // We will not have another chance to reconnect it so we assume it is disconnected.
        pStrmExt->hConnect = NULL; 
    }  

    return Status;
}


//
// GetSystemTime in 100 nS units
//

ULONGLONG GetSystemTime()
{

    LARGE_INTEGER rate, ticks;

    ticks = KeQueryPerformanceCounter(&rate);

    return (KSCONVERT_PERFORMANCE_TIME(rate.QuadPart, ticks));
}




#define DIFBLK_SIZE 12000

#define PACK_NO_INFO            0xff

// Subcode header identifier
#define SC_HDR_TIMECODE         0x13
#define SC_HDR_BINARYGROUP      0x14

// header identifier

#define AAUX_HDR_SOURCE         0x50
#define AAUX_HDR_SOURCE_CONTROL 0x51
#define AAUX_HDR_REC_DATE       0x52
#define AAUX_HDR_REC_TIME       0x53
#define AAUX_HDR_BINARY_GROUP   0x54
#define AAUX_HDR_CC             0x55
#define AAUX_HDR_TR             0x56

#define VAUX_HDR_SOURCE         0x60
#define VAUX_HDR_SOURCE_CONTROL 0x61
#define VAUX_HDR_REC_DATE       0x62
#define VAUX_HDR_REC_TIME       0x63
#define VAUX_HDR_BINARY_GROUP   0x64
#define VAUX_HDR_CC             0x65
#define VAUX_HDR_TR             0x66

// Determine section type (MS 3 bits); Fig.66; Table 36.
#define ID0_SCT_MASK            0xe0
#define ID0_SCT_HEADER          0x00
#define ID0_SCT_SUBCODE         0x20
#define ID0_SCT_VAUX            0x40
#define ID0_SCT_AUDIO           0x60
#define ID0_SCT_VIDEO           0x80

// A pack is consisted of one byte of header identifier and 4 bytes of data; Part2, annex D.
typedef struct _DV_PACK {
    UCHAR Header;
    UCHAR Data[4];
} DV_PACK, *PDV_PACK;

typedef struct _DV_H0 {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    UCHAR DSF;
    UCHAR DFTIA;
    UCHAR TF1;
    UCHAR TF2;
    UCHAR TF3;

    UCHAR Reserved[72];
} DV_H0, *PDV_H0;

typedef struct _DV_SC {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb0;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb1;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb2;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb3;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb4;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb5;

    UCHAR Reserved[29];
} DV_SC, *PDV_SC;

#define MAX_VAUX_PACK 15

typedef struct _DV_VAUX {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    DV_PACK Pack[MAX_VAUX_PACK];

    UCHAR Reserved[2];
} DV_VAUX, *PDV_VAUX;

typedef struct _DV_A {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;
    DV_PACK Pack;
    UCHAR Data[72];
} DV_A, *PDV_A;

typedef struct _DV_V {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;    
    UCHAR Data[77]; // 3..79
} DV_V, *PDV_V;

// Two source packets
#define V_BLOCKS 15
typedef struct _DV_AV {
    DV_A  A;
    DV_V  V[V_BLOCKS];
} DV_AV, *PDV_AV; 


#define SC_SECTIONS     2
#define VAUX_SECTIONS   3
#define AV_SECTIONS     9

typedef struct _DV_DIF_SEQ {
    DV_H0   H0;
    DV_SC   SC[SC_SECTIONS];
    DV_VAUX VAux[VAUX_SECTIONS];
    DV_AV   AV[AV_SECTIONS];
} DV_DIF_SEQ, *PDV_DIF_SEQ;


typedef struct _DV_FRAME_NTSC {
    DV_DIF_SEQ DifSeq[10];
} DV_FRAME_NTSC, *PDV_FRAME_NTSC;

typedef struct _DV_FRAME_PAL {
    DV_DIF_SEQ DifSeq[12];
} DV_FRAME_PAL, *PDV_FRAME_PAL;

// By setting REC MODE to 111b (invalid recording) can
// cause DV to mute the audio
#define AAUX_REC_MODE_INVALID_MASK 0x38   // xx11:1xxx
#define AAUX_REC_MODE_ORIGINAL     0x08   // xx00:1xxx


#ifdef MSDV_SUPPORT_MUTE_AUDIO
// #define SHOW_ONE_FIELD_TWICE

BOOL
DVMuteDVFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN OUT PUCHAR      pFrameBuffer,
    IN BOOL            bMuteAudio
    )
{
    PDV_DIF_SEQ pDifSeq;
#ifdef SHOW_ONE_FIELD_TWICE  
    PDV_VAUX    pVAux;
    ULONG k;
#endif
    ULONG i, j;
#ifdef SHOW_ONE_FIELD_TWICE  
    BOOL bFound1 = FALSE;
#endif
    BOOL bFound2 = FALSE;

    pDifSeq = (PDV_DIF_SEQ) pFrameBuffer;

    // find the VVAX Source pack
    for (i=0; i < DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences; i++) {

#ifdef SHOW_ONE_FIELD_TWICE  // Advise by Adobe that we may want to show bothj field but mute audio
        // Make the field2 output twice, FrameChange to 0 (same as previous frame)
        for (j=0; j < VAUX_SECTIONS; j++) {
            pVAux = &pDifSeq->VAux[j];
            if((pVAux->ID0 & ID0_SCT_MASK) != ID0_SCT_VAUX) {
                TRACE(TL_CIP_WARNING,("\'Invalid ID0:%.2x for pVAUX:%x (Dif:%d;V%d;S%d)\n", pVAux->ID0, pVAux, i, j, k)); 
                continue;
            }

            for (k=0; k< MAX_VAUX_PACK; k++) {
                if(pVAux->Pack[k].Header == VAUX_HDR_SOURCE_CONTROL) {
                    if(bMuteAudio) {
                        TRACE(TL_CIP_WARNING,("\'Mute Audio; pDifSeq:%x; pVAux:%x; (Dif:%d,V%d,S%d); %.2x,[%.2x,%.2x,%.2x,%.2x]; pack[2]->%.2x\n", \
                            pDifSeq, pVAux, i, j, k, \
                            pVAux->Pack[k].Header, pVAux->Pack[k].Data[0], pVAux->Pack[k].Data[1], pVAux->Pack[k].Data[2], pVAux->Pack[k].Data[3], \
                            (pVAux->Pack[k].Data[2] & 0x1F) ));
                        pVAux->Pack[k].Data[2] &= 0x1f; // 0x1F; // set FF, FS and FC to 0
                        TRACE(TL_CIP_TRACE,("\'pVAux->Pack[k].Data[2] = %.2x\n", pVAux->Pack[k].Data[2])); 
                    } else {
                        TRACE(TL_CIP_TRACE,("\'un-Mute Audio; pack[2]: %.2x ->%.2x\n", pVAux->Pack[k].Data[2], (pVAux->Pack[k].Data[2] | 0xc0) ));  
                        pVAux->Pack[k].Data[2] |= 0xe0; // set FF, FS and FCto 1; Show both fields in field 1,2 order
                    }
                    bFound1 = TRUE;
                    break;   // Set only the 1st occurrence
                }
            }
        }
#endif

        for (j=0; j < AV_SECTIONS; j++) {
            if(pDifSeq->AV[j].A.Pack.Header == AAUX_HDR_SOURCE_CONTROL) {
                TRACE(TL_CIP_TRACE,("\'A0Aux %.2x,[%.2x,%.2x,%.2x,%.2x] %.2x->%.2x\n", \
                    pDifSeq->AV[j].A.Pack.Header,  pDifSeq->AV[j].A.Pack.Data[0], \
                    pDifSeq->AV[j].A.Pack.Data[1], pDifSeq->AV[j].A.Pack.Data[2], pDifSeq->AV[j].A.Pack.Data[3], \
                    pDifSeq->AV[j].A.Pack.Data[1], pDifSeq->AV[j].A.Pack.Data[1] | AAUX_REC_MODE_INVALID_MASK
                    ));
                if(bMuteAudio) 
                    pDifSeq->AV[j].A.Pack.Data[1] |= AAUX_REC_MODE_INVALID_MASK;  // Cause DV to mute this.
                else 
                    pDifSeq->AV[j].A.Pack.Data[1] = \
                        (pDifSeq->AV[j].A.Pack.Data[1] & ~AAUX_REC_MODE_INVALID_MASK) | AAUX_REC_MODE_ORIGINAL;
                bFound2 = TRUE;
                break;  // Set only the 1st occurrence
            }
        }

        // Must do the 1st occurance of all Dif sequences;
        pDifSeq++;  // Next DIF sequence
    }
#ifdef SHOW_ONE_FIELD_TWICE  
    return (bFound1 && bFound2);  
#else
    return bFound2;
#endif
}
#endif

#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA

VOID
DVCRExtractTimecodeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    )
{
    PUCHAR pDIFBlk;
    PUCHAR pS0, pS1, pSID0;
    ULONG i, j;
    BYTE LastTimecode[4], Timecode[4]; // hh:mm:ss,ff
    DWORD LastAbsTrackNumber, AbsTrackNumber;
    PUCHAR pSID1;
    BYTE  Timecode2[4]; // hh:mm:ss,ff
    DWORD AbsTrackNumber2;
    BOOL bGetAbsT = TRUE, bGetTimecode = TRUE;


    // Can be called at DISPATCH_LEVEL

    pDIFBlk = (PUCHAR) pFrameBuffer;

    // Save the last timecode so we will now if it has 

    LastTimecode[0] = pStrmExt->Timecode[0];
    LastTimecode[1] = pStrmExt->Timecode[1];
    LastTimecode[2] = pStrmExt->Timecode[2];
    LastTimecode[3] = pStrmExt->Timecode[3];

    LastAbsTrackNumber = pStrmExt->AbsTrackNumber;

    //
    // Traverse thru every DIF BLOCK looking for VA0,1 and 2
    for(i=0; i < DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences; i++) {

        pS0 = pDIFBlk + 80;
        pS1 = pS0     + 80;


        //
        // Is this Subcode source packet? See Table 36 (P.111) of the Blue Book
        //
        if ((pS0[0] & 0xe0) == 0x20 && (pS1[0] & 0xe0) == 0x20) {

            if(bGetAbsT) {
                //
                // See Figure 42 (p. 94) of the Blue book
                // SID0(Low nibble),1 (high nibble) of every three subcode sync block can form the ATN
                //
                pSID0 = &pS0[3];              
                AbsTrackNumber = 0;
                for (j = 0 ; j < 3; j++) {
                    AbsTrackNumber = (( ( (pSID0[0] & 0x0f) << 4) | (pSID0[1] >> 4) ) << (j * 8)) | AbsTrackNumber;
                    pSID0 += 8;
                    bGetAbsT = FALSE;
                }

                pSID1 = &pS1[3];
                AbsTrackNumber2 = 0;
                for (j = 0 ; j < 3; j++) {
                    AbsTrackNumber2 = (( ( (pSID1[0] & 0x0f) << 4) | (pSID1[1] >> 4) ) << (j * 8)) | AbsTrackNumber2;
                    pSID1 += 8;
                }
            
                // Verify that the track number is the same!
                if(AbsTrackNumber == AbsTrackNumber2) {

                    bGetAbsT = FALSE;
                } else {
                   bGetAbsT = TRUE;
                   TRACE(TL_CIP_TRACE,("\'%d Sequence;  AbsT (%d,%d) != AbsT2 (%d,%d)\n",
                       i,
                       AbsTrackNumber / 2, AbsTrackNumber & 0x01,                       
                       AbsTrackNumber2 / 2, AbsTrackNumber2 & 0x01
                       ));
                }
            }


            if(bGetTimecode) {
                // See Figure 68 (p. 114) of the Blue Book
                // Subcode sync block number 3, 4 and 5
                for(j = 3; j <= 5; j++) {
                    // 3 bytes of IDs and follow by sequence of 8 bytes SyncBlock (3:5); 
                    // 0x13 == TIMECODE
                    if(pS0[3+3+j*8] == 0x13 
                       && pS0[3+3+j*8+4] != 0xff
                       && pS0[3+3+j*8+3] != 0xff
                       && pS0[3+3+j*8+2] != 0xff
                       && pS0[3+3+j*8+1] != 0xff) {

                        Timecode[0] = pS0[3+3+j*8+4]&0x3f;  // hh
                        Timecode[1] = pS0[3+3+j*8+3]&0x7f;  // mm
                        Timecode[2] = pS0[3+3+j*8+2]&0x7f;  // ss
                        Timecode[3] = pS0[3+3+j*8+1]&0x3f;  // ff
                                        
                        bGetTimecode = FALSE;
                        break;                  
                   }
                }

                // Subcode sync block number 9, 10 and 11
                for(j = 3; j <= 5; j++) {
                    // 3 bytes of IDs and follow by sequence of 8 bytes SyncBlock (3:5); 
                    // 0x13 == TIMECODE
                    if(pS1[3+3+j*8] == 0x13
                       && pS1[3+3+j*8+4] != 0xff
                       && pS1[3+3+j*8+3] != 0xff
                       && pS1[3+3+j*8+2] != 0xff
                       && pS1[3+3+j*8+1] != 0xff) {

                       Timecode2[0] = pS1[3+3+j*8+4]&0x3f;  // hh
                       Timecode2[1] = pS1[3+3+j*8+3]&0x7f;  // mm
                       Timecode2[2] = pS1[3+3+j*8+2]&0x7f;  // ss
                       Timecode2[3] = pS1[3+3+j*8+1]&0x3f;  // ff
            
                       bGetTimecode = FALSE;
                       break;                   
                    }
                }

                //
                // Verify
                //
                if(!bGetTimecode) {

                    if( Timecode[0] == Timecode2[0] 
                     && Timecode[1] == Timecode2[1] 
                     && Timecode[2] == Timecode2[2] 
                     && Timecode[3] == Timecode2[3]) {

                       } else {
                        bGetTimecode = TRUE;
                        TRACE(TL_CIP_TRACE,("\'%d Sequence;  %.2x:%.2x:%.2x,%.2x != %.2x:%.2x:%.2x,%.2x\n",
                            i,
                            Timecode[0],  Timecode[1],  Timecode[2],  Timecode[3],
                            Timecode2[0], Timecode2[1], Timecode2[2], Timecode2[3]
                            ));
                    }       
                }
            }
        }
        
        if(!bGetAbsT && !bGetTimecode) 
            break;

        pDIFBlk += DIFBLK_SIZE;  // Get to next block    
                
    }

    if(!bGetAbsT && pStrmExt->AbsTrackNumber != AbsTrackNumber) {
        pStrmExt->AbsTrackNumber = AbsTrackNumber;  // BF is the LSB  
        pStrmExt->bATNUpdated = TRUE;
        TRACE(TL_CIP_TRACE,("\'Extracted TrackNum:%d; DicontBit:%d\n", AbsTrackNumber / 2, AbsTrackNumber & 0x01));
    }

    if(!bGetTimecode &&
        (
         Timecode[0] != LastTimecode[0] ||
         Timecode[1] != LastTimecode[1] ||
         Timecode[2] != LastTimecode[2] ||
         Timecode[3] != LastTimecode[3]
        ) 
      )  { 
        pStrmExt->Timecode[0] = Timecode[0];  // hh
        pStrmExt->Timecode[1] = Timecode[1];  // mm
        pStrmExt->Timecode[2] = Timecode[2];  // mm
        pStrmExt->Timecode[3] = Timecode[3];  // ff
        pStrmExt->bTimecodeUpdated = TRUE;

        TRACE(TL_CIP_TRACE,("\'Extracted Timecode %.2x:%.2x:%.2x,%.2x\n", Timecode[0], Timecode[1], Timecode[2], Timecode[3]));
    }    
}

#endif // MSDV_SUPPORT_EXTRACT_SUBCODE_DATA


#ifdef MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

VOID
DVCRExtractRecDateAndTimeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    )
{
    PUCHAR pDIFBlk;
    PUCHAR pS0, pS1;
    ULONG i, j;
    BOOL bGetRecDate = TRUE, bGetRecTime = TRUE;

    // Can be called at DISPATCH_LEVEL


    pDIFBlk = (PUCHAR) pFrameBuffer + DIFBLK_SIZE * DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences/2;


    //
    // REC Data (VRD) and Time (VRT) on in the 2nd half oa a video frame
    // 
    for(i=DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences/2; i < DVFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences; i++) {

        pS0 = pDIFBlk + 80;
        pS1 = pS0     + 80;


        //
        // Find SC0 and SC1. See Table 36 (P.111) of the Blue Book
        //
        // SC0/1: ID(0,1,2), Data (3,50), Reserved(51-79)
        //     SC0:Data: SSYB0(3..10), SSYB1(11..18), SSYB2(19..26), SSYB3(27..34), SSYB4(35..42),   SSYB5(43..50)
        //     SC1:Data: SSYB6(3..10), SSYB7(11..18), SSYB8(19..26), SSYB9(27..34), SSYB10(35..42), SSYB11(43..50)
        //         SSYBx(SubCodeId0, SubcodeID1, Reserved, Pack(3,4,5,6,7))
        //
        //  TTC are in the 1st half: SSYB0..11 (every)
        //  TTC are in the 2nd half: SSYB0,3,6,9
        //  VRD are in the 2nd half of a video frame, SSYB1,4,7,10
        //  VRT are in the 2nd half of a video frame, SSYB2,5,8,11
        //

        // Subcode data ?
        if ((pS0[0] & 0xe0) == 0x20 && (pS1[0] & 0xe0) == 0x20) {

            //
            // RecDate: VRD
            //
            if(bGetRecDate) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 1(SSYB1),4(SSYB4) for SC0
                for(j=0; j <= 5 ; j++) {
                    if(j == 1 || j == 4) {
                        // 0x62== RecDate
                        if(pS0[3+3+j*8] == 0x62) {
                            pStrmExt->RecDate[0] = pS0[3+3+j*8+4];        // Year
                            pStrmExt->RecDate[1] = pS0[3+3+j*8+3]&0x1f;   // Month
                            pStrmExt->RecDate[2] = pS0[3+3+j*8+2]&0x3f;   // Day
                            pStrmExt->RecDate[3] = pS0[3+3+j*8+1]&0x3f;   // TimeZone
                            bGetRecDate = FALSE;
                            break;
                        }
                    }
                }
            }

            if(bGetRecDate) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 1 (SSYB7),4(SSYB10) for SC1
                for(j=0; j <= 5; j++) {
                    if(j == 1 || j == 4) {
                        // 0x62== RecDate
                        if(pS1[3+3+j*8] == 0x62) {
                            pStrmExt->RecDate[0] = pS1[3+3+j*8+4];         // Year
                            pStrmExt->RecDate[1] = pS1[3+3+j*8+3]&0x1f;    // Month
                            pStrmExt->RecDate[2] = pS1[3+3+j*8+2]&0x3f;    // Day
                            pStrmExt->RecDate[3] = pS1[3+3+j*8+1]&0x3f;    // TimeZone
                            bGetRecDate = FALSE;
                            break;
                        }
                    }
               }
            }

            //
            // RecTime: VRT
            //
            if(bGetRecTime) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 2(SSYB2),5(SSYB5) for SC0
                for(j=0; j <= 5 ; j++) {
                    if(j == 2 || j == 5) {
                        // 0x63== RecTime
                        if(pS0[3+3+j*8] == 0x63) {
                            pStrmExt->RecTime[0] = pS0[3+3+j*8+4]&0x3f;
                            pStrmExt->RecTime[1] = pS0[3+3+j*8+3]&0x7f;
                            pStrmExt->RecTime[2] = pS0[3+3+j*8+2]&0x7f;
                            pStrmExt->RecTime[3] = pS0[3+3+j*8+1]&0x3f;
                            bGetRecTime = FALSE;
                            break;
                        }
                    }
                }
            }

            if(bGetRecTime) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 2 (SSYB8),5(SSYB11) for SC1
                for(j=0; j <= 5; j++) {
                    if(j == 2 || j == 5) {
                        // 0x63== RecTime
                        if(pS1[3+3+j*8] == 0x63) {
                            pStrmExt->RecTime[0] = pS1[3+3+j*8+4]&0x3f;
                            pStrmExt->RecTime[1] = pS1[3+3+j*8+3]&0x7f;
                            pStrmExt->RecTime[2] = pS1[3+3+j*8+2]&0x7f;
                            pStrmExt->RecTime[3] = pS1[3+3+j*8+1]&0x3f;
                            bGetRecTime = FALSE;
                            break;
                        }
                    }
                }
            }

        }
        
        if(!bGetRecDate && !bGetRecTime)
            break;

        pDIFBlk += DIFBLK_SIZE;  // Next sequence    
                
    }

    TRACE(TL_CIP_TRACE,("\'Frame# %.5d, Date %s %x-%.2x-%.2x,  Time %s %.2x:%.2x:%.2x,%.2x\n", 
        (ULONG) pStrmExt->FramesProcessed,
        bGetRecDate ? "NF:" : "Found:", pStrmExt->RecDate[0], pStrmExt->RecDate[1] & 0x1f, pStrmExt->RecDate[2] & 0x3f,                 
        bGetRecTime ? "NF:" : "Found:",pStrmExt->RecTime[0], pStrmExt->RecTime[1], pStrmExt->RecTime[2], pStrmExt->RecTime[3]
       ));
}

#endif //  MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

#ifdef READ_CUTOMIZE_REG_VALUES

NTSTATUS 
CreateRegistryKeySingle(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    NTSTATUS status;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES objectAttributes;

    RtlInitUnicodeString(&ustr, pwszSection);
       InitializeObjectAttributes(
              &objectAttributes,
              &ustr,
              OBJ_CASE_INSENSITIVE,
              hKey,
              NULL
              );

    status = 
           ZwCreateKey(
                  phKeySection,
                  desiredAccess,
                  &objectAttributes,
                  0,
                  NULL,                            /* optional*/
                  REG_OPTION_NON_VOLATILE,
                  NULL
                  );         

    return status;
}


NTSTATUS 
CreateRegistrySubKey(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    UNICODE_STRING ustr;
    USHORT usPos = 1;             // Skip first backslash
    static WCHAR wSep = '\\';
    NTSTATUS status = STATUS_SUCCESS;

    RtlInitUnicodeString(&ustr, pwszSection);

    while(usPos < ustr.Length) {
        if(ustr.Buffer[usPos] == wSep) {

            // NULL terminate our partial string
            ustr.Buffer[usPos] = UNICODE_NULL;
            status = 
                CreateRegistryKeySingle(
                    hKey,
                    desiredAccess,
                    ustr.Buffer,
                    phKeySection
                    );
            ustr.Buffer[usPos] = wSep;

            if(NT_SUCCESS(status)) {
                ZwClose(*phKeySection);
            } else {
                break;
            }
        }
        usPos++;
    }

    // Create the full key
    if(NT_SUCCESS(status)) {
        status = 
            CreateRegistryKeySingle(
                 hKey,
                 desiredAccess,
                 ustr.Buffer,
                 phKeySection
                 );
    }

    return status;
}


NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN PULONG DataLength
    )

/*++

Routine Description:
    
    This routine gets the specified value out of the registry

Arguments:

    Handle - Handle to location in registry

    KeyNameString - registry key we're looking for

    KeyNameStringLength - length of registry key we're looking for

    Data - where to return the data

    DataLength - how big the data is

Return Value:

    status is returned from ZwQueryValueKey

--*/

{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;


    RtlInitUnicodeString(&keyName, KeyNameString);
    
    length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
            KeyNameStringLength + *DataLength;
            
    fullInfo = ExAllocatePool(PagedPool, length); 
     
    if (fullInfo) { 
       
        status = ZwQueryValueKey(
                    Handle,
                   &keyName,
                    KeyValueFullInformation,
                    fullInfo,
                    length,
                   &length
                    );
                        
        if (NT_SUCCESS(status)){

            ASSERT(fullInfo->DataLength <= *DataLength); 

            RtlCopyMemory(
                Data,
                ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                fullInfo->DataLength
                );

        }            

        *DataLength = fullInfo->DataLength;
        ExFreePool(fullInfo);

    }        
    
    return (status);

}


#if 0 // Not used
NTSTATUS
SetRegistryKeyValue(
   HANDLE hKey,
   PWCHAR pwszEntry, 
   LONG nValue
   )
{
    NTSTATUS status;
    UNICODE_STRING ustr;

    RtlInitUnicodeString(&ustr, pwszEntry);

    status =          
        ZwSetValueKey(
                  hKey,
                  &ustr,
                  0,            /* optional */
                  REG_DWORD,
                  &nValue,
                  sizeof(nValue)
                  );         

   return status;
}
#endif  // Not used

//
// Registry subky and values wide character strings.
//
WCHAR wszSettings[]      = L"Settings";

WCHAR wszATNSearch[]     = L"bSupportATNSearch";
WCHAR wszSyncRecording[] = L"bSyncRecording";
WCHAR wszMaxDataSync[]   = L"tmMaxDataSync";
WCHAR wszPlayPs2RecPs[]  = L"fmPlayPause2RecPause";
WCHAR wszStop2RecPs[]    = L"fmStop2RecPause";
WCHAR wszRecPs2Rec[]     = L"tmRecPause2Rec";
WCHAR wszXprtStateChangeWait[] = L"tmXprtStateChangeWait";

BOOL
DVGetPropertyValuesFromRegistry(
    IN PDVCR_EXTENSION  pDevExt
    )
{
    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;
    ULONG ulLength; 


    //
    // Registry key: 
    //   Windows 2000:
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    // Win98:
    //    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Class\Image\000x
    // 
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->pPhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_READ, 
            &hPDOKey
            );

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

            // Note: we can be more selective by checking
            //   pDevExt->ulDevType
#if 0  // Not supported yet!
            // ATNSearch
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszATNSearch, 
                sizeof(wszATNSearch), 
                (PVOID) &pDevExt->bATNSearch, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, bATNSearch:%d (1:Yes)\n", Status, ulLength, pDevExt->bATNSearch));
            if(!NT_SUCCESS(Status)) pDevExt->bATNSearch = FALSE;

            // bSyncRecording
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszSyncRecording, 
                sizeof(wszSyncRecording), 
                (PVOID) &pDevExt->bSyncRecording, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, bSyncRecording:%d (1:Yes)\n", Status, ulLength, pDevExt->bSyncRecording));
            if(!NT_SUCCESS(Status)) pDevExt->bSyncRecording = FALSE;

            // tmMaxDataSync
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszMaxDataSync, 
                sizeof(wszMaxDataSync), 
                (PVOID) &pDevExt->tmMaxDataSync, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, tmMaxDataSync:%d (msec)\n", Status, ulLength, pDevExt->tmMaxDataSync));

            // fmPlayPs2RecPs
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszPlayPs2RecPs, 
                sizeof(wszPlayPs2RecPs), 
                (PVOID) &pDevExt->fmPlayPs2RecPs, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, fmPlayPs2RecPs:%d (frames)\n", Status, ulLength, pDevExt->fmPlayPs2RecPs));

            // fmStop2RecPs
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszStop2RecPs, 
                sizeof(wszStop2RecPs), 
                (PVOID) &pDevExt->fmStop2RecPs, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, fmStop2RecPs:%d (frames)\n", Status, ulLength, pDevExt->fmStop2RecPs));

            // tmRecPs2Rec
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszRecPs2Rec, 
                sizeof(wszRecPs2Rec), 
                (PVOID) &pDevExt->tmRecPs2Rec, 
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, tmRecPs2Rec:%d (msec)\n", Status, ulLength, pDevExt->tmRecPs2Rec));
#endif
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszXprtStateChangeWait, 
                sizeof(wszXprtStateChangeWait), 
                (PVOID) &pDevExt->XprtStateChangeWait, // in msec
                &ulLength);
            TRACE(TL_PNP_WARNING,("\'GetRegVal: St:%x, Len:%d, XprtStateChangeWait:%d msec\n", Status, ulLength, pDevExt->XprtStateChangeWait));
            if(!NT_SUCCESS(Status)) pDevExt->XprtStateChangeWait = 0;

            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            TRACE(TL_PNP_ERROR,("\'GetPropertyValuesFromRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        TRACE(TL_PNP_ERROR,("\'GetPropertyValuesFromRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    // Not implemented so always return FALSE to use the defaults.
    return FALSE;
}

#if 0  // Not used
BOOL
DVSetPropertyValuesToRegistry(    
    PDVCR_EXTENSION  pDevExt
    )
{
    // Set the default to :
    //        HLM\Software\DeviceExtension->pchVendorName\1394DCam

    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;

    TRACE(TL_PNP_TRACE,("\'SetPropertyValuesToRegistry: pDevExt=%x; pDevExt->pBusDeviceObject=%x\n", pDevExt, pDevExt->pBusDeviceObject));


    //
    // Registry key: 
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->pPhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_WRITE, 
            &hPDOKey);

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

#if 0       // Note used, just an example:
            // Brightness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszBrightness,
                pDevExt->XXXX);
            TRACE(TL_PNP_TRACE,("\'SetPropertyValuesToRegistry: Status %x, Brightness %d\n", Status, pDevExt->Brightness));

#endif
            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            TRACE(TL_PNP_ERROR,("\'GetPropertyValuesToRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        TRACE(TL_PNP_TRACE,("\'GetPropertyValuesToRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    return FALSE;
}
#endif  // Not used
#endif  // READ_CUTOMIZE_REG_VALUES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\dbg.h ===
/*++

Copyright (C) Microsoft Corporation, 2000 - 2001 

Module Name:

    dbg.h

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

    03-02-2001 Switch to use TraceMask instead of DebugLevel   

--*/
#ifndef _DBG_INC
#define _DBG_INC


//
// Various definitions
//

#if 1
extern LONG MSDVCRMutextUseCount;
#endif

#if DBG

    #define _DRIVERNAME_        "MSTape"

    // PnP: loading, power state, surprise removal, device SRB
    #define TL_PNP_MASK         0x0000000F
    #define TL_PNP_INFO         0x00000001
    #define TL_PNP_TRACE        0x00000002
    #define TL_PNP_WARNING      0x00000004
    #define TL_PNP_ERROR        0x00000008

    // Connection, plug and 61883 info (get/set)
    #define TL_61883_MASK       0x000000F0
    #define TL_61883_INFO       0x00000010
    #define TL_61883_TRACE      0x00000020
    #define TL_61883_WARNING    0x00000040
    #define TL_61883_ERROR      0x00000080

    // Data
    #define TL_CIP_MASK         0x00000F00
    #define TL_CIP_INFO         0x00000100
    #define TL_CIP_TRACE        0x00000200
    #define TL_CIP_WARNING      0x00000400
    #define TL_CIP_ERROR        0x00000800

    // AVC commands
    #define TL_FCP_MASK         0x0000F000
    #define TL_FCP_INFO         0x00001000
    #define TL_FCP_TRACE        0x00002000
    #define TL_FCP_WARNING      0x00004000
    #define TL_FCP_ERROR        0x00008000

    // Stream (data intersection, open/close, stream state (get/set))
    #define TL_STRM_MASK        0x000F0000
    #define TL_STRM_INFO        0x00010000
    #define TL_STRM_TRACE       0x00020000
    #define TL_STRM_WARNING     0x00040000
    #define TL_STRM_ERROR       0x00080000

    // clock and clock event
    #define TL_CLK_MASK         0x00F00000
    #define TL_CLK_INFO         0x00100000
    #define TL_CLK_TRACE        0x00200000
    #define TL_CLK_WARNING      0x00400000
    #define TL_CLK_ERROR        0x00800000


    extern ULONG TapeTraceMask;
    extern ULONG TapeAssertLevel;


    #define TRAP DbgBreakPoint();

    #define TRACE( l, x )                       \
        if( (l) & TapeTraceMask ) {              \
            KdPrint( (_DRIVERNAME_ ": ") );     \
            KdPrint( x );                       \
        }

    #ifdef ASSERT
    #undef ASSERT
    #endif
    #define ASSERT( exp ) \
        if (TapeAssertLevel && !(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )


#else  // #if DBG

    #define TRACE( l, x ) 

#endif // #if DBG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpavc.h ===
/*++

Module Name:

    MsTpAvc.h

Abstract:

    Header file for MsTpAvc.c.

Author:   

    Yee J. Wu 27-July-99

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef _MSTPAVC_INC
#define _MSTPAVC_INC

#include "XPrtDefs.h"  // WdmCap directory; derived from DShow's edevdefs.h
#include "EDevCtrl.h"  // External Device COM interface structures


#ifdef SUPPORT_NEW_AVC_CMD
//
// Define an AVC command constant and strcutures
//

typedef enum {
    OPC_UNIT_CONNECT_AV_20      = 0x20,
    OPC_UNIT_UNIT_INFO_30       = 0x30,
    OPC_UNIT_SUBUNIT_INFO_31    = 0x31,

    OPC_TAPE_PLAY_C3            = 0xC3,
    OPC_TAPE_TRANSPORT_STATE_D0 = 0xD0,

    // More...
} AVC_COMMAND_OP_CODE;


#define MAX_FCP_DATA_LEN      512
#define AVC_CMD_HEADER_LEN      3
#define MAX_OPERAND_LEN         (MAX_FCP_DATA_LEN - AVC_CMD_HEADER_LEN)

typedef struct _SUBUNIT_TYPE_ID {
    UCHAR   SubunitID:3;   // 1-4 instance number; 7: unit/ignoerd
    UCHAR   SubunitType:5; // 4:Tape; 5:Tuner; 7:VideoCamera;
} SUBUNIT_TYPE_ID, *PSUBUNIT_TYPE_ID;

typedef struct _AVC_CMD_FRAME_HEADER {
    union {
        UCHAR CmdType:4;   // 0:Control;1:Status;2:SpecInq;3:Notify;4:Geninq;other:reserved.
        UCHAR RespCode:4;  // 8:Not_IMPL;9:Accept;A:Rejected;B:InTransition;C:Imple/Stable;D:Changed;E:Reserved;F:Interim
    };
    UCHAR   CTS:4;         // 0000 for AVC

    SUBUNIT_TYPE_ID  SubunitTypeID;

    UCHAR   Opcode;
} AVC_CMD_FRAME_HEADER, *PAVC_CMD_FRAME_HEADER;

typedef struct _AVC_CMD_FRAME {
    AVC_CMD_FRAME_HEADER CmdHeader;
    UCHAR   Operand[MAX_OPERAND_LEN];
} AVC_CMD_FRAME, *PAVC_CMD_FRAME;

typedef struct _UNIT_CONNECT_AV_20 {
    AVC_CMD_FRAME_HEADER CmdHeader;
    UCHAR  AudDstType:2;
    UCHAR  VidDstType:2;
    UCHAR  AudSrcType:2;
    UCHAR  VidSrvType:2;
    UCHAR  VideoSource;
    UCHAR  AudSrc;
    UCHAR  VidSrc;
    UCHAR  AudDst;
    UCHAR  VidDst;
} UNIT_CONNECT_AV_20, *PUNIT_CONNECT_AV_20;

typedef struct _UNIT_UNIT_INFO_30 {
    AVC_CMD_FRAME_HEADER CmdHeader;
    UCHAR  Opcode;  // 0x30
    UCHAR  Operand; // 0x07
    ULONG  Unit:3;
    ULONG  UnitType:5;
    ULONG  CompanyID:24;
} UNIT_UNIT_INFO_30, *PUNIT_UNIT_INFO_30;



typedef struct _UNIT_SUBUNIT_INFO_31 {
    AVC_CMD_FRAME_HEADER CmdHeader;

    UCHAR  ExtCode:3;
    UCHAR  Rsv0:1;
    UCHAR  Page:3;  // 0..7
    UCHAR  Rsv1:1;

    UCHAR  Operand; // 0x07
    // Exclude extension_code, there are max of 8 pages.
    SUBUNIT_TYPE_ID  SubunitTypeID0[4];
    SUBUNIT_TYPE_ID  SubunitTypeID1[4];
    SUBUNIT_TYPE_ID  SubunitTypeID2[4];
    SUBUNIT_TYPE_ID  SubunitTypeID3[4];
    SUBUNIT_TYPE_ID  SubunitTypeID4[4];
    SUBUNIT_TYPE_ID  SubunitTypeID5[4];
    SUBUNIT_TYPE_ID  SubunitTypeID6[4];
    SUBUNIT_TYPE_ID  SubunitTypeID7[4];

} UNIT_SUBUNIT_INFO_31, *PUNIT_SUBUNIT_INFO_31;

typedef enum {
    NEXT_FRAME = 0x30,  // R
    SLOWEST_FORWARD,    // R
    SLOW_FORWARD_6,
    SLOW_FORWARD_5,
    SLOW_FORWARD_4,
    SLOW_FORWARD_3,
    SLOW_FORWARD_2,
    SLOW_FORWARD_1,
    X1,
    FAST_FORWARD_1,
    FAST_FORWARD_2,
    FAST_FORWARD_3,
    FAST_FORWARD_4,
    FAST_FORWARD_5,
    FAST_FORWARD_6,
    FASTEST_FORWARD,    // M
    //.... more...
} PlaybackMode;

typedef struct _TAPE_PLAY_C3 {
    AVC_CMD_FRAME_HEADER CmdHeader;
    PlaybackMode PlaybackMode;
} TAPE_PLAY_C3, *PTAPE_PLAY_C3;

typedef struct _TAPE_TRANSPORT_STATE_D0 {
    AVC_CMD_FRAME_HEADER CmdHeader;
    UCHAR  Operand;  // 7F
    UCHAR  TransportMode;
    UCHAR  TransportState;
} TAPE_TRANSPORT_STATE_D0, *PTAPE_TRANSPORT_STATE_D0;


//
// "Super" AVC command frame structure
//
typedef struct _AVC_CMD {
    ULONG   DataLen;  // 4..512; at least 4 (header+opcode+operand) to be valid.
    union {
        // Generic
        UCHAR                    FCP_DATA[MAX_FCP_DATA_LEN];
        AVC_CMD_FRAME            CmdFrame;

        // Unit commands
        UNIT_CONNECT_AV_20       ConnectAV;
        UNIT_UNIT_INFO_30        UnitInfo;
        UNIT_SUBUNIT_INFO_31     SubunitInfo;

        // Tape subunit commands
        TAPE_TRANSPORT_STATE_D0  TapeTransportState;
        TAPE_PLAY_C3             TapePlay;
    };
} AVC_CMD, *PAVC_CMD;

#endif // SUPPORT_NEW_AVC_CMD

// 
// The index MUST match DVcrAVCCmdTable[]
//
typedef enum {

    DV_UNIT_INFO = 0
    ,DV_SUBUNIT_INFO
    ,DV_CONNECT_AV_MODE

    ,DV_VEN_DEP_CANON_MODE    // Vendor denpendent mode of operation for Canon DV that does not support ConnectDV
    ,DV_VEN_DEP_DVCPRO        // Vendor depend cmd to detect DVC PRO tape format

    ,DV_IN_PLUG_SIGNAL_FMT
    ,DV_OUT_PLUG_SIGNAL_FMT   // to determine if it is a PAL or NTSC

    ,DV_GET_POWER_STATE         // Get current power state
    ,DV_SET_POWER_STATE_ON      // Get power state to ON
    ,DV_SET_POWER_STATE_OFF     // Get power state to OFF

    ,VCR_TIMECODE_SEARCH 
    ,VCR_TIMECODE_READ

    ,VCR_ATN_SEARCH 
    ,VCR_ATN_READ

    ,VCR_RTC_SEARCH 
    ,VCR_RTC_READ

    ,VCR_OPEN_MIC_CLOSE
    ,VCR_OPEN_MIC_READ
    ,VCR_OPEN_MIC_WRITE
    ,VCR_OPEN_MIC_STATUS

    ,VCR_READ_MIC

    ,VCR_WRITE_MIC

    ,VCR_OUTPUT_SIGNAL_MODE
    ,VCR_INPUT_SIGNAL_MODE

    ,VCR_LOAD_MEDIUM_EJECT

    ,VCR_RECORD
    ,VCR_RECORD_PAUSE

    ,VCR_PLAY_FORWARD_STEP
    ,VCR_PLAY_FORWARD_SLOWEST
    ,VCR_PLAY_FORWARD_SLOWEST2
    ,VCR_PLAY_FORWARD_FASTEST

    ,VCR_PLAY_REVERSE_STEP
    ,VCR_PLAY_REVERSE_SLOWEST
    ,VCR_PLAY_REVERSE_SLOWEST2
    ,VCR_PLAY_REVERSE_FASTEST

    ,VCR_PLAY_FORWARD
    ,VCR_PLAY_FORWARD_PAUSE

    ,VCR_WIND_STOP
    ,VCR_WIND_REWIND
    ,VCR_WIND_FAST_FORWARD

    ,VCR_TRANSPORT_STATE
    ,VCR_TRANSPORT_STATE_NOTIFY

    ,VCR_MEDIUM_INFO

    ,VCR_RAW_AVC
    
} DVCR_AVC_COMMAND, *PDVCR_AVC_COMMAND;



#define MAX_FCP_PAYLOAD_SIZE 512

//
// CTYPE definitions (in bit-map form... should correlate with AvcCommandType from avc.h)
//
typedef enum {
    CMD_CONTROL  = 0x01
   ,CMD_STATUS   = 0x02
   ,CMD_SPEC_INQ = 0x04
   ,CMD_NOTIFY   = 0x08
   ,CMD_GEN_INQ  = 0x10
} BITMAP_CTYPE;

typedef enum {
    CMD_STATE_UNDEFINED   
   ,CMD_STATE_ISSUED 
   ,CMD_STATE_RESP_ACCEPTED
   ,CMD_STATE_RESP_REJECTED
   ,CMD_STATE_RESP_NOT_IMPL           
   ,CMD_STATE_RESP_INTERIM
   ,CMD_STATE_ABORTED
} AVC_CMD_STATE, *PAVC_CMD_STATE;


// An AVC command entry 
typedef struct _AVC_CMD_ENTRY {
    LIST_ENTRY      ListEntry;
    PDVCR_EXTENSION pDevExt;        
    PIRP            pIrp;           // The Irp associated with this command
    PAVC_COMMAND_IRB pAvcIrb;       // points to the AVC command information
    PVOID           pProperty;      // Data from/to COM interface
    DVCR_AVC_COMMAND idxDVCRCmd;    // Used to check for RAW AVC command, which requires special processing
    AVC_CMD_STATE   cmdState;       // Issuing, interim, completed
    NTSTATUS        Status;         // To save the results of response parsing
    AvcCommandType  cmdType;        // Type of command: Control, Status. Notify, Gen or Spec Inquery
    BYTE            OpCode;         // Since the opcode in response frame of TRANSITION and STABLE can be different from the COMMAND frame
    BYTE            Reserved[3];    // Pack to DWORD
} AVCCmdEntry, *PAVCCmdEntry;



#define CMD_IMPLEMENTED       1
#define CMD_NOT_IMPLEMENTED   0
#define CMD_UNDETERMINED      0xffffffff   // -1


typedef struct {    
    DVCR_AVC_COMMAND command; // VCR_PLAY_FORWARD
    LONG   lCmdImplemented;   // 1:Implemented, 0:NotImpelemnted; -1:UnDetermined

    ULONG  ulRespFlags;       // DVCR_AVC_SEND

    ULONG  ulCmdSupported;    // one or more of constants defined in BITMAP_CTYPE

    LONG   OperandLength;      // -1 = variable length

    BYTE   CType;
    BYTE   SubunitAddr;
    BYTE   Opcode;

    BYTE   Operands[MAX_AVC_OPERAND_BYTES];

} KSFCP_PACKET, *PKSFCP_PACKET;



#define OPC_TIMECODE          0x51
#define OPC_OPEN_MIC          0x60
#define OPC_READ_MIC          0x61
#define OPC_WRITE_MIC         0x62
#define OPC_INPUT_SIGNAL_MODE 0x79
#define OPC_LOAD_MEDIUM       0xc1
#define OPC_RECORD            0xc2
#define OPC_PLAY              0xc3
#define OPC_WIND              0xc4
#define OPC_TRANSPORT_STATE   0xd0
#define OPC_MEDIUM_INFO       0xda




#define UNIT_TYPE_ID_VCR      0x20  // VCR    00100:000; 00100 == 4 == VCR,    000 == instancve number
#define UNIT_TYPE_ID_CAMERA   0x38  // Camera 00111:000; 00111 == 7 == Camera, 000 == instancve number
#define UNIT_TYPE_ID_DV       0xff  // DV UNIT as a whole


// Vendor IDs that require special treatments
#define VENDOR_ID_MASK        0x00ffffff
#define VENDORID_CANON        0x85     //  VEN_85   : Vendor Dependent command for ModeOfOperation
#define VENDORID_PANASONIC    0x8045   //  VEN_8045 : DVCPRO?


#define AVC_POWER_STATE_ON    0x70
#define AVC_POWER_STATE_OFF   0x60

#endif


NTSTATUS  
DVIssueAVCCommand (
    IN PDVCR_EXTENSION pDevExt, 
    IN AvcCommandType cType,
    IN DVCR_AVC_COMMAND idxAVCCmd,
    IN PVOID pProperty
    );


void
DVAVCCmdResetAfterBusReset(
    PDVCR_EXTENSION pDevExt
    );


NTSTATUS
AVCTapeGetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPDesc,
    OUT PULONG pulActualBytetransferred
    );


NTSTATUS
AVCTapeSetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,  
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytetransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpdef.h ===
/*++

Copyright (C) Microsoft Corporation, 2000 - 2001

Module Name:

    MsTpDef.h

Abstract:

    Header file for all of AV/C tape subunit

Last changed by:
    
    $Author::                $

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#ifndef _DVCRDEF_INC
#define _DVCRDEF_INC


#include "AVCStrm.h"

#define DRIVER_TAG (ULONG)'USpT'  // Tape SubUnit

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, DRIVER_TAG)


//
// In order to send a request to lower driver, we need an irp and the request block.
// 
typedef struct _DRIVER_REQUEST {

    //
    // Link with other request (in attach or detach list)
    //
    LIST_ENTRY ListEntry;

    //
    // Some context and reserved
    //
    PVOID Context1;
    PVOID Context2;

#if DBG
    //
    // Unique id of this data request
    //
    LONGLONG cntDataRequestReceived;
#endif

    //
    // Irp used to send down a reqest
    //
    PIRP pIrp;

    //
    // Request block
    //
    AVC_STREAM_REQUEST_BLOCK AVCStrmReq;

} DRIVER_REQUEST, *PDRIVER_REQUEST;

//
// Need to reference this in PSTRMEX
//
typedef struct _DVCR_EXTENSION;



// 
// The index MUST match 
//
typedef enum {

    FMT_IDX_SD_DVCR_NTSC = 0,
    FMT_IDX_SD_DVCR_PAL,

#ifdef MSDV_SUPPORT_HD_DVCR
    FMT_IDX_HD_DVCR_NTSC,
    FMT_IDX_HD_DVCR_PAL,
#endif

#ifdef MSDV_SUPPORT_SDL_DVCR
    FMT_IDX_SDL_DVCR_NTSC,
    FMT_IDX_SDL_DVCR_PAL,
#endif

} FMT_INDEX, *PFMT_INDEX;


#define MAX_DATA_BUFFERS  32                    // Max data buffer (allocator framing)
#define MAX_DATA_REQUESTS (MAX_DATA_BUFFERS+2)  // 2 extra for optional flags "data request", such as EndOfStream.

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//
 
typedef struct _STREAMEX {

    // return stream exension (a context) if a stream is open successfully
    // This context is used for subsequent call after a stream is opened.
    PVOID  AVCStreamContext;

    //
    // Point to pSrb->HwDeviceExtension
    // 
    struct _DVCR_EXTENSION * pDevExt;

    //
    // Cache pSrb->StreamObject:
    //     ->HwStreamExtension  (pStrmExt)
    //     ->StreamNumber
    //     ->HwDeviceExtension  (pDevExt)
    //
    PHW_STREAM_OBJECT  pStrmObject;      


    //
    //  ->NumberOfPossibleInstances;
    //  ->DataFlow;
    //
    PHW_STREAM_INFORMATION pStrmInfo;
    
    //
    // Holds state
    //
    KSSTATE StreamState;

    //
    // Holds whether or not the dvcr is listening or receiving
    //
    // TRUE:  successful REQUEST_ISOCH_LISTEN and REQUEST_ISOCH_TALK
    // FALSE: successful INIT and REQUEST_ISOCH_STOP
    //
    BOOLEAN bIsochIsActive;  // Close associated with StreamState

    //
    // Set to TRUE when receiving KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM for SRB_WRITE_DATA
    // For SRB_WRITE_DATA only since then this driver servers as a renderer.
    //
    BOOL      bEOStream;  

    //
    // Count number of SRB_READ/WRITE_DATA received since last transiting to PAUSE state from STOP
    //
    LONGLONG  cntSRBReceived;


    //
    // Count number of Data buffer has submitted for receiving or transmitting.
    //
    LONGLONG  cntDataSubmitted;

    //
    // Statistic of the frame information since last start stream
    // PictureNumber = FramesProcessed + FramesDropped + cndSRBCancelled.
    //    
    LONGLONG  FramesProcessed;   // Frame sent (including repeated)
    LONGLONG  FramesDropped;     // SRB not sent
    LONGLONG  PictureNumber;     // Number of SRB_XXX_DATA made it to or from 1394 bus

    //
    // Count number of SRB_READ/WRITE_DATA that was incompleted and cancelled
    //
    LONGLONG  cntSRBCancelled;


    //
    // The stream time (master clock or not) is "almost" or near 0 
    // when setting to RUN state and start increment.
    //
    LONGLONG CurrentStreamTime;

    //
    // Holds the master clock
    //
    HANDLE hMyClock;       // If set, we can be a clock provider.
    HANDLE hMasterClock;   // If set, we are the master clock.
    HANDLE hClock;         // If set, other device on the same graph is the master clock.



    //
    // 2nd CIP Quadlet: 01:Fmt, 50/60:STYPE:RSv, SYT
    //
    BYTE cipQuad2[4];

    //
    // Timecode, RecDate and RecTime are all in pack format (4 bytes)
    //
    BOOL bATNUpdated;
    DWORD AbsTrackNumber; // LSB:BlankField   

    BOOL bTimecodeUpdated;
    BYTE Timecode[4];     // hh:mm:ss,ff

    //
    // Regulate flow between between setting to STOP state and SRB_XXX_DATA
    //
    KMUTEX * hMutexFlow;


    //
    // Counter used to indicate starting of an work item to cancel 
    //
    LONG  lCancelStateWorkItem;
    BOOL  AbortInProgress;

    //
    // Hold the work item
    //
#ifdef USE_WDM110  // Win2000 code base
    PIO_WORKITEM       pIoWorkItem;
#else
    WORK_QUEUE_ITEM    IoWorkItem;
#endif

    //
    // TO singal that an work item is completed.
    //
    KEVENT hCancelDoneEvent;

    //
    // Stream open format
    //
    AVCSTRM_FORMAT_INFO  AVCFormatInfo;

    //
    // AVCStrm request for issuing synchronous request
    
    KMUTEX * hMutexReq;

    PIRP pIrpReq;
    AVC_STREAM_REQUEST_BLOCK AVCStrmReq;

    //
    // free list
    //
    LONG       cntDataDetached;
    LIST_ENTRY DataDetachedListHead;

    //
    // busy list
    //
    LONG       cntDataAttached;
    LIST_ENTRY DataAttachedListHead;

    //
    // AVCStrem request for asynchronous request, such as read and write data
    //
    DRIVER_REQUEST  AsyncReq[MAX_DATA_REQUESTS];  

    //
    // AVCStrm request for issuing synchronous request to abort at DISPATCH_LEVEL
    //
    PIRP pIrpAbort;
    AVC_STREAM_REQUEST_BLOCK AVCStrmReqAbort;

    //
    // Data list lock
    // 
    KSPIN_LOCK * DataListLock;

    // 
    // DPC and TIMER objects; this is used for the signal clock events.
    //
    KDPC   DPCTimer;

    KTIMER Timer;


} STREAMEX, *PSTREAMEX;


//
// Max number of input and output PCR an AVC can support
//
#define MAX_NUM_PCR  31  

#define MAX_PAYLOAD 1024 

//
// Structure for a plug control register
//
typedef struct _AVC_DEV_PLUG {
    //
    // Plug handle of a PCR returned from 61883.sys
    //
    HANDLE hPlug;

    //
    // PCR's state; this is dynamic and is consider as a snap shot.
    //
    CMP_GET_PLUG_STATE PlugState;

} AVC_DEV_PLUG, *PAVC_DEV_PLUG;


//
// Structure for a max (31) plug control registers 
//
typedef struct _AVC_DEV_PLUGS {

    //
    // data rate of the device
    //
    ULONG  MaxDataRate;

    //
    // Number of input or output plugs (as in i/oMPR)
    //
    ULONG  NumPlugs;

    //
    // Array of plug handles and states;
    //
    AVC_DEV_PLUG  DevPlug[MAX_NUM_PCR];

} AVC_DEV_PLUGS, *PAVC_DEV_PLUGS;

    
//
// Device Extension for our  Desktop Camera Driver
//
typedef struct _DVCR_EXTENSION {  

    //
    // Holds video format supported by this device (presentaly allow only one format per device)
    //
    AVCSTRM_FORMAT VideoFormatIndex;

    //
    // Number of pin supported by this device; this usually equal to number of data range supported.
    //
    ULONG NumOfPins;

    //
    // Contain a table for the support formats (HW_STREAM_INFORMATION && HW_STREAM_OBJECT)
    //
    STREAM_INFO_AND_OBJ  * pStreamInfoObject;

    //
    // Keep track of number of stream that is openned; in this driver, only one stream can be open at any time.
    //
    LONG  cndStrmOpen;  // [0..1]

    //
    // Count the stream index (pin index) that has been opened.
    //
    ULONG idxStreamNumber;  // Index of current stream

    //
    // Can have only 1 Stream active at any time.
    // (Stream Class will allocate the stream extension at SRB_OPENSTREAM)    
    //
    PSTREAMEX  paStrmExt[3];    

    // 
    // Current Device Power State
    //
    DEVICE_POWER_STATE  PowerState;

    // 
    // TRUE only after SRB_SURPRISE_REMOVAL; 
    //
    BOOL  bDevRemoved;  

    // The list of AVC commands that have been issued
    LIST_ENTRY  AVCCmdList;

    // Number of completed commands waiting to be removed from the list
    // This includes:
    //     Command response has returned and processed in the completion routine
    //     Interim response awaiting final response
    LONG  cntCommandQueued;

    // Protection for command processing
    KSPIN_LOCK  AVCCmdLock;

    // The counted list of possible opcode values on response from Transport State status or notify
    UCHAR  TransportModes[5]; // 0x4, [0xC1, 0xC2, 0xC3, 0xC4]
    UCHAR  Reserved0[3];

    // Subunit type
    UCHAR  Subunit_Type[4];   // There are only two subunits

    //
    // The device type (and its capabilities) cannot be determined until a tape is in    
    //
    ULONG  MediaType;         // DVCR standard, small, medium; VHS; VHS-C; unknown
    ULONG  ulDevType;         // 0: undetermined, ED_DEVTYPE_CAMERA or ED_DEVTYPE_VCR
    BOOL  bHasTape;
    BOOL  bWriteProtected;
    BOOL  bDVCPro;

    //
    // Save Unit capabilities:
    //    Vendor and Model IDs
    //

    ULONG      ulVendorID;
    ULONG      ulModelID;

    LARGE_INTEGER  UniqueID;


    //
    // AVC Device's output plugs
    //
    PAVC_DEV_PLUGS pDevOutPlugs;

    //
    // AVC Device's input plugs
    //
    PAVC_DEV_PLUGS pDevInPlugs;


#ifdef SUPPORT_LOCAL_PLUGS
    //
    // Support local oPCR
    //
    AV_PCR  OPCR;
    ULONG  OutputPCRLocalNum;
    HANDLE  hOutputPCRLocal;

    //
    // Support local iPCR
    //
    AV_PCR  IPCR;
    ULONG  InputPCRLocalNum;
    HANDLE  hInputPCRLocal;
#endif

    //
    // Holds the Device Object of our parent (1394 bus driver)
    //
    PDEVICE_OBJECT pBusDeviceObject;  // IoCallDriver()

    //
    // Holds my Physical Device Object
    // pass it in PnP API, such as IoOpenDeviceRegistryKey()
    //
    PDEVICE_OBJECT pPhysicalDeviceObject;


    // 
    // Cache device's Unit capa
    //
    GET_UNIT_IDS  UnitIDs;

#ifndef NT51_61883
//
// Add support for unit model text that 61883 does not support for its 1st version
//
    //
    // 1394 generation count; used in 1394 asych operation.
    //
    ULONG GenerationCount;

    //
    // RootModelString
    //
    UNICODE_STRING  UniRootModelString;

    //
    // UnitModelString
    //
    UNICODE_STRING  UniUnitModelString;

#endif


    //
    // Serialize in the event of getting two consecutive SRB_OPEN_STREAMs
    //
    KMUTEX hMutex;


    //
    // Irp for sychnonize call
    //
    PIRP  pIrpSyncCall;

#ifdef SUPPORT_NEW_AVC
    //
    // 61883 request
    //
    HANDLE  hPlugLocalIn;        // Generic i/oPLUG handle
    HANDLE  hPlugLocalOut;       // Generic i/oPLUG handle
#endif

    AV_61883_REQUEST  AVReq;

    // Pin and connection 
    ULONG  PinCount;
    AVC_MULTIFUNC_IRB  AvcMultIrb;

} DVCR_EXTENSION, *PDVCR_EXTENSION;



//
// Used to queue a SRB
//

typedef struct _SRB_ENTRY {
    LIST_ENTRY                ListEntry;
    PHW_STREAM_REQUEST_BLOCK  pSrb; 
    BOOL                      bStale;  // TRUE if it is marked stale but is the only Srb in the SrbQ
    // Audio Mute ?
    BOOL                      bAudioMute;
#if DBG
    ULONG SrbNum;
#endif
} SRB_ENTRY, *PSRB_ENTRY;



//
// This is the context used to attach a frame 
//

typedef struct _SRB_DATA_PACKET {
    // Build list
    LIST_ENTRY                  ListEntry;

    PHW_STREAM_REQUEST_BLOCK    pSrb;  
    PSTREAMEX                   pStrmExt;  // Can get this from pSrb, here for convenience only!

#if DBG
    BOOL                        bAttached;  // TRUE if attached to 61883.
#endif

    // Used to send 61883 request
    PIRP                        pIrp;     // Use to attach and release.

    PCIP_FRAME                  Frame;
    PVOID                       FrameBuffer;

    //
    // Add debug related info here
    //
    LONGLONG                    FrameNumber;

    // Use to send 61883 AV data request
    AV_61883_REQUEST            AVReq;

} SRB_DATA_PACKET, *PSRB_DATA_PACKET;


//
// Wait time constants
//
#define DV_AVC_CMD_DELAY_STARTUP                       500   // MSec
#define DV_AVC_CMD_DELAY_INTER_CMD                      20   // MSec
#define DV_AVC_CMD_DELAY_DVCPRO                        500   // MSec                          
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpavc.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MsTpAvc.c

Abstract:

    Interface code with for issuing external device control commands.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "MsTpFmt.h"
#include "MsTpDef.h"
#include "MsTpUtil.h"
#include "MsTpAvc.h"

#include "EDevCtrl.h"


PAVCCmdEntry
DVCRFindCmdEntryCompleted(
    PDVCR_EXTENSION pDevExt,
    DVCR_AVC_COMMAND idxDVCRCmd,
    BYTE OpCodeToMatch,
    AvcCommandType cmdTypeToMatch
    );
NTSTATUS 
DVGetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );
NTSTATUS 
DVSetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVGetExtTransportProperty(    
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVSetExtTransportProperty( 
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    );
NTSTATUS 
DVGetTimecodeReaderProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );
NTSTATUS 
DVMediaSeekingProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    );

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVCRFindCmdEntryCompleted)
     // #pragma alloc_text(PAGE, DVIssueAVCCommand)
     #pragma alloc_text(PAGE, DVGetExtDeviceProperty)
     #pragma alloc_text(PAGE, DVSetExtDeviceProperty)
     #pragma alloc_text(PAGE, DVGetExtTransportProperty)
     #pragma alloc_text(PAGE, DVSetExtTransportProperty)
     #pragma alloc_text(PAGE, DVGetTimecodeReaderProperty)
     #pragma alloc_text(PAGE, DVMediaSeekingProperty)
     #pragma alloc_text(PAGE, AVCTapeGetDeviceProperty)
     #pragma alloc_text(PAGE, AVCTapeSetDeviceProperty)
#endif
#endif

KSFCP_PACKET  DVcrAVCCmdTable[] = {
//                                                      ctype             subunitaddr       opcode    operands
  {  DV_UNIT_INFO,              -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x30, 0xff, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_SUBUNIT_INFO,           -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x31, 0x07, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_CONNECT_AV_MODE,        -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x20, 0xf0, 0xff, 0xff, 0x20, 0x20}
 ,{  DV_VEN_DEP_CANON_MODE,     -1, 0, CMD_STATUS,   7, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x00, 0x00, 0x00, 0x85, 0x00, 0x10, 0x08, 0xff}
 ,{  DV_VEN_DEP_DVCPRO,         -1, 0, CMD_STATUS,   7, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x00, 0x00, 0x80, 0x45, 0x82, 0x48, 0xff, 0xff}
 ,{  DV_IN_PLUG_SIGNAL_FMT,     -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x19, 0x00, 0xff, 0xff, 0xff, 0xff}
 ,{  DV_OUT_PLUG_SIGNAL_FMT,    -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV,  0x18, 0x00, 0xff, 0xff, 0xff, 0xff}

 ,{  DV_GET_POWER_STATE,        -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_DV, 0xb2, 0x7f}
 ,{  DV_SET_POWER_STATE_ON,     -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_DV, 0xb2, 0x70}
 ,{  DV_SET_POWER_STATE_OFF,    -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_DV, 0xb2, 0x60}


 ,{ VCR_TIMECODE_SEARCH,        -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x51, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_TIMECODE_READ,          -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x51, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_ATN_SEARCH,             -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x52, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_ATN_READ,               -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x52, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_RTC_SEARCH,             -1, 0, CMD_CONTROL,  5, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x57, 0x20, 0x00, 0x00, 0x00, 0x00}
 ,{ VCR_RTC_READ,               -1, 0, CMD_STATUS,   5, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x57, 0x71, 0xff, 0xff, 0xff, 0xff}

 ,{ VCR_OPEN_MIC_CLOSE,         -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x00}
 ,{ VCR_OPEN_MIC_READ,          -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x01}
 ,{ VCR_OPEN_MIC_WRITE,         -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x60, 0x03}
 ,{ VCR_OPEN_MIC_STATUS,        -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x60, 0xff}

 ,{ VCR_READ_MIC,               -1, 0, CMD_CONTROL, -1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x61}

 ,{ VCR_WRITE_MIC,              -1, 0, CMD_CONTROL, -1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0x62}

 ,{ VCR_OUTPUT_SIGNAL_MODE,     -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x78, 0xff}
 ,{ VCR_INPUT_SIGNAL_MODE,      -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0x79, 0xff}

 ,{ VCR_LOAD_MEDIUM_EJECT,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc1, 0x60}

 ,{ VCR_RECORD,                 -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc2, 0x75}
 ,{ VCR_RECORD_PAUSE,           -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc2, 0x7d}

 ,{ VCR_PLAY_FORWARD_STEP,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x30}  // 00=AVC, 20=VCR, c3=Opcode, 30=Operand[0]
 ,{ VCR_PLAY_FORWARD_SLOWEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x31}  
 ,{ VCR_PLAY_FORWARD_SLOWEST2,  -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x33}  
 ,{ VCR_PLAY_FORWARD_FASTEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x3f}

 ,{ VCR_PLAY_REVERSE_STEP,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x40} 
 ,{ VCR_PLAY_REVERSE_SLOWEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x41}
 ,{ VCR_PLAY_REVERSE_SLOWEST2,  -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x43}
 ,{ VCR_PLAY_REVERSE_FASTEST,   -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x4f}
 
 ,{ VCR_PLAY_FORWARD,           -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x75}  
 ,{ VCR_PLAY_FORWARD_PAUSE,     -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc3, 0x7d}

 ,{ VCR_WIND_STOP,              -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x60}
 ,{ VCR_WIND_REWIND,            -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x65}
 ,{ VCR_WIND_FAST_FORWARD,      -1, 0, CMD_CONTROL,  1, AVC_CTYPE_CONTROL,UNIT_TYPE_ID_VCR, 0xc4, 0x75}

 ,{ VCR_TRANSPORT_STATE,        -1, 0, CMD_STATUS,   1, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0xd0, 0x7f}
 ,{ VCR_TRANSPORT_STATE_NOTIFY, -1, 0, CMD_NOTIFY,   1, AVC_CTYPE_NOTIFY, UNIT_TYPE_ID_VCR, 0xd0, 0x7f}


 ,{ VCR_MEDIUM_INFO,            -1, 0, CMD_STATUS,   2, AVC_CTYPE_STATUS, UNIT_TYPE_ID_VCR, 0xda, 0x7f,0x7f}

 ,{ VCR_RAW_AVC,                 1, 0, CMD_CONTROL | CMD_STATUS | CMD_NOTIFY | CMD_SPEC_INQ | CMD_GEN_INQ, 0}

};



void
DVCRXlateGetMediumInfo(
    PMEDIUM_INFO pMediumInfo,
    PBYTE pbOperand0,
    PBYTE pbOperand1
    )
{

    TRACE(TL_FCP_TRACE,("GetMediumInfo: Type:%x; WriteProtect:%x\n", *pbOperand0, *pbOperand1));

    switch(*pbOperand0) {

    // Support for DigitalHi8; if we get this query, we treat DHi8 as a mini DV tape.
    case 0x12:  // DHi8

    case 0x31:// DVCR standard cassette
    case 0x32:// DVCR small cassette
    case 0x33:// DVCR medium cassette
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_DVC;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x22: // VHS cassette
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_VHS;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x23:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_VHSC;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    case 0x60:
        pMediumInfo->MediaPresent  = FALSE;
        pMediumInfo->MediaType     = ED_MEDIA_NOT_PRESENT;
        pMediumInfo->RecordInhibit = TRUE;  // Cannot record if there is no tape.
        break;
    case 0x7e:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_UNKNOWN;
        pMediumInfo->RecordInhibit = TRUE;  // Actually cannot be determined
        break;
    // Sony's NEO device
    case 0x41:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_NEO;
        pMediumInfo->RecordInhibit = (*pbOperand1 & 0x01) == 0x01;
        break;
    default:
        pMediumInfo->MediaPresent  = TRUE;
        pMediumInfo->MediaType     = ED_MEDIA_UNKNOWN;
        pMediumInfo->RecordInhibit = TRUE;
        break;
    }

    // Reset command opcode/operands
    *pbOperand0 = 0x7f;
    *pbOperand1 = 0x7f;
}

void
DVCRXlateGetTransportState(
    PTRANSPORT_STATE pXPrtState,
    PBYTE pbOpcode,
    PBYTE pbOperand0
    )
{

    TRACE(TL_FCP_TRACE,("XlateGetTransportState: OpCode %x, Operand %x\n", *pbOpcode, *pbOperand0));

    switch(*pbOpcode) {

    case OPC_LOAD_MEDIUM:
        pXPrtState->Mode = ED_MEDIA_UNLOAD;
        ASSERT(*pbOperand0 == 0x60);
        break;

    case OPC_RECORD:
        pXPrtState->Mode = ED_MODE_RECORD;
        switch(*pbOperand0) {
        case 0x75: // RECORD
            pXPrtState->State = ED_MODE_RECORD;
            break;
        case 0x7d: // RECORD_FREEZE
            pXPrtState->State = ED_MODE_RECORD_FREEZE;
            break;
        default:
            ASSERT(FALSE && "OPC_RECORD: Operand0 undefined!");
            break;
        }
        break;

    case OPC_PLAY:
        pXPrtState->Mode = ED_MODE_PLAY;
        switch(*pbOperand0) {
        case 0x30:  // NEXT FRAME
            pXPrtState->State = ED_MODE_STEP_FWD;
            break;
        case 0x31:  // SLOWEST FORWARD
        case 0x32:  // SLOW FORWARD 6        
        case 0x33:  // SLOW FORWARD 5
        case 0x34:  // SLOW FORWARD 4
        case 0x35:  // SLOW FORWARD 3
        case 0x36:  // SLOW FORWARD 2
        case 0x37:  // SLOW FORWARD 1
            pXPrtState->State = ED_MODE_PLAY_SLOWEST_FWD;
            break;
        case 0x38:  // PLAY FORWARD 1
            pXPrtState->State = ED_MODE_PLAY;
            break;
        case 0x39:  // FAST FORWARD 1
        case 0x3a:  // FAST FORWARD 2
        case 0x3b:  // FAST FORWARD 3
        case 0x3c:  // FAST FORWARD 4
        case 0x3d:  // FAST FORWARD 5
        case 0x3e:  // FAST FORWARD 6
        case 0x3f:  // FASTEST FORWARD
            pXPrtState->State = ED_MODE_PLAY_FASTEST_FWD;
            break;
        case 0x40:  // PREVIOUS FRAME
            pXPrtState->State = ED_MODE_STEP_REV;
            break;
        case 0x41:  // SLOWEST REVERSE
        case 0x42:  // SLOW REVERSE 6
        case 0x43:  // SLOW REVERSE 5 
        case 0x44:  // SLOW REVERSE 4 
        case 0x45:  // SLOW REVERSE 3
        case 0x46:  // SLOW REVERSE 2 
        case 0x47:  // SLOW REVERSE 1 
            pXPrtState->State = ED_MODE_PLAY_SLOWEST_REV;
            break;
        case 0x48:  // X1 REVERSE
        case 0x65:  // REVERSE 
            pXPrtState->State = ED_MODE_REV_PLAY;
            break;
        case 0x49:  // FAST REVERSE 1
        case 0x4a:  // FAST REVERSE 2
        case 0x4b:  // FAST REVERSE 3
        case 0x4c:  // FAST REVERSE 4
        case 0x4d:  // FAST REVERSE 5
        case 0x4e:  // FAST REVERSE 6
        case 0x4f:  // FASTEST REVERSE
            pXPrtState->State = ED_MODE_PLAY_FASTEST_REV;
            break;
        case 0x75:  // FORWARD
            pXPrtState->State = ED_MODE_PLAY;
            break;
        case 0x6d:  // REVERSE PAUSE
        case 0x7d:  // FORWARD PAUSE
            pXPrtState->State = ED_MODE_FREEZE;
            break;
        default:
            pXPrtState->State = 0;
            ASSERT(FALSE && "OPC_PLAY: Operand0 undefined!");
            break;
        }
        break;

    case OPC_WIND:
        //pXPrtState->Mode = ED_MODE_WIND;
        switch(*pbOperand0) {
        case 0x45:  // HIGH SPEED REWIND
            pXPrtState->State = ED_MODE_REW_FASTEST;
            break;
        case 0x60:  // STOP
            pXPrtState->State = ED_MODE_STOP;
            break;
        case 0x65:  // REWIND
            pXPrtState->State = ED_MODE_REW;
            break;
        case 0x75:  // FAST FORWARD
            pXPrtState->State = ED_MODE_FF;
            break;
        default:
            TRACE(TL_FCP_ERROR,("XlateGetTransportState:  OPC_WIND with unknown operand0 %x\n", *pbOperand0));            
            break;
        }
        // Thre is not a state defined for WIND
        pXPrtState->Mode = pXPrtState->State;
        break;

    case OPC_TRANSPORT_STATE:  // As a result of the notify command
        break;

    default:
        ASSERT(FALSE && "OpCode undefined!");
        break;
    }

    // Reset command opcode/operands
    *pbOpcode   = 0xd0;
    *pbOperand0 = 0x7f;
}


void
DVCRXlateGetIOSignalMode(
    PULONG pIOSignalMode,
    PBYTE pbOperand0
    )
{

    TRACE(TL_FCP_WARNING,("IOSignalMode: IoSignal:%x\n", *pbOperand0));

    switch(*pbOperand0) {
    case 0x00:  // SD 525-60
    case 0x06:  // Analog 8mm NTSC
    case 0x0e:  // Analog Hi8 NTSC
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_525_60_SD;
        break;
    case 0x04:  // SDL 525-60
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_525_60_SDL;
        break;
    case 0x80:  // SD 625-50
    case 0x86:  // Analog 8mm NTSC
    case 0x8e:  // Analog Hi8 NTSC
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_625_50_SD;
        break;
    case 0x84:  // SDL 625-50
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_625_50_SDL;
        break;
  
    // Various MPEG2 format
    case 0x05:  // Analog VHS NTSC 525/60
    case 0x25:  // Analog VHS M-NTSC 525/60
    case 0xA5:  // Analog VHS PAL 625/50
    case 0xB5:  // Analog VHS M-PAL 625/50
    case 0xC5:  // Analog VHS SECAM 625/50
    case 0xD5:  // Analog VHS ME-SECAM 625/50
    case 0x01:  // D-VHS
    case 0x0d:  // Analob S-VHS 525/60
    case 0xed:  // Analog S-VHS 625/50
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_MPEG2TS;
        break;
    
    case 0x10:  // MPEG 25    Mbps-60
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_2500_60_MPEG;
        break;
    case 0x14:  // MPEG 12.5 Mbps-60
    case 0x24:  // MPEG 12.5 Mbps-60 (NEO)
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_1250_60_MPEG;
        break;
    case 0x18:  // MPEG  6.25Mbps-60
    case 0x28:  // MPEG  6.25Mbps-60 (NEO)
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_0625_60_MPEG;
        break;
    case 0x90:  // MPEG 25Mbps-50
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_2500_50_MPEG;
        break;
    case 0x94:  // MPEG 12.5Mbps-50
    case 0xa4:  // MPEG 12.5Mbps-50 (NEO)
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_1250_50_MPEG;
        break;
    case 0x98:  // MPEG  6.25Mbps-50
    case 0xa8:  // MPEG  6.25Mbps-50 (NEO)
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_0625_50_MPEG;
        break;

    case 0x0f:  // Unknown data 
        *pIOSignalMode = ED_TRANSBASIC_SIGNAL_UNKNOWN;
        break;

    default:
        // This driver does not understand other format;
        TRACE(TL_FCP_ERROR,("Unknown IoSignal:%x\n", *pbOperand0));
        ASSERT(FALSE && "Unknown IoSignal!");
        break;
    }

    // Reset command opcode/operands
    *pbOperand0 = 0xff;
}

NTSTATUS
DVCRXlateRAwAVC(
    PAVCCmdEntry pCmdEntry,
    PVOID     pProperty
    )
{
    PAVC_COMMAND_IRB pAvcIrb = pCmdEntry->pAvcIrb;
    UCHAR ucRespCode = pAvcIrb->ResponseCode;   
    NTSTATUS  Status;
    PUCHAR   pbRtnBuf;
    PKSPROPERTY_EXTDEVICE_S pXDevProperty;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    PKSPROPERTY_TIMECODE_S pTmCdReaderProperty;

    if(STATUS_SUCCESS != pCmdEntry->Status) {
        TRACE(TL_FCP_ERROR,("XlateRAwAVC: Status:%x\n", pCmdEntry->Status));
        return pCmdEntry->Status;
    }


    switch (pCmdEntry->idxDVCRCmd) {
    case DV_UNIT_INFO:       
        pbRtnBuf = (PBYTE) pProperty;        
        memcpy(pbRtnBuf, pAvcIrb->Operands+1, 4);
        break;
    case DV_SUBUNIT_INFO:
    case DV_IN_PLUG_SIGNAL_FMT:
    case DV_OUT_PLUG_SIGNAL_FMT:
        pbRtnBuf = (PBYTE) pProperty;
        memcpy(pbRtnBuf, pAvcIrb->Operands+1, 4);
        break;
     // special case, return the response code in the first byte
    case DV_CONNECT_AV_MODE:
        pbRtnBuf = (PBYTE) pProperty;
        pbRtnBuf[0] = ucRespCode;
        memcpy(&pbRtnBuf[1], pAvcIrb->Operands, 5);        
        break;
     // special case, return the response code in the first byte
    case DV_VEN_DEP_CANON_MODE:
        pbRtnBuf = (PBYTE) pProperty;
        pbRtnBuf[0] = ucRespCode;
        memcpy(&pbRtnBuf[1], pAvcIrb->Operands, 7);        
        break;
    case DV_GET_POWER_STATE:
        pXDevProperty = (PKSPROPERTY_EXTDEVICE_S) pProperty;
        TRACE(TL_FCP_WARNING,("GET_POWER_STATE: OperandsStatus:%x\n", pAvcIrb->Operands[0]));
        switch(pAvcIrb->Operands[0]) {
        case AVC_POWER_STATE_OFF: // 0x60
            // If the device is OFF, it cannot give us this response so it must be in standby mode.
            pXDevProperty->u.PowerState = ED_POWER_OFF;
            break;
        case AVC_POWER_STATE_ON:      // 0x70
            pXDevProperty->u.PowerState = ED_POWER_ON;
            break;
        default:
            // If it is not ON or OFF, we "guess" it is a new power state of "Standby".
            pXDevProperty->u.PowerState = ED_POWER_STANDBY;
            break;
        }
        break;

    case VCR_TIMECODE_READ:
        pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pProperty;
        if(pAvcIrb->Operands[1] == 0xff || 
           pAvcIrb->Operands[2] == 0xff || 
           pAvcIrb->Operands[3] == 0xff || 
           pAvcIrb->Operands[4] == 0xff )  {
            TRACE(TL_FCP_ERROR,("TimeCodeRead: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
            // Even though command succeded, but the data is not valid!
            Status = STATUS_UNSUCCESSFUL;
        } else {
            // bswap them.
            pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                (((DWORD) pAvcIrb->Operands[4]) << 24) |
                (((DWORD) pAvcIrb->Operands[3]) << 16) |
                (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                 ((DWORD) pAvcIrb->Operands[1]);
             TRACE(TL_FCP_TRACE,("TimeCodeRead: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
        }
        break;
    case VCR_RTC_READ:
        pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pProperty;
        if(// 0xFF is valid for RTC: pAvcIrb->Operands[1] == 0xff || 
           pAvcIrb->Operands[2] == 0xff || 
           pAvcIrb->Operands[3] == 0xff || 
           pAvcIrb->Operands[4] == 0xff )  {
           TRACE(TL_FCP_ERROR,("RTC_Read: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
            // Even though command succeded, but the data is not valid!
            Status = STATUS_UNSUCCESSFUL;
        } else {
            // bswap them.
            pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                (((DWORD) pAvcIrb->Operands[4]) << 24) |
                (((DWORD) pAvcIrb->Operands[3]) << 16) |
                (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                 ((DWORD) pAvcIrb->Operands[1]);
            TRACE(TL_FCP_TRACE,("RTC_Read: %.2x:%.2x:%.2x,%.2x\n", pAvcIrb->Operands[4], pAvcIrb->Operands[3], pAvcIrb->Operands[2], pAvcIrb->Operands[1]));
        }
        break;
    case VCR_ATN_READ:
        pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pProperty;
        if(pAvcIrb->Operands[1] == 0x00 && 
           pAvcIrb->Operands[2] == 0x00 && 
           pAvcIrb->Operands[3] == 0x00 )  {
            // Even though command succeded, but the data is not valid!
            Status = STATUS_UNSUCCESSFUL;
        } else {

#define MEDIUM_TYPE_MASK  0xf8 // 11111000b
#define MEDIUM_TYPE_DVHS  0x08 // 00001000b
#define MEDIUM_TYPE_DVCR  0xf8 // 11111000b
#define MEDIUM_TYPE_NEO   0x10 // 00010000b

            switch(pAvcIrb->Operands[4] & MEDIUM_TYPE_MASK) {
            case MEDIUM_TYPE_DVCR:            
                pTmCdReaderProperty->TimecodeSamp.dwUser = 
                    pAvcIrb->Operands[1] & 0x01;  // Get the Blank flag
                 // bswap them.
                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                    ( (((DWORD) pAvcIrb->Operands[3]) << 16) |
                      (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                      (((DWORD) pAvcIrb->Operands[1]))
                    ) >> 1;
                break;
            case MEDIUM_TYPE_DVHS:            
                pTmCdReaderProperty->TimecodeSamp.dwUser = 
                    (pAvcIrb->Operands[1] >> 6) & 0x03;  // Get the SF
                 // bswap them.
                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                    ( (((DWORD) (pAvcIrb->Operands[1] & 0x3f)) << 16) |
                      (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                      (((DWORD) pAvcIrb->Operands[3]))
                    );
                break;            
            case MEDIUM_TYPE_NEO:            
                pTmCdReaderProperty->TimecodeSamp.dwUser = 
                    (pAvcIrb->Operands[3] >> 7) & 0x01;  // Get the Blank flag
                 // bswap them.
                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames  = 
                    ( (((DWORD) (pAvcIrb->Operands[3] & 0x7f)) << 16) |
                      (((DWORD) pAvcIrb->Operands[2]) <<  8) |
                      (((DWORD) pAvcIrb->Operands[1]))
                    );

                TRACE(TL_FCP_TRACE, ("ATN (NEO):bf:%d ATN:%d\n",
                    pTmCdReaderProperty->TimecodeSamp.dwUser,
                    pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames
                    ));
                break;
            default:
                // Unknown medium type
                Status = STATUS_UNSUCCESSFUL;
                TRACE(TL_FCP_ERROR, ("Operand4:%x; Unknown Medium type for ATN: %x\n",
                        pAvcIrb->Operands[4], pAvcIrb->Operands[4] & MEDIUM_TYPE_MASK));
                break;
            }
        }
        break;
    case VCR_INPUT_SIGNAL_MODE:
    case VCR_OUTPUT_SIGNAL_MODE:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetIOSignalMode(&pXPrtProperty->u.SignalMode, &pAvcIrb->Operands[0]);
        break;
    case VCR_TRANSPORT_STATE:
    case VCR_TRANSPORT_STATE_NOTIFY:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetTransportState(&pXPrtProperty->u.XPrtState, &pAvcIrb->Opcode, &pAvcIrb->Operands[0]);
        break;
    case VCR_MEDIUM_INFO:
        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pProperty;
        DVCRXlateGetMediumInfo(&pXPrtProperty->u.MediumInfo, &pAvcIrb->Operands[0], &pAvcIrb->Operands[1]);
        break;
    case VCR_RAW_AVC:
        // Do nothing.
        break;
     default:
        // No translation necessary
         TRACE(TL_FCP_TRACE,("No tranlsation: pCmdEntry:%x; idx:%d\n", pCmdEntry, pCmdEntry->idxDVCRCmd));
        break;
    }

    return pCmdEntry->Status;
}



PAVCCmdEntry
DVCRFindCmdEntryCompleted(
    PDVCR_EXTENSION pDevExt,
    DVCR_AVC_COMMAND idxDVCRCmd,
    BYTE OpCodeToMatch,
    AvcCommandType cmdTypeToMatch
    )
/*++

Routine Description:

Arguments:

Return Value:

    PLIST_ENTRY

--*/
{
    LIST_ENTRY   *pEntry;
    KIRQL         OldIrql;

    PAGED_CODE();

    //
    // Special case:
    //
    //     ATN:       Status 01 20 52; Control 00 20 52
    //     (resp)            0c 20 52          0f 20 52   (CtrlInterim)
    //
    //     XPrtState: Status 01 20 d0;  Notify 03 20 d0
    //     (resp)            0c 20 xx          0f 20 xx xx (NotifyInterim)      
    //
    // Summary: if we keep cmdType and OpCode, it is unique.
    //
    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    pEntry = pDevExt->AVCCmdList.Flink;
    while(pEntry != &pDevExt->AVCCmdList) {       
        PAVCCmdEntry pCmdEntry = (PAVCCmdEntry)pEntry;

        if (pCmdEntry->idxDVCRCmd == idxDVCRCmd) {
            //
            //  We only fetch if it is completed!       
            //
            if(pCmdEntry->cmdState != CMD_STATE_ISSUED) {
                if (pCmdEntry->cmdType == cmdTypeToMatch) {
                    // Control/GenInq/SpecInq: OpCode and Operand[n] remina unchanged.
                    if (pCmdEntry->OpCode == OpCodeToMatch) {
                        TRACE(TL_FCP_TRACE,("FindCmdEntryCompleted: (1) Found pCmdEntry:%x (%x, %x, %x)\n", 
                            pCmdEntry, pCmdEntry->pAvcIrb, cmdTypeToMatch, OpCodeToMatch));

                        RemoveEntryList(&pCmdEntry->ListEntry);  pDevExt->cntCommandQueued--;
                        InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership
#if DBG
                        // pIrp should be NULL (completed).
                        if(pCmdEntry->pIrp) {
                            TRACE(TL_FCP_ERROR,("Error: FindCmdEntry: pCmdEntry:%x; pIrp:%x not completed\n", pCmdEntry, pCmdEntry->pIrp));
                        } 
#endif
                        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

                        return pCmdEntry;  // Found
                    } 

                } else {
                    TRACE(TL_FCP_WARNING,("FindCmdEntryCompleted: cmdType %x != %x\n", pCmdEntry->cmdType, cmdTypeToMatch));
                }
            }
            else {
                TRACE(TL_FCP_TRACE,("FindCmdEntryCompleted: (0) Skip %x not completed (%x, %x) match entry %x\n", 
                        pCmdEntry, cmdTypeToMatch, OpCodeToMatch));                
            }
        }

        pEntry = pEntry->Flink;
    }

    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

    TRACE(TL_FCP_TRACE,("FindCmdEntryCompleted: (a) No match\n"));                
    return NULL; // No match
}


void
DVAVCCmdResetAfterBusReset(
    PDVCR_EXTENSION pDevExt
    )
/*++

Routine Description:

Arguments:

Return Value:

    Nothing

--*/
{
    KIRQL        OldIrql;

    KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
    TRACE(TL_FCP_TRACE,("BusReset: <enter> AVCCmd [completed %d]; CmdList:%x\n", pDevExt->cntCommandQueued, pDevExt->AVCCmdList));

    // Clear the command list
    while (!IsListEmpty(&pDevExt->AVCCmdList)) {

        PAVCCmdEntry pCmdEntry = (PAVCCmdEntry)RemoveHeadList(&pDevExt->AVCCmdList); pDevExt->cntCommandQueued--;
        InitializeListHead(&pCmdEntry->ListEntry);
        TRACE(TL_FCP_TRACE,("BusReset: AbortAVC: Completed:%d; pCmdEntry:%x; cmdState:%d; cmdSt:%x\n", 
            pDevExt->cntCommandQueued, pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status));

        switch(pCmdEntry->cmdState) {
        case CMD_STATE_ISSUED:
        case CMD_STATE_RESP_INTERIM:  // AVC.sys may still has it!
            TRACE(TL_FCP_WARNING,("BusReset: AbortAVC: IoCancelIrp(%x)!\n", pCmdEntry->pIrp));
            ASSERT(pCmdEntry->pIrp != NULL);
            IoCancelIrp(pCmdEntry->pIrp);    // Calls DVIssueAVCCommandCR() with pIrp->Cancel
            break;

        // Completed command
        case CMD_STATE_UNDEFINED:
            TRACE(TL_FCP_ERROR,("AVCCmdResetAfterBusReset: Unexpected CMD state %d; pCmdEntry %x\n", pCmdEntry->cmdState, pCmdEntry));
        case CMD_STATE_RESP_ACCEPTED:
        case CMD_STATE_RESP_REJECTED:
        case CMD_STATE_RESP_NOT_IMPL:
        case CMD_STATE_ABORTED:
            break;      

        default:
            TRACE(TL_FCP_ERROR,("AVCCmdResetAfterBusReset: Unknown CMD state %d; pCmdEntry %x\n", pCmdEntry->cmdState, pCmdEntry));
            ASSERT(FALSE && "Unknown cmdState\n");
            break;
        }

        // We are guaranteed at this point that no one needs the
        // results anymore so we will free the resources.
        ExFreePool(pCmdEntry->pAvcIrb);
        ExFreePool(pCmdEntry);
    }

#if DBG
    //
    // Should have no more entry !
    // 
    if(pDevExt->cntCommandQueued != 0) {
        TRACE(TL_FCP_ERROR,("BusReset: <exit> AVCCmd [completed %d]; CmdList:%x\n", pDevExt->cntCommandQueued, pDevExt->AVCCmdList));
        ASSERT(pDevExt->cntCommandQueued == 0);
    }
#endif

    KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

}

NTSTATUS
DVIssueAVCCommandCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PAVCCmdEntry pCmdEntry
    )
/*++

Routine Description:

    This is the completion routine for the AVC command when it is completed which imply that 
    the interim response will not be called here.

Arguments:
    Note: pCmdEntry cannot be used if pIrp->Cancel.

Return Value:

    Always STATUS_MORE_PROCESSING_REQUIRED.
    Note: the real return is in pCmdEntry->Status.

--*/
{
    KIRQL oldIrql;

    if (!pIrp->Cancel) {

        PDVCR_EXTENSION pDevExt = pCmdEntry->pDevExt;
        BOOL bSignalInterimCotrolCompleted = FALSE;
        BOOL bSignalInterimNotifyCompleted = FALSE;
        PKSEVENT_ENTRY   pEvent;


        // Serialize AVC command response processing
        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &oldIrql);

        ASSERT(pCmdEntry->pIrp == pIrp);
        pCmdEntry->pIrp = NULL; // don't need this anymore

        // Check if it's worthwhile to examine the response buffer
        if (STATUS_SUCCESS == pIrp->IoStatus.Status) {

            PAVC_COMMAND_IRB pAvcIrb = pCmdEntry->pAvcIrb;

            // Check Opcode for return state
            switch(pAvcIrb->ResponseCode) {
            case AVC_RESPONSE_NOTIMPL:
                pCmdEntry->cmdState = CMD_STATE_RESP_NOT_IMPL;
                pCmdEntry->Status   = STATUS_NOT_SUPPORTED;  // -> ERROR_NOT_SUPPORTED
                break;

            case AVC_RESPONSE_ACCEPTED:
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        bSignalInterimCotrolCompleted = TRUE;
                        TRACE(TL_FCP_TRACE,("--> Accept: for control interim\n"));
                    } else {
                        TRACE(TL_FCP_ERROR,("pCmdExtry %x\n", pCmdEntry));
                        ASSERT(pCmdEntry->cmdType == AVC_CTYPE_CONTROL && "Accept+Interim but not control cmd");
                    }
                } 
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // -> NOERROR
                break;

            case AVC_RESPONSE_REJECTED:
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        TRACE(TL_FCP_TRACE,("--> Reject: for control interim\n"));
                        bSignalInterimCotrolCompleted = TRUE;
                    } else if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                        TRACE(TL_FCP_TRACE,("--> Reject: for notify interim\n"));
                        bSignalInterimNotifyCompleted = TRUE;                  
                    } else {
                        TRACE(TL_FCP_ERROR,("pCmdExtry %x\n", pCmdEntry));
                        ASSERT((pCmdEntry->cmdType == AVC_CTYPE_CONTROL || pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) && "Reject+Interim but not control or notify cmd");
                    }
                }
                pCmdEntry->cmdState = CMD_STATE_RESP_REJECTED;
                pCmdEntry->Status   = STATUS_REQUEST_NOT_ACCEPTED;  // ERROR_REQ_NOT_ACCEPTED
                break;

            case AVC_RESPONSE_IN_TRANSITION:
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // -> NOERROR
                break;

            case AVC_RESPONSE_STABLE: // == AVC_RESPONSE_IMPLEMENTED:
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // ->  NOERROR
                break;

            case AVC_RESPONSE_CHANGED:
#if DBG
                if(pCmdEntry->cmdState != CMD_STATE_RESP_INTERIM) {
                   TRACE(TL_FCP_ERROR,("Err: Changed; pCmdExtry:%x; cmdState:%d\n", pCmdEntry, pCmdEntry->cmdState));
                   ASSERT(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM);
                }
#endif
                if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                    TRACE(TL_FCP_TRACE,("--> Changed: for notify interim\n"));
                     bSignalInterimNotifyCompleted = TRUE;                  
                } else {
                    TRACE(TL_FCP_ERROR,("pCmdExtry %x\n", pCmdEntry));
                    ASSERT(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY && "Changed but not notify cmd!");
                }
 
                pCmdEntry->cmdState = CMD_STATE_RESP_ACCEPTED;
                pCmdEntry->Status   = STATUS_SUCCESS;       // ->  NOERROR
                break;

            // AVC.sys should never return this response !!
            case AVC_RESPONSE_INTERIM:              
                ASSERT( pAvcIrb->ResponseCode != AVC_RESPONSE_INTERIM && "CmpRoutine should not has this response!");
                pCmdEntry->cmdState = CMD_STATE_RESP_INTERIM;
                pCmdEntry->Status   = STATUS_MORE_ENTRIES;   // ov.Internal 
                break;
        
            default:
                TRACE(TL_FCP_ERROR,("pCmdEntry%x; State:%d; pAvcIrb:%x; RespCode:%x\n", pCmdEntry, pCmdEntry->cmdState, pAvcIrb, pAvcIrb->ResponseCode));
                ASSERT(FALSE && "Undefined cmdState");
                pCmdEntry->cmdState = CMD_STATE_UNDEFINED;
                pCmdEntry->Status   = STATUS_NOT_SUPPORTED;   // ov.Internal 
                break;
            }

#if DBG
            if(pCmdEntry->cmdState != CMD_STATE_UNDEFINED) {
                TRACE(TL_FCP_WARNING,("<<<< AVCResp: pCmdEntry:%x; pAvcIrb:%x, cmdSt:%d; St:%x; %d:[%.2x %.2x %.2x %.2x]:[%.2x %.2x %.2x %.2x]\n",                  
                    pCmdEntry, pCmdEntry->pAvcIrb,
                    pCmdEntry->cmdState,
                    pCmdEntry->Status,
                    pAvcIrb->OperandLength+3,  // Resp+SuID+OpCd+Opr[]
                    pAvcIrb->ResponseCode,
                    pAvcIrb->SubunitAddr[0],
                    pAvcIrb->Opcode,
                    pAvcIrb->Operands[0],
                    pAvcIrb->Operands[1],
                    pAvcIrb->Operands[2],
                    pAvcIrb->Operands[3],
                    pAvcIrb->Operands[4]
                ));
            }
#endif
        } else {
            TRACE(TL_FCP_ERROR,("AVCCmdCR: pIrp->IoStatus.Status return error:%x\n", pIrp->IoStatus.Status));
            // Irp returns ERROR !!
            if (STATUS_BUS_RESET == pIrp->IoStatus.Status || STATUS_REQUEST_ABORTED == pIrp->IoStatus.Status) {
                TRACE(TL_FCP_ERROR,("Bus-Reset or abort (IoStatus.St:%x); pCmdEntry:%x; OpC:%x\n", pIrp->IoStatus.Status, pCmdEntry, pCmdEntry->OpCode));

                // Busreset while there is an interim pending, signal its client to wake up 
                // and get the "final" (busreset) result.
                if(pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM) {
                    if(pCmdEntry->cmdType == AVC_CTYPE_CONTROL) {
                        TRACE(TL_FCP_TRACE,("--> BusRest: for control interim\n"));
                        bSignalInterimCotrolCompleted = TRUE;
                    } else if(pCmdEntry->cmdType == AVC_CTYPE_NOTIFY) {
                        TRACE(TL_FCP_TRACE,("--> BusRest: for notify interim\n"));
                        bSignalInterimNotifyCompleted = TRUE;                  
                    } else {
                        //
                        // Unexpected command state for a interim response
                        //
                        ASSERT(FALSE && "Unknow command state");
                    }
                }
            }
            else {
                TRACE(TL_FCP_ERROR,("IOCTL_AVC_CLASS Failed 0x%x\n", pIrp->IoStatus.Status));
            }

            pCmdEntry->cmdState = CMD_STATE_ABORTED;
            pCmdEntry->Status   = STATUS_REQUEST_ABORTED;  // -> ERROR_REQUERT_ABORT
        }

        //
        // If suceeded, translate the AVC response to COM property. if not 
        //    interim's final reponse.
        //    raw AVC command response
        //
        if(STATUS_SUCCESS == pCmdEntry->Status &&
           !bSignalInterimNotifyCompleted &&
           !bSignalInterimCotrolCompleted &&
           pCmdEntry->idxDVCRCmd != VCR_RAW_AVC
            )
            DVCRXlateRAwAVC(
                pCmdEntry, 
                pCmdEntry->pProperty
                );


        // Signal a KS event to inform its client that the final response 
        // has returned and come and get it.
        if(bSignalInterimNotifyCompleted) {
            pEvent = NULL;
            if(pEvent = StreamClassGetNextEvent((PVOID) pDevExt, 0, \
                (GUID *)&KSEVENTSETID_EXTDEV_Command, KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY, pEvent)) {            
                // Make sure the right event and then signal it
                if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY) {
                    StreamClassDeviceNotification(SignalDeviceEvent, pDevExt, pEvent);
                    TRACE(TL_FCP_TRACE,("->Signal NOTIFY_INTERIM ready; EventId %d.\n", pEvent->EventItem->EventId));
                }          
            }            
        } else if(bSignalInterimCotrolCompleted) {
            pEvent = NULL;
            if(pEvent = StreamClassGetNextEvent((PVOID) pDevExt, 0, \
                    (GUID *)&KSEVENTSETID_EXTDEV_Command, KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY, pEvent)) {
                // Make sure the right event and then signal it
                if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY) {
                    StreamClassDeviceNotification(SignalDeviceEvent, pDevExt, pEvent);
                    TRACE(TL_FCP_TRACE,("->Signal CONTROL_INTERIM ready; EventId %d.\n", pEvent->EventItem->EventId));
                }          
            }            
        }

        // Check that the command entry is ours only to process 
        // When a command is completed, it will be added to the list and therefore not empty.
        // It is designed to be added to the list in this completino routine.
        if (!IsListEmpty(&pCmdEntry->ListEntry)) {
            if(bSignalInterimNotifyCompleted || bSignalInterimCotrolCompleted) {
                // If final reponse is returned, we need to keep them in the list.
                TRACE(TL_FCP_TRACE,("Final response is completed; stay in the list\n"));
                KeReleaseSpinLock(&pDevExt->AVCCmdLock, oldIrql);
            }
            else {
                // This is a undefined path!!!
                // The command entry can only be in the list if it is interim of anykind.
                // If it is an interim, it will not be removed in the completion routine.
                ASSERT(FALSE && "Cannot complete an interim in CR\n");
            }
        }
        else {
            // This means that we have completed, but the code that issued the
            // command is still executing, and hasn't had a chance to look at
            // the results yet. Put this in the command list as a signal that
            // we have completed and updated the command state, but are not
            // planning to free the command resources.
            InsertTailList(&pDevExt->AVCCmdList, &pCmdEntry->ListEntry); pDevExt->cntCommandQueued++;
            TRACE(TL_FCP_TRACE,("Command completed and Queued(%d); pCmdEntry:%x.\n", pDevExt->cntCommandQueued, pCmdEntry));
            KeReleaseSpinLock(&pDevExt->AVCCmdLock, oldIrql);    
        }
    }
    else {
        TRACE(TL_FCP_WARNING,("IssueAVCCommandCR: pCmdEntry:%x; pIrp:%x cancelled\n", pCmdEntry, pIrp));
    }

    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // DVIssueAVCCommandCR

NTSTATUS  
DVIssueAVCCommand (
    IN PDVCR_EXTENSION pDevExt, 
    IN AvcCommandType cType,
    IN DVCR_AVC_COMMAND idxAVCCmd,
    IN PVOID pProperty
    )
/*++

Routine Description:

    Issue a FCP/AVC command.

Arguments:
    

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS      Status; 
    PAVCCmdEntry pCmdEntry;
    PAVC_COMMAND_IRB  pAvcIrb; 
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
#if DBG
    ULONGLONG tmStart;
    DWORD dwElapsed;
#endif
    PAGED_CODE();   
 

    if(pDevExt->bDevRemoved)
        return STATUS_DEVICE_NOT_CONNECTED;

    //
    // Validate Command type; the command type that each entry of the command table support.
    //
    switch(cType) {
    case AVC_CTYPE_CONTROL:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_CONTROL) != CMD_CONTROL)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_STATUS:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_STATUS) != CMD_STATUS)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_SPEC_INQ:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_SPEC_INQ) != CMD_SPEC_INQ) 
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_GEN_INQ:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_GEN_INQ) != CMD_GEN_INQ)
           return STATUS_NOT_SUPPORTED;
        break;
    case AVC_CTYPE_NOTIFY:
        if((DVcrAVCCmdTable[idxAVCCmd].ulCmdSupported & CMD_NOTIFY) != CMD_NOTIFY)
           return STATUS_NOT_SUPPORTED;
        break;
    default:
        TRACE(TL_FCP_ERROR,("IssueAVCCommand: idx %d, ctype (%02x) not supported; (%02x %02x %02x) %d:[%.8x]\n",
            idxAVCCmd,
            cType,
            DVcrAVCCmdTable[idxAVCCmd].CType,
            DVcrAVCCmdTable[idxAVCCmd].SubunitAddr,
            DVcrAVCCmdTable[idxAVCCmd].Opcode,
            DVcrAVCCmdTable[idxAVCCmd].OperandLength,
            (DWORD) *(&DVcrAVCCmdTable[idxAVCCmd].Operands[0])
            ));
        return STATUS_NOT_SUPPORTED;
    }

    // Create an AVC IRB and initialize it -
    pAvcIrb = ExAllocatePool(NonPagedPool, sizeof(AVC_COMMAND_IRB));
    if(!pAvcIrb) {
        TRACE(TL_FCP_ERROR,("IssueAVCCommand: Allocate Irb (%d bytes) failed\n", sizeof(AVC_COMMAND_IRB)));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));
    pAvcIrb->Function = AVC_FUNCTION_COMMAND;

    // - set the AVC command type (Control, Status, Notify, General Inquiry, Specific Inquiry)
    pAvcIrb->CommandType = cType;

    // - override the subunit address in the avc unit driver (if it even has one for us)
    pAvcIrb->SubunitAddrFlag = 1;
    pAvcIrb->SubunitAddr = &DVcrAVCCmdTable[idxAVCCmd].SubunitAddr;
    pAvcIrb->Opcode = DVcrAVCCmdTable[idxAVCCmd].Opcode;

    // - include alternate opcodes for the transport state opcode
    if (pAvcIrb->Opcode == OPC_TRANSPORT_STATE) {
        pAvcIrb->AlternateOpcodesFlag = 1;
        pAvcIrb->AlternateOpcodes = pDevExt->TransportModes;
    }

    // - set up the operand list
    pAvcIrb->OperandLength = DVcrAVCCmdTable[idxAVCCmd].OperandLength;
    ASSERT(pAvcIrb->OperandLength <= MAX_AVC_OPERAND_BYTES);
    RtlCopyMemory(pAvcIrb->Operands, DVcrAVCCmdTable[idxAVCCmd].Operands, pAvcIrb->OperandLength);

    // Create an Irp and initialize it
    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        TRACE(TL_FCP_ERROR,("IssueAVCCommand: Allocate Irb (%d bytes) failed\n", sizeof(AVC_COMMAND_IRB)));
        ExFreePool(pAvcIrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Create an AVC Command entry and initialize it
    pCmdEntry = (AVCCmdEntry *) ExAllocatePool(NonPagedPool, sizeof(AVCCmdEntry));
    if(!pCmdEntry) {
        TRACE(TL_FCP_ERROR,("IssueAVCCommand: Allocate CmdEntry (%d bytes) failed\n", sizeof(AVCCmdEntry)));
        ExFreePool(pAvcIrb);
        IoFreeIrp(pIrp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pCmdEntry, sizeof(AVCCmdEntry));
    pCmdEntry->pDevExt      = pDevExt;  // So we can access pDevExt->AVCCmdList;
    pCmdEntry->pProperty    = pProperty;
    pCmdEntry->cmdState     = CMD_STATE_ISSUED;
    pCmdEntry->Status       = STATUS_UNSUCCESSFUL;
    pCmdEntry->cmdType      = cType;
    pCmdEntry->OpCode       = DVcrAVCCmdTable[idxAVCCmd].Opcode;
    pCmdEntry->idxDVCRCmd   = idxAVCCmd;
    pCmdEntry->pAvcIrb      = pAvcIrb;
    pCmdEntry->pIrp         = pIrp;
    InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership

    TRACE(TL_FCP_WARNING,(">>>> AVCCmd: %d:[%.2x %.2x %.2x %.2x]:[%.2x %.2x %.2x %.2x]\n",                  
        pAvcIrb->OperandLength+3,  // Resp+SuID+OpCd+Opr[]
        cType,
        pAvcIrb->SubunitAddr[0],
        pAvcIrb->Opcode,
        pAvcIrb->Operands[0],
        pAvcIrb->Operands[1],
        pAvcIrb->Operands[2],
        pAvcIrb->Operands[3],
        pAvcIrb->Operands[4]
        ));

    // Finish initializing the Irp
    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_AVC_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAvcIrb;

    IoSetCompletionRoutine(pIrp, DVIssueAVCCommandCR, pCmdEntry, TRUE, TRUE, TRUE);

    pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

#if DBG
    tmStart = GetSystemTime();
#endif

    // Now make the call
    // If encounter an interim response, STATUS_PENDING will be returned.    
    Status = 
        IoCallDriver(
            pDevExt->pBusDeviceObject, 
            pIrp
            );

#if DBG
#define MAX_RESPONSE_TIME_FOR_ALERT  500 // msec
    dwElapsed = (DWORD) ((GetSystemTime() - tmStart)/10000); // Convert 100nsec unit to msec
    if(dwElapsed > MAX_RESPONSE_TIME_FOR_ALERT) {    
        TRACE(TL_FCP_ERROR,("ST:%x; AVC Cmd took %d msec to response; CmdType:%d; OpCd:%x\n", Status, dwElapsed, cType, DVcrAVCCmdTable[idxAVCCmd].Opcode));
        ASSERT(dwElapsed < MAX_RESPONSE_TIME_FOR_ALERT * 8 && "Exceeded max response time!");  // It should be 100, but let's detect the really slow one.
    }
#endif
   

    // Interim response...
    if (STATUS_PENDING == Status) {
        
        KIRQL OldIrql;

#if 1   // WORKITEM: control command can be in interim for a while!!!
        // Some DV will return interim but it will completed it with a change quickly.
        if(cType == AVC_CTYPE_CONTROL) {
#define MSDV_WAIT_CONTROL_CMD_INTERIM   300
            TRACE(TL_FCP_WARNING,("!!!!!!!!!!!  Control Interim-- Wait %d msec !!!!!!!!\n", MSDV_WAIT_CONTROL_CMD_INTERIM));
            DVDelayExecutionThread(MSDV_WAIT_CONTROL_CMD_INTERIM);
            ASSERT(!IsListEmpty(&pCmdEntry->ListEntry) && "Control Cmd was interim after wait.");
        }
#endif

        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);

        // Check that the Irp didn't complete between the return of IoCallDriver and now
        if (IsListEmpty(&pCmdEntry->ListEntry)) {
            // Enter INTERIM state
            pCmdEntry->cmdState = CMD_STATE_RESP_INTERIM;
            // Return STATUS_MORE_ENTRIES to inform caller that the command is pending.
            pCmdEntry->Status   = STATUS_MORE_ENTRIES;   // xlate to ERROR_MORE_DATA; No yet done with this command so keep the entry in the list

            // We have submitted a control or notify command, and have gotten
            // an Interim response. Put the command in the list so it can be
            // tracked for possible cancellation, and as an indication to the
            // completion routine that we won't be releasing any resources here.
            InsertTailList(&pDevExt->AVCCmdList, &pCmdEntry->ListEntry); pDevExt->cntCommandQueued++;
            pCmdEntry->pProperty = NULL;    // won't be using this, so get rid of it
            TRACE(TL_FCP_TRACE,("->AVC command Irp is pending!\n"));
            KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
            return pCmdEntry->Status;

        } else {
            // Although IoCallDriver indicated that the command was pending,
            // it has since been completed. The completion routine saw that
            // the command entry had not yet been added to the command list,
            // so put it there to let us know that we need to retain control
            // and free the resources.
            //
            // Temporarily change the status so the cleanup code path will
            // be followed.
            TRACE(TL_FCP_TRACE,("-> Cmd Rtns Pending but completed; treat as non-pending! ST:%x\n", pCmdEntry->Status));
            Status = STATUS_SUCCESS;
        }

        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);
    } 

    // Status from IoCallDriver can return:
    //    STATUS_PENDING (process above)  // If control, we wait and see if it get completed (risky!!)
    //    STATUS_TIMEOUT 
    //    STATUS_SUCCESS

    if(STATUS_PENDING != Status) {
        // The completion routine is usually the only one that frees the Irp. Is
        // it possible that the completion routine never got called? This will let
        // us know, since the completion routine will always make sure that the
        // command entry's Irp pointer is cleared.
        if(pCmdEntry->pIrp) {
            // If for some reason the completion routine never got called, free the Irp
            if(pCmdEntry->pIrp)
                IoFreeIrp(pCmdEntry->pIrp);
            pCmdEntry->pIrp = NULL;
        }
    }

    //
    // pCmdEntry->Status is the command response Status set in the completion routine, which can be
    //    STATUS_SUCCESS
    //    STATUS_REQ_NOT_ACCEP
    //    STATUS_NOT_SUPPORTED
    //    STATUS_MORE_ENTRIES    // Should not happen!!
    //    STATUS_REQUEST_ABORTED
    //

    // One possible valid command from IoCallDriver is STATUS_TIMEOUT, and
    // this shoull be returned, anything else we will get the status from pCmdEntry->Status
    // which was set in the completion routine.
    if (Status != STATUS_TIMEOUT) 
        Status = pCmdEntry->Status;  // This Status is being returned from this functino

    // Desiding if leaving the command response (entry) in the command list
    // Not if it is an (1) interim (all STATUS_MORE_ENTRIES); or (2) any RAW AVC response regardless of its status.
    if(STATUS_MORE_ENTRIES == Status ||
       VCR_RAW_AVC == pCmdEntry->idxDVCRCmd) {
        TRACE(TL_FCP_TRACE,("Status:%x; Do not remove (1) interim response or (2) a raw AVC response\n", Status));
    } 
    // Else we are done!
    else {
        KIRQL OldIrql;
        // It's time to clean up the command
        KeAcquireSpinLock(&pDevExt->AVCCmdLock, &OldIrql);
        if (!IsListEmpty(&pCmdEntry->ListEntry)) {
            RemoveEntryList(&pCmdEntry->ListEntry); pDevExt->cntCommandQueued--;
            InitializeListHead(&pCmdEntry->ListEntry);  // used as a flag for ownership
        }
        KeReleaseSpinLock(&pDevExt->AVCCmdLock, OldIrql);

        // Free the resources
        ExFreePool(pCmdEntry);
        ExFreePool(pAvcIrb);
    }  // else

    TRACE(TL_FCP_TRACE,("**** DVIssueAVCCmd (exit): St:%x; pCmdEntry:%x; cmdQueued:%d\n", Status, pCmdEntry, pDevExt->cntCommandQueued));                

    return Status;
}



#ifndef OATRUE
#define OATRUE (-1)
#endif
#ifndef OAFALSE
#define OAFALSE (0)
#endif

NTSTATUS 
DVGetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Get external device property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTDEVICE_S pExtDeviceProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_STATUS;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTDEVICE_S)); 

    pExtDeviceProperty = (PKSPROPERTY_EXTDEVICE_S) pSPD->PropertyInfo;    // pointer to the data

  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_EXTDEVICE_ID:
        if(pDevExt->ulVendorID) {
            // It was not bswap in the monolithic version so for competibility,
            // we will bswap this.
            pExtDeviceProperty->u.NodeUniqueID[0] = pDevExt->UniqueID.LowPart; 
            pExtDeviceProperty->u.NodeUniqueID[1] = pDevExt->UniqueID.HighPart;
            TRACE(TL_FCP_WARNING,("Low:%x; High:%x of UniqueID\n", pDevExt->UniqueID.LowPart, pDevExt->UniqueID.HighPart ));
            Status = STATUS_SUCCESS;
        } else {
            TRACE(TL_FCP_ERROR,("Failed: Vid:%x; Mid:%x\n", bswap(pDevExt->ulVendorID) >> 8, pDevExt->ulModelID ));
            Status = STATUS_UNSUCCESSFUL;
        }
        goto ExitGetDeviceProperty;                
        break;

    case KSPROPERTY_EXTDEVICE_VERSION:
        // AV/C VCR Subunit Specification 2.1.0 
        // Change from 2.0.1:
        //     Add Hi8 support
        wcscpy(pExtDeviceProperty->u.pawchString, L"2.1.0");  
        Status = STATUS_SUCCESS;
        goto ExitGetDeviceProperty;        
        break;

    case KSPROPERTY_EXTDEVICE_POWER_STATE:       
        idxDVCRCmd = DV_GET_POWER_STATE;
        break;       

    case KSPROPERTY_EXTDEVICE_PORT:
        pExtDeviceProperty->u.DevPort  = DEV_PORT_1394; 
        Status = STATUS_SUCCESS;        
        goto ExitGetDeviceProperty;                
        break;

    case KSPROPERTY_EXTDEVICE_CAPABILITIES:

        // Refresh mode of operation whenever capabilities is queried
        // since the mode of operation might have changed and is returned..
        DVGetDevModeOfOperation(pDevExt);

        // Can record only in VCR mode and has input plug(s).
        pExtDeviceProperty->u.Capabilities.CanRecord  = pDevExt->ulDevType == ED_DEVTYPE_VCR ? (pDevExt->pDevInPlugs->NumPlugs > 0 ? OATRUE : OAFALSE): OAFALSE;
        pExtDeviceProperty->u.Capabilities.CanRecordStrobe  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.HasAudio   = OATRUE;         
        pExtDeviceProperty->u.Capabilities.HasVideo   = OATRUE;        
        pExtDeviceProperty->u.Capabilities.UsesFiles  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.CanSave    = OAFALSE;
        pExtDeviceProperty->u.Capabilities.DeviceType = pDevExt->ulDevType;        
        pExtDeviceProperty->u.Capabilities.TCRead     = OATRUE;        
        pExtDeviceProperty->u.Capabilities.TCWrite    = OAFALSE; // DV decided        
        pExtDeviceProperty->u.Capabilities.CTLRead    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.IndexRead  = OAFALSE;        
        pExtDeviceProperty->u.Capabilities.Preroll    = 0L;      // NOT implemented, supposely can reg in INF and then read from registry       
        pExtDeviceProperty->u.Capabilities.Postroll   = 0L;      // NOT implemented, supposely can reg in INF and then read from registry 
        pExtDeviceProperty->u.Capabilities.SyncAcc    = ED_CAPABILITY_UNKNOWN;       
        pExtDeviceProperty->u.Capabilities.NormRate   = pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_SDDV_NTSC ? ED_RATE_2997 : ED_RATE_25;
        pExtDeviceProperty->u.Capabilities.CanPreview = OAFALSE;    // View what is in the bus or tape
        pExtDeviceProperty->u.Capabilities.CanMonitorSrc = OATRUE;  // ViewFinder
        pExtDeviceProperty->u.Capabilities.CanTest    = OAFALSE;    // To see if a function is iplemented
        pExtDeviceProperty->u.Capabilities.VideoIn    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.AudioIn    = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.Calibrate  = OAFALSE;  
        pExtDeviceProperty->u.Capabilities.SeekType   = ED_CAPABILITY_UNKNOWN;  

        TRACE(TL_FCP_TRACE,("GetExtDeviceProperty: DeviceType %x\n", pExtDeviceProperty->u.Capabilities.DeviceType));

        Status = STATUS_SUCCESS;               
        goto ExitGetDeviceProperty;        
        break;
       
    default:
        Status = STATUS_NOT_SUPPORTED;        
        goto ExitGetDeviceProperty;        
        break;
    }

    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pExtDeviceProperty);
    TRACE(TL_FCP_TRACE,("GetExtDevice: idxDVCRCmd %d, cmdType %d, Status %x\n", idxDVCRCmd, cType, Status)); 

ExitGetDeviceProperty:

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTDEVICE_S) : 0);

    return Status;
}




NTSTATUS 
DVSetExtDeviceProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Set external device property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTDEVICE_S pExtDeviceProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_CONTROL;



    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTDEVICE_S)); 

    pExtDeviceProperty = (PKSPROPERTY_EXTDEVICE_S) pSPD->PropertyInfo;    // pointer to the data

  
    switch (pSPD->Property->Id) {
    case KSPROPERTY_EXTDEVICE_POWER_STATE:
        switch(pExtDeviceProperty->u.PowerState) {
        case ED_POWER_ON:
            idxDVCRCmd = DV_SET_POWER_STATE_ON;
            break;
        case ED_POWER_STANDBY:
            Status = STATUS_NOT_SUPPORTED;  // AVC spec does not have a stanby power mode
            goto ExitSetDeviceProperty;
            break;
        case ED_POWER_OFF:
            idxDVCRCmd = DV_SET_POWER_STATE_OFF;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto ExitSetDeviceProperty;
        }
        break;  
    default:   
        Status = STATUS_NOT_SUPPORTED;                ;
        goto ExitSetDeviceProperty;
    }

    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pExtDeviceProperty);
    TRACE(TL_FCP_TRACE,("SetExtDevice: idxDVCRCmd %d, cmdType %d, Status %x\n", idxDVCRCmd, cType, Status)); 

ExitSetDeviceProperty:

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTDEVICE_S) : 0);
 
    return Status;
}

NTSTATUS 
DVGetExtTransportProperty(    
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Get external transport property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferred.

Return Value:

    NTSTATUS 

--*/
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_STATUS;
    BOOL bHasTape = pDevExt->bHasTape;

    PAVCCmdEntry  pCmdEntry;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTXPORT_S)); 

    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pSPD->PropertyInfo;    // pointer to the data
    *pulActualBytesTransferred = 0;


    switch (pSPD->Property->Id) {
    case KSPROPERTY_EXTXPORT_CAPABILITIES:
        return STATUS_NOT_IMPLEMENTED;

    case KSPROPERTY_RAW_AVC_CMD:
        pCmdEntry = DVCRFindCmdEntryCompleted( 
            pDevExt, 
            VCR_RAW_AVC,
            DVcrAVCCmdTable[VCR_RAW_AVC].Opcode,
            DVcrAVCCmdTable[VCR_RAW_AVC].CType
            );

        if(pCmdEntry) {
            PAVC_COMMAND_IRB pAvcIrb;

            pAvcIrb = pCmdEntry->pAvcIrb;
            ASSERT(pAvcIrb);

            if (pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED ||
                pCmdEntry->cmdState == CMD_STATE_RESP_REJECTED ||
                pCmdEntry->cmdState == CMD_STATE_RESP_NOT_IMPL ||
                pCmdEntry->cmdState == CMD_STATE_RESP_INTERIM
                ) {
                // bytes for operands plus response, subunit addr, and opcode
                pXPrtProperty->u.RawAVC.PayloadSize = pAvcIrb->OperandLength + 3;
                pXPrtProperty->u.RawAVC.Payload[0] = pAvcIrb->ResponseCode;
                pXPrtProperty->u.RawAVC.Payload[1] = pAvcIrb->SubunitAddr[0];
                pXPrtProperty->u.RawAVC.Payload[2] = pAvcIrb->Opcode;                
                RtlCopyMemory(&pXPrtProperty->u.RawAVC.Payload[3], pAvcIrb->Operands, pAvcIrb->OperandLength);

                TRACE(TL_FCP_WARNING,("RawAVCResp: pEntry:%x; State:%x; Status:%x; Sz:%d; Rsp:%x;SuId:%x;OpCd:%x; Opr:[%x %x %x %x]\n",
                    pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status,
                    pXPrtProperty->u.RawAVC.PayloadSize,
                    pXPrtProperty->u.RawAVC.Payload[0],
                    pXPrtProperty->u.RawAVC.Payload[1],
                    pXPrtProperty->u.RawAVC.Payload[2],
                    pXPrtProperty->u.RawAVC.Payload[3],
                    pXPrtProperty->u.RawAVC.Payload[4],
                    pXPrtProperty->u.RawAVC.Payload[5],
                    pXPrtProperty->u.RawAVC.Payload[6]
                    )); 

                // If not success, bytes transferred and data will not returned!
                Status = STATUS_SUCCESS;  

                *pulActualBytesTransferred = sizeof (KSPROPERTY_EXTXPORT_S);
            } else {
                TRACE(TL_FCP_ERROR,("RawAVCResp: Found; but pCmdEntry:%x, unexpected cmdState:%d; ST:%x\n", pCmdEntry, pCmdEntry->cmdState, pCmdEntry->Status));
                ASSERT(pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED && "Unexpected command state\n");
                Status = STATUS_REQUEST_ABORTED;
                *pulActualBytesTransferred = 0;
            }

            // pIrp is NULL if it has been completed.
            if(pCmdEntry->pIrp) {
                TRACE(TL_FCP_ERROR,("RawAVCResp: pCmdEntry %x; ->pIrp:%x not completd yet!\n", pCmdEntry, pCmdEntry->pIrp));
                ASSERT(pCmdEntry->pIrp == NULL && "pIrp is not completed!");
                IoCancelIrp(pCmdEntry->pIrp);
            }
            // Not used in the completion routine if pIrp->Cancel
            ExFreePool(pCmdEntry);
            ExFreePool(pAvcIrb);
        }
        else {
            TRACE(TL_FCP_ERROR,("KSPROPERTY_RAW_AVC_CMD, did not find a match[%x]!\n", 
                *((DWORD *) &DVcrAVCCmdTable[VCR_RAW_AVC].CType) )); 
            *pulActualBytesTransferred = 0;
            Status = STATUS_NOT_FOUND;  // ERROR_MR_MID_NOT_FOUND
        }
        return Status;

    case KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE: // MPEG, D-VHS, Analog VHS etc.
        idxDVCRCmd = VCR_INPUT_SIGNAL_MODE;
        break;
    case KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE: // MPEG, D-VHS, Analog VHS etc.
        idxDVCRCmd = VCR_OUTPUT_SIGNAL_MODE;
        break;
    case KSPROPERTY_EXTXPORT_MEDIUM_INFO:       // cassettte_type and tape_grade_and_write_protect
        idxDVCRCmd = VCR_MEDIUM_INFO;
        break;  
    case KSPROPERTY_EXTXPORT_STATE: 
        idxDVCRCmd = VCR_TRANSPORT_STATE;        
        break; 

    case KSPROPERTY_EXTXPORT_STATE_NOTIFY: 
        // Get final result from previous set command
        pCmdEntry = DVCRFindCmdEntryCompleted( 
            pDevExt, 
            VCR_TRANSPORT_STATE_NOTIFY,
            DVcrAVCCmdTable[VCR_TRANSPORT_STATE_NOTIFY].Opcode,
            DVcrAVCCmdTable[VCR_TRANSPORT_STATE_NOTIFY].CType
            );

        if(pCmdEntry) {
            PAVC_COMMAND_IRB pAvcIrb;

            pAvcIrb = pCmdEntry->pAvcIrb;
            ASSERT(pCmdEntry->pAvcIrb);

            TRACE(TL_FCP_WARNING,("->Notify Resp: pCmdEntry:%x; pIrb:%x; %d:[%.2x %.2x %.2x %.2x]\n",
                pCmdEntry, pAvcIrb,
                pAvcIrb->OperandLength + 3,
                pAvcIrb->ResponseCode,
                pAvcIrb->SubunitAddr[0],
                pAvcIrb->Opcode,
                pAvcIrb->Operands[0]
                )); 

            if(pCmdEntry->cmdState == CMD_STATE_RESP_ACCEPTED)
                Status = 
                    DVCRXlateRAwAVC(
                        pCmdEntry, 
                        pXPrtProperty
                        );

            // pIrp is NULL if it has been completed.
            if(pCmdEntry->pIrp) {
                TRACE(TL_FCP_ERROR,("XPrtNotifyResp: pCmdEntry %x; ->pIrp:%x not completed; IoCancelIrp(pIrp)\n", pCmdEntry, pCmdEntry->pIrp));
                IoCancelIrp(pCmdEntry->pIrp);
            }
            // These two are not touched in the CompletionRoutine if pIrp->Cancel
            ExFreePool(pCmdEntry);
            ExFreePool(pAvcIrb);

            *pulActualBytesTransferred = STATUS_SUCCESS == Status ? sizeof (KSPROPERTY_EXTXPORT_S) : 0;
        }
        else {
            TRACE(TL_FCP_ERROR,("EXTXPORT_STATE_NOTIFY: no match!\n"));
            *pulActualBytesTransferred = 0;
            Status = STATUS_NOT_FOUND;  // ERROR_MR_MID_NOT_FOUND
        }
        return Status;

    default:
        TRACE(TL_FCP_ERROR,("GetExtTransportProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED;                
    }


    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pXPrtProperty);
    TRACE(TL_FCP_TRACE,("GetExtTransportProperty: idxDVCRCmd %d, cmdType %d, Status %x\n", idxDVCRCmd, cType, Status)); 
    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_EXTXPORT_S) : 0);


    if(STATUS_SUCCESS == Status &&
       idxDVCRCmd == VCR_MEDIUM_INFO) {

        // Update Media info
        pDevExt->bHasTape        = pXPrtProperty->u.MediumInfo.MediaPresent;
        pDevExt->bWriteProtected = pXPrtProperty->u.MediumInfo.RecordInhibit;

        TRACE(TL_FCP_TRACE,("bHasTape: IN(%d):OUT(%d), ulDevType %d\n", bHasTape, pDevExt->bHasTape, pDevExt->ulDevType));        
    }
 
    return Status;
}




NTSTATUS 
DVSetExtTransportProperty( 
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT ULONG *pulActualBytesTransferred
    )
/*++

Routine Description:

    Handle Set external transport property.

Arguments:

    pDevExt - Device's extension
    pSPD - Stream property descriptor
    pulActualBytesTransferred - Number of byte transferr

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;
    AvcCommandType cType = AVC_CTYPE_CONTROL;


    PAGED_CODE();

    ASSERT(pDevExt);    
    ASSERT(pSPD);
    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_EXTXPORT_S)); 

    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) pSPD->PropertyInfo;    // pointer to the data    
    *pulActualBytesTransferred = 0;

    switch (pSPD->Property->Id) {

    case KSPROPERTY_EXTXPORT_STATE: 
     
         switch (pXPrtProperty->u.XPrtState.Mode) {
// RECORD
         case ED_MODE_RECORD:
             idxDVCRCmd = VCR_RECORD;
             break;
         case ED_MODE_RECORD_FREEZE:
             idxDVCRCmd = VCR_RECORD_PAUSE;
             break;

// PLAY
         case ED_MODE_STEP_FWD:
             idxDVCRCmd = VCR_PLAY_FORWARD_STEP;
             break;
         case ED_MODE_PLAY_SLOWEST_FWD:
             // DVCPRO does not seem to support the standard play slow fwd so this is an alternate
             if(pDevExt->bDVCPro)
                 idxDVCRCmd = VCR_PLAY_FORWARD_SLOWEST2;
             else
                 idxDVCRCmd = VCR_PLAY_FORWARD_SLOWEST;
             break;
         case ED_MODE_PLAY_FASTEST_FWD:
             idxDVCRCmd = VCR_PLAY_FORWARD_FASTEST;
             break;

         case ED_MODE_STEP_REV:
             idxDVCRCmd = VCR_PLAY_REVERSE_STEP;
             break;
         case ED_MODE_PLAY_SLOWEST_REV:
             // DVCPRO does not seem to support the standard play slow rev so this is an alternate
             if(pDevExt->bDVCPro)
                 idxDVCRCmd = VCR_PLAY_REVERSE_SLOWEST2;
             else
                 idxDVCRCmd = VCR_PLAY_REVERSE_SLOWEST;
             break;
         case ED_MODE_PLAY_FASTEST_REV:
             idxDVCRCmd = VCR_PLAY_REVERSE_FASTEST;
             break;

         case ED_MODE_PLAY:
             idxDVCRCmd = VCR_PLAY_FORWARD;
             break;
         case ED_MODE_FREEZE:
             idxDVCRCmd = VCR_PLAY_FORWARD_PAUSE;
             break;


// WIND
         case ED_MODE_STOP:
             idxDVCRCmd = VCR_WIND_STOP;
             break;
         case ED_MODE_FF:
             idxDVCRCmd = VCR_WIND_FAST_FORWARD;
             break;
         case ED_MODE_REW:
             idxDVCRCmd = VCR_WIND_REWIND;
             break;


         default:
             TRACE(TL_FCP_ERROR,("SetExtTransportProperty: NOT_IMPLEMENTED XPrtState.Mode %d\n", pXPrtProperty->u.XPrtState.Mode));        
             return STATUS_NOT_SUPPORTED; 
         }
         break;

    case KSPROPERTY_EXTXPORT_STATE_NOTIFY: 
        idxDVCRCmd = VCR_TRANSPORT_STATE_NOTIFY;
        cType = AVC_CTYPE_NOTIFY;        
        TRACE(TL_FCP_TRACE,("->Notify XPrt State Cmd issued.\n"));
        break; 

    case KSPROPERTY_EXTXPORT_LOAD_MEDIUM:  
        idxDVCRCmd = VCR_LOAD_MEDIUM_EJECT;
        break;

    case KSPROPERTY_EXTXPORT_TIMECODE_SEARCH: 
        idxDVCRCmd = VCR_TIMECODE_SEARCH;
        TRACE(TL_FCP_ERROR,("SetExtTransportProperty: KSPROPERTY_EXTXPORT_TIMECODE_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED; 
        
    case KSPROPERTY_EXTXPORT_ATN_SEARCH: 
        idxDVCRCmd = VCR_ATN_SEARCH;
        TRACE(TL_FCP_ERROR,("SetExtTransportProperty: KSPROPERTY_EXTXPORT_ATN_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED; 
        
    case KSPROPERTY_EXTXPORT_RTC_SEARCH: 
        idxDVCRCmd = VCR_RTC_SEARCH;
        TRACE(TL_FCP_ERROR,("SetExtTransportProperty: KSPROPERTY_EXTXPORT_RTC_SEARCH NOT_SUPPORTED\n"));        
        *pulActualBytesTransferred = 0;
        return STATUS_NOT_SUPPORTED;         

    case KSPROPERTY_RAW_AVC_CMD:
        idxDVCRCmd = VCR_RAW_AVC;   
        if(pXPrtProperty->u.RawAVC.PayloadSize <= MAX_FCP_PAYLOAD_SIZE) { 

            DVcrAVCCmdTable[idxDVCRCmd].CType = pXPrtProperty->u.RawAVC.Payload[0];
            DVcrAVCCmdTable[idxDVCRCmd].SubunitAddr = pXPrtProperty->u.RawAVC.Payload[1];
            DVcrAVCCmdTable[idxDVCRCmd].Opcode = pXPrtProperty->u.RawAVC.Payload[2];
            DVcrAVCCmdTable[idxDVCRCmd].OperandLength = pXPrtProperty->u.RawAVC.PayloadSize - 3;
            RtlCopyMemory(DVcrAVCCmdTable[idxDVCRCmd].Operands, pXPrtProperty->u.RawAVC.Payload + 3, DVcrAVCCmdTable[idxDVCRCmd].OperandLength);

            // extract command type; for RAW AVC, it can be anything.
            cType = pXPrtProperty->u.RawAVC.Payload[0];

            TRACE(TL_FCP_WARNING,("RawAVC cmd: cType %x, PayLoadSize %d, PayLoad %x %x %x %x\n",
                cType,
                pXPrtProperty->u.RawAVC.PayloadSize,
                pXPrtProperty->u.RawAVC.Payload[0],
                pXPrtProperty->u.RawAVC.Payload[1],
                pXPrtProperty->u.RawAVC.Payload[2],
                pXPrtProperty->u.RawAVC.Payload[3]
                )); 

        } else {
            Status = STATUS_INVALID_PARAMETER;
            *pulActualBytesTransferred = 0;
            return Status;
        }
        break;

    default:
        TRACE(TL_FCP_ERROR,("SetExtTransportProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED; 
    }

    Status = DVIssueAVCCommand(pDevExt, cType, idxDVCRCmd, (PVOID) pXPrtProperty);

    TRACE(TL_FCP_TRACE,("SetExtTransportProperty: idxDVCRCmd %d, Status %x\n", idxDVCRCmd, Status));
    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (PKSPROPERTY_EXTXPORT_S) : 0);

    return Status;
}

NTSTATUS 
DVGetTimecodeReaderProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSPROPERTY_TIMECODE_S pTmCdReaderProperty;
    DVCR_AVC_COMMAND idxDVCRCmd;


    PAGED_CODE();

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TIMECODE_S)); 

    pTmCdReaderProperty = (PKSPROPERTY_TIMECODE_S) pSPD->PropertyInfo;    // pointer to the data
    *pulActualBytesTransferred = 0;
  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_TIMECODE_READER:
        idxDVCRCmd = VCR_TIMECODE_READ;
#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
        // There can only be one active stream.
        if(pDevExt->cndStrmOpen == 1 &&            
           pDevExt->paStrmExt[pDevExt->idxStreamNumber]->StreamState == KSSTATE_RUN) {

            if(pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bTimecodeUpdated) {
                // Once it is read, it is stale.
                pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bTimecodeUpdated = FALSE;

                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames = 
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[0]) << 24) |
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[1]) << 16) |
                    (((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[2]) <<  8) |
                     ((DWORD) pDevExt->paStrmExt[pDevExt->idxStreamNumber]->Timecode[3]);

                *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);
                return STATUS_SUCCESS;
            }
            else {
                TRACE(TL_FCP_TRACE,("bTimecode stale, issue AVC command to read it.\n"));
            }
        }
#endif
        break;

    case KSPROPERTY_ATN_READER:
        idxDVCRCmd = VCR_ATN_READ;
#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA

        // There can only be one active stream.
        if(pDevExt->cndStrmOpen == 1 && 
           pDevExt->paStrmExt[pDevExt->idxStreamNumber]->StreamState == KSSTATE_RUN) {

            if(pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bATNUpdated) {
                // Once it is read, it is stale.
                pDevExt->paStrmExt[pDevExt->idxStreamNumber]->bATNUpdated = FALSE;

                pTmCdReaderProperty->TimecodeSamp.timecode.dwFrames = 
                    pDevExt->paStrmExt[pDevExt->idxStreamNumber]->AbsTrackNumber >> 1;
                pTmCdReaderProperty->TimecodeSamp.dwUser = 
                    pDevExt->paStrmExt[pDevExt->idxStreamNumber]->AbsTrackNumber & 0x00000001;

                *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);            
                return STATUS_SUCCESS;
            }
            else {
                TRACE(TL_FCP_WARNING,("bATN stale, issue AVC command to read it.\n"));
            }
        }
#endif
        break;

    case KSPROPERTY_RTC_READER:
        idxDVCRCmd = VCR_RTC_READ;
        break;

    default:
        TRACE(TL_FCP_ERROR,("GetTimecodeReaderProperty: NOT_IMPLEMENTED Property->Id %d\n", pSPD->Property->Id));        
        return STATUS_NOT_SUPPORTED; 
    }

    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            idxDVCRCmd, 
            (PVOID) pTmCdReaderProperty
            );  

    TRACE(TL_FCP_TRACE,("GetTimecodeReaderProperty: idxDVCRCmd %d, Status %x\n", idxDVCRCmd, Status));     

    *pulActualBytesTransferred = (Status == STATUS_SUCCESS ? sizeof (KSPROPERTY_TIMECODE_S) : 0);
 
    return Status;
}

NTSTATUS 
DVMediaSeekingProperty(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    OUT PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID * pTimeFormatGuid;
    KSMULTIPLE_ITEM * pMultipleItem;

    PAGED_CODE();


    *pulActualBytesTransferred = 0;
  
    switch (pSPD->Property->Id) {

    case KSPROPERTY_MEDIASEEKING_FORMATS:
        // Its is KSMULTIPLE_ITEM so it is a two step process to return the data:
        // (1) return size in pActualBytesTransferred with STATUS_BUFFER_OVERFLOW
        // (2) 2nd time to get its actual data.
        if(pSPD->PropertyOutputSize == 0) {
            *pulActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            Status = STATUS_BUFFER_OVERFLOW;
        
        } else if(pSPD->PropertyOutputSize >= (sizeof(KSMULTIPLE_ITEM) + sizeof(GUID))) {
            pMultipleItem = (KSMULTIPLE_ITEM *) pSPD->PropertyInfo;    // pointer to the data
            pMultipleItem->Count = 1;
            pMultipleItem->Size  = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            pTimeFormatGuid = (GUID *) (pMultipleItem + 1);    // pointer to the data
            memcpy(pTimeFormatGuid, &KSTIME_FORMAT_MEDIA_TIME, sizeof(GUID));
            *pulActualBytesTransferred = sizeof(KSMULTIPLE_ITEM) + sizeof(GUID);
            Status = STATUS_SUCCESS;         

        } else {
            TRACE(TL_FCP_ERROR,("MediaSeekingProperty: KSPROPERTY_MEDIASEEKING_FORMAT; STATUS_INVALID_PARAMETER\n"));
            Status = STATUS_INVALID_PARAMETER;
        }  
        break;

    default:
        TRACE(TL_FCP_ERROR,("MediaSeekingProperty:Not supported ID %d\n", pSPD->Property->Id));
        return STATUS_NOT_SUPPORTED;         
    }

    return Status;
}



NTSTATUS
AVCTapeGetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handles Get operations for all adapter properties.

Arguments:   

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;

    PAGED_CODE();


    if (IsEqualGUID (&PROPSETID_EXT_DEVICE, &pSPD->Property->Set)) {
        Status = 
            DVGetExtDeviceProperty(              
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_EXT_TRANSPORT, &pSPD->Property->Set)) {
        Status = 
            DVGetExtTransportProperty(
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_TIMECODE_READER, &pSPD->Property->Set)) {
        Status = 
            DVGetTimecodeReaderProperty(
                pDevExt,
                pSPD,
                pulActualBytesTransferred
                );
    } 
    else 
    if (IsEqualGUID (&KSPROPSETID_MediaSeeking, &pSPD->Property->Set)) {

        Status = 
            DVMediaSeekingProperty(                
                pDevExt,
                pSPD, 
                pulActualBytesTransferred
                ); 
        
    } else {
        //
        // We should never get here
        //
        Status = STATUS_NOT_SUPPORTED;
        TRACE(TL_FCP_ERROR,("get unknown property\n"));
        ASSERT(FALSE);
    }

    return Status;
}



NTSTATUS
AVCTapeSetDeviceProperty(
    IN PDVCR_EXTENSION     pDevExt,  
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    IN PULONG pulActualBytetransferred
    )
/*++

Routine Description:

    Handles Set operations for all adapter properties.

Arguments:

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PAGED_CODE();


    if (IsEqualGUID (&PROPSETID_EXT_DEVICE, &pSPD->Property->Set)) {
        Status = 
            DVSetExtDeviceProperty(
                pDevExt,
                pSPD,
                pulActualBytetransferred
                );
    } 
    else 
    if (IsEqualGUID (&PROPSETID_EXT_TRANSPORT, &pSPD->Property->Set)) {
        Status = 
            DVSetExtTransportProperty(
                pDevExt,
                pSPD,
                pulActualBytetransferred
                );
    } 
    else {
        Status = STATUS_NOT_SUPPORTED;

        //
        // We should never get here
        //
        TRACE(TL_FCP_ERROR,("set unknown property\n"));
        ASSERT(FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpguts.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSTpGuts.c

Abstract:

    Main service functions.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"

#include "1394.h"
#include "61883.h"
#include "avc.h"

#include "dbg.h"
#include "ksguid.h"

#include "MsTpFmt.h"  // Before MsTpDefs.h
#include "MsTpDef.h"

#include "MsTpGuts.h"
#include "MsTpUtil.h"
#include "MsTpAvc.h"

#include "XPrtDefs.h"
#include "EDevCtrl.h"

// Support MPEG2TS stride data format MPEG2_TRANSPORT_STRIDE
#include "BdaTypes.h" 

//
// Define formats supported
//
#include "strmdata.h"


NTSTATUS
AVCTapeGetDevInfo(
    IN PDVCR_EXTENSION  pDevExt,
    IN PAV_61883_REQUEST  pAVReq
    );
VOID 
AVCTapeIniStrmExt(
    PHW_STREAM_OBJECT  pStrmObject,
    PSTREAMEX          pStrmExt,
    PDVCR_EXTENSION    pDevExt,
    PSTREAM_INFO_AND_OBJ   pStream
    );
NTSTATUS 
DVStreamGetConnectionProperty (
    PDVCR_EXTENSION pDevExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    );
NTSTATUS
DVGetDroppedFramesProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    );

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, AVCTapeGetDevInfo)
     #pragma alloc_text(PAGE, AVCTapeInitialize)
     #pragma alloc_text(PAGE, AVCTapeGetStreamInfo)
     #pragma alloc_text(PAGE, AVCTapeVerifyDataFormat)
     #pragma alloc_text(PAGE, AVCTapeGetDataIntersection)
     #pragma alloc_text(PAGE, AVCTapeIniStrmExt)
     #pragma alloc_text(PAGE, AVCTapeOpenStream)
     #pragma alloc_text(PAGE, AVCTapeCloseStream)
     #pragma alloc_text(PAGE, DVChangePower)
     #pragma alloc_text(PAGE, AVCTapeSurpriseRemoval)
     #pragma alloc_text(PAGE, AVCTapeProcessPnPBusReset)
     #pragma alloc_text(PAGE, AVCTapeUninitialize)

     #pragma alloc_text(PAGE, DVStreamGetConnectionProperty)
     #pragma alloc_text(PAGE, DVGetDroppedFramesProperty)
     #pragma alloc_text(PAGE, DVGetStreamProperty)
     #pragma alloc_text(PAGE, DVSetStreamProperty)
     #pragma alloc_text(PAGE, AVCTapeOpenCloseMasterClock)
     #pragma alloc_text(PAGE, AVCTapeIndicateMasterClock)
#endif
#endif



NTSTATUS
AVCStrmReqIrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          Event
    )
{
#if DBG
    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        TRACE(TL_FCP_WARNING,("AVCStrmReqIrpSynchCR: pIrp->IoStatus.Status:%x\n", pIrp->IoStatus.Status));
    }
#endif
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // AVCStrmReqIrpSynchCR


NTSTATUS
AVCStrmReqSubmitIrpSynch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP  pIrp,
    IN PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq
    )
{
    NTSTATUS            Status;
    KEVENT              Event;
    PIO_STACK_LOCATION  NextIrpStack;
  

    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_AVCSTRM_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAVCStrmReq;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        AVCStrmReqIrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            DeviceObject,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_TRACE,("(AVCStrm) Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("Irp has completed; IoStatus.Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    TRACE(TL_PNP_TRACE,("AVCStrmReqSubmitIrpSynch: IoCallDriver, Status:%x\n", Status));

    return Status;
} // AVCStrmReqSubmitIrpSynch


NTSTATUS
AVCReqIrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          Event
    )
{
#if DBG
    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        TRACE(TL_PNP_WARNING,("AVCReqIrpSynchCR: pIrp->IoStatus.Status:%x\n", pIrp->IoStatus.Status));
    }
#endif
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // AVCReqIrpSynchCR


NTSTATUS
AVCReqSubmitIrpSynch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP  pIrp,
    IN PAVC_MULTIFUNC_IRB  pAvcIrbReq
    )
{
    NTSTATUS            Status;
    KEVENT              Event;
    PIO_STACK_LOCATION  NextIrpStack;
  

    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_AVC_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAvcIrbReq;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        AVCReqIrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            DeviceObject,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_TRACE,("(AVC) Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("Irp has completed; IoStatus.Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    TRACE(TL_PNP_TRACE,("AVCReqSubmitIrpSynch: IoCallDriver, Status:%x\n", Status));

    return Status;
} // AVCReqSubmitIrpSynch

VOID
DVIniDevExtStruct(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo    
    )
/*++

Routine Description:

    Initialiaze the device extension structure.

--*/
{
    ULONG            i;


    RtlZeroMemory( pDevExt, sizeof(DVCR_EXTENSION) );

    //
    // Cache what are in ConfigInfo in device extension
    //
    pDevExt->pBusDeviceObject      = pConfigInfo->PhysicalDeviceObject;      // IoCallDriver()
    pDevExt->pPhysicalDeviceObject = pConfigInfo->RealPhysicalDeviceObject;  // Used in PnP API

    //
    // Allow only one stream open at a time to avoid cyclic format
    //
    pDevExt->cndStrmOpen = 0;

    //
    // Serialize in the event of getting two consecutive SRB_OPEN_STREAMs
    //
    KeInitializeMutex( &pDevExt->hMutex, 0);  // Level 0 and in Signal state


    //
    // Initialize our pointer to stream extension
    //
    for (i=0; i<pDevExt->NumOfPins; i++) {
        pDevExt->paStrmExt[i] = NULL;  
    }

    //
    // Bus reset, surprise removal 
    //
    pDevExt->bDevRemoved = FALSE;

    pDevExt->PowerState = PowerDeviceD0;

    //
    // External device control (AV/C commands)
    // 
    KeInitializeSpinLock( &pDevExt->AVCCmdLock );  // To guard the count  

    pDevExt->cntCommandQueued   = 0; // Cmd that is completed its life cycle waiting to be read (most for RAW_AVC's Set/Read model)

    InitializeListHead(&pDevExt->AVCCmdList);      

    // Initialize the list of possible opcode values of the response
    // from a Transport State status or notify command. The first item
    // is the number of values that follow.
    ASSERT(sizeof(pDevExt->TransportModes) == 5);
    pDevExt->TransportModes[0] = 4;
    pDevExt->TransportModes[1] = 0xC1;
    pDevExt->TransportModes[2] = 0xC2;
    pDevExt->TransportModes[3] = 0xC3;
    pDevExt->TransportModes[4] = 0xC4;
}


NTSTATUS
AVCTapeGetDevInfo(
    IN PDVCR_EXTENSION  pDevExt,
    IN PAV_61883_REQUEST  pAVReq
    )
/*++

Routine Description:

    Issue AVC command to determine basic device information and cache them in the device extension.

--*/
{
    NTSTATUS    Status;
    PIRP        pIrp;
    BYTE                   bAvcBuf[MAX_FCP_PAYLOAD_SIZE];  // For issue AV/C command within this module
    PKSPROPERTY_EXTXPORT_S pXPrtProperty;                  // Point to bAvcBuf;
    KSPROPERTY_EXTDEVICE_S XDevProperty;   // External device property

    PAGED_CODE();


    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) {    
        ASSERT(pIrp && "IoAllocateIrp() failed!");
        return STATUS_INSUFFICIENT_RESOURCES;       
    }


    //
    // The input and output plug arrays are at the end of the device extension
    //
    pDevExt->pDevOutPlugs = (PAVC_DEV_PLUGS) ((PBYTE) pDevExt + sizeof(DVCR_EXTENSION));
    pDevExt->pDevInPlugs  = (PAVC_DEV_PLUGS) ((PBYTE) pDevExt + sizeof(DVCR_EXTENSION) + sizeof(AVC_DEV_PLUGS));


    //
    // Get unit's capabilities indirectly from 61883.sys
    //    Speed
    //

    Status = DVGetUnitCapabilities(pDevExt, pIrp, pAVReq);
    if(!NT_SUCCESS(Status)) {
         TRACE(TL_61883_ERROR,("Av61883_GetUnitCapabilities Failed %x\n", Status));
         IoFreeIrp(pIrp);
         return Status;
    }

    IoFreeIrp(pIrp);

    //
    //  Get current power state.  Turn it on if it's off.
    // 
    Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, DV_GET_POWER_STATE, (PVOID) &XDevProperty);
    TRACE(TL_PNP_WARNING,("GET_POWER_STATE: Status:%x; %s\n", Status, XDevProperty.u.PowerState == ED_POWER_ON ? "PowerON" : "PowerStandby"));

    if(STATUS_SUCCESS == Status) {
  
#define WAIT_SET_POWER         100 // Wait time when set power state; (msec)
#define MAX_SET_POWER_RETRIES    3

        if(    XDevProperty.u.PowerState == ED_POWER_STANDBY
            || XDevProperty.u.PowerState == ED_POWER_OFF
          ) {
            NTSTATUS StatusSetPower;
            LONG lRetries = 0;

            do {
                //
                // Some AVC device, such as D-VHS will return STATUS_DEVICE_DATA_ERROR when
                // this command is issue right after get power state command.  Such device
                // might be slow in response to the AVC command.  Even though wait is not
                // desirable, but it is the only way.
                //
                DVDelayExecutionThread(WAIT_SET_POWER);  // Wait a little
                StatusSetPower = DVIssueAVCCommand(pDevExt, AVC_CTYPE_CONTROL, DV_SET_POWER_STATE_ON, (PVOID) &XDevProperty);
                lRetries++;
                TRACE(TL_PNP_WARNING,("SET_POWER_STATE_ON: (%d) StatusSetPower:%x; Waited (%d msec).\n", lRetries, StatusSetPower, WAIT_SET_POWER));

            } while ( lRetries < MAX_SET_POWER_RETRIES
                   && (   StatusSetPower == STATUS_REQUEST_ABORTED 
                       || StatusSetPower == STATUS_DEVICE_DATA_ERROR
                       || StatusSetPower == STATUS_IO_TIMEOUT
                      ));

            TRACE(TL_PNP_WARNING,("SET_POWER_STATE_ON: StatusSetPower:%x; Retries:%d times\n\n", StatusSetPower, lRetries));
        } 
    } 

    //
    // Subunit_Info : VCR or camera
    //
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, DV_SUBUNIT_INFO, (PVOID) bAvcBuf);

    if(STATUS_SUCCESS == Status) {
        TRACE(TL_PNP_TRACE,("GetDevInfo: Status %x DV_SUBUNIT_INFO (%x %x %x %x)\n", 
            Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3]));
        //
        // Cache it. We assume max_subunit_ID is 0 and there is a max of 4 entries.
        //
        pDevExt->Subunit_Type[0] = bAvcBuf[0] & AVC_SUBTYPE_MASK;  
        pDevExt->Subunit_Type[1] = bAvcBuf[1] & AVC_SUBTYPE_MASK;
        pDevExt->Subunit_Type[2] = bAvcBuf[2] & AVC_SUBTYPE_MASK;
        pDevExt->Subunit_Type[3] = bAvcBuf[3] & AVC_SUBTYPE_MASK;

        // This is a tape subunit driver so one of the subunit must be a tape subunit.
        if(pDevExt->Subunit_Type[0] != AVC_DEVICE_TAPE_REC && pDevExt->Subunit_Type[1]) {                       
            TRACE(TL_PNP_ERROR,("GetDevInfo:Device not supported: %x, %x; (VCR %x, Camera %x)\n",
                pDevExt->Subunit_Type[0], pDevExt->Subunit_Type[1], AVC_DEVICE_TAPE_REC, AVC_DEVICE_CAMERA));            
            return STATUS_NOT_SUPPORTED;
        }
    } else {
        TRACE(TL_PNP_ERROR,("GetDevInfo: DV_SUBUNIT_INFO failed, Status %x\n", Status));

        if(STATUS_TIMEOUT == Status) {
            TRACE(TL_PNP_WARNING, ("GetDevInfo: Query DV_SUBUNIT_INFO failed. This could be the MediaDecoder box.\n"));
            // Do not fail this.  Making an exception.
        }

        // Has our device gone away?
        if (STATUS_IO_DEVICE_ERROR == Status || STATUS_REQUEST_ABORTED == Status)
            return Status;       

        pDevExt->Subunit_Type[0] = AVC_DEVICE_UNKNOWN;  
        pDevExt->Subunit_Type[1] = AVC_DEVICE_UNKNOWN;
        pDevExt->Subunit_Type[2] = AVC_DEVICE_UNKNOWN;
        pDevExt->Subunit_Type[3] = AVC_DEVICE_UNKNOWN;
    }


    //
    // Medium_Info: MediaPresent, MediaType, RecordInhibit
    //
    pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) bAvcBuf;
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, VCR_MEDIUM_INFO, (PVOID) pXPrtProperty);

    if(STATUS_SUCCESS == Status) {
        pDevExt->bHasTape  = pXPrtProperty->u.MediumInfo.MediaPresent;
        pDevExt->MediaType = pXPrtProperty->u.MediumInfo.MediaType;
        TRACE(TL_PNP_TRACE,("GetDevInfo: Status %x HasTape %s, VCR_MEDIUM_INFO (%x %x %x %x)\n", 
            Status, pDevExt->bHasTape ? "Yes" : "No", bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3]));
    } else {
        pDevExt->bHasTape = FALSE;
        TRACE(TL_PNP_ERROR,("GetDevInfo: VCR_MEDIUM_INFO failed, Status %x\n", Status));
        // Has our device gone away?
        if (STATUS_IO_DEVICE_ERROR == Status || STATUS_REQUEST_ABORTED == Status)
            return Status;
    }


    //
    // If this is a Panasonic AVC device, we will detect if it is a DVCPro format; 
    // This needs to be called before MediaFormat
    //
    if(pDevExt->ulVendorID == VENDORID_PANASONIC) {
        DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
        DVGetDevIsItDVCPro(pDevExt);
    }


    //
    // Medium format: NTSC or PAL
    //
    pDevExt->VideoFormatIndex = AVCSTRM_FORMAT_SDDV_NTSC;  // Default
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    if(!DVGetDevSignalFormat(
        pDevExt,
        KSPIN_DATAFLOW_OUT,
        0)) {
        ASSERT(FALSE && "IN/OUTPUT SIGNAL MODE is not supported; driver abort.");
        return STATUS_NOT_SUPPORTED;
    } else {
        if(pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_SDDV_NTSC && 
           pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_SDDV_PAL  &&
           pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_MPEG2TS
           ) {
            TRACE(TL_PNP_ERROR,("**** Format idx %d not supported by this driver ***\n", pDevExt->VideoFormatIndex));
            ASSERT(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_SDDV_NTSC || pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_SDDV_PAL);
            return STATUS_NOT_SUPPORTED;
        }
    }

    //
    // Mode of Operation: 0(Undetermined), Camera or VCR
    //
    DVDelayExecutionThread(DV_AVC_CMD_DELAY_INTER_CMD);
    DVGetDevModeOfOperation(
        pDevExt
        );

         
    return STATUS_SUCCESS; // Status;
}

#ifdef SUPPORT_NEW_AVC


HANDLE
AVCTapeGetPlugHandle(
    IN PDVCR_EXTENSION  pDevExt,
    IN ULONG  PlugNum,
    IN KSPIN_DATAFLOW DataFlow
    )
{
    NTSTATUS Status;
    PAV_61883_REQUEST  pAVReq;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    pAVReq = &pDevExt->AVReq;
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugHandle);
    pAVReq->GetPlugHandle.PlugNum = PlugNum;
    pAVReq->GetPlugHandle.hPlug   = 0;
    pAVReq->GetPlugHandle.Type    = DataFlow == KSPIN_DATAFLOW_OUT ? CMP_PlugOut : CMP_PlugIn;

    Status = DVSubmitIrpSynch(pDevExt, pDevExt->pIrpSyncCall, pAVReq);

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("GetPlugHandle: Failed:%x\n", Status));
        ASSERT(NT_SUCCESS(Status));
        pAVReq->GetPlugHandle.hPlug = NULL;
        return NULL;
    }
    else {
        TRACE(TL_61883_TRACE,("hPlug=%x\n", pAVReq->GetPlugHandle.hPlug));
    }

    return pAVReq->GetPlugHandle.hPlug;
}


NTSTATUS
AVCTapeGetPinInfo(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    Acquire pin information from avc.sys.  These information will be used to define data range and 
    then for doing data interssection.

--*/
{
    NTSTATUS Status;
    ULONG  i;
    ULONG PinId;  // Pin number

    Status = STATUS_SUCCESS;

    // Get pin count
    RtlZeroMemory(&pDevExt->AvcMultIrb, sizeof(AVC_MULTIFUNC_IRB));
    pDevExt->AvcMultIrb.Function = AVC_FUNCTION_GET_PIN_COUNT;
    Status = AVCReqSubmitIrpSynch(pDevExt->pBusDeviceObject, pDevExt->pIrpSyncCall, &pDevExt->AvcMultIrb);
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_STRM_ERROR,("GetPinCount Failed:%x\n", Status));
        goto GetPinInfoDone;
    } else {
        TRACE(TL_STRM_TRACE,("There are %d pins\n", pDevExt->AvcMultIrb.PinCount.PinCount));
        if(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_MPEG2TS) {
            if(pDevExt->AvcMultIrb.PinCount.PinCount > 1) {
                goto GetPinInfoDone;
            }
        } else {
            if(pDevExt->AvcMultIrb.PinCount.PinCount > 3) {
                goto GetPinInfoDone;
            }
        }
        pDevExt->PinCount = pDevExt->AvcMultIrb.PinCount.PinCount;  // <<<
    }

    // Get all pin descriptors
    for(i=0; i<pDevExt->PinCount; i++) {

        // Get a pin descriptor
        RtlZeroMemory(&pDevExt->AvcMultIrb, sizeof(AVC_MULTIFUNC_IRB));
        pDevExt->AvcMultIrb.Function = AVC_FUNCTION_GET_PIN_DESCRIPTOR;
        pDevExt->AvcMultIrb.PinDescriptor.PinId = i; 
        Status = AVCReqSubmitIrpSynch(pDevExt->pBusDeviceObject, pDevExt->pIrpSyncCall, &pDevExt->AvcMultIrb);
        if(!NT_SUCCESS(Status)) {
            TRACE(TL_PNP_ERROR,("GetPinDescriptor Failed:%x\n", Status));
            goto GetPinInfoDone;
        } else {
            // Copy the pDevExt->AvcMultIrb.PinDescriptor.PinDescriptor
            PinId = pDevExt->AvcMultIrb.PinDescriptor.PinId;
            // Anything else ?
        }

        // Get pre connection info
        RtlZeroMemory(&pDevExt->AvcMultIrb, sizeof(AVC_MULTIFUNC_IRB));
        pDevExt->AvcMultIrb.Function = AVC_FUNCTION_GET_CONNECTINFO;
        pDevExt->AvcMultIrb.PinDescriptor.PinId = PinId;
        Status = AVCReqSubmitIrpSynch(pDevExt->pBusDeviceObject, pDevExt->pIrpSyncCall, &pDevExt->AvcMultIrb);
        if(!NT_SUCCESS(Status)) {
            TRACE(TL_PNP_ERROR,("GetPinDescriptor Failed:%x\n", Status));
            goto GetPinInfoDone;
        } else {
            // Cache connectInfo
            if(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_MPEG2TS) {
                // Check 
                if(pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo.DataFlow == KSPIN_DATAFLOW_OUT) {
                    MPEG2TStreamOut.ConnectInfo = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                } else {
                    MPEG2TStreamIn.ConnectInfo  = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                }
            }
            else {
 
                if(pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo.DataFlow == KSPIN_DATAFLOW_OUT) {
                    DvcrNTSCiavStream.ConnectInfo = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                    DvcrPALiavStream.ConnectInfo  = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                } else if(pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo.DataFlow == KSPIN_DATAFLOW_IN) {
                    DvcrNTSCiavStreamIn.ConnectInfo = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                    DvcrPALiavStreamIn.ConnectInfo  = pDevExt->AvcMultIrb.PreConnectInfo.ConnectInfo;
                } else {
                    // Error; unexpected;
                    TRACE(TL_PNP_ERROR,("Unexpected index:%d for format:%d\n", i, pDevExt->VideoFormatIndex));
                    // goto GetPinInfoDone;
                }
            }
        }
    }


GetPinInfoDone:

    TRACE(TL_STRM_TRACE,("GetPinInfo exited with ST:%x\n", Status));

    return Status;
}

#endif // SUPPORT_NEW_AVC


NTSTATUS
AVCTapeInitialize(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    IN PAV_61883_REQUEST  pAVReq
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

--*/

{
    ULONG i;
    NTSTATUS         Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Initialize the device extension structure
    //
    DVIniDevExtStruct(
        pDevExt,
        pConfigInfo
        );

#ifdef READ_CUTOMIZE_REG_VALUES
    //
    // Get values from this device's own registry 
    //
    DVGetPropertyValuesFromRegistry(
        pDevExt
        );
#endif

    // Allocate an Irp for synchronize call
    pDevExt->pIrpSyncCall = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pDevExt->pIrpSyncCall) {
        ASSERT(pDevExt->pIrpSyncCall && "Allocate Irp failed.\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query device information at the laod time:
    //    Subunit
    //    Unit Info
    //    Mode of operation
    //    NTSC or PAL
    //    Speed
    //
    Status = 
        AVCTapeGetDevInfo(
            pDevExt,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_PNP_ERROR,("GetDevInfo failed %x\n", Status));
        ASSERT(NT_SUCCESS(Status) && "AVCTapeGetDevInfo failed");
        goto AbortLoading;
    }


    //
    // Get device's output plug handles and states
    //

    if(pDevExt->pDevOutPlugs->NumPlugs) {
        NTSTATUS StatusPlug;

        TRACE(TL_61883_WARNING,("%d oPCR(s); MaxDataRate:%d (%s)\n", 
            pDevExt->pDevOutPlugs->NumPlugs, 
            pDevExt->pDevOutPlugs->MaxDataRate,
            (pDevExt->pDevOutPlugs->MaxDataRate == CMP_SPEED_S100) ? "S100" :
            (pDevExt->pDevOutPlugs->MaxDataRate == CMP_SPEED_S200) ? "S200" :
            (pDevExt->pDevOutPlugs->MaxDataRate == CMP_SPEED_S400) ? "S400" : "Sxxx"
            ));

        for (i = 0; i < pDevExt->pDevOutPlugs->NumPlugs; i++) {
            if(NT_SUCCESS(
                StatusPlug = AVCDevGetDevPlug( 
                    pDevExt,
                    CMP_PlugOut,
                    i,
                    &pDevExt->pDevOutPlugs->DevPlug[i].hPlug
                    ))) {

                if(NT_SUCCESS(
                    AVCDevGetPlugState(
                    pDevExt,
                    pDevExt->pDevOutPlugs->DevPlug[i].hPlug,
                    &pDevExt->pDevOutPlugs->DevPlug[i].PlugState
                    ))) {
                } else {
                    // 
                    // This is an error if we were told to this many number of plugs;
                    // Set default plug states.
                    //   
                    pDevExt->pDevOutPlugs->DevPlug[i].PlugState.DataRate       = CMP_SPEED_S100;
                    pDevExt->pDevOutPlugs->DevPlug[i].PlugState.Payload        = PCR_PAYLOAD_MPEG2TS_DEF;
                    pDevExt->pDevOutPlugs->DevPlug[i].PlugState.BC_Connections = 0;
                    pDevExt->pDevOutPlugs->DevPlug[i].PlugState.PP_Connections = 0;
                }
            }
            else {
                //
                // If there is a plug, we should be able to get its handle!
                //
                TRACE(TL_61883_ERROR,("GetDevPlug oPlug[%d] failed %x\n", i, StatusPlug));
                ASSERT(NT_SUCCESS(StatusPlug) && "Failed to get oPCR handle from 61883!");
                break;
            }
        }
    }
    else {
        TRACE(TL_61883_WARNING,("Has no oPCR\n"));
    }

    //
    // Get device's input plug handles and states
    //
    if(pDevExt->pDevInPlugs->NumPlugs) {
        NTSTATUS StatusPlug;

        TRACE(TL_61883_WARNING,("%d iPCR(s); MaxDataRate:%d (%s)\n", 
            pDevExt->pDevInPlugs->NumPlugs, 
            pDevExt->pDevInPlugs->MaxDataRate,
            (pDevExt->pDevInPlugs->MaxDataRate == CMP_SPEED_S100) ? "S100" :
            (pDevExt->pDevInPlugs->MaxDataRate == CMP_SPEED_S200) ? "S200" :
            (pDevExt->pDevInPlugs->MaxDataRate == CMP_SPEED_S400) ? "S400" : "Sxxx"
            ));

        for (i = 0; i < pDevExt->pDevInPlugs->NumPlugs; i++) {
            if(NT_SUCCESS(
                StatusPlug = AVCDevGetDevPlug( 
                    pDevExt,
                    CMP_PlugIn,
                    i,
                    &pDevExt->pDevInPlugs->DevPlug[i].hPlug
                    ))) {

                if(NT_SUCCESS(
                    AVCDevGetPlugState(
                    pDevExt,
                    pDevExt->pDevInPlugs->DevPlug[i].hPlug,
                    &pDevExt->pDevInPlugs->DevPlug[i].PlugState
                    ))) {
                } else {
                    // 
                    // This is an error if we were told to this many number of plugs;
                    // Set default plug states.
                    //   
                    pDevExt->pDevInPlugs->DevPlug[i].PlugState.DataRate       = CMP_SPEED_S200;
                    pDevExt->pDevInPlugs->DevPlug[i].PlugState.Payload        = PCR_PAYLOAD_MPEG2TS_DEF;
                    pDevExt->pDevInPlugs->DevPlug[i].PlugState.BC_Connections = 0;
                    pDevExt->pDevInPlugs->DevPlug[i].PlugState.PP_Connections = 0;
                }
            }
            else {
                //
                // If there is a plug, we should be able to get its handle!
                //
                TRACE(TL_61883_ERROR,("GetDevPlug iPlug[%d] failed %x\n", i, StatusPlug));
                ASSERT(NT_SUCCESS(StatusPlug) && "Failed to get iPCR handle from 61883!");
                break;
            }
        }
    }
    else {
        TRACE(TL_61883_WARNING,("Has no iPCR\n"));
    }


#ifdef SUPPORT_LOCAL_PLUGS
    // Create a local output plug.
    pDevExt->OPCR.oPCR.OnLine     = 0;  // We are not online so we cannot be programmed.
    pDevExt->OPCR.oPCR.BCCCounter = 0;
    pDevExt->OPCR.oPCR.PPCCounter = 0;
    pDevExt->OPCR.oPCR.Channel    = 0;

    // Default to MPEG2TS data since MPEg2TS device, like D-VHS,  can initialize connection.
    if(pDevExt->pDevOutPlugs->NumPlugs) {
        //
        // Set PC's oPCR to match device's oPCR[0]
        //
        pDevExt->OPCR.oPCR.DataRate   = 
#if 0
            // Be conservative and use this to match its oPCR[0]'s setting..
            pDevExt->pDevOutPlugs->DevPlug[0].PlugState.DataRate;  // oPCR's data rate <= MPR's MaxDataRate
#else
            // Be aggreessive in conserving BWU, use MaxDataRate.
            pDevExt->pDevOutPlugs->MaxDataRate;                    // Use MPR's MaxDataRate?
#endif
        pDevExt->OPCR.oPCR.OverheadID = PCR_OVERHEAD_ID_MPEG2TS_DEF;  // Default since we do not get this as a plug state
        pDevExt->OPCR.oPCR.Payload    = pDevExt->pDevOutPlugs->DevPlug[0].PlugState.Payload;

    } else {
        pDevExt->OPCR.oPCR.DataRate   = CMP_SPEED_S200;               // Default of D-VHS
        pDevExt->OPCR.oPCR.OverheadID = PCR_OVERHEAD_ID_MPEG2TS_DEF;  // This is just default
        pDevExt->OPCR.oPCR.Payload    = PCR_PAYLOAD_MPEG2TS_DEF;      // Default
    }

    if(!AVCTapeCreateLocalPlug(
        pDevExt,
        &pDevExt->AVReq,
        CMP_PlugOut,
        &pDevExt->OPCR,
        &pDevExt->OutputPCRLocalNum,
        &pDevExt->hOutputPCRLocal)) {
        TRACE(TL_PNP_ERROR,("Create PC oPCR failed!\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }       
    
    // Create a local input plug.
    pDevExt->IPCR.iPCR.OnLine     = 0;  // We are not online so we cannot be programmed.
    pDevExt->IPCR.iPCR.BCCCounter = 0;
    pDevExt->IPCR.iPCR.PPCCounter = 0;
    pDevExt->IPCR.iPCR.Channel    = 0;

    if(!AVCTapeCreateLocalPlug(
        pDevExt,
        &pDevExt->AVReq,
        CMP_PlugIn,
        &pDevExt->IPCR,
        &pDevExt->InputPCRLocalNum,
        &pDevExt->hInputPCRLocal)) {

        TRACE(TL_PNP_ERROR,("Create PC iPCR failed!\n"));

        // Delete oPCR created
        if(!AVCTapeDeleteLocalPlug(
            pDevExt,
            &pDevExt->AVReq,
            &pDevExt->OutputPCRLocalNum,
            &pDevExt->hOutputPCRLocal)) {
            TRACE(TL_PNP_ERROR,("Delete PC oPCR failed!\n"));        
        } 

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    } 
#endif

#ifdef SUPPORT_NEW_AVC  // Initialize device

    //
    // Get plug handle of this device;
    // BUGBUG: For now, assume there is one pair of input and output plugs
    //
    pDevExt->hPlugLocalIn  = AVCTapeGetPlugHandle(pDevExt, 0, KSPIN_DATAFLOW_IN);
    pDevExt->hPlugLocalOut = AVCTapeGetPlugHandle(pDevExt, 0, KSPIN_DATAFLOW_OUT);


    //
    // Get Pin information for connection purpose
    //
    Status = AVCTapeGetPinInfo(pDevExt);
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_PNP_ERROR,("GetPinInfo failed %x\n", Status));
        ASSERT(NT_SUCCESS(Status) && "AVCTapeGetPinInfo failed");
        goto AbortLoading;
    }
#endif
    //
    // Can customize the FormatInfoTable here!
    //
    switch(pDevExt->VideoFormatIndex) {
    case AVCSTRM_FORMAT_SDDV_NTSC:
    case AVCSTRM_FORMAT_SDDV_PAL:
    case AVCSTRM_FORMAT_HDDV_NTSC:
    case AVCSTRM_FORMAT_HDDV_PAL:
    case AVCSTRM_FORMAT_SDLDV_NTSC:
    case AVCSTRM_FORMAT_SDLDV_PAL:
        pDevExt->NumOfPins = DV_STREAM_COUNT;

        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.DBS = CIP_DBS_SDDV;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.FN  = CIP_FN_DV;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.QPC = CIP_QPC_DV;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.SPH = CIP_SPH_DV;

        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.FMT    = CIP_FMT_DV;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.STYPE  = CIP_STYPE_DV;
        break;

    case AVCSTRM_FORMAT_MPEG2TS:
        pDevExt->NumOfPins = MPEG_STREAM_COUNT;

        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.DBS = CIP_DBS_MPEG;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.FN  = CIP_FN_MPEG;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.QPC = CIP_QPC_MPEG;
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr1.SPH = CIP_SPH_MPEG;

        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.FMT   = CIP_FMT_MPEG;
        // AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.F5060_OR_TSF = CIP_60_FIELDS;
        break;
    default:
        Status = STATUS_NOT_SUPPORTED;
        goto AbortLoading;
        break;
    }

    switch(pDevExt->VideoFormatIndex) {
    case AVCSTRM_FORMAT_SDDV_NTSC:
    case AVCSTRM_FORMAT_HDDV_NTSC:
    case AVCSTRM_FORMAT_SDLDV_NTSC:
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.F5060_OR_TSF = CIP_60_FIELDS;
        break;
    case AVCSTRM_FORMAT_SDDV_PAL:
    case AVCSTRM_FORMAT_HDDV_PAL:
    case AVCSTRM_FORMAT_SDLDV_PAL:
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].cipHdr2.F5060_OR_TSF = CIP_50_FIELDS;
        break;
    }


    //
    // Note: Must do ExAllocatePool after DVIniDevExtStruct() since ->pStreamInfoObject is initialized.
    // Since the format that this driver support is known when this driver is known,'
    // the stream information table need to be custonmized.  Make a copy and customized it.
    //

    //
    // Set the size of the stream inforamtion structure that we returned in SRB_GET_STREAM_INFO
    //
        
    pDevExt->pStreamInfoObject = (STREAM_INFO_AND_OBJ *) 
        ExAllocatePool(NonPagedPool, sizeof(STREAM_INFO_AND_OBJ) * pDevExt->NumOfPins);

    if(!pDevExt->pStreamInfoObject) {
        ASSERT(pDevExt->pStreamInfoObject && "STATUS_INSUFFICIENT_RESOURCES");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }
        
    pConfigInfo->StreamDescriptorSize = 
        (pDevExt->NumOfPins * sizeof(HW_STREAM_INFORMATION)) +      // number of stream descriptors
        sizeof(HW_STREAM_HEADER);                                   // and 1 stream header

    TRACE(TL_PNP_TRACE,("pStreamInfoObject:%x; StreamDescriptorSize:%d\n", pDevExt->pStreamInfoObject, pConfigInfo->StreamDescriptorSize ));

    // Make a copy of the default stream information
    for(i = 0; i < pDevExt->NumOfPins; i++ ) {
        if(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_MPEG2TS)
           pDevExt->pStreamInfoObject[i] = MPEGStreams[i];
        else
           pDevExt->pStreamInfoObject[i] = DVStreams[i];
    }

    switch(pDevExt->VideoFormatIndex) {
    case AVCSTRM_FORMAT_SDDV_NTSC:
    case AVCSTRM_FORMAT_SDDV_PAL:
        // Set AUDIO AUX to reflect: NTSC/PAL, consumer DV or DVCPRO
        if(pDevExt->bDVCPro) {
            // Note: there is no DVInfo in VideoInfoHeader but there is for the iAV streams.
            DvcrPALiavStream.DVVideoInfo.dwDVAAuxSrc  = PAL_DVAAuxSrc_DVCPRO;
            DvcrNTSCiavStream.DVVideoInfo.dwDVAAuxSrc = NTSC_DVAAuxSrc_DVCPRO;
        } else {
            DvcrPALiavStream.DVVideoInfo.dwDVAAuxSrc  = PAL_DVAAuxSrc;
            DvcrNTSCiavStream.DVVideoInfo.dwDVAAuxSrc = NTSC_DVAAuxSrc;
        }
    }

    TRACE(TL_PNP_WARNING,("#### %s:%s:%s PhyDO %x, BusDO %x, DevExt %x, FrmSz %d; StrmIf %d\n", 
        pDevExt->ulDevType == ED_DEVTYPE_VCR ? "DVCR" : pDevExt->ulDevType == ED_DEVTYPE_CAMERA ? "Camera" : "Tuner?",
        pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_SDDV_NTSC ? "SD:NTSC" : pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_SDDV_PAL ? "PAL" : "MPEG_TS?",
        (pDevExt->ulDevType == ED_DEVTYPE_VCR && pDevExt->pDevInPlugs->NumPlugs > 0) ? "CanRec" : "NotRec",
        pDevExt->pPhysicalDeviceObject, 
        pDevExt->pBusDeviceObject, 
        pDevExt,  
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize,
        pConfigInfo->StreamDescriptorSize
        ));
    
    return STATUS_SUCCESS;

AbortLoading:

    DvFreeTextualString(pDevExt, &pDevExt->UnitIDs);
    return Status;
}


NTSTATUS
AVCTapeInitializeCompleted(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

--*/

{
    PAGED_CODE();


#ifdef SUPPORT_ACCESS_DEVICE_INTERFACE
    //
    // Access to the device's interface section
    //
    DVAccessDeviceInterface(pDevExt, NUMBER_OF_DV_CATEGORIES, DVCategories);
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
AVCTapeGetStreamInfo(
    IN PDVCR_EXTENSION        pDevExt,
    IN ULONG                  ulBytesToTransfer, 
    IN PHW_STREAM_HEADER      pStreamHeader,       
    IN PHW_STREAM_INFORMATION pStreamInfo
    )

/*++

Routine Description:

    Returns the information of all streams that are supported by the driver

--*/

{
    ULONG i;

    PAGED_CODE();


    //
    // Make sure we have enough space to return our stream informations
    //
    if(ulBytesToTransfer < sizeof (HW_STREAM_HEADER) + sizeof(HW_STREAM_INFORMATION) * pDevExt->NumOfPins ) {
        TRACE(TL_PNP_ERROR,("GetStrmInfo: ulBytesToTransfer %d ?= %d\n",  
            ulBytesToTransfer, sizeof(HW_STREAM_HEADER) + sizeof(HW_STREAM_INFORMATION) * pDevExt->NumOfPins ));
        ASSERT(ulBytesToTransfer >= sizeof(HW_STREAM_HEADER) + sizeof(HW_STREAM_INFORMATION) * pDevExt->NumOfPins );

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize stream header:
    //   Device properties
    //   Streams
    //

    RtlZeroMemory(pStreamHeader, sizeof(HW_STREAM_HEADER));

    pStreamHeader->NumberOfStreams           = pDevExt->NumOfPins;
    pStreamHeader->SizeOfHwStreamInformation = sizeof(HW_STREAM_INFORMATION);

    pStreamHeader->NumDevPropArrayEntries    = NUMBER_VIDEO_DEVICE_PROPERTIES;
    pStreamHeader->DevicePropertiesArray     = (PKSPROPERTY_SET) VideoDeviceProperties;

    pStreamHeader->NumDevEventArrayEntries   = NUMBER_VIDEO_DEVICE_EVENTS;
    pStreamHeader->DeviceEventsArray         = (PKSEVENT_SET) VideoDeviceEvents;


    TRACE(TL_PNP_TRACE,("GetStreamInfo: StreamPropEntries %d, DevicePropEntries %d\n",
        pStreamHeader->NumberOfStreams, pStreamHeader->NumDevPropArrayEntries));


    //
    // Initialize the stream structure.
    //
    ASSERT(pDevExt->pStreamInfoObject);
    for( i = 0; i < pDevExt->NumOfPins; i++ )
        *pStreamInfo++ = pDevExt->pStreamInfoObject[i].hwStreamInfo;

    //
    //
    // store a pointer to the topology for the device
    //        
    if(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_MPEG2TS)
        pStreamHeader->Topology = &MPEG2TSTopology;
    else
        pStreamHeader->Topology = &DVTopology;



    return STATUS_SUCCESS;
}


BOOL 
AVCTapeVerifyDataFormat(
    IN  ULONG  NumOfPins,
    PKSDATAFORMAT  pKSDataFormatToVerify, 
    ULONG          StreamNumber,
    ULONG          ulSupportedFrameSize,
    STREAM_INFO_AND_OBJ * pStreamInfoObject 
    )
/*++

Routine Description:

    Checks the validity of a format request by walking through the array of 
    supported KSDATA_RANGEs for a given stream.

Arguments:

     pKSDataFormat - pointer of a KS_DATAFORMAT_VIDEOINFOHEADER structure.
     StreamNumber - index of the stream being queried / opened.

Return Value:

     TRUE if the format is supported
     FALSE if the format cannot be suppored

--*/
{
    PKSDATAFORMAT  *pAvailableFormats;
    int            NumberOfFormatArrayEntries;
    int            j;
     
    PAGED_CODE();

    //
    // Make sure the stream index is valid
    //
    if(StreamNumber >= NumOfPins) {
        return FALSE;
    }

    //
    // How many formats does this data range support?
    //
    NumberOfFormatArrayEntries = pStreamInfoObject[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //
    pAvailableFormats = pStreamInfoObject[StreamNumber].hwStreamInfo.StreamFormatsArray;
    
    
    //
    // Walk the array, searching for a match
    //
    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {
        
        if (!DVCmpGUIDsAndFormatSize(
                 pKSDataFormatToVerify, 
                 *pAvailableFormats,
                 FALSE /* CompareFormatSize */ )) {
            continue;
        }

        //
        // Additional verification test
        //
        if(IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
            // Make sure 
            if( ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage !=
                ulSupportedFrameSize) {
                TRACE(TL_STRM_TRACE,("VIDEOINFO: biSizeToVerify %d != Supported %d\n",
                    ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage,
                    ulSupportedFrameSize
                    ));
                continue;
            } else {
                TRACE(TL_STRM_TRACE,("VIDOINFO: **** biSizeToVerify %d == Supported %d\n",
                    ((PKS_DATAFORMAT_VIDEOINFOHEADER)pKSDataFormatToVerify)->VideoInfoHeader.bmiHeader.biSizeImage,
                    ulSupportedFrameSize
                    ));
            }
        } else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier, &KSDATAFORMAT_SPECIFIER_DVINFO)) {

            // Test 50/60 bit
            if((((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc & MASK_AUX_50_60_BIT) != 
               (((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc    & MASK_AUX_50_60_BIT)  ||
               (((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc & MASK_AUX_50_60_BIT) != 
               (((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc    & MASK_AUX_50_60_BIT) ) {

                TRACE(TL_STRM_TRACE,("DVINFO VerifyFormat failed: ASrc: %x!=%x (MSDV);or VSrc: %x!=%x\n",                    
                 ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc, 
                    ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc,
                 ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc,
                    ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc
                     ));

                continue;
            }

            TRACE(TL_STRM_TRACE,("DVINFO: dwDVAAuxCtl %x, Supported %x\n", 
                ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVAAuxSrc,
                ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVAAuxSrc
                ));

            TRACE(TL_STRM_TRACE,("DVINFO: dwDVVAuxSrc %x, Supported %x\n", 
                ((PKS_DATARANGE_DVVIDEO) pKSDataFormatToVerify)->DVVideoInfo.dwDVVAuxSrc,
                ((PKS_DATARANGE_DVVIDEO) *pAvailableFormats)->DVVideoInfo.dwDVVAuxSrc
                ));

        }
        else if (IsEqualGUID (&pKSDataFormatToVerify->SubFormat, &KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)  ) {
            TRACE(TL_STRM_TRACE,("VerifyFormat: MPEG2 subformat\n"));
        }
        else if (IsEqualGUID (&pKSDataFormatToVerify->SubFormat, &KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE) 
            && pKSDataFormatToVerify->FormatSize >= (sizeof(KSDATARANGE)+sizeof(MPEG2_TRANSPORT_STRIDE)) ) {
            //
            // Verify the STRIDE structure
            //
            if(  ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwOffset       != MPEG2TS_STRIDE_OFFSET 
              || ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwPacketLength != MPEG2TS_STRIDE_PACKET_LEN 
              || ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwStride       != MPEG2TS_STRIDE_STRIDE_LEN 
              ) {
                TRACE(TL_STRM_ERROR,("VerifyDataFormat: Invalid STRIDE parameters: dwOffset:%d; dwPacketLength:%d; dwStride:%d\n",
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwOffset,
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwPacketLength,
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pKSDataFormatToVerify)->Stride.dwStride
                    ));
                    continue;
            }
            TRACE(TL_STRM_TRACE,("VerifyFormat: MPEG2 stride subformat\n"));
        }
        else {
            continue;
        }


        return TRUE;
    }

    return FALSE;
} 




NTSTATUS
AVCTapeGetDataIntersection(
    IN  ULONG  NumOfPins,
    IN  ULONG          ulStreamNumber,
    IN  PKSDATARANGE   pDataRange,
    OUT PVOID          pDataFormatBuffer,
    IN  ULONG          ulSizeOfDataFormatBuffer,
    IN  ULONG          ulSupportedFrameSize,
    OUT ULONG          *pulActualBytesTransferred,
    STREAM_INFO_AND_OBJ * pStreamInfoObject
#ifdef SUPPORT_NEW_AVC
    ,
    HANDLE  hPlugLocalOut,
    HANDLE  hPlugLocalIn
#endif
    )
/*++

Routine Description:

    Called to get a DATAFORMAT from a DATARANGE.

--*/
{
    BOOL                        bMatchFound = FALSE;
    ULONG                       ulFormatSize;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;
#ifdef SUPPORT_NEW_AVC
    AVCPRECONNECTINFO * pPreConnectInfo;
    AVCCONNECTINFO * pConnectInfo;
#endif

    PAGED_CODE();

    
    //
    // Check that the stream number is valid
    //
    if(ulStreamNumber >= NumOfPins) {
        TRACE(TL_STRM_ERROR,("FormatFromRange: ulStreamNumber %d >= NumOfPins %d\n", ulStreamNumber, NumOfPins)); 
        ASSERT(ulStreamNumber < NumOfPins && "Invalid stream index");
        return STATUS_NOT_SUPPORTED;
    }


    // Number of format this stream supports
    ulNumberOfFormatArrayEntries = pStreamInfoObject[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //
    pAvailableFormats = pStreamInfoObject[ulStreamNumber].hwStreamInfo.StreamFormatsArray;


    //
    // Walk the formats supported by the stream searching for a match
    // Note: DataIntersection is really enumerating supported MediaType only!
    //       SO matter compare format is NTSC or PAL, we need suceeded both;
    //       however, we will copy back only the format is currently supported (NTSC or PAL).
    //
    for(j = 0; j < ulNumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if(!DVCmpGUIDsAndFormatSize(pDataRange, *pAvailableFormats, TRUE)) {
            TRACE(TL_STRM_TRACE,("CmpGUIDsAndFormatSize failed! FormatSize:%d?=%d\n", pDataRange->FormatSize, (*pAvailableFormats)->FormatSize));
            continue;
        }

        //
        // SUBTYPE_DVSD has a fix sample size; 
        //
        if(   IsEqualGUID (&pDataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_DVSD)  
           && (*pAvailableFormats)->SampleSize != ulSupportedFrameSize) {
            TRACE(TL_STRM_TRACE,("_SUBTYPE_DVSD: StrmNum %d, %d of %d formats, SizeToVerify %d *!=* SupportedSampleSize %d\n", 
                ulStreamNumber,
                j+1, ulNumberOfFormatArrayEntries, 
                (*pAvailableFormats)->SampleSize,  
                ulSupportedFrameSize));
            continue;
        }

         
        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if(IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
         
            PKS_DATARANGE_VIDEO pDataRangeVideoToVerify = (PKS_DATARANGE_VIDEO) pDataRange;
            PKS_DATARANGE_VIDEO pDataRangeVideo         = (PKS_DATARANGE_VIDEO) *pAvailableFormats;

#if 0
            //
            // Check that the other fields match
            //
            if ((pDataRangeVideoToVerify->bFixedSizeSamples      != pDataRangeVideo->bFixedSizeSamples)
                || (pDataRangeVideoToVerify->bTemporalCompression   != pDataRangeVideo->bTemporalCompression) 
                || (pDataRangeVideoToVerify->StreamDescriptionFlags != pDataRangeVideo->StreamDescriptionFlags) 
                || (pDataRangeVideoToVerify->MemoryAllocationFlags  != pDataRangeVideo->MemoryAllocationFlags) 
#ifdef COMPARE_CONFIG_CAP
                || (RtlCompareMemory (&pDataRangeVideoToVerify->ConfigCaps,
                    &pDataRangeVideo->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))
#endif
                    )   {

                TRACE(TL_STRM_TRACE,("FormatFromRange: *!=* bFixSizeSample (%d %d) (%d %d) (%d %d) (%x %x)\n",
                    pDataRangeVideoToVerify->bFixedSizeSamples,      pDataRangeVideo->bFixedSizeSamples,
                    pDataRangeVideoToVerify->bTemporalCompression ,  pDataRangeVideo->bTemporalCompression,
                    pDataRangeVideoToVerify->StreamDescriptionFlags, pDataRangeVideo->StreamDescriptionFlags,
                    pDataRangeVideoToVerify->ConfigCaps.VideoStandard, pDataRangeVideo->ConfigCaps.VideoStandard 
                    ));
                    
                continue;
            } else {
                TRACE(TL_STRM_TRACE,("FormatFromRange: == bFixSizeSample (%d %d) (%d %d) (%d %d) (%x %x)\n",
                    pDataRangeVideoToVerify->bFixedSizeSamples,      pDataRangeVideo->bFixedSizeSamples,
                    pDataRangeVideoToVerify->bTemporalCompression ,  pDataRangeVideo->bTemporalCompression,
                    pDataRangeVideoToVerify->StreamDescriptionFlags, pDataRangeVideo->StreamDescriptionFlags,
                    pDataRangeVideoToVerify->ConfigCaps.VideoStandard, pDataRangeVideo->ConfigCaps.VideoStandard 
                    ));
            }
           
#endif
            bMatchFound = TRUE;            
            ulFormatSize = sizeof (KSDATAFORMAT) + 
                KS_SIZE_VIDEOHEADER (&pDataRangeVideo->VideoInfoHeader);
            
            if(ulSizeOfDataFormatBuffer == 0) {

                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;

                return STATUS_BUFFER_OVERFLOW;
            }


            // Caller wants the full data format
            if(ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_TRACE,("VIDEOINFO: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n",ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            // KS_DATAFORMAT_VIDEOINFOHEADER
            //    KSDATAFORMAT            DataFormat;
            //    KS_VIDEOINFOHEADER      VideoInfoHeader;                
            RtlCopyMemory(
                &((PKS_DATAFORMAT_VIDEOINFOHEADER)pDataFormatBuffer)->DataFormat,
                &pDataRangeVideo->DataRange, 
                sizeof (KSDATAFORMAT));

            // This size is differnt from our data range size which also contains ConfigCap
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

            RtlCopyMemory(
                &((PKS_DATAFORMAT_VIDEOINFOHEADER) pDataFormatBuffer)->VideoInfoHeader,
                &pDataRangeVideo->VideoInfoHeader,  
                KS_SIZE_VIDEOHEADER (&pDataRangeVideo->VideoInfoHeader));

            TRACE(TL_STRM_TRACE,("FormatFromRange: Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d, biSizeImage.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer,
                ((PKS_DATAFORMAT_VIDEOINFOHEADER) pDataFormatBuffer)->VideoInfoHeader.bmiHeader.biSizeImage));

            return STATUS_SUCCESS;

        } else if (IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_DVINFO)) {
            // -------------------------------------------------------------------
            // Specifier FORMAT_DVInfo for KS_DATARANGE_DVVIDEO
            // -------------------------------------------------------------------

            // MATCH FOUND!
            bMatchFound = TRUE;            

            ulFormatSize = sizeof(KS_DATARANGE_DVVIDEO);

            if(ulSizeOfDataFormatBuffer == 0) {
                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;
                return STATUS_BUFFER_OVERFLOW;
            }
            
            // Caller wants the full data format
            if (ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("DVINFO: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n", ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            RtlCopyMemory(
                pDataFormatBuffer,
                *pAvailableFormats, 
                (*pAvailableFormats)->FormatSize); 
            
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

#ifdef SUPPORT_NEW_AVC  // Data intersection; return hPlug if flag is set
            pPreConnectInfo = &(((KS_DATARANGE_DV_AVC *) *pAvailableFormats)->ConnectInfo);
            pConnectInfo    = &(((KS_DATAFORMAT_DV_AVC *) pDataFormatBuffer)->ConnectInfo);

            if(pPreConnectInfo->Flags & (KSPIN_FLAG_AVC_PCRONLY | KSPIN_FLAG_AVC_FIXEDPCR)) {
                // Need to return the plug handle
                pConnectInfo->hPlug = \
                    (pPreConnectInfo->DataFlow == KSPIN_DATAFLOW_OUT) ? hPlugLocalOut : hPlugLocalIn;        
            } else {
                // Choose any that is available
                // Set to 0 for now.
                pConnectInfo->hPlug = NULL;
            }

#if DBG
            TRACE(TL_STRM_TRACE,("DVINFO: pPreConnectInfo:%x; pConnectInfo:%x\n", pPreConnectInfo, pConnectInfo));
            if(TapeDebugLevel >= 2) {
                ASSERT(FALSE && "Check ConnectInfo!");
            }
#endif
#endif
            TRACE(TL_STRM_TRACE,("FormatFromRange: Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer));

            return STATUS_SUCCESS;

        } else if (IsEqualGUID (&pDataRange->SubFormat, &KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE) ){


            // -------------------------------------------------------------------
            // Compare subformat since it is unique
            // Subformat STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE
            // -------------------------------------------------------------------

#if 0       // Not enforced.     
            // Only for a certain specifier
            if(!IsEqualGUID (&pDataRange->Specifier, &KSDATAFORMAT_SPECIFIER_61883_4)) {
                TRACE(TL_STRM_TRACE,("SubFormat KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE but Specifier is not STATIC_KSDATAFORMAT_SPECIFIER_61883_4\n"));
                continue;
            }
#endif

            // Sample size must match!
            if((*pAvailableFormats)->SampleSize != pDataRange->SampleSize) {
                TRACE(TL_STRM_TRACE,("SampleSize(MPEG2_TRANSPORT_STRIDE): Availabel:%d != Range:%d\n", (*pAvailableFormats)->SampleSize, pDataRange->SampleSize));
                continue;
            }

            // MATCH FOUND!
            bMatchFound = TRUE;            

#ifdef SUPPORT_NEW_AVC
            ulFormatSize = sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC);                               
#else
            ulFormatSize = sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC) - sizeof(AVCPRECONNECTINFO);     // FormatSize; exclude AVCPRECONNECTINFO
#endif
            if(ulSizeOfDataFormatBuffer == 0) {
                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;
                return STATUS_BUFFER_OVERFLOW;
            }
            
            // Caller wants the full data format
            if (ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("MPEG2_TRANSPORT_STRIDE: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n", ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            //
            // Verify the STRIDE structure
            //
            if(  ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwOffset       != MPEG2TS_STRIDE_OFFSET 
              || ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwPacketLength != MPEG2TS_STRIDE_PACKET_LEN 
              || ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwStride       != MPEG2TS_STRIDE_STRIDE_LEN 
              ) {
                TRACE(TL_PNP_ERROR,("AVCTapeGetDataIntersection:Invalid STRIDE parameters: dwOffset:%d; dwPacketLength:%d; dwStride:%d\n",
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwOffset,
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwPacketLength,
                    ((KS_DATARANGE_MPEG2TS_STRIDE_AVC *) pDataRange)->Stride.dwStride
                    ));
                    return STATUS_INVALID_PARAMETER;
            }


            RtlCopyMemory(pDataFormatBuffer, *pAvailableFormats, (*pAvailableFormats)->FormatSize);             
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

#ifdef SUPPORT_NEW_AVC  // Data intersection; return hPlug if flag is set

            pPreConnectInfo = &(((KS_DATARANGE_MPEG2TS_AVC *) *pAvailableFormats)->ConnectInfo);
            pConnectInfo    = &(((KS_DATAFORMAT_MPEG2TS_AVC *) pDataFormatBuffer)->ConnectInfo);


            if(pPreConnectInfo->Flags & (KSPIN_FLAG_AVC_PCRONLY | KSPIN_FLAG_AVC_FIXEDPCR)) {
                // Need to return the plug handle
                pConnectInfo->hPlug = \
                    (pPreConnectInfo->DataFlow == KSPIN_DATAFLOW_OUT) ? hPlugLocalOut : hPlugLocalIn;        
            } else {
                // Choose any that is available
                // Set to 0 for now.
                pConnectInfo->hPlug = NULL;
            }
#if DBG
            TRACE(TL_STRM_TRACE,("MPEG2TS: pPreConnectInfo:%x; pConnectInfo:%x\n", pPreConnectInfo, pConnectInfo));
            ASSERT(FALSE && "Check ConnectInfo!");            
#endif
#endif

            TRACE(TL_STRM_TRACE,("FormatFromRange:(MPEG2TS_STRIDE) Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer));

            return STATUS_SUCCESS;

        } else if (IsEqualGUID (&pDataRange->SubFormat, &KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)) {

            // -------------------------------------------------------------------
            // Compare subformat since it is unique
            // Subformat STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT
            // -------------------------------------------------------------------

            // Sample size must match!
            if((*pAvailableFormats)->SampleSize != pDataRange->SampleSize) {
                TRACE(TL_STRM_TRACE,("SampleSize(MPEG2_TRANSPORT): Availabel:%d != Range:%d\n", (*pAvailableFormats)->SampleSize, pDataRange->SampleSize));
                continue;
            }

            // MATCH FOUND!
            bMatchFound = TRUE;            

#ifdef SUPPORT_NEW_AVC
            ulFormatSize = sizeof(KS_DATARANGE_MPEG2TS_AVC);                               
#else
            ulFormatSize = sizeof(KS_DATARANGE_MPEG2TS_AVC) - sizeof(AVCPRECONNECTINFO);     // FormatSize; exclude AVCPRECONNECTINFO
#endif
            if(ulSizeOfDataFormatBuffer == 0) {
                // We actually have not returned this much data,
                // this "size" will be used by Ksproxy to send down 
                // a buffer of that size in next query.
                *pulActualBytesTransferred = ulFormatSize;
                return STATUS_BUFFER_OVERFLOW;
            }
            
            // Caller wants the full data format
            if (ulSizeOfDataFormatBuffer < ulFormatSize) {
                TRACE(TL_STRM_ERROR,("MPEG2_TRANSPORT: StreamNum %d, SizeOfDataFormatBuffer %d < ulFormatSize %d\n", ulStreamNumber, ulSizeOfDataFormatBuffer, ulFormatSize));
                return STATUS_BUFFER_TOO_SMALL;
            }

            RtlCopyMemory(pDataFormatBuffer, *pAvailableFormats, (*pAvailableFormats)->FormatSize);             
            ((PKSDATAFORMAT)pDataFormatBuffer)->FormatSize = ulFormatSize;
            *pulActualBytesTransferred = ulFormatSize;

#ifdef SUPPORT_NEW_AVC  // Data intersection; return hPlug if flag is set

            pPreConnectInfo = &(((KS_DATARANGE_MPEG2TS_AVC *) *pAvailableFormats)->ConnectInfo);
            pConnectInfo    = &(((KS_DATAFORMAT_MPEG2TS_AVC *) pDataFormatBuffer)->ConnectInfo);


            if(pPreConnectInfo->Flags & (KSPIN_FLAG_AVC_PCRONLY | KSPIN_FLAG_AVC_FIXEDPCR)) {
                // Need to return the plug handle
                pConnectInfo->hPlug = \
                    (pPreConnectInfo->DataFlow == KSPIN_DATAFLOW_OUT) ? hPlugLocalOut : hPlugLocalIn;        
            } else {
                // Choose any that is available
                // Set to 0 for now.
                pConnectInfo->hPlug = NULL;
            }
#if DBG
            TRACE(TL_STRM_TRACE,("MPEG2TS: pPreConnectInfo:%x; pConnectInfo:%x\n", pPreConnectInfo, pConnectInfo));
            ASSERT(FALSE && "Check ConnectInfo!");            
#endif
#endif

            TRACE(TL_STRM_TRACE,("FormatFromRange: (MPEG2TS) Matched, StrmNum %d, FormatSize %d, CopySize %d; FormatBufferSize %d.\n", 
                ulStreamNumber, (*pAvailableFormats)->FormatSize, ulFormatSize, ulSizeOfDataFormatBuffer));

            return STATUS_SUCCESS;

        } 

    } // End of loop on all formats for this stream
    
    if(!bMatchFound) {

        TRACE(TL_STRM_TRACE,("FormatFromRange: No Match! StrmNum %d, pDataRange %x\n", ulStreamNumber, pDataRange));
    }

    return STATUS_NO_MATCH;         
}



VOID 
AVCTapeIniStrmExt(
    PHW_STREAM_OBJECT  pStrmObject,
    PSTREAMEX          pStrmExt,
    PDVCR_EXTENSION    pDevExt,
    PSTREAM_INFO_AND_OBJ   pStream
    )
/*++

Routine Description:

    Initialize stream extension strcuture.

--*/
{

    PAGED_CODE();

    RtlZeroMemory( pStrmExt, sizeof(STREAMEX) );

    pStrmExt->bEOStream     = TRUE;       // Stream has not started yet!

    pStrmExt->pStrmObject   = pStrmObject;
    pStrmExt->StreamState   = KSSTATE_STOP;
    pStrmExt->pDevExt       = pDevExt;

    pStrmExt->hMyClock      = 0;
    pStrmExt->hMasterClock  = 0;
    pStrmExt->hClock        = 0;


//
// Aplly to both IN/OUT data flow
//
    //
    // Init isoch resources
    //
    pStrmExt->CurrentStreamTime = 0;  

    pStrmExt->cntSRBReceived    = 0;  // Total number of SRB_READ/WRITE_DATA
    pStrmExt->cntDataSubmitted  = 0;  // Number of pending data buffer

    pStrmExt->cntSRBCancelled   = 0;  // number of SRB_READ/WRITE_DATA cancelled
    

    pStrmExt->FramesProcessed = 0;
    pStrmExt->PictureNumber   = 0;
    pStrmExt->FramesDropped   = 0;   

    //
    // Subcode data that can be extract from a DV frame
    //

    pStrmExt->AbsTrackNumber = 0;
    pStrmExt->bATNUpdated    = FALSE;

    pStrmExt->Timecode[0] = 0;
    pStrmExt->Timecode[1] = 0;
    pStrmExt->Timecode[2] = 0;
    pStrmExt->Timecode[3] = 0;
    pStrmExt->bTimecodeUpdated = FALSE;


    //
    // Work item variables use to cancel all SRBs
    //
    pStrmExt->lCancelStateWorkItem = 0;
    pStrmExt->AbortInProgress = FALSE;

#ifdef USE_WDM110
    pStrmExt->pIoWorkItem = NULL;
#endif
   
    //
    // Cache the pointer
    // What in DVStreams[] are READONLY
    //
    pStrmExt->pStrmInfo = &pStream->hwStreamInfo;

    pStrmObject->ReceiveDataPacket    = (PVOID) pStream->hwStreamObject.ReceiveDataPacket;
    pStrmObject->ReceiveControlPacket = (PVOID) pStream->hwStreamObject.ReceiveControlPacket;
    pStrmObject->Dma                          = pStream->hwStreamObject.Dma;
    pStrmObject->Pio                          = pStream->hwStreamObject.Pio;
    pStrmObject->StreamHeaderWorkspace        = pStream->hwStreamObject.StreamHeaderWorkspace;
    pStrmObject->StreamHeaderMediaSpecific    = pStream->hwStreamObject.StreamHeaderMediaSpecific;
    pStrmObject->HwClockObject                = pStream->hwStreamObject.HwClockObject;
    pStrmObject->Allocator                    = pStream->hwStreamObject.Allocator;
    pStrmObject->HwEventRoutine               = pStream->hwStreamObject.HwEventRoutine;

}



NTSTATUS
AVCTapeOpenStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    )

/*++

Routine Description:

    Verify the OpenFormat and then allocate PC resource needed for this stream.
    The isoch resource, if needed, is allocated when streaming is transition to PAUSE state.

--*/

{
    NTSTATUS         Status = STATUS_SUCCESS;
    PSTREAMEX        pStrmExt;
    PDVCR_EXTENSION  pDevExt;
    ULONG            idxStreamNumber;
    KSPIN_DATAFLOW   DataFlow;
    PIRP             pIrp = NULL;
    FMT_INDEX        VideoFormatIndexLast;  // Last format index; used to detect change.
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;
    ULONG  i, j;

    PAGED_CODE();

    
    pDevExt  = (PDVCR_EXTENSION) pStrmObject->HwDeviceExtension;
    pStrmExt = (PSTREAMEX)       pStrmObject->HwStreamExtension;
    idxStreamNumber =            pStrmObject->StreamNumber;

    TRACE(TL_STRM_TRACE,("OpenStream: pStrmObject %x, pOpenFormat %x, cntOpen %d, idxStream %d\n", pStrmObject, pOpenFormat, pDevExt->cndStrmOpen, idxStreamNumber));

    //
    // When nonone else has open a stream (or is opening ?)
    //
    if(pDevExt->cndStrmOpen > 0) {

        Status = STATUS_UNSUCCESSFUL; 
        TRACE(TL_STRM_WARNING,("OpenStream: %d stream open already; failed hr %x\n", pDevExt->cndStrmOpen, Status));
        return Status;
    }

    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        ASSERT(pIrp && "IoAllocateIrp() failed!");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If a user switch from Camera to VCR mode very quickly (passing the OFF position), 
    // the driver may not be relaoded to detect correct mode of operation.
    // It is safe to redetect here.
    // Note: MSDV does return all the stream info for both input and output pin format.
    //
    DVGetDevModeOfOperation(pDevExt);


    //
    // WARNING: !! we advertise both input and output pin regardless of its mode of operation,
    // but Camera does not support input pin so open should failed!
    // If a VCR does not have input pin should fail as well.
    //
    // Ignore checking for ED_DEVTYOPE_UNKNOWN (most likely a hardware decoder box)
    //
    if((pDevExt->ulDevType == ED_DEVTYPE_CAMERA || 
        (pDevExt->ulDevType == ED_DEVTYPE_VCR && pDevExt->pDevInPlugs->NumPlugs == 0))
        && idxStreamNumber == 2) {

        IoFreeIrp(pIrp);
        TRACE(TL_STRM_WARNING,("OpenStream:Camera mode or VCR with 0 input pin cannot take external in.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    ASSERT(idxStreamNumber < pDevExt->NumOfPins);
    ASSERT(pDevExt->paStrmExt[idxStreamNumber] == NULL);  // Not yet open!

    //
    // Data flow
    //
    DataFlow= pDevExt->pStreamInfoObject[idxStreamNumber].hwStreamInfo.DataFlow;

           
    //
    // Initialize the stream extension structure
    //
    AVCTapeIniStrmExt(
         pStrmObject, 
         pStrmExt,
         pDevExt,
         &pDevExt->pStreamInfoObject[idxStreamNumber]
         );

    //
    // Sony's NTSC can play PAL tape and its plug will change its supported format accordingly.
    //
    // Query video format (NTSC/PAL) supported.
    // Compare with its default (set at load time or last opensteam),
    // if difference, change our internal video format table.
    //
    if(pDevExt->ulDevType != ED_DEVTYPE_CAMERA) {
        VideoFormatIndexLast = pDevExt->VideoFormatIndex;
        if(!DVGetDevSignalFormat(
            pDevExt,
            DataFlow,
            pStrmExt
            )) {
            IoFreeIrp(pIrp);
            // If querying its format has failed, we cannot open this stream.
            TRACE(TL_STRM_WARNING,("OpenStream:Camera mode cannot take external in.\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto AbortOpenStream;
        }
    }


    //
    // Check the video data format is okay.
    //
    if(!AVCTapeVerifyDataFormat(
            pDevExt->NumOfPins,
            pOpenFormat, 
            idxStreamNumber,
            AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize,
            pDevExt->pStreamInfoObject
            ) ) {
        IoFreeIrp(pIrp);
        TRACE(TL_STRM_ERROR,("OpenStream: AdapterVerifyFormat failed.\n"));        
        return STATUS_INVALID_PARAMETER;
    }


    //
    // This event guard againt work item completion
    // 

    KeInitializeEvent(&pStrmExt->hCancelDoneEvent, NotificationEvent, TRUE);


    //
    // Alloccate synchronization structures for flow control and queue management
    //

    pStrmExt->hMutexFlow = (KMUTEX *) ExAllocatePool(NonPagedPool, sizeof(KMUTEX));
    if(!pStrmExt->hMutexFlow) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeMutex( pStrmExt->hMutexFlow, 0);      // Level 0 and in Signal state

    pStrmExt->hMutexReq = (KMUTEX *) ExAllocatePool(NonPagedPool, sizeof(KMUTEX));
    if(!pStrmExt->hMutexReq) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeMutex(pStrmExt->hMutexReq, 0);

    pStrmExt->DataListLock = (KSPIN_LOCK *) ExAllocatePool(NonPagedPool, sizeof(KSPIN_LOCK));
    if(!pStrmExt->DataListLock) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }
    KeInitializeSpinLock(pStrmExt->DataListLock);


    // 
    // Request AVCStrm to open a stream
    //

    pStrmExt->pIrpReq = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pStrmExt->pIrpReq) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }

    pStrmExt->pIrpAbort = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pStrmExt->pIrpAbort) {
        IoFreeIrp(pStrmExt->pIrpReq);   pStrmExt->pIrpReq = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortOpenStream;
    }


    //
    // Pre-allocate list of detached (free) and attached (busy) list for tracking
    // data request sending down to lower driver for processing.
    // 
    InitializeListHead(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached = 0;
    InitializeListHead(&pStrmExt->DataAttachedListHead); pStrmExt->cntDataAttached = 0;

    for (i=0; i < MAX_DATA_REQUESTS; i++) {
        pStrmExt->AsyncReq[i].pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
        if(!pStrmExt->AsyncReq[i].pIrp) {
            // Free resource allocated so far.
            for (j=0; j < i; j++) {
                if(pStrmExt->AsyncReq[j].pIrp) {
                    IoFreeIrp(pStrmExt->AsyncReq[j].pIrp); pStrmExt->AsyncReq[j].pIrp = NULL;
                }
                RemoveEntryList(&pStrmExt->AsyncReq[j].ListEntry);  pStrmExt->cntDataDetached--;            
            }
            IoFreeIrp(pStrmExt->pIrpAbort); pStrmExt->pIrpAbort = NULL;
            IoFreeIrp(pStrmExt->pIrpReq);   pStrmExt->pIrpReq = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortOpenStream;
        }

        InsertTailList(&pStrmExt->DataDetachedListHead, &pStrmExt->AsyncReq[i].ListEntry); pStrmExt->cntDataDetached++;
    }

    // Synchronous calls share the same AV request packet in the stream extension..
    EnterAVCStrm(pStrmExt->hMutexReq);

    pAVCStrmReq = &pStrmExt->AVCStrmReq;
    RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
    INIT_AVCSTRM_HEADER(pAVCStrmReq, AVCSTRM_OPEN);
#if 1
    if(pDevExt->VideoFormatIndex == AVCSTRM_FORMAT_MPEG2TS) {
        // Data Rate
        // AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].AvgTimePerFrame = ?
        if(DataFlow == KSPIN_DATAFLOW_IN) {
            AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].OptionFlags = 0;
            AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize = BUFFER_SIZE_MPEG2TS_SPH;
        } else {
            if(IsEqualGUID (&pOpenFormat->SubFormat, &KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE)) {
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].OptionFlags = 0;
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize = BUFFER_SIZE_MPEG2TS_SPH; 
            } else {
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].OptionFlags = AVCSTRM_FORMAT_OPTION_STRIP_SPH;
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize = BUFFER_SIZE_MPEG2TS; 
            }
        }
    }
#endif
    pAVCStrmReq->CommandData.OpenStruct.AVCFormatInfo    = &AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex]; 
    pAVCStrmReq->CommandData.OpenStruct.AVCStreamContext = 0;   // will return the AV stream context
    pAVCStrmReq->CommandData.OpenStruct.DataFlow         = DataFlow;
#ifdef SUPPORT_LOCAL_PLUGS
    if(DataFlow == KSPIN_DATAFLOW_OUT)
        pAVCStrmReq->CommandData.OpenStruct.hPlugLocal   = pDevExt->hInputPCRLocal;  // Remote(oPCR)->Local(iPCR)
    else
        pAVCStrmReq->CommandData.OpenStruct.hPlugLocal   = pDevExt->hOutputPCRLocal; // Remote(iPCR)<-Local(oPCR)
#else
    pAVCStrmReq->CommandData.OpenStruct.hPlugLocal   = 0; // Not supported; use whatever 61883 supply.
#endif

    Status = 
        AVCStrmReqSubmitIrpSynch( 
            pDevExt->pBusDeviceObject,
            pStrmExt->pIrpReq,
            pAVCStrmReq
            );

    // Expect SUCCESS or anything else is failure! (including _PENDING) since this is a Sync call.
    if(STATUS_SUCCESS != Status) {
        TRACE(TL_STRM_ERROR,("AVCSTRM_OPEN: failed %x; pAVCStrmReq:%x\n", Status, pAVCStrmReq));
        ASSERT(NT_SUCCESS(Status) && "AVCSTGRM_OPEN failed!\n");
        IoFreeIrp(pStrmExt->pIrpReq); pStrmExt->pIrpReq = NULL;
        LeaveAVCStrm(pStrmExt->hMutexReq);
        goto OpenStreamDone;  // Failed to open!
    }

    //
    // Save the context, which is used for subsequent call to AVCStrm filter driver
    //
    pStrmExt->AVCStreamContext = pAVCStrmReq->CommandData.OpenStruct.AVCStreamContext;
    TRACE(TL_STRM_TRACE,("AVCSTRM_OPEN: suceeded %x; pAVCStrmReq:%x; AVCStreamContext:%x\n", Status, pAVCStrmReq, pStrmExt->AVCStreamContext));


    //
    // Format specific tasks
    //
    switch(pDevExt->VideoFormatIndex) {
    // For DV input pin, setup a timer DPC to periodically fired to singal clock event.
    case AVCSTRM_FORMAT_MPEG2TS:
        break;

    case AVCSTRM_FORMAT_SDDV_NTSC:      // 61883-2
    case AVCSTRM_FORMAT_SDDV_PAL:       // 61883-2
    case AVCSTRM_FORMAT_HDDV_NTSC:      // 61883-3
    case AVCSTRM_FORMAT_HDDV_PAL:       // 61883-3
    case AVCSTRM_FORMAT_SDLDV_NTSC:     // 61883-5
    case AVCSTRM_FORMAT_SDLDV_PAL:      // 61883-5
#ifdef SUPPORT_LOCAL_PLUGS
        if(DataFlow == KSPIN_DATAFLOW_IN) {
            // Remote(iPCR)<-Local(oPCR)
            // The default was S200 for MPEG2TS data; set it to DV.
            pDevExt->OPCR.oPCR.DataRate   = CMP_SPEED_S100; 
            pDevExt->OPCR.oPCR.OverheadID = PCR_OVERHEAD_ID_SDDV_DEF;
            pDevExt->OPCR.oPCR.Payload    = PCR_PAYLOAD_SDDV_DEF;
            if(AVCTapeSetLocalPlug(
                pDevExt,
                &pDevExt->AVReq,
                &pDevExt->hOutputPCRLocal,
                &pDevExt->OPCR)) {
                TRACE(TL_STRM_ERROR|TL_61883_ERROR,("Failed to set oPCR\n"));
            }
        } 
#endif

        KeInitializeDpc(
            &pStrmExt->DPCTimer,
            AVCTapeSignalClockEvent,
            pStrmExt
            );
        KeInitializeTimer(
            &pStrmExt->Timer
            );
        break;
    default:
        // Not supported!
        break;
    }


    LeaveAVCStrm(pStrmExt->hMutexReq);

    //
    //  Cache it and reference when pDevExt is all we have, such as BusReset and SurprieseRemoval
    //
    pDevExt->idxStreamNumber = idxStreamNumber;  // index of current active stream; work only if there is only one active stream at any time.
    pDevExt->paStrmExt[idxStreamNumber] = pStrmExt;

    //
    // In the future, a DV can be unplug and plug back in, 
    // and restore its state if the application is not yet closed.
    //
    pDevExt->bDevRemoved    = FALSE;

    //
    // No one else can open another stream (inout or output) unitil this is release.
    // This is done to avoid cyclic graph.
    //
    pDevExt->cndStrmOpen++;    
    ASSERT(pDevExt->cndStrmOpen == 1);

OpenStreamDone:

    TRACE(TL_STRM_WARNING,("OpenStream: %d stream open, idx %d, Status %x, pStrmExt %x, Context:%x; pDevExt %x\n", 
        pDevExt->cndStrmOpen, pDevExt->idxStreamNumber, Status, pStrmExt, pStrmExt->AVCStreamContext, pDevExt));     
    TRACE(TL_STRM_TRACE,("OpenStream: Status %x, idxStream %d, pDevExt %x, pStrmExt %x, Contextg:%x\n", 
        Status, idxStreamNumber, pDevExt, pStrmExt, pStrmExt->AVCStreamContext));

    return Status;

AbortOpenStream:

    if(pStrmExt->DataListLock) {
        ExFreePool(pStrmExt->DataListLock); pStrmExt->DataListLock = NULL;
    }

    if(pStrmExt->hMutexFlow) {
        ExFreePool(pStrmExt->hMutexFlow); pStrmExt->hMutexFlow = NULL;
    }

    if(pStrmExt->hMutexReq) {
        ExFreePool(pStrmExt->hMutexReq); pStrmExt->hMutexReq = NULL;
    }

    TRACE(TL_STRM_ERROR,("OpenStream failed %x, idxStream %d, pDevExt %x, pStrmExt %x\n", 
        Status, idxStreamNumber, pDevExt, pStrmExt));

    return Status;
}


NTSTATUS
AVCTapeCloseStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    )

/*++

Routine Description:

    Called when an CloseStream Srb request is received

--*/

{
    PSTREAMEX         pStrmExt;
    PDVCR_EXTENSION   pDevExt;
    ULONG             idxStreamNumber;  
    NTSTATUS  Status;
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;
    ULONG  i;
    PDRIVER_REQUEST pDriverReq;


    PAGED_CODE();

    
    pDevExt  = (PDVCR_EXTENSION) pStrmObject->HwDeviceExtension;
    pStrmExt = (PSTREAMEX)       pStrmObject->HwStreamExtension;
    idxStreamNumber =            pStrmObject->StreamNumber;


    TRACE(TL_STRM_TRACE,("CloseStream: >> pStrmExt %x, pDevExt %x\n", pStrmExt, pDevExt));    


    //
    // If the stream isn't open, just return
    //
    if(pStrmExt == NULL) {
        ASSERT(pStrmExt && "CloseStream but pStrmExt is NULL!");   
        return STATUS_SUCCESS;  // ????
    }

    //
    // Wait until the pending work item is completed.  
    //
    KeWaitForSingleObject( &pStrmExt->hCancelDoneEvent, Executive, KernelMode, FALSE, 0 );

    // 
    // Request AVCStrm to close a stream
    //
    EnterAVCStrm(pStrmExt->hMutexReq);

#if 0
    // For DV input pin, setup a timer DPC to periodically fired to singal clock event.
    if(pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_MPEG2TS) {
        // Cancel timer
        TRACE(TL_STRM_TRACE,("*** CancelTimer *********************************************...\n"));
        KeCancelTimer(
            &pStrmExt->Timer
            );
    }
#endif

    pAVCStrmReq = &pStrmExt->AVCStrmReq;
    RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
    INIT_AVCSTRM_HEADER(pAVCStrmReq, AVCSTRM_CLOSE);

    pAVCStrmReq->AVCStreamContext = pStrmExt->AVCStreamContext;

    Status = 
        AVCStrmReqSubmitIrpSynch( 
            pDevExt->pBusDeviceObject,
            pStrmExt->pIrpReq,
            pAVCStrmReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_STRM_ERROR,("AVCSTRM_CLOSE: failed %x; pAVCStrmReq:%x\n", Status, pAVCStrmReq));
        ASSERT(NT_SUCCESS(Status) && "AVCSTGRM_CLOSE failed!\n");
    }
    else {
        // Save the context, which is used for subsequent call to AVCStrm.sys
        TRACE(TL_STRM_TRACE,("AVCSTRM_CLOSE: suceeded %x; pAVCStrmReq:%x\n", Status, pAVCStrmReq));
        pStrmExt->AVCStreamContext = 0;
    }

    // Free system resources
    if(pStrmExt->pIrpReq) {
        IoFreeIrp(pStrmExt->pIrpReq); pStrmExt->pIrpReq = NULL;
    }

    if(pStrmExt->pIrpAbort) {
        IoFreeIrp(pStrmExt->pIrpAbort); pStrmExt->pIrpAbort = NULL;
    }

#if 0
    for (i=0; i < MAX_DATA_REQUESTS; i++) {
        if(pStrmExt->AsyncReq[i].pIrp) {
            IoFreeIrp(pStrmExt->AsyncReq[i].pIrp); pStrmExt->AsyncReq[i].pIrp = NULL;
        }
    }
#else
    //
    // Free IRPs preallocated.  The entire data structure is part of the stream extension so
    // it will be freed by the StreamClass.
    //
    ASSERT(pStrmExt->cntDataAttached == 0);
    ASSERT(pStrmExt->cntDataDetached >= MAX_DATA_REQUESTS);
    while (!IsListEmpty(&pStrmExt->DataDetachedListHead)) {
        pDriverReq = (PDRIVER_REQUEST) RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;
        IoFreeIrp(pDriverReq->pIrp); pDriverReq->pIrp = NULL;
    }
#endif

    LeaveAVCStrm(pStrmExt->hMutexReq);

    //
    //  Not valid after this call.
    //
    for (i=0; i<pDevExt->NumOfPins; i++) {
        //
        // Find what we cache and remove it.
        //
        if(pStrmExt == pDevExt->paStrmExt[i]) {
            pDevExt->paStrmExt[i] = NULL;
            break;
        }
    }

    //
    // Free synchronization structures
    //

    if(pStrmExt->DataListLock) {
        ExFreePool(pStrmExt->DataListLock); pStrmExt->DataListLock = NULL;
    }

    if(pStrmExt->hMutexFlow) {
        ExFreePool(pStrmExt->hMutexFlow); pStrmExt->hMutexFlow = NULL;
    }

    if(pStrmExt->hMutexReq) {
        ExFreePool(pStrmExt->hMutexReq); pStrmExt->hMutexReq = NULL;
    }

    // Release this count so other can open.   
    pDevExt->cndStrmOpen--;
    ASSERT(pDevExt->cndStrmOpen == 0);

    TRACE(TL_STRM_TRACE,("CloseStream: completed; %d stream;\n", pDevExt->cndStrmOpen));

    return STATUS_SUCCESS;
}


NTSTATUS
DVChangePower(
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST pAVReq,
    DEVICE_POWER_STATE NewPowerState
    )
/*++

Routine Description:

    Process changing this device's power state.  

--*/
{
    ULONG i;   
    NTSTATUS Status;

    PAGED_CODE();


    // 
    //    D0: Device is on and can be streaming.
    //    D1,D2: not supported.
    //    D3: Device is off and can not streaming. The context is lost.  
    //        Power can be removed from the device.
    //        When power is back on, we will get a bus reset.
    //

    TRACE(TL_PNP_TRACE,("ChangePower: PowrSt: %d->%d; (d0:[1:On],D3[4:off])\n", pDevExt->PowerState, NewPowerState));

    Status = STATUS_SUCCESS;

    if(pDevExt->PowerState == NewPowerState) {
        TRACE(TL_STRM_WARNING,("ChangePower: no change; do nothing!\n"));
        return STATUS_SUCCESS;
    }

    switch (NewPowerState) {
    case PowerDeviceD3:  // Power OFF   
        // We are at D0 and ask to go to D3: save state, stop streaming and Sleep
        if( pDevExt->PowerState == PowerDeviceD0)  {
            // For a supported power state change
            for (i=0; i<pDevExt->NumOfPins; i++) {
                if(pDevExt->paStrmExt[i]) {
                    if(pDevExt->paStrmExt[i]->bIsochIsActive) {
                        // Stop isoch but do not change the streaming state
                        TRACE(TL_PNP_WARNING,("ChangePower: Stop isoch but not change stream state:%d\n", pDevExt->paStrmExt[i]->StreamState)); 
                    }
                }
            }
        }
        else {
            TRACE(TL_PNP_WARNING,("pDevExt->paStrmExt[i].StreamState:Intermieate power state; do nothing;\n"));
        }
        break;

    case PowerDeviceD0:  // Powering ON (waking up)
        if( pDevExt->PowerState == PowerDeviceD3) {
            // For a supported power state change
            for (i=0; i<pDevExt->NumOfPins; i++) {
                if(pDevExt->paStrmExt[i]) {
                    if(!pDevExt->paStrmExt[i]->bIsochIsActive) {
                        TRACE(TL_PNP_ERROR,("ChangePower: StrmSt:%d; Start isoch\n", pDevExt->paStrmExt[i]->StreamState)); 
                        // Start isoch depending on streaming state for DATAFLOW_IN/OUT
                        if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {
                            if(pDevExt->paStrmExt[i]->StreamState == KSSTATE_PAUSE ||
                                pDevExt->paStrmExt[i]->StreamState == KSSTATE_RUN) {   
                            }
                        }
                        else if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
                            if(pDevExt->paStrmExt[i]->StreamState == KSSTATE_RUN) {                             
                            }
                        }                    
                    }  // IsochActive
                }
            }
        }
        else {
            TRACE(TL_PNP_WARNING,("Intermieate power state; do nothing;\n"));
        }
        break;

    // These state are not supported.
    case PowerDeviceD1:
    case PowerDeviceD2:               
    default:
        TRACE(TL_PNP_WARNING,("ChangePower: Not supported PowerState %d\n", DevicePowerState));                  
        Status = STATUS_SUCCESS; // STATUS_INVALID_PARAMETER;
        break;
    }
           

    if(Status == STATUS_SUCCESS) 
        pDevExt->PowerState = NewPowerState;         
    else 
        Status = STATUS_NOT_IMPLEMENTED;

    return STATUS_SUCCESS;     
}


NTSTATUS
AVCTapeSurpriseRemoval(
    PDVCR_EXTENSION pDevExt,
    PAV_61883_REQUEST  pAVReq
    )

/*++

Routine Description:

    Response to SRB_SURPRISE_REMOVAL.

--*/

{
    ULONG  i;
    PKSEVENT_ENTRY  pEvent = NULL;

    PAGED_CODE();

    //
    // ONLY place this flag is set to TRUE.
    // Block incoming read although there might still in the process of being attached
    //
    pDevExt->bDevRemoved    = TRUE;

    // Signal
    if(pDevExt->PowerState != PowerDeviceD3) {
        pDevExt->PowerState = PowerDeviceD3;  // It is as good as power is off.
    }

    //
    // Now Stop the stream and clean up
    //

    for(i=0; i < pDevExt->NumOfPins; i++) {
        
        if(pDevExt->paStrmExt[i] != NULL) {

            TRACE(TL_PNP_WARNING,("#SURPRISE_REMOVAL# StrmNum %d, pStrmExt %x\n", i, pDevExt->paStrmExt[i]));

            // Signal this event so SRB can complete.
            if(pDevExt->paStrmExt[i]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN ) {
                //
                // Imply EOStream!
                //

                if(!pDevExt->paStrmExt[i]->bEOStream)
                    pDevExt->paStrmExt[i]->bEOStream = TRUE;
                //
                // Signal EOStream
                //
                StreamClassStreamNotification(
                    SignalMultipleStreamEvents,
                    pDevExt->paStrmExt[i]->pStrmObject,
                    (GUID *)&KSEVENTSETID_Connection_Local,
                    KSEVENT_CONNECTION_ENDOFSTREAM
                    );
            }

            //
            // Start a work item to abort streaming
            //
            AVCTapeCreateAbortWorkItem(pDevExt, pDevExt->paStrmExt[i]);

            //
            // Wait until the pending work item is completed.  
            //
            TRACE(TL_PNP_WARNING,("SupriseRemoval: Wait for CancelDoneEvent <entering>; lCancelStateWorkItem:%d\n", pDevExt->paStrmExt[i]->lCancelStateWorkItem));
            KeWaitForSingleObject( &pDevExt->paStrmExt[i]->hCancelDoneEvent, Executive, KernelMode, FALSE, 0 );
            TRACE(TL_PNP_WARNING,("SupriseRemoval: Wait for CancelDoneEvent; Attached:%d <exited>...\n", pDevExt->paStrmExt[i]->cntDataAttached));
            ASSERT(pDevExt->paStrmExt[i]->cntDataAttached == 0);  // No more attach after abort stream!
        }
    }


    // Signal KSEvent that device is removed.
    // After this SRb, there will be no more Set/Get property Srb into this driver.
    // By notifying the COM I/F, it will wither signal application that device is removed and
    // return ERROR_DEVICE_REMOVED error code for subsequent calls.

    pEvent = 
        StreamClassGetNextEvent(
            (PVOID) pDevExt,
            0,
            (GUID *)&KSEVENTSETID_EXTDEV_Command,
            KSEVENT_EXTDEV_NOTIFY_REMOVAL,
            pEvent);

    if(pEvent) {
        //
        // signal the event here
        //     
        if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_NOTIFY_REMOVAL) {
            StreamClassDeviceNotification(
                SignalDeviceEvent,
                pDevExt,
                pEvent
                );        
             TRACE(TL_PNP_WARNING,("SurpriseRemoval: signal KSEVENT_EXTDEV_NOTIFY_REMOVAL, id %x.\n", pEvent->EventItem->EventId));
        } else {
            TRACE(TL_PNP_TRACE,("SurpriseRemoval: pEvent:%x; Id:%d not matched!\n", pEvent, pEvent->EventItem->EventId)); 
        }
    } else {
        TRACE(TL_PNP_TRACE,("SurpriseRemoval: KSEVENT_EXTDEV_NOTIFY_REMOVAL event not enabled\n")); 
    }
   
    return STATUS_SUCCESS;
}


// Return code is basically return in pSrb->Status.
NTSTATUS
AVCTapeProcessPnPBusReset(
    PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    Process a bus reset.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/
{   
#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT
    PKSEVENT_ENTRY   pEvent;
#endif

    PAGED_CODE();


    TRACE(TL_PNP_TRACE,("ProcessPnPBusReset: >>\n"));
    
#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT
    //
    // Signal (if enabled) busreset event to let upper layer know that a busreset has occurred.
    //
    pEvent = NULL;
    pEvent = 
        StreamClassGetNextEvent(
            (PVOID) pDevExt,
            0, 
            (GUID *)&KSEVENTSETID_EXTDEV_Command,
            KSEVENT_EXTDEV_COMMAND_BUSRESET,
            pEvent
            );

    if(pEvent) {
        //
        // signal the event here
        //    
        if(pEvent->EventItem->EventId == KSEVENT_EXTDEV_COMMAND_BUSRESET) {
            StreamClassDeviceNotification(
                SignalDeviceEvent,
                pDevExt,
                pEvent
                );        

            TRACE(TL_PNP_TRACE,("ProcessPnPBusReset: Signal BUSRESET; EventId %d.\n", pEvent->EventItem->EventId));
        }
    }
#endif   

    //
    // Reset pending count and AVC command that is in Interim
    //
    DVAVCCmdResetAfterBusReset(pDevExt);


    //
    // Can we return anything other than SUCCESS ?
    //
    return STATUS_SUCCESS;
}   


NTSTATUS
AVCTapeUninitialize(
    IN PDVCR_EXTENSION  pDevExt
    )
/*++

Routine Description:

    This where we perform the necessary initialization tasks.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/
{
    PAGED_CODE();

    TRACE(TL_PNP_TRACE,("UnInitialize: pDevExt=%x\n", pDevExt));

    //
    // Clear all pending AVC command entries.
    //
    DVAVCCmdResetAfterBusReset(pDevExt);

    
    //
    // Free textual string
    //
    DvFreeTextualString(pDevExt, &pDevExt->UnitIDs);


#ifdef SUPPORT_LOCAL_PLUGS

    // Delete the local output plug.
    if(pDevExt->hOutputPCRLocal) {
        if(!AVCTapeDeleteLocalPlug(
            pDevExt,
            &pDevExt->AVReq,
            &pDevExt->OutputPCRLocalNum,
            &pDevExt->hOutputPCRLocal)) {
            TRACE(TL_PNP_ERROR,("Failed to delete a local oPCR!\n"));        
        }
    }

    // Delete the local input plug.
    if(pDevExt->hInputPCRLocal) {
        if(!AVCTapeDeleteLocalPlug(
            pDevExt,
            &pDevExt->AVReq,
            &pDevExt->InputPCRLocalNum,
            &pDevExt->hInputPCRLocal)) {
            TRACE(TL_PNP_ERROR,("Failed to delete a local iPCR!\n"));        
        }
    }

#endif

    // Free preallocate resource
    if(pDevExt->pIrpSyncCall) {
        IoFreeIrp(pDevExt->pIrpSyncCall); pDevExt->pIrpSyncCall = NULL;
    }

    // Free stream information allocated
    if(pDevExt->pStreamInfoObject) {
        ExFreePool(pDevExt->pStreamInfoObject);
        pDevExt->pStreamInfoObject = NULL;
    }

    TRACE(TL_PNP_TRACE,("UnInitialize: done!\n"));

    return STATUS_SUCCESS;
}


//*****************************************************************************
//*****************************************************************************
// S T R E A M    S R B
//*****************************************************************************
//*****************************************************************************
#if DBG
ULONG DbgLastIdx = 0;
#endif

NTSTATUS
AVCTapeReqReadDataCR(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP  pIrpReq,
    IN PDRIVER_REQUEST  pDriverReq
    )
{
    PHW_STREAM_REQUEST_BLOCK  pSrb;
    PSTREAMEX  pStrmExt;
    KIRQL  oldIrql;

    ASSERT(pDriverReq);
    pSrb     = pDriverReq->Context1;
    pStrmExt = pDriverReq->Context2;

    if(pSrb == NULL || pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("ReqReadDataCR: Context are all NULL!\n"));
        return STATUS_MORE_PROCESSING_REQUIRED;  // Will reuse this irp
    }



    KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql);
    
    // Count frame procesed
    pStrmExt->FramesProcessed++;
    pStrmExt->cntDataSubmitted--;

#if 1
    // Retrieve current stream time
    if(pStrmExt->hMasterClock) {
        pStrmExt->CurrentStreamTime = pSrb->CommandData.DataBufferArray->PresentationTime.Time;
#if 0
        AVCTapeSignalClockEvent(pStrmExt);
#endif
    }
#endif

#if DBG
    //
    // Check data request completion is in sequence
    //
    if(pStrmExt->FramesProcessed != pDriverReq->cntDataRequestReceived) {
        TRACE(TL_STRM_WARNING,("** OOSeq: Next:%d != Actual:%d **\n", 
            (DWORD) pStrmExt->FramesProcessed, (DWORD) pDriverReq->cntDataRequestReceived));
        // ASSERT(pStrmExt->FramesProcessed == pDriverReq->cntDataRequestReceived);
    }
#endif

    if(!NT_SUCCESS(pIrpReq->IoStatus.Status)) {
        TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("ReadDataReq failed; St:%x; DataUsed:%d\n", pIrpReq->IoStatus.Status,
            pSrb->CommandData.DataBufferArray->DataUsed));
        // Only acceptable status is cancel.
        ASSERT(pIrpReq->IoStatus.Status == STATUS_CANCELLED && "ReadDataReq failed\n");
    } else {
        TRACE(TL_STRM_INFO,("ReadDataReq pSrb:%x; St:%x; DataUsed:%d; Flag:%x\n", pIrpReq->IoStatus.Status, 
            pSrb->CommandData.DataBufferArray->DataUsed, pSrb->CommandData.DataBufferArray->OptionsFlags));
    }

    ASSERT(pIrpReq->IoStatus.Status != STATUS_PENDING);

    pSrb->Status = pIrpReq->IoStatus.Status;

    // Reset them so if this is completed here before the IRP's IoCallDriver is returned,
    // it will not try to complete again.
    pDriverReq->Context1 = NULL;
    pDriverReq->Context2 = NULL;

    // Done; recycle.
    RemoveEntryList(&pDriverReq->ListEntry);  pStrmExt->cntDataAttached--;
    InsertTailList(&pStrmExt->DataDetachedListHead, &pDriverReq->ListEntry); pStrmExt->cntDataDetached++;

    KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

    //
    // Signal the graph manager that we are completed.
    //
    if(pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {

        StreamClassStreamNotification(
            SignalMultipleStreamEvents,
            pStrmExt->pStrmObject,
            &KSEVENTSETID_Connection,
            KSEVENT_CONNECTION_ENDOFSTREAM
            );
    }

    // Finally, send the srb back up ...
    StreamClassStreamNotification( 
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb 
        );



    return STATUS_MORE_PROCESSING_REQUIRED;  // Will reuse this irp
} // AVCStrmReqIrpSynchCR


NTSTATUS
AVCTapeGetStreamState(
    PSTREAMEX  pStrmExt,
    IN PDEVICE_OBJECT DeviceObject,
    PKSSTATE   pStreamState,
    PULONG     pulActualBytesTransferred
    )
/*++

Routine Description:

    Gets the current state of the requested stream

--*/
{
    NTSTATUS Status;
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;

    PAGED_CODE();

    if(!pStrmExt) {
        TRACE(TL_STRM_ERROR,("GetStreamState: pStrmExt:%x; STATUS_UNSUCCESSFUL\n", pStrmExt));
        return STATUS_UNSUCCESSFUL;        
    }

    // 
    // Request AVCStrm to get current stream state
    //
    EnterAVCStrm(pStrmExt->hMutexReq);

    pAVCStrmReq = &pStrmExt->AVCStrmReq;
    RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
    INIT_AVCSTRM_HEADER(pAVCStrmReq, AVCSTRM_GET_STATE);
    pAVCStrmReq->AVCStreamContext = pStrmExt->AVCStreamContext;

    Status = 
        AVCStrmReqSubmitIrpSynch( 
            DeviceObject,
            pStrmExt->pIrpReq,
            pAVCStrmReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_STRM_ERROR,("AVCSTRM_GET_STATE: failed %x; pAVCStrmReq:%x\n", Status, pAVCStrmReq));
        ASSERT(NT_SUCCESS(Status) && "AVCSTRM_GET_STATE failed!\n");
    }
    else {
        // Save the context, which is used for subsequent call to AVCStrm.sys
        TRACE(TL_STRM_WARNING,("AVCSTRM_GET_STATE: Status:%x; pAVCStrmReq:%x; KSSTATE:%d\n", Status, pAVCStrmReq, pAVCStrmReq->CommandData.StreamState));
        *pStreamState = pAVCStrmReq->CommandData.StreamState;
        *pulActualBytesTransferred = sizeof (KSSTATE);

        // A very odd rule:
        // When transitioning from stop to pause, DShow tries to preroll
        // the graph.  Capture sources can't preroll, and indicate this
        // by returning VFW_S_CANT_CUE in user mode.  To indicate this
        // condition from drivers, they must return ERROR_NO_DATA_DETECTED
        if(   *pStreamState == KSSTATE_PAUSE 
           && pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT
          ) 
           Status = STATUS_NO_DATA_DETECTED;
        else 
           Status = STATUS_SUCCESS;
    }

    LeaveAVCStrm(pStrmExt->hMutexReq);

    return Status;
}



NTSTATUS
AVCTapeSetStreamState(
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq,
    KSSTATE          StreamState
    )
/*++

Routine Description:

    Sets the stream state via the SRB.

--*/

{
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;
    NTSTATUS Status;

   
    PAGED_CODE();


    ASSERT(pStrmExt);
    if(pStrmExt == NULL)  {
        return STATUS_UNSUCCESSFUL;      
    }

    Status = STATUS_SUCCESS;

    TRACE(TL_STRM_TRACE,("Set State %d -> %d; PowerSt:%d (1/On;4/Off]); AD [%d,%d]\n", \
        pStrmExt->StreamState, StreamState, pDevExt->PowerState,
        pStrmExt->cntDataAttached,
        pStrmExt->cntDataDetached
        ));

#if DBG
    if(StreamState == KSSTATE_RUN) {
        ASSERT(pDevExt->PowerState == PowerDeviceD0 && "Cannot set to RUN while power is off!");
    }
#endif

    // 
    // Request AVCStrm to set to a new stream state
    //
    EnterAVCStrm(pStrmExt->hMutexReq);

    pAVCStrmReq = &pStrmExt->AVCStrmReq;
    RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
    INIT_AVCSTRM_HEADER(pAVCStrmReq, AVCSTRM_SET_STATE);
    pAVCStrmReq->AVCStreamContext = pStrmExt->AVCStreamContext;
    pAVCStrmReq->CommandData.StreamState = StreamState;

    Status = 
        AVCStrmReqSubmitIrpSynch( 
            pDevExt->pBusDeviceObject,
            pStrmExt->pIrpReq,
            pAVCStrmReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_STRM_ERROR,("AVCSTRM_SET_STATE: failed %x; pAVCStrmReq:%x\n", Status, pAVCStrmReq));
        ASSERT(NT_SUCCESS(Status) && "AVCSTRM_SET_STATE failed!\n");
    }
    else {
        // Save the context, which is used for subsequent call to AVCStrm.sys
        TRACE(TL_STRM_TRACE,("AVCSTRM_SET_STATE: Status:%x; pAVCStrmReq:%x, new KSSTATE:%d\n", Status, pAVCStrmReq, pAVCStrmReq->CommandData.StreamState));

        // Reset the abort state
        if(pStrmExt->StreamState == KSSTATE_STOP && StreamState == KSSTATE_ACQUIRE)
            pStrmExt->AbortInProgress  = FALSE;


        // Reaction due to state change
        switch(StreamState) {
        case KSSTATE_STOP:
            TRACE(TL_STRM_TRACE,("SrbRcv:%d, Processed:%d; Pending:%d\n", (DWORD) pStrmExt->cntSRBReceived, (DWORD) pStrmExt->FramesProcessed, (DWORD) pStrmExt->cntDataSubmitted));
            // Reset it
            pStrmExt->cntSRBReceived = pStrmExt->FramesProcessed = pStrmExt->cntDataSubmitted = 0;
            pStrmExt->CurrentStreamTime = 0;  
            break;

        case KSSTATE_PAUSE:
            // For DV input pin, setup a timer DPC to periodically fired to singal clock event.
            if(pStrmExt->hMasterClock && pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_MPEG2TS && pStrmExt->StreamState == KSSTATE_RUN) {
               // Cancel timer
#if 1
                TRACE(TL_STRM_TRACE,("*** (RUN->PAUSE) CancelTimer *********************************************...\n"));
                KeCancelTimer(
                    &pStrmExt->Timer
                    );
#endif
            }
            break;

        case KSSTATE_RUN:
            // For DV input pin, setup a timer DPC to periodically fired to singal clock event.
            if(pStrmExt->hMasterClock &&
               pDevExt->VideoFormatIndex != AVCSTRM_FORMAT_MPEG2TS) {
                LARGE_INTEGER DueTime;
#define CLOCK_INTERVAL 20 // Unit=MilliSeconds

#if 0
                // For DV input pin, setup a timer DPC to periodically fired to singal clock event.
                KeInitializeDpc(
                    &pStrmExt->DPCTimer,
                    AVCTapeSignalClockEvent,
                    pStrmExt
                    );
                KeInitializeTimer(
                    &pStrmExt->Timer              
                    );    
#endif

                DueTime = RtlConvertLongToLargeInteger(-CLOCK_INTERVAL * 10000);
                TRACE(TL_STRM_TRACE,("*** ScheduleTimer (RUN) *****************************************...\n"));
                KeSetTimerEx(
                    &pStrmExt->Timer,
                    DueTime,
                    CLOCK_INTERVAL,  // Repeat every 40 MilliSecond
                    &pStrmExt->DPCTimer
                    );
            }
            break;
        default:
            break;
        }

            // Cache the current state
        pStrmExt->StreamState = StreamState;
    }

    LeaveAVCStrm(pStrmExt->hMutexReq);

    return Status;
}



NTSTATUS 
DVStreamGetConnectionProperty (
    PDVCR_EXTENSION pDevExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handles KS_PROPERTY_CONNECTION* request.  For now, only ALLOCATORFRAMING and
    CONNECTION_STATE are supported.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        if (pDevExt != NULL && pDevExt->cndStrmOpen)  {
            PKSALLOCATOR_FRAMING pFraming = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            
            pFraming->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            pFraming->PoolType = NonPagedPool;

            pFraming->Frames = \
                pDevExt->paStrmExt[pDevExt->idxStreamNumber]->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT ? \
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].NumOfRcvBuffers : \
                 AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].NumOfXmtBuffers;

            // Note:  we'll allocate the biggest frame.  We need to make sure when we're
            // passing the frame back up we also set the number of bytes in the frame.
            pFraming->FrameSize = AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize;
            pFraming->FileAlignment = 0; // FILE_LONG_ALIGNMENT;
            pFraming->Reserved = 0;
            *pulActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);

            TRACE(TL_STRM_TRACE,("*** AllocFraming: cntStrmOpen:%d; VdoFmtIdx:%d; Frames %d; size:%d\n", \
                pDevExt->cndStrmOpen, pDevExt->VideoFormatIndex, pFraming->Frames, pFraming->FrameSize));
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        break;
        
    default:
        *pulActualBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);
        break;
    }

    return Status;
}


NTSTATUS
DVGetDroppedFramesProperty(  
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX       pStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    )
/*++

Routine Description:

    Return the dropped frame information while captureing.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
  
    PAGED_CODE();

    switch (pSPD->Property->Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
         {

         PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
                     (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;
         
         pDroppedFrames->AverageFrameSize = AVCStrmFormatInfoTable[pStrmExt->pDevExt->VideoFormatIndex].FrameSize;

         if(pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_IN) {     
#if 0
             // pStrmExt->PictureNumber is not returned since it might be greater than number of SRBs returned.
             // pStrmExt->CurrentStreamTime >= pDroppedFrames->PictureNumber * (ulAvgTimePerFrame)
             // CurrentStreamTime will be ahead if there is repeat frame and the data source
             // cannot keep up with the constant data transfer of 29.97 (or 25) FPS; therefore,
             // repeat frame might have inserted and the last data in the last SRB is transferred.
             // To resolve this, an application can query PictureNumber and CurrentStreamTime and
             // does a read ahead of their delta to "catch up".
             pDroppedFrames->PictureNumber = pStrmExt->FramesProcessed + pStrmExt->FramesDropped;   
#else
             // This is the picture number that MSDV is actually sending, and in a slow harddisk case,
             // it will be greater than (FramesProcessed + FramesDropped) considering repeat frame.
             pDroppedFrames->PictureNumber = pStrmExt->PictureNumber;
#endif
         } else {
             pDroppedFrames->PictureNumber = pStrmExt->PictureNumber;
         }
         pDroppedFrames->DropCount        = pStrmExt->FramesDropped;    // For transmit, this value includes both dropped and repeated.

         TRACE(TL_STRM_TRACE,("*DroppedFP: Pic#(%d), Drp(%d)\n", (LONG) pDroppedFrames->PictureNumber, (LONG) pDroppedFrames->DropCount));
               
         *pulBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
         Status = STATUS_SUCCESS;

         }
         break;

    default:
        *pulBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        ASSERT(pSPD->Property->Id == KSPROPERTY_DROPPEDFRAMES_CURRENT);
        break;
    }

    return Status;
}


NTSTATUS
DVGetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Routine to process property request

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PAGED_CODE();

    if(IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {

        Status = 
            DVStreamGetConnectionProperty (
                pSrb->HwDeviceExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {

        Status = 
            DVGetDroppedFramesProperty (
                pSrb->HwDeviceExtension,
                (PSTREAMEX) pSrb->StreamObject->HwStreamExtension,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
    } 
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}


NTSTATUS 
DVSetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Routine to process set property request

--*/

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PAGED_CODE();

    TRACE(TL_STRM_TRACE,("SetStreamProperty:  entered ...\n"));

    return STATUS_NOT_SUPPORTED;

}


void
DVCancelSrbWorkItemRoutine(
#ifdef USE_WDM110  // Win2000 code base
    // Extra parameter if using WDM10
    PDEVICE_OBJECT DeviceObject,
#endif
    PSTREAMEX  pStrmExt
    )
/*++

Routine Description:

   This work item routine will stop streaming and cancel all SRBs.   

--*/
{
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;
    NTSTATUS Status;
    NTSTATUS StatusWait;

    PAGED_CODE();

    TRACE(TL_STRM_WARNING,("CancelWorkItem: StreamState:%d; lCancel:%d\n", pStrmExt->StreamState, pStrmExt->lCancelStateWorkItem));
    ASSERT(pStrmExt->lCancelStateWorkItem == 1);
#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pStrmExt->pIoWorkItem);
#endif

    // Synchronize 
    //    streaming state, and 
    //    incoming streaming data SRBs
    StatusWait = 
        KeWaitForMutexObject(pStrmExt->hMutexFlow, Executive, KernelMode, FALSE, NULL);
    ASSERT(StatusWait == STATUS_SUCCESS);

    // 
    // We get here usually as a result of a thread was terminated and it needs to cancel irps.
    // We therefore abort streaming.
    //
    pAVCStrmReq = &pStrmExt->AVCStrmReqAbort;

    RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
    INIT_AVCSTRM_HEADER(pAVCStrmReq, AVCSTRM_ABORT_STREAMING);
    pAVCStrmReq->AVCStreamContext = pStrmExt->AVCStreamContext;

    Status = 
        AVCStrmReqSubmitIrpSynch( 
            pStrmExt->pDevExt->pBusDeviceObject,
            pStrmExt->pIrpAbort,
            pAVCStrmReq
            );

#if DBG
    if(Status != STATUS_SUCCESS) {
        TRACE(TL_STRM_ERROR,("Abort streaming status:%x\n", Status));
        ASSERT(Status == STATUS_SUCCESS && "Abort streaming failed\n");
    }
#endif

    KeReleaseMutex(pStrmExt->hMutexFlow, FALSE);  

#ifdef USE_WDM110  // Win2000 code base
    // Release work item and release the cancel token
    IoFreeWorkItem(pStrmExt->pIoWorkItem);  pStrmExt->pIoWorkItem = NULL; 
#endif
    pStrmExt->AbortInProgress = TRUE;
    InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 0);
    KeSetEvent(&pStrmExt->hCancelDoneEvent, 0, FALSE);
}

VOID
AVCTapeCreateAbortWorkItem(
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX pStrmExt
    )
{    
    // Claim this token
    if(InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 1) == 1) {
        TRACE(TL_STRM_WARNING,("Cancel work item is already issued.\n"));
        return;
    }
    // Cancel is already in progress
    if(pStrmExt->AbortInProgress) {
        TRACE(TL_STRM_WARNING,("Cancel work item is already in progress.\n"));
        return;
    }

#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pStrmExt->pIoWorkItem == NULL);  // Have not yet queued work item.

    // We will queue work item to stop and cancel all SRBs
    if(pStrmExt->pIoWorkItem = IoAllocateWorkItem(pDevExt->pBusDeviceObject)) { 

        // Set to non-signal
        KeClearEvent(&pStrmExt->hCancelDoneEvent);  // Before queuing; just in case it return the work item is completed.

        IoQueueWorkItem(
            pStrmExt->pIoWorkItem,
            DVCancelSrbWorkItemRoutine,
            DelayedWorkQueue, // CriticalWorkQueue 
            pStrmExt
            );

#else  // Win9x code base
    ExInitializeWorkItem( &pStrmExt->IoWorkItem, DVCancelSrbWorkItemRoutine, pStrmExt);
    if(TRUE) {

        // Set to non-signal
        KeClearEvent(&pStrmExt->hCancelDoneEvent);  // Before queuing; just in case it return the work item is completed.

        ExQueueWorkItem( 
            &pStrmExt->IoWorkItem,
            DelayedWorkQueue // CriticalWorkQueue 
            ); 
#endif

        TRACE(TL_STRM_WARNING,("CancelWorkItm queued\n"));
    } 
#ifdef USE_WDM110  // Win2000 code base
    else {
        InterlockedExchange(&pStrmExt->lCancelStateWorkItem, 0);
        ASSERT(pStrmExt->pIoWorkItem && "IoAllocateWorkItem failed.\n");
    }
#endif
}


VOID
DVCRCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
/*++

Routine Description:

   Search pending read lists for the SRB to be cancel.  If found cancel it.   

--*/
{
    PDVCR_EXTENSION pDevExt;
    PSTREAMEX pStrmExt;

                                                                                                              
    pDevExt = (PDVCR_EXTENSION) pSrbToCancel->HwDeviceExtension; 
               
    // Cannot cancel device Srb.
    if ((pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        TRACE(TL_PNP_WARNING,("CancelOnePacket: Device SRB %x; cannot cancel!\n", pSrbToCancel));
        ASSERT((pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) == SRB_HW_FLAGS_STREAM_REQUEST );
        return;
    }         
        
    // Can try to cancel a stream Srb and only if the stream extension still around.
    pStrmExt = (PSTREAMEX) pSrbToCancel->StreamObject->HwStreamExtension;
    if(pStrmExt == NULL) {
        TRACE(TL_PNP_ERROR,("CancelOnePacket: pSrbTocancel %x but pStrmExt %x\n", pSrbToCancel, pStrmExt));
        ASSERT(pStrmExt && "Stream SRB but stream extension is NULL\n");
        return;
    }

    // We can only cancel SRB_READ/WRITE_DATA SRB
    if((pSrbToCancel->Command != SRB_READ_DATA) && (pSrbToCancel->Command != SRB_WRITE_DATA)) {
        TRACE(TL_PNP_ERROR,("CancelOnePacket: pSrbTocancel %x; Command:%d not SRB_READ,WRITE_DATA\n", pSrbToCancel, pSrbToCancel->Command));
        ASSERT(pSrbToCancel->Command == SRB_READ_DATA || pSrbToCancel->Command == SRB_WRITE_DATA);
        return;
    }

    TRACE(TL_STRM_TRACE,("CancelOnePacket: KSSt %d; Srb:%x;\n", pStrmExt->StreamState, pSrbToCancel));


    // This is called at DispatchLevel.
    // We will create a work item to do the cancelling (detaching buffers) at the passive level.
    AVCTapeCreateAbortWorkItem(pDevExt, pStrmExt);
}



VOID
DVTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    This routine is called when a packet has been in the minidriver too long.
    It can only valid if we are it wa a streaming packet and in PAUSE state;
    else we have a problem!

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    //
    // Note:
    //    Called from StreamClass at DisptchLevel
    //    

    //
    // We only expect stream SRB, but not device SRB.  
    //

    if ( (pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        TRACE(TL_PNP_WARNING,("TimeoutHandler: Device SRB %x timed out!\n", pSrb));
        ASSERT((pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST) == SRB_HW_FLAGS_STREAM_REQUEST );
        return;
    } else {

        //
        // pSrb->StreamObject (and pStrmExt) only valid if it is a stream SRB
        //
        PSTREAMEX pStrmExt;

        pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;
        ASSERT(pStrmExt);

        if(!pStrmExt) {
            TRACE(TL_PNP_ERROR,("TimeoutHandler: Stream SRB %x timeout with ppStrmExt %x\n", pSrb, pStrmExt));
            ASSERT(pStrmExt);
            return;
        }

        //
        // Reset Timeout counter, or we are going to get this call immediately.
        //

        pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
    }
}



NTSTATUS 
AVCTapeEventHandler(
    IN PHW_EVENT_DESCRIPTOR pEventDescriptor
    )
/*++

Routine Description:

    This routine is called to enable/disable and possibly process events.

--*/
{
    PKSEVENT_TIME_MARK  pEventTime;
    PSTREAMEX  pStrmExt;

    if(IsEqualGUID (&KSEVENTSETID_Clock, pEventDescriptor->EventEntry->EventSet->Set)) {
        if(pEventDescriptor->EventEntry->EventItem->EventId == KSEVENT_CLOCK_POSITION_MARK) {
            if(pEventDescriptor->Enable) {
                // Note: According to the DDK, StreamClass queues pEventDescriptor->EventEntry, and dellaocate
                // every other structures, including the pEventDescriptor->EventData.
                if(pEventDescriptor->StreamObject) { 
                    pStrmExt = (PSTREAMEX) pEventDescriptor->StreamObject->HwStreamExtension;
                    pEventTime = (PKSEVENT_TIME_MARK) pEventDescriptor->EventData;
                    // Cache the event data (Specified in the ExtraEntryData of KSEVENT_ITEM)
                    RtlCopyMemory((pEventDescriptor->EventEntry+1), pEventDescriptor->EventData, sizeof(KSEVENT_TIME_MARK));
                    TRACE(TL_CLK_TRACE,("CurrentStreamTime:%d, MarkTime:%d\n", (DWORD) pStrmExt->CurrentStreamTime, (DWORD) pEventTime->MarkTime));
                }
            } else {
               // Disabled!
                TRACE(TL_CLK_TRACE,("KSEVENT_CLOCK_POSITION_MARK disabled!\n"));            
            }
            return STATUS_SUCCESS;
        }
    } else if(IsEqualGUID (&KSEVENTSETID_Connection, pEventDescriptor->EventEntry->EventSet->Set)) {
        TRACE(TL_STRM_TRACE,("Connecytion event: pEventDescriptor:%x; id:%d\n", pEventDescriptor, pEventDescriptor->EventEntry->EventItem->EventId));
        if(pEventDescriptor->EventEntry->EventItem->EventId == KSEVENT_CONNECTION_ENDOFSTREAM) {
            if(pEventDescriptor->Enable) {
                TRACE(TL_STRM_TRACE,("KSEVENT_CONNECTION_ENDOFSTREAM enabled!\n"));
            } else {
                TRACE(TL_STRM_TRACE,("KSEVENT_CONNECTION_ENDOFSTREAM disabled!\n"));            
            }
            return STATUS_SUCCESS;
        }
    }

    TRACE(TL_PNP_ERROR|TL_CLK_ERROR,("NOT_SUPPORTED event: pEventDescriptor:%x\n", pEventDescriptor));
    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}

VOID
AVCTapeSignalClockEvent(
    IN PKDPC Dpc,
    
    IN PSTREAMEX  pStrmExt,

    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2    
)
/*++

Routine Description:

    This routine is called when we are the clock provider and when our clock "tick".  
    Find a pending clock event, signal it if it has expired.

--*/
{
    PKSEVENT_ENTRY pEvent, pLast;

    pEvent = NULL;
    pLast = NULL;

    while(( 
        pEvent = StreamClassGetNextEvent(
            pStrmExt->pDevExt,
            pStrmExt->pStrmObject,
            (GUID *)&KSEVENTSETID_Clock,
            KSEVENT_CLOCK_POSITION_MARK,
            pLast )) 
        != NULL ) {

#if 1
#define CLOCK_ADJUSTMENT  400000
        if (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime <= pStrmExt->CurrentStreamTime + CLOCK_ADJUSTMENT) {
#else
        if (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime <= pStrmExt->CurrentStreamTime) {
#endif
            TRACE(TL_CLK_TRACE,("Clock event %x with id %d; Data:%x; tmMark:%d; tmCurrentStream:%d; Notify!\n", 
                pEvent, KSEVENT_CLOCK_POSITION_MARK, (PKSEVENT_TIME_MARK)(pEvent +1),
                (DWORD) (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime), (DWORD) pStrmExt->CurrentStreamTime));
            ASSERT( ((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime != 0 );

            //
            // signal the event here
            //
            StreamClassStreamNotification(
                SignalStreamEvent,
                pStrmExt->pStrmObject,
                pEvent
                );
        } else {
            TRACE(TL_CLK_WARNING,("Still early! ClockEvent: MarkTime:%d, tmStream%d\n",
                (DWORD) (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime), (DWORD) pStrmExt->CurrentStreamTime));

        }
        pLast = pEvent;
    }

#if DBG
    if(pLast == NULL) {
        TRACE(TL_CLK_WARNING,("No clock event in the queued! State:%d; tmCurrentStream:%d\n", pStrmExt->StreamState, (DWORD) pStrmExt->CurrentStreamTime));
    }
#endif

}

VOID 
AVCTapeStreamClockRtn(
    IN PHW_TIME_CONTEXT TimeContext
    )
/*++

Routine Description:

    This routine is called whenever someone in the graph wants to know what time it is, and we are the Master Clock.

--*/
{
    PDVCR_EXTENSION    pDevExt;
    PHW_STREAM_OBJECT  pStrmObj;
    PSTREAMEX          pStrmExt;
    
    // Call at dispatch level

    pDevExt  = (PDVCR_EXTENSION) TimeContext->HwDeviceExtension;
    pStrmObj = TimeContext->HwStreamObject;
    if(pStrmObj)
        pStrmExt = pStrmObj->HwStreamExtension;
    else 
        pStrmExt = 0;

    if(!pDevExt || !pStrmExt) {
        ASSERT(pDevExt && pStrmExt);
        return;
    }


    switch (TimeContext->Function) {
    
    case TIME_GET_STREAM_TIME:

        //
        // How long since the stream was first set into the run state?
        //
        ASSERT(pStrmExt->hMasterClock && "We are not master clock but we were qureied?");
        TimeContext->Time = pStrmExt->CurrentStreamTime;
        TimeContext->SystemTime = GetSystemTime();

        TRACE(TL_STRM_WARNING|TL_CLK_TRACE,("State:%d; tmStream:%d tmSys:%d\n", pStrmExt->StreamState, (DWORD) TimeContext->Time, (DWORD) TimeContext->SystemTime ));  
        break;
   
    default:
        ASSERT(TimeContext->Function == TIME_GET_STREAM_TIME && "Unsupport clock func");
        break;
    } // switch TimeContext->Function
}


NTSTATUS 
AVCTapeOpenCloseMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    )
/*++

Routine Description:

    We can be a clock provider.

--*/
{

    PAGED_CODE();

    // Make sure the stream exist.
    if(pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR|TL_CLK_ERROR,("OpenCloseMasterClock: stream is not yet running.\n"));
        ASSERT(pStrmExt);
        return  STATUS_UNSUCCESSFUL;
    } 

    TRACE(TL_CLK_WARNING,("OpenCloseMasterClock: pStrmExt %x; hMyClock:%x->%x\n", 
        pStrmExt, pStrmExt->hMyClock, hMasterClockHandle));

    if(hMasterClockHandle) {
        // Open master clock
        ASSERT(pStrmExt->hMyClock == NULL && "OpenMasterClk while hMyClock is not NULL!");
        pStrmExt->hMyClock = hMasterClockHandle;
    } else {
        // Close master clock
        ASSERT(pStrmExt->hMyClock && "CloseMasterClk while hMyClock is NULL!");
        pStrmExt->hMyClock = NULL;
    }
    return STATUS_SUCCESS;
}


NTSTATUS 
AVCTapeIndicateMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hIndicateClockHandle
    )
/*++

Routine Description:

    Compare the indicate clock handle with my clock handle.
    If the same, we are the master clock; else, other device is 
    the master clock.

    Note: either hMasterClock or hClock can be set.

--*/
{
    PAGED_CODE();

    // Make sure the stream exist.
    if (pStrmExt == NULL) {
        TRACE(TL_STRM_ERROR|TL_CLK_ERROR,("AVCTapeIndicateMasterClock: stream is not yet running.\n"));
        ASSERT(pStrmExt);
        return STATUS_UNSUCCESSFUL;
    }

    TRACE(TL_STRM_TRACE|TL_CLK_WARNING,("IndicateMasterClock[Enter]: pStrmExt:%x; hMyClk:%x; IndMClk:%x; pClk:%x, pMClk:%x\n",
        pStrmExt, pStrmExt->hMyClock, hIndicateClockHandle, pStrmExt->hClock, pStrmExt->hMasterClock));

    // it not null, set master clock accordingly.    
    if(hIndicateClockHandle == pStrmExt->hMyClock) {
        pStrmExt->hMasterClock = hIndicateClockHandle;
        pStrmExt->hClock       = NULL;
    } else {
        pStrmExt->hMasterClock = NULL;
        pStrmExt->hClock       = hIndicateClockHandle;
    }

    TRACE(TL_STRM_TRACE|TL_CLK_TRACE,("IndicateMasterClk[Exit]: hMyClk:%x; IndMClk:%x; pClk:%x; pMClk:%x\n",
        pStrmExt->hMyClock, hIndicateClockHandle, pStrmExt->hClock, pStrmExt->hMasterClock));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpfmt.h ===
/*++

Copyright (C) Microsoft Corporation, 2000 - 2001

Module Name:

    MsTpFmt.h

Abstract:

    Header file for AV/C Tape format data.

Last changed by:
    
$Author::                $

Environment:

    Kernel mode only

Revision History:

$Revision::                    $
$Date::                        $

--*/




#ifndef _DVFORMAT_INC
#define _DVFORMAT_INC


// ****************
// Support switches
// ****************

//
// Differnt level of WDM supports may use different API
//
// e.g. MmGetSystemAddressForMdl (win9x) 
//          Return NULL for Win9x; bugcheck for Win2000 if NULL would have returned.
//
//      MmGetSystemAddressForMdlSafe (win2000)
//          Not supported in Win9x or Millen
//
// #define USE_WDM110  // Define this if WDM1.10 is used; e.g. Win2000 code base; Set this in SOURCES file.


//
// Turn this on to support HD DVCR 
//#define MSDV_SUPPORT_HD_DVCR

//
// Turn this on to support SDL DVCR 
//#define SUPPORT_SDL_DVCR




//
// Turn on this switch to support bus reset KS event
// #define MSDVDV_SUPPORT_BUSRESET_EVENT


//
// Turn this define to extract timecode from a video frame
// Advantage: faster turn around compare to an AVC status command
// #define MSDV_SUPPORT_EXTRACT_SUBCODE_DATA


//
// To get recorded date and time
// #define MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

//
// Mute audio when in pause state while transmitting to DV
#define MSDV_SUPPORT_MUTE_AUDIO

//
// Support getting regitry value for this device
//
// #define READ_CUTOMIZE_REG_VALUES


//
// Suuport accessing to the device's interface section
//
#define SUPPORT_ACCESS_DEVICE_INTERFACE

//
// Support new AVC - plug connection ..etc.
//
// #define SUPPORT_NEW_AVC


//
// Support local plug.
//
#define SUPPORT_LOCAL_PLUG

//
// Testing
//
#if DBG
    #define EnterAVCStrm(pMutex)  \
        { \
        KeWaitForMutexObject(pMutex, Executive, KernelMode, FALSE, NULL);\
        InterlockedIncrement(&MSDVCRMutextUseCount);\
        }
    #define LeaveAVCStrm(pMutex)  \
        { \
        KeReleaseMutex(pMutex, FALSE);\
        InterlockedDecrement(&MSDVCRMutextUseCount);\
        }
#else
    #define EnterAVCStrm(pMutex) KeWaitForMutexObject(pMutex, Executive, KernelMode, FALSE, NULL);
    #define LeaveAVCStrm(pMutex) KeReleaseMutex(pMutex, FALSE);
#endif

//
// DV format tables
//


typedef struct _STREAM_INFO_AND_OBJ {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} STREAM_INFO_AND_OBJ, *PSTREAM_INFO_AND_OBJ;



// All CIP sizes are in quads. The upper third byte is the size.
#define CIP_HDR_FMT_DV                   0x00
#define CIP_HDR_FMT_DVCPRO               0x1e


//
// 1394 stuff
//
#define SPEED_100_INDEX                     0
#define SPEED_200_INDEX                     1
#define SPEED_400_INDEX                     2


#define CIP_DBS_SD_DVCR                   120       // quadlets in a data block of the SD DVCR; BlueBook Part 2
#define CIP_DBS_HD_DVCR                   240       // quadlets in a data block of the HD DVCR; BlueBook Part 3
#define CIP_DBS_SDL_DVCR                  108       // quadlets in a data block of the SDL DVCR; BlueBook Part 5

#define CIP_FN_SD_DVCR                      0       // Data blocks in a source pacaket of SD DVCR; BlueBook Part 2
#define CIP_FN_HD_DVCR                      0       // Data blocks in a source pacaket of HD DVCR; BlueBook Part 3
#define CIP_FN_SDL_DVCR                     0       // Data blocks in a source pacaket of SDL DVCR; BlueBook Part 5


#define MAX_FCP_PAYLOAD_SIZE              512


// CIP header definition:

// FMT: "Blue book" Part 1, page 25, Table 3; DVCR:000000
#define FMT_DVCR             0x80  // 10:FMT(00:0000)
#define FMT_DVCR_CANON       0x20  // 10:FMT(00:0000); but Canon return 00:FMT(10:0000)
#define FMT_MPEG             0xa0  // 10:FMT(10:0000)


// FDF
#define FDF0_50_60_MASK      0x80
#define FDF0_50_60_PAL       0x80
#define FDF0_50_60_NTSC      0x00

#define FDF0_STYPE_MASK      0x7c
#define FDF0_STYPE_SD_DVCR   0x00  // STYPE: 000:00
#define FDF0_STYPE_SDL_DVCR  0x04  // STYPE: 000:01
#define FDF0_STYPE_HD_DVCR   0x08  // STYPE: 000:10
#define FDF0_STYPE_SD_DVCPRO 0x78  // STYPE: 111:10


// PCR constants
#define PCR_OVERHEAD_ID_SDDV_DEF        0xf      // 480; delays caused by IEEE 1394 bus parmeters
#define PCR_PAYLOAD_SDDV_DEF            122      // Fixed: 122 * 4 = 480 + 8

#define PCR_OVERHEAD_ID_MPEG2TS_DEF     0xf      // 480; delays caused by IEEE 1394 bus parmeters
#define PCR_PAYLOAD_MPEG2TS_DEF         146      // Variable but this is based on oPCR of a Panasonic's D-VHS


//
// FCP and AVCC stuff.  Used in conjunction with defs in 1394.h
//

// DVCR:
#define SUBUNIT_TYPE_CAMCORDER           4
#define SUBUNIT_ID_CAMCORDER             0

#define DIF_SEQS_PER_NTSC_FRAME         10
#define DIF_SEQS_PER_PAL_FRAME          12

#define SRC_PACKETS_PER_NTSC_FRAME     250
#define SRC_PACKETS_PER_PAL_FRAME      300


#define NUM_OF_RCV_BUFFERS_DV           8
#define NUM_OF_XMT_BUFFERS_DV           8


// MPEG2TS
#define MPEG2TS_STRIDE_OFFSET           4   // 4 byte of SPH
#define MPEG2TS_STRIDE_PACKET_LEN     188   // standard 188-byte packet
#define MPEG2TS_STRIDE_STRIDE_LEN     (MPEG2TS_STRIDE_OFFSET+MPEG2TS_STRIDE_PACKET_LEN)   // Stride packet length


//
// Data buffers
//

#define NUM_BUF_ATTACHED_THEN_ISOCH         4   // number of buffers attached before streaming and also as the water mark.
#define DV_NUM_EXTRA_USER_XMT_BUFFERS      12   // Extra user buffers that the data source can send to us as a read ahead.
#define DV_NUM_OF_XMT_BUFFERS               (NUM_BUF_ATTACHED_THEN_ISOCH + DV_NUM_EXTRA_USER_XMT_BUFFERS)




//
// The "signature" of the header section of Seq0 of incoming source packets:
//
// "Blue" book, Part2, 11.4 (page 50); Figure 66, table 36 (page 111)
//
// ID0 = {SCT2,SCT1,SCT0,RSV,Seq3,Seq2,Seq1,Seq0} = {0,0,0,1, 1,1,1,1} = 0x1f
//
//     SCT2-0 = {0,0,0}
//     RSV    = {1}
//     Seq3-0 = {1,1,1,1} for NoInfo or {0,0,0,} for Sequence 0
//
// ID1 = {DSeq3-0, 0, RSV, RSV, RSV} = {0,0,0,0, 0,1,1,1} = 0x07
//     DSeq3-0 = {0, 0, 0, 0}  // Start from seq 0
//
#define ID0_SEQ0_HEADER_MASK    0xf0 // 11110000  Seq3-0 = xxxx Don't care!; check only SCT2-0:000 and RSV:1
#define ID0_SEQ0_HEADER_NO_INFO 0x1f // 00011111  Seq3-0 = 1111 no data     (Most of Consumer DV)
#define ID0_SEQ0_HEADER_0000    0x10 // 00010000  Seq3-0 = 0000 sequence 0  (DVCPRO)
#define ID1_SEQ0_HEADER         0x07 // 00000111 


//
// AV/C command response data definition
//
#define AVC_SUBTYPE_MASK    0xf8
#define AVC_DEVICE_TAPE_REC 0x20  // 00100:000
#define AVC_DEVICE_CAMERA   0x38  // 00111:000
#define AVC_DEVICE_TUNER    0x28  // 00101:000
#define AVC_DEVICE_UNKNOWN  0xff  // 11111:111



//
// GUID definitions for pins and DV format types.
//

// DV vid only output pin
#define STATIC_PINNAME_DV_VID_OUTPUT \
    0x5b21c540L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c540-7aee-11d1-883b-006097f05c70", PINNAME_DV_VID_OUTPUT);
#define PINNAME_DV_VID_OUTPUT DEFINE_GUIDNAMED(PINNAME_DV_VID_OUTPUT)
#define PINNAME_VID_OUT PINNAME_DV_VID_OUTPUT

// DV A/V output pin
#define STATIC_PINNAME_DV_AV_OUTPUT \
    0x5b21c541L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c540-7aee-11d1-883b-006097f05c70", PINNAME_DV_AV_OUTPUT);
#define PINNAME_DV_AV_OUTPUT DEFINE_GUIDNAMED(PINNAME_DV_AV_OUTPUT)
#define PINNAME_AV_OUTPUT PINNAME_DV_AV_OUTPUT

// DV A/V input pin
#define STATIC_PINNAME_DV_AV_INPUT \
    0x5b21c543L, 0x7aee, 0x11d1, 0x88, 0x3b, 0x00, 0x60, 0x97, 0xf0, 0x5c, 0x70
DEFINE_GUIDSTRUCT("5b21c543-7aee-11d1-883b-006097f05c70", PINNAME_DV_AV_INPUT);
#define PINNAME_DV_AV_INPUT DEFINE_GUIDNAMED(PINNAME_DV_AV_INPUT)
#define PINNAME_AV_INPUT PINNAME_DV_AV_INPUT


// MPEG2TS Output pin
#define STATIC_PINNAME_MPEG2TS_OUTPUT \
    0x2CFF7B83L, 0x96F1, 0x47e3, 0x98, 0xEC, 0x57, 0xBD, 0x8A, 0x99, 0x72, 0x15
    DEFINE_GUIDSTRUCT("2CFF7B83-96F1-47e3-98EC-57BD8A997215", PINNAME_MPEG2TS_OUTPUT);
#define PINNAME_MPEG2TS_OUTPUT DEFINE_GUIDNAMED(PINNAME_MPEG2TS_OUTPUT)
#define PINNAME_AV_MPEG2TS_OUTPUT PINNAME_MPEG2TS_OUTPUT

// MPEG2TS Input pin
#define STATIC_PINNAME_MPEG2TS_INPUT \
    0xCF4C59A3L, 0xACE3, 0x444B, 0x8C, 0x37, 0xB, 0x22, 0x66, 0x1A, 0x4A, 0x29
    DEFINE_GUIDSTRUCT("CF4C59A3-ACE3-444b-8C37-0B22661A4A29", PINNAME_MPEG2TS_INPUT);
#define PINNAME_MPEG2TS_INPUT DEFINE_GUIDNAMED(PINNAME_MPEG2TS_INPUT)
#define PINNAME_AV_MPEG2TS_INPUT PINNAME_MPEG2TS_INPUT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpguts.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MsTpGuts.h

Abstract:

    Header file MsTpGuts.c

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/


//
// Device SRB
//

NTSTATUS
AVCTapeInitialize(
    IN PDVCR_EXTENSION  pDevExt,
    IN PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    IN PAV_61883_REQUEST pAVReq
    );

NTSTATUS
AVCTapeInitializeCompleted(
    IN PDVCR_EXTENSION  pDevExt
    );

NTSTATUS
AVCTapeGetStreamInfo(
    IN PDVCR_EXTENSION        pDevExt,
    IN ULONG                  ulBytesToTransfer, 
    IN PHW_STREAM_HEADER      pStreamHeader,       
    IN PHW_STREAM_INFORMATION pStreamInfo
    );

BOOL 
AVCTapeVerifyDataFormat(
    IN  ULONG  NumOfPins,
    PKSDATAFORMAT  pKSDataFormatToVerify, 
    ULONG          StreamNumber,
    ULONG          ulSupportedFrameSize,
    STREAM_INFO_AND_OBJ * paCurrentStrmInfo	
    );

NTSTATUS
AVCTapeGetDataIntersection(
    IN  ULONG  NumOfPins,
    IN  ULONG          ulStreamNumber,
    IN  PKSDATARANGE   pDataRange,
    OUT PVOID          pDataFormatBuffer,
    IN  ULONG          ulSizeOfDataFormatBuffer,
    IN  ULONG          ulSupportedFrameSize,
    OUT ULONG          *pulActualBytesTransferred,
    STREAM_INFO_AND_OBJ * paCurrentStrmInfo
#ifdef SUPPORT_NEW_AVC
    ,
    IN HANDLE  hPlugLocalOut,
    IN HANDLE  hPlugLocalIn
#endif
    );

NTSTATUS
AVCTapeOpenStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    );

NTSTATUS
AVCTapeCloseStream(
    IN PHW_STREAM_OBJECT pStrmObject,
    IN PKSDATAFORMAT     pOpenFormat,
    IN PAV_61883_REQUEST    pAVReq
    );

NTSTATUS
DVChangePower(
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST pAVReq,
    DEVICE_POWER_STATE NewPowerState
    );

NTSTATUS
AVCTapeSurpriseRemoval(
    PDVCR_EXTENSION pDevExt,
    PAV_61883_REQUEST  pAVReq
    );

NTSTATUS
AVCTapeProcessPnPBusReset(
    PDVCR_EXTENSION pDevExt
    );

NTSTATUS
AVCTapeUninitialize(
    IN PDVCR_EXTENSION  pDevExt
    );

//
// Stream SRB
//

NTSTATUS
AVCTapeReqReadDataCR(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP  pIrp,
    IN PDRIVER_REQUEST  pDriverReq
    );

NTSTATUS
AVCTapeGetStreamState(
    PSTREAMEX  pStrmExt,
    IN PDEVICE_OBJECT DeviceObject,
    PKSSTATE   pStreamState,
    PULONG     pulActualBytesTransferred
    );

NTSTATUS
AVCTapeSetStreamState(
    PSTREAMEX        pStrmExt,
    PDVCR_EXTENSION  pDevExt,
    PAV_61883_REQUEST   pAVReq,
    KSSTATE          StreamState
    );

NTSTATUS 
DVGetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DVSetStreamProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
AVCTapeCreateAbortWorkItem(
    PDVCR_EXTENSION pDevExt,
    PSTREAMEX pStrmExt
    );

VOID
DVCRCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    );

VOID
DVCRCancelAllPackets(
    IN PSTREAMEX        pStrmExt,
    IN PDVCR_EXTENSION  pDevExt
    );

VOID
DVTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS 
AVCTapeOpenCloseMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    );

NTSTATUS 
AVCTapeIndicateMasterClock (
    PSTREAMEX  pStrmExt,
    HANDLE  hMasterClockHandle
    );

VOID
AVCTapeRcvDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
AVCTapeRcvControlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );
NTSTATUS 
AVCTapeEventHandler(
    IN PHW_EVENT_DESCRIPTOR pEventDescriptor
    );
VOID
AVCTapeSignalClockEvent(
    IN PKDPC Dpc,
    
    IN PSTREAMEX  pStrmExt,

    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2    
    );
VOID 
AVCTapeStreamClockRtn(
    IN PHW_TIME_CONTEXT TimeContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstputil.h ===
//
// Copyright (C) Microsoft Corporation, 1999 - 2000  
//
// MsTpUtil.h
//


VOID
DVDelayExecutionThread(
    ULONG ulDelayMSec
    );

NTSTATUS
DVSubmitIrpSynch(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq
    );

//
// Related to DeviceControl
//
#ifdef SUPPORT_LOCAL_PLUGS
BOOL
AVCTapeCreateLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    IN CMP_PLUG_TYPE PlugType,
    IN AV_PCR *pPCR,
    OUT ULONG *pPlugNumber,
    OUT HANDLE *pPlugHandle
    );

BOOL
AVCTapeDeleteLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    OUT ULONG *pPlugNumber,
    OUT HANDLE *pPlugHandle
    );
BOOL
AVCTapeSetLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    IN HANDLE *pPlugHandle,
    IN AV_PCR *pPCR
    );
#endif

NTSTATUS
AVCDevGetDevPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
   );

NTSTATUS
AVCDevGetPlugState(
    IN PDVCR_EXTENSION  pDevExt,
    IN HANDLE  hPlug,
    OUT CMP_GET_PLUG_STATE *pPlugState
    );

NTSTATUS
DVGetUnitCapabilities(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq
    );

BOOL
DVGetDevModeOfOperation(   
    PDVCR_EXTENSION  pDevExt
    );

BOOL
DVGetDevIsItDVCPro(   
    IN PDVCR_EXTENSION  pDevExt
    );

BOOL
DVGetDevSignalFormat(
    IN PDVCR_EXTENSION  pDevExt,
    IN KSPIN_DATAFLOW   DataFlow,
    IN PSTREAMEX        pStrmExt
    );

BOOL 
DVCmpGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    IN BOOL fCompareFormatSize
    );

ULONGLONG 
GetSystemTime(
    );

VOID
DvFreeTextualString(
  PDVCR_EXTENSION pDevExt,
  GET_UNIT_IDS  * pUnitIds
  );


#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA
VOID
DVCRExtractTimecodeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    );
#endif

#ifdef MSDV_SUPPORT_EXTRACT_DV_DATE_TIME
VOID
DVCRExtractRecDateAndTimeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    );
#endif

#ifdef MSDV_SUPPORT_MUTE_AUDIO
BOOL
DVMuteDVFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN OUT PUCHAR      pFrameBuffer,
    IN BOOL            bMute     // TRUE to mute; FALSE to un-Mute
    );
#endif

BOOL
DVGetPropertyValuesFromRegistry(
    IN PDVCR_EXTENSION  pDevExt
    );

BOOL
DVSetPropertyValuesToRegistry(	
    PDVCR_EXTENSION  pDevExt
    );

BOOL
DVAccessDeviceInterface(
    IN PDVCR_EXTENSION  pDevExt,
    IN const ULONG ulNumCategories,
    IN GUID DVCategories[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstpuppr.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MSTpUppr.c

Abstract:

    Interface code with stream class driver.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "MsTpFmt.h"
#include "MsTpDef.h"
#include "MsTpGuts.h"  // Function prototypes
#include "MsTpAvc.h"

#include "EDevCtrl.h"

#ifdef TIME_BOMB
#include "..\..\inc\timebomb.c"
#endif

#if DBG
LONG MSDVCRMutextUseCount = 0;
#endif


// global flag for debugging.  Inlines are defined in dbg.h.  The debug level is set for
// minimal amount of messages.
#if DBG

#define TraceMaskCheckIn  TL_PNP_ERROR | TL_STRM_ERROR

#define TraceMaskDefault  TL_PNP_ERROR   | TL_PNP_WARNING \
                          | TL_61883_ERROR | TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  \
                          | TL_STRM_ERROR  | TL_STRM_WARNING \
                          | TL_CLK_ERROR

#define TraceMaskDebug    TL_PNP_ERROR  | TL_PNP_WARNING \
                          | TL_61883_ERROR| TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  | TL_FCP_WARNING \
                          | TL_STRM_ERROR | TL_STRM_WARNING \
                          | TL_CLK_ERROR


ULONG TapeTraceMask   = TraceMaskCheckIn;
ULONG TapeAssertLevel = 1;

#endif


extern AVCSTRM_FORMAT_INFO  AVCStrmFormatInfoTable[];

//
// Function prototypes
//
VOID
DVRcvStreamDevicePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );
VOID
DVSRBRead(
    IN PKSSTREAM_HEADER pStrmHeader,
    IN ULONG            ulFrameSize,
    IN PDVCR_EXTENSION  pDevExt,
    IN PSTREAMEX        pStrmExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb        // needs Srb->Status 
    );
BOOL
DVSignalEOStream(    
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PSTREAMEX                pStrmExt,
    IN FMT_INDEX                ulVideoFormatIndex,
    IN ULONG                    ulOptionFlags
    );
NTSTATUS
DVAttachWriteFrame(
    IN PSTREAMEX  pStrmExt
    );
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    ); 

#if 0  // Enable later
#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DVRcvStreamDevicePacket)
     #pragma alloc_text(PAGE, AVCTapeRcvControlPacket)
     #pragma alloc_text(PAGE, AVCTapeRcvDataPacket)
     // #pragma alloc_text(INIT, DriverEntry)
#endif
#endif


VOID
DVRcvStreamDevicePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    This is where most of the interesting Stream requests come to us

--*/
{
    PDVCR_EXTENSION  pDevExt;  
    PAV_61883_REQUEST  pAVReq;
    PIO_STACK_LOCATION  pIrpStack;


    PAGED_CODE();


    //
    // Get these extensions from a SRB
    //
    pDevExt = (PDVCR_EXTENSION) pSrb->HwDeviceExtension; 
    pAVReq  = (PAV_61883_REQUEST) pSrb->SRBExtension;       // Use in IrpSync is OK, 
                             
#if DBG
    if(pSrb->Command != SRB_INITIALIZE_DEVICE && // PowerState is initialize in this SRB so ignore it.
       pDevExt->PowerState != PowerDeviceD0) {
        TRACE(TL_PNP_WARNING,("RcvDevPkt; pSrb:%x; Cmd:%x; Dev is OFF state\n", pSrb, pSrb->Command));
    }
#endif

    TRACE(TL_PNP_TRACE,("StreamDevicePacket: pSrb %x, Cmd %d, pdevExt %x\n", pSrb, pSrb->Command, pDevExt));

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

    case SRB_INITIALIZE_DEVICE:

        ASSERT(((PPORT_CONFIGURATION_INFORMATION) pSrb->CommandData.ConfigInfo)->HwDeviceExtension == pDevExt);
        pSrb->Status = 
            AVCTapeInitialize(
                (PDVCR_EXTENSION) ((PPORT_CONFIGURATION_INFORMATION)pSrb->CommandData.ConfigInfo)->HwDeviceExtension,
                pSrb->CommandData.ConfigInfo,
                pAVReq
                );
        break;



    case SRB_INITIALIZATION_COMPLETE:

        //
        // Stream class has finished initialization.
        // Now create DShow Medium interface BLOBs.
        // This needs to be done at low priority since it uses the registry, so use a callback
        //
        pSrb->Status = 
            AVCTapeInitializeCompleted(
                pDevExt
                );
        break;


    case SRB_GET_STREAM_INFO:

        //
        // this is a request for the driver to enumerate requested streams
        //
        pSrb->Status = 
            AVCTapeGetStreamInfo(
                pDevExt,
                pSrb->NumberOfBytesToTransfer,
                &pSrb->CommandData.StreamBuffer->StreamHeader,
                &pSrb->CommandData.StreamBuffer->StreamInfo
                );
        break;



    case SRB_GET_DATA_INTERSECTION:

        pSrb->Status = 
            AVCTapeGetDataIntersection(
                pDevExt->NumOfPins,
                pSrb->CommandData.IntersectInfo->StreamNumber,
                pSrb->CommandData.IntersectInfo->DataRange,
                pSrb->CommandData.IntersectInfo->DataFormatBuffer,
                pSrb->CommandData.IntersectInfo->SizeOfDataFormatBuffer,
                AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize,
                &pSrb->ActualBytesTransferred,
                pDevExt->pStreamInfoObject
#ifdef SUPPORT_NEW_AVC
                ,
                pDevExt->hPlugLocalOut,
                pDevExt->hPlugLocalIn
#endif
                );
        break;



    case SRB_OPEN_STREAM:

        //
        // Serialize SRB_OPEN_STREAMs
        //

        KeWaitForMutexObject(&pDevExt->hMutex, Executive, KernelMode, FALSE, NULL);

        pSrb->Status = 
            AVCTapeOpenStream(
                pSrb->StreamObject,
                pSrb->CommandData.OpenFormat,
                pAVReq
                );

        KeReleaseMutex(&pDevExt->hMutex, FALSE); 

        break;



    case SRB_CLOSE_STREAM:

        KeWaitForMutexObject(&pDevExt->hMutex, Executive, KernelMode, FALSE, NULL);
        pSrb->Status = 
            AVCTapeCloseStream(
                pSrb->StreamObject,
                pSrb->CommandData.OpenFormat,
                pAVReq
                );
        KeReleaseMutex(&pDevExt->hMutex, FALSE); 
        break;



    case SRB_GET_DEVICE_PROPERTY:

        pSrb->Status = 
            AVCTapeGetDeviceProperty(
                pDevExt,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
        break;

        
    case SRB_SET_DEVICE_PROPERTY:

        pSrb->Status = 
            AVCTapeSetDeviceProperty(
                pDevExt,
                pSrb->CommandData.PropertyInfo,
                &pSrb->ActualBytesTransferred
                );
        break;



    case SRB_CHANGE_POWER_STATE:
            
        pIrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

        if(pIrpStack->MinorFunction == IRP_MN_SET_POWER) {
            pSrb->Status = 
                DVChangePower(
                    (PDVCR_EXTENSION) pSrb->HwDeviceExtension,
                    pAVReq,
                    pSrb->CommandData.DeviceState
                    );
        } else 
        if(pIrpStack->MinorFunction == IRP_MN_QUERY_POWER) {
            TRACE(TL_PNP_WARNING,("IRP_MN_QUERY_POWER: PwrSt:%d\n", pDevExt->PowerState)); 
            pSrb->Status = STATUS_SUCCESS;
        }
        else {
            TRACE(TL_PNP_WARNING,("Not Supported POWER_STATE MinorFunc:%d\n", pIrpStack->MinorFunction)); 
            pSrb->Status = STATUS_NOT_IMPLEMENTED; // STATUS_NOT_SUPPORTED;
        }

        break;


    case SRB_UNKNOWN_DEVICE_COMMAND:

        //
        // We might be interested in unknown commands if they pertain
        // to bus resets.  Bus resets are important cuz we need to know
        // what the current generation count is.
        //
        pIrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

        if(pIrpStack->MajorFunction == IRP_MJ_PNP) {
            if(pIrpStack->MinorFunction == IRP_MN_BUS_RESET) {
            
                AVCTapeProcessPnPBusReset(
                    pDevExt
                    );
                
                //  Always success                
                pSrb->Status = STATUS_SUCCESS;
            }        
            else  {
                TRACE(TL_PNP_TRACE,("StreamDevicePacket: NOT_IMPL; IRP_MJ_PNP Min:%x\n",                  
                    pIrpStack->MinorFunction
                    )); 
                pSrb->Status = STATUS_NOT_IMPLEMENTED; // SUPPORTED;
            } 
        }
        else 
            pSrb->Status = STATUS_NOT_IMPLEMENTED; // SUPPORTED;
        break;


    case SRB_SURPRISE_REMOVAL:

        TRACE(TL_PNP_WARNING,("#SURPRISE_REMOVAL# pSrb %x, pDevExt %x\n", pSrb, pDevExt));
        pSrb->Status = 
             AVCTapeSurpriseRemoval(
                 pDevExt,
                 pAVReq
                 );
        break;            


        
    case SRB_UNINITIALIZE_DEVICE:

        TRACE(TL_PNP_WARNING,("#UNINITIALIZE_DEVICE# pSrb %x, pDevExt %x\n", pSrb, pDevExt));                   
        pSrb->Status = 
            AVCTapeUninitialize(
                (PDVCR_EXTENSION) pSrb->HwDeviceExtension
                );          
        break;           


    default:
            
        TRACE(TL_PNP_WARNING,("StreamDevicePacket: Unknown or unprocessed SRB cmd %x\n", pSrb->Command));

        //
        // this is a request that we do not understand.  Indicate invalid
        // command and complete the request
        //

        pSrb->Status = STATUS_NOT_IMPLEMENTED; 
    }

    //
    // NOTE:
    //
    // all of the commands that we do, or do not understand can all be completed
    // synchronously at this point, so we can use a common callback routine here.
    // If any of the above commands require asynchronous processing, this will
    // have to change
    //
#if DBG
    if (pSrb->Status != STATUS_SUCCESS && 
        pSrb->Status != STATUS_NOT_SUPPORTED &&
        pSrb->Status != STATUS_NOT_IMPLEMENTED &&
        pSrb->Status != STATUS_BUFFER_TOO_SMALL &&
        pSrb->Status != STATUS_BUFFER_OVERFLOW &&
        pSrb->Status != STATUS_NO_MATCH
        ) {
        TRACE(TL_PNP_WARNING,("StreamDevicePacket:pSrb->Command(0x%x) does not return STATUS_SUCCESS or NOT_IMPLEMENTED but 0x%x\n", pSrb->Command, pSrb->Status));
    }
#endif

    if(STATUS_PENDING != pSrb->Status) {

        StreamClassDeviceNotification(
            DeviceRequestComplete,
            pSrb->HwDeviceExtension,
           pSrb
           );
    } 
    else {

        // Pending pSrb which will be completed asynchronously
        TRACE(TL_PNP_WARNING,("ReceiveDevicePacket:Pending pSrb %x\n", pSrb));
    }
}



VOID
AVCTapeRcvControlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Called with packet commands that control the video stream

--*/
{
    PAV_61883_REQUEST   pAVReq;
    PSTREAMEX        pStrmExt;
    PDVCR_EXTENSION  pDevExt;


    PAGED_CODE();

    //
    // Get these three extension from SRB
    //
    pAVReq   = (PAV_61883_REQUEST) pSrb->SRBExtension;  // This is OK to be used us IrpSync operation
    pDevExt  = (PDVCR_EXTENSION) pSrb->HwDeviceExtension;
    pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;      // Only valid in SRB_OPEN/CLOSE_STREAM
    ASSERT(pStrmExt && pDevExt && pAVReq);

    //
    // Default to success
    //
    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

    case SRB_GET_STREAM_STATE:

        pSrb->Status =
            AVCTapeGetStreamState( 
                pStrmExt,
                pDevExt->pBusDeviceObject,
                &(pSrb->CommandData.StreamState),
                &(pSrb->ActualBytesTransferred)
                );
        break;
            
    case SRB_SET_STREAM_STATE:
            
        pSrb->Status =
            AVCTapeSetStreamState(
                pStrmExt,
                pDevExt,
                pAVReq,
                pSrb->CommandData.StreamState   // Target KSSTATE
               );       
        break;

        
    case SRB_GET_STREAM_PROPERTY:

        pSrb->Status =
            DVGetStreamProperty( 
                pSrb 
                );
        break;


    case SRB_SET_STREAM_PROPERTY:

        pSrb->Status =        
            DVSetStreamProperty( 
                pSrb 
                );
        break;

    case SRB_OPEN_MASTER_CLOCK:
    case SRB_CLOSE_MASTER_CLOCK:

        //
        // This stream is being selected to provide a Master clock.
        //
        pSrb->Status =
            AVCTapeOpenCloseMasterClock(                 
                pStrmExt, 
                pSrb->Command == SRB_OPEN_MASTER_CLOCK ? pSrb->CommandData.MasterClockHandle: NULL);
        break;

    case SRB_INDICATE_MASTER_CLOCK:

        //
        // Assigns a clock to a stream.
        //
        pSrb->Status = 
            AVCTapeIndicateMasterClock(
                pStrmExt, 
                pSrb->CommandData.MasterClockHandle);
        break;

    case SRB_PROPOSE_DATA_FORMAT:
    
        //
        // The SRB_PROPOSE_DATA_FORMAT command queries the minidriver
        // to determine if the minidriver can change the format of a 
        // particular stream. If the minidriver is able to switch the 
        // stream to the specified format, STATUS_SUCCESS is returned. 
        // Note that this function only proposes a new format, but does
        // not change it. 
        //
        // The CommandData.OpenFormat passes the format to validate.
        // If the minidriver is able to accept the new format, at some 
        // later time the class driver may send the minidriver a format 
        // change, which is indicated by an OptionsFlags flag in a 
        // KSSTREAM_HEADER structure. 
        //
 
        if(!AVCTapeVerifyDataFormat(
            pDevExt->NumOfPins,
            pSrb->CommandData.OpenFormat, 
            pSrb->StreamObject->StreamNumber,
            AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize,
            pDevExt->pStreamInfoObject
            ))  {
            TRACE(TL_PNP_WARNING,("RcvControlPacket: AdapterVerifyFormat failed.\n"));
            pSrb->Status = STATUS_NO_MATCH;
        }
        break;
 
    default:

        //
        // invalid / unsupported command. Fail it as such
        //
        TRACE(TL_PNP_WARNING,("RcvControlPacket: unknown cmd = %x\n",pSrb->Command));
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    TRACE(TL_PNP_TRACE,("RcvControlPacket: pSrb:%x, Command %x, ->Status %x, ->CommandData %x\n",
         pSrb, pSrb->Command, pSrb->Status, &(pSrb->CommandData.StreamState) ));

    StreamClassStreamNotification(          
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb);
}




VOID
AVCTapeRcvDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called with video data packet commands

--*/

{
    PSTREAMEX       pStrmExt;
    PDVCR_EXTENSION pDevExt;
    PAVC_STREAM_REQUEST_BLOCK  pAVCStrmReq;
    PIRP  pIrpReq;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS Status;
    PDRIVER_REQUEST pDriverReq;
    KIRQL oldIrql;


    
    PAGED_CODE();

    pStrmExt = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;  
    pDevExt  = (PDVCR_EXTENSION) pSrb->HwDeviceExtension;

#if DBG
    if(pDevExt->PowerState != PowerDeviceD0) {
        TRACE(TL_PNP_WARNING,("SRB_READ/WRITE; PowerSt:OFF; pSrb:%x\n", pSrb));
    }
#endif

    // The stream has to be open before we can do anything.
    if (pStrmExt == NULL) {
        TRACE(TL_STRM_TRACE,("RcvDataPacket: stream not opened for SRB %x. kicking out...\n", pSrb->Command));
        pSrb->Status = STATUS_UNSUCCESSFUL;
        pSrb->CommandData.DataBufferArray->DataUsed = 0;
        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
        return;        
    }


    TRACE(TL_PNP_TRACE,("XXX_DATA(%d, %d);Srb:%x;Flg:%x;FExt:%d:%d\n", 
        (DWORD) pStrmExt->cntSRBReceived, 
        (DWORD) pSrb->CommandData.DataBufferArray->PresentationTime.Time/10000,
        pSrb, 
        pSrb->CommandData.DataBufferArray->OptionsFlags,
        pSrb->CommandData.DataBufferArray->FrameExtent,
        AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize
        ));

    // If we has asked to stopped, we should not receive data request.
    ASSERT(pStrmExt->StreamState != KSSTATE_STOP);

    //
    // determine the type of packet.
    //
    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {


    case SRB_WRITE_DATA:

        // ********************************
        // Take care of some special cases:
        // ********************************

        // Can signal this when the last is transmitted or sigal it immediately like 
        // what is done here.
        if(pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
            // Optional, wait a fix time and can be signalled when the last one has returned.
            // And then signal the completion.

            TRACE(TL_STRM_WARNING,("RcvDataPacket: EndOfStream is signalled!\n"));
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            pSrb->Status = STATUS_SUCCESS;

            //
            // Send this flag down to AVCStrm.sys so it will wait until 
            // all attach buffers are completed.
            //

        } else if (pSrb->CommandData.DataBufferArray->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
            TRACE(TL_PNP_WARNING,("RcvDataPacket:KSSTREAM_HEADER_OPTIONSF_TYPECHANGED.\n"));
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            // May need to compare the data format; instead of return STATUS_SUCCESS??
            pSrb->Status = STATUS_SUCCESS; // May need to check the format when dynamic format change is allowed.
            break; 
        }

    case SRB_READ_DATA:

        //
        // If removed, cancel the request with STATUS_DEVICE_REMOVED. 
        // (apply to both SRB_READ_DATA and SRB_WRITE_DATA)
        //
        if(pDevExt->bDevRemoved) {
            TRACE(TL_STRM_WARNING,("SRB_READ/WRITE; DevRemoved!\n", pSrb));
            pSrb->Status = STATUS_DEVICE_REMOVED;
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            break;
        }

        //
        // A true data request must has a MdlAddress unless it is a know 
        // optional flag.
        //
        if(pSrb->Irp->MdlAddress == NULL) {
            if((pSrb->CommandData.DataBufferArray->OptionsFlags & 
                (KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM | KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) )) {
                //
                // Known optional flags
                //
            } else {
                TRACE(TL_STRM_ERROR,("pSrb:%x, unknown OptionsFlags:%x\n",pSrb, pSrb->CommandData.DataBufferArray->OptionsFlags));
                ASSERT(pSrb->Irp->MdlAddress);
                break;
                
                //
                // We do not know how to handle this option flag so we will quit on this data request.
                //
            }
        }

        // 
        // Serialize with setting state
        //
        EnterAVCStrm(pStrmExt->hMutexReq);

        //
        // Get a context to send this request down
        //
        KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql); 

        pStrmExt->cntSRBReceived++;

        if(IsListEmpty(&pStrmExt->DataDetachedListHead)) {
            TRACE(TL_STRM_ERROR,("**** DataDetachList is empty! ****\n"));
            ASSERT(!IsListEmpty(&pStrmExt->DataDetachedListHead));

            //
            // Note: The alternative to the failure is to expand the pre-allocated list.
            //

            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
            LeaveAVCStrm(pStrmExt->hMutexReq);
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            pSrb->CommandData.DataBufferArray->DataUsed = 0;
            break;
        } else {

            pDriverReq = (PDRIVER_REQUEST) RemoveHeadList(&pStrmExt->DataDetachedListHead); pStrmExt->cntDataDetached--;          
#if DBG
            pDriverReq->cntDataRequestReceived = pStrmExt->cntSRBReceived;  // For verification
#endif
            InsertTailList(&pStrmExt->DataAttachedListHead, &pDriverReq->ListEntry); pStrmExt->cntDataAttached++;

            pAVCStrmReq = &pDriverReq->AVCStrmReq;
            pIrpReq     = pDriverReq->pIrp;
            KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);
        }

        RtlZeroMemory(pAVCStrmReq, sizeof(AVC_STREAM_REQUEST_BLOCK));
        INIT_AVCSTRM_HEADER(pAVCStrmReq, (pSrb->Command == SRB_READ_DATA) ? AVCSTRM_READ : AVCSTRM_WRITE);
        pAVCStrmReq->AVCStreamContext = pStrmExt->AVCStreamContext;
        // Need these context when this IRP is completed.
        pDriverReq->Context1 = (PVOID) pSrb;
        pDriverReq->Context2 = (PVOID) pStrmExt;

        // We are the clock provide if hMasterClock is not NULL.
        pAVCStrmReq->CommandData.BufferStruct.ClockProvider = (pStrmExt->hMasterClock != NULL);
        pAVCStrmReq->CommandData.BufferStruct.ClockHandle   =  pStrmExt->hClock;  // Used only if !ClockProvider

        pAVCStrmReq->CommandData.BufferStruct.StreamHeader = pSrb->CommandData.DataBufferArray;

        //
        // This could be a data or just flag that need to be processed.
        // Get its system address only if there is an MdlAddress.
        //
        if(pSrb->Irp->MdlAddress) {

            pAVCStrmReq->CommandData.BufferStruct.FrameBuffer =             
#ifdef USE_WDM110   // Win2000, XP
                MmGetSystemAddressForMdlSafe(pSrb->Irp->MdlAddress, NormalPagePriority);
            if(!pAVCStrmReq->CommandData.BufferStruct.FrameBuffer) {
                
                //
                // Reclaim the data entry from attach (busy) to detach (free)
                //
                KeAcquireSpinLock(pStrmExt->DataListLock, &oldIrql); 
                RemoveEntryList(&pDriverReq->ListEntry);  pStrmExt->cntDataAttached--;
                InsertHeadList(&pStrmExt->DataAttachedListHead, &pDriverReq->ListEntry); pStrmExt->cntDataAttached++;
                KeReleaseSpinLock(pStrmExt->DataListLock, oldIrql);

                pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
                pSrb->CommandData.DataBufferArray->DataUsed = 0;
                ASSERT(pAVCStrmReq->CommandData.BufferStruct.FrameBuffer);
                break;
            }
#else               // Win9x
                MmGetSystemAddressForMdl    (pSrb->Irp->MdlAddress);
#endif        
        }

        // This is a Async command
        NextIrpStack = IoGetNextIrpStackLocation(pIrpReq);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_AVCSTRM_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pAVCStrmReq;

        // Not cancellable!
        IoSetCancelRoutine(
            pIrpReq,
            NULL
            );

        IoSetCompletionRoutine( 
            pIrpReq,
            AVCTapeReqReadDataCR,
            pDriverReq,
            TRUE,  // Success
            TRUE,  // Error
            TRUE   // or Cancel
            );

        pSrb->Status = STATUS_PENDING;
        pStrmExt->cntDataSubmitted++;

        Status = 
            IoCallDriver(
                pDevExt->pBusDeviceObject,
                pIrpReq
                );

        LeaveAVCStrm(pStrmExt->hMutexReq);

        if(Status == STATUS_PENDING) {
            // Normal case.
            return;  // Will complete asychronousely (Success, Error, or Cancel)
        } else {
            //
            // Complete the data request synchronousely (no pending)
            //
            if(pDriverReq->Context1 == NULL || pDriverReq->Context2 == NULL) {
                TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("pSrb:%x; SRB_READ_DATA/WRITE IRP completed with Status;%x\n", pSrb, Status));
                return;
            } else {
                TRACE(TL_STRM_WARNING,("AVCSTRM_READ/WRITE: pSrb %x; failed or completed with ST:%x; pAVCStrmReq:%x\n", pSrb, Status, pAVCStrmReq));
                ASSERT(FALSE);
                // Complete the SRB if not pending
                pSrb->Status = pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_UNSUCCESSFUL;
                pSrb->CommandData.DataBufferArray->DataUsed = 0;
            }
        }

        break;
            
    default:
        //
        // invalid / unsupported command. Fail it as such
        //
        pSrb->Status = STATUS_NOT_SUPPORTED;
        break;
    }   


    ASSERT(pSrb->Status != STATUS_PENDING);

    // Finally, send the srb back up ...
    StreamClassStreamNotification( 
        StreamRequestComplete,
        pSrb->StreamObject,
        pSrb );
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This where life begins for a driver.  The stream class takes care
    of alot of stuff for us, but we still need to fill in an initialization
    structure for the stream class and call it.

Arguments:

    Context1 - DriverObject
    Context2 - RegistryPath

Return Value:

    The function value is the final status from the initialization operation.

--*/
{

    HW_INITIALIZATION_DATA HwInitData;


    TRACE(TL_PNP_ERROR,("<<<<<<< MSTape.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        TRACE(TL_PNP_ERROR, ("Evaluation period expired!") );
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("TapeTraceMask=0x%.8x = 0x[7][6][5][4][3][2][1][0] where\n", TapeTraceMask));
    TRACE(TL_PNP_ERROR,("\n"));
    TRACE(TL_PNP_ERROR,("PNP:   [0]:Loading, power state, surprise removal, device SRB..etc.\n"));
    TRACE(TL_PNP_ERROR,("61883: [1]:Plugs, connection, CMP info and call to 61883.\n"));
    TRACE(TL_PNP_ERROR,("CIP:   [2]:Isoch data transfer.\n"));
    TRACE(TL_PNP_ERROR,("AVC:   [3]:AVC commands.\n"));
    TRACE(TL_PNP_ERROR,("Stream:[4]:Data intersec, open/close,.state, property etc.\n"));
    TRACE(TL_PNP_ERROR,("Clock: [5]:Clock (event and signal)etc.\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("dd mstape!TapeTraceMask L1\n"));
    TRACE(TL_PNP_ERROR,("e mstape!TapeTraceMask <new value> <enter>\n"));
    TRACE(TL_PNP_ERROR,("<for each nibble: ERROR:8, WARNING:4, TRACE:2, INFO:1, MASK:f>\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n\n"));


    //
    // Fill in the HwInitData structure    
    //
    RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);
    HwInitData.HwInterrupt              = NULL;

    HwInitData.HwReceivePacket          = DVRcvStreamDevicePacket;
    HwInitData.HwRequestTimeoutHandler  = DVTimeoutHandler; 
    HwInitData.HwCancelPacket           = DVCRCancelOnePacket;
    HwInitData.DeviceExtensionSize      = sizeof(DVCR_EXTENSION) +     
                                          sizeof(AVC_DEV_PLUGS) * 2;

    //
    // The ULONG is used in SRB_WRITE_DATA to keep track of 
    // number of times the same SRB was attached for transmit.
    // 
    // Data SRB: ULONG is used (< sizeof(AV_61883_REQ)
    // DeviceControl or StreamControl Srb: AV_61883_REQ is used.
    HwInitData.PerRequestExtensionSize  = sizeof(AV_61883_REQUEST);    // Per SRB
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX);         // Per pin/stream
    HwInitData.FilterInstanceExtensionSize = 0;

    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = sizeof(ULONG) - 1;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    return StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\mstputil.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000  

Module Name:

    MsTpUtil.c

Abstract:

    Provide utility functions for MSTAPE.

Last changed by:
    
    Author:      Yee J. Wu

Environment:

    Kernel mode only

Revision History:

    $Revision::                    $
    $Date::                        $

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "dbg.h"
#include "MsTpFmt.h"
#include "MsTpDef.h"
#include "MsTpAvc.h"
#include "MsTpUtil.h"  

#include "XPrtDefs.h"

#if 0  // Enable later
#ifdef ALLOC_PRAGMA
     #pragma alloc_text(PAGE, DVDelayExecutionThread)
     #pragma alloc_text(PAGE, DVGetUnitCapabilities)
     // Local variables might paged out but the called might use it in DISPATCH level!
     // #pragma alloc_text(PAGE, DVGetDevModeOfOperation)
     // #pragma alloc_text(PAGE, DVGetDevIsItDVCPro)
     // #pragma alloc_text(PAGE, DVGetDevSignalFormat)
     #pragma alloc_text(PAGE, DvAllocatePCResource)
     #pragma alloc_text(PAGE, DvFreePCResource)
     #pragma alloc_text(PAGE, DVGetPlugState)
#endif
#endif

extern AVCSTRM_FORMAT_INFO  AVCStrmFormatInfoTable[];

VOID
DVDelayExecutionThread(
    ULONG ulDelayMSec
    )
/*
    Device might need a "wait" in between AV/C commands.
*/
{
    PAGED_CODE();

    if (ulDelayMSec)
    {
        LARGE_INTEGER tmDelay;   

        TRACE(TL_PNP_TRACE,("DelayExeThrd: %d MSec\n",  ulDelayMSec));
    
        tmDelay.LowPart  =  (ULONG) (-1 * ulDelayMSec * 10000);
        tmDelay.HighPart = -1;
        KeDelayExecutionThread(KernelMode, FALSE, &tmDelay);
    }
}


NTSTATUS
DVIrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          Event
    )
{
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // DVIrpSynchCR


NTSTATUS
DVSubmitIrpSynch(
    IN PDVCR_EXTENSION   pDevExt,
    IN PIRP              pIrp,
    IN PAV_61883_REQUEST pAVReq
    )
{
    NTSTATUS            Status;
    KEVENT              Event;
    PIO_STACK_LOCATION  NextIrpStack;
  

    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAVReq;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        DVIrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->pBusDeviceObject,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_TRACE,("Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("Irp has completed; IoStatus.Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    return Status;
} // DVSubmitIrpSynchAV

#ifdef SUPPORT_LOCAL_PLUGS

BOOL
AVCTapeCreateLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    IN CMP_PLUG_TYPE PlugType,
    IN AV_PCR *pPCR,
    OUT ULONG *pPlugNumber,
    OUT HANDLE *pPlugHandle
    )
/* 
    To be a compliant device, we need to have both input and output 
    plugs in order to do isoch streaming. These plug is belong to 
    the device and is part of the device extension.  In theory, the
    lugs belong to the unit (ei.e. avc.sys) and not this subunit 
    Driver; however, in this case, we create directly from 61883.sys.
*/  
{   
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP pIrp;

    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) 
        return FALSE;
    
    // Create a local oPCR
    // Need to correctly update Overhead_ID and payload fields of PC's own oPCR
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_CreatePlug);

    pAVReq->CreatePlug.Context   = NULL;
    pAVReq->CreatePlug.pfnNotify = NULL; 
    pAVReq->CreatePlug.PlugType  = PlugType;

    if(PlugType == CMP_PlugOut) 
        pAVReq->CreatePlug.Pcr.oPCR = pPCR->oPCR;
    else 
        pAVReq->CreatePlug.Pcr.iPCR = pPCR->iPCR;

    Status = DVSubmitIrpSynch(pDevExt, pIrp, pAVReq);

    if(!NT_SUCCESS(Status)) {
        *pPlugNumber = 0xffffffff;
        *pPlugHandle = 0;
        TRACE(TL_61883_ERROR,("Av61883_CreatePlug (%s) Failed:%x\n", 
            PlugType == CMP_PlugOut ? "oPCR":"iPCR", Status));
    } else {
        *pPlugNumber = pAVReq->CreatePlug.PlugNum;
        *pPlugHandle = pAVReq->CreatePlug.hPlug;
        TRACE(TL_61883_TRACE,("Av61883_CreatePlug (%s): PlugNum:%d, hPlug:%x\n", 
            PlugType == CMP_PlugOut ? "oPCR":"iPCR", *pPlugNumber, *pPlugHandle));
#if DBG
        if(PlugType == CMP_PlugOut) {
            TRACE(TL_61883_WARNING,("Av61883_CreatePlug: oPCR DataRate:%d (%s); Payload:%d, Overhead_ID:0x%x\n",
                pPCR->oPCR.DataRate,
                (pPCR->oPCR.DataRate == CMP_SPEED_S100) ? "S100" :
                (pPCR->oPCR.DataRate == CMP_SPEED_S200) ? "S200" :
                (pPCR->oPCR.DataRate == CMP_SPEED_S400) ? "S400" : "Sxxx",
                pPCR->oPCR.Payload,
                pPCR->oPCR.OverheadID
                ));
        }
#endif        
    }

    IoFreeIrp(pIrp);
    pIrp = NULL;

    return NT_SUCCESS(Status);
}

BOOL
AVCTapeDeleteLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    OUT ULONG *pPlugNumber,
    OUT HANDLE *pPlugHandle
    )
/* 
    Delete a local plug.
*/  
{   
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP pIrp;

    TRACE(TL_61883_TRACE,("Deleting hPlug[%d]:%x\n", *pPlugNumber, *pPlugHandle));

    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) 
        return FALSE;

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_DeletePlug);
    pAVReq->DeletePlug.hPlug = *pPlugHandle;

    Status = DVSubmitIrpSynch(pDevExt, pIrp, pAVReq);

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_DeletePlug Failed; ST:%x\n", Status));        
        // Do not care if this result in error.
    } else {
        *pPlugNumber = 0xffffffff;
        *pPlugHandle = 0;
        TRACE(TL_61883_TRACE,("Av61883_DeltePlug suceeded.\n"));
    }

    IoFreeIrp(pIrp);
    pIrp = NULL;

    return NT_SUCCESS(Status);

}


BOOL
AVCTapeSetLocalPlug(
    IN PDVCR_EXTENSION  pDevExt,
    IN AV_61883_REQUEST * pAVReq,
    IN HANDLE *pPlugHandle,
    IN AV_PCR *pPCR
    )
/* 
    Set the content of a local plug.
*/  
{   
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP pIrp;

    pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE);
    if(!pIrp) 
        return FALSE;

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_SetPlug);
    pAVReq->SetPlug.hPlug = *pPlugHandle;
    pAVReq->SetPlug.Pcr   = *pPCR;

     TRACE(TL_61883_TRACE,("Av61883_SetPlug hPlug:%x to %x.\n", *pPlugHandle, pPCR->ulongData));

    Status = DVSubmitIrpSynch(pDevExt, pIrp, pAVReq);

#if DBG
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_SetPlug to %x Failed; ST:%x\n", pPCR->ulongData, Status));        
    } 
#endif

    IoFreeIrp(pIrp);
    pIrp = NULL;

    return NT_SUCCESS(Status);
}

#endif // SUPPORT_LOCAL_PLUGS


//
// Get device plug and query its state
//
NTSTATUS
AVCDevGetDevPlug( 
    IN PDVCR_EXTENSION  pDevExt,
    IN CMP_PLUG_TYPE PlugType,
    IN ULONG  PlugNum,
    OUT HANDLE  *pPlugHandle
   )
/*++

Routine Description:

    Get the targe device's plug handle
 
Arguments:

Return Value:

    STATUS_SUCCESS 
    STATUS_INSUFFICIENT_RESOURCES
    status return from 61883.

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugHandle);
    pAVReq->GetPlugHandle.PlugNum = PlugNum;
    pAVReq->GetPlugHandle.hPlug   = 0;
    pAVReq->GetPlugHandle.Type    = PlugType;

    if(NT_SUCCESS(        
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        *pPlugHandle = pAVReq->GetPlugHandle.hPlug;
        TRACE(TL_61883_WARNING,("Created h%sPlugDV[%d]=%x\n", PlugType == CMP_PlugIn ? "I" : "O", PlugNum, *pPlugHandle));
    } else {
        TRACE(TL_61883_ERROR,("Created h%sPlugDV[%d] failed; Status:%x\n", PlugType == CMP_PlugIn ? "I" : "O", PlugNum, Status));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}


NTSTATUS
AVCDevGetPlugState(
    IN PDVCR_EXTENSION  pDevExt,
    IN HANDLE  hPlug,
    OUT CMP_GET_PLUG_STATE *pPlugState
    )
/*++

Routine Description:

    Ask 61883.sys for the plug state.
 
Arguments:

Return Value:

    Nothing

--*/
{
    PIRP pIrp;
    PAV_61883_REQUEST  pAVReq;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(!hPlug || !pPlugState) 
        return STATUS_INVALID_PARAMETER;    

    if(!(pIrp = IoAllocateIrp(pDevExt->pBusDeviceObject->StackSize, FALSE)))
        return STATUS_INSUFFICIENT_RESOURCES;

    if(!(pAVReq = (AV_61883_REQUEST *) ExAllocatePool(NonPagedPool, sizeof(AV_61883_REQUEST)))) { 
        IoFreeIrp(pIrp); pIrp = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugState);
    pAVReq->GetPlugState.hPlug = hPlug;

    if(NT_SUCCESS(
        Status = DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            ))) {
        //
        // Transfer plug state (note: these are dynamic values)
        //
        *pPlugState = pAVReq->GetPlugState;

        TRACE(TL_61883_WARNING,("GetPlugState: ST %x; State %x; DRate %d (%s); Payld %d; BCCnt %d; PPCnt %d\n", 
            pAVReq->Flags ,
            pAVReq->GetPlugState.State,
            pAVReq->GetPlugState.DataRate,
            (pAVReq->GetPlugState.DataRate == CMP_SPEED_S100) ? "S100" : 
            (pAVReq->GetPlugState.DataRate == CMP_SPEED_S200) ? "S200" :
            (pAVReq->GetPlugState.DataRate == CMP_SPEED_S400) ? "S400" : "Sxxx",
            pAVReq->GetPlugState.Payload,
            pAVReq->GetPlugState.BC_Connections,
            pAVReq->GetPlugState.PP_Connections
            ));
    }
    else {
        TRACE(TL_61883_ERROR,("GetPlugState Failed %x\n", Status));
    }

    IoFreeIrp(pIrp); pIrp = NULL;
    ExFreePool(pAVReq); pAVReq = NULL;

    return Status;
}

#ifndef NT51_61883

NTSTATUS
AVCDevSubmitIrpSynch1394(
    IN PDEVICE_OBJECT pDevObj,
    IN PIRP pIrp,
    IN PIRB pIrb
    )
{
    NTSTATUS            Status;
    KEVENT              Event;
    PIO_STACK_LOCATION  NextIrpStack;
  

    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        DVIrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevObj,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_TRACE,("Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("Irp has completed; IoStatus.Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    return Status;
} // AVCDevSubmitIrpSynch1394

NTSTATUS
Av1394_GetGenerationCount(
    IN PDVCR_EXTENSION  pDevExt,
    OUT PULONG pGenerationCount
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PIRP        pIrp = NULL;
    PIRB        p1394Irb = NULL;
    CCHAR       StackSize;


    PAGED_CODE();

    StackSize = pDevExt->pBusDeviceObject->StackSize;

    pIrp = IoAllocateIrp(StackSize, FALSE);
    p1394Irb = ExAllocatePool(NonPagedPool, sizeof(IRB));

    if ((pIrp == NULL) || (p1394Irb == NULL)) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate pIrp (%x) or p1394Irb (%x)", pIrp, p1394Irb));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_GetGenerationCount;
    }

    //
    // Get the current generation count first
    //
    p1394Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    p1394Irb->Flags = 0;

    ntStatus = AVCDevSubmitIrpSynch1394(pDevExt->pBusDeviceObject, pIrp, p1394Irb);
    if (!NT_SUCCESS(ntStatus)) {
        TRACE(TL_PNP_ERROR, ("REQUEST_GET_GENERATION_COUNT Failed %x", ntStatus));
        goto Exit_GetGenerationCount;
    }

    *pGenerationCount = p1394Irb->u.GetGenerationCount.GenerationCount;

Exit_GetGenerationCount:

    if(pIrp) {
        IoFreeIrp(pIrp);  pIrp = NULL;
    }

    if(p1394Irb) {
        ExFreePool(p1394Irb);  p1394Irb = NULL;
    }

    return(ntStatus);
} // Av1394_GetGenerationCount

#define RETRY_COUNT     4

//
// IEEE 1212 Directory definition
//
typedef struct _DIRECTORY_INFO {
    union {
        USHORT          DI_CRC;
        USHORT          DI_Saved_Length;
    } u;
    USHORT              DI_Length;
} DIRECTORY_INFO, *PDIRECTORY_INFO;


//
// IEEE 1212 Immediate entry definition
//
typedef struct _IMMEDIATE_ENTRY {
    ULONG               IE_Value:24;
    ULONG               IE_Key:8;
} IMMEDIATE_ENTRY, *PIMMEDIATE_ENTRY;


NTSTATUS
Av1394_QuadletRead(
    IN PDVCR_EXTENSION  pDevExt,
    IN OUT PULONG  pData,
    IN ULONG  Address
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PIRP        pIrp;
    PIRB        p1394Irb;
    PMDL        Mdl = NULL;
    ULONG       Retries = RETRY_COUNT;
    CCHAR       StackSize;


    PAGED_CODE();

    StackSize = pDevExt->pBusDeviceObject->StackSize;

    pIrp = IoAllocateIrp(StackSize, FALSE);
    p1394Irb = ExAllocatePool(NonPagedPool, sizeof(IRB));

    if ((pIrp == NULL) || (p1394Irb == NULL)) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate Irp (0x%x) or Irb (0x%x)", pIrp, p1394Irb));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Av1394_QuadletRead;
    }

    Mdl = IoAllocateMdl(pData, sizeof(ULONG), FALSE, FALSE, NULL);

    if (!Mdl) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate Mdl!"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Av1394_QuadletRead;
    }

    MmBuildMdlForNonPagedPool(Mdl);

    do {

        p1394Irb->FunctionNumber = REQUEST_ASYNC_READ;
        p1394Irb->Flags = 0;
        p1394Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = (USHORT)0xffff;
        p1394Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = Address;
        p1394Irb->u.AsyncRead.nNumberOfBytesToRead = 4;
        p1394Irb->u.AsyncRead.nBlockSize = 0;
        p1394Irb->u.AsyncRead.fulFlags = 0;
        p1394Irb->u.AsyncRead.Mdl = Mdl;
        p1394Irb->u.AsyncRead.ulGeneration = pDevExt->GenerationCount;
        p1394Irb->u.AsyncRead.chPriority = 0;
        p1394Irb->u.AsyncRead.nSpeed = 0;
        p1394Irb->u.AsyncRead.tCode = 0;
        p1394Irb->u.AsyncRead.Reserved = 0;

        ntStatus = AVCDevSubmitIrpSynch1394(pDevExt->pBusDeviceObject, pIrp, p1394Irb);

        if (ntStatus == STATUS_INVALID_GENERATION) {

            TRACE(TL_PNP_WARNING, ("QuadletRead: Invalid GenerationCount = %d", pDevExt->GenerationCount));

            Av1394_GetGenerationCount(pDevExt, &pDevExt->GenerationCount);
        }
        else if (!NT_SUCCESS(ntStatus)) {

            TRACE(TL_PNP_ERROR, ("Av1394_QuadletRead Failed = 0x%x  Address = 0x%x", ntStatus, Address));
        }
        else {

            goto Exit_Av1394_QuadletRead;
        }

    } while ((ntStatus == STATUS_INVALID_GENERATION) || (Retries--));

Exit_Av1394_QuadletRead:

    if(pIrp) {
        IoFreeIrp(pIrp);  pIrp = NULL;
    }
    if(p1394Irb) {
        ExFreePool(p1394Irb); p1394Irb = NULL;
    }

    if(Mdl) {
        IoFreeMdl(Mdl); Mdl = NULL;
    }

    return(ntStatus);
} // Av1394_QuadletRead


#define KEY_ModuleVendorId      (0x03)
#define KEY_ModuleHwVersion     (0x04)
#define KEY_UnitSwVersion       (0x13)
#define KEY_ModelId             (0x17)

#define DEVICE_NAME_MAX_CHARS   100*sizeof(WCHAR)

NTSTATUS
Av1394_ReadTextualDescriptor(
    IN PDVCR_EXTENSION  pDevExt,
    IN OUT PUNICODE_STRING uniString,
    IN ULONG Address
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PULONG pData = NULL;
    ULONG DataLength, i, n;
    ULONG ulUnicode;

    ULONG ulQuadlet;

    union {
        ULONG            asUlong;
        UCHAR            asUchar[4];
        DIRECTORY_INFO   DirectoryHeader;
    } u;


    PAGED_CODE();

    TRACE(TL_PNP_TRACE, ("Address = 0x%x", Address));

    // read the first quadlet of leaf, this is the header
    ntStatus = Av1394_QuadletRead(pDevExt, &ulQuadlet, Address);

    if (!NT_SUCCESS(ntStatus)) {

        TRACE(TL_PNP_ERROR, ("GetUnitInfo: QuadletRead Error = 0x%x", ntStatus));
        goto Exit_Av1394_ReadTextualDescriptor;
    }

    // number of entries
    u.asUlong = bswap(ulQuadlet);
    DataLength = u.DirectoryHeader.DI_Length-2; // one extra for the header

    // read the second quadlet of leaf to determine unicode
    Address += 4;

    ntStatus = Av1394_QuadletRead(pDevExt, &ulQuadlet, Address);

    if (!NT_SUCCESS(ntStatus)) {

        TRACE(TL_PNP_ERROR, ("GetUnitInfo: QuadletRead Error = 0x%x", ntStatus));
        goto Exit_Av1394_ReadTextualDescriptor;
    }

    // save spec type
    ulUnicode = bswap(ulQuadlet);

    pData = ExAllocatePool(NonPagedPool, DataLength*sizeof(ULONG)+2);

    if (pData == NULL) {
        TRACE(TL_PNP_ERROR, ("Failed to allocate pData"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Av1394_ReadTextualDescriptor;
    }

    RtlZeroMemory(pData, DataLength*sizeof(ULONG)+2);

    // lets read in each quad
    Address += 8;

    for (i=0; i<DataLength; i++) {

        ntStatus = Av1394_QuadletRead(pDevExt, &u.asUlong, Address+(sizeof(ULONG)*i));

        if (!NT_SUCCESS(ntStatus)) {

            TRACE(TL_PNP_ERROR, ("GetUnitInfo: QuadletRead Error = 0x%x", ntStatus));
            goto Exit_Av1394_ReadTextualDescriptor;
        }

        // need to make sure we have valid characters...
        for (n=0; n<4; n++) {

            // we should be done if the char equals 0x00
            if (u.asUchar[n] == 0x00)
                break;

            if ((u.asUchar[n] == 0x2C) || (u.asUchar[n] < 0x20) || (u.asUchar[n] > 0x7F)) {

                TRACE(TL_PNP_WARNING, ("Invalid Character = 0x%x", u.asUchar[n]));

                // set it to space
                u.asUchar[n] = 0x20;
            }

            if (ulUnicode & 0x80000000)
                n++;
        }

        RtlCopyMemory((PULONG)pData+i, &u.asUlong, sizeof(ULONG));
    }

    // if there's a vendor leaf, then convert it to unicode
    {
        ANSI_STRING     ansiString;

        uniString->Length = 0;
        uniString->MaximumLength = DEVICE_NAME_MAX_CHARS;
        uniString->Buffer = ExAllocatePool(NonPagedPool, uniString->MaximumLength);

        if (!uniString->Buffer) {

            TRACE(TL_PNP_ERROR, ("Failed to allocate uniString.Buffer!"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_Av1394_ReadTextualDescriptor;
        }
        RtlZeroMemory(uniString->Buffer, uniString->MaximumLength);

        // unicode??
        if (ulUnicode & 0x80000000) {

            RtlAppendUnicodeToString(uniString, ((PWSTR)pData));
        }
        else {

            RtlInitAnsiString(&ansiString, (PUCHAR)pData);
            RtlAnsiStringToUnicodeString(uniString, &ansiString, FALSE);
        }
    }

Exit_Av1394_ReadTextualDescriptor:

    if (pData)
        ExFreePool(pData);

    return(ntStatus);
} // ReadTextualLeaf




NTSTATUS
AVCDevGetModelText(
    IN PDVCR_EXTENSION  pDevExt,
    PUNICODE_STRING  pUniRootModelString,
    PUNICODE_STRING  pUniUnitModelString
    )
{
    CCHAR StackSize;
    PIRP pIrp = NULL;
    PIRB p1394Irb = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    CONFIG_ROM ConfigRom;
    ULONG ulQuadlet = 0;
    ULONG CurrAddress;
    PULONG UnitDir = NULL, UnitDirToFree = NULL;
    ULONG i;
    ULONG LastKey;

    union {
        ULONG           asUlong;
        DIRECTORY_INFO  DirInfo;
        IMMEDIATE_ENTRY Entry;
    } u, u2; //, u3;


    PAGED_CODE();

    StackSize = pDevExt->pBusDeviceObject->StackSize;
    pIrp = IoAllocateIrp(StackSize, FALSE);
    p1394Irb = ExAllocatePool(NonPagedPool, sizeof(IRB));

    if ((pIrp == NULL) || (p1394Irb == NULL)) {
        TRACE(TL_PNP_ERROR, ("Failed to allocate pIrp (%x) or p1394Irb (%x)", pIrp, p1394Irb));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the current generation count (used to read config rom)
    //
    Av1394_GetGenerationCount(pDevExt, &pDevExt->GenerationCount);


    //
    // Get Model Text from the Root directory
    //
    CurrAddress = 0xF0000414;

    // root directory
    ntStatus = Av1394_QuadletRead(pDevExt, &ulQuadlet, CurrAddress);

    if (!NT_SUCCESS(ntStatus)) {

        TRACE(TL_PNP_ERROR, ("GetUnitInfo: QuadletRead Error = 0x%x", ntStatus));
        goto Exit_GetUnitInfo;
    }

    u.asUlong = bswap(ulQuadlet);
    TRACE(TL_PNP_TRACE, ("RootDir: Length = %d", u.DirInfo.DI_Length));

    // process the root directory
    for (i=0; i<u.DirInfo.DI_Length; i++) {

        CurrAddress += sizeof(ULONG);

        ntStatus = Av1394_QuadletRead(pDevExt, &ulQuadlet, CurrAddress);

        if (!NT_SUCCESS(ntStatus)) {

            TRACE(TL_PNP_ERROR, ("GetUnitInfo: QuadletRead Error = 0x%x", ntStatus));
            goto Exit_GetUnitInfo;
        }

        u2.asUlong = bswap(ulQuadlet);

        TRACE(TL_PNP_TRACE, ("CurrAddress = 0x%x  Key = 0x%x  Value = 0x%x",
	        CurrAddress, u2.Entry.IE_Key, u2.Entry.IE_Value));

        // ModelId Textual Descriptor
        if ((u2.Entry.IE_Key == 0x81) && (LastKey == KEY_ModelId)) {

            // get the first entry of the textual descriptor
            Av1394_ReadTextualDescriptor( pDevExt, 
                                          pUniRootModelString,
                                          CurrAddress+(u2.Entry.IE_Value*sizeof(ULONG))
                                          );            
        }
#if 0
        // ModelId Textual Descriptor Layer
        if ((u2.Entry.IE_Key == 0xC1) && (LastKey == KEY_ModelId)) {

            ULONG   DescAddress;

            DescAddress = CurrAddress+(u2.Entry.IE_Value*sizeof(ULONG));

            Av1394_QuadletRead(pDevExt, &ulQuadlet, DescAddress);

            u3.asUlong = bswap(ulQuadlet);

            // get the first entry of the textual descriptor
            Av1394_ReadTextualDescriptor( pDevExt, 
                                          pUniRootModelString,
                                          DescAddress+(u3.Entry.IE_Value*sizeof(ULONG))
                                          );
        }
#endif
        LastKey = u2.Entry.IE_Key;
    }


    //
    // Get Configuration Info
    //
    p1394Irb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    p1394Irb->Flags = 0;

    p1394Irb->u.GetConfigurationInformation.ConfigRom = NULL;
    p1394Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.UnitDirectory = NULL;
    p1394Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.UnitDependentDirectory = NULL;
    p1394Irb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.VendorLeaf = NULL;
    p1394Irb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.ModelLeaf = NULL;

    ntStatus = AVCDevSubmitIrpSynch1394(pDevExt->pBusDeviceObject, pIrp, p1394Irb);
    if (!NT_SUCCESS(ntStatus)) {

        TRACE(TL_PNP_ERROR, ("REQUEST_GET_CONFIGURATION_INFO Failed %x", ntStatus));
        goto Exit_GetUnitInfo;
    }


    //
    // Allocate buffer in order retrieve unit directory of a config rom
    //
    if (p1394Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize) {

        UnitDir = UnitDirToFree = 
        p1394Irb->u.GetConfigurationInformation.UnitDirectory =
            ExAllocatePool(NonPagedPool, p1394Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize);

        if (!p1394Irb->u.GetConfigurationInformation.UnitDirectory) {
            TRACE(TL_PNP_ERROR, ("Couldn't allocate memory for the UnitDirectory"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_GetUnitInfo;
        }
    }
    else {
         TRACE(TL_PNP_ERROR, ("No Unit directory. Bad Device."));
         ntStatus = STATUS_BAD_DEVICE_TYPE;
         goto Exit_GetUnitInfo;
    }

    p1394Irb->u.GetConfigurationInformation.ConfigRom = &ConfigRom;
    p1394Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    p1394Irb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;
    ntStatus = AVCDevSubmitIrpSynch1394(pDevExt->pBusDeviceObject, pIrp, p1394Irb);
    if (!NT_SUCCESS(ntStatus)) {
        TRACE(TL_PNP_ERROR, ("2nd REQUEST_GET_CONFIGURATION_INFO Failed = 0x%x", ntStatus));
        goto Exit_GetUnitInfo;
    }

    //
    // Process unit directory; see this doc for detail:
    //    1394TA specification: Configuration ROM for AV/C device 1.0 (AVWG)
    //
    u.asUlong = bswap(*UnitDir++);  // Get length, and dkip first quadlet
    TRACE(TL_PNP_TRACE, ("UnitDir: Length = %d", u.DirInfo.DI_Length));

    CurrAddress = p1394Irb->u.GetConfigurationInformation.UnitDirectoryLocation.IA_Destination_Offset.Off_Low;
    for (i=0; i<u.DirInfo.DI_Length; i++) {
        TRACE(TL_PNP_TRACE, ("i = %d  UnitDir = 0x%x  *UnitDir = 0x%x", i, UnitDir, *UnitDir));
        u2.asUlong = bswap(*UnitDir++);
        CurrAddress += sizeof(ULONG);
        TRACE(TL_PNP_TRACE, ("UnitDir Quadlet = 0x%x", u2.asUlong));

        //
        // ModelId Textual Descriptor
        //
        if ((u2.Entry.IE_Key == 0x81) && (LastKey == KEY_ModelId)) {

            // get the first entry of the textual descriptor
            Av1394_ReadTextualDescriptor( 
                pDevExt, 
                pUniUnitModelString,
                CurrAddress+(u2.Entry.IE_Value*sizeof(ULONG))
                );
        }
#if 0
        //
        // UnitModelId Textual Descriptor Layer
        //
        if ((u2.Entry.IE_Key == 0xC1) && (LastKey == KEY_ModelId)) {
            ULONG   DescAddress;
            DescAddress = CurrAddress+(u2.Entry.IE_Value*sizeof(ULONG));
            Av1394_QuadletRead(pDevExt, &ulQuadlet, DescAddress);
            u3.asUlong = bswap(ulQuadlet);

            // get the first entry of the textual descriptor
            Av1394_ReadTextualDescriptor( 
                pDevExt,
                pUniUnitModelString,
                DescAddress+(u3.Entry.IE_Value*sizeof(ULONG))
                );
        }
#endif

        LastKey = u2.Entry.IE_Key;
    }


Exit_GetUnitInfo:

    if (UnitDirToFree) {
        ExFreePool(UnitDirToFree);  UnitDirToFree = NULL;
    }
    if(pIrp) {
        IoFreeIrp(pIrp);  pIrp = NULL;
    }
    if(p1394Irb) {
        ExFreePool(p1394Irb);  p1394Irb = NULL;
    }

    return ntStatus;
}
#endif


NTSTATUS
DVGetUnitCapabilities(
    IN PDVCR_EXTENSION  pDevExt,
    IN PIRP            pIrp,
    IN PAV_61883_REQUEST  pAVReq
    )
{
    NTSTATUS Status;
    GET_UNIT_IDS * pUnitIds;
    GET_UNIT_CAPABILITIES * pUnitCaps;

    PAGED_CODE();


    //
    // Query device's capability
    //
    pUnitCaps = (GET_UNIT_CAPABILITIES *) ExAllocatePool(NonPagedPool, sizeof(GET_UNIT_CAPABILITIES));
    if(!pUnitCaps) {
        TRACE(TL_61883_ERROR,("DVGetUnitCapabilities: Allocate pUnitCaps (%d bytes) failed\n", sizeof(GET_UNIT_CAPABILITIES)));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // UnitIDS is cached in DevExt.
    pUnitIds = &pDevExt->UnitIDs;

    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetUnitInfo);
    pAVReq->GetUnitInfo.nLevel   = GET_UNIT_INFO_IDS;
    RtlZeroMemory(pUnitIds, sizeof(GET_UNIT_IDS));  // Initialize pointers.    
    pAVReq->GetUnitInfo.Information = (PVOID) pUnitIds;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_GetUnitCapabilities Failed = 0x%x\n", Status));
        pDevExt->UniqueID.QuadPart = 0;
        pDevExt->ulVendorID = 0;
        pDevExt->ulModelID  = 0;
    }
    else {
        pDevExt->UniqueID   = pUnitIds->UniqueID;
        pDevExt->ulVendorID = pUnitIds->VendorID;
        pDevExt->ulModelID  = pUnitIds->ModelID;

         TRACE(TL_61883_TRACE,("UniqueId:(Low)%x:(High)%x; VendorID:%x; ModelID:%x\n", 
            pDevExt->UniqueID.LowPart, pDevExt->UniqueID.HighPart, pDevExt->ulVendorID, pDevExt->ulModelID));
  
        //
        // Allocate memory needed for the text string for VendorText, 
        // ModelText and UntiModelText.
        //
        if(pUnitIds->ulVendorLength) {
            pUnitIds->VendorText = (PWSTR) ExAllocatePool(NonPagedPool, pUnitIds->ulVendorLength);
            if(!pUnitIds->VendorText)
                goto AbortGetUnitCapabilities;
        }

        if(pUnitIds->ulModelLength) {
            pUnitIds->ModelText = (PWSTR) ExAllocatePool(NonPagedPool, pUnitIds->ulModelLength);
            if(!pUnitIds->ModelText)
                goto AbortGetUnitCapabilities;
        }


#ifdef NT51_61883
        if(pUnitIds->ulUnitModelLength) {
            pUnitIds->UnitModelText = (PWSTR) ExAllocatePool(NonPagedPool, pUnitIds->ulUnitModelLength);
            if(!pUnitIds->UnitModelText)
                goto AbortGetUnitCapabilities;
        }
#else
        // 
        // 1st version of 61883.sys does not retrieve Root and Unit model text 
        // the same way as in WinXP; so we retieve them directly using 1394 API
        //
        if(!NT_SUCCESS(AVCDevGetModelText(
                pDevExt,
                &pDevExt->UniRootModelString,
                &pDevExt->UniUnitModelString
                ))) {
                goto AbortGetUnitCapabilities;
        } 
#endif

        Status = 
            DVSubmitIrpSynch( 
                pDevExt,
                pIrp,
                pAVReq
                );
    }


    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetUnitInfo);
    pAVReq->GetUnitInfo.nLevel = GET_UNIT_INFO_CAPABILITIES;
    RtlZeroMemory(pUnitCaps, sizeof(GET_UNIT_CAPABILITIES));  // Initialize pointers.    
    pAVReq->GetUnitInfo.Information = (PVOID) pUnitCaps;

    Status = 
        DVSubmitIrpSynch( 
            pDevExt,
            pIrp,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Av61883_GetUnitCapabilities Failed = 0x%x\n", Status));
        pDevExt->pDevOutPlugs->MaxDataRate = 0;
        pDevExt->pDevOutPlugs->NumPlugs    = 0; 

        pDevExt->pDevInPlugs->MaxDataRate  = 0;
        pDevExt->pDevInPlugs->NumPlugs     = 0;
    }
    else {
        //
        // There can never be more than MAX_NUM_PCR (= 31) of plugs
        //
        ASSERT(pUnitCaps->NumOutputPlugs <= MAX_NUM_PCR);
        ASSERT(pUnitCaps->NumInputPlugs  <= MAX_NUM_PCR);

        pDevExt->pDevOutPlugs->MaxDataRate = pUnitCaps->MaxDataRate;  
        pDevExt->pDevOutPlugs->NumPlugs = (pUnitCaps->NumOutputPlugs > MAX_NUM_PCR ? MAX_NUM_PCR : pUnitCaps->NumOutputPlugs);

        pDevExt->pDevInPlugs->MaxDataRate = pUnitCaps->MaxDataRate;  
        pDevExt->pDevInPlugs->NumPlugs = (pUnitCaps->NumInputPlugs > MAX_NUM_PCR ? MAX_NUM_PCR : pUnitCaps->NumInputPlugs);
    }

    TRACE(TL_61883_TRACE,("** UnitCaps: OutP:%d; InP:%d; MDRate:%s; CtsF:%x; HwF:%x; VID:%x; MID:%x\n", 
         pUnitCaps->NumOutputPlugs,
         pUnitCaps->NumInputPlugs,
         pUnitCaps->MaxDataRate == 0 ? "S100": pUnitCaps->MaxDataRate == 1? "S200" : "S400 or +",   
         pUnitCaps->CTSFlags,
         pUnitCaps->HardwareFlags,
         pUnitIds->VendorID,
         pUnitIds->ModelID
         ));      

AbortGetUnitCapabilities:

    if(pUnitIds->ulVendorLength && pUnitIds->VendorText) {
         TRACE(TL_61883_TRACE,("Vendor:    Len:%d; \"%S\"\n", pUnitIds->ulVendorLength, pUnitIds->VendorText)); 
        if(!NT_SUCCESS(Status)) {
            ExFreePool(pUnitIds->VendorText);  pUnitIds->VendorText = NULL;
        }
    }
    
    if(pUnitIds->ulModelLength && pUnitIds->ModelText) {
         TRACE(TL_61883_TRACE,("Model:     Len:%d; \"%S\"\n", pUnitIds->ulModelLength, pUnitIds->ModelText)); 
        if(!NT_SUCCESS(Status)) {
            ExFreePool(pUnitIds->ModelText);  pUnitIds->ModelText = NULL;
        }
    }

#ifdef NT51_61883
    if(pUnitIds->ulUnitModelLength && pUnitIds->UnitModelText) {
        TRACE(TL_61883_TRACE,("UnitModel (61883): Len:%d; \"%S\"\n", pUnitIds->ulUnitModelLength, pUnitIds->UnitModelText));
        if(!NT_SUCCESS(Status)) {
            ExFreePool(pUnitIds->UnitModelText);  pUnitIds->UnitModelText = NULL;
        }
    }
#else
    if(pDevExt->UniRootModelString.Length && pDevExt->UniRootModelString.Buffer) {
        TRACE(TL_61883_TRACE,("RootModel (MSTape): Len:%d; \"%S\"\n", pDevExt->UniRootModelString.Length, pDevExt->UniRootModelString.Buffer));
        if(!NT_SUCCESS(Status)) {
            ExFreePool(pDevExt->UniRootModelString.Buffer);  pDevExt->UniRootModelString.Buffer = NULL;
        }
    }

    if(pDevExt->UniUnitModelString.Length && pDevExt->UniUnitModelString.Buffer) {
        TRACE(TL_61883_TRACE,("UnitModel (MSTape): Len:%d; \"%S\"\n", pDevExt->UniUnitModelString.Length, pDevExt->UniUnitModelString.Buffer));
        if(!NT_SUCCESS(Status)) {
            ExFreePool(pDevExt->UniUnitModelString.Buffer);  pDevExt->UniUnitModelString.Buffer = NULL;
        }
    }
#endif

    ExFreePool(pUnitCaps);  pUnitCaps = NULL;

    return Status;
}

#ifdef SUPPORT_NEW_AVC_CMD
BOOL
InitializeAVCCommand (
    PAVC_CMD pAVCCmd,
    AvcCommandType  CmdType,
    AvcSubunitType  SubunitType,
    UCHAR  SubunitID,  
    AVC_COMMAND_OP_CODE  Opcode
    )
{
    switch(Opcode) {
    case OPC_UNIT_CONNECT_AV_20:
        pAVCCmd->DataLen = 8;

        pAVCCmd->ConnectAV.AudSrc = 3;
        pAVCCmd->ConnectAV.VidSrc = 3;
        pAVCCmd->ConnectAV.AudDst = 0;  // subunit
        pAVCCmd->ConnectAV.VidDst = 0;  // subunit

        pAVCCmd->ConnectAV.VidSrc = 0xff;
        pAVCCmd->ConnectAV.AudSrc = 0xff;
        pAVCCmd->ConnectAV.VidDst = 0x20;
        pAVCCmd->ConnectAV.AudDst = 0x20;
        break;

    case OPC_TAPE_PLAY_C3:
        pAVCCmd->DataLen = 4;
        // pAVCCmd->TapePlay.PlaybackMode = 
        break;

    default:
        return FALSE;
    }

    pAVCCmd->CmdFrame.CmdHeader.CTS = 0;
    pAVCCmd->CmdFrame.CmdHeader.CmdType = CmdType;
    pAVCCmd->CmdFrame.CmdHeader.SubunitTypeID.SubunitType = SubunitType;
    pAVCCmd->CmdFrame.CmdHeader.SubunitTypeID.SubunitID = SubunitID;
    pAVCCmd->CmdFrame.CmdHeader.Opcode = Opcode;

    return TRUE;
}
#endif // SUPPORT_NEW_AVC_CMD

BOOL
DVGetDevModeOfOperation(   
    IN PDVCR_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];

#ifdef SUPPORT_NEW_AVC_CMD
    AVC_CMD  AVCCmd;
#endif

    PAGED_CODE();

#ifdef SUPPORT_NEW_AVC_CMD
    InitializeAVCCommand(&AVCCmd, AVC_CTYPE_STATUS, AVC_SUBUNITTYPE_UNIT, 0, OPC_UNIT_CONNECT_AV_20);
    InitializeAVCCommand(&AVCCmd, AVC_CTYPE_CONTROL, AVC_SUBUNITTYPE_TAPE_PLAYER, 0, OPC_TAPE_PLAY_C3);
    AVCCmd.TapePlay.PlaybackMode = NEXT_FRAME;   // Testing...
#endif
    
    //
    // Use ConnectAV STATUS cmd to determine mode of operation,
    // except for some Canon DVs that it requires its vendor specific command
    //    
   
    Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, DV_CONNECT_AV_MODE, (PVOID) bAvcBuf); 

     TRACE(TL_61883_TRACE,("GetDevModeOfOperation(DV_CONNECT_AV_MODE): Status %x,  %x %x %x %x : %x %x %x %x\n",
        Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7]));

    if(Status == STATUS_SUCCESS) {
        if(bAvcBuf[0] == 0x0c) {
            if(bAvcBuf[1] == 0x00 &&
               bAvcBuf[2] == 0x38 &&
               bAvcBuf[3] == 0x38) {
                pDevExt->ulDevType = ED_DEVTYPE_CAMERA;  
            } else 
            if(bAvcBuf[1] == 0xa0 &&
               bAvcBuf[2] == 0x00 &&
               bAvcBuf[3] == 0x00) {
                pDevExt->ulDevType = ED_DEVTYPE_VCR;  
            } 
        }    
    } else if(pDevExt->ulVendorID == VENDORID_CANON) {
        // If this is a Canon, we can try this:
        Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, DV_VEN_DEP_CANON_MODE, (PVOID) bAvcBuf); 
         TRACE(TL_61883_TRACE,("GetDevModeOfOperation(DV_VEN_DEP_CANON_MODE): Status %x,  %x %x %x %x : %x %x %x %x\n",
            Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7]));

        if(Status == STATUS_SUCCESS) {
            if(bAvcBuf[0] == 0x0c) {
                if(bAvcBuf[7] == 0x38) {
                    pDevExt->ulDevType = ED_DEVTYPE_CAMERA;  
                } else 
                if(bAvcBuf[7] == 0x20) {
                    pDevExt->ulDevType = ED_DEVTYPE_VCR;  
                } 
            }
        }
    }

    //
    // Connect AV is an optional command, a device may not support it.
    // If this device support a tape subunit, we will assume we are in that device type.
    //
    if(Status != STATUS_SUCCESS) {
        // We are the subunit driver so if any of the device type is a 
        // tape subunit, we are in that device type.
        if(   pDevExt->Subunit_Type[0] == AVC_DEVICE_TAPE_REC 
           || pDevExt->Subunit_Type[1] == AVC_DEVICE_TAPE_REC
           || pDevExt->Subunit_Type[2] == AVC_DEVICE_TAPE_REC
           || pDevExt->Subunit_Type[3] == AVC_DEVICE_TAPE_REC) {
            pDevExt->ulDevType = ED_DEVTYPE_VCR;
        } else {
            pDevExt->ulDevType = ED_DEVTYPE_UNKNOWN;  // Such as MediaConverter box.
        }

        TRACE(TL_PNP_ERROR|TL_FCP_ERROR,("GetDevModeOfOperation: failed but we choose DevType:%x\n", pDevExt->ulDevType));
    }

     TRACE(TL_61883_TRACE,("** Mode of operation: %s (%x); NumOPlg:%d; NumIPlg:%d\n", 
        pDevExt->ulDevType == ED_DEVTYPE_CAMERA ? "Camera" : pDevExt->ulDevType == ED_DEVTYPE_VCR ? "Tape" : "Unknown",
        pDevExt->ulDevType, pDevExt->pDevOutPlugs->NumPlugs, pDevExt->pDevInPlugs->NumPlugs));
             
    return TRUE;
}


BOOL
DVGetDevIsItDVCPro(   
    IN PDVCR_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];

    PAGED_CODE();    

    //
    // Use Panasnoic's vendor dependent command to determine if the system support DVCPro
    //        
    Status = DVIssueAVCCommand(pDevExt, AVC_CTYPE_STATUS, DV_VEN_DEP_DVCPRO, (PVOID) bAvcBuf);
    pDevExt->bDVCPro = (Status == STATUS_SUCCESS);
    
     TRACE(TL_61883_TRACE,("GetDevIsItDVCPro? %s; Status %x,  %x %x %x %x : %x %x %x %x\n",
        pDevExt->bDVCPro ? "Yes":"No",
        Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2], bAvcBuf[3], bAvcBuf[4], bAvcBuf[5], bAvcBuf[6], bAvcBuf[7]));

    return pDevExt->bDVCPro;
}


#define GET_MEDIA_FMT_MAX_RETRIES 10  // AVC.sys will retry so we may rey just once.

BOOL
DVGetDevSignalFormat(
    IN PDVCR_EXTENSION pDevExt,
    IN KSPIN_DATAFLOW  DataFlow,
    IN PSTREAMEX       pStrmExt
    )
{
    NTSTATUS Status;
    BYTE    bAvcBuf[MAX_FCP_PAYLOAD_SIZE];
    LONG lRetries = GET_MEDIA_FMT_MAX_RETRIES;

    PAGED_CODE();


    //
    // Respone of Input/output signal mode is used to determine plug signal format:
    //
    //     FMT: 
    //         DVCR 10:00 0000 = 0x80; Canon returns 00:100000 (0x20)
    //             50/60: 0:NTSC/60; 1:PAL/50
    //             STYPE:
    //                 SD: 00000  (DVCPRO:11110)
    //                 HD: 00010
    //                 SDL:00001
    //             00:
    //             SYT:
    //         MPEG 10:10 0000 = 0xa0
    //             TSF:0:NotTimeShifted; 1:Time shifted
    //             000 0000 0000 0000 0000 0000
    //
    // If this command failed, we can use Input/Output Signal Mode subunit command
    // to determine signal format.
    // 

    do {
        RtlZeroMemory(bAvcBuf, sizeof(bAvcBuf));

        Status = 
            DVIssueAVCCommand(
                pDevExt, 
                AVC_CTYPE_STATUS, 
                pStrmExt == NULL ? DV_OUT_PLUG_SIGNAL_FMT : pStrmExt->pStrmInfo->DataFlow == KSPIN_DATAFLOW_OUT ? DV_OUT_PLUG_SIGNAL_FMT : DV_IN_PLUG_SIGNAL_FMT,
                (PVOID) bAvcBuf
                );  

        --lRetries;

        // 
        // Camcorders that has problem with this command:
        //
        // Panasonic's DVCPRO: if power on while connected to PC, it will 
        // reject this command with (STATUS_REQUEST_NOT_ACCEPTED)
        // so we will retry up to 10 time with .5 second wait between tries.
        //
        // JVC: returns STATUS_NOT_SUPPORTED.
        //
        // SONY DV Decoder Box: return STATUS_TIMEOUT
        //

        if(Status == STATUS_SUCCESS ||
           Status == STATUS_NOT_SUPPORTED ||
           Status == STATUS_TIMEOUT) {
            break;  // No need to retry
        } else 
        if(Status == STATUS_REQUEST_NOT_ACCEPTED) {
            if(lRetries >= 0) 
                DVDelayExecutionThread(DV_AVC_CMD_DELAY_DVCPRO);        
        }
        // else retry.
    } while (lRetries >= 0); 


    if(NT_SUCCESS(Status)) {

        switch(bAvcBuf[0]) {

        case FMT_DVCR:
        case FMT_DVCR_CANON:  // Workaround for buggy Canon Camcorders
            switch(bAvcBuf[1] & FDF0_STYPE_MASK) {
            case FDF0_STYPE_SD_DVCR:
            case FDF0_STYPE_SD_DVCPRO:                
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? AVCSTRM_FORMAT_SDDV_PAL : AVCSTRM_FORMAT_SDDV_NTSC);
                break;
            case FDF0_STYPE_HD_DVCR:
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? AVCSTRM_FORMAT_HDDV_PAL : AVCSTRM_FORMAT_HDDV_NTSC);
                break;
            case FDF0_STYPE_SDL_DVCR:
                pDevExt->VideoFormatIndex = ((bAvcBuf[1] & FDF0_50_60_MASK) ? AVCSTRM_FORMAT_SDLDV_PAL : AVCSTRM_FORMAT_SDLDV_NTSC);
                break;                
            default:  // Unknown format
                Status = STATUS_UNSUCCESSFUL;              
                break;
            }   
            break;

        case FMT_MPEG:
            pDevExt->VideoFormatIndex = AVCSTRM_FORMAT_MPEG2TS;
            break;

        default:
            Status = STATUS_UNSUCCESSFUL;
        }  

        if(NT_SUCCESS(Status)) {
             TRACE(TL_PNP_ERROR|TL_FCP_ERROR,("ST:%x; PlugSignal:FMT[%x %x %x %x]; VideoFormatIndex;%d\n", Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2] , bAvcBuf[3], pDevExt->VideoFormatIndex)); 
            return TRUE;  // Success
        }        
    }

     TRACE(TL_FCP_TRACE,("ST:%x; PlugSignal:FMT[%x %x %x %x]\n", Status, bAvcBuf[0], bAvcBuf[1], bAvcBuf[2] , bAvcBuf[3], pDevExt->VideoFormatIndex)); 


    //
    // If "recommended" unit input/output plug signal status command fails,
    // try "manadatory" input/output signal mode status command.
    // This command may failed some device if its tape is not playing for
    // output signal mode command.
    //

    RtlZeroMemory(bAvcBuf, sizeof(bAvcBuf));
    Status = 
        DVIssueAVCCommand(
            pDevExt, 
            AVC_CTYPE_STATUS, 
            DataFlow == KSPIN_DATAFLOW_OUT ? VCR_OUTPUT_SIGNAL_MODE : VCR_INPUT_SIGNAL_MODE,
            (PVOID) bAvcBuf
            );             

    if(STATUS_SUCCESS == Status) {

        PKSPROPERTY_EXTXPORT_S pXPrtProperty;

        pXPrtProperty = (PKSPROPERTY_EXTXPORT_S) bAvcBuf;
         TRACE(TL_STRM_TRACE|TL_FCP_TRACE,("** MediaFormat: Retry %d mSec; ST:%x; SignalMode:%dL\n", 
            (GET_MEDIA_FMT_MAX_RETRIES - lRetries) * DV_AVC_CMD_DELAY_DVCPRO, Status, pXPrtProperty->u.SignalMode - ED_BASE));

        switch(pXPrtProperty->u.SignalMode) {
        case ED_TRANSBASIC_SIGNAL_525_60_SD:
            pDevExt->VideoFormatIndex = AVCSTRM_FORMAT_SDDV_NTSC;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR; // 0x80 
                if(pDevExt->bDVCPro)
                    pStrmExt->cipQuad2[1] = FDF0_50_60_NTSC | FDF0_STYPE_SD_DVCPRO; // 0x78 = NTSC(0):STYPE(11110):RSV(00)
                else
                    pStrmExt->cipQuad2[1] = FDF0_50_60_NTSC | FDF0_STYPE_SD_DVCR;   // 0x00 = NTSC(0):STYPE(00000):RSV(00)            
            }
            break;
        case ED_TRANSBASIC_SIGNAL_625_50_SD:
            pDevExt->VideoFormatIndex = AVCSTRM_FORMAT_SDDV_PAL;
            if(pStrmExt) {
                pStrmExt->cipQuad2[0] = FMT_DVCR;  // 0x80
                if(pDevExt->bDVCPro)
                    pStrmExt->cipQuad2[1] = FDF0_50_60_PAL | FDF0_STYPE_SD_DVCPRO; // 0xf8 = PAL(1):STYPE(11110):RSV(00)
                else
                    pStrmExt->cipQuad2[1] = FDF0_50_60_PAL | FDF0_STYPE_SD_DVCR;   // 0x80 = PAL(1):STYPE(00000):RSV(00)             
            }
            break;

        case ED_TRANSBASIC_SIGNAL_MPEG2TS:
            pDevExt->VideoFormatIndex = AVCSTRM_FORMAT_MPEG2TS;
            break;

        default:
            TRACE(TL_PNP_ERROR|TL_FCP_ERROR,("Unsupported SignalMode:%dL", pXPrtProperty->u.SignalMode - ED_BASE));
            ASSERT(FALSE && "Unsupported IoSignal! Refuse to load.");
            return FALSE;
            break;
        }
    } 

    // WORKITEM Sony HW CODEC does not response to any AVC command.
    // We are making an exception here to load it.
    if(Status == STATUS_TIMEOUT) {
        Status = STATUS_SUCCESS;
    }

    // We must know the signal format!!  If this failed, the driver will either:
    //    fail to load, or fail to open an stream
    ASSERT(Status == STATUS_SUCCESS && "Failed to get media signal format!\n");

#if DBG
    if(pStrmExt)  {
        // Note: bAvcBuf[0] is operand[1] == 10:fmt
         TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("** MediaFormat: St:%x; idx:%d; CIP:[FMT:%.2x(%s); FDF:[%.2x(%s,%s):SYT]\n",
            Status,
            pDevExt->VideoFormatIndex,
            pStrmExt->cipQuad2[0],
            pStrmExt->cipQuad2[0] == FMT_DVCR ? "DVCR" : pStrmExt->cipQuad2[0] == FMT_MPEG ? "MPEG" : "Fmt:???",
            pStrmExt->cipQuad2[1],
            (pStrmExt->cipQuad2[1] & FDF0_50_60_MASK) == FDF0_50_60_PAL ? "PAL" : "NTSC",
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SD_DVCR ?   "SD" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SDL_DVCR ?  "SDL" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_HD_DVCR ?   "HD" : \
            (pStrmExt->cipQuad2[1] & FDF0_STYPE_MASK) == FDF0_STYPE_SD_DVCPRO ? "DVCPRO" : "DV:????"
            ));
    } else
         TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("** MediaFormat: St:%x; use idx:%d\n", Status, pDevExt->VideoFormatIndex));

#endif

    return STATUS_SUCCESS == Status;
}



BOOL 
DVCmpGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    IN BOOL fCompareFormatSize
    )
/*++

Routine Description:

    Checks for a match on the three GUIDs and FormatSize

Arguments:

    IN pDataRange1
    IN pDataRange2

Return Value:

    TRUE if all elements match
    FALSE if any are different

--*/

{
    return (
        IsEqualGUID (
            &pDataRange1->MajorFormat, 
            &pDataRange2->MajorFormat) &&
        IsEqualGUID (
            &pDataRange1->SubFormat, 
            &pDataRange2->SubFormat) &&
        IsEqualGUID (
            &pDataRange1->Specifier, 
            &pDataRange2->Specifier) &&
        (fCompareFormatSize ? 
                (pDataRange1->FormatSize == pDataRange2->FormatSize) : TRUE ));
}


//
// GetSystemTime in 100 nS units
//

ULONGLONG GetSystemTime()
{

    LARGE_INTEGER rate, ticks;

    ticks = KeQueryPerformanceCounter(&rate);

    return (KSCONVERT_PERFORMANCE_TIME(rate.QuadPart, ticks));
}


VOID
DvFreeTextualString(
    PDVCR_EXTENSION pDevExt,
    GET_UNIT_IDS  * pUnitIds
  )
{
    if(pUnitIds->ulVendorLength && pUnitIds->VendorText) {
        ExFreePool(pUnitIds->VendorText);  pUnitIds->VendorText = NULL;
    }
    
    if(pUnitIds->ulModelLength && pUnitIds->ModelText) {
        ExFreePool(pUnitIds->ModelText);  pUnitIds->ModelText = NULL;
    }

#ifdef NT51_61883
    if(pUnitIds->ulUnitModelLength && pUnitIds->UnitModelText) {
        ExFreePool(pUnitIds->UnitModelText);  pUnitIds->UnitModelText = NULL;
    }
#else
    if(pDevExt->UniRootModelString.Length && pDevExt->UniRootModelString.Buffer) {
        ExFreePool(pDevExt->UniRootModelString.Buffer);  pDevExt->UniRootModelString.Buffer = NULL;
    }
    if(pDevExt->UniUnitModelString.Length && pDevExt->UniUnitModelString.Buffer) {
        ExFreePool(pDevExt->UniUnitModelString.Buffer);  pDevExt->UniUnitModelString.Buffer = NULL;
    }
#endif
}



#define DIFBLK_SIZE 12000

#define PACK_NO_INFO            0xff

// Subcode header identifier
#define SC_HDR_TIMECODE         0x13
#define SC_HDR_BINARYGROUP      0x14

// header identifier

#define AAUX_HDR_SOURCE         0x50
#define AAUX_HDR_SOURCE_CONTROL 0x51
#define AAUX_HDR_REC_DATE       0x52
#define AAUX_HDR_REC_TIME       0x53
#define AAUX_HDR_BINARY_GROUP   0x54
#define AAUX_HDR_CC             0x55
#define AAUX_HDR_TR             0x56

#define VAUX_HDR_SOURCE         0x60
#define VAUX_HDR_SOURCE_CONTROL 0x61
#define VAUX_HDR_REC_DATE       0x62
#define VAUX_HDR_REC_TIME       0x63
#define VAUX_HDR_BINARY_GROUP   0x64
#define VAUX_HDR_CC             0x65
#define VAUX_HDR_TR             0x66

// Determine section type (MS 3 bits); Fig.66; Table 36.
#define ID0_SCT_MASK            0xe0
#define ID0_SCT_HEADER          0x00
#define ID0_SCT_SUBCODE         0x20
#define ID0_SCT_VAUX            0x40
#define ID0_SCT_AUDIO           0x60
#define ID0_SCT_VIDEO           0x80

// A pack is consisted of one byte of header identifier and 4 bytes of data; Part2, annex D.
typedef struct _DV_PACK {
    UCHAR Header;
    UCHAR Data[4];
} DV_PACK, *PDV_PACK;

typedef struct _DV_H0 {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    UCHAR DSF;
    UCHAR DFTIA;
    UCHAR TF1;
    UCHAR TF2;
    UCHAR TF3;

    UCHAR Reserved[72];
} DV_H0, *PDV_H0;

typedef struct _DV_SC {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb0;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb1;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb2;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb3;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb4;
    struct {
        UCHAR SID0;
        UCHAR SID1;
        UCHAR Reserved;
        DV_PACK Pack;
    } SSyb5;

    UCHAR Reserved[29];
} DV_SC, *PDV_SC;

#define MAX_VAUX_PACK 15

typedef struct _DV_VAUX {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;

    DV_PACK Pack[MAX_VAUX_PACK];

    UCHAR Reserved[2];
} DV_VAUX, *PDV_VAUX;

typedef struct _DV_A {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;
    DV_PACK Pack;
    UCHAR Data[72];
} DV_A, *PDV_A;

typedef struct _DV_V {
    UCHAR ID0;
    UCHAR ID1;
    UCHAR ID2;    
    UCHAR Data[77]; // 3..79
} DV_V, *PDV_V;

// Two source packets
#define V_BLOCKS 15
typedef struct _DV_AV {
    DV_A  A;
    DV_V  V[V_BLOCKS];
} DV_AV, *PDV_AV; 


#define SC_SECTIONS     2
#define VAUX_SECTIONS   3
#define AV_SECTIONS     9

typedef struct _DV_DIF_SEQ {
    DV_H0   H0;
    DV_SC   SC[SC_SECTIONS];
    DV_VAUX VAux[VAUX_SECTIONS];
    DV_AV   AV[AV_SECTIONS];
} DV_DIF_SEQ, *PDV_DIF_SEQ;


typedef struct _DV_FRAME_NTSC {
    DV_DIF_SEQ DifSeq[10];
} DV_FRAME_NTSC, *PDV_FRAME_NTSC;

typedef struct _DV_FRAME_PAL {
    DV_DIF_SEQ DifSeq[12];
} DV_FRAME_PAL, *PDV_FRAME_PAL;

// By setting REC MODE to 111b (invalid recording) can
// cause DV to mute the audio
#define AAUX_REC_MODE_INVALID_MASK 0x38   // xx11:1xxx
#define AAUX_REC_MODE_ORIGINAL     0x08   // xx00:1xxx


#ifdef MSDV_SUPPORT_MUTE_AUDIO
BOOL
DVMuteDVFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN OUT PUCHAR      pFrameBuffer,
    IN BOOL            bMuteAudio
    )
{
    PDV_DIF_SEQ pDifSeq;
#if 0
    PDV_VAUX    pVAux;
    ULONG k;
#endif
    ULONG i, j;
#if 0
    BOOL bFound1 = FALSE;
#endif
    BOOL bFound2 = FALSE;

    pDifSeq = (PDV_DIF_SEQ) pFrameBuffer;

    // find the VVAX Source pack
    for (i=0; i < AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].FrameSize/DIFBLK_SIZE; i++) {

// #define SHOW_ONE_FIELD_TWICE
#ifdef SHOW_ONE_FIELD_TWICE  // Advise by Adobe that we may want to show bothj field but mute audio
        // Make the field2 output twice, FrameChange to 0 (same as previous frame)
        for (j=0; j < VAUX_SECTIONS; j++) {
            pVAux = &pDifSeq->VAux[j];
            if((pVAux->ID0 & ID0_SCT_MASK) != ID0_SCT_VAUX) {
                 TRACE(TL_CIP_TRACE,("Invalid ID0:%.2x for pVAUX:%x (Dif:%d;V%d;S%d)\n", pVAux->ID0, pVAux, i, j, k)); 
                continue;
            }

            for (k=0; k< MAX_VAUX_PACK; k++) {
                if(pVAux->Pack[k].Header == VAUX_HDR_SOURCE_CONTROL) {
                    if(bMuteAudio) {
                        TRACE(TL_CIP_TRACE,("Mute Audio; pDifSeq:%x; pVAux:%x; (Dif:%d,V%d,S%d); %.2x,[%.2x,%.2x,%.2x,%.2x]; pack[2]->%.2x\n", \
                            pDifSeq, pVAux, i, j, k, \
                            pVAux->Pack[k].Header, pVAux->Pack[k].Data[0], pVAux->Pack[k].Data[1], pVAux->Pack[k].Data[2], pVAux->Pack[k].Data[3], \
                            (pVAux->Pack[k].Data[2] & 0x1F) ));
                        pVAux->Pack[k].Data[2] &= 0x1f; // 0x1F; // set FF, FS and FC to 0
                        TRACE(TL_CIP_INFO,("pVAux->Pack[k].Data[2] = %.2x\n", pVAux->Pack[k].Data[2])); 
                    } else {
                        TRACE(TL_CIP_INFO,("un-Mute Audio; pack[2]: %.2x ->%.2x\n", pVAux->Pack[k].Data[2], (pVAux->Pack[k].Data[2] | 0xc0) ));  
                        pVAux->Pack[k].Data[2] |= 0xe0; // set FF, FS and FCto 1; Show both fields in field 1,2 order
                    }
                    bFound1 = TRUE;
                    break;   // Set only the 1st occurrence
                }
            }
        }
#endif

        for (j=0; j < AV_SECTIONS; j++) {
            if(pDifSeq->AV[j].A.Pack.Header == AAUX_HDR_SOURCE_CONTROL) {
                TRACE(TL_CIP_INFO,("A0Aux %.2x,[%.2x,%.2x,%.2x,%.2x] %.2x->%.2x\n", \
                    pDifSeq->AV[j].A.Pack.Header,  pDifSeq->AV[j].A.Pack.Data[0], \
                    pDifSeq->AV[j].A.Pack.Data[1], pDifSeq->AV[j].A.Pack.Data[2], pDifSeq->AV[j].A.Pack.Data[3], \
                    pDifSeq->AV[j].A.Pack.Data[1], pDifSeq->AV[j].A.Pack.Data[1] | AAUX_REC_MODE_INVALID_MASK
                    ));
                if(bMuteAudio) 
                    pDifSeq->AV[j].A.Pack.Data[1] |= AAUX_REC_MODE_INVALID_MASK;  // Cause DV to mute this.
                else 
                    pDifSeq->AV[j].A.Pack.Data[1] = \
                        (pDifSeq->AV[j].A.Pack.Data[1] & ~AAUX_REC_MODE_INVALID_MASK) | AAUX_REC_MODE_ORIGINAL;
                bFound2 = TRUE;
                break;  // Set only the 1st occurrence
            }
        }

        // Must do the 1st occurance of all Dif sequences;
        pDifSeq++;  // Next DIF sequence
    }
#if 0
    return (bFound1 && bFound2);  
#else
    return bFound2;
#endif
}
#endif

#ifdef MSDV_SUPPORT_EXTRACT_SUBCODE_DATA

VOID
DVCRExtractTimecodeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    )
{
    PUCHAR pDIFBlk;
    PUCHAR pS0, pS1, pSID0;
    ULONG i, j;
    BYTE LastTimecode[4], Timecode[4]; // hh:mm:ss,ff
    DWORD LastAbsTrackNumber, AbsTrackNumber;
    PUCHAR pSID1;
    BYTE  Timecode2[4]; // hh:mm:ss,ff
    DWORD AbsTrackNumber2;
    BOOL bGetAbsT = TRUE, bGetTimecode = TRUE;


    // Can be called at DISPATCH_LEVEL

    pDIFBlk = (PUCHAR) pFrameBuffer;

    // Save the last timecode so we will now if it has 

    LastTimecode[0] = pStrmExt->Timecode[0];
    LastTimecode[1] = pStrmExt->Timecode[1];
    LastTimecode[2] = pStrmExt->Timecode[2];
    LastTimecode[3] = pStrmExt->Timecode[3];

    LastAbsTrackNumber = pStrmExt->AbsTrackNumber;

    //
    // Traverse thru every DIF BLOCK looking for VA0,1 and 2
    for(i=0; i < AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences; i++) {

        pS0 = pDIFBlk + 80;
        pS1 = pS0     + 80;


        //
        // Is this Subcode source packet? See Table 36 (P.111) of the Blue Book
        //
        if ((pS0[0] & 0xe0) == 0x20 && (pS1[0] & 0xe0) == 0x20) {

            if(bGetAbsT) {
                //
                // See Figure 42 (p. 94) of the Blue book
                // SID0(Low nibble),1 (high nibble) of every three subcode sync block can form the ATN
                //
                pSID0 = &pS0[3];              
                AbsTrackNumber = 0;
                for (j = 0 ; j < 3; j++) {
                    AbsTrackNumber = (( ( (pSID0[0] & 0x0f) << 4) | (pSID0[1] >> 4) ) << (j * 8)) | AbsTrackNumber;
                    pSID0 += 8;
                    bGetAbsT = FALSE;
                }

                pSID1 = &pS1[3];
                AbsTrackNumber2 = 0;
                for (j = 0 ; j < 3; j++) {
                    AbsTrackNumber2 = (( ( (pSID1[0] & 0x0f) << 4) | (pSID1[1] >> 4) ) << (j * 8)) | AbsTrackNumber2;
                    pSID1 += 8;
                }
            
                // Verify that the track number is the same!
                if(AbsTrackNumber == AbsTrackNumber2) {

                    bGetAbsT = FALSE;
                } else {
                   bGetAbsT = TRUE;
                   TRACE(TL_CIP_TRACE,("%d Sequence;  AbsT (%d,%d) != AbsT2 (%d,%d)\n",
                       i,
                       AbsTrackNumber / 2, AbsTrackNumber & 0x01,                       
                       AbsTrackNumber2 / 2, AbsTrackNumber2 & 0x01
                       ));
                }
            }


            if(bGetTimecode) {
                // See Figure 68 (p. 114) of the Blue Book
                // Subcode sync block number 3, 4 and 5
                for(j = 3; j <= 5; j++) {
                    // 3 bytes of IDs and follow by sequence of 8 bytes SyncBlock (3:5); 
                    // 0x13 == TIMECODE
                    if(pS0[3+3+j*8] == 0x13 
                       && pS0[3+3+j*8+4] != 0xff
                       && pS0[3+3+j*8+3] != 0xff
                       && pS0[3+3+j*8+2] != 0xff
                       && pS0[3+3+j*8+1] != 0xff) {

                        Timecode[0] = pS0[3+3+j*8+4]&0x3f;  // hh
                        Timecode[1] = pS0[3+3+j*8+3]&0x7f;  // mm
                        Timecode[2] = pS0[3+3+j*8+2]&0x7f;  // ss
                        Timecode[3] = pS0[3+3+j*8+1]&0x3f;  // ff
                                        
                        bGetTimecode = FALSE;
                        break;                  
                   }
                }

                // Subcode sync block number 9, 10 and 11
                for(j = 3; j <= 5; j++) {
                    // 3 bytes of IDs and follow by sequence of 8 bytes SyncBlock (3:5); 
                    // 0x13 == TIMECODE
                    if(pS1[3+3+j*8] == 0x13
                       && pS1[3+3+j*8+4] != 0xff
                       && pS1[3+3+j*8+3] != 0xff
                       && pS1[3+3+j*8+2] != 0xff
                       && pS1[3+3+j*8+1] != 0xff) {

                       Timecode2[0] = pS1[3+3+j*8+4]&0x3f;  // hh
                       Timecode2[1] = pS1[3+3+j*8+3]&0x7f;  // mm
                       Timecode2[2] = pS1[3+3+j*8+2]&0x7f;  // ss
                       Timecode2[3] = pS1[3+3+j*8+1]&0x3f;  // ff
            
                       bGetTimecode = FALSE;
                       break;                   
                    }
                }

                //
                // Verify
                //
                if(!bGetTimecode) {

                    if( Timecode[0] == Timecode2[0] 
                     && Timecode[1] == Timecode2[1] 
                     && Timecode[2] == Timecode2[2] 
                     && Timecode[3] == Timecode2[3]) {

                       } else {
                        bGetTimecode = TRUE;
                        TRACE(TL_CIP_TRACE,("%d Sequence;  %.2x:%.2x:%.2x,%.2x != %.2x:%.2x:%.2x,%.2x\n",
                            i,
                            Timecode[0],  Timecode[1],  Timecode[2],  Timecode[3],
                            Timecode2[0], Timecode2[1], Timecode2[2], Timecode2[3]
                            ));
                    }       
                }
            }
        }
        
        if(!bGetAbsT && !bGetTimecode) 
            break;

        pDIFBlk += DIFBLK_SIZE;  // Get to next block    
                
    }

    if(!bGetAbsT && pStrmExt->AbsTrackNumber != AbsTrackNumber) {
        pStrmExt->AbsTrackNumber = AbsTrackNumber;  // BF is the LSB  
        pStrmExt->bATNUpdated = TRUE;
        TRACE(TL_CIP_INFO,("Extracted TrackNum:%d; DicontBit:%d\n", AbsTrackNumber / 2, AbsTrackNumber & 0x01));
    }

    if(!bGetTimecode &&
        (
         Timecode[0] != LastTimecode[0] ||
         Timecode[1] != LastTimecode[1] ||
         Timecode[2] != LastTimecode[2] ||
         Timecode[3] != LastTimecode[3]
        ) 
      )  { 
        pStrmExt->Timecode[0] = Timecode[0];  // hh
        pStrmExt->Timecode[1] = Timecode[1];  // mm
        pStrmExt->Timecode[2] = Timecode[2];  // mm
        pStrmExt->Timecode[3] = Timecode[3];  // ff
        pStrmExt->bTimecodeUpdated = TRUE;

        TRACE(TL_CIP_INFO,("Extracted Timecode %.2x:%.2x:%.2x,%.2x\n", Timecode[0], Timecode[1], Timecode[2], Timecode[3]));
    }    
}

#endif // MSDV_SUPPORT_EXTRACT_SUBCODE_DATA


#ifdef MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

VOID
DVCRExtractRecDateAndTimeFromFrame(
    IN PDVCR_EXTENSION pDevExt,
    IN PSTREAMEX       pStrmExt,
    IN PUCHAR          pFrameBuffer
    )
{
    PUCHAR pDIFBlk;
    PUCHAR pS0, pS1;
    ULONG i, j;
    BOOL bGetRecDate = TRUE, bGetRecTime = TRUE;

    // Can be called at DISPATCH_LEVEL


    pDIFBlk = (PUCHAR) pFrameBuffer + DIFBLK_SIZE * AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences/2;


    //
    // REC Data (VRD) and Time (VRT) on in the 2nd half oa a video frame
    // 
    for(i=AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences/2; i < AVCStrmFormatInfoTable[pDevExt->VideoFormatIndex].ulNumOfDIFSequences; i++) {

        pS0 = pDIFBlk + 80;
        pS1 = pS0     + 80;


        //
        // Find SC0 and SC1. See Table 36 (P.111) of the Blue Book
        //
        // SC0/1: ID(0,1,2), Data (3,50), Reserved(51-79)
        //     SC0:Data: SSYB0(3..10), SSYB1(11..18), SSYB2(19..26), SSYB3(27..34), SSYB4(35..42),   SSYB5(43..50)
        //     SC1:Data: SSYB6(3..10), SSYB7(11..18), SSYB8(19..26), SSYB9(27..34), SSYB10(35..42), SSYB11(43..50)
        //         SSYBx(SubCodeId0, SubcodeID1, Reserved, Pack(3,4,5,6,7))
        //
        //  TTC are in the 1st half: SSYB0..11 (every)
        //  TTC are in the 2nd half: SSYB0,3,6,9
        //  VRD are in the 2nd half of a video frame, SSYB1,4,7,10
        //  VRT are in the 2nd half of a video frame, SSYB2,5,8,11
        //

        // Subcode data ?
        if ((pS0[0] & 0xe0) == 0x20 && (pS1[0] & 0xe0) == 0x20) {

            //
            // RecDate: VRD
            //
            if(bGetRecDate) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 1(SSYB1),4(SSYB4) for SC0
                for(j=0; j <= 5 ; j++) {
                    if(j == 1 || j == 4) {
                        // 0x62== RecDate
                        if(pS0[3+3+j*8] == 0x62) {
                            pStrmExt->RecDate[0] = pS0[3+3+j*8+4];        // Year
                            pStrmExt->RecDate[1] = pS0[3+3+j*8+3]&0x1f;   // Month
                            pStrmExt->RecDate[2] = pS0[3+3+j*8+2]&0x3f;   // Day
                            pStrmExt->RecDate[3] = pS0[3+3+j*8+1]&0x3f;   // TimeZone
                            bGetRecDate = FALSE;
                            break;
                        }
                    }
                }
            }

            if(bGetRecDate) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 1 (SSYB7),4(SSYB10) for SC1
                for(j=0; j <= 5; j++) {
                    if(j == 1 || j == 4) {
                        // 0x62== RecDate
                        if(pS1[3+3+j*8] == 0x62) {
                            pStrmExt->RecDate[0] = pS1[3+3+j*8+4];         // Year
                            pStrmExt->RecDate[1] = pS1[3+3+j*8+3]&0x1f;    // Month
                            pStrmExt->RecDate[2] = pS1[3+3+j*8+2]&0x3f;    // Day
                            pStrmExt->RecDate[3] = pS1[3+3+j*8+1]&0x3f;    // TimeZone
                            bGetRecDate = FALSE;
                            break;
                        }
                    }
               }
            }

            //
            // RecTime: VRT
            //
            if(bGetRecTime) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 2(SSYB2),5(SSYB5) for SC0
                for(j=0; j <= 5 ; j++) {
                    if(j == 2 || j == 5) {
                        // 0x63== RecTime
                        if(pS0[3+3+j*8] == 0x63) {
                            pStrmExt->RecTime[0] = pS0[3+3+j*8+4]&0x3f;
                            pStrmExt->RecTime[1] = pS0[3+3+j*8+3]&0x7f;
                            pStrmExt->RecTime[2] = pS0[3+3+j*8+2]&0x7f;
                            pStrmExt->RecTime[3] = pS0[3+3+j*8+1]&0x3f;
                            bGetRecTime = FALSE;
                            break;
                        }
                    }
                }
            }

            if(bGetRecTime) {
                // go thru 6 sync blocks (8 bytes per block) per Subcode; idx 2 (SSYB8),5(SSYB11) for SC1
                for(j=0; j <= 5; j++) {
                    if(j == 2 || j == 5) {
                        // 0x63== RecTime
                        if(pS1[3+3+j*8] == 0x63) {
                            pStrmExt->RecTime[0] = pS1[3+3+j*8+4]&0x3f;
                            pStrmExt->RecTime[1] = pS1[3+3+j*8+3]&0x7f;
                            pStrmExt->RecTime[2] = pS1[3+3+j*8+2]&0x7f;
                            pStrmExt->RecTime[3] = pS1[3+3+j*8+1]&0x3f;
                            bGetRecTime = FALSE;
                            break;
                        }
                    }
                }
            }

        }
        
        if(!bGetRecDate && !bGetRecTime)
            break;

        pDIFBlk += DIFBLK_SIZE;  // Next sequence    
                
    }

    TRACE(TL_PNP_TRACE,("Frame# %.5d, Date %s %x-%.2x-%.2x,  Time %s %.2x:%.2x:%.2x,%.2x\n", 
        (ULONG) pStrmExt->FramesProcessed,
        bGetRecDate ? "NF:" : "Found:", pStrmExt->RecDate[0], pStrmExt->RecDate[1] & 0x1f, pStrmExt->RecDate[2] & 0x3f,                 
        bGetRecTime ? "NF:" : "Found:",pStrmExt->RecTime[0], pStrmExt->RecTime[1], pStrmExt->RecTime[2], pStrmExt->RecTime[3]
       ));
}

#endif //  MSDV_SUPPORT_EXTRACT_DV_DATE_TIME

#ifdef READ_CUTOMIZE_REG_VALUES

NTSTATUS 
CreateRegistryKeySingle(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    NTSTATUS status;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES objectAttributes;

    RtlInitUnicodeString(&ustr, pwszSection);
       InitializeObjectAttributes(
              &objectAttributes,
              &ustr,
              OBJ_CASE_INSENSITIVE,
              hKey,
              NULL
              );

    status = 
           ZwCreateKey(
                  phKeySection,
                  desiredAccess,
                  &objectAttributes,
                  0,
                  NULL,                            /* optional*/
                  REG_OPTION_NON_VOLATILE,
                  NULL
                  );         

    return status;
}



NTSTATUS 
CreateRegistrySubKey(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    UNICODE_STRING ustr;
    USHORT usPos = 1;             // Skip first backslash
    static WCHAR wSep = '\\';
    NTSTATUS status = STATUS_SUCCESS;

    RtlInitUnicodeString(&ustr, pwszSection);

    while(usPos < ustr.Length) {
        if(ustr.Buffer[usPos] == wSep) {

            // NULL terminate our partial string
            ustr.Buffer[usPos] = UNICODE_NULL;
            status = 
                CreateRegistryKeySingle(
                    hKey,
                    desiredAccess,
                    ustr.Buffer,
                    phKeySection
                    );
            ustr.Buffer[usPos] = wSep;

            if(NT_SUCCESS(status)) {
                ZwClose(*phKeySection);
            } else {
                break;
            }
        }
        usPos++;
    }

    // Create the full key
    if(NT_SUCCESS(status)) {
        status = 
            CreateRegistryKeySingle(
                 hKey,
                 desiredAccess,
                 ustr.Buffer,
                 phKeySection
                 );
    }

    return status;
}



NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN PULONG DataLength
    )

/*++

Routine Description:
    
    This routine gets the specified value out of the registry

Arguments:

    Handle - Handle to location in registry

    KeyNameString - registry key we're looking for

    KeyNameStringLength - length of registry key we're looking for

    Data - where to return the data

    DataLength - how big the data is

Return Value:

    status is returned from ZwQueryValueKey

--*/

{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;


    RtlInitUnicodeString(&keyName, KeyNameString);
    
    length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
            KeyNameStringLength + *DataLength;
            
    fullInfo = ExAllocatePool(PagedPool, length); 
     
    if (fullInfo) { 
       
        status = ZwQueryValueKey(
                    Handle,
                   &keyName,
                    KeyValueFullInformation,
                    fullInfo,
                    length,
                   &length
                    );
                        
        if (NT_SUCCESS(status)){

            ASSERT(fullInfo->DataLength <= *DataLength); 

            RtlCopyMemory(
                Data,
                ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                fullInfo->DataLength
                );

        }            

        *DataLength = fullInfo->DataLength;
        ExFreePool(fullInfo);

    }        
    
    return (status);

}



NTSTATUS
SetRegistryKeyValue(
   HANDLE hKey,
   PWCHAR pwszEntry, 
   LONG nValue
   )
{
    NTSTATUS status;
    UNICODE_STRING ustr;

    RtlInitUnicodeString(&ustr, pwszEntry);

    status =          
        ZwSetValueKey(
                  hKey,
                  &ustr,
                  0,            /* optional */
                  REG_DWORD,
                  &nValue,
                  sizeof(nValue)
                  );         

   return status;
}

//
// Registry subky and values wide character strings.
//
WCHAR wszSettings[]      = L"Settings";

WCHAR wszATNSearch[]     = L"bSupportATNSearch";
WCHAR wszSyncRecording[] = L"bSyncRecording";
WCHAR wszMaxDataSync[]   = L"tmMaxDataSync";
WCHAR wszPlayPs2RecPs[]  = L"fmPlayPause2RecPause";
WCHAR wszStop2RecPs[]    = L"fmStop2RecPause";
WCHAR wszRecPs2Rec[]     = L"tmRecPause2Rec";

BOOL
DVGetPropertyValuesFromRegistry(
    IN PDVCR_EXTENSION  pDevExt
    )
{
    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;
    ULONG ulLength; 


    //
    // Registry key: 
    //   Windows 2000:
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    // Win98:
    //    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Class\Image\000x
    // 
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->pPhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_READ, 
            &hPDOKey
            );

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

            // Note: we can be more selective by checking
            //   pDevExt->ulDevType

            // ATNSearch
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszATNSearch, 
                sizeof(wszATNSearch), 
                (PVOID) &pDevExt->bATNSearch, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, bATNSearch:%d (1:Yes)\n", Status, ulLength, pDevExt->bATNSearch));
            if(!NT_SUCCESS(Status)) pDevExt->bATNSearch = FALSE;

            // bSyncRecording
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszSyncRecording, 
                sizeof(wszSyncRecording), 
                (PVOID) &pDevExt->bSyncRecording, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, bSyncRecording:%d (1:Yes)\n", Status, ulLength, pDevExt->bSyncRecording));
            if(!NT_SUCCESS(Status)) pDevExt->bSyncRecording = FALSE;

            // tmMaxDataSync
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszMaxDataSync, 
                sizeof(wszMaxDataSync), 
                (PVOID) &pDevExt->tmMaxDataSync, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, tmMaxDataSync:%d (msec)\n", Status, ulLength, pDevExt->tmMaxDataSync));

            // fmPlayPs2RecPs
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszPlayPs2RecPs, 
                sizeof(wszPlayPs2RecPs), 
                (PVOID) &pDevExt->fmPlayPs2RecPs, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, fmPlayPs2RecPs:%d (frames)\n", Status, ulLength, pDevExt->fmPlayPs2RecPs));

            // fmStop2RecPs
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszStop2RecPs, 
                sizeof(wszStop2RecPs), 
                (PVOID) &pDevExt->fmStop2RecPs, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, fmStop2RecPs:%d (frames)\n", Status, ulLength, pDevExt->fmStop2RecPs));

            // tmRecPs2Rec
            ulLength = sizeof(LONG);
            Status = GetRegistryKeyValue(
                hKeySettings, 
                wszRecPs2Rec, 
                sizeof(wszRecPs2Rec), 
                (PVOID) &pDevExt->tmRecPs2Rec, 
                &ulLength);
            TRACE(TL_PNP_TRACE,("GetRegVal: St:%x, Len:%d, tmRecPs2Rec:%d (msec)\n", Status, ulLength, pDevExt->tmRecPs2Rec));


            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            TRACE(TL_PNP_ERROR,("GetPropertyValuesFromRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        TRACE(TL_PNP_ERROR,("GetPropertyValuesFromRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    // Not implemented so always return FALSE to use the defaults.
    return FALSE;
}


BOOL
DVSetPropertyValuesToRegistry(    
    PDVCR_EXTENSION  pDevExt
    )
{
    // Set the default to :
    //        HLM\Software\DeviceExtension->pchVendorName\1394DCam

    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;

    TRACE(TL_PNP_TRACE,("SetPropertyValuesToRegistry: pDevExt=%x; pDevExt->pBusDeviceObject=%x\n", pDevExt, pDevExt->pBusDeviceObject));


    //
    // Registry key: 
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->pPhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_WRITE, 
            &hPDOKey);

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

#if 0       // Note used, just an example:
            // Brightness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszBrightness,
                pDevExt->XXXX);
            TRACE(TL_PNP_TRACE,("SetPropertyValuesToRegistry: Status %x, Brightness %d\n", Status, pDevExt->Brightness));

#endif
            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            TRACE(TL_PNP_ERROR,("GetPropertyValuesToRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        TRACE(TL_PNP_TRACE,("GetPropertyValuesToRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    return FALSE;
}

#endif  // READ_CUTOMIZE_REG_VALUES


#ifdef SUPPORT_ACCESS_DEVICE_INTERFACE

#if DBG

NTSTATUS
DVGetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PVOID Data,
                   IN ULONG DataLength
)
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    FullInfo = ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }                   // buffer right length

        }                      // if success
        else {
            TRACE(TL_PNP_ERROR,("ReadRegValue failed; ST:%x\n", Status));
        }
        ExFreePool(FullInfo);

    }                           // if fullinfo
    return Status;

}

#endif


#ifdef NT51_61883 
static const WCHAR DeviceTypeName[] = L"GLOBAL";
#endif

static const WCHAR UniqueID_Low[]   = L"UniqueID_Low";
static const WCHAR UniqueID_High[]  = L"UniqueID_High";

static const WCHAR VendorID[]       = L"VendorID";
static const WCHAR ModelID[]        = L"ModelID";

static const WCHAR VendorText[]     = L"VendorText";
static const WCHAR ModelText[]      = L"ModelText";
static const WCHAR UnitModelText[]  = L"UnitModelText";

static const WCHAR DeviceOPcr0Payload[]     = L"DeviceOPcr0Payload";
static const WCHAR DeviceOPcr0DataRate[]    = L"DeviceOPcr0DataRate";


#if DBG
static const WCHAR FriendlyName[]   = L"FriendlyName";
#endif

BOOL
DVAccessDeviceInterface(
    IN PDVCR_EXTENSION  pDevExt,
    IN const ULONG ulNumCategories,
    IN GUID DVCategories[]
    )
/*++

Routine Description:

    Access to the device's interface section and update the VendorText, 
    ModelText and UnitModelText.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE hDevIntfKey;
    UNICODE_STRING *aSymbolicLinkNames, 
#ifdef NT51_61883 
                   RefString,
#endif
                   TempUnicodeString;
    ULONG i;
#ifdef NT51_61883 
#if DBG
    WCHAR DataBuffer[MAX_PATH];
#endif
#endif


    //
    // allocate space for the array of catagory names
    //

    if (!(aSymbolicLinkNames = ExAllocatePool(PagedPool,
                                              sizeof(UNICODE_STRING) * ulNumCategories))) {
        return FALSE;
    }
    //
    // zero the array in case we're unable to fill it in below.  the Destroy
    // routine below will then correctly handle this case.
    //

    RtlZeroMemory(aSymbolicLinkNames, sizeof(UNICODE_STRING) * ulNumCategories);

#ifdef NT51_61883 
    //
    // loop through each of the catagory GUID's for each of the pins,
    // creating a symbolic link for each one.
    //

    RtlInitUnicodeString(&RefString, DeviceTypeName);
#endif

    for (i = 0; i < ulNumCategories; i++) {

        // Register our Device Interface
        ntStatus = IoRegisterDeviceInterface(
            pDevExt->pPhysicalDeviceObject,
            &DVCategories[i],  
#ifdef NT51_61883 
            &RefString, 
#else
            NULL,
#endif
            &aSymbolicLinkNames[i]
            );

        if(!NT_SUCCESS(ntStatus)) {
            //
            //  Can't register device interface
            //
            TRACE(TL_PNP_WARNING,("Cannot register device interface! ST:%x\n", ntStatus));          
            goto Exit;
        }

        TRACE(TL_PNP_TRACE,("AccessDeviceInterface:%d) Cateogory (Len:%d; MaxLen:%d); Name:\n%S\n", i, 
            aSymbolicLinkNames[i].Length, aSymbolicLinkNames[i].MaximumLength, aSymbolicLinkNames[i].Buffer));

        //
        // Get deice interface 
        //
        hDevIntfKey = 0;            
        ntStatus = IoOpenDeviceInterfaceRegistryKey(&aSymbolicLinkNames[i],
                                                     STANDARD_RIGHTS_ALL, 
                                                     &hDevIntfKey);
        if (NT_SUCCESS(ntStatus)) {

#ifdef NT51_61883 
#if DBG
            // Get DeviceInstance
            ntStatus = DVGetRegistryValue(hDevIntfKey, 
                                          (PWCHAR) FriendlyName, 
                                          sizeof(FriendlyName), 
                                          &DataBuffer, 
                                          MAX_PATH);
            if(NT_SUCCESS(ntStatus)) {
               TRACE(TL_PNP_TRACE,("AccessDeviceInterface:%S:%S\n", FriendlyName, DataBuffer));
            } else {
                TRACE(TL_PNP_WARNING,("Get %S failed; ST:%x\n", FriendlyName, ntStatus));
            }
#endif
#endif

            //
            // Update ConfigROM info read from an AV/C device: 
            // UniqueID, VendorID, ModelID,
            // VendorText, ModelText and UnitModelText             
            //

            if(pDevExt->UniqueID.LowPart || pDevExt->UniqueID.HighPart) {

                RtlInitUnicodeString(&TempUnicodeString, UniqueID_High);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->UniqueID.HighPart,  
                              sizeof(pDevExt->UniqueID.HighPart));

                RtlInitUnicodeString(&TempUnicodeString, UniqueID_Low);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->UniqueID.LowPart,  
                              sizeof(pDevExt->UniqueID.LowPart));

               TRACE(TL_PNP_TRACE,("Reg: %S = (Low)%x:(High)%x\n", TempUnicodeString.Buffer, pDevExt->UniqueID.LowPart, pDevExt->UniqueID.HighPart));
            }

            if(pDevExt->ulVendorID) {
                RtlInitUnicodeString(&TempUnicodeString, VendorID);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->ulVendorID,
                              sizeof(pDevExt->ulVendorID));
               TRACE(TL_PNP_TRACE,("Reg: %S = %x\n", TempUnicodeString.Buffer, pDevExt->ulVendorID));
            }

            if(pDevExt->ulModelID) {
                RtlInitUnicodeString(&TempUnicodeString, ModelID);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->ulModelID,
                              sizeof(pDevExt->ulModelID));
               TRACE(TL_PNP_TRACE,("Reg: %S = %x\n", TempUnicodeString.Buffer, pDevExt->ulModelID));
            }

            if(pDevExt->UnitIDs.ulVendorLength && pDevExt->UnitIDs.VendorText) {
                RtlInitUnicodeString(&TempUnicodeString, VendorText);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              pDevExt->UnitIDs.VendorText,
                              pDevExt->UnitIDs.ulVendorLength);
               TRACE(TL_PNP_TRACE,("Reg: %S = %S\n", TempUnicodeString.Buffer, pDevExt->UnitIDs.VendorText));
            }

#ifdef NT51_61883
            if(pDevExt->UnitIDs.ulModelLength && pDevExt->UnitIDs.ModelText) {
                RtlInitUnicodeString(&TempUnicodeString, ModelText);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              pDevExt->UnitIDs.ModelText,
                              pDevExt->UnitIDs.ulModelLength);
               TRACE(TL_PNP_WARNING,("Reg: %S = %S\n", TempUnicodeString.Buffer, pDevExt->UnitIDs.ModelText));
            }
#else
            if(pDevExt->UniRootModelString.Length && pDevExt->UniRootModelString.Buffer) {
                RtlInitUnicodeString(&TempUnicodeString, ModelText);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              pDevExt->UniRootModelString.Buffer,
                              pDevExt->UniRootModelString.Length);
               TRACE(TL_PNP_WARNING,("Reg: %S = %S\n", TempUnicodeString.Buffer, pDevExt->UniRootModelString.Buffer));
            }
#endif

#ifdef NT51_61883
            if(pDevExt->UnitIDs.ulUnitModelLength && pDevExt->UnitIDs.UnitModelText) {
                RtlInitUnicodeString(&TempUnicodeString, UnitModelText);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              pDevExt->UnitIDs.UnitModelText,
                              pDevExt->UnitIDs.ulUnitModelLength);
               TRACE(TL_PNP_WARNING,("Reg: %S = %S\n", TempUnicodeString.Buffer, pDevExt->UnitIDs.UnitModelText));
            }
#else
            if(pDevExt->UniUnitModelString.Length && pDevExt->UniUnitModelString.Buffer) {
                RtlInitUnicodeString(&TempUnicodeString, UnitModelText);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_SZ,
                              pDevExt->UniUnitModelString.Buffer,
                              pDevExt->UniUnitModelString.Length);
               TRACE(TL_PNP_WARNING,("Reg: %S = %S\n", TempUnicodeString.Buffer, pDevExt->UniUnitModelString.Buffer));
            }
#endif

            //
            // Cache cache device's payload field of the oPCR[0]; 
            // The valid range is 0 to 1023 where 0 is 1024.
            // This value is needed for an application figure out 
            // max data rate.  However, if this payload is 
            // dynamically changing, it will not be accurate.
            //

            if(pDevExt->pDevOutPlugs->NumPlugs) {
                //
                // 98 and 146 are two known valid payloads
                //
                ASSERT(pDevExt->pDevOutPlugs->DevPlug[0].PlugState.Payload <= MAX_PAYLOAD-1);  // 0..MAX_PAYLOAD-1 is the valid range; "0" is MAX_PAYLOAD (1024) quadlets.
                RtlInitUnicodeString(&TempUnicodeString, DeviceOPcr0Payload);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->pDevOutPlugs->DevPlug[0].PlugState.Payload, 
                              sizeof(pDevExt->pDevOutPlugs->DevPlug[0].PlugState.Payload));
                TRACE(TL_PNP_TRACE,("Reg: %S = %d quadlets\n", TempUnicodeString.Buffer, pDevExt->pDevOutPlugs->DevPlug[0].PlugState.Payload));

                //
                // 0 (S100), 1(S200) and 2(S400) are the only three valid data rates.
                //
                ASSERT(pDevExt->pDevOutPlugs->DevPlug[0].PlugState.DataRate <= CMP_SPEED_S400);
                RtlInitUnicodeString(&TempUnicodeString, DeviceOPcr0DataRate);
                ZwSetValueKey(hDevIntfKey,
                              &TempUnicodeString,
                              0,
                              REG_DWORD,
                              &pDevExt->pDevOutPlugs->DevPlug[0].PlugState.DataRate,  
                              sizeof(pDevExt->pDevOutPlugs->DevPlug[0].PlugState.DataRate));
                TRACE(TL_PNP_TRACE,("Reg: %S = %d (0:S100,1:S200,2:S400)\n", TempUnicodeString.Buffer, 
                    pDevExt->pDevOutPlugs->DevPlug[0].PlugState.DataRate));
            }

            ZwClose(hDevIntfKey);

        } else {
            TRACE(TL_PNP_ERROR,("IoOpenDeviceInterfaceRegistryKey failed; ST:%x\n", ntStatus));
        }


        RtlFreeUnicodeString(&aSymbolicLinkNames[i]);    
    }

Exit:

    ExFreePool(aSymbolicLinkNames);  aSymbolicLinkNames = NULL;

    return ntStatus == STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\sources.inc ===
#############################################################################
#
#       Confidential Microsoft
#       Copyright (C) Microsoft Corporation 2000-2001
#       All Rights Reserved.
#                                                                          
#       Sources for 1394 Tape subunit driver
#
##########################################################################

TARGETNAME=mstape
TARGETPATH=obj
TARGETTYPE=DRIVER
DRIVERTYPE=WDM

USE_MAPSYM      = 1

INCLUDES=$(MULTIMEDIA_INC_PATH);$(SDK_PATH)\amovie\inc;

TARGETLIBS= \
    $(DDK_LIB_PATH)\stream.lib \
    $(DDK_LIB_PATH)\ksguid.lib

SOURCES= \
    MsTpUtil.c\
    MsTpUppr.c\
    MsTpGuts.c\
    MsTpAvc.c\
    MsTape.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CAPDEBUG_H
#define __CAPDEBUG_H

#define TRAP   KdBreakPoint();

#endif // #ifndef __CAPDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\mstape\strmdata.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001  

Module Name:

    StrmData.h

Abstract:

    Header file for supporting SD DV over 1394;

Last changed by:
    
    Author:      Yee J. Wu

--*/

#ifndef _DVSTRM_INC
#define _DVSTRM_INC



#define STATIC_KSCATEGORY_RENDER_EXTERNAL \
    0xcc7bfb41L, 0xf175, 0x11d1, 0xa3, 0x92, 0x00, 0xe0, 0x29, 0x1f, 0x39, 0x59
DEFINE_GUIDSTRUCT("cc7bfb41-f175-11d1-a392-00e0291f3959", KSCATEGORY_RENDER_EXTERNAL);
#define KSCATEGORY_RENDER_EXTERNAL DEFINE_GUIDNAMED(KSCATEGORY_RENDER_EXTERNAL)

// stream topology stuff for DV
static GUID DVCategories[] = {
    STATIC_KSCATEGORY_VIDEO,             // Output pin
    STATIC_KSCATEGORY_CAPTURE,           // Output pin
    STATIC_KSCATEGORY_RENDER,            // Input pin
    STATIC_KSCATEGORY_RENDER_EXTERNAL,   // Input pin
};

#define NUMBER_OF_DV_CATEGORIES  SIZEOF_ARRAY (DVCategories)

static KSTOPOLOGY DVTopology = {
    NUMBER_OF_DV_CATEGORIES,     // CategoriesCount
    DVCategories,                // Categories
    0,                           // TopologyNodesCount
    NULL,                        // TopologyNodes
    0,                           // TopologyConnectionsCount
    NULL,                        // TopologyConnections
    NULL,                        // TopologyNodesNames
    0,                           // Reserved
};

// stream topology stuff for MPEG2TS 
static GUID MPEG2TSCategories[] = {
    STATIC_KSCATEGORY_VIDEO,             // Output pin
    STATIC_KSCATEGORY_CAPTURE,           // Output pin
};

#define NUMBER_OF_MPEG2TS_CATEGORIES  SIZEOF_ARRAY (MPEG2TSCategories)

static KSTOPOLOGY MPEG2TSTopology = {
    NUMBER_OF_MPEG2TS_CATEGORIES, // CategoriesCount
    MPEG2TSCategories,           // Categories
    0,                           // TopologyNodesCount
    NULL,                        // TopologyNodes
    0,                           // TopologyConnectionsCount
    NULL,                        // TopologyConnections
    NULL,                        // TopologyNodesNames
    0,                           // Reserved
};
    
#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif  
#define FOURCC_DVSD        mmioFOURCC('d', 'v', 's', 'd')

#undef D_X_NTSC
#undef D_Y_NTSC
#undef D_X_NTSC_MIN
#undef D_Y_NTSC_MIN
#undef D_X_PAL
#undef D_Y_PAL
#undef D_X_PAL_MIN
#undef D_Y_PAL_MIN

#define D_X_NTSC            720
#define D_Y_NTSC            480
#define D_X_NTSC_MIN        360
#define D_Y_NTSC_MIN        240

#define D_X_PAL                720
#define D_Y_PAL                576
#define D_X_PAL_MIN            360
#define D_Y_PAL_MIN            288


// ------------------------------------------------------------------------
// External Device PROPERTY
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(ExternalDeviceProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_CAPABILITIES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_PORT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ), 
    
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_POWER_STATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),    

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_ID,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTDEVICE_VERSION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTDEVICE_S),         // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};



DEFINE_KSPROPERTY_TABLE(ExternalTransportProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_CAPABILITIES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_LOAD_MEDIUM,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_MEDIUM_INFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_STATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        // If this is an asychronous operation, we need to set and then get in separate calls.
        KSPROPERTY_EXTXPORT_STATE_NOTIFY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),


    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_ATN_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_EXTXPORT_RTC_SEARCH,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    //
    // Allow any RAW AVC to go through including Vendor dependent
    //
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_RAW_AVC_CMD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_EXTXPORT_S),          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};


DEFINE_KSPROPERTY_TABLE(TimeCodeReaderProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TIMECODE_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_ATN_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_RTC_READER,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSPROPERTY_TIMECODE_S),          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


DEFINE_KSPROPERTY_TABLE(MediaSeekingProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        // Corresponding to IMediaSeeking::IsFormatSupported()
        KSPROPERTY_MEDIASEEKING_FORMATS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData; MULTIPLE_ITEM, 2 step process to get data
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
   ),
};

KSPROPERTY_SET    VideoDeviceProperties[] =
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_EXT_DEVICE,                   // Set
        SIZEOF_ARRAY(ExternalDeviceProperties),         // PropertiesCount
        ExternalDeviceProperties,                       // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_EXT_TRANSPORT,                // Set
        SIZEOF_ARRAY(ExternalTransportProperties),      // PropertiesCount
        ExternalTransportProperties,                    // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_TIMECODE_READER,              // Set
        SIZEOF_ARRAY(TimeCodeReaderProperties),         // PropertiesCount
        TimeCodeReaderProperties,                       // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_MediaSeeking,                    // Set
        SIZEOF_ARRAY(MediaSeekingProperties),         // PropertiesCount
        MediaSeekingProperties,                       // PropertyItem
        0,                                            // FastIoCount
        NULL                                          // FastIoTable
    ),
};

#define NUMBER_VIDEO_DEVICE_PROPERTIES (SIZEOF_ARRAY(VideoDeviceProperties))


// ------------------------------------------------------------------------
// External Device Events
// ------------------------------------------------------------------------

KSEVENT_ITEM ExtDevCommandItm[] = 
{
    {
        KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },    

    {
        KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },

#ifdef MSDVDV_SUPPORT_BUSRESET_EVENT    
    // Application cares about this since AVC command will be ABORTED!
    {
        KSEVENT_EXTDEV_COMMAND_BUSRESET,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },
#endif

    // Tell client this device is being removed.
    {
        KSEVENT_EXTDEV_NOTIFY_REMOVAL,
        0, // sizeof(KSEVENT_ITEM),
        0,
        NULL,
        NULL,
        NULL
    },
};

// define event set related with streams
KSEVENT_SET VideoDeviceEvents[] =
{
    {
        &KSEVENTSETID_EXTDEV_Command,
        SIZEOF_ARRAY(ExtDevCommandItm),
        ExtDevCommandItm,
    },
};

#define NUMBER_VIDEO_DEVICE_EVENTS (SIZEOF_ARRAY(VideoDeviceEvents))


// ------------------------------------------------------------------------
// Stream Property sets for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};


KSPROPERTY_SET    VideoStreamProperties[] =
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))


// ----------------------------------------------------------------------
// Stream events
// ------------------------------------------------------------------------


// FORMAT_DVInfo
//
// Create a local copy of this GUID and make sure that it is not in the PAGED segment
//
const
GUID
KSEVENTSETID_Connection_Local = {STATICGUIDOF(KSEVENTSETID_Connection)};

const
GUID
KSEVENTSETID_Clock_Local = {STATICGUIDOF(KSEVENTSETID_Clock)};

// Isoch transmit End of stream event item
KSEVENT_ITEM EndOfStreamEventItm[] = 
{
    {
        KSEVENT_CONNECTION_ENDOFSTREAM,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

// Clock event item
KSEVENT_ITEM ClockEventItm[] =
{
    {
        KSEVENT_CLOCK_POSITION_MARK,        // position mark event supported
        sizeof (KSEVENT_TIME_MARK),         // requires this data as input
        sizeof (KSEVENT_TIME_MARK),         // allocate space to copy the data
        NULL,
        NULL,
        NULL
    },
#if 0
    {
        KSEVENT_CLOCK_INTERVAL_MARK,        // interval mark event supported
        sizeof (KSEVENT_TIME_INTERVAL),     // requires interval data as input
        sizeof (MYTIME),                    // we use an additional workspace of
                                            // size longlong for processing
                                            // this event
        NULL,
        NULL,
        NULL
    }
#endif
};

KSEVENT_SET ClockEventSet[] =
{
    {
        &KSEVENTSETID_Clock,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    }
};


// define event set related with streams

// Output pin event set
KSEVENT_SET StreamEventsOutPin[] =
{
    {
        &KSEVENTSETID_Clock_Local,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    },
};

// Input pin events set
KSEVENT_SET StreamEventsInPin[] =
{
    {
        &KSEVENTSETID_Connection_Local, 
        SIZEOF_ARRAY(EndOfStreamEventItm),
        EndOfStreamEventItm,
    },
    {
        &KSEVENTSETID_Clock_Local,
        SIZEOF_ARRAY(ClockEventItm),
        ClockEventItm,
    },
};

// Input pin events set for MPEG2TS (has EOS but no clock event)
KSEVENT_SET StreamEventsInPinMPEG2TS[] =
{
    {
        &KSEVENTSETID_Connection_Local, 
        SIZEOF_ARRAY(EndOfStreamEventItm),
        EndOfStreamEventItm,
    },
};

#define NUMBER_STREAM_EVENTS_OUT_PIN (SIZEOF_ARRAY(StreamEventsOutPin))
#define NUMBER_STREAM_EVENTS_IN_PIN (SIZEOF_ARRAY(StreamEventsInPin))

#define NUMBER_STREAM_EVENTS_IN_PIN_MPEG2TS (SIZEOF_ARRAY(StreamEventsInPinMPEG2TS))




// ----------------------------------------------------------------------
// Stream data ranges
// ------------------------------------------------------------------------



/**********************************************************************
 SDDV data range
 **********************************************************************/

// NTSC stream
KS_DATARANGE_VIDEO DvcrNTSCVideoStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),    // FormatSize
        0,                              // Flags
        FRAME_SIZE_SDDV_NTSC,           // SampleSize
        0,                              // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_NTSC_M,        // AnalogVideoStandard
        D_X_NTSC, D_Y_NTSC,         // InputSize, (the inherent size of the incoming signal
                                    //             with every digitized pixel unique)
        D_X_NTSC_MIN, D_Y_NTSC_MIN, // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_NTSC, D_Y_NTSC,         // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_NTSC_MIN, D_Y_NTSC_MIN,     // MinOutputSize, smallest bitmap stream can produce
        D_X_NTSC, D_Y_NTSC,                // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units// MinFrameInterval, 100 nS units
        333667,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SDDV_NTSC * 8)*30,     // MinBitsPerSecond;
        (FRAME_SIZE_SDDV_NTSC * 8)*30,     // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, //D_X_NTSC,D_Y_NTSC,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SDDV_NTSC * 8 * 30),    //    DWORD           dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        333667,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_NTSC,                       //    LONG       biWidth;
        D_Y_NTSC,                       //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSD,                //    DWORD      biCompression;
        FRAME_SIZE_SDDV_NTSC,       //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};

// PAL stream format
KS_DATARANGE_VIDEO DvcrPALVideoStream =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),
        0,                                // Flags
        FRAME_SIZE_SDDV_PAL,              // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    FALSE,              // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,    // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                  // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, //MEDIATYPE_Video
        KS_AnalogVideo_PAL_B,        // AnalogVideoStandard
        D_X_PAL, D_Y_PAL,            // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        D_X_PAL, D_Y_PAL,           // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY    
        1,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        D_X_PAL_MIN, D_Y_PAL_MIN,   // MinOutputSize, smallest bitmap stream can produce
        D_X_PAL, D_Y_PAL,            // MaxOutputSize, largest  bitmap stream can produce
        1,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY
        400000,         // MinFrameInterval, 100 nS units
        400000,         // MaxFrameInterval, 100 nS units
        (FRAME_SIZE_SDDV_PAL * 8)*25,  // MinBitsPerSecond;
        (FRAME_SIZE_SDDV_PAL * 8)*25,  // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0, // D_X_PAL,D_Y_PAL,    // 0,0,720,480
        0,0,0,0,        //    RECT            rcTarget;          // Where the video should go
        (FRAME_SIZE_SDDV_PAL * 8 * 25),  //    DWORD   dwBitRate;         // Approximate bit data rate
        0L,             //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        400000,         //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

        sizeof (KS_BITMAPINFOHEADER),   //    DWORD      biSize;
        D_X_PAL,                        //    LONG       biWidth;
        D_Y_PAL,                        //    LONG       biHeight;
        1,                          //    WORD       biPlanes;
        24,                         //    WORD       biBitCount;
        FOURCC_DVSD,                //    DWORD      biCompression;
        FRAME_SIZE_SDDV_PAL,     //    DWORD      biSizeImage;
        0,                          //    LONG       biXPelsPerMeter;
        0,                          //    LONG       biYPelsPerMeter;
        0,                          //    DWORD      biClrUsed;
        0,                          //    DWORD      biClrImportant;
    },
};



#define NTSC_DVAAuxSrc         0xd1c030cf 
#define PAL_DVAAuxSrc          0xd1e030d0
 
#define NTSC_DVAAuxSrc_DVCPRO  0xd1de30cf 
#define PAL_DVAAuxSrc_DVCPRO   0xd1fe30d0 

// NTSC stream (for iavs connections)
#ifdef SUPPORT_NEW_AVC
KS_DATARANGE_DV_AVC
#else
KS_DATARANGE_DVVIDEO 
#endif
    DvcrNTSCiavStream =
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
        sizeof (KS_DATARANGE_DV_AVC),     // FormatSize
#else
        sizeof (KS_DATARANGE_DVVIDEO),     // FormatSize
#endif
        0,                                 // Flags
        FRAME_SIZE_SDDV_NTSC,              // SampleSize
        0,                                 // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },

    // DVINFO
    // Note: audio is set for 32khz
    {
        //for 1st 5/6 DIF seq.
        NTSC_DVAAuxSrc, // 0xd1c030cf,                    // DWORD dwDVAAuxSrc;
        0xffa0c733,                    // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        0xd1c03fcf,                    // DWORD dwDVAAuxSrc1; 32K, 12bit
        0xffa0ff3f,                    // DWORD dwDVAAuxCtl1;
        //for video information
        0xff00ffff,                    // DWORD dwDVVAuxSrc;
        0xfffcc833,                    // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
#endif
};


// PAL stream (for iavs connections)
#ifdef SUPPORT_NEW_AVC
KS_DATARANGE_DV_AVC
#else
KS_DATARANGE_DVVIDEO 
#endif
    DvcrPALiavStream =
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
        sizeof (KS_DATARANGE_DV_AVC),     // FormatSize
#else
        sizeof (KS_DATARANGE_DVVIDEO),    // FormatSize
#endif
        0,                                // Flags
        FRAME_SIZE_SDDV_PAL,              // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },
    
    // DVINFO
    // Note: Audio is set for 32khz.
    {
        //for 1st 5/6 DIF seq.
        PAL_DVAAuxSrc, // 0xd1e030d0,                    // DWORD dwDVAAuxSrc;
        0xffa0cf3f,                    // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        0xd1e03fd0,                    // DWORD dwDVAAuxSrc1; 32k, 12bit
        0xffa0cf3f,                    // DWORD dwDVAAuxCtl1;
        //for video information
        0xff20ffff,                    // DWORD dwDVVAuxSrc;
        0xfffdc83f,                    // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
#endif
};


// NTSC stream (for iavs connections)
#ifdef SUPPORT_NEW_AVC
KS_DATARANGE_DV_AVC
#else
KS_DATARANGE_DVVIDEO 
#endif
    DvcrNTSCiavStreamIn =
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
        sizeof (KS_DATARANGE_DV_AVC),     // FormatSize
#else
        sizeof (KS_DATARANGE_DVVIDEO),     // FormatSize
#endif
        0,                                 // Flags
        FRAME_SIZE_SDDV_NTSC,              // SampleSize
        0,                                 // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },

    // DVINFO
    // Note: audio is set for 32khz
    {
        //for 1st 5/6 DIF seq.
        NTSC_DVAAuxSrc, // 0xd1c030cf,                    // DWORD dwDVAAuxSrc;
        0xffa0c733,                    // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        0xd1c03fcf,                    // DWORD dwDVAAuxSrc1; 32K, 12bit
        0xffa0ff3f,                    // DWORD dwDVAAuxCtl1;
        //for video information
        0xff00ffff,                    // DWORD dwDVVAuxSrc;
        0xfffcc833,                    // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
#endif
};


// PAL stream (for iavs connections)
#ifdef SUPPORT_NEW_AVC
KS_DATARANGE_DV_AVC
#else
KS_DATARANGE_DVVIDEO 
#endif
    DvcrPALiavStreamIn =
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
        sizeof (KS_DATARANGE_DV_AVC),     // FormatSize
#else
        sizeof (KS_DATARANGE_DVVIDEO),    // FormatSize
#endif
        0,                                // Flags
        FRAME_SIZE_SDDV_PAL,              // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_INTERLEAVED,
        STATIC_KSDATAFORMAT_SUBTYPE_DVSD,
        STATIC_KSDATAFORMAT_SPECIFIER_DVINFO,
    },
    
    // DVINFO
    // Note: Audio is set for 32khz.
    {
        //for 1st 5/6 DIF seq.
        PAL_DVAAuxSrc, // 0xd1e030d0,                    // DWORD dwDVAAuxSrc;
        0xffa0cf3f,                    // DWORD dwDVAAuxCtl;
        // for 2nd  5/6 DIF seq.
        0xd1e03fd0,                    // DWORD dwDVAAuxSrc1; 32k, 12bit
        0xffa0cf3f,                    // DWORD dwDVAAuxCtl1;
        //for video information
        0xff20ffff,                    // DWORD dwDVVAuxSrc;
        0xfffdc83f,                    // DWORD dwDVVAuxCtl;
        0,                             // DWORD dwDVReserved[2];
        0,                             //
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug Handle
     0,   // UnitPlugNumber
    },
#endif
};





//
// A driver does not support both format at the same time,
// the MediaType (NTSC or PAL) is determined at the load time.
//

PKSDATAFORMAT DVCRStream0Formats[] = 
{
    (PKSDATAFORMAT) &DvcrNTSCVideoStream,
    (PKSDATAFORMAT) &DvcrPALVideoStream,
};

PKSDATAFORMAT DVCRStream1Formats[] = 
{
    (PKSDATAFORMAT) &DvcrNTSCiavStream,
    (PKSDATAFORMAT) &DvcrPALiavStream,
};

PKSDATAFORMAT DVCRStream2Formats[] = 
{
    (PKSDATAFORMAT) &DvcrNTSCiavStreamIn,
    (PKSDATAFORMAT) &DvcrPALiavStreamIn,
};


static KSPIN_MEDIUM NULLMedium = {STATIC_GUID_NULL, 0, 0};


#define NUM_DVCR_STREAM0_FORMATS        (SIZEOF_ARRAY(DVCRStream0Formats))
#define NUM_DVCR_STREAM1_FORMATS        (SIZEOF_ARRAY(DVCRStream1Formats))
#define NUM_DVCR_STREAM2_FORMATS        (SIZEOF_ARRAY(DVCRStream2Formats))

static GUID guidPinCategoryCapture  = {STATIC_PINNAME_VIDEO_CAPTURE};

static GUID guidPinNameDVVidOutput  = {STATIC_PINNAME_DV_VID_OUTPUT};
static GUID guidPinNameDVAVOutput   = {STATIC_PINNAME_DV_AV_OUTPUT};
static GUID guidPinNameDVAVInput    = {STATIC_PINNAME_DV_AV_INPUT};

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

STREAM_INFO_AND_OBJ DVStreams [] = 
{
    // -----------------------------------------------------------------
    // Stream 0, DV coming from the camcorder
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_OUT,                             // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM0_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream0Formats,                             // StreamFormatsArray
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
        (PKSPROPERTY_SET) VideoStreamProperties,        // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_OUT_PIN,                   // NumStreamEventArrayEntries
        StreamEventsOutPin,                             // StreamEventsArray
        &guidPinCategoryCapture,                        // Category
        &guidPinNameDVVidOutput,                        // Name
        0,                                              // Mediums count
        &NULLMedium,                                    // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        0,                                              // StreamNumber
        0,                                              // HwStreamExtension
        AVCTapeRcvDataPacket,                           // ReceiveDataPacket
        AVCTapeRcvControlPacket,                        // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) AVCTapeStreamClockRtn, // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        sizeof(KS_FRAME_INFO),                          // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        AVCTapeEventHandler,                            // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },
    },

    // -----------------------------------------------------------------
    // Stream 1, DV coming from the camcorder (interleaved format)
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_OUT,                             // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM1_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream1Formats,                             // StreamFormatsArrayf
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
        (PKSPROPERTY_SET) VideoStreamProperties,        // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_OUT_PIN,                   // NumStreamEventArrayEntries
        StreamEventsOutPin,                             // StreamEventsArray
        &guidPinCategoryCapture,                        // Category
        &guidPinNameDVAVOutput,                         // Name
        0,                                              // Mediums count
        &NULLMedium,                                    // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        1,                                              // StreamNumber
        0,                                              // HwStreamExtension
        AVCTapeRcvDataPacket,                           // ReceiveDataPacket
        AVCTapeRcvControlPacket,                        // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) AVCTapeStreamClockRtn, // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        AVCTapeEventHandler,                            // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },    
    },
 

    // -----------------------------------------------------------------
    // Stream 2, DV flows out of the adapter (interleaved)
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
        1,                                              // NumberOfPossibleInstances
        KSPIN_DATAFLOW_IN,                              // DataFlow
        TRUE,                                           // DataAccessible
        NUM_DVCR_STREAM2_FORMATS,                       // NumberOfFormatArrayEntries
        DVCRStream2Formats,                             // StreamFormatsArray
        0,                                              // ClassReserved[0]
        0,                                              // ClassReserved[1]
        0,                                              // ClassReserved[2]
        0,                                              // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
        (PKSPROPERTY_SET) VideoStreamProperties,        // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_IN_PIN,                    // NumStreamEventArrayEntries
        StreamEventsInPin,                              // StreamEventsArray
        NULL,                                           // Category
        &guidPinNameDVAVInput,                          // Name
        0,                                              // Mediums count
        &NULLMedium,                                    // Mediums
        FALSE,                                          // BridgeStream
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        2,                                              // StreamNumber
        0,                                              // HwStreamExtension
        AVCTapeRcvDataPacket,                           // ReceiveDataPacket
        AVCTapeRcvControlPacket,                        // ReceiveControlPacket
        {
            (PHW_CLOCK_FUNCTION) AVCTapeStreamClockRtn, // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        AVCTapeEventHandler,                            // HwEventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        }
    }
};

#define DV_STREAM_COUNT        (SIZEOF_ARRAY(DVStreams))




/**********************************************************************
 MPEG2TS data range
 **********************************************************************/

 
static GUID guidPinNameMPEG2TSOutput  = {STATIC_PINNAME_MPEG2TS_OUTPUT};
static GUID guidPinNameMPEG2TSInput   = {STATIC_PINNAME_MPEG2TS_INPUT};

//
// Default buffer setting for MPEG2TS
//

#define SRC_PACKETS_PER_MPEG2TS_FRAME   256 // Variable length

#define BUFFER_SIZE_MPEG2TS      (((CIP_DBS_MPEG << 2) * (1 << CIP_FN_MPEG) - 4) * SRC_PACKETS_PER_MPEG2TS_FRAME)
#define BUFFER_SIZE_MPEG2TS_SPH  (((CIP_DBS_MPEG << 2) * (1 << CIP_FN_MPEG)    ) * SRC_PACKETS_PER_MPEG2TS_FRAME)

#define NUM_OF_RCV_BUFFERS_MPEG2TS      MAX_DATA_BUFFERS
#define NUM_OF_XMT_BUFFERS_MPEG2TS      MAX_DATA_BUFFERS


// These values are from the "Blue book" Part 4 P. 9-10
// transmission rate:
//     Src Pkt/cycle
//         1/8       : 188/8 bytes * 8000 cycles * 8 bits/byte =  1,504,000 bits/sec 
//         ...
//         1/2       : 188/2 bytes * 8000 cycles * 8 bits/byte =  6,015,000 bits/sec 
//          1        : 188   bytes * 8000 cycles * 8 bits/byte = 12,032,000 bits/sec
//          5        : 188*5 bytes * 8000 cycles * 8 bits/byte = 60,160,000 bits/sec
//          


// this structure reuqires inclusion of "bdatypes.h" for MPEG2_TRANSPORT_STRIDE
typedef struct tagKS_DATARANGE_MPEG2TS_STRIDE_AVC {
   KSDATARANGE             DataRange;
   MPEG2_TRANSPORT_STRIDE  Stride;
   AVCPRECONNECTINFO       ConnectInfo;
} KS_DATARANGE_MPEG2TS_STRIDE_AVC, *PKS_DATARANGE_MPEG2TS_STRIDE_AVC;

KS_DATARANGE_MPEG2TS_STRIDE_AVC
MPEG2TStreamOutStride =      
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
     sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC),                                 // FormatSize
#else
     sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC) - sizeof(AVCPRECONNECTINFO),     // FormatSize; exclude AVCPRECONNECTINFO
#endif
     0,                                 // Flags
     BUFFER_SIZE_MPEG2TS_SPH,           // SampleSize with SPH:192*N
     0,                                 // Reserved
     STATIC_KSDATAFORMAT_TYPE_STREAM,
     STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE, 
     // If there is a format block (like MPEG2_TRANSPORT_STRIDE), 
     // the specifier cannot use STATIC_KSDATAFORMAT_SPECIFIER_NONE or _WILDCARD    
     STATIC_KSDATAFORMAT_SPECIFIER_61883_4,  
    },
    // MPEG2_TRANSPORT_STRIDE 
    {
    MPEG2TS_STRIDE_OFFSET,     // 4
    MPEG2TS_STRIDE_PACKET_LEN, // 188
    MPEG2TS_STRIDE_STRIDE_LEN, // 192
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug handle
     0,   // UnitPlugNumber
    },
#endif
};

KS_DATARANGE_MPEG2TS_AVC
MPEG2TStreamOut =      
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
     sizeof(KS_DATARANGE_MPEG2TS_AVC),                                 // FormatSize
#else
     sizeof(KS_DATARANGE_MPEG2TS_AVC) - sizeof(AVCPRECONNECTINFO),     // FormatSize; exclude AVCPRECONNECTINFO
#endif
     0,                                 // Flags
     BUFFER_SIZE_MPEG2TS,               // SampleSize:188*N
     0,                                 // Reserved
     STATIC_KSDATAFORMAT_TYPE_STREAM,
     STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT,
     STATIC_KSDATAFORMAT_SPECIFIER_NONE,
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug handle
     0,   // UnitPlugNumber
    },
#endif
};



KS_DATARANGE_MPEG2TS_STRIDE_AVC
MPEG2TStreamInStride =      
{
    // KSDATARANGE
    {
#ifdef SUPPORT_NEW_AVC
     sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC),                                 // FormatSize
#else
     sizeof(KS_DATARANGE_MPEG2TS_STRIDE_AVC) - sizeof(AVCPRECONNECTINFO),     // FormatSize; exclude AVCPRECONNECTINFO
#endif
     0,                                 // Flags
     BUFFER_SIZE_MPEG2TS_SPH,           // SampleSize with SPH:192*N
     0,                                 // Reserved
     STATIC_KSDATAFORMAT_TYPE_STREAM,
     STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT_STRIDE,
     // If there is a format block (like MPEG2_TRANSPORT_STRIDE), 
     // the specifier cannot use STATIC_KSDATAFORMAT_SPECIFIER_NONE or _WILDCARD 
     STATIC_KSDATAFORMAT_SPECIFIER_61883_4,
    },
    // MPEG2_TRANSPORT_STRIDE 
    {
    MPEG2TS_STRIDE_OFFSET,     // 4
    MPEG2TS_STRIDE_PACKET_LEN, // 188
    MPEG2TS_STRIDE_STRIDE_LEN, // 192
    },
#ifdef SUPPORT_NEW_AVC
    // AVCPRECONNECTINFO
    {
     0,   // Device ID
     0,   // Subunit address
     0,   // Subunit Plug number
     0,   // Data Flow
     0,   // Flag/Plug handle
     0,   // UnitPlugNumber
    },
#endif
};


PKSDATAFORMAT MPEG2TStream0Formats[] = 
{

    (PKSDATAFORMAT) &MPEG2TStreamOutStride,
    (PKSDATAFORMAT) &MPEG2TStreamOut,
};

#define NUM_MPEG_STREAM0_FORMATS  (SIZEOF_ARRAY(MPEG2TStream0Formats))

PKSDATAFORMAT MPEG2TStream1Formats[] = 
{
    (PKSDATAFORMAT) &MPEG2TStreamInStride,
};

#define NUM_MPEG_STREAM1_FORMATS  (SIZEOF_ARRAY(MPEG2TStream1Formats))


STREAM_INFO_AND_OBJ MPEGStreams [] = 
{
    // -----------------------------------------------------------------
    // Stream 0, MPEG2 TS coming from the AV device
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------        
        {
        1,                                      // NumberOfPossibleInstances
        KSPIN_DATAFLOW_OUT,                     // DataFlow
        TRUE,                                   // DataAccessible
        NUM_MPEG_STREAM0_FORMATS,               // NumberOfFormatArrayEntries
        MPEG2TStream0Formats,                   // StreamFormatsArray
        0,                                      // ClassReserved[0]
        0,                                      // ClassReserved[1]
        0,                                      // ClassReserved[2]
        0,                                      // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
        (PKSPROPERTY_SET) VideoStreamProperties, // StreamPropertiesArray
        0,                                      // NUMBER_STREAM_EVENTS,                           // NumStreamEventArrayEntries
        NULL,                                   // StreamEvents,
        &guidPinCategoryCapture,                // Category
        &guidPinNameMPEG2TSOutput,              // Name
        0,                                      // MediumsCount
        NULL,                                   // Mediums
        FALSE,                                  // BridgeStream
        0,
        0
        },


        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        0,                                              // StreamNumber
        0,                                              // HwStreamExtension
        AVCTapeRcvDataPacket,                           // ReceiveDataPacket
        AVCTapeRcvControlPacket,                        // ReceiveControlPacket
        {
#if 0
            (PHW_CLOCK_FUNCTION) AVCTapeStreamClockRtn, // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
#else
            (PHW_CLOCK_FUNCTION) NULL,                  // HW_CLOCK_OBJECT.HWClockFunction
            0,                                          // HW_CLOCK_OBJECT.ClockSupportFlags
#endif
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        NULL,                                           // EventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },
    },
    // -----------------------------------------------------------------
    // Stream 1, MPEG2 TS from adapter to the AV device
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------        
        {
        1,                                      // NumberOfPossibleInstances
        KSPIN_DATAFLOW_IN,                      // DataFlow
        TRUE,                                   // DataAccessible
        NUM_MPEG_STREAM1_FORMATS,               // NumberOfFormatArrayEntries
        MPEG2TStream1Formats,                   // StreamFormatsArray
        0,                                      // ClassReserved[0]
        0,                                      // ClassReserved[1]
        0,                                      // ClassReserved[2]
        0,                                      // ClassReserved[3]
        NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
        (PKSPROPERTY_SET) VideoStreamProperties, // StreamPropertiesArray
        NUMBER_STREAM_EVENTS_IN_PIN_MPEG2TS,    // NumStreamEventArrayEntries
        StreamEventsInPinMPEG2TS,               // StreamEventsArray
        &guidPinCategoryCapture,                // Category
        &guidPinNameMPEG2TSInput,               // Name
        0,                                      // MediumsCount
        NULL,                                   // Mediums
        FALSE,                                  // BridgeStream
        0,
        0
        },


        // HW_STREAM_OBJECT ------------------------------------------------
        {
        sizeof(HW_STREAM_OBJECT),
        1,                                              // StreamNumber
        0,                                              // HwStreamExtension
        AVCTapeRcvDataPacket,                           // ReceiveDataPacket
        AVCTapeRcvControlPacket,                        // ReceiveControlPacket
        {
#if 0
            (PHW_CLOCK_FUNCTION) AVCTapeStreamClockRtn, // HW_CLOCK_OBJECT.HWClockFunction
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,       // HW_CLOCK_OBJECT.ClockSupportFlags
#else
            (PHW_CLOCK_FUNCTION) NULL,                  // HW_CLOCK_OBJECT.HWClockFunction
            0,                                          // HW_CLOCK_OBJECT.ClockSupportFlags
#endif
            0,                                          // HW_CLOCK_OBJECT.Reserved[0]
            0,                                          // HW_CLOCK_OBJECT.Reserved[1]
        },
        FALSE,                                          // Dma
        FALSE,                                          // Pio
        0,                                              // HwDeviceExtension
        0,                                              // StreamHeaderMediaSpecific
        0,                                              // StreamHeaderWorkspace 
        FALSE,                                          // Allocator 
        NULL,                                           // EventRoutine
        0,                                              // Reserved[0]
        0,                                              // Reserved[1]
        },
    }
};


#define MPEG_STREAM_COUNT        (SIZEOF_ARRAY(MPEGStreams))



/**********************************************************************
 Supported AVC Stream format information table
 **********************************************************************/

#define BLOCK_PERIOD_MPEG2TS  192   // number of 1394 cycle offset to send one block

AVCSTRM_FORMAT_INFO AVCStrmFormatInfoTable[] = {
//
// SDDV_NTSC
//
    {
        sizeof(AVCSTRM_FORMAT_INFO),
        AVCSTRM_FORMAT_SDDV_NTSC,
        {
            0,0,
            CIP_DBS_SDDV,
            CIP_FN_DV,
            CIP_QPC_DV,
            CIP_SPH_DV,0,
            0
        },  // CIP header[0]
        { 
            0x2, 
            CIP_FMT_DV,
            CIP_60_FIELDS, 
            CIP_STYPE_DV, 0,
            0
        },  // CIP header[1]
        SRC_PACKETS_PER_NTSC_FRAME,
        FRAME_SIZE_SDDV_NTSC,
        NUM_OF_RCV_BUFFERS_DV,
        NUM_OF_XMT_BUFFERS_DV,
        FALSE,  // No source header
        FRAME_TIME_NTSC,
        BLOCK_PERIOD_2997,
        0,0,0,0,
    },
//
// SDDV_PAL
//
    { 
        sizeof(AVCSTRM_FORMAT_INFO),
        AVCSTRM_FORMAT_SDDV_PAL,
        {
            0,0,
            CIP_DBS_SDDV,
            CIP_FN_DV,
            CIP_QPC_DV,
            CIP_SPH_DV,0,
            0
        },  // CIP header[0]
        { 
            0x2, 
            CIP_FMT_DV,
            CIP_50_FIELDS, 
            CIP_STYPE_DV, 0,
            0
        },  // CIP header[1]
        SRC_PACKETS_PER_PAL_FRAME,
        FRAME_SIZE_SDDV_PAL, 
        NUM_OF_RCV_BUFFERS_DV,
        NUM_OF_XMT_BUFFERS_DV,
        FALSE,  // No source header
        FRAME_TIME_PAL,
        BLOCK_PERIOD_25,
        0,0,0,0,
    },
//
// MPEG2TS
//
    { 
        sizeof(AVCSTRM_FORMAT_INFO),
        AVCSTRM_FORMAT_MPEG2TS,
        {
            0,0,
            CIP_DBS_MPEG,
            CIP_FN_MPEG,
            CIP_QPC_MPEG,
            CIP_SPH_MPEG,0,
            0
        },  // CIP header[0]
        { 
            0x2, 
            CIP_FMT_MPEG,
            CIP_TSF_OFF,\
            0, 0,
            0
        },  // CIP header[1]
        SRC_PACKETS_PER_MPEG2TS_FRAME,  // Default
        BUFFER_SIZE_MPEG2TS_SPH,        // Default
        NUM_OF_RCV_BUFFERS_MPEG2TS,
        NUM_OF_XMT_BUFFERS_MPEG2TS,
        FALSE,  // Strip source packet header
        FRAME_TIME_NTSC,
        BLOCK_PERIOD_MPEG2TS,  
        0,0,0,0,
    },
//
// HDDV_NTSC
// ...

//
// HDDV_PAL
// ...

//
// SDLDV_NTSC
// ...

//
// SDLDV_PAL
// ...
};



#endif  // _DVSTRM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\bert.h ===
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//     This software is supplied under the terms of a license agreement or
//     nondisclosure agreement with Intel Corporation and may not be copied
//     or disclosed except in accordance with the terms of that agreement.
//           Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
//  Workfile: BERT.H
//
//  Purpose:
//     This header contains the defines for the Bert Gate Array Asic
//     registers and functions
//
//  Contents:
//

#ifndef  _BERT_H_
#define _BERT_H_

// Bert register offsets

#define BERT_CAPSTAT_REG        0x00
#define BERT_VINSTAT_REG        0x04
#define BERT_INTSTAT_REG        0x08
#define BERT_INTRST_REG         0x0c
#define BERT_IIC_REG            0x10
#define BERT_FIFOCFG_REG        0x14
#define BERT_RPSADR_REG         0x18

#define BERT_UALIMIT_REG        0x20
#define BERT_LALIMIT_REG        0x24
#define BERT_RPSPAGE_REG        0x28

#define BERT_YPTR_REG           0x30
#define BERT_UPTR_REG           0x34
#define BERT_VPTR_REG           0x38

#define BERT_YSTRIDE_REG        0x40
#define BERT_USTRIDE_REG        0x44
#define BERT_VSTRIDE_REG        0x48

#define BERT_DALI_REG           0x50
#define BERT_EEPROM_REG         0x60

#define BERT_DMASTAT_REG        0x70
#define BERT_TEST_REG           0x74

// for Pistachio's Register 97-03-21(Fri)
#define BERT_P_SKIP_REG                 0x80
#define BERT_P_ISIZ_REG                 0x84
#define BERT_P_OSIZ_REG                 0x88
#define BERT_P_LUMI_REG                 0x8c
#define BERT_P_COL_REG                  0x90
#define BERT_P_FILT_REG                 0x94
#define BERT_P_SUP1_REG                 0x98
#define BERT_P_SUP2_REG                 0x9c
#define BERT_P_SUP3_REG                 0xa0

#define BERT_BURST_LEN                  0x9c    // Insert 97-03-17(Mon)

#define BERT_FER_REG                    0xf0
#define BERT_FEMR_REG                   0xf4
#define BERT_FPSR_REG                   0xf8
#define BERT_FECREG                     0xfc

// I2C status byte bits
#define I2C_OFFSET                      0x40

#define I2CSTATUS_ALTD          0x02
#define I2CSTATUS_FIDT          0x20
#define I2CSTATUS_HLCK          0x40

// INTSTAT Interrupt status register bit defines

#define FIELD_INT             0x00000001
#define RPS_INT               0x00000002
#define SYNC_LOCK_INT         0x00000004
#define SPARE_INT             0x00000008
#define FIFO_OVERFLOW_INT     0x00000010
#define LINE_TIMEOUT_INT      0x00000020
#define RPS_OOB_INT           0x00000040
#define REG_UNDEF_INT         0x00000080

#define CODEC_INT             0x00000100
#define SLOW_CLOCK_INT        0x00000200
#define OVER_RUN_INT          0x00000400
#define REG_LOAD_INT          0x00000800
#define LINE_SYNC_INT         0x00001000
#define IIC_ERROR_INT         0x00002000
#define PCI_PARITY_ERROR_INT  0x00004000
#define PCI_ACCESS_ERROR_INT  0x00008000

// INSTAT Interrupt enable OR mask bits

#define FIELD_INT_MASK            0x00010000
#define RPS_INT_MASK              0x00020000
#define SYNC_LOCK_INT_MASK        0x00040000
#define SPARE_INT_MASK            0x00080000
#define FIFO_OVERFLOW_INT_MASK    0x00100000
#define LINE_TIMEOUT_INT_MASK     0x00200000
#define RPS_OOB_INT_MASK          0x00400000
#define REG_UNDEF_INT_MASK        0x00800000

#define CODEC_INT_MASK            0x01000000
#define SLOW_CLOCK_INT_MASK       0x02000000
#define OVER_RUN_INT_MASK         0x04000000
#define REG_LOAD_INT_MASK         0x08000000
#define LINE_SYNC_INT_MASK        0x10000000
#define IIC_ERROR_INT_MASK        0x20000000
#define PCI_PARITY_ERROR_INT_MASK 0x40000000
#define PCI_ACCESS_ERROR_INT_MASK 0x80000000


// INTRST Interrupt ReSeT Register bits
// reset bits
#define FIELD_INT_RESET             0x00000001
#define RPS_INT_RESET               0x00000002
#define SYNC_LOCK_INT_RESET         0x00000004
#define SPARE_INT_RESET             0x00000008
#define FIFO_OVERFLOW_INT_RESET     0x00000010
#define LINE_TIMEOUT_INT_RESET      0x00000020
#define RPS_OOB_INT_RESET           0x00000040
#define REG_UNDEF_INT_RESET         0x00000080

#define SLOW_CLOCK_INT_RESET        0x00000200
#define OVER_RUN_INT_RESET          0x00000400
#define REG_LOAD_INT_RESET          0x00000800
#define LINE_SYNC_INT_RESET         0x00001000
#define IIC_ERROR_INT_RESET         0x00002000
#define PCI_PARITY_ERROR_INT_RESET  0x00004000
#define PCI_ACCESS_ERROR_INT_RESET  0x00008000

// set bits
#define FIELD_INT_SET               0x00010000
#define RPS_INT_SET                 0x00020000
#define SYNC_LOCK_INT_SET           0x00040000
#define SPARE_INT_SET               0x00080000
#define FIFO_OVERFLOW_INT_SET       0x00100000
#define LINE_TIMEOUT_INT_SET        0x00200000
#define RPS_OOB_INT_SET             0x00400000
#define REG_UNDEF_INT_SET           0x00800000

#define SLOW_CLOCK_INT_SET          0x02000000
#define OVER_RUN_INT_SET            0x04000000
#define REG_LOAD_INT_SET            0x08000000
#define LINE_SYNC_INT_SET           0x10000000
#define IIC_ERROR_INT_SET           0x20000000
#define PCI_PARITY_ERROR_INT_SET    0x40000000
#define PCI_ACCESS_ERROR_INT_SET    0x80000000

#define TEST_MAKE_VORLON1           0x10000000

//
// The following values for the FIFO trip points and giving unlimited
// PCI bus master access is reasonable for all platforms.
//

#define BERT_DEF_TRIP_POINTS    16
#define BERT_DEF_PCI_BURST_LEN  3


typedef struct _RPS_COMMAND
{
   union
   {
      struct
      {
         ULONG  RegisterOffset:8;
         ULONG  Reserved:19;
         ULONG  FWait:1;
         ULONG  Edge:1;
         ULONG  Int:1;
         ULONG  ReadWrite:1;
         ULONG  Continue:1;
      } bits;
      ULONG  AsULONG;
   } u;

   ULONG Argument;

} RPS_COMMAND, *PRPS_COMMAND;

#define RPS_COMMAND_CONT          0x80000000
#define RPS_COMMAND_STOP          0x00000000
#define RPS_COMMAND_READ          0x40000000
#define RPS_COMMAND_WRITE         0x00000000
#define RPS_COMMAND_INT           0x20000000
#define RPS_COMMAND_NOINT         0x00000000
#define RPS_COMMAND_RISE_EDGE     0x10000000
#define RPS_COMMAND_FALL_EDGE     0x00000000
#define RPS_COMMAND_FWAIT         0x00000000


#define RPS_COMMAND_DEFAULT   (RPS_COMMAND_STOP | RPS_COMMAND_WRITE |      \
                               RPS_COMMAND_RISE_EDGE | RPS_COMMAND_FWAIT | \
                               RPS_COMMAND_NOINT)

// RPS COMMAND
#define RPS_CONTINUE_CMD        0x80000000
#define RPS_READ_CMD            0x40000000
#define RPS_INT_CMD             0x20000000



// Enable bits for the CAPSTAT register
#define RST             0x80000000              // Reset front end.
#define EBMV            0x10000000              // Enable Bus Master Video (i.e. DMA)
#define EREO            0x04000000              // Enable RPS Even
#define EROO            0x02000000              // Enable RPS Odd
#define LOCK            0x00002000              // Sync Lock
#define RPSS            0x00001000              // RPS Status
#define GO0             0x00000010              // Power to camara
#define CKRE            0x00000008              // Clock Run Enable             // Add 97-05-08
#define CKMD            0x00000004              // Clock Request Mode   // Add 97-05-08
#define ERPS            0x08000000              // Enable RPS
#define FEMR_ENABLE     0x00008000
#define CAMARA_OFF      RST

//#define PASSIVE_ENABLE        (ERPS | GO0)
//#define CAPTURE_EVEN          (ERPS | EREO | GO0 | EBMV)
//#define CAPTURE_ODD           (ERPS | EROO | GO0 | EBMV)
//#define SKIP_EVEN             (ERPS | EREO | GO0)
//#define SKIP_ODD              (ERPS | EROO | GO0)

#define PASSIVE_ENABLE  ERPS            // DEL GO0 97-04-07(Mon) BUN
#define CAPTURE_EVEN    (ERPS | EBMV)   // DEL EREO ZGO0 97-04-07(Mon) BUN
#define CAPTURE_ODD     (ERPS | EBMV)   // mode 97-03-29(Sat) BUN
#define SKIP_EVEN       ERPS            // DEL EREO ZGO0 97-04-07(Mon) BUN
#define SKIP_ODD        ERPS            // DEL EROO ZGO0 97-04-07(Mon) BUN


// Bit positions for the INTSTAT register's ENABLE flags.
#define FIE     0x10000         // Field Interrupt Enable
#define RIE     0x20000         // RPS Interrupt Enable
#define SLIE    0x40000         // Sync Lock Interrupt Enable
#define EXIE    0x80000         // External interrupt Enable(Dilbert)
#define SPIE    0x80000         // Spare Interrupt Enable(Bert).
#define FOIE    0x100000        // FIFO Overflow Interrupt Enable.
#define LTIE    0x200000        // LINE Timeout Interrupt Enable.
#define ROIE    0x400000        // RPS Out of Bounds Interrupt Enable.
#define RUIE    0x800000        // Register Undefined Interrupt Enable.
#define SCIE    0x2000000       // Slock Clock Interrupt Enable.
#define ORIE    0x4000000       // Over Run Interrupt Enable.
#define RLIE    0x8000000       // Register Load Interrupt Enable.
#define DEIE    0x10000000      // DCI Error Interrupt Enable(Dilbert).
#define LSIE    0x10000000      // Line Sync Interrupt Enable(Bert).
#define IEIE    0x20000000      // IIC Error Interrupt Enable.
#define PPIE    0x40000000      // PCI Parity Error Interrupt Enable.
#define PEIE    0x80000000      // PCI Access Error Interrupt Enable.

// The active video capture interrupts mask
//#define ACTIVE_CAPTURE_IRQS (RIE | SLIE | FOIE | ROIE | RUIE |\
//                             ORIE | RLIE | IEIE | PPIE | PEIE)

// delete PPIE & IEIE & ORIE 97-03-15(Sat)
// Pistachi not support to PPIE and ORIE. Santaclara does not use I2c bus.
#define ACTIVE_CAPTURE_IRQS (RIE | SLIE | FOIE | LTIE | ROIE | RUIE | RLIE | PEIE)

// for Pistachio's flags 97-03-21(Fri)
#define CHGCOL          0x00010000      // P_LUMI Change Color
#define VFL             0x00010000      // P_FIL Vertical Filter
#define EI_H            0x00000001      // P_SUP1 EI Level H
#define EI_L            0x00000000      // P_SUP1 EI Level L
#define EICH_2          0x00000000      // P_SUP1 EICH 2ms
#define EICH_10         0x00000010      // P_SUP1 EICH 10ms
#define EICH_50         0x00000020      // P_SUP1 EICH 50ms
#define EICH_NONE       0x00000030      // P_SUP1 EICH None
#define MSTOPI          0x00000002      // P_SUP3 IIC Stop Not Auto
#define HSIIC           0x00000001      // P_SUP3 IIC HighSpeed Mode
#define VSNC            0x00000008      // VINSTAT VSNC




//
// define the video standard constants
//
#define NTSC_MAX_PIXELS_PER_LINE        640
#define NTSC_MAX_LINES_PER_FIELD        240

#define PAL_MAX_PIXELS_PER_LINE         768
#define PAL_MAX_LINES_PER_FIELD         288

#define NTSC_HORIZONTAL_START           3
#define NTSC_VERTICAL_START             14
#define PAL_HORIZONTAL_START            NTSC_HORIZONTAL_START   // Same as NTSC
#define PAL_VERTICAL_START              19

#define MAX_CAPTURE_BUFFER_SIZE         ((640*480*12)/8)
#define DEFAULT_CAPTURE_BUFFER_SIZE     ((320*240*12)/8)

//
// frame timing, time between vsync interrupts
//
#define PAL_MICROSPERFRAME      (1000L/25)
#define NTSC_MICROSPERFRAME     (1000L/30)

//#define EBMV_TIMEOUT        200000      // 20 millisec
#define EBMV_TIMEOUT        500000      // 20 millisec

#define DEF_RPS_FRAMES      30          // 30 default fps

#define CAMERA_OFF_TIME         5000    // StreamFini -> CameraOFF      Add 97-05-03(Sat)
#define CAMERA_FLAG_ON          0x01    // Add 97-05-10(Sat)
#define CAMERA_FLAG_OFF         0x00    // Add 97-05-10(Sat)
#define CAVCE_ON                        0x01    // Add 97-05-10(Sat)
#define CAVCE_OFF                       0x00    // Add 97-05-10(Sat)

#define ZV_ENABLE                       0x01l   // Add 97-05-10(Sat)
#define ZV_DISABLE                      0x00l   // Add 97-05-10(Sat)
#define ZV_GETSTATUS            0xffl   // Add 97-05-10(Sat)
#define ZV_ERROR                        0xffl   // Add 97-05-10(Sat)

#define MODE_VFW                        0x01    // Add 97-05-10(Sat)
#define MODE_ZV                         0x02    // Add 97-05-10(Sat)


#define MAX_HUE         0xff
#define DEFAULT_HUE     0x80
#define MAX_HUE          0xff
#define MAX_BRIGHTNESS   0xff
#define MAX_CONTRAST     0xff
#define MAX_SATURATION   0xff


#define IGNORE100msec   0x200000l
#define PCI_CFGCCR              0x08    /* offset of Pistachio Configration/Revision */
#define PCI_Wake_Up             0x40    /* offset of Pistachio Wake up  */
#define PCI_CFGWAK              0x40    /* offset of Pistachio Wake up  */
#define PCI_DATA_PATH   0x44    /* offset of Pistachio Data path */
#define PCI_CFGPAT              0x44    /* offset of Pistachio Data path */

#define SELIZV_CFGPAT   0x2l
#define ZVEN_CFGPAT             0x1l
#define CAVCE_CFGPAT    0x10l
#define CADTE_CFGPAT    0x20l
#define PXCCE_CFGPAT    0x100l
#define PXCSE_CFGPAT    0x200l
#define PCIFE_CFGPAT    0x400l
#define PCIME_CFGPAT    0x800l
#define PCIDS_CFGPAT    0x1000l
#define GPB_CFGPAT      0x30000l

#define CASL_CFGWAK             0x00010000l





VOID    HW_ApmResume(PHW_DEVICE_EXTENSION);
VOID    HW_ApmSuspend(PHW_DEVICE_EXTENSION);
VOID    HW_SetFilter(PHW_DEVICE_EXTENSION, BOOL);
ULONG   HW_ReadFilter(PHW_DEVICE_EXTENSION, BOOL);
BOOL
SetupPCILT(PHW_DEVICE_EXTENSION pHwDevExt);

VOID
InitializeConfigDefaults(PHW_DEVICE_EXTENSION pHwDevExt);

BOOL
CameraChkandON(PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulMode);

BOOL
CameraChkandOFF(PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulMode);

BOOL
CheckCameraStatus(PHW_DEVICE_EXTENSION pHwDevExt);     // Add 97-05-05(Mon)

BOOL
SetZVControl(PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulZVStatus);     // Add 97-05-02(Fri)

VOID
WriteRegUlong(PHW_DEVICE_EXTENSION pHwDevExt,
                          ULONG,
                          ULONG);

VOID
ReadModifyWriteRegUlong(PHW_DEVICE_EXTENSION pHwDevExt,
                                                ULONG,
                                                ULONG,
                                                ULONG);

ULONG
ReadRegUlong(PHW_DEVICE_EXTENSION pHwDevExt, ULONG);

BOOL
HWInit(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertInterruptEnable(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN BOOL bStatus
);

VOID
BertDMAEnable(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN BOOL bStatus
);

BOOL
BertIsLocked(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
BertFifoConfig(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN ULONG dwFormat
);

BOOL
BertInitializeHardware(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertEnableRps(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertDisableRps(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
BertIsCAPSTATReady(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertVsncSignalWait(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertDMARestart(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
BertBuildNodes(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
BertTriBuildNodes(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
BertIsCardIn(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

VOID
BertSetDMCHE(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
ImageSetInputImageSize(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN PRECT pRect
);

BOOL
ImageSetOutputImageSize(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN ULONG ulWidth,
  IN ULONG ulHeight
);

BOOL
ImageSetChangeColorAvail(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN ULONG ulChgCol
);

BOOL
ImageSetHueBrightnessContrastSat(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
ImageSetFilterInfo(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN ULONG ulVFL,
  IN ULONG ulFL1,
  IN ULONG ulFL2,
  IN ULONG ulFL3,
  IN ULONG ulFL4
);

BOOL
ImageFilterON(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
ImageFilterOFF(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
ImageGetFilterInfo(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
ImageGetFilteringAvailable(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
Alloc_TriBuffer(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
Free_TriBuffer(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
SetASICRev(
  IN PHW_DEVICE_EXTENSION pHwDevExt
);

BOOL
VC_GetPCIRegister(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulOffset,
    PVOID pData,
    ULONG ulLength);

BOOL
VC_SetPCIRegister(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulOffset,
    PVOID pData,
    ULONG ulLength);

VOID VC_Delay(int nMillisecs);

#if DBG
void DbgDumpPciRegister( PHW_DEVICE_EXTENSION pHwDevExt );
void DbgDumpCaptureRegister( PHW_DEVICE_EXTENSION pHwDevExt );
#endif

#endif   // _BERT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\bert.c ===
//
//              TOSHIBA CORPORATION PROPRIETARY INFORMATION
//     This software is supplied under the terms of a license agreement or
//     nondisclosure agreement with TOSHIBA Corporation and may not be copied
//     or disclosed except in accordance with the terms of that agreement.
//           Copyright (c) 1997 TOSHIBA Corporation. All Rights Reserved.
//
//  Workfile: BERT.C
//
//  Purpose:
//
//  Contents:
//


#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "bert.h"
#include "image.h"

#ifdef  TOSHIBA // '99-01-20 Added
extern  ULONG   CurrentOSType;
ULONG           ulConfigAddress;
#endif//TOSHIBA

//--------------------------------------------------------------------
//  ReadRegUlong
//--------------------------------------------------------------------

ULONG
ReadRegUlong(PHW_DEVICE_EXTENSION pHwDevExt, ULONG offset)
{
    PUCHAR  pBase = (PUCHAR)(pHwDevExt->ioBaseLocal);

#ifndef TOSHIBA
    if (!pHwDevExt->IsCardIn) return 0L;
#endif//TOSHIBA
    return *(PULONG)(pBase + offset);
}

//--------------------------------------------------------------------
//  WriteRegUlong
//--------------------------------------------------------------------

VOID
WriteRegUlong(PHW_DEVICE_EXTENSION pHwDevExt, ULONG offset, ULONG data)
{
    ULONG volatile *temp;
    PUCHAR  pBase = (PUCHAR)(pHwDevExt->ioBaseLocal);

#ifndef TOSHIBA
    if (!pHwDevExt->IsCardIn) return;
#endif//TOSHIBA
    temp = (PULONG)(pBase + offset);
    *temp = data;
}

//--------------------------------------------------------------------
//  ReadModifyWriteRegUlong
//--------------------------------------------------------------------

VOID
ReadModifyWriteRegUlong(PHW_DEVICE_EXTENSION pHwDevExt,
                                       ULONG offset,
                                       ULONG a_mask,
                                       ULONG o_mask)
{
    ULONG tdata;
    ULONG volatile *temp;
    PUCHAR  pBase = (PUCHAR)(pHwDevExt->ioBaseLocal);

#ifndef TOSHIBA
    if (!pHwDevExt->IsCardIn) return;
#endif//TOSHIBA
    temp = (PULONG)(pBase + offset);
    tdata = *temp;
    tdata = (tdata & a_mask) | o_mask;
    *temp = tdata;
}

BOOL
BertIsCardIn(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
{
    DWORD value;
    value = ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG);
    if ((value == 0) || (value == 0xffffffff))
        return FALSE;
    else
        return TRUE;
}


//--------------------------------------------------------------------
//  BertInterruptEnable
//--------------------------------------------------------------------

VOID
BertInterruptEnable(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN BOOL bStatus
)
{
    WriteRegUlong(pHwDevExt, BERT_INTRST_REG , 0xFFFF);

    if (!bStatus)
    {
        ReadModifyWriteRegUlong(pHwDevExt, BERT_INTSTAT_REG, (ULONG)~ACTIVE_CAPTURE_IRQS, 0);
    }
    else
    {
        ReadModifyWriteRegUlong(pHwDevExt, BERT_INTSTAT_REG, ~0UL, (ULONG)ACTIVE_CAPTURE_IRQS);
    }
}

//--------------------------------------------------------------------
//  BertDMAEnable
//--------------------------------------------------------------------

VOID
BertDMAEnable(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN BOOL bStatus
)
{
    DWORD   dwAddr;

    if (bStatus)    // Turn On Video Transfer.
    {
        dwAddr = (DWORD)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
        dwAddr = (dwAddr + 0x1FFF) & 0xFFFFE000;
#endif
        WriteRegUlong(pHwDevExt, BERT_RPSADR_REG, dwAddr);
        WriteRegUlong(pHwDevExt, BERT_RPSPAGE_REG, dwAddr);
        BertVsncSignalWait(pHwDevExt);
        // Let the RPS turn on/off EBMV
        WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD)); // mod passive_enable -> ERPS 97-03-15(Sat) Mod 97-05-08(Thu)
    }
    else    // Turn Off Video Transfer.
    {
        if (ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & ERPS)
        {
            ReadModifyWriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ULONG)~ERPS, 0UL);
        }

        if (!BertIsCAPSTATReady(pHwDevExt))
        {
            ReadModifyWriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ULONG)~EBMV, 0UL);
        }

        if (ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & RPSS)
        {
            pHwDevExt->NeedHWInit = TRUE;
        }
    }
}

//--------------------------------------------------------------------
//  BertIsLocked
//--------------------------------------------------------------------

BOOL
BertIsLocked(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
/*++

Routine Description :

    Check if the decoder has been locked or not.

Arguments :

    pDevInfo - Device Info for the driver

Return Value :

    TRUE - configuration success

--*/
{
    return ((ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & LOCK) != 0);
}

//--------------------------------------------------------------------
//  BertFifoConfig
//--------------------------------------------------------------------

BOOL
BertFifoConfig(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN ULONG ulFormat
)
/*++

Routine Description :

    Configure the BERT fifo for the format choosen.

Arguments :

    pDevInfo - Device Info for the driver
    dwFormat - format index as defined in wally.h

Return Value :

    TRUE - configuration success

--*/
{
    DWORD dwFifo;

    switch (ulFormat)
    {
        case FmtYUV12:
                dwFifo = 0xe;
                break;
        case FmtYUV9:
                dwFifo = 0xd;
                break;
        default:
                return FALSE;
    }

    dwFifo=(dwFifo<<24)| 0x100000l;     // Modify 97-04-02

    WriteRegUlong(pHwDevExt, BERT_FIFOCFG_REG, dwFifo);
    WriteRegUlong(pHwDevExt, BERT_BURST_LEN, 0x00000002);
    // DATA=8 DWORD, RPS=2DWORD
    WriteRegUlong(pHwDevExt, BERT_YSTRIDE_REG, pHwDevExt->Ystride);
    WriteRegUlong(pHwDevExt, BERT_USTRIDE_REG, pHwDevExt->Ustride);
    WriteRegUlong(pHwDevExt, BERT_VSTRIDE_REG, pHwDevExt->Vstride);
    return TRUE;
}

//--------------------------------------------------------------------
//  BertInitializeHardware
//--------------------------------------------------------------------

BOOL
BertInitializeHardware(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
/*++

Routine Description :

    This function initializes the bert asic to the default values.

Arguments :

    pDevInfo - Device Info for the driver
    pHw - pointer to hardware info data structure

Return Value :

    TRUE - initialization success

--*/
{
    WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (CAMARA_OFF | CKRE | CKMD));      // Mod 97-05-08(Thu)
    return TRUE;
}


//--------------------------------------------------------------------
//  BertEnableRps
//--------------------------------------------------------------------

VOID
BertEnableRps(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
/*++

Routine Description :

    enable the rps execution by setting ERPS and EROO bits
    in the CAPSTAT reg

Arguments :

    pDevInfo - Device Info for the driver

Return Value :

    None

--*/
{
    ReadModifyWriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, 0xf0ffffff, 0x08000000); // MOD 97-03-17(Mon)
}

//--------------------------------------------------------------------
//  BertDisableRps
//--------------------------------------------------------------------

VOID
BertDisableRps(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
/*++

Routine Description :

    disable the rps execution by reseting the ERPS bit
    in the CAPSTAT reg

Arguments :

    pDevInfo - Device Info for the driver

Return Value :

    None

--*/
{
    ReadModifyWriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ULONG)~ERPS, 0L);
}


BOOL
BertIsCAPSTATReady(PHW_DEVICE_EXTENSION pHwDevExt)
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER StartTime;

    KeQuerySystemTime( &StartTime );
    // Wait until EBMV is cleared by the RPS
    while (ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & EBMV)
    {
        KeQuerySystemTime( &CurrentTime );
        if ((CurrentTime.QuadPart - StartTime.QuadPart) > EBMV_TIMEOUT)
        {
            return FALSE;
        }
    }
    return TRUE;
}

VOID
BertVsncSignalWait(PHW_DEVICE_EXTENSION pHwDevExt)
{
    ULONG ulCount;

    // Wait until VSNC is low
    for (ulCount = 0; ulCount < 500; ulCount++ )
    {
        if (!(ReadRegUlong(pHwDevExt, BERT_VINSTAT_REG) & VSNC)) break;
        VC_Delay(2);
    }
}

VOID
BertDMARestart(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
{
    DWORD   dwAddr;

    dwAddr = (DWORD)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
    dwAddr = (dwAddr + 0x1FFF) & 0xFFFFE000;
#endif
    WriteRegUlong(pHwDevExt, BERT_RPSADR_REG, dwAddr);
    WriteRegUlong(pHwDevExt, BERT_RPSPAGE_REG, dwAddr);
    WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD));
}


void
ActiveField(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN DWORD *addr,
  IN DWORD *PhysAddr,   /* Insert BUN 97-03-25(Tue) */
  IN DWORD bNoCopy,
  IN DWORD *y_DMA_addr,
  IN DWORD *v_DMA_addr,
  IN DWORD *u_DMA_addr,
  IN DWORD *nextRPSaddr,
  IN DWORD *readRegAddr,
  IN BOOL genIRQ /* = FALSE */,
  IN DWORD fieldsToCapture /* = CAPTURE_BOTH */ )
{
    // Set DmaActive flag right away since this is the indicator register for whether DMA is pending.
    // If the DmaActive flag is zero, it is safe to copy the DMA frame buffer.  The YPTR register is
    // used as a scratch register to be read into the DmaActive flag.

    *addr++ = RPS_CONTINUE_CMD | BERT_YPTR_REG;
    *addr++ = (DWORD)y_DMA_addr;                            // Address of y DMA buffer.

    *addr++ = RPS_CONTINUE_CMD | ((genIRQ) ? RPS_INT_CMD : 0) | BERT_RPSPAGE_REG;
    *addr++ = (pHwDevExt->s_physDmaActiveFlag-0x1860);      // Page s_DmaActiveFlag is on mod BUN

    *addr++ = RPS_CONTINUE_CMD | BERT_VPTR_REG;
    *addr++ = (DWORD)v_DMA_addr;                            // Address of v DMA buffer.

    *addr++ = RPS_CONTINUE_CMD | BERT_UPTR_REG;
    *addr++ = (DWORD)u_DMA_addr;                            // Address of u DMA buffer.

    *addr++ = BERT_CAPSTAT_REG;                             // LAST RPS command this VSYNC
    *addr++ = fieldsToCapture;                              // Switch on bus master bit.

    *addr++ = RPS_CONTINUE_CMD | BERT_RPSADR_REG;
    *addr   = (DWORD)nextRPSaddr;                           // Address of next RPS.
}

//
// SKIP_FIELD_RPS is the size of a RPS node that skips a field.
// Skip frame is programmed as follows:
//      DWORD                                   -- RPS command register
//      DWORD                                   -- Value of register programming.
//---------------- Actual RPS for Skip Frame ------------------------
// RPS_CONTINUE_CMD | CAPSTAT   - RPS, read next RPS, select CAPSTAT
//  ERPS | EROO | GO0           - Enable RPS & Power to camara (off bus master)
// INTSTAT                                      - Don't continue & select INITSTAT register.
// m_passive_cap_IRQs           - Don't interrupt end of field.
// RPS_CONTINUE_CMD | RPSADDR   - Set up address
// Address field                        - Program at init for next field.
//-------------------------------------------------------------------
//
VOID
SkipField(
  IN PHW_DEVICE_EXTENSION pHwDevExt,
  IN DWORD *addr,
  IN DWORD *PhysAddr,   /* Insert BUN 97-03-25(Tue) */
  IN DWORD *nextRPSaddr,
  IN DWORD *readRegAddr,
  IN BOOL genIRQ /* = FALSE */,
  IN DWORD fieldToSkip /* = SKIP_BOTH */ )
{
    // Set YPTR right away since this is the indicator register for whether DMA is pending.
    // If DmaActive flag is zero, it is safe to copy the DMA frame buffer.

    *addr++ = RPS_CONTINUE_CMD | BERT_YPTR_REG;
    *addr++ = (DWORD)PhysAddr;

    *addr++ = RPS_CONTINUE_CMD | ((genIRQ) ? RPS_INT_CMD : 0) | BERT_RPSPAGE_REG;
    *addr++ = (pHwDevExt->s_physDmaActiveFlag-0x1860);      // Page s_physDmaActiveFlag is on MOD bun

    *addr++ = BERT_CAPSTAT_REG;  /* mod BUN 97-04-16(Wed) */
    *addr++ = fieldToSkip;                                  // Switch off bus master bit.
    *addr++ = RPS_CONTINUE_CMD | BERT_RPSADR_REG;
    *addr   = (DWORD)nextRPSaddr;                           // Address of next RPS.
}


BOOL
BertBuildNodes(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
{
    DWORD*          addr;
    DWORD*          physAddr;
    DWORD*          physBase;
    ULONG           ulTemp;
    unsigned        framesPerSecond;
    unsigned        f;
    unsigned        max_rps;
    BOOL            lastOneActive = FALSE;

    framesPerSecond = pHwDevExt->uiFramePerSecond;
    max_rps = DEF_RPS_FRAMES;

    ulTemp = (ULONG)pHwDevExt->pRpsDMABuf;
#if 0
    ulTemp = (ulTemp + 0x1FFF) & 0xFFFFE000;
#endif
    addr   = (DWORD *)ulTemp;
    ulTemp = (ULONG)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
    ulTemp = (ulTemp + 0x1FFF) & 0xFFFFE000;
#endif
    physAddr = (DWORD *)ulTemp;
    physBase = physAddr;

    if (addr == NULL) return FALSE;

    // Build an RPS per frame.
    // Building 2 nodes per iteration when capturing both fields, so always
    // go thru only DEF_RPS_FRAMES iterations.

    for (f = max_rps ; f >= 1 ; f-- )
    {
        if (((framesPerSecond * f) % DEF_RPS_FRAMES) < framesPerSecond)
        {
            ActiveField(pHwDevExt,addr,(DWORD *)0,
                        TRUE,       // No buffer copying during the processing of this node
                        (DWORD *)((BYTE *)pHwDevExt->pPhysCaptureBufferY.LowPart + pHwDevExt->YoffsetOdd),    // Position Y data.
                        (DWORD *)((BYTE *)pHwDevExt->pPhysCaptureBufferV.LowPart + pHwDevExt->VoffsetOdd),    // Position V data.
                        (DWORD *)((BYTE *)pHwDevExt->pPhysCaptureBufferU.LowPart + pHwDevExt->UoffsetOdd),    // Position U data.
                        ((f == 1 )
                            ? physBase
                            : physAddr + 0x1A),
                        physAddr + 0x19,    // Put the read value at the end of the list.
                        lastOneActive,
                        (CAPTURE_ODD | CKRE | CKMD));       // Mod 97-05-08(Thu)
            lastOneActive = TRUE;
        }
        else
        {
            // Don't generate interrupts for skipped frames
            SkipField(pHwDevExt,addr,
                      (DWORD *)((BYTE *)pHwDevExt->pPhysCapBuf2Y.LowPart + pHwDevExt->YoffsetOdd),
                      ((f == 1 )
                          ? physBase
                          : physAddr + 0x1A),
                      physAddr + 0x19,    // Put the read value at the end of the list.
                      lastOneActive,
                      (SKIP_ODD | CKRE | CKMD));  // Mod 97-05-08(Thu)

            lastOneActive = FALSE;
        }
        addr += 0x1A;
        physAddr += 0x1A;
    }
    return TRUE;
}

BOOL
BertTriBuildNodes(
  IN PHW_DEVICE_EXTENSION pHwDevExt
)
{
    DWORD*          addr;
    DWORD*          physAddr;
    DWORD*          physBase;
    ULONG           ulTemp;
    unsigned        framesPerSecond;
    unsigned        f;
    unsigned        max_rps;
    BOOL            lastOneActive = FALSE;
    DWORD*          CapphysAddrY;
    DWORD*          CapphysAddrV;
    DWORD*          CapphysAddrU;

    framesPerSecond = pHwDevExt->uiFramePerSecond;
    max_rps = DEF_RPS_FRAMES;

    ulTemp      = (ULONG)pHwDevExt->pRpsDMABuf;
#if 0
    ulTemp      = (ulTemp + 0x1FFF) & 0xFFFFE000;
#endif
    addr        = (DWORD *)ulTemp;
    ulTemp      = (ULONG)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
    ulTemp      = (ulTemp + 0x1FFF) & 0xFFFFE000;
#endif
    physAddr    = (DWORD *)ulTemp;
    physBase    = physAddr;

    if (addr == NULL) return FALSE;

    // Build an RPS per frame.
    // Building 2 nodes per iteration when capturing both fields, so always
    // go thru only DEF_RPS_FRAMES iterations.

    lastOneActive = ( ((framesPerSecond*1)%DEF_RPS_FRAMES) < framesPerSecond ) ? TRUE : FALSE ;

    for (f = max_rps ; f >= 1 ; f-- )
    {
        if( f%2 ){
            CapphysAddrY=(DWORD *)pHwDevExt->pPhysCapBuf2Y.LowPart;
            CapphysAddrV=(DWORD *)pHwDevExt->pPhysCapBuf2V.LowPart;
            CapphysAddrU=(DWORD *)pHwDevExt->pPhysCapBuf2U.LowPart;
        }
        else{
            CapphysAddrY=(DWORD *)pHwDevExt->pPhysCaptureBufferY.LowPart;
            CapphysAddrV=(DWORD *)pHwDevExt->pPhysCaptureBufferV.LowPart;
            CapphysAddrU=(DWORD *)pHwDevExt->pPhysCaptureBufferU.LowPart;
        }

        if (((framesPerSecond * f) % DEF_RPS_FRAMES) < framesPerSecond)
        {
            ActiveField(pHwDevExt,addr,(DWORD *)0,
                        TRUE,       // No buffer copying during the processing of this node
                        (DWORD *)((BYTE *)CapphysAddrY + pHwDevExt->YoffsetOdd),   // Position Y data.
                        (DWORD *)((BYTE *)CapphysAddrV + pHwDevExt->VoffsetOdd),   // Position V data.
                        (DWORD *)((BYTE *)CapphysAddrU + pHwDevExt->UoffsetOdd),   // Position U data.
                        ((f == 1 )
                            ? physBase
                            : physAddr + 0x1A),
                        physAddr + 0x19,    // Put the read value at the end of the list.
                        lastOneActive,
                        (CAPTURE_ODD | CKRE | CKMD));       // Mod 97-05-08(Thu)

            lastOneActive = TRUE;
        }
        else
        {
            // Don't generate interrupts for skipped frames
            SkipField(pHwDevExt,addr,(DWORD *)((BYTE *)CapphysAddrY + pHwDevExt->YoffsetOdd),
                      ((f == 1 )
                          ? physBase
                          : physAddr + 0x1A),
                      physAddr + 0x19,    // Put the read value at the end of the list.
                      lastOneActive,
                      (SKIP_ODD | CKRE | CKMD));  // Mod 97-05-08(Thu)

            lastOneActive = FALSE;
        }
        addr += 0x1A;
        physAddr += 0x1A;
    }
    return TRUE;
}


//--------------------------------------------------------------------
//  BertSetDMCHE
//--------------------------------------------------------------------

VOID
BertSetDMCHE(IN PHW_DEVICE_EXTENSION pHwDevExt)
{
    switch(pHwDevExt->dwAsicRev){
        case 0:         // Pistachio #1
        case 1:         // Pistachio #2
        case 2:         // Pistachio #3
            WriteRegUlong(pHwDevExt, BERT_P_SUP3_REG, 0x00);
            break;
        default:        // Pistachio #4~
            WriteRegUlong(pHwDevExt, BERT_P_SUP3_REG, 0x0100);
            break;
    }
}

VOID
HW_ApmResume(PHW_DEVICE_EXTENSION pHwDevExt)
{
    BertSetDMCHE(pHwDevExt);
    CameraChkandON(pHwDevExt, MODE_VFW);
    BertInitializeHardware(pHwDevExt);
    pHwDevExt->NeedHWInit = TRUE;
    pHwDevExt->IsRPSReady = FALSE;
}

VOID
HW_ApmSuspend(PHW_DEVICE_EXTENSION pHwDevExt)
{
    BertInterruptEnable(pHwDevExt, FALSE);
    BertDMAEnable(pHwDevExt, FALSE);
    pHwDevExt->bRequestDpc = FALSE;
    CameraChkandOFF(pHwDevExt, MODE_VFW);
}

VOID
HW_SetFilter(PHW_DEVICE_EXTENSION pHwDevExt, BOOL bFlag)
{
    if( bFlag )
    {
        ImageFilterON(pHwDevExt);
    }
    else
    {
        ImageFilterOFF(pHwDevExt);
    }
}

ULONG
HW_ReadFilter(PHW_DEVICE_EXTENSION pHwDevExt, BOOL bFlag)
{
    ULONG ulRet;

    if( bFlag )
    {
        ulRet = ImageGetFilteringAvailable(pHwDevExt);
    }
    else
    {
        ulRet = ImageGetFilterInfo(pHwDevExt);
    }
    return ulRet;
}

BOOL
HWInit(PHW_DEVICE_EXTENSION pHwDevExt)
{
    if (pHwDevExt->NeedHWInit == FALSE) return TRUE;

    // reset hardware to power up state
    if ( !BertInitializeHardware(pHwDevExt) )        // MOD 97-03-31(Fri)
    {
        return FALSE;
    }
    else
    {
        pHwDevExt->NeedHWInit = FALSE;
    }
    return TRUE;
}

#ifdef  TOSHIBA // '99-01-20 Added
//--------------------------------------------------------------------
//  InitConfigAddress
//--------------------------------------------------------------------
VOID
InitConfigAddress( PHW_DEVICE_EXTENSION pHwDevExt )
{
    ULONG OldPort;
    ULONG Id;
    ULONG Data;
    ULONG i, j;

    ulConfigAddress = 0xFFFFFFFF;
#ifdef  TOSHIBA // '99-02-05 Modified
    return;
#else //TOSHIBA
    if ( CurrentOSType ) return;    // NT5.0

    if ( !StreamClassReadWriteConfig(
                    pHwDevExt,
                    TRUE,           // indicates a READ
                    (PVOID)&Id,
                    0,              // this is the offset into the PCI space
                    4               // this is the # of bytes to read.
            )) {
        return;
    }
    if ( Id == 0 || Id == 0xFFFFFFFF ) return;

    OldPort = READ_PORT_ULONG( (PULONG)0xCF8 );
    for ( i = 0 ; i < 256; i++ ) {   // PCI_MAX_BRIDGE_NUMBER
        for ( j = 0 ; j < 32; j++ ) {// PCI_MAX_DEVICE
            WRITE_PORT_ULONG( (PULONG)0xCF8, (i << 16) | (j << 11) | 0x80000000 );
            Data = READ_PORT_ULONG( (PULONG)0xCFC );
            if ( Data == Id ) {
                ulConfigAddress = (i << 16) | (j << 11) | 0x80000000;
                break;
            }
        }
        if ( Data == Id ) break;
    }
    WRITE_PORT_ULONG( (PULONG)0xCF8, OldPort );
#endif//TOSHIBA
}
#endif//TOSHIBA

//--------------------------------------------------------------------
//  InitializeConfigDefaults
//--------------------------------------------------------------------

VOID
InitializeConfigDefaults(PHW_DEVICE_EXTENSION pHwDevExt)
{
    ULONG ImageSize;

#ifdef  TOSHIBA // '99-01-20 Added
    InitConfigAddress( pHwDevExt );
#endif//TOSHIBA

#ifndef TOSHIBA
    pHwDevExt->VideoStd = NTSC;
#endif//TOSHIBA
    pHwDevExt->Format = FmtYUV9;
    pHwDevExt->ulWidth = 320;
    pHwDevExt->ulHeight = 240;
    pHwDevExt->MaxRect.right = NTSC_MAX_PIXELS_PER_LINE;
    pHwDevExt->MaxRect.bottom = NTSC_MAX_LINES_PER_FIELD * 2; // Mod 97-04-08(Tue)
    pHwDevExt->SrcRect = pHwDevExt->MaxRect;

#ifdef  TOSHIBA
    pHwDevExt->Hue = 0x80;
    pHwDevExt->Contrast = 0x80;
    pHwDevExt->Brightness = 0x80;
    pHwDevExt->Saturation = 0x80;

    ImageSetChangeColorAvail(pHwDevExt, IMAGE_CHGCOL_AVAIL);
#else //TOSHIBA
    pHwDevExt->ulHue = 0x80;
    pHwDevExt->ulContrast = 0x80;
    pHwDevExt->ulBrightness = 0x80;
    pHwDevExt->ulSaturation = 0x80;

    ImageSetChangeColorAvail(pHwDevExt, IMAGE_CHGCOL_NOTAVAIL);
#endif//TOSHIBA
}

BOOL SetupPCILT( PHW_DEVICE_EXTENSION pHwDevExt )
{
    BYTE   byte_buffer;
    ULONG  ulCommand;

#define PCI_LTIME_OFFSET        0x0d    /* offset of Latency timer from PCI base */
#define PCI_CACHELINE_OFFSET    0x0c    /* offset of cache line size from PCI base */
#define PCI_STATUSorCOMMAND     0x04    /* offset of Pistachio Status and Command regster */


        byte_buffer = 255;
        VC_SetPCIRegister(pHwDevExt,
                          PCI_LTIME_OFFSET,
                          &byte_buffer,
                          0x01);

        byte_buffer=(BYTE) 0;
        VC_SetPCIRegister(pHwDevExt,
                          PCI_CACHELINE_OFFSET,
                          &byte_buffer,
                          0x01);

        ulCommand = 0x02000006;
        VC_SetPCIRegister(pHwDevExt,
                          PCI_STATUSorCOMMAND,
                          &ulCommand,
                          0x04);

        ulCommand = IGNORE100msec ; // Set ignore time for chattering
        VC_SetPCIRegister(pHwDevExt,
                          PCI_Wake_Up,
                          &ulCommand,
                          0x04);

        return TRUE;
}


BOOL CameraChkandON( PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulMode )
{

        ULONG  dd_buffer;

        if (!VC_GetPCIRegister(pHwDevExt,
                               PCI_Wake_Up,
                               &dd_buffer,
                               0x04) )
        {
            return FALSE;
        }

        if( (dd_buffer&0x10000l) == 0)
        {
            return TRUE;
        }

        dd_buffer = IGNORE100msec | 0x101l; // Set Wake Up enable
        if (!VC_SetPCIRegister(pHwDevExt,
                               PCI_Wake_Up,
                               &dd_buffer,
                               0x04) )
        {
            return FALSE;
        }

        switch(ulMode){
                case MODE_VFW:
                        dd_buffer = CAVCE_CFGPAT | CADTE_CFGPAT | PXCCE_CFGPAT | PXCSE_CFGPAT
                                | PCIFE_CFGPAT | PCIME_CFGPAT | PCIDS_CFGPAT | GPB_CFGPAT;      // Mod 97-05-06(Tue)
                        break;
                case MODE_ZV:
                        dd_buffer = CAVCE_CFGPAT | CADTE_CFGPAT | PXCCE_CFGPAT | PCIFE_CFGPAT
                                | PCIME_CFGPAT | PCIDS_CFGPAT | GPB_CFGPAT;                                     // Add 97-05-06(Tue)
                        break;
        }

        // Power ON to camera.
        if (!VC_SetPCIRegister(pHwDevExt,
                               PCI_DATA_PATH,
                               &dd_buffer,
                               0x04) )
        {
            return FALSE;
        }

        return TRUE;
}


BOOL CameraChkandOFF( PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulMode )
{
        DWORD   dwBuffer;
        DWORD   dwSystemWait;   // Add 97-05-06(Tue)

        switch(ulMode){
                case MODE_VFW:
                        break;
                case MODE_ZV:
                        SetZVControl(pHwDevExt, ZV_DISABLE);
                        break;
        }

        dwBuffer = GPB_CFGPAT;  // Camera Power Off

        if (!VC_SetPCIRegister(pHwDevExt,
                               PCI_CFGPAT,
                               &dwBuffer,
                               0x04) )
        {
            return FALSE;
        }

        return TRUE;
}


BOOL CheckCameraStatus(PHW_DEVICE_EXTENSION pHwDevExt)    // Add 97-05-06(Tue)
{
        DWORD   dwBuffer;
        BOOL    crStatus;

        if (!VC_GetPCIRegister(pHwDevExt,
                               PCI_CFGPAT,
                               &dwBuffer,
                               0x04) )
        {
            return FALSE;
        }

        if(dwBuffer & CAVCE_CFGPAT){
                crStatus = TRUE;
        }
        else{
                crStatus = FALSE;
        }

        return crStatus;
}


BOOL SetZVControl(PHW_DEVICE_EXTENSION pHwDevExt, ULONG ulZVStatus) // Add 97-05-02(Fri)
{
        DWORD   dwBuffer, dwBuffer2;
        BOOL    crStatus = TRUE;

        if (!VC_GetPCIRegister(pHwDevExt,
                               PCI_CFGPAT,
                               &dwBuffer,
                               0x04) )
        {
            return FALSE;
        }

        if (!VC_GetPCIRegister(pHwDevExt,
                               PCI_CFGWAK,
                               &dwBuffer2,
                               0x04) )
        {
            return FALSE;
        }

        if(!(dwBuffer2 & CASL_CFGWAK))  // Camera Not Connect
        {
            return FALSE;
        }

        switch(ulZVStatus){
                case ZV_ENABLE:
                        if(!(dwBuffer & CAVCE_CFGPAT)){         // Check CAVCE Status
                                crStatus = CameraChkandON(pHwDevExt, MODE_ZV);
                                if(!crStatus){
                                        return FALSE;
                                }
                        }
                case ZV_DISABLE:
                        dwBuffer = (dwBuffer & 0xfffffffe) | ulZVStatus;
                        if (!VC_SetPCIRegister(pHwDevExt,
                                               PCI_CFGPAT,
                                               &dwBuffer,
                                               0x04) )
                        {
                                return FALSE;
                        }
                        crStatus = TRUE;
                        break;
                case ZV_GETSTATUS:
                        if(dwBuffer & ZV_ENABLE){
                                crStatus = TRUE;
                        }
                        else{
                                crStatus = FALSE;
                        }
                        break;
        }

        return crStatus;
}


BOOL SetASICRev(PHW_DEVICE_EXTENSION pHwDevExt)   // Add 97-05-12(Mon)
{
    DWORD   dwBuffer;
    DWORD   dwAsicRev;

        if (!VC_GetPCIRegister(pHwDevExt,
                               PCI_CFGCCR,
                               &dwBuffer,
                               0x04) )
        {
                return FALSE;
        }

        dwAsicRev = dwBuffer & 0x0f;

        pHwDevExt->dwAsicRev = dwAsicRev;

        return TRUE;
}

BOOL
Alloc_TriBuffer(PHW_DEVICE_EXTENSION pHwDevExt)
{
    ULONG            ulSize;
    PUCHAR           puTemp;

    ulSize = pHwDevExt->BufferSize;
    puTemp = (PUCHAR)pHwDevExt->pCaptureBufferY;
    pHwDevExt->pCapBuf2Y = puTemp + ulSize;
    puTemp = (PUCHAR)pHwDevExt->pCaptureBufferU;
    pHwDevExt->pCapBuf2U = puTemp + ulSize;
    puTemp = (PUCHAR)pHwDevExt->pCaptureBufferV;
    pHwDevExt->pCapBuf2V = puTemp + ulSize;
    pHwDevExt->pPhysCapBuf2Y.LowPart = pHwDevExt->pPhysCaptureBufferY.LowPart + ulSize;
    pHwDevExt->pPhysCapBuf2U.LowPart = pHwDevExt->pPhysCaptureBufferU.LowPart + ulSize;
    pHwDevExt->pPhysCapBuf2V.LowPart = pHwDevExt->pPhysCaptureBufferV.LowPart + ulSize;
    return TRUE;
}

BOOL
Free_TriBuffer(PHW_DEVICE_EXTENSION pHwDevExt)
{
    pHwDevExt->pCapBuf2Y = NULL;
    pHwDevExt->pCapBuf2U = NULL;
    pHwDevExt->pCapBuf2V = NULL;
    pHwDevExt->pPhysCapBuf2Y.LowPart = 0;
    pHwDevExt->pPhysCapBuf2U.LowPart = 0;
    pHwDevExt->pPhysCapBuf2V.LowPart = 0;
    return TRUE;
}


BOOL
VC_GetPCIRegister(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulOffset,
    PVOID pData,
    ULONG ulLength)
{
#ifdef  TOSHIBA // '99-01-20 Added
    if( ulConfigAddress != 0xFFFFFFFF ) {
        ULONG OldPort;
        ULONG DataPort;

        OldPort = READ_PORT_ULONG( (PULONG)0xCF8 );
        WRITE_PORT_ULONG( (PULONG)0xCF8, ( ulConfigAddress | ulOffset) & 0xFFFFFFFC );
        DataPort = 0xCFC + (ulOffset % 4);
        switch ( ulLength ) {
            case 1:
                *((PUCHAR)pData) = READ_PORT_UCHAR( (PUCHAR)DataPort );
                break;
            case 2:
                *((PUSHORT)pData) = READ_PORT_USHORT( (PUSHORT)DataPort );
                break;
            case 4:
                *((PULONG)pData) = READ_PORT_ULONG( (PULONG)DataPort );
                break;
        }
        WRITE_PORT_ULONG( (PULONG)0xCF8, OldPort );
        return TRUE;
    }
#endif//TOSHIBA
    if( StreamClassReadWriteConfig(
                    pHwDevExt,
                    TRUE,           // indicates a READ
                    pData,
                    ulOffset,       // this is the offset into the PCI space
                    ulLength        // this is the # of bytes to read.
            )) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
VC_SetPCIRegister(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulOffset,
    PVOID pData,
    ULONG ulLength)
{
#ifdef  TOSHIBA // '99-01-20 Added
    if( ulConfigAddress != 0xFFFFFFFF ) {
        ULONG OldPort;
        ULONG DataPort;

        OldPort = READ_PORT_ULONG( (PULONG)0xCF8 );
        WRITE_PORT_ULONG( (PULONG)0xCF8, ( ulConfigAddress | ulOffset) & 0xFFFFFFFC );
        DataPort = 0xCFC + (ulOffset % 4);
        switch ( ulLength ) {
            case 1:
                WRITE_PORT_UCHAR( (PUCHAR)DataPort, *((PUCHAR)pData) );
                break;
            case 2:
                WRITE_PORT_USHORT( (PUSHORT)DataPort, *((PUSHORT)pData) );
                break;
            case 4:
                WRITE_PORT_ULONG( (PULONG)DataPort, *((PULONG)pData) );
                break;
        }
        WRITE_PORT_ULONG( (PULONG)0xCF8, OldPort );
        return TRUE;
    }
#endif//TOSHIBA
    if( StreamClassReadWriteConfig(
                    pHwDevExt,
                    FALSE,          // indicates a WRITE
                    pData,
                    ulOffset,       // this is the offset into the PCI space
                    ulLength        // this is the # of bytes to read.
            )) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * delay for a number of milliseconds. This is accurate only to
 * +- 15msecs at best.
 */
VOID
VC_Delay(int nMillisecs)
{
    LARGE_INTEGER Delay;

    /*
     * relative times are negative, in units of 100 nanosecs
     */

    // first wait for the minimum length of time - this ensures that
    // our wait is never less than nMillisecs.
    Delay = RtlConvertLongToLargeInteger(-1);
    KeDelayExecutionThread(KernelMode,
                           FALSE,               //non-alertable
                           &Delay);


    // now wait for the requested time.

    Delay = RtlConvertLongToLargeInteger(-(nMillisecs * 10000));

    KeDelayExecutionThread(KernelMode,
                           FALSE,               //non-alertable
                           &Delay);
}


#if DBG
void
DbgDumpPciRegister( PHW_DEVICE_EXTENSION pHwDevExt )
{
    ULONG  i;
    ULONG  data;

    DbgPrint("\n+++++ PCI Config Register +++++\n");
    for( i=0; i<0x48; i+=4 )
    {
        if (VC_GetPCIRegister(pHwDevExt,
                              i,
                              &data,
                              0x04) )
        {
            DbgPrint("0x%02X: 0x%08X\n", i, data);
        }
        else
        {
            DbgPrint("0x%02X: Read Error.\n", i);
        }
    }
}

void
DbgDumpCaptureRegister( PHW_DEVICE_EXTENSION pHwDevExt )
{
    ULONG  i;
    ULONG  data;

    DbgPrint("\n+++++ Capture Register +++++\n");
    for( i=0; i<0xA4; i+=4 )
    {
        data = ReadRegUlong(pHwDevExt, i);
        DbgPrint("0x%02X: 0x%08X\n", i, data);
    }
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capirq.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#ifdef  TOSHIBA
#include "bert.h"

#ifdef  _FPS_COUNT_
extern  ULONG    FrameCounter;
extern  ULONG    InterruptCounter;
#endif//_FPS_COUNT_
#endif//TOSHIBA

#ifdef  TOSHIBA
BOOLEAN InterruptAcknowledge( PHW_DEVICE_EXTENSION );
#endif//TOSHIBA

#ifdef  TOSHIBA
void ImageSynthXXX (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    KS_VIDEOINFOHEADER      *pVideoInfoHdr = pStrmEx->pVideoInfoHeader;

    UINT biWidth        =   pVideoInfoHdr->bmiHeader.biWidth;
    UINT biHeight       =   pVideoInfoHdr->bmiHeader.biHeight;
    UINT biSizeImage    =   pVideoInfoHdr->bmiHeader.biSizeImage;
    UINT biWidthBytes   =   KS_DIBWIDTHBYTES (pVideoInfoHdr->bmiHeader);
    UINT biBitCount     =   pVideoInfoHdr->bmiHeader.biBitCount;
    UINT LinesToCopy    =   abs (biHeight);
    DWORD biCompression =   pVideoInfoHdr->bmiHeader.biCompression;

    UINT                    Line;
    PUCHAR                  pLineBuffer;

    PKSSTREAM_HEADER        pDataPacket = pSrb->CommandData.DataBufferArray;
    PUCHAR                  pImage =  pDataPacket->Data;
    ULONG                   InRPSflag;
    ULONG                   ImageSizeY;
    ULONG                   ImageSizeU;
    ULONG                   ImageSizeV;


    DEBUG_ASSERT (pSrb->NumberOfBuffers == 1);

#if 0
    // Note:  set "ulInDebug = 1" in a debugger to view this output with .ntkern
    KdPrint(("\'TsbVcap: ImageSynthBegin\n"));
    KdPrint(("\'TsbVcap: biSizeImage=%d, DataPacketLength=%d\n",
            biSizeImage, pDataPacket->DataPacketLength));
    KdPrint(("\'TsbVcap: biWidth=%d biHeight=%d WidthBytes=%d bpp=%d\n",
            biWidth, biHeight, biWidthBytes, biBitCount));
    KdPrint(("\'TsbVcap: pImage=%x\n", pImage));
#endif

    if (pHwDevExt->Format == FmtYUV12) {
        ImageSizeY = biWidth * biHeight;
        ImageSizeU = ImageSizeY / 4;
        ImageSizeV = ImageSizeY / 4;
    } else if (pHwDevExt->Format == FmtYUV9) {
        ImageSizeY = biWidth * biHeight;
        ImageSizeU = ImageSizeY / 16;
        ImageSizeV = ImageSizeY / 16;
    } else {
        biSizeImage = 0;
        return;
    }

    if (pHwDevExt->dblBufflag) {
        InRPSflag = ReadRegUlong(pHwDevExt, BERT_YPTR_REG);
        if (InRPSflag == pHwDevExt->pPhysCaptureBufferY.LowPart) {
            if (pHwDevExt->Format == FmtYUV12) {
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferY, ImageSizeY );
                pImage += ImageSizeY;
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferU, ImageSizeU );
                pImage += ImageSizeU;
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferV, ImageSizeV );
            } else {
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferY, ImageSizeY );
                pImage += ImageSizeY;
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferV, ImageSizeV );
                pImage += ImageSizeV;
                RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferU, ImageSizeU );
            }
        } else if (InRPSflag == pHwDevExt->pPhysCapBuf2Y.LowPart) {
            if (pHwDevExt->Format == FmtYUV12) {
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2Y, ImageSizeY );
                pImage += ImageSizeY;
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2U, ImageSizeU );
                pImage += ImageSizeU;
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2V, ImageSizeV );
            } else {
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2Y, ImageSizeY );
                pImage += ImageSizeY;
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2V, ImageSizeV );
                pImage += ImageSizeV;
                RtlCopyMemory( pImage, pHwDevExt->pCapBuf2U, ImageSizeU );
            }
        } else {
            biSizeImage = 0;
        }
    } else {
        if (pHwDevExt->Format == FmtYUV12) {
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferY, ImageSizeY );
            pImage += ImageSizeY;
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferU, ImageSizeU );
            pImage += ImageSizeU;
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferV, ImageSizeV );
        } else {
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferY, ImageSizeY );
            pImage += ImageSizeY;
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferV, ImageSizeV );
            pImage += ImageSizeV;
            RtlCopyMemory( pImage, pHwDevExt->pCaptureBufferU, ImageSizeU );
        }
    }
    pDataPacket->DataUsed = biSizeImage;
#ifdef  _FPS_COUNT_
    FrameCounter++;
#endif//_FPS_COUNT_
}

VOID
TransferRoutine(
    PHW_DEVICE_EXTENSION        pHwDevExt,
    int                         StreamNumber
    )
{
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    PSTREAMEX                   pStrmEx;
    PKSSTREAM_HEADER            pDataPacket;
    PKS_FRAME_INFO              pFrameInfo;

    pStrmEx = (PSTREAMEX)pHwDevExt->pStrmEx[StreamNumber];

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }

    // Find out what time it is, if we're using a clock

    if (pStrmEx->hMasterClock ) {
        HW_TIME_CONTEXT TimeContext;

        TimeContext.HwDeviceExtension = pHwDevExt;
        TimeContext.HwStreamObject = pStrmEx->pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
                pStrmEx->hMasterClock,
                &TimeContext);

        pStrmEx->QST_StreamTime = TimeContext.Time;
        pStrmEx->QST_Now = TimeContext.SystemTime;

        if (pStrmEx->QST_NextFrame == 0) {
            pStrmEx->QST_NextFrame = pStrmEx->QST_StreamTime + pStrmEx->pVideoInfoHeader->AvgTimePerFrame;
        }

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        KdPrint(("TsbVcap:    Time=%16lx\n", TimeContext.Time));
        KdPrint(("TsbVcap: SysTime=%16lx\n", TimeContext.SystemTime));
#endif
    }

    // Only capture in the RUN state

    if (pStrmEx->KSState == KSSTATE_RUN) {

        //
        // Determine if it is time to capture a frame based on
        // how much time has elapsed since capture started.
        // If there isn't a clock available, then capture immediately.
        //

        if ((!pStrmEx->hMasterClock) ||
             (pStrmEx->QST_StreamTime >= pStrmEx->QST_NextFrame)) {
            // Increment the picture count (usually this is VSYNC count)

            pStrmEx->FrameInfo.PictureNumber++;

            //
            // Get the next queue SRB (if any)
            //

            pSrb = VideoQueueRemoveSRB (
                            pHwDevExt,
                            StreamNumber);

            if (pSrb) {

                pDataPacket = pSrb->CommandData.DataBufferArray;
                pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

                //
                // Call the routine which synthesizes images
                //

                ImageSynthXXX (pSrb);

                // Set additional info fields about the data captured such as:
                //   Frames Captured
                //   Frames Dropped
                //   Field Polarity

                pStrmEx->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

                *pFrameInfo = pStrmEx->FrameInfo;

                // Init the flags to zero
                pDataPacket->OptionsFlags = 0;

                // Set the discontinuity flag if frames have been previously
                // dropped, and then reset our internal flag

                if (pStrmEx->fDiscontinuity) {
                    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    pStrmEx->fDiscontinuity = FALSE;
                }

                //
                // Return the timestamp for the frame
                //
                pDataPacket->PresentationTime.Numerator = 1;
                pDataPacket->PresentationTime.Denominator = 1;
                pDataPacket->Duration = pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

                //
                // if we have a master clock AND this is the capture stream
                //
                if (pStrmEx->hMasterClock && (StreamNumber == 0)) {

                    pDataPacket->PresentationTime.Time = pStrmEx->QST_StreamTime;
                    pDataPacket->OptionsFlags |=
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
                }
                else {
                    //
                    // no clock or the preview stream, so just mark the time as unknown
                    //
                    pDataPacket->PresentationTime.Time = 0;
                    // clear the timestamp valid flags
                    pDataPacket->OptionsFlags &=
                        ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                          KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
                }

                // Every frame we generate is a key frame (aka SplicePoint)
                // Delta frames (B or P) should not set this flag

                pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

                CompleteStreamSRB (pSrb);

            } // if we have an SRB

            else {

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // dropped frames

                pStrmEx->FrameInfo.DropCount++;

                // Set the (local) discontinuity flag
                // This will cause the next packet processed to have the
                //   KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag set.

                pStrmEx->fDiscontinuity = TRUE;

            }

            // Figure out when to capture the next frame
            pStrmEx->QST_NextFrame += pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

        } // endif time to capture a frame
    } // endif we're running

}

VOID
DeferredRoutine(
    PKDPC          pDpc,
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrpNotUsed,
    PVOID          Context
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)Context;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    PSTREAMEX                   pStrmEx;
    PKSSTREAM_HEADER            pDataPacket;
    PKS_FRAME_INFO              pFrameInfo;
    int                         StreamNumber;

    pHwDevExt->DpcRequested = FALSE;

    if (pHwDevExt->NeedCameraON == TRUE) {
        CameraChkandON(pHwDevExt, MODE_VFW);
        KeStallExecutionProcessor(100000);    // Wait 100 msec
        BertDMARestart(pHwDevExt);
        pHwDevExt->bVideoIn = TRUE;
        pHwDevExt->NeedCameraON = FALSE;
    }

    if (pHwDevExt->NeedCameraOFF == TRUE) {
        BertDMAEnable(pHwDevExt, FALSE);
        pHwDevExt->NeedCameraOFF = FALSE;
    }

    if (pHwDevExt->bRequestDpc == FALSE) {
        return;
    }

    for (StreamNumber = 0; StreamNumber < MAX_TSBVCAP_STREAMS; StreamNumber++) {
        if ( pHwDevExt->pStrmEx[StreamNumber] ) {
            TransferRoutine(pHwDevExt, StreamNumber);
        }
    }
}
#endif//TOSHIBA

/*
** HwInterrupt()
**
**   Routine is called when an interrupt at the IRQ level specified by the
**   ConfigInfo structure passed to the HwInitialize routine is received.
**
**   Note: IRQs may be shared, so the device should ensure the IRQ received
**         was expected
**
** Arguments:
**
**  pHwDevEx - the device extension for the hardware interrupt
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN
HwInterrupt(
    IN PHW_DEVICE_EXTENSION  pHwDevEx
    )
{

#ifdef  TOSHIBA
    pHwDevEx->bRequestDpc = FALSE;
    /*
     * call the acknowledge. this will not do any service, but will
     * return TRUE if the service routine is to be called.
     */
    if (!InterruptAcknowledge(pHwDevEx)) {
        return(FALSE);
    }

    /* the isr reckons that it is time to schedule the service
     * routine. This is done on a DPC.
     */

    if( pHwDevEx->bRequestDpc )
    {
        if (pHwDevEx->DpcRequested) {
            KdPrint(("dpc overrun.\n"));
        } else {
//          KdPrint(("dpc requested.\n"));
            pHwDevEx->DpcRequested = TRUE;
            IoRequestDpc(pHwDevEx->PDO, NULL, pHwDevEx);
        }
    }
    else
    {
        KdPrint(("bRequestDpc Flag is False.\n"));
        if (pHwDevEx->DpcRequested) {
            KdPrint(("dpc overrun.\n"));
        } else {
//          KdPrint(("dpc requested.\n"));
            pHwDevEx->DpcRequested = TRUE;
            IoRequestDpc(pHwDevEx->PDO, NULL, pHwDevEx);
        }
    }

    /* everything else is done in dpc routine */

    return(TRUE);
#else //TOSHIBA
    BOOL fMyIRQ = FALSE;

    if (pHwDevEx->IRQExpected)
    {
        pHwDevEx->IRQExpected = FALSE;

        //
        // call the routine to handle the IRQ here
        //

        fMyIRQ = TRUE;
    }


    //
    // returning FALSE indicates that this was not an IRQ for this device, and
    // the IRQ dispatcher will pass the IRQ down the chain to the next handler
    // for this IRQ level
    //

    return(fMyIRQ);
#endif//TOSHIBA
}

#ifdef  TOSHIBA
/*
 * interrupt acknowledge routine. This is called to ack the interrupt
 * and re-enable it for next time. It should return TRUE if it is time
 * to capture a frame.
 */
BOOLEAN
InterruptAcknowledge(PHW_DEVICE_EXTENSION pHwDevExt)
{
    LARGE_INTEGER CurrentTime;
    ULONG istat;
    ULONG intrst;
    BOOLEAN bret;
    BOOL bSLI;

    istat = ReadRegUlong(pHwDevExt, BERT_INTSTAT_REG);

    if (0xFFFFFFFF == istat)
        return FALSE;

    if (!((istat >> 16) & (istat & 0xffff)))
    {
        return FALSE;
    }

    intrst = 0x0;
    bret = FALSE;
    bSLI = FALSE;

    if ((istat & RPS_INT_MASK) && (istat & RPS_INT))
    {
        intrst |= RPS_INT_RESET;

        bret = TRUE;

        if (pHwDevExt->bVideoIn)
        {
            pHwDevExt->bRequestDpc = TRUE;
        }
#ifdef  _FPS_COUNT_
        InterruptCounter++;
#endif//_FPS_COUNT_
    }

    if ((istat & FIELD_INT_MASK) && (istat & FIELD_INT))
    {
        intrst |= FIELD_INT_RESET;
        bret = TRUE;
    }

    if ((istat & SYNC_LOCK_INT_MASK) && (istat & SYNC_LOCK_INT))
    {
        intrst |= SYNC_LOCK_INT_RESET;
        bret = TRUE;
        bSLI = TRUE;
    }

    if ((istat & FIFO_OVERFLOW_INT_MASK) && (istat & FIFO_OVERFLOW_INT))
    {
        intrst |= FIFO_OVERFLOW_INT_RESET;
        bret = TRUE;
    }

    if ((istat & LINE_TIMEOUT_INT_MASK) && (istat & LINE_TIMEOUT_INT))
    {
        intrst |= LINE_TIMEOUT_INT_RESET;
        bret = TRUE;
    }

    if ((istat & RPS_OOB_INT_MASK) && (istat & RPS_OOB_INT))
    {
        intrst |= RPS_OOB_INT_RESET;
        bret = TRUE;
    }

    if ((istat & REG_UNDEF_INT_MASK) && (istat & REG_UNDEF_INT))
    {
        intrst |= REG_UNDEF_INT_RESET;
        bret = TRUE;
    }

    if ((istat & SLOW_CLOCK_INT_MASK) && (istat & SLOW_CLOCK_INT))
    {
        intrst |= SLOW_CLOCK_INT_RESET;
        bret = TRUE;

        if (pHwDevExt->bVideoIn)
        {
            if ((ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & ERPS) == 0x0)
            {
                WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD));
            }
        }
    }

    if ((istat & OVER_RUN_INT_MASK) && (istat & OVER_RUN_INT))
    {
        intrst |= OVER_RUN_INT_RESET;
        bret = TRUE;

        if (pHwDevExt->bVideoIn)
        {
            if ((ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & ERPS) == 0x0)
            {
                WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD));
            }
        }
    }

    if ((istat & REG_LOAD_INT_MASK) && (istat & REG_LOAD_INT))
    {
        intrst |= REG_LOAD_INT_RESET;
        bret = TRUE;

        if (pHwDevExt->bVideoIn)
        {
            if ((ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & ERPS) == 0x0)
            {
                WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD));
            }
        }
    }

    if ((istat & LINE_SYNC_INT_MASK) && (istat & LINE_SYNC_INT))
    {
        intrst |= LINE_SYNC_INT_RESET;
        bret = TRUE;
    }

    if ((istat & IIC_ERROR_INT_MASK) && (istat & IIC_ERROR_INT))
    {
        intrst |= IIC_ERROR_INT_RESET;
        bret = TRUE;

        if (pHwDevExt->bVideoIn)
        {
            if ((ReadRegUlong(pHwDevExt, BERT_CAPSTAT_REG) & ERPS) == 0x0)
            {
                WriteRegUlong(pHwDevExt, BERT_CAPSTAT_REG, (ERPS | CKRE | CKMD));
            }
        }
    }

    if ((istat & PCI_PARITY_ERROR_INT_MASK) && (istat & PCI_PARITY_ERROR_INT))
    {
        intrst |= PCI_PARITY_ERROR_INT_RESET;
        bret = TRUE;
    }

    if ((istat & PCI_ACCESS_ERROR_INT_MASK) && (istat & PCI_ACCESS_ERROR_INT))
    {
        intrst |= PCI_ACCESS_ERROR_INT_RESET;
        bret = TRUE;
    }

    if ((istat & SPARE_INT_MASK) && (istat & SPARE_INT))
    {
        intrst |= SPARE_INT_RESET;
        bret = TRUE;
    }

    if (bret)
    {
        WriteRegUlong(pHwDevExt, BERT_INTRST_REG, intrst);
    }

    if (bSLI)
    {
        if (BertIsLocked(pHwDevExt))    // Mount Camera
        {
            pHwDevExt->NeedCameraON = TRUE;
            KdPrint(("Mount Camera\n"));
        }
        else                            // Remove Camera
        {
            pHwDevExt->NeedCameraOFF = TRUE;
            pHwDevExt->bVideoIn = FALSE;
            KdPrint(("Remove Camera\n"));
        }
    }
    return bret;
}
#endif//TOSHIBA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capmain.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPMAIN_H__
#define __CAPMAIN_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef  TOSHIBA
//#define _FPS_COUNT_     // For FPS confirm
#endif//TOSHIBA

#ifndef FIELDOFFSET
#define FIELDOFFSET(type, field)        (int)((INT_PTR)(&((type *)1)->field)-1)
#endif

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifdef  TOSHIBA
#define FOURCC_YVU9             mmioFOURCC('Y', 'V', 'U', '9')
#define FOURCC_YUV12            mmioFOURCC('I', '4', '2', '0')
#else //TOSHIBA
#define FOURCC_YUV422           mmioFOURCC('U', 'Y', 'V', 'Y')
#endif//TOSHIBA

typedef struct _STREAMX;
typedef struct _STREAMX *PSTREAMX;

#ifdef  TOSHIBA
#define MAX_TSBVCAP_STREAMS 2
#else //TOSHIBA
#define MAX_TSBVCAP_STREAMS 4
#endif//TOSHIBA

#ifdef  TOSHIBA
/* possible capture formats */
typedef enum _CAPTUREFORMAT {
    FmtInvalid = 0,             // default fmt is 'not set yet'
    FmtYUV12,                   // yuv12 planar
    FmtYUV9,                    // yuv9 planar
    MaxCaptureFormat
} CAPTUREFORMAT;
#endif//TOSHIBA

typedef struct _COMPRESSION_SETTINGS {
    LONG                     CompressionKeyFrameRate;
    LONG                     CompressionPFramesPerKeyFrame;
    LONG                     CompressionQuality;
} COMPRESSION_SETTINGS, *PCOMPRESSION_SETTINGS;

//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _HW_DEVICE_EXTENSION {
    PULONG                   ioBaseLocal;                           // board base address
    USHORT                   Irq;                                   // IRQ level
    BOOLEAN                  IRQExpected;                           // IRQ expected
    PSTREAMX                 pStrmEx [MAX_TSBVCAP_STREAMS];         // Pointers to each stream
    UINT                     ActualInstances [MAX_TSBVCAP_STREAMS]; // Counter of instances per stream
    PDEVICE_OBJECT           PDO;                                   // Physical Device Object
    DEVICE_POWER_STATE       DeviceState;                           // D0 ... D3

    // Spinlock and Queue for the Adapter
    BOOL                     AdapterQueueInitialized;               // Stays TRUE after first init
    KSPIN_LOCK               AdapterSpinLock;                       // Multiprocessor safe access to AdapterSRBList
    LIST_ENTRY               AdapterSRBList;                        // List of pending adapter commands
    BOOL                     ProcessingAdapterSRB;                  // Master flag which prevents reentry

    // Spinlocks and Queues for each data stream
    LIST_ENTRY               StreamSRBList[MAX_TSBVCAP_STREAMS];    // List of pending read requests
    KSPIN_LOCK               StreamSRBSpinLock[MAX_TSBVCAP_STREAMS];// Multiprocessor safe access to StreamSRBList
    int                      StreamSRBListSize[MAX_TSBVCAP_STREAMS];// Number of entries in the list

    // Control Queues for each data stream
    LIST_ENTRY               StreamControlSRBList[MAX_TSBVCAP_STREAMS];
    BOOL                     ProcessingControlSRB[MAX_TSBVCAP_STREAMS];

#ifdef  TOSHIBA
    // VideoProcAmp settings
    LONG                     Brightness;
    LONG                     BrightnessFlags;
    LONG                     Contrast;
    LONG                     ContrastFlags;
    LONG                     Hue;
    LONG                     HueFlags;
    LONG                     Saturation;
    LONG                     SaturationFlags;
    LONG                     ColorEnable;
    LONG                     ColorEnableFlags;

    // VideoControl settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    LONG                     VideoControlMode;

    // Compressor settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    COMPRESSION_SETTINGS     CompressionSettings;

#ifdef  TOSHIBA // '98-12-09 Added, for Bug-Report 253529
    KSPROPERTY_BOUNDS_LONG   BrightnessRange;
    KSPROPERTY_BOUNDS_LONG   ContrastRange;
    KSPROPERTY_BOUNDS_LONG   HueRange;
    KSPROPERTY_BOUNDS_LONG   SaturationRange;
#endif//TOSHIBA

    // Misc
    volatile BOOL            bVideoIn;  // are we actually doing video in ?
    CAPTUREFORMAT            Format;    // format of destination DIB
    DWORD                    dwAsicRev;
    // source rectangle data
    RECT                     SrcRect;
    RECT                     MaxRect;
    // driver DMA structures for direct io
    PVOID                    pRpsDMABuf;    // pointer to the RPS DMA buffer
    STREAM_PHYSICAL_ADDRESS  pPhysRpsDMABuf;// physical address of RPS DMA buffer
    // driver capture buffer information
    PVOID                    pCaptureBufferY;
    PVOID                    pCaptureBufferU;
    PVOID                    pCaptureBufferV;
    STREAM_PHYSICAL_ADDRESS  pPhysCaptureBufferY;
    STREAM_PHYSICAL_ADDRESS  pPhysCaptureBufferU;
    STREAM_PHYSICAL_ADDRESS  pPhysCaptureBufferV;
    PVOID                    pCapBuf2Y;
    PVOID                    pCapBuf2U;
    PVOID                    pCapBuf2V;
    STREAM_PHYSICAL_ADDRESS  pPhysCapBuf2Y;
    STREAM_PHYSICAL_ADDRESS  pPhysCapBuf2U;
    STREAM_PHYSICAL_ADDRESS  pPhysCapBuf2V;
    BOOL                     dblBufflag;
    //  configuration parameters for the video source and the format
    ULONG                    ulWidth;
    ULONG                    ulHeight;
    ULONG                    BufferSize;
    // RequestDpc flag for CaptureService
    BOOL                     bRequestDpc;
    volatile BOOLEAN         DpcRequested;

    unsigned                 uiFramePerSecond;
    volatile DWORD           s_physDmaActiveFlag;

    DWORD                    YoffsetOdd;
    DWORD                    UoffsetOdd;
    DWORD                    VoffsetOdd;

    DWORD                    YoffsetEven;
    DWORD                    UoffsetEven;
    DWORD                    VoffsetEven;

    DWORD                    Ystride;
    DWORD                    Ustride;
    DWORD                    Vstride;

    BOOL                     NeedCameraON;
    BOOL                     NeedCameraOFF;
    BOOL                     NeedHWInit;
    BOOL                     IsRPSReady;
#else //TOSHIBA
    // Unique identifier for the analog video input pin
    KSPIN_MEDIUM             AnalogVideoInputMedium;

    // Crossbar settings
    LONG                     VideoInputConnected;                   // which input is the video out connected to?
    LONG                     AudioInputConnected;                   // which input is the audio out connected to?

    // TV Tuner settings
    ULONG                    Frequency;
    ULONG                    VideoStandard;
    ULONG                    TuningQuality;
    ULONG                    TunerInput;
    ULONG                    Busy;

    // TV Audio settings
    ULONG                    TVAudioMode;

    // VideoProcAmp settings
    LONG                     Brightness;
    LONG                     BrightnessFlags;
    LONG                     Contrast;
    LONG                     ContrastFlags;
    LONG                     ColorEnable;
    LONG                     ColorEnableFlags;

    // CameraControl settings
    LONG                     Focus;
    LONG                     FocusFlags;
    LONG                     Zoom;
    LONG                     ZoomFlags;

    // AnalogVideoDecoder settings
    LONG                     VideoDecoderVideoStandard;
    LONG                     VideoDecoderOutputEnable;
    LONG                     VideoDecoderVCRTiming;

    // VideoControl settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    LONG                     VideoControlMode;

    // Compressor settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    COMPRESSION_SETTINGS     CompressionSettings;

    // Channel Change information
    KS_TVTUNER_CHANGE_INFO   TVTunerChangeInfo;
#endif//TOSHIBA

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAMEX {
    PHW_DEVICE_EXTENSION        pHwDevExt;          // For timer use
    PHW_STREAM_OBJECT           pStreamObject;      // For timer use
    KS_VIDEOINFOHEADER         *pVideoInfoHeader;   // format (variable size!)
    KS_FRAME_INFO               FrameInfo;          // PictureNumber, etc.
    ULONG                       fDiscontinuity;     // Discontinuity since last valid
    KSSTATE                     KSState;            // Run, Stop, Pause
    UCHAR                       LineBuffer[720 * 3];// working buffer (RGB24)

    // Clock
    HANDLE                      hMasterClock;       // Master clock to use
    REFERENCE_TIME              QST_Now;            // KeQuerySystemTime currently
    REFERENCE_TIME              QST_NextFrame;      // When to capture the next frame
    REFERENCE_TIME              QST_StreamTime;     // Stream time reported by master clock

    // Compressor settings (note these are duplicated in the
    // HW_DEVICE_EXTENSION to allow setting these before a pin is created)
    COMPRESSION_SETTINGS        CompressionSettings;

    // VideoControl settings (note these are duplicated in the
    // HW_DEVICE_EXTENSION to allow setting these before a pin is created)
    LONG                        VideoControlMode;

    // Kernel DDraw interface
    BOOL                        KernelDirectDrawRegistered;
    HANDLE                      UserDirectDrawHandle;       // DD itself
    HANDLE                      KernelDirectDrawHandle;
    BOOL                        PreEventOccurred;
    BOOL                        PostEventOccurred;
} STREAMEX, *PSTREAMEX;

//
// this structure defines the per request extension.  It defines any storage
// space that the mini driver may need in each request packet.
//

typedef struct _SRB_EXTENSION {
    LIST_ENTRY                  ListEntry;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    HANDLE                      UserSurfaceHandle;      // DDraw
    HANDLE                      KernelSurfaceHandle;    // DDraw
} SRB_EXTENSION, * PSRB_EXTENSION;

// -------------------------------------------------------------------
//
// Adapter level prototypes
//
// These functions affect the device as a whole, as opposed to
// affecting individual streams.
//
// -------------------------------------------------------------------

//
// DriverEntry:
//
// This routine is called when the mini driver is first loaded.  The driver
// should then call the StreamClassRegisterAdapter function to register with
// the stream class driver
//

ULONG DriverEntry (PVOID Context1, PVOID Context2);

#ifdef  TOSHIBA
VOID GetPCIConfigSpace(PHW_STREAM_REQUEST_BLOCK pSrb);
#endif//TOSHIBA

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the adapter should also be performed at this time.
//

BOOL STREAMAPI HwInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOL STREAMAPI HwUnInitialize ( PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called whenever the minidriver receives an interrupt
//

BOOLEAN HwInterrupt ( IN PHW_DEVICE_EXTENSION pDeviceExtension );

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID STREAMAPI AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID STREAMAPI AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID STREAMAPI AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the AdapterReceivePacket routine.  This is the
// entry point for command packets that are sent to the adapter (not to a
// specific open stream)
//

VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The adapter may choose to ignore a
// packet timeout, or rest the adapter and cancel the requests, as required.
//

VOID STREAMAPI AdapterTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// Adapter level property set handling
//

VOID STREAMAPI AdapterGetCrossbarProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetCrossbarProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetTunerProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetTunerProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoProcAmpProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoProcAmpProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetCameraControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetCameraControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetTVAudioProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetTVAudioProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetAnalogVideoDecoderProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetAnalogVideoDecoderProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoCompressionProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoCompressionProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);

BOOL
STREAMAPI
AdapterVerifyFormat(
        PKSDATAFORMAT pKSDataFormatToVerify,
        int StreamNumber);

BOOL
STREAMAPI
AdapterFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID
STREAMAPI
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb
        );

VOID
STREAMAPI
AdapterSetInstance (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


//
// prototypes for general queue management using a busy flag
//

BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    );

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    );


// -------------------------------------------------------------------
//
// Stream level prototypes
//
// These functions affect individual streams, as opposed to
// affecting the device as a whole.
//
// -------------------------------------------------------------------

//
// Routines to manage the SRB queue on a per stream basis
//

VOID
STREAMAPI
VideoQueueAddSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

PHW_STREAM_REQUEST_BLOCK
STREAMAPI
VideoQueueRemoveSRB (
    PHW_DEVICE_EXTENSION pHwDevExt,
    int StreamNumber
    );

VOID
STREAMAPI
VideoQueueCancelAllSRBs (
    PSTREAMEX pStrmEx
    );

BOOL
STREAMAPI
VideoQueueCancelOneSRB (
    PSTREAMEX pStrmEx,
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    );

//
// Data packet handlers
//
//
// prototypes for data handling routines
//
VOID STREAMAPI CompleteStreamSRB (IN PHW_STREAM_REQUEST_BLOCK pSrb);
BOOL STREAMAPI VideoSetFormat(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogVideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogVideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI EnableIRQ(PHW_STREAM_OBJECT pstrm);
VOID STREAMAPI DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//

VOID STREAMAPI VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// stream clock functions
//
VOID
STREAMAPI
VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK pSrb);

ULONGLONG
STREAMAPI
VideoGetSystemTime();

//
// The point of it all
//
VOID
STREAMAPI
VideoCaptureRoutine(
    IN PSTREAMEX pStrmEx
    );

#ifdef  TOSHIBA
VOID
DeferredRoutine(
    PKDPC          pDpc,
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrpNotUsed,
    PVOID          Context
    );

ULONG
get_AblFilter (
    PHW_DEVICE_EXTENSION pHwDevExt
    );

ULONG
get_filtering (
    PHW_DEVICE_EXTENSION pHwDevExt
    );

VOID
set_filtering (
    PHW_DEVICE_EXTENSION pHwDevExt,
    BOOL bFlag
    );

NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory (
    IN ULONG NumberOfBytes,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory (
    IN PVOID BaseAddress
    );
#endif//TOSHIBA

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CAPMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capmain.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "mediums.h"
#include "capstrm.h"
#include "capprop.h"
#include "capdebug.h"
#ifdef  TOSHIBA
#include "bert.h"

ULONG   CurrentOSType;  // 0:Win98 1:NT5.0
#endif//TOSHIBA

#ifdef  TOSHIBA
VOID
DevicePowerON (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    DWORD                   dwAddr;

    CameraChkandON(pHwDevExt, MODE_VFW);
    VC_Delay(100);
    ImageSetInputImageSize(pHwDevExt, &(pHwDevExt->SrcRect));
    ImageSetOutputImageSize(pHwDevExt, pHwDevExt->ulWidth, pHwDevExt->ulHeight);
    BertFifoConfig(pHwDevExt, pHwDevExt->Format);
    ImageSetHueBrightnessContrastSat(pHwDevExt);
    if ( pHwDevExt->ColorEnable ) {
        if ( get_AblFilter( pHwDevExt ) ) {
            set_filtering( pHwDevExt, TRUE );
        } else {
            set_filtering( pHwDevExt, FALSE );
            pHwDevExt->ColorEnable = 0;
        }
    } else {
        set_filtering( pHwDevExt, FALSE );
    }
    dwAddr = (DWORD)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
    dwAddr = (dwAddr + 0x1FFF) & 0xFFFFE000;
#endif
    pHwDevExt->s_physDmaActiveFlag = dwAddr + 0X1860;

    if( pHwDevExt->dblBufflag ){
        BertTriBuildNodes(pHwDevExt); // Add 97-04-08(Tue)
    }
    else{
        BertBuildNodes(pHwDevExt);  // Add 97-04-08(Tue)
    }
    pHwDevExt->IsRPSReady = TRUE;
    BertInterruptEnable(pHwDevExt, TRUE);
    BertDMARestart(pHwDevExt);
}

VOID
CameraPowerON (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    CameraChkandON(pHwDevExt, MODE_VFW);
    VC_Delay(100);
}

VOID
CameraPowerOFF (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    CameraChkandOFF(pHwDevExt, MODE_VFW);
}

VOID
QueryOSTypeFromRegistry()
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LONG     RegVals[2];
    PLONG    pRegVal;
    WCHAR    BasePath[] = L"\\Registry\\MACHINE\\SOFTWARE\\Toshiba\\Tsbvcap";
    RTL_QUERY_REGISTRY_TABLE Table[2];
    UNICODE_STRING RegPath;

    //
    // Get the actual values for the controls
    //

    RtlZeroMemory (Table, sizeof(Table));

    CurrentOSType = 1;  // Assume NT5.0
    RegVals[0] = CurrentOSType;

    pRegVal = RegVals;  // for convenience sake
    RegPath.Buffer = BasePath;
#ifdef  TOSHIBA // '99-01-08 Modified
    RegPath.MaximumLength = sizeof(BasePath) + (32 * sizeof(WCHAR)); //32 chars for keys
#else //TOSHIBA
    RegPath.MaximumLength = sizeof(BasePath + 32); //32 chars for keys
#endif//TOSHIBA
    RegPath.Length = 0;

    Table[0].Name = L"CurrentOSType";
    Table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[0].EntryContext = pRegVal++;

    ntStatus = RtlQueryRegistryValues(
                       RTL_REGISTRY_ABSOLUTE,
                       RegPath.Buffer,
                       Table,
                       NULL,
                       NULL );

    if( NT_SUCCESS(ntStatus))
    {
        CurrentOSType = RegVals[0];
    }
}

VOID
QueryControlsFromRegistry(
    PHW_DEVICE_EXTENSION pHwDevExt
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LONG     RegVals[6];
    PLONG    pRegVal;
    WCHAR    BasePath[] = L"\\Registry\\MACHINE\\SOFTWARE\\Toshiba\\Tsbvcap";
    RTL_QUERY_REGISTRY_TABLE Table[6];
    UNICODE_STRING RegPath;

    //
    // Get the actual values for the controls
    //

    RtlZeroMemory (Table, sizeof(Table));

    RegVals[0] = pHwDevExt->Brightness;
    RegVals[1] = pHwDevExt->Contrast;
    RegVals[2] = pHwDevExt->Hue;
    RegVals[3] = pHwDevExt->Saturation;
    RegVals[4] = pHwDevExt->ColorEnable;

    pRegVal = RegVals;   // for convenience sake
    RegPath.Buffer = BasePath;
#ifdef  TOSHIBA // '99-01-08 Modified
    RegPath.MaximumLength = sizeof(BasePath) + (32 * sizeof(WCHAR)); //32 chars for keys
#else //TOSHIBA
    RegPath.MaximumLength = sizeof(BasePath + 32); //32 chars for keys
#endif//TOSHIBA
    RegPath.Length = 0;

    Table[0].Name = L"Brightness";
    Table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[0].EntryContext = pRegVal++;

    Table[1].Name = L"Contrast";
    Table[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[1].EntryContext = pRegVal++;

    Table[2].Name = L"Hue";
    Table[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[2].EntryContext = pRegVal++;

    Table[3].Name = L"Saturation";
    Table[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[3].EntryContext = pRegVal++;

    Table[4].Name = L"FilterEnable";
    Table[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Table[4].EntryContext = pRegVal++;

    ntStatus = RtlQueryRegistryValues(
                       RTL_REGISTRY_ABSOLUTE,
                       RegPath.Buffer,
                       Table,
                       NULL,
                       NULL );

    if( NT_SUCCESS(ntStatus))
    {
        pHwDevExt->Brightness  = RegVals[0];
        pHwDevExt->Contrast    = RegVals[1];
        pHwDevExt->Hue         = RegVals[2];
        pHwDevExt->Saturation  = RegVals[3];
        pHwDevExt->ColorEnable = RegVals[4];
    }
}

VOID
SaveControlsToRegistry(
    PHW_DEVICE_EXTENSION pHwDevExt
    )
{
    LONG Value;
    WCHAR BasePath[] = L"\\Registry\\MACHINE\\SOFTWARE\\Toshiba\\Tsbvcap";
    UNICODE_STRING RegPath;


    RegPath.Buffer = BasePath;
#ifdef  TOSHIBA // '99-01-08 Modified
    RegPath.MaximumLength = sizeof(BasePath) + (32 * sizeof(WCHAR)); //32 chars for keys
#else //TOSHIBA
    RegPath.MaximumLength = sizeof(BasePath + 32); //32 chars for keys
#endif//TOSHIBA
    RegPath.Length = 0;

    Value = pHwDevExt->Brightness;
    RtlWriteRegistryValue(
                          RTL_REGISTRY_ABSOLUTE,
                          RegPath.Buffer,
                          L"Brightness",
                          REG_DWORD,
                          &Value,
                          sizeof (ULONG));

    Value = pHwDevExt->Contrast;
    RtlWriteRegistryValue(
                          RTL_REGISTRY_ABSOLUTE,
                          RegPath.Buffer,
                          L"Contrast",
                          REG_DWORD,
                          &Value,
                          sizeof (ULONG));

    Value = pHwDevExt->Hue;
    RtlWriteRegistryValue(
                          RTL_REGISTRY_ABSOLUTE,
                          RegPath.Buffer,
                          L"Hue",
                          REG_DWORD,
                          &Value,
                          sizeof (ULONG));

    Value = pHwDevExt->Saturation;
    RtlWriteRegistryValue(
                          RTL_REGISTRY_ABSOLUTE,
                          RegPath.Buffer,
                          L"Saturation",
                          REG_DWORD,
                          &Value,
                          sizeof (ULONG));

    Value = pHwDevExt->ColorEnable;
    RtlWriteRegistryValue(
                          RTL_REGISTRY_ABSOLUTE,
                          RegPath.Buffer,
                          L"FilterEnable",
                          REG_DWORD,
                          &Value,
                          sizeof (ULONG));
}
#endif//TOSHIBA

/*
** DriverEntry()
**
**   This routine is called when the driver is first loaded by PnP.
**   It in turn, calls upon the stream class to perform registration services.
**
** Arguments:
**
**   DriverObject -
**          Driver object for this driver
**
**   RegistryPath -
**          Registry path string for this driver's key
**
** Returns:
**
**   Results of StreamClassRegisterAdapter()
**
** Side Effects:  none
*/

ULONG
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{

    HW_INITIALIZATION_DATA      HwInitData;
    ULONG                       ReturnValue;


    KdPrint(("TsbVcap: DriverEntry\n"));

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    //
    // Set the Adapter entry points for the driver
    //

#ifdef  TOSHIBA
    QueryOSTypeFromRegistry();

    HwInitData.HwInterrupt              = HwInterrupt;
#else //TOSHIBA
    HwInitData.HwInterrupt              = NULL; // HwInterrupt;
#endif//TOSHIBA

    HwInitData.HwReceivePacket          = AdapterReceivePacket;
    HwInitData.HwCancelPacket           = AdapterCancelPacket;
    HwInitData.HwRequestTimeoutHandler  = AdapterTimeoutPacket;

    HwInitData.DeviceExtensionSize      = sizeof(HW_DEVICE_EXTENSION);
    HwInitData.PerRequestExtensionSize  = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX);
    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = 3;
#ifdef  TOSHIBA
    if ( CurrentOSType ) {  // NT5.0
        HwInitData.DmaBufferSize = 8192 * 2;
    } else {
        HwInitData.DmaBufferSize = 8192 * 2 + MAX_CAPTURE_BUFFER_SIZE;
    }
#else //TOSHIBA
    HwInitData.DmaBufferSize            = 0;
#endif//TOSHIBA

    // Don't rely on the stream class using raised IRQL to synchronize
    // execution.  This single paramter most affects the overall structure
    // of the driver.

    HwInitData.TurnOffSynchronization   = TRUE;

    ReturnValue = StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData);

    KdPrint(("TsbVcap: StreamClassRegisterAdapter = %x\n", ReturnValue));

    return ReturnValue;
}

//==========================================================================;
//                   Adapter Based Request Handling Routines
//==========================================================================;

/*
** HwInitialize()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Initialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOL
STREAMAPI
HwInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    STREAM_PHYSICAL_ADDRESS     adr;
    ULONG                       Size;
    PUCHAR                      pDmaBuf;
    int                         j;

    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;

    PHW_DEVICE_EXTENSION pHwDevExt =
        (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

    KdPrint(("TsbVcap: HwInitialize()\n"));

#ifdef  TOSHIBA
    if (ConfigInfo->NumberOfAccessRanges == 0) {
#else //TOSHIBA
    if (ConfigInfo->NumberOfAccessRanges != 0) {
#endif//TOSHIBA
        KdPrint(("TsbVcap: illegal config info\n"));

        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }

    KdPrint(("TsbVcap: Number of access ranges = %lx\n", ConfigInfo->NumberOfAccessRanges));
    KdPrint(("TsbVcap: Memory Range = %lx\n", pHwDevExt->ioBaseLocal));
    KdPrint(("TsbVcap: IRQ = %lx\n", ConfigInfo->BusInterruptLevel));

    if (ConfigInfo->NumberOfAccessRanges != 0) {
        pHwDevExt->ioBaseLocal
                = (PULONG)(ConfigInfo->AccessRanges[0].RangeStart.LowPart);
    }

    pHwDevExt->Irq  = (USHORT)(ConfigInfo->BusInterruptLevel);

    ConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
                DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    pDmaBuf = StreamClassGetDmaBuffer(pHwDevExt);

    adr = StreamClassGetPhysicalAddress(pHwDevExt,
            NULL, pDmaBuf, DmaBuffer, &Size);

#ifdef  TOSHIBA
    if ( CurrentOSType ) {  // NT5.0
        pHwDevExt->pRpsDMABuf = pDmaBuf;
        pHwDevExt->pPhysRpsDMABuf = adr;
        pHwDevExt->pCaptureBufferY = NULL;
        pHwDevExt->pCaptureBufferU = NULL;
        pHwDevExt->pCaptureBufferV = NULL;
        pHwDevExt->pPhysCaptureBufferY.LowPart = 0;
        pHwDevExt->pPhysCaptureBufferY.HighPart = 0;
        pHwDevExt->pPhysCaptureBufferU.LowPart = 0;
        pHwDevExt->pPhysCaptureBufferU.HighPart = 0;
        pHwDevExt->pPhysCaptureBufferV.LowPart = 0;
        pHwDevExt->pPhysCaptureBufferV.HighPart = 0;
        pHwDevExt->BufferSize = 0;
    } else {
        pHwDevExt->pRpsDMABuf = pDmaBuf;
        pHwDevExt->pCaptureBufferY = pDmaBuf + (8192 * 2);
        pHwDevExt->pPhysRpsDMABuf = adr;
        adr.LowPart += 8192 * 2;
        pHwDevExt->pPhysCaptureBufferY = adr;
        pHwDevExt->BufferSize = 0;
    }

    InitializeConfigDefaults(pHwDevExt);
    pHwDevExt->NeedHWInit = TRUE;
    if(!SetupPCILT(pHwDevExt))
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }
    pHwDevExt->dblBufflag=FALSE;
    BertInitializeHardware(pHwDevExt);
    if(SetASICRev(pHwDevExt) != TRUE )
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }
    BertSetDMCHE(pHwDevExt);
#if 0   // move to CameraPowerON()
    if( !CameraChkandON(pHwDevExt, MODE_VFW) )
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }
#endif
    HWInit(pHwDevExt);
#endif//TOSHIBA

#ifdef  TOSHIBA
    // Init VideoProcAmp properties
    pHwDevExt->Brightness = 0x80;
    pHwDevExt->BrightnessFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    pHwDevExt->Contrast = 0x80;
    pHwDevExt->ContrastFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    pHwDevExt->Hue = 0x80;
    pHwDevExt->HueFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    pHwDevExt->Saturation = 0x80;
    pHwDevExt->SaturationFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    pHwDevExt->ColorEnable = ColorEnableDefault;
    pHwDevExt->ColorEnableFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

#ifdef  TOSHIBA // '98-12-09 Added, for Bug-Report 253529
    pHwDevExt->BrightnessRange = BrightnessRangeAndStep[0].Bounds;
    pHwDevExt->ContrastRange   = ContrastRangeAndStep[0].Bounds;
    pHwDevExt->HueRange        = HueRangeAndStep[0].Bounds;
    pHwDevExt->SaturationRange = SaturationRangeAndStep[0].Bounds;
#endif//TOSHIBA

    // Init VideoControl properties
    pHwDevExt->VideoControlMode = 0;
#else //TOSHIBA
    // Init Crossbar properties
    pHwDevExt->VideoInputConnected = 0;     // TvTuner video is the default
    pHwDevExt->AudioInputConnected = 5;     // TvTuner audio is the default

    // Init VideoProcAmp properties
    pHwDevExt->Brightness = BrightnessDefault;
    pHwDevExt->BrightnessFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
    pHwDevExt->Contrast = ContrastDefault;
    pHwDevExt->ContrastFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
    pHwDevExt->ColorEnable = ColorEnableDefault;
    pHwDevExt->ColorEnableFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    // Init CameraControl properties
    pHwDevExt->Focus = FocusDefault;
    pHwDevExt->FocusFlags = KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
    pHwDevExt->Zoom = ZoomDefault;
    pHwDevExt->ZoomFlags = KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;

    // Init TvTuner properties
    pHwDevExt->TunerInput = 0;
    pHwDevExt->Busy = 0;

    // Init TvAudio properties
    pHwDevExt->TVAudioMode = KS_TVAUDIO_MODE_MONO   |
                             KS_TVAUDIO_MODE_LANG_A ;

    // Init AnalogVideoDecoder properties
    pHwDevExt->VideoDecoderVideoStandard = KS_AnalogVideo_NTSC_M;
    pHwDevExt->VideoDecoderOutputEnable = FALSE;
    pHwDevExt->VideoDecoderVCRTiming = FALSE;

    // Init VideoControl properties
    pHwDevExt->VideoControlMode = 0;
#endif//TOSHIBA

    // Init VideoCompression properties
    pHwDevExt->CompressionSettings.CompressionKeyFrameRate = 15;
    pHwDevExt->CompressionSettings.CompressionPFramesPerKeyFrame = 3;
    pHwDevExt->CompressionSettings.CompressionQuality = 5000;

    pHwDevExt->PDO = ConfigInfo->PhysicalDeviceObject;
    KdPrint(("TsbVcap: Physical Device Object = %lx\n", pHwDevExt->PDO));

#ifdef  TOSHIBA
    IoInitializeDpcRequest(pHwDevExt->PDO, DeferredRoutine);
#endif//TOSHIBA

    for (j = 0; j < MAX_TSBVCAP_STREAMS; j++){

        // For each stream, maintain a separate queue for data and control
        InitializeListHead (&pHwDevExt->StreamSRBList[j]);
        InitializeListHead (&pHwDevExt->StreamControlSRBList[j]);
        KeInitializeSpinLock (&pHwDevExt->StreamSRBSpinLock[j]);
        pHwDevExt->StreamSRBListSize[j] = 0;
    }


    KdPrint(("TsbVcap: Exit, HwInitialize()\n"));

    pSrb->Status = STATUS_SUCCESS;

    return (TRUE);

}

/*
** HwUnInitialize()
**
**   This routine is called when an SRB_UNINITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the UnInitialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOL
STREAMAPI
HwUnInitialize (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
#ifdef  TOSHIBA
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    if ( CurrentOSType ) {  // NT5.0
        if ( pHwDevExt->pCaptureBufferY )
        {
            // free frame buffer
            MmFreeContiguousMemory(pHwDevExt->pCaptureBufferY);
            pHwDevExt->pCaptureBufferY = NULL;
            pHwDevExt->pPhysCaptureBufferY.LowPart = 0;
            pHwDevExt->pPhysCaptureBufferY.HighPart = 0;
        }
        if ( pHwDevExt->pCaptureBufferU )
        {
            // free frame buffer
            MmFreeContiguousMemory(pHwDevExt->pCaptureBufferU);
            pHwDevExt->pCaptureBufferU = NULL;
            pHwDevExt->pPhysCaptureBufferU.LowPart = 0;
            pHwDevExt->pPhysCaptureBufferU.HighPart = 0;
        }
        if ( pHwDevExt->pCaptureBufferV )
        {
            // free frame buffer
            MmFreeContiguousMemory(pHwDevExt->pCaptureBufferV);
            pHwDevExt->pCaptureBufferV = NULL;
            pHwDevExt->pPhysCaptureBufferV.LowPart = 0;
            pHwDevExt->pPhysCaptureBufferV.HighPart = 0;
        }
    }
#endif//TOSHIBA

    pSrb->Status = STATUS_SUCCESS;

    return TRUE;
}

/*
** AdapterPowerState()
**
**   This routine is called when an SRB_CHANGE_POWER_STATE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Change Power state command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN
STREAMAPI
AdapterPowerState (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
#ifdef  TOSHIBA
    int                     Counter;
    PSTREAMEX               pStrmEx;
#endif//TOSHIBA

    pHwDevExt->DeviceState = pSrb->CommandData.DeviceState;

#ifdef  TOSHIBA
    for (Counter = 0; Counter < DRIVER_STREAM_COUNT; Counter++) {
        if ( pStrmEx = (PSTREAMEX)pHwDevExt->pStrmEx[Counter] ) {
            //
            // Only when it is not streaming, its power state can be changed.
            // We have "DontSuspendIfStreamsAreRunning" turn on in the INF.
            //
            if (pStrmEx->KSState == KSSTATE_PAUSE ||
                pStrmEx->KSState == KSSTATE_RUN) {
                if (pHwDevExt->DeviceState == PowerDeviceD3) {
                    if (pHwDevExt->bVideoIn == TRUE) {
                      // disable the RPS_INT and field interrupts
                      BertInterruptEnable(pHwDevExt, FALSE);
                      BertDMAEnable(pHwDevExt, FALSE);
                      // wait for the current data xfer to complete
                      pHwDevExt->bVideoIn = FALSE;
                    }
                    VideoQueueCancelAllSRBs (pStrmEx);
                    break;
                } else if (pHwDevExt->DeviceState == PowerDeviceD0) {
                    pHwDevExt->bVideoIn = TRUE;
#ifdef  TOSHIBA // '99-01-20 Modified
                    DevicePowerON( pSrb );
#else //TOSHIBA
                    StreamClassCallAtNewPriority(
                            NULL,
                            pSrb->HwDeviceExtension,
                            Low,
                            (PHW_PRIORITY_ROUTINE) DevicePowerON,
                            pSrb
                    );
#endif//TOSHIBA
                }
            }
        }
    }
#endif//TOSHIBA

    return TRUE;
}

/*
** AdapterSetInstance()
**
**   This routine is called to set all of the Medium instance fields
**
** Arguments:
**
**   pSrb - pointer to stream request block
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetInstance (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    int j;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    // Use our HwDevExt as the instance data on the Mediums
    // This allows multiple instances to be uniquely identified and
    // connected.  The value used in .Id is not important, only that
    // it is unique for each hardware connection

#ifdef  TOSHIBA
    for (j = 0; j < SIZEOF_ARRAY (CaptureMediums); j++) {
        CaptureMediums[j].Id = 0; //(ULONG) pHwDevExt;
    }
#else //TOSHIBA
    for (j = 0; j < SIZEOF_ARRAY (TVTunerMediums); j++) {
        TVTunerMediums[j].Id = 0; //(ULONG) pHwDevExt;
    }
    for (j = 0; j < SIZEOF_ARRAY (TVAudioMediums); j++) {
        TVAudioMediums[j].Id = 0; //(ULONG) pHwDevExt;
    }
    for (j = 0; j < SIZEOF_ARRAY (CrossbarMediums); j++) {
        CrossbarMediums[j].Id = 0; //(ULONG) pHwDevExt;
    }
    for (j = 0; j < SIZEOF_ARRAY (CaptureMediums); j++) {
        CaptureMediums[j].Id = 0; //(ULONG) pHwDevExt;
    }

    pHwDevExt->AnalogVideoInputMedium = CaptureMediums[2];
#endif//TOSHIBA
}

/*
** AdapterCompleteInitialization()
**
**   This routine is called when an SRB_COMPLETE_INITIALIZATION request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCompleteInitialization (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS                Status;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    KIRQL                   KIrql;

    KIrql = KeGetCurrentIrql();

    // The following allows multiple instance of identical hardware
    // to be installed
    AdapterSetInstance (pSrb);

    // Create the Registry blobs that DShow uses to create
    // graphs via Mediums

#ifndef TOSHIBA
    // Register the TVTuner
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVTUNER,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVTunerMediums),  // IN ULONG            PinCount,
                    TVTunerPinDirection,            // IN ULONG          * Flags,
                    TVTunerMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the Crossbar
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CROSSBAR,           // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CrossbarMediums), // IN ULONG            PinCount,
                    CrossbarPinDirection,           // IN ULONG          * Flags,
                    CrossbarMediums,                // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the TVAudio decoder
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVAUDIO,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVAudioMediums),  // IN ULONG            PinCount,
                    TVAudioPinDirection,            // IN ULONG          * Flags,
                    TVAudioMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the Capture filter
    // Note:  This should be done automatically be MSKsSrv.sys,
    // when that component comes on line (if ever) ...
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CAPTURE,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CaptureMediums),  // IN ULONG            PinCount,
                    CapturePinDirection,            // IN ULONG          * Flags,
                    CaptureMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );
#endif//TOSHIBA

}


/*
** AdapterOpenStream()
**
**   This routine is called when an OpenStream SRB request is received.
**   A stream is identified by a stream number, which indexes an array
**   of KSDATARANGE structures.  The particular KSDATAFORMAT format to
**   be used is also passed in, which should be verified for validity.
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterOpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    //
    // the stream extension structure is allocated by the stream class driver
    //

    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
#ifdef  TOSHIBA
    int                     Counter;
    BOOL                    First = TRUE;
#endif//TOSHIBA


    RtlZeroMemory(pStrmEx, sizeof(STREAMEX));

    KdPrint(("TsbVcap: ------- ADAPTEROPENSTREAM ------- StreamNumber=%d\n", StreamNumber));

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT || StreamNumber < 0) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

    //
    // Check that we haven't exceeded the instance count for this stream
    //

    if (pHwDevExt->ActualInstances[StreamNumber] >=
        Streams[StreamNumber].hwStreamInfo.NumberOfPossibleInstances) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

    //
    // Check the validity of the format being requested
    //

    if (!AdapterVerifyFormat (pKSDataFormat, StreamNumber)) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

#ifdef  TOSHIBA
    QueryControlsFromRegistry(pHwDevExt);
#endif//TOSHIBA

    //
    // And set the format for the stream
    //

    if (!VideoSetFormat (pSrb)) {

        return;
    }

    ASSERT (pHwDevExt->pStrmEx [StreamNumber] == NULL);

#ifdef  TOSHIBA
    for (Counter = 0; Counter < DRIVER_STREAM_COUNT; Counter++) {
        if ( pHwDevExt->pStrmEx[Counter] ) {
            First = FALSE;
            break;
        }
    } // for all streams
#endif//TOSHIBA

    // Maintain an array of all the StreamEx structures in the HwDevExt
    // so that we can cancel IRPs from any stream

    pHwDevExt->pStrmEx [StreamNumber] = (PSTREAMX) pStrmEx;

    // Set up pointers to the handlers for the stream data and control handlers

    pSrb->StreamObject->ReceiveDataPacket =
            (PVOID) Streams[StreamNumber].hwStreamObject.ReceiveDataPacket;
    pSrb->StreamObject->ReceiveControlPacket =
            (PVOID) Streams[StreamNumber].hwStreamObject.ReceiveControlPacket;

    //
    // The DMA flag must be set when the device will be performing DMA directly
    // to the data buffer addresses passed in to the ReceiceDataPacket routines.
    //

    pSrb->StreamObject->Dma = Streams[StreamNumber].hwStreamObject.Dma;

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing
    //

    pSrb->StreamObject->Pio = Streams[StreamNumber].hwStreamObject.Pio;

    //
    // How many extra bytes will be passed up from the driver for each frame?
    //

    pSrb->StreamObject->StreamHeaderMediaSpecific =
                Streams[StreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

    pSrb->StreamObject->StreamHeaderWorkspace =
                Streams[StreamNumber].hwStreamObject.StreamHeaderWorkspace;

    //
    // Indicate the clock support available on this stream
    //

    pSrb->StreamObject->HwClockObject =
                Streams[StreamNumber].hwStreamObject.HwClockObject;

    //
    // Increment the instance count on this stream
    //
    pHwDevExt->ActualInstances[StreamNumber]++;


    // Retain a private copy of the HwDevExt and StreamObject in the stream extension
    // so we can use a timer

    pStrmEx->pHwDevExt = pHwDevExt;                     // For timer use
    pStrmEx->pStreamObject = pSrb->StreamObject;        // For timer use

    // Initialize the compression settings
    // These may have been changed from the default values in the HwDevExt
    // before the stream was opened
    pStrmEx->CompressionSettings.CompressionKeyFrameRate =
        pHwDevExt->CompressionSettings.CompressionKeyFrameRate;
    pStrmEx->CompressionSettings.CompressionPFramesPerKeyFrame =
        pHwDevExt->CompressionSettings.CompressionPFramesPerKeyFrame;
    pStrmEx->CompressionSettings.CompressionQuality =
        pHwDevExt->CompressionSettings.CompressionQuality;

    // Init VideoControl properties
    pStrmEx->VideoControlMode = pHwDevExt->VideoControlMode;

#ifdef  TOSHIBA
    if ( First ) {
#ifdef  TOSHIBA // '99-01-20 Modified
        CameraPowerON( pSrb );
#else //TOSHIBA
        StreamClassCallAtNewPriority(
                NULL,
                pSrb->HwDeviceExtension,
                Low,
                (PHW_PRIORITY_ROUTINE) CameraPowerON,
                pSrb
        );
#endif//TOSHIBA
    }
#endif//TOSHIBA

    KdPrint(("TsbVcap: AdapterOpenStream Exit\n"));

}

/*
** AdapterCloseStream()
**
**   Close the requested data stream.
**
**   Note that a stream could be closed arbitrarily in the midst of streaming
**   if a user mode app crashes.  Therefore, you must release all outstanding
**   resources, disable interrupts, complete all pending SRBs, and put the
**   stream back into a quiescent condition.
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
    KS_VIDEOINFOHEADER      *pVideoInfoHdr = pStrmEx->pVideoInfoHeader;
#ifdef  TOSHIBA
    int                     Counter;
    BOOL                    ClosedAll = TRUE;
#endif//TOSHIBA


    KdPrint(("TsbVcap: -------- ADAPTERCLOSESTREAM ------ StreamNumber=%d\n", StreamNumber));

    if (pHwDevExt->StreamSRBListSize > 0) {
        VideoQueueCancelAllSRBs (pStrmEx);
        KdPrint(("TsbVcap: Outstanding SRBs at stream close!!!\n"));
    }

    pHwDevExt->ActualInstances[StreamNumber]--;

    ASSERT (pHwDevExt->pStrmEx [StreamNumber] != 0);

    pHwDevExt->pStrmEx [StreamNumber] = 0;

    //
    // the minidriver should free any resources that were allocate at
    // open stream time etc.
    //

    // Free the variable length VIDEOINFOHEADER

    if (pVideoInfoHdr) {
        ExFreePool(pVideoInfoHdr);
        pStrmEx->pVideoInfoHeader = NULL;
    }

    // Make sure we no longer reference the clock
    pStrmEx->hMasterClock = NULL;

    // Make sure the state is reset to stopped,
    pStrmEx->KSState = KSSTATE_STOP;

#ifdef  TOSHIBA
    for (Counter = 0; Counter < DRIVER_STREAM_COUNT; Counter++) {
        if ( pHwDevExt->pStrmEx[Counter] ) {
            ClosedAll = FALSE;
            break;
        }
    } // for all streams
    if ( ClosedAll ) {
        if( pHwDevExt->dblBufflag ){
                Free_TriBuffer(pHwDevExt);
                pHwDevExt->IsRPSReady = FALSE;
                pHwDevExt->dblBufflag = FALSE;
        }
#ifdef  TOSHIBA // '99-01-20 Modified
        CameraPowerOFF( pSrb );
#else //TOSHIBA
        StreamClassCallAtNewPriority(
                NULL,
                pSrb->HwDeviceExtension,
                Low,
                (PHW_PRIORITY_ROUTINE) CameraPowerOFF,
                pSrb
        );
#endif//TOSHIBA
        SaveControlsToRegistry(pHwDevExt);
    }
#endif//TOSHIBA

}


/*
** AdapterStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    int j;

    PHW_DEVICE_EXTENSION pHwDevExt =
        ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //

    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

     //
     // pick up the pointer to the array of stream information data structures
     //

     PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // verify that the buffer is large enough to hold our return data
    //

    DEBUG_ASSERT (pSrb->NumberOfBytesToTransfer >=
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION) * DRIVER_STREAM_COUNT);

#ifndef TOSHIBA
    // Ugliness.  To allow mulitple instances, modify the pointer to the
    // AnalogVideoMedium and save it in our device extension

    Streams[STREAM_AnalogVideoInput].hwStreamInfo.Mediums =
           &pHwDevExt->AnalogVideoInputMedium;
    pHwDevExt->AnalogVideoInputMedium = CrossbarMediums[9];
    pHwDevExt->AnalogVideoInputMedium.Id = 0; //(ULONG) pHwDevExt;
#endif//TOSHIBA

     //
     // Set the header
     //

     StreamHeader.NumDevPropArrayEntries = NUMBER_OF_ADAPTER_PROPERTY_SETS;
     StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) AdapterPropertyTable;
     *pstrhdr = StreamHeader;

     //
     // stuff the contents of each HW_STREAM_INFORMATION struct
     //

     for (j = 0; j < DRIVER_STREAM_COUNT; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
     }

}


/*
** AdapterReceivePacket()
**
**   Main entry point for receiving adapter based request SRBs.  This routine
**   will always be called at Passive level.
**
**   Note: This is an asyncronous entry point.  The request does not necessarily
**         complete on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    BOOL                    Busy;

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    KdPrint(("TsbVcap: Receiving Adapter  SRB %8x, %x\n", pSrb, pSrb->Command));

    // The very first time through, we need to initialize the adapter spinlock
    // and queue
    if (!pHwDevExt->AdapterQueueInitialized) {
        InitializeListHead (&pHwDevExt->AdapterSRBList);
        KeInitializeSpinLock (&pHwDevExt->AdapterSpinLock);
        pHwDevExt->AdapterQueueInitialized = TRUE;
        pHwDevExt->ProcessingAdapterSRB = FALSE;
    }

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                    pSrb,
                    &pHwDevExt->AdapterSpinLock,
                    &pHwDevExt->ProcessingAdapterSRB,
                    &pHwDevExt->AdapterSRBList);

    if (Busy) {
        return;
    }

    //
    // This will run until the queue is empty
    //
    while (TRUE) {
        //
        // Assume success
        //
        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_INITIALIZE_DEVICE:

            // open the device

            HwInitialize(pSrb);

            break;

        case SRB_UNINITIALIZE_DEVICE:

            // close the device.

            HwUnInitialize(pSrb);

            break;

        case SRB_OPEN_STREAM:

            // open a stream

            AdapterOpenStream(pSrb);

            break;

        case SRB_CLOSE_STREAM:

            // close a stream

            AdapterCloseStream(pSrb);

            break;

        case SRB_GET_STREAM_INFO:

            //
            // return a block describing all the streams
            //

            AdapterStreamInfo(pSrb);

            break;

        case SRB_GET_DATA_INTERSECTION:

            //
            // Return a format, given a range
            //

            AdapterFormatFromRange(pSrb);

            break;

        case SRB_OPEN_DEVICE_INSTANCE:
        case SRB_CLOSE_DEVICE_INSTANCE:

            //
            // We should never get these since this is a single instance device
            //

            TRAP
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_GET_DEVICE_PROPERTY:

            //
            // Get adapter wide properties
            //

            AdapterGetProperty (pSrb);
            break;

        case SRB_SET_DEVICE_PROPERTY:

            //
            // Set adapter wide properties
            //

            AdapterSetProperty (pSrb);
            break;

        case SRB_PAGING_OUT_DRIVER:

            //
            // The driver is being paged out
            // Disable Interrupts if you have them!
            //
            KdPrint(("'TsbVcap: Receiving SRB_PAGING_OUT_DRIVER -- SRB=%x\n", pSrb));
            break;

        case SRB_CHANGE_POWER_STATE:

            //
            // Changing the device power state, D0 ... D3
            //
            KdPrint(("'TsbVcap: Receiving SRB_CHANGE_POWER_STATE ------ SRB=%x\n", pSrb));
            AdapterPowerState(pSrb);
            break;

        case SRB_INITIALIZATION_COMPLETE:

            //
            // Stream class has finished initialization.
            // Now create DShow Medium interface BLOBs.
            // This needs to be done at low priority since it uses the registry
            //
            KdPrint(("'TsbVcap: Receiving SRB_INITIALIZATION_COMPLETE-- SRB=%x\n", pSrb));

            AdapterCompleteInitialization (pSrb);
            break;


        case SRB_UNKNOWN_DEVICE_COMMAND:
        default:

            //
            // this is a request that we do not understand.  Indicate invalid
            // command and complete the request
            //
            pSrb->Status = STATUS_NOT_IMPLEMENTED;

        }

        //
        // Indicate back to the Stream Class that we're done with this SRB
        //
        CompleteDeviceSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                &pSrb,
                &pHwDevExt->AdapterSpinLock,
                &pHwDevExt->ProcessingAdapterSRB,
                &pHwDevExt->AdapterSRBList);

        if (!Busy) {
            break;
        }
    } // end of while there's anything in the queue
}

/*
** AdapterCancelPacket ()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    PSTREAMEX                   pStrmEx;
    int                         StreamNumber;
    BOOL                        Found = FALSE;

    //
    // Run through all the streams the driver has available
    //

    for (StreamNumber = 0; !Found && (StreamNumber < DRIVER_STREAM_COUNT); StreamNumber++) {

        //
        // Check to see if the stream is in use
        //

        if (pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamNumber]) {

            Found = VideoQueueCancelOneSRB (
                pStrmEx,
                pSrb
                );

        } // if the stream is open
    } // for all streams

    KdPrint(("TsbVcap: Cancelling SRB %8x Succeeded=%d\n", pSrb, Found));
}

/*
** AdapterTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The adapter must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    //
    // Unlike most devices, we need to hold onto data SRBs indefinitely,
    // since the graph could be in a pause state indefinitely
    //

    KdPrint(("TsbVcap: Timeout    Adapter SRB %8x\n", pSrb));

    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

}

/*
** CompleteDeviceSRB ()
**
**   This routine is called when a packet is being completed.
**   The optional second notification type is used to indicate ReadyForNext
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:
**
*/

VOID
STREAMAPI
CompleteDeviceSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    KdPrint(("TsbVcap: Completing Adapter SRB %8x\n", pSrb));

    StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
}

/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**         BOOL fCompareFormatSize - TRUE when comparing ranges
**                                 - FALSE when comparing formats
**
** Returns:
**
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOL fCompareFormatSize
    )
{
    return (
        IsEqualGUID (
            &DataRange1->MajorFormat,
            &DataRange2->MajorFormat) &&
        IsEqualGUID (
            &DataRange1->SubFormat,
            &DataRange2->SubFormat) &&
        IsEqualGUID (
            &DataRange1->Specifier,
            &DataRange2->Specifier) &&
        (fCompareFormatSize ?
                (DataRange1->FormatSize == DataRange2->FormatSize) : TRUE ));
}


/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported KSDATA_RANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormat - pointer of a KSDATAFORMAT structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterVerifyFormat(
    PKSDATAFORMAT pKSDataFormatToVerify,
    int StreamNumber
    )
{
    BOOL                        fOK = FALSE;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT) {
        TRAP;
        return FALSE;
    }

    NumberOfFormatArrayEntries =
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;


    KdPrint(("TsbVcap: AdapterVerifyFormat, Stream=%d\n", StreamNumber));
    KdPrint(("TsbVcap: FormatSize=%d\n",  pKSDataFormatToVerify->FormatSize));
    KdPrint(("TsbVcap: MajorFormat=%x\n", pKSDataFormatToVerify->MajorFormat));

    //
    // Walk the formats supported by the stream
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        // Check for a match on the three GUIDs and format size

        if (!AdapterCompareGUIDsAndFormatSize(
                        pKSDataFormatToVerify,
                        *pAvailableFormats,
                        FALSE /* CompareFormatSize */ )) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (&pKSDataFormatToVerify->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

            PKS_DATAFORMAT_VIDEOINFOHEADER  pDataFormatVideoInfoHeader =
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormatToVerify;
            PKS_VIDEOINFOHEADER  pVideoInfoHdrToVerify =
                     (PKS_VIDEOINFOHEADER) &pDataFormatVideoInfoHeader->VideoInfoHeader;
            PKS_DATARANGE_VIDEO             pKSDataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            KS_VIDEO_STREAM_CONFIG_CAPS    *pConfigCaps = &pKSDataRangeVideo->ConfigCaps;
            RECT                            rcImage;

            KdPrint(("TsbVcap: AdapterVerifyFormat\n"));
            KdPrint(("TsbVcap: pVideoInfoHdrToVerify=%x\n", pVideoInfoHdrToVerify));
            KdPrint(("TsbVcap: KS_VIDEOINFOHEADER size=%d\n",
                    KS_SIZE_VIDEOHEADER (pVideoInfoHdrToVerify)));
            KdPrint(("TsbVcap: Width=%d  Height=%d  BitCount=%d\n",
            pVideoInfoHdrToVerify->bmiHeader.biWidth,
            pVideoInfoHdrToVerify->bmiHeader.biHeight,
            pVideoInfoHdrToVerify->bmiHeader.biBitCount));
            KdPrint(("TsbVcap: biSizeImage=%d\n",
                pVideoInfoHdrToVerify->bmiHeader.biSizeImage));

            /*
            **  HOW BIG IS THE IMAGE REQUESTED (pseudocode follows)
            **
            **  if (IsRectEmpty (&rcTarget) {
            **      SetRect (&rcImage, 0, 0,
            **              BITMAPINFOHEADER.biWidth,
                            BITMAPINFOHEADER.biHeight);
            **  }
            **  else {
            **      // Probably rendering to a DirectDraw surface,
            **      // where biWidth is used to expressed the "stride"
            **      // in units of pixels (not bytes) of the destination surface.
            **      // Therefore, use rcTarget to get the actual image size
            **
            **      rcImage = rcTarget;
            **  }
            */

            if ((pVideoInfoHdrToVerify->rcTarget.right -
                 pVideoInfoHdrToVerify->rcTarget.left <= 0) ||
                (pVideoInfoHdrToVerify->rcTarget.bottom -
                 pVideoInfoHdrToVerify->rcTarget.top <= 0)) {

                 rcImage.left = rcImage.top = 0;
                 rcImage.right = pVideoInfoHdrToVerify->bmiHeader.biWidth;
                 rcImage.bottom = pVideoInfoHdrToVerify->bmiHeader.biHeight;
            }
            else {
                 rcImage = pVideoInfoHdrToVerify->rcTarget;
            }

            //
            // TODO, perform all other verification tests here!!!
            //

            //
            // HOORAY, the format passed all of the tests, so we support it
            //

            fOK = TRUE;
            break;

        } // End of VIDEOINFOHEADER specifier

#ifndef TOSHIBA
        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier,
                &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {

            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            //
            // TODO, perform all other verification tests here!!!
            //

            fOK = TRUE;
            break;

        } // End of KS_ANALOGVIDEOINFO specifier
#endif//TOSHIBA

    } // End of loop on all formats for this stream

    return fOK;
}

/*
** AdapterFormatFromRange()
**
**   Produces a DATAFORMAT given a DATARANGE.
**
**   Think of a DATARANGE as a multidimensional space of all of the possible image
**       sizes, cropping, scaling, and framerate possibilities.  Here, the caller
**       is saying "Out of this set of possibilities, could you verify that my
**       request is acceptable?".  The resulting singular output is a DATAFORMAT.
**       Note that each different colorspace (YUV vs RGB8 vs RGB24)
**       must be represented as a separate DATARANGE.
**
**   Generally, the resulting DATAFORMAT will be immediately used to open a stream
**       in that format.
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       FormatSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT) {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        TRAP;
        return FALSE;
    }

    NumberOfFormatArrayEntries =
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    //
    // Is the caller trying to get the format, or the size of the format?
    //

    OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if (!AdapterCompareGUIDsAndFormatSize(
                        DataRange,
                        *pAvailableFormats,
                        TRUE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (&DataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

            PKS_DATARANGE_VIDEO DataRangeVideoToVerify =
                    (PKS_DATARANGE_VIDEO) DataRange;
            PKS_DATARANGE_VIDEO DataRangeVideo =
                    (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            PKS_DATAFORMAT_VIDEOINFOHEADER DataFormatVideoInfoHeaderOut;

            //
            // Check that the other fields match
            //
            if ((DataRangeVideoToVerify->bFixedSizeSamples != DataRangeVideo->bFixedSizeSamples) ||
                (DataRangeVideoToVerify->bTemporalCompression != DataRangeVideo->bTemporalCompression) ||
                (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
                (DataRangeVideoToVerify->MemoryAllocationFlags != DataRangeVideo->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps,
                        &DataRangeVideo->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) !=
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
                continue;
            }

            // MATCH FOUND!
            MatchFound = TRUE;
            FormatSize = sizeof (KSDATAFORMAT) +
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader);

            if (OnlyWantsSize) {
                break;
            }

            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the
            // actual VideoInfoHeader

            DataFormatVideoInfoHeaderOut = (PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer;

            // Copy over the KSDATAFORMAT
            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->DataFormat,
                &DataRangeVideoToVerify->DataRange,
                sizeof (KSDATARANGE));

            DataFormatVideoInfoHeaderOut->DataFormat.FormatSize = FormatSize;

            // Copy over the callers requested VIDEOINFOHEADER

            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->VideoInfoHeader,
                &DataRangeVideoToVerify->VideoInfoHeader,
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader));

            // Calculate biSizeImage for this request, and put the result in both
            // the biSizeImage field of the bmiHeader AND in the SampleSize field
            // of the DataFormat.
            //
            // Note that for compressed sizes, this calculation will probably not
            // be just width * height * bitdepth

            DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader.biSizeImage =
                DataFormatVideoInfoHeaderOut->DataFormat.SampleSize =
                KS_DIBSIZE(DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader);

            //
            // TODO Perform other validation such as cropping and scaling checks
            //

            break;

        } // End of VIDEOINFOHEADER specifier

#ifndef TOSHIBA
        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&DataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {

            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;
            FormatSize = sizeof (KS_DATARANGE_ANALOGVIDEO);

            if (OnlyWantsSize) {
                break;
            }

            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            RtlCopyMemory(
                IntersectInfo->DataFormatBuffer,
                DataRangeVideo,
                sizeof (KS_DATARANGE_ANALOGVIDEO));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;

        } // End of KS_ANALOGVIDEOINFO specifier
#endif//TOSHIBA

        else {
            pSrb->Status = STATUS_NO_MATCH;
            return FALSE;
        }

    } // End of loop on all formats for this stream

    if (OnlyWantsSize) {
        *(PULONG) IntersectInfo->DataFormatBuffer = FormatSize;
        pSrb->ActualBytesTransferred = sizeof(ULONG);
        return TRUE;
    }
    pSrb->ActualBytesTransferred = FormatSize;
    return TRUE;
}























=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef TOSHIBA
// ------------------------------------------------------------------------
// Property set for the Video Crossbar
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(XBarProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),     // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),     // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAN_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_PININFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),  // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

};

// ------------------------------------------------------------------------
// Property set for the TVTuner
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(TVTunerProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinProperty
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_FREQUENCY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_INPUT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinProperty
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinProperty
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )
};


// ------------------------------------------------------------------------
// Property set for the TVAudio
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(TVAudioProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        FALSE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};
#endif//TOSHIBA

// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
#ifdef  TOSHIBA
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] =
{
    {
        256 / 1,            // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        255                 // Maximum in (IRE * 100) units
    }
};

static const ULONG BrightnessDefault = 128;
#else //TOSHIBA
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] =
{
    {
        10000 / 10,         // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        10000               // Maximum in (IRE * 100) units
    }
};

static const ULONG BrightnessDefault = 5000;
#endif//TOSHIBA

static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
            sizeof (BrightnessDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault,
    }
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
#ifdef  TOSHIBA
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] =
{
    {
        256 / 1,            // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        255                 // Maximum in (gain * 100) units
    }
};

static const ULONG ContrastDefault = 128;
#else //TOSHIBA
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] =
{
    {
        10000 / 256,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        10000               // Maximum in (gain * 100) units
    }
};

static const ULONG ContrastDefault = 5000;
#endif//TOSHIBA

static KSPROPERTY_MEMBERSLIST ContrastMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ContrastRangeAndStep),
            SIZEOF_ARRAY (ContrastRangeAndStep),
            0
        },
        (PVOID) ContrastRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ContrastDefault),
            sizeof (ContrastDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ContrastDefault,
    }
};

static KSPROPERTY_VALUES ContrastValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ContrastMembersList),
    ContrastMembersList
};

#ifdef  TOSHIBA
// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG HueRangeAndStep [] =
{
    {
        256 / 1,            // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        255                 // Maximum in (IRE * 100) units
    }
};

static const ULONG HueDefault = 128;

static KSPROPERTY_MEMBERSLIST HueMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (HueRangeAndStep),
            SIZEOF_ARRAY (HueRangeAndStep),
            0
        },
        (PVOID) HueRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (HueDefault),
            sizeof (HueDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &HueDefault,
    }
};

static KSPROPERTY_VALUES HueValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (HueMembersList),
    HueMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] =
{
    {
        256 / 1,            // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        255                 // Maximum in (gain * 100) units
    }
};

static const ULONG SaturationDefault = 128;

static KSPROPERTY_MEMBERSLIST SaturationMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SaturationRangeAndStep),
            SIZEOF_ARRAY (SaturationRangeAndStep),
            0
        },
        (PVOID) SaturationRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SaturationDefault),
            sizeof (SaturationDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SaturationDefault,
    }
};

static KSPROPERTY_VALUES SaturationValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SaturationMembersList),
    SaturationMembersList
};
#endif//TOSHIBA

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ColorEnableRangeAndStep [] =
{
    {
        1,                  // SteppingDelta (this is a BOOL)
        0,                  // Reserved
        0,                  // Minimum
        1                   // Maximum
    }
};

#ifdef  TOSHIBA
static const ULONG ColorEnableDefault = 0;
#else //TOSHIBA
static const ULONG ColorEnableDefault = 1;
#endif//TOSHIBA

static KSPROPERTY_MEMBERSLIST ColorEnableMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ColorEnableRangeAndStep),
            SIZEOF_ARRAY (ColorEnableRangeAndStep),
            0
        },
        (PVOID) ColorEnableRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ColorEnableDefault),
            sizeof (ColorEnableDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ColorEnableDefault,
    }
};

static KSPROPERTY_VALUES ColorEnableValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ColorEnableMembersList),
    ColorEnableMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_CONTRAST,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ContrastValues,                        // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
#ifdef  TOSHIBA
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_HUE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &HueValues,                             // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SATURATION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SaturationValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
#endif//TOSHIBA
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ColorEnableValues,                     // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

#ifndef TOSHIBA
// ------------------------------------------------------------------------
// Property set for CameraControl
// ------------------------------------------------------------------------

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ZoomRangeAndStep [] =
{
    {
        10000 / 10,         // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum
        10000               // Maximum
    }
};

static const ULONG ZoomDefault = 5000;

static KSPROPERTY_MEMBERSLIST ZoomMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ZoomRangeAndStep),
            SIZEOF_ARRAY (ZoomRangeAndStep),
            0
        },
        (PVOID) ZoomRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ZoomDefault),
            sizeof (ZoomDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ZoomDefault,
    }
};

static KSPROPERTY_VALUES ZoomValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ZoomMembersList),
    ZoomMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG FocusRangeAndStep [] =
{
    {
        10000 / 256,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum
        10000               // Maximum
    }
};

static const ULONG FocusDefault = 5000;

static KSPROPERTY_MEMBERSLIST FocusMembersList [] =
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (FocusRangeAndStep),
            SIZEOF_ARRAY (FocusRangeAndStep),
            0
        },
        (PVOID) FocusRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (FocusDefault),
            sizeof (FocusDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &FocusDefault,
    }
};

static KSPROPERTY_VALUES FocusValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (FocusMembersList),
    FocusMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(CameraControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_ZOOM,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &ZoomValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_FOCUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &FocusValues,                           // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for AnalogVideoDecoder
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(AnalogVideoDecoder)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_VCR_TIMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};
#endif//TOSHIBA

#ifndef TOSHIBA // '98-12-10 Deleted, for Bug-Report 253534
// ------------------------------------------------------------------------
// Property set for VideoControl
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSMULTIPLE_ITEM),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VideoCompression
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamCompressionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_GETINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S),// MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};
#endif//TOSHIBA

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
#ifdef  TOSHIBA
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0,
        NULL
    ),
#else //TOSHIBA // '98-12-10 Moved, for Bug-Report 253534
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOCONTROL,
        SIZEOF_ARRAY(VideoControlProperties),
        VideoControlProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOCOMPRESSION,             // Set
        SIZEOF_ARRAY(VideoStreamCompressionProperties), // PropertiesCount
        VideoStreamCompressionProperties,               // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
//#else //TOSHIBA  '98-12-10 Moved, for Bug-Report 253534
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_CROSSBAR,             // Set
        SIZEOF_ARRAY(XBarProperties),           // PropertiesCount
        XBarProperties,                         // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_TUNER,
        SIZEOF_ARRAY(TVTunerProperties),
        TVTunerProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_TVAUDIO,
        SIZEOF_ARRAY(TVAudioProperties),
        TVAudioProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_CAMERACONTROL,
        SIZEOF_ARRAY(CameraControlProperties),
        CameraControlProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOCONTROL,
        SIZEOF_ARRAY(VideoControlProperties),
        VideoControlProperties,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEODECODER,
        SIZEOF_ARRAY(AnalogVideoDecoder),
        AnalogVideoDecoder,
        0,
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOCOMPRESSION,             // Set
        SIZEOF_ARRAY(VideoStreamCompressionProperties), // PropertiesCount
        VideoStreamCompressionProperties,               // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
#endif//TOSHIBA

};

#define NUMBER_OF_ADAPTER_PROPERTY_SETS (SIZEOF_ARRAY (AdapterPropertyTable))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capstrm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPSTRM_H__
#define __CAPSTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


KSPIN_MEDIUM StandardMedium = {
    STATIC_KSMEDIUMSETID_Standard,
    0, 0
};

// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef enum {
    STREAM_Capture,
#ifndef TOSHIBA
    STREAM_Preview,
    STREAM_AnalogVideoInput
#endif//TOSHIBA
};

// ------------------------------------------------------------------------
// Property sets for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,             // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

#define D_X 320
#define D_Y 240

#ifdef  TOSHIBA
static  KS_DATARANGE_VIDEO StreamFormatYVU9_Capture =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        (D_X * D_Y * 9)/8,                      // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        FOURCC_YVU9, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,  //MEDIASUBTYPE_YVU9
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
#if 1
        KS_AnalogVideo_None,    // VideoStandard
#else
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
#endif
        640,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        640,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        2,              // CropGranularityX, granularity of cropping size
        2,              // CropGranularityY
        2,              // CropAlignX, alignment of cropping rect
        2,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        640, 480,       // MaxOutputSize, largest  bitmap stream can produce
        16,             // OutputGranularityX, granularity of output bitmap size
        4,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        2,              // ShrinkTapsX
        2,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        30 * 160 * 120 * 9,  // MinBitsPerSecond;
        30 * 640 * 480 * 9   // MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource;
        0,0,0,0,                            // RECT  rcTarget;
        D_X * D_Y * 9 / 8 * 30,             // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        9,                                  // WORD  biBitCount;
        FOURCC_YVU9,                        // DWORD biCompression;
        D_X * D_Y * 9 / 8,                  // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};

static  KS_DATARANGE_VIDEO StreamFormatYUV12_Capture =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        (D_X * D_Y * 12)/8,                     // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        FOURCC_YUV12, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, //MEDIASUBTYPE_YUV12
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
#if 1
        KS_AnalogVideo_None,    // VideoStandard
#else
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
#endif
        640,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        640,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        2,              // CropGranularityX, granularity of cropping size
        2,              // CropGranularityY
        2,              // CropAlignX, alignment of cropping rect
        2,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        640, 480,       // MaxOutputSize, largest  bitmap stream can produce
        16,             // OutputGranularityX, granularity of output bitmap size
        4,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        2,              // ShrinkTapsX
        2,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        30 * 160 * 120 * 12, // MinBitsPerSecond;
        30 * 640 * 480 * 12  // MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource;
        0,0,0,0,                            // RECT  rcTarget;
        D_X * D_Y * 12 / 8 * 30,            // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        12,                                 // WORD  biBitCount;
        FOURCC_YUV12,                       // DWORD biCompression;
        D_X * D_Y * 12 / 8,                 // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};
#else //TOSHIBA
static  KS_DATARANGE_VIDEO StreamFormatRGB24Bpp_Capture =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 3,                          // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70, //MEDIASUBTYPE_RGB24,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX
        0,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource;
        0,0,0,0,                            // RECT  rcTarget;
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240


static  KS_DATARANGE_VIDEO StreamFormatUYU2_Capture =
{
    // KSDATARANGE
    {
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, //MEDIASUBTYPE_UYVY,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX
        0,              // ShrinkTapsY
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource;
        0,0,0,0,                            // RECT  rcTarget;
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};
#endif//TOSHIBA

#undef D_X
#undef D_Y

#ifndef TOSHIBA
static  KS_DATARANGE_ANALOGVIDEO StreamFormatAnalogVideo =
{
    // KS_DATARANGE_ANALOGVIDEO
    {
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;
        0, 0, 720, 480,         // rcTarget;
        720,                    // dwActiveWidth;
        480,                    // dwActiveHeight;
        0,                      // REFERENCE_TIME  AvgTimePerFrame;
    }
};
#endif//TOSHIBA


//---------------------------------------------------------------------------
//  STREAM_Capture Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT Stream0Formats[] =
{
#ifdef  TOSHIBA
    (PKSDATAFORMAT) &StreamFormatYUV12_Capture,
    (PKSDATAFORMAT) &StreamFormatYVU9_Capture,
#else //TOSHIBA
    (PKSDATAFORMAT) &StreamFormatRGB24Bpp_Capture,
    (PKSDATAFORMAT) &StreamFormatUYU2_Capture,
#endif//TOSHIBA
};
#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))

#ifndef TOSHIBA
//---------------------------------------------------------------------------
//  STREAM_Preview Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT Stream1Formats[] =
{
#ifdef  TOSHIBA
    (PKSDATAFORMAT) &StreamFormatYUV12_Capture,
    (PKSDATAFORMAT) &StreamFormatYVU9_Capture,
#else //TOSHIBA
    (PKSDATAFORMAT) &StreamFormatRGB24Bpp_Capture,
    (PKSDATAFORMAT) &StreamFormatUYU2_Capture,
#endif//TOSHIBA
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------
//  STREAM_AnalogVideoInput Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT Stream2Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatAnalogVideo,
};
#define NUM_STREAM_2_FORMATS (SIZEOF_ARRAY (Stream2Formats))
#endif//TOSHIBA

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static  ALL_STREAM_INFO Streams [] =
{
  // -----------------------------------------------------------------
  // STREAM_Capture
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_0_FORMATS,                   // NumberOfFormatArrayEntries
    Stream0Formats,                         // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET) VideoStreamProperties,// StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_CAPTURE,        // Category
    (GUID *) &PINNAME_VIDEO_CAPTURE,        // Name
    1,                                      // MediumsCount
    &StandardMedium,                        // Mediums
        FALSE,                                                                  // BridgeStream
    },

    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    0,                                      // StreamNumber
    0,                                      // HwStreamExtension
    VideoReceiveDataPacket,                 // HwReceiveDataPacket
    VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    NULL,                                   // HwDeviceExtension
    sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace
    FALSE,                                  // Allocator
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
#ifndef TOSHIBA
 },
 // -----------------------------------------------------------------
 // STREAM_Preview
 // -----------------------------------------------------------------
 {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
    Stream1Formats,                         // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET) VideoStreamProperties,// StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_PREVIEW,        // Category
    (GUID *) &PINNAME_VIDEO_PREVIEW,        // Name
    1,                                      // MediumsCount
    &StandardMedium,                        // Mediums
        FALSE,                                                                  // BridgeStream
    },

    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    1,                                      // StreamNumber
    0,                                      // HwStreamExtension
    VideoReceiveDataPacket,                 // HwReceiveDataPacket
    VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    0,                                      // HwDeviceExtension
    sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace
    FALSE,                                  // Allocator
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
 },
 // -----------------------------------------------------------------
 // STREAM_AnalogVideoInput
 // -----------------------------------------------------------------
 {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_IN,                      // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_2_FORMATS,                   // NumberOfFormatArrayEntries
    Stream2Formats,                         // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    0,                                      // NumStreamPropArrayEntries
    0,                                      // StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Category
    (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Name
    1,                                      // MediumsCount
    &CrossbarMediums[9],                    // Mediums
        FALSE,                                                                  // BridgeStream
    },

    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    2,                                      // StreamNumber
    0,                                      // HwStreamExtension
    AnalogVideoReceiveDataPacket,           // HwReceiveDataPacket
    AnalogVideoReceiveCtrlPacket,           // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    0,                                      // HwDeviceExtension
    0,                                      // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace
    FALSE,                                  // Allocator
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    }
#endif//TOSHIBA
  }
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static const GUID Categories[] = {
#ifdef  TOSHIBA
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
#else //TOSHIBA
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_KSCATEGORY_TVTUNER,
    STATIC_KSCATEGORY_CROSSBAR,
    STATIC_KSCATEGORY_TVAUDIO
#endif//TOSHIBA
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)


static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,               // CategoriesCount
    (GUID*) &Categories,                // Categories
    0,                                  // TopologyNodesCount
    NULL,                               // TopologyNodes
    0,                                  // TopologyConnectionsCount
    NULL,                               // TopologyConnections
    NULL,                               // TopologyNodesNames
    0,                                  // Reserved
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __CAPSTRM_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capvideo.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "ntstatus.h"
#ifdef  TOSHIBA
#include "bert.h"

extern  ULONG   CurrentOSType;
#ifdef  _FPS_COUNT_
ULONG   InterruptCounter = 0;
ULONG   FrameCounter = 0;
#endif//_FPS_COUNT_
#endif//TOSHIBA

//==========================================================================;
// General queue management routines
//==========================================================================;

/*
** AddToListIfBusy ()
**
**   Grabs a spinlock, checks the busy flag, and if set adds an SRB to a queue
**
** Arguments:
**
**   pSrb - Stream request block
**
**   SpinLock - The spinlock to use when checking the flag
**
**   BusyFlag - The flag to check
**
**   ListHead - The list onto which the Srb will be added if the busy flag is set
**
** Returns:
**
**   The state of the busy flag on entry.  This will be TRUE if we're already
**   processing an SRB, and FALSE if no SRB is already in progress.
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    )
{
    KIRQL                       Irql;
    PSRB_EXTENSION              pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

    KeAcquireSpinLock (SpinLock, &Irql);

    // If we're already processing another SRB, add this current request
    // to the queue and return TRUE

    if (*BusyFlag == TRUE) {
        // Save the SRB pointer away in the SRB Extension
        pSrbExt->pSrb = pSrb;
        InsertTailList(ListHead, &pSrbExt->ListEntry);
        KeReleaseSpinLock(SpinLock, Irql);
        return TRUE;
    }

    // Otherwise, set the busy flag, release the spinlock, and return FALSE

    *BusyFlag = TRUE;
    KeReleaseSpinLock(SpinLock, Irql);

    return FALSE;
}

/*
** RemoveFromListIfAvailable ()
**
**   Grabs a spinlock, checks for an available SRB, and removes it from the list
**
** Arguments:
**
**   &pSrb - where to return the Stream request block if available
**
**   SpinLock - The spinlock to use
**
**   BusyFlag - The flag to clear if the list is empty
**
**   ListHead - The list from which an SRB will be removed if available
**
** Returns:
**
**   TRUE if an SRB was removed from the list
**   FALSE if the list is empty
**
** Side Effects:  none
*/

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    )
{
    KIRQL                       Irql;

    KeAcquireSpinLock (SpinLock, &Irql);

    //
    // If the queue is now empty, clear the busy flag, and return
    //
    if (IsListEmpty(ListHead)) {
        *BusyFlag = FALSE;
        KeReleaseSpinLock(SpinLock, Irql);
        return FALSE;
    }
    //
    // otherwise extract the SRB
    //
    else {
        PUCHAR          ptr;
        PSRB_EXTENSION  pSrbExt;

        ptr = (PUCHAR)RemoveHeadList(ListHead);
        *BusyFlag = TRUE;
        KeReleaseSpinLock(SpinLock, Irql);
        // Get the SRB out of the SRB extension and return it
        pSrbExt = (PSRB_EXTENSION) (((PUCHAR) ptr) -
                     FIELDOFFSET(SRB_EXTENSION, ListEntry));
        *pSrb = pSrbExt->pSrb;
    }
    return TRUE;
}

//==========================================================================;
// Routines for managing the SRB queue on a per stream basis
//==========================================================================;

/*
** VideoQueueAddSRB ()
**
**   Adds a stream data SRB to a stream queue.  The queue is maintained in a
**   first in, first out order.
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoQueueAddSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    KIRQL                   oldIrql;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    // Save the SRB pointer in the IRP so we can use the IRPs
    // ListEntry to maintain a doubly linked list of pending
    // requests

    pSrb->Irp->Tail.Overlay.DriverContext[0] = pSrb;

    InsertTailList (
                &pHwDevExt->StreamSRBList[StreamNumber],
                &pSrb->Irp->Tail.Overlay.ListEntry);

    // Increment the count of outstanding SRBs in this queue
    pHwDevExt->StreamSRBListSize[StreamNumber]++;

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

}

/*
** VideoQueueRemoveSRB ()
**
**   Removes a stream data SRB from a stream queue
**
** Arguments:
**
**   pHwDevExt - Device Extension
**
**   StreamNumber - Index of the stream
**
** Returns: SRB or NULL
**
** Side Effects:  none
*/

PHW_STREAM_REQUEST_BLOCK
STREAMAPI
VideoQueueRemoveSRB (
    PHW_DEVICE_EXTENSION pHwDevExt,
    int StreamNumber
    )
{
    PUCHAR ptr;
    PIRP pIrp;
    PHW_STREAM_REQUEST_BLOCK pSrb = NULL;
    KIRQL oldIrql;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    //
    // Get the SRB out of the IRP out of the pending list
    //
    if (!IsListEmpty (&pHwDevExt->StreamSRBList[StreamNumber])) {

        ptr = (PUCHAR) RemoveHeadList(
                         &pHwDevExt->StreamSRBList[StreamNumber]);

        pIrp = (PIRP) (((PUCHAR) ptr) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        // Decrement the count of SRBs in this queue
        pHwDevExt->StreamSRBListSize[StreamNumber]--;

    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    return pSrb;
}

/*
** VideoQueueCancelAllSRBs()
**
**    In case of a client crash, this empties the stream queue when the stream closes
**
** Arguments:
**
**    pStrmEx - pointer to the stream extension
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoQueueCancelAllSRBs (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PUCHAR                      ptr;
    PIRP                        pIrp;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    KIRQL                       oldIrql;

    if (pStrmEx->KSState != KSSTATE_STOP) {

        KdPrint(("TsbVcap: ERROR Cleanup without being in the stopped state\n"));
        // May need to force the device to a stopped state here
        // may need to disable interrupts here !
    }

    //
    // The stream class will cancel all outstanding IRPs for us
    // (but only if we've set TurnOffSynchronization = FALSE)
    //

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    //
    // Get the SRB out of the IRP out of the pending list
    //
    while (!IsListEmpty (&pHwDevExt->StreamSRBList[StreamNumber])) {

        ptr = (PUCHAR) RemoveHeadList(
                         &pHwDevExt->StreamSRBList[StreamNumber]);

        pIrp = (PIRP) (((PUCHAR) ptr) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        // Decrement the count of SRBs in this queue
        pHwDevExt->StreamSRBListSize[StreamNumber]--;

        //
        // Make the length zero, and status cancelled
        //

        pSrb->CommandData.DataBufferArray->DataUsed = 0;
        pSrb->Status = STATUS_CANCELLED;

        KdPrint(("TsbVcap: VideoQueueCancelALLSRBs FOUND Srb=%x\n", pSrb));

        CompleteStreamSRB (pSrb);

    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    KdPrint(("TsbVcap: VideoQueueCancelAll\n"));

}

/*
** VideoQueueCancelOneSRB()
**
**    Called when cancelling a particular SRB
**
** Arguments:
**
**    pStrmEx - pointer to the stream extension
**
**    pSRBToCancel - pointer to the SRB
**
** Returns:
**
**    TRUE if the SRB was found in this queue
**
** Side Effects:  none
*/

BOOL
STREAMAPI
VideoQueueCancelOneSRB (
    PSTREAMEX pStrmEx,
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    KIRQL                       oldIrql;
    BOOL                        Found = FALSE;
    PIRP                        pIrp;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    PLIST_ENTRY                 Entry;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    Entry = pHwDevExt->StreamSRBList[StreamNumber].Flink;

    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //

    while (Entry != &pHwDevExt->StreamSRBList[StreamNumber]) {

        pIrp = (PIRP) (((PUCHAR) Entry) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        if (pSrb == pSrbToCancel) {
            RemoveEntryList(Entry);
            Found = TRUE;
            break;
        }

        Entry = Entry->Flink;
    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    if (Found) {

        pHwDevExt->StreamSRBListSize[StreamNumber]--;

        //
        // Make the length zero, and status cancelled
        //

        pSrbToCancel->CommandData.DataBufferArray->DataUsed = 0;
        pSrbToCancel->Status = STATUS_CANCELLED;

        CompleteStreamSRB (pSrbToCancel);

        KdPrint(("TsbVcap: VideoQueueCancelOneSRB FOUND Srb=%x\n", pSrb));

    }

    KdPrint(("TsbVcap: VideoQueueCancelOneSRB\n"));

    return Found;
}

/*
** VideoSetFormat()
**
**   Sets the format for a video stream.  This happens both when the
**   stream is first opened, and also when dynamically switching formats
**   on the preview pin.
**
**   It is assumed that the format has been verified for correctness before
**   this call is made.
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns:
**
**   TRUE if the format could be set, else FALSE
**
** Side Effects:  none
*/

BOOL
STREAMAPI
VideoSetFormat(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    UINT                    nSize;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
#ifdef  TOSHIBA
    ULONG                   ImageSize;
    ULONG                   ImageSizeY;
    ULONG                   ImageSizeU;
    ULONG                   ImageSizeV;
    ULONG                   ulFrameRate;
    DWORD                   dwAddr;
    UINT                    biWidth;
    UINT                    biHeight;
    int                     Counter;
    PSTREAMEX               pStrmExTmp;
#endif//TOSHIBA

    // -------------------------------------------------------------------
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    // -------------------------------------------------------------------

    if (IsEqualGUID (&pKSDataFormat->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

        PKS_DATAFORMAT_VIDEOINFOHEADER  pVideoInfoHeader =
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
        PKS_VIDEOINFOHEADER     pVideoInfoHdrRequested =
                    &pVideoInfoHeader->VideoInfoHeader;

        nSize = KS_SIZE_VIDEOHEADER (pVideoInfoHdrRequested);

        KdPrint(("TsbVcap: New Format\n"));
        KdPrint(("TsbVcap: pVideoInfoHdrRequested=%x\n", pVideoInfoHdrRequested));
        KdPrint(("TsbVcap: KS_VIDEOINFOHEADER size=%d\n", nSize));
        KdPrint(("TsbVcap: Width=%d  Height=%d  BitCount=%d\n",
                    pVideoInfoHdrRequested->bmiHeader.biWidth,
                    pVideoInfoHdrRequested->bmiHeader.biHeight,
                    pVideoInfoHdrRequested->bmiHeader.biBitCount));
        KdPrint(("TsbVcap: biSizeImage=%d\n",
                    pVideoInfoHdrRequested->bmiHeader.biSizeImage));

#ifdef  TOSHIBA // '98-12-10 Added, for Bug-Report 253563
        if ( (pVideoInfoHdrRequested->bmiHeader.biWidth  & 0x03) ||
             (pVideoInfoHdrRequested->bmiHeader.biHeight & 0x03) ) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }
#endif//TOSHIBA

#ifdef  TOSHIBA
        for (Counter = 0; Counter < MAX_TSBVCAP_STREAMS; Counter++) {
            if ( pStrmExTmp = (PSTREAMEX)pHwDevExt->pStrmEx[Counter] ) {
                // Check other opened stream format
                if ( pStrmExTmp->pVideoInfoHeader ) {
                    if ( (pStrmExTmp->pVideoInfoHeader->bmiHeader.biWidth !=
                          pVideoInfoHdrRequested->bmiHeader.biWidth) ||
                         (pStrmExTmp->pVideoInfoHeader->bmiHeader.biHeight !=
                          pVideoInfoHdrRequested->bmiHeader.biHeight) ||
                         (pStrmExTmp->pVideoInfoHeader->bmiHeader.biBitCount !=
                          pVideoInfoHdrRequested->bmiHeader.biBitCount) ) {
                        pSrb->Status = STATUS_INVALID_PARAMETER;
                        return FALSE;
                    }
                }
            }
        }
#endif//TOSHIBA

        //
        // If a previous format was in use, release the memory
        //
        if (pStrmEx->pVideoInfoHeader) {
            ExFreePool(pStrmEx->pVideoInfoHeader);
            pStrmEx->pVideoInfoHeader = NULL;
        }

        // Since the VIDEOINFOHEADER is of potentially variable size
        // allocate memory for it

        pStrmEx->pVideoInfoHeader = ExAllocatePool(NonPagedPool, nSize);

        if (pStrmEx->pVideoInfoHeader == NULL) {
            KdPrint(("TsbVcap: ExAllocatePool failed\n"));
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            return FALSE;
        }

        // Copy the VIDEOINFOHEADER requested to our storage
        RtlCopyMemory(
                pStrmEx->pVideoInfoHeader,
                pVideoInfoHdrRequested,
                nSize);

#ifdef  TOSHIBA
        if (pHwDevExt->NeedHWInit) HWInit(pHwDevExt);
        biWidth = pVideoInfoHdrRequested->bmiHeader.biWidth,
        biHeight = pVideoInfoHdrRequested->bmiHeader.biHeight,
        pHwDevExt->ulWidth = biWidth;
        pHwDevExt->ulHeight = biHeight;
        ImageSize = biWidth * biHeight;
        switch (pVideoInfoHdrRequested->bmiHeader.biCompression)
        {
            case FOURCC_YUV12:  // I420
                pHwDevExt->Format = FmtYUV12;
                pHwDevExt->YoffsetEven = 0;
                pHwDevExt->UoffsetEven = 0;
                pHwDevExt->VoffsetEven = 0;
                pHwDevExt->YoffsetOdd = 0;
                pHwDevExt->UoffsetOdd = 0;
                pHwDevExt->VoffsetOdd = 0;
                pHwDevExt->Ystride = 0;
                pHwDevExt->Ustride = 0;
                pHwDevExt->Vstride = 0;
                if ( CurrentOSType ) {  // NT5.0
                    ImageSizeY = ImageSize;
                    ImageSizeU = ImageSize / 4;
                    ImageSizeV = ImageSize / 4;
                } else {  // Win98
                    pHwDevExt->pCaptureBufferU = (PUCHAR)pHwDevExt->pCaptureBufferY + ImageSize;
                    pHwDevExt->pCaptureBufferV = (PUCHAR)pHwDevExt->pCaptureBufferU + ImageSize/4;
                    pHwDevExt->pPhysCaptureBufferU.LowPart = pHwDevExt->pPhysCaptureBufferY.LowPart + ImageSize;
                    pHwDevExt->pPhysCaptureBufferV.LowPart = pHwDevExt->pPhysCaptureBufferU.LowPart + ImageSize/4;
                }
                ImageSize = ImageSize * 12 / 8;
                break;
            case FOURCC_YVU9:   // YVU9
                pHwDevExt->Format = FmtYUV9;
                pHwDevExt->YoffsetEven = 0;
                pHwDevExt->UoffsetEven = 0;
                pHwDevExt->VoffsetEven = 0;
                pHwDevExt->YoffsetOdd = 0;
                pHwDevExt->UoffsetOdd = 0;
                pHwDevExt->VoffsetOdd = 0;
                pHwDevExt->Ystride = 0;
                pHwDevExt->Ustride = 0;
                pHwDevExt->Vstride = 0;
                if ( CurrentOSType ) {  // NT5.0
                    ImageSizeY = ImageSize;
                    ImageSizeU = ImageSize / 16;
                    ImageSizeV = ImageSize / 16;
                } else {  // Win98
                    pHwDevExt->pCaptureBufferV = (PUCHAR)pHwDevExt->pCaptureBufferY + ImageSize;
                    pHwDevExt->pCaptureBufferU = (PUCHAR)pHwDevExt->pCaptureBufferV + ImageSize/16;
                    pHwDevExt->pPhysCaptureBufferV.LowPart = pHwDevExt->pPhysCaptureBufferY.LowPart + ImageSize;
                    pHwDevExt->pPhysCaptureBufferU.LowPart = pHwDevExt->pPhysCaptureBufferV.LowPart + ImageSize/16;
                }
                ImageSize = ImageSize * 9 / 8;
                break;
            default:
                pSrb->Status = STATUS_INVALID_PARAMETER;
                return FALSE;
        }

        if (ImageSize > MAX_CAPTURE_BUFFER_SIZE) {
            if (pStrmEx->pVideoInfoHeader) {
                ExFreePool(pStrmEx->pVideoInfoHeader);
                pStrmEx->pVideoInfoHeader = NULL;
            }
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        ulFrameRate = pHwDevExt->uiFramePerSecond;
        if (pHwDevExt->BufferSize != ImageSize) {
            if ( CurrentOSType ) {  // NT5.0
                ULONG            ulSize;
                PVOID            VirtualAddress;
                PHYSICAL_ADDRESS LimitAddress;
                PHYSICAL_ADDRESS PhysicalAddress;

                pHwDevExt->IsRPSReady = FALSE;

                if ( pHwDevExt->pCaptureBufferY )
                {
                    // free frame buffer
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferY);
                    pHwDevExt->pCaptureBufferY = NULL;
                }
                if ( pHwDevExt->pCaptureBufferU )
                {
                    // free frame buffer
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferU);
                    pHwDevExt->pCaptureBufferU = NULL;
                }
                if ( pHwDevExt->pCaptureBufferV )
                {
                    // free frame buffer
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferV);
                    pHwDevExt->pCaptureBufferV = NULL;
                }

                // Allocate frame buffer

                LimitAddress.LowPart = 0xFFFFFFFF;
                LimitAddress.HighPart = 0;
                pHwDevExt->BufferSize = ImageSize;

                VirtualAddress = MmAllocateContiguousMemory(ImageSizeY, LimitAddress);
                if (VirtualAddress == 0)
                {
                    pHwDevExt->pPhysCaptureBufferY.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferY.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.HighPart = 0;
                    pHwDevExt->BufferSize = 0;
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                    return FALSE;
                }
                RtlZeroMemory(VirtualAddress, ImageSizeY);
                pHwDevExt->pCaptureBufferY = VirtualAddress;
                PhysicalAddress = MmGetPhysicalAddress(pHwDevExt->pCaptureBufferY);
                pHwDevExt->pPhysCaptureBufferY = PhysicalAddress;

                VirtualAddress = MmAllocateContiguousMemory(ImageSizeU, LimitAddress);
                if (VirtualAddress == 0)
                {
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferY);
                    pHwDevExt->pCaptureBufferY = NULL;
                    pHwDevExt->pPhysCaptureBufferY.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferY.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.HighPart = 0;
                    pHwDevExt->BufferSize = 0;
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                    return FALSE;
                }
                RtlZeroMemory(VirtualAddress, ImageSizeU);
                pHwDevExt->pCaptureBufferU = VirtualAddress;
                PhysicalAddress = MmGetPhysicalAddress(pHwDevExt->pCaptureBufferU);
                pHwDevExt->pPhysCaptureBufferU = PhysicalAddress;

                VirtualAddress = MmAllocateContiguousMemory(ImageSizeV, LimitAddress);
                if (VirtualAddress == 0)
                {
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferY);
                    pHwDevExt->pCaptureBufferY = NULL;
                    MmFreeContiguousMemory(pHwDevExt->pCaptureBufferU);
                    pHwDevExt->pCaptureBufferU = NULL;
                    pHwDevExt->pPhysCaptureBufferY.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferY.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferU.HighPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.LowPart = 0;
                    pHwDevExt->pPhysCaptureBufferV.HighPart = 0;
                    pHwDevExt->BufferSize = 0;
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                    return FALSE;
                }
                RtlZeroMemory(VirtualAddress, ImageSizeV);
                pHwDevExt->pCaptureBufferV = VirtualAddress;
                PhysicalAddress = MmGetPhysicalAddress(pHwDevExt->pCaptureBufferV);
                pHwDevExt->pPhysCaptureBufferV = PhysicalAddress;


                ulFrameRate = 15;
                pHwDevExt->dblBufflag = FALSE;
            } else {
                pHwDevExt->IsRPSReady = FALSE;
                pHwDevExt->BufferSize = ImageSize;
                if ((ImageSize * 2) > MAX_CAPTURE_BUFFER_SIZE) {
                    ulFrameRate = 15;
                    pHwDevExt->dblBufflag = FALSE;
                } else {
                    ulFrameRate = 30;
                    Alloc_TriBuffer(pHwDevExt);
                    pHwDevExt->dblBufflag = TRUE;
                }
            }
        }

        if(!ImageSetInputImageSize(pHwDevExt, &(pHwDevExt->SrcRect)))  // Insert 97-04-08(Tue)
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        if(!ImageSetOutputImageSize(pHwDevExt, pHwDevExt->ulWidth, pHwDevExt->ulHeight))     // Insert 97-04-08(Tue)
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }

        if (!BertFifoConfig(pHwDevExt, pHwDevExt->Format))
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return FALSE;
        }
        if(!ImageSetHueBrightnessContrastSat(pHwDevExt)){                                // Insert 97-04-08(Tue)
            return FALSE;
        }

        if ( pHwDevExt->ColorEnable ) {
            if ( get_AblFilter( pHwDevExt ) ) {
                set_filtering( pHwDevExt, TRUE );
            } else {
                set_filtering( pHwDevExt, FALSE );
                pHwDevExt->ColorEnable = 0;
            }
        } else {
            set_filtering( pHwDevExt, FALSE );
        }

    //
    // check the bounds for the frame rate
    //
        if (pHwDevExt->uiFramePerSecond != ulFrameRate)
        {
            pHwDevExt->uiFramePerSecond = ulFrameRate;
            pHwDevExt->IsRPSReady = FALSE;
        }

        if (pHwDevExt->IsRPSReady == FALSE)
        {
            dwAddr = (DWORD)pHwDevExt->pPhysRpsDMABuf.LowPart;
#if 0
            dwAddr = (dwAddr + 0x1FFF) & 0xFFFFE000;
#endif
            pHwDevExt->s_physDmaActiveFlag = dwAddr + 0X1860;

            if( pHwDevExt->dblBufflag ){
                    BertTriBuildNodes(pHwDevExt); // Add 97-04-08(Tue)
            }
            else{
                    BertBuildNodes(pHwDevExt);  // Add 97-04-08(Tue)
            }

            pHwDevExt->IsRPSReady = TRUE;
        }
#endif//TOSHIBA

    }

    // -------------------------------------------------------------------
    // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
    // -------------------------------------------------------------------
    else if (IsEqualGUID (&pKSDataFormat->Specifier,
                &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {

            //
            // AnalogVideo DataRange == DataFormat!
            //

            // For now, don't even cache this
            // TODO - Save the requested format
            //

            PKS_DATARANGE_ANALOGVIDEO pDataFormatAnalogVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) pSrb->CommandData.OpenFormat;
    }
    else {
        // Unknown format
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    return TRUE;
}

/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands on the output streams
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT((ULONG)pHwDevExt);

    KdPrint(("TsbVcap: Receiving Stream Data    SRB %8x, %x\n", pSrb, pSrb->Command));

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //

    switch (pSrb->Command){

    case SRB_READ_DATA:

        // Rule:
        // Only accept read requests when in either the Pause or Run
        // States.  If Stopped, immediately return the SRB.

        if (pStrmEx->KSState == KSSTATE_STOP) {

            CompleteStreamSRB (pSrb);

            break;
        }

#ifdef  TOSHIBA
        if (pHwDevExt->bVideoIn == FALSE) {

            CompleteStreamSRB (pSrb);

            break;
        }
#endif//TOSHIBA

        //
        // Put this read request on the pending queue
        //

        VideoQueueAddSRB (pSrb);

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP

        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        CompleteStreamSRB (pSrb);

    }  // switch (pSrb->Command)
}


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video output streams
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    BOOL                    Busy;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT((ULONG)pHwDevExt);

    KdPrint(("TsbVcap: Receiving Stream Control SRB %8x, %x\n", pSrb, pSrb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    while (TRUE) {

        //
        // Default to success
        //

        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_PROPOSE_DATA_FORMAT:
            KdPrint(("TsbVcap: Receiving SRB_PROPOSE_DATA_FORMAT  SRB %8x, StreamNumber= %d\n", pSrb, StreamNumber));
            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
                KdPrint(("TsbVcap: SRB_PROPOSE_DATA_FORMAT FAILED\n"));
            }
            break;

        case SRB_SET_DATA_FORMAT:
            KdPrint(("TsbVcap: SRB_SET_DATA_FORMAT\n"));
            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
                KdPrint(("TsbVcap: SRB_SET_DATA_FORMAT FAILED\n"));
            } else {
                VideoSetFormat (pSrb);
                KdPrint(("TsbVcap: SRB_SET_DATA_FORMAT SUCCEEDED\n"));
            }

            break;

        case SRB_GET_DATA_FORMAT:
            KdPrint(("TsbVcap: SRB_GET_DATA_FORMAT\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;


        case SRB_SET_STREAM_STATE:

            VideoSetState(pSrb);
            break;

        case SRB_GET_STREAM_STATE:

            VideoGetState(pSrb);
            break;

        case SRB_GET_STREAM_PROPERTY:

            VideoGetProperty(pSrb);
            break;

        case SRB_SET_STREAM_PROPERTY:

            VideoSetProperty(pSrb);
            break;

        case SRB_INDICATE_MASTER_CLOCK:

            //
            // Assigns a clock to a stream
            //

            VideoIndicateMasterClock (pSrb);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //


            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        CompleteStreamSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

        if (!Busy) {
            break;
        }
    }
}

#ifndef TOSHIBA
/*
** AnalogVideoReceiveDataPacket()
**
**   Receives AnalogVideo data packet commands on the input stream
**
** Arguments:
**
**   pSrb - Stream request block for the Analog Video stream.
**          This stream receives tuner control packets.
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
AnalogVideoReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PKSSTREAM_HEADER        pDataPacket = pSrb->CommandData.DataBufferArray;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT((ULONG)pHwDevExt);

    KdPrint(("TsbVcap: Receiving Tuner packet    SRB %8x, %x\n", pSrb, pSrb->Command));

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //

    switch (pSrb->Command){

    case SRB_WRITE_DATA:

        //
        // This data packet contains the channel change information
        // passed on the AnalogVideoIn stream.  Devices which support
        // VBI data streams need to pass this info on their output pins.
        //

        if (pDataPacket->FrameExtent == sizeof (KS_TVTUNER_CHANGE_INFO)) {

            RtlCopyMemory(
                &pHwDevExt->TVTunerChangeInfo,
                pDataPacket->Data,
                sizeof (KS_TVTUNER_CHANGE_INFO));
        }

        CompleteStreamSRB (pSrb);

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //


        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        CompleteStreamSRB (pSrb);

    }  // switch (pSrb->Command)
}


/*
** AnalogVideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Analog Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
AnalogVideoReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    BOOL                    Busy;

    //
    // make sure we have a device extension and we are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT((ULONG)pHwDevExt);

    KdPrint(("TsbVcap: Receiving Analog Stream Control SRB %8x, %x\n", pSrb, pSrb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    while (TRUE) {
        //
        // Default to success
        //

        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_PROPOSE_DATA_FORMAT:
            KdPrint(("TsbVcap: Receiving SRB_PROPOSE_DATA_FORMAT  SRB %8x, StreamNumber= %d\n", pSrb, StreamNumber));

            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
            }
            break;

        case SRB_SET_STREAM_STATE:

            //
            // Don't use VideoSetState, since we don't want to start another
            // timer running
            //

            pStrmEx->KSState = pSrb->CommandData.StreamState;
            break;

        case SRB_GET_STREAM_STATE:

            VideoGetState(pSrb);
            break;

        case SRB_GET_STREAM_PROPERTY:

            VideoGetProperty(pSrb);
            break;

        case SRB_INDICATE_MASTER_CLOCK:

            //
            // Assigns a clock to a stream
            //

            VideoIndicateMasterClock (pSrb);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //


            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        CompleteStreamSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

        if (!Busy) {
            break;
        }
    }
}
#endif//TOSHIBA

/*
** CompleteStreamSRB ()
**
**   This routine is called when a packet is being completed.
**
** Arguments:
**
**   pSrb - pointer to the request packet to be completed
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
CompleteStreamSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    KdPrint(("TsbVcap: Completing Stream        SRB %8x\n", pSrb));

    StreamClassStreamNotification(
            StreamRequestComplete,
            pSrb->StreamObject,
            pSrb);
}


/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
//    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_NOT_IMPLEMENTED;
}


#ifdef  TOSHIBA
#ifdef  _FPS_COUNT_
VOID
STREAMAPI
VideoFpsOutputRoutine(
    IN PSTREAMEX pStrmEx
    )
{
    if (pStrmEx->KSState == KSSTATE_RUN) {
        DbgPrint("INT = %d FPS = %d\n", InterruptCounter, FrameCounter);
        InterruptCounter = 0;
        FrameCounter = 0;
    }
}

VOID
STREAMAPI
VideoTimerRoutine(
    PVOID Context
    )
{
    PSTREAMEX                   pStrmEx = ((PSTREAMEX)Context);
    PHW_DEVICE_EXTENSION        pHwDevExt = pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }

    // Capture a frame if it's time and we have a buffer

    VideoFpsOutputRoutine(pStrmEx);

    // Schedule the next timer event
    // Make it run at 2x the requested capture rate (which is in 100nS units)

    StreamClassScheduleTimer (
            pStrmEx->pStreamObject,     // StreamObject
            pHwDevExt,                  // HwDeviceExtension
            (ULONG) 1000000,            // Microseconds
            VideoTimerRoutine,          // TimerRoutine
            pStrmEx);                   // Context
}
#endif//_FPS_COUNT_
#else //TOSHIBA
/*
** VideoTimerRoutine()
**
**    A timer has been created based on the requested capture interval.
**    This is the callback routine for this timer event.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
**    Context - pointer to the stream extension
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoTimerRoutine(
    PVOID Context
    )
{
    PSTREAMEX                   pStrmEx = ((PSTREAMEX)Context);
    PHW_DEVICE_EXTENSION        pHwDevExt = pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }

    // Capture a frame if it's time and we have a buffer

    VideoCaptureRoutine(pStrmEx);

    // Schedule the next timer event
    // Make it run at 2x the requested capture rate (which is in 100nS units)

    StreamClassScheduleTimer (
            pStrmEx->pStreamObject,     // StreamObject
            pHwDevExt,                  // HwDeviceExtension
            (ULONG) (pStrmEx->pVideoInfoHeader->AvgTimePerFrame / 20), // Microseconds
            VideoTimerRoutine,          // TimerRoutine
            pStrmEx);                   // Context
}


/*
** VideoCaptureRoutine()
**
**    Routine to capture video frames based on a timer.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoCaptureRoutine(
    IN PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PKSSTREAM_HEADER        pDataPacket;
    PKS_FRAME_INFO          pFrameInfo;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }


    // Find out what time it is, if we're using a clock

    if (pStrmEx->hMasterClock ) {
        HW_TIME_CONTEXT TimeContext;

        TimeContext.HwDeviceExtension = pHwDevExt;
        TimeContext.HwStreamObject = pStrmEx->pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
                pStrmEx->hMasterClock,
                &TimeContext);

        pStrmEx->QST_StreamTime = TimeContext.Time;
        pStrmEx->QST_Now = TimeContext.SystemTime;

        if (pStrmEx->QST_NextFrame == 0) {
            pStrmEx->QST_NextFrame = pStrmEx->QST_StreamTime + pStrmEx->pVideoInfoHeader->AvgTimePerFrame;
        }

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        KdPrint(("TsbVcap:    Time=%16lx\n", TimeContext.Time));
        KdPrint(("TsbVcap: SysTime=%16lx\n", TimeContext.SystemTime));
#endif
    }


    // Only capture in the RUN state

    if (pStrmEx->KSState == KSSTATE_RUN) {

        //
        // Determine if it is time to capture a frame based on
        // how much time has elapsed since capture started.
        // If there isn't a clock available, then capture immediately.
        //

        if ((!pStrmEx->hMasterClock) ||
             (pStrmEx->QST_StreamTime >= pStrmEx->QST_NextFrame)) {

            PHW_STREAM_REQUEST_BLOCK pSrb;

            // Increment the picture count (usually this is VSYNC count)

            pStrmEx->FrameInfo.PictureNumber++;

            //
            // Get the next queue SRB (if any)
            //

            pSrb = VideoQueueRemoveSRB (
                            pHwDevExt,
                            StreamNumber);

            if (pSrb) {

                pDataPacket = pSrb->CommandData.DataBufferArray;
                pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

                //
                // Call the routine which synthesizes images
                //

                ImageSynth (pSrb,
                            pHwDevExt->VideoInputConnected,
                            pStrmEx->VideoControlMode & KS_VideoControlFlag_FlipHorizontal);

                // Set additional info fields about the data captured such as:
                //   Frames Captured
                //   Frames Dropped
                //   Field Polarity

                pStrmEx->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

                *pFrameInfo = pStrmEx->FrameInfo;

                // Init the flags to zero
                pDataPacket->OptionsFlags = 0;

                // Set the discontinuity flag if frames have been previously
                // dropped, and then reset our internal flag

                if (pStrmEx->fDiscontinuity) {
                    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    pStrmEx->fDiscontinuity = FALSE;
                }

                //
                // Return the timestamp for the frame
                //
                pDataPacket->PresentationTime.Numerator = 1;
                pDataPacket->PresentationTime.Denominator = 1;
                pDataPacket->Duration = pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

                //
                // if we have a master clock AND this is the capture stream
                //
                if (pStrmEx->hMasterClock && (StreamNumber == 0)) {

                    pDataPacket->PresentationTime.Time = pStrmEx->QST_StreamTime;
                    pDataPacket->OptionsFlags |=
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
                }
                else {
                    //
                    // no clock or the preview stream, so just mark the time as unknown
                    //
                    pDataPacket->PresentationTime.Time = 0;
                    // clear the timestamp valid flags
                    pDataPacket->OptionsFlags &=
                        ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                          KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
                }

                // Every frame we generate is a key frame (aka SplicePoint)
                // Delta frames (B or P) should not set this flag

                pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

                CompleteStreamSRB (pSrb);

            } // if we have an SRB

            else {

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // dropped frames

                pStrmEx->FrameInfo.DropCount++;

                // Set the (local) discontinuity flag
                // This will cause the next packet processed to have the
                //   KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag set.

                pStrmEx->fDiscontinuity = TRUE;

            }

            // Figure out when to capture the next frame
            pStrmEx->QST_NextFrame += pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

        } // endif time to capture a frame
    } // endif we're running
}
#endif//TOSHIBA


/*
** VideoSetState()
**
**    Sets the current state for a given stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX                   pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    KSSTATE                     PreviousState;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    //          and whether you're using the Stream class for synchronization
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    //
    // Remember the state we're transitioning away from
    //

    PreviousState = pStrmEx->KSState;

    //
    // Set the new state
    //

    pStrmEx->KSState = pSrb->CommandData.StreamState;

    switch (pSrb->CommandData.StreamState)

    {
    case KSSTATE_STOP:

        //
        // The stream class will cancel all outstanding IRPs for us
        // (but only if it is maintaining the queue ie. using Stream Class synchronization)
        // Since TsbVcap is not using Stream Class synchronization, we must clear the queue here

#ifdef  TOSHIBA
        if (pHwDevExt->bVideoIn == TRUE) {
            // disable the RPS_INT and field interrupts
            BertInterruptEnable(pHwDevExt, FALSE);
            BertDMAEnable(pHwDevExt, FALSE);
            // wait for the current data xfer to complete
//          if (!BertIsCAPSTATReady(pHwDevExt)) return FALSE;
            pHwDevExt->bVideoIn = FALSE;
        }
#endif//TOSHIBA

        VideoQueueCancelAllSRBs (pStrmEx);

        KdPrint(("TsbVcap: STATE Stopped, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_ACQUIRE:

        //
        // This is a KS only state, that has no correspondence in DirectShow
        //
        KdPrint(("TsbVcap: STATE Acquire, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_PAUSE:

        //
        // On a transition to pause from acquire or stop, start our timer running.
        //

        if (PreviousState == KSSTATE_ACQUIRE || PreviousState == KSSTATE_STOP) {

            // Zero the frame counters
            pStrmEx->FrameInfo.PictureNumber = 0;
            pStrmEx->FrameInfo.DropCount = 0;
            pStrmEx->FrameInfo.dwFrameFlags = 0;

#ifdef  TOSHIBA
#ifdef  _FPS_COUNT_
            FrameCounter = 0;
            InterruptCounter = 0;
            StreamClassScheduleTimer (
                    pSrb->StreamObject,         // StreamObject
                    pHwDevExt,                  // HwDeviceExtension
                    (ULONG) 1000000,            // Microseconds
                    VideoTimerRoutine,          // TimerRoutine
                    pStrmEx);                   // Context
#endif//_FPS_COUNT_
            if (!BertIsLocked(pHwDevExt))
            {
                pHwDevExt->NeedHWInit = TRUE;
            }
            pHwDevExt->bVideoIn = TRUE;
            // enable the RPS_INT and field interrupts
            BertInterruptEnable(pHwDevExt, TRUE);
            BertDMAEnable(pHwDevExt, TRUE);
        } else {
            // disable the RPS_INT and field interrupts
            BertInterruptEnable(pHwDevExt, FALSE);
            BertDMAEnable(pHwDevExt, FALSE);
            // wait for the current data xfer to complete
//          if (!BertIsCAPSTATReady(pHwDevExt)) return FALSE;
            pHwDevExt->bVideoIn = FALSE;
#else //TOSHIBA
            // Setup the next timer callback
            // Make it run at 2x the requested capture rate (which is in 100nS units)

            StreamClassScheduleTimer (
                    pSrb->StreamObject,                             // StreamObject
                    pHwDevExt,                                      // HwDeviceExtension
                    (ULONG) (pStrmEx->pVideoInfoHeader->AvgTimePerFrame / 20), // Microseconds
                    VideoTimerRoutine,                              // TimerRoutine
                    pStrmEx);                                       // Context
#endif//TOSHIBA
        }
        KdPrint(("TsbVcap: STATE Pause, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_RUN:

        //
        // Begin Streaming.
        //

        // Reset the discontinuity flag

        pStrmEx->fDiscontinuity = FALSE;

        // Setting the NextFrame time to zero will cause the value to be
        // reset from the stream time

        pStrmEx->QST_NextFrame = 0;

#ifdef  TOSHIBA
        if (pHwDevExt->bVideoIn == FALSE) {
            if (!BertIsLocked(pHwDevExt))
            {
                pHwDevExt->NeedHWInit = TRUE;
            }
            pHwDevExt->bVideoIn = TRUE;
            // enable the RPS_INT and field interrupts
            BertInterruptEnable(pHwDevExt, TRUE);
            BertDMAEnable(pHwDevExt, TRUE);
        }
#endif//TOSHIBA

        KdPrint(("TsbVcap: STATE Run, Stream=%d\n", StreamNumber));
        break;

    } // end switch (pSrb->CommandData.StreamState)
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    pSrb->CommandData.StreamState = pStrmEx->KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return STATUS_NO_DATA_DETECTED

    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }
}


/*
** VideoStreamGetConnectionProperty()
**
**    Gets the properties for a stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    // This property describes the allocator requirements for the stream
    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        if (pStrmEx->pVideoInfoHeader) {
            PKSALLOCATOR_FRAMING Framing =
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Framing->PoolType = PagedPool;
            Framing->Frames = 1;
            Framing->FrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
            Framing->FileAlignment = 0; // FILE_LONG_ALIGNMENT???;
            Framing->Reserved = 0;
            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        else {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }
        break;

    default:
        break;
    }
}

/*
** VideoStreamGetDroppedFramesProperty()
**
**    Gets dynamic information about the progress of the capture process.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoStreamGetDroppedFramesProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
        {
            PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames =
                (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

            pDroppedFrames->PictureNumber = pStrmEx->FrameInfo.PictureNumber;
            pDroppedFrames->DropCount = pStrmEx->FrameInfo.DropCount;
            pDroppedFrames->AverageFrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
        }
        break;

    default:
        break;
    }
}

//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    If this stream is not being used as the master clock, this function
**      is used to provide us with a handle to the clock to use when
**      requesting the current stream time.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    pStrmEx->hMasterClock = pSrb->CommandData.MasterClockHandle;
}

/*
** GetSystemTime ()
**
**    Returns the system time in 100 nS units
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

ULONGLONG
STREAMAPI
VideoGetSystemTime(
    )
{
    ULONGLONG ticks;
    ULONGLONG rate;

    ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

    //
    // convert from ticks to 100ns clock
    //

    ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ticks & 0x00000000FFFFFFFF) * 10000000 / rate;

    return(ticks);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\image.c ===
//
//              TOSHIBA CORPORATION PROPRIETARY INFORMATION
//     This software is supplied under the terms of a license agreement or
//     nondisclosure agreement with TOSHIBA Corporation and may not be copied
//     or disclosed except in accordance with the terms of that agreement.
//           Copyright (c) 1997 TOSHIBA Corporation. All Rights Reserved.
//
//  Workfile: IMAGE.C
//
//  Purpose:
//
//  Contents:
//

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "bert.h"
#include "Image.h"


//
// SetInputImageSize
//      Set Input Image Size
//      Set P_SKIP_REG, P_ISIZ_REG
//

BOOL SetInputImageSize(PHW_DEVICE_EXTENSION pHwDevExt, PRECT pRect)
{
        ULONG ulSkipLine;
        ULONG ulSkipPix;
        ULONG ulSrcHeight;
        ULONG ulSrcWidth;

        if((pHwDevExt->MaxRect.bottom < pRect->bottom) || (pHwDevExt->MaxRect.right < pRect->right)) { // Mod 97-04-09(Wed)
            return FALSE;
        }

        ulSkipLine = pRect->left & 0x000003ff;
        ulSkipPix = pRect->top & 0x000003ff;
        ulSrcHeight = (pRect->bottom - pRect->top) & 0x000003ff;
        ulSrcWidth = (pRect->right - pRect->left) & 0x000003ff;

        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_SKIP_REG, 0xfc00ffff, ulSkipLine << 16);
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_SKIP_REG, 0xfffffc00, ulSkipPix);

        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_ISIZ_REG, 0xfc00ffff, ulSrcHeight << 16);
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_ISIZ_REG, 0xfffffc00, ulSrcWidth);

        return TRUE;
}


//
// SetOutputImageSize
//      Set Output Image Size
//      Set P_OSIZ_REG
//

BOOL SetOutputImageSize(PHW_DEVICE_EXTENSION pHwDevExt,
                                       ULONG ulWidth,
                                       ULONG ulHeight
                                                )
{
        ULONG ulMaxWidth = pHwDevExt->MaxRect.right - pHwDevExt->MaxRect.left;
        ULONG ulMaxHeight = pHwDevExt->MaxRect.bottom - pHwDevExt->MaxRect.top;

        if((ulWidth <= ulMaxWidth) && (ulHeight <= ulMaxHeight)){       // Mod 97-04-09(Wed)
                ulWidth &= 0x000003ff;
                ulHeight &= 0x000003ff;
                ulHeight <<= 16;
                ReadModifyWriteRegUlong(pHwDevExt, BERT_P_OSIZ_REG, 0xfffffc00, ulWidth);
                ReadModifyWriteRegUlong(pHwDevExt, BERT_P_OSIZ_REG, 0xfc00ffff, ulHeight);
        }
        else{
                return FALSE;
        }
        return TRUE;
}


//
// SetLumiInfo
//      Set Luminance Info
//      Set P_LUMI_REG
//

BOOL SetLumiInfo(PHW_DEVICE_EXTENSION pHwDevExt,
                                ULONG ulContrast,
                                ULONG ulBrightness
                                 )
{
        if(ulContrast > 0xff){
                return FALSE;
        }
        if(ulBrightness > 0xff){
                return FALSE;
        }

        ulContrast >>= 1;       // 1/2
        ulContrast <<= 8;
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_LUMI_REG, 0xffff80ff, ulContrast);
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_LUMI_REG, 0xffffff00, ulBrightness);
        return TRUE;
}


//
// SetColorInfo
//      Set Color Info
//      Set P_COL_REG
//

BOOL SetColorInfo(PHW_DEVICE_EXTENSION pHwDevExt,   // Mod 97-04-12(Sat)
                                 ULONG ulHue,
                                 ULONG ulSaturation
                                  )
{
        ULONG   ulUFU, ulVFU, ulUFV, ulVFV;
        ULONG   ulUFUVFU, ulUFVVFV;
        long    lSatu;

        long sindata[256] = {
                -1, -1, -1, -1, -1, -1, -1, -1, -1,                             // 1/sin(-128~-120)     0~8
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-119~-110)     9~18
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-109~-100)     19~28
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-99~-90)       29~38
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-89~-80)       39~48
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-79~-70)       49~58
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-69~-60)       59~68
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                 // 1/sin(-59~-50)       69~78
                -1, -1, -1, -1, -1, -1, -1, -1, -2, -2,                 // 1/sin(-49~-40)       79~88
                -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,                 // 1/sin(-39~-30)       89~98
                -2, -2, -2, -2, -2, -2, -3, -3, -3, -3,                 // 1/sin(-29~-20)       99~108
                -3, -3, -3, -4, -4, -4, -4, -5, -5, -6,                 // 1/sin(-19~-10)       109~118
                -6, -7, -8, -10, -11, -14, -19, -29, -57,               // 1/sin(-9~-1)         119~127
                0,                                                                                              // 1/sin(0)                     128
                57, 29, 19, 14, 11, 10, 8, 7, 6, 6,                             // 1/sin(1~10)          129~138
                5, 5, 4, 4, 4, 4, 3, 3, 3, 3,                                   // 1/sin(11~20)         139~148
                3, 3, 3, 2, 2, 2, 2, 2, 2, 2,                                   // 1/sin(21~30)         149~158
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2,                                   // 1/sin(31~40)         159~168
                2, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(41~50)         169~178
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(51~60)         179~188
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(61~70)         189~198
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(71~80)         199~208
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(81~90)         209~218
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(91~100)        219~228
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(101~110)       229~238
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/sin(111~120)       239~248
                1, 1, 1, 1, 1, 1, 1                                                             // 1/sin(121~127)       249~255
        };
        long cosdata[256] = {
                -2, -2, -2, -2, -2, -2, -2, -2, -2,                             // 1/cos(-128~-120)     0~8
                -2, -2, -2, -2, -2, -2, -3, -3, -3, -3,                 // 1/cos(-119~-110)     9~18
                -3, -3, -3, -4, -4, -4, -4, -5, -5, -6,                 // 1/cos(-109~-100)     19~28
                -6, -7, -8, -10, -11, -14, -19, -29, -57,               // 1/cos(-99~-91)       29~37
                0,                                                                                              // 1/cos(-90)           38
                57, 29, 19, 14, 11, 10, 8, 7, 6, 6,                             // 1/cos(-89~-80)       39~48
                5, 5, 4, 4, 4, 4, 3, 3, 3, 3,                                   // 1/cos(-79~-70)       49~58
                3, 3, 3, 2, 2, 2, 2, 2, 2, 2,                                   // 1/cos(-69~-60)       59~68
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2,                                   // 1/cos(-59~-50)       69~78
                2, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(-49~-40)       79~88
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(-39~-30)       89~98
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(-29~-20)       99~108
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(-19~-10)       109~118
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(-9~0)          119~128
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(1~10)          129~138
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(11~20)         139~148
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(21~30)         149~158
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                   // 1/cos(31~40)         159~168
                1, 1, 1, 1, 1, 1, 1, 1, 2, 2,                                   // 1/cos(41~50)         169~178
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2,                                   // 1/cos(51~60)         179~188
                2, 2, 2, 2, 2, 2, 3, 3, 3, 3,                                   // 1/cos(61~70)         189~198
                3, 3, 3, 4, 4, 4, 4, 5, 5, 6,                                   // 1/cos(71~80)         199~208
                6, 7, 8, 10, 11, 14, 19, 29, 57,                                // 1/cos(81~89)         209~217
                0,                                                                                              // 1/cos(90)            218
                -57, -29, -19, -14, -11, -10, -8, -7, -6, -6,   // 1/cos(91~100)        219~228
                -5, -5, -4, -4, -4, -4, -3, -3, -3, -3,                 // 1/cos(101~110)       229~238
                -3, -3, -3, -2, -2, -2, -2, -2, -2, -2,                 // 1/cos(111~120)       239~248
                -2, -2, -2, -2, -2, -2, -2                                              // 1/cos(121~127)       249~255
        };

        if(ulHue > 0xff){
                return FALSE;
        }
        if(ulSaturation > 0xff){
                return FALSE;
        }
        lSatu = ulSaturation / 2;       // Mod 97-05-10(Sat)

        switch(ulHue){
                case 38:        // -90
                        ulUFU = 128;
                        ulVFU = lSatu + 128;
                        ulUFV = -lSatu + 127;
                        ulVFV = 128;
                        break;
                case 128:       // 0
                        ulUFU = lSatu + 128;
                        ulVFU = 128;
                        ulUFV = 128;
                        ulVFV = lSatu + 128;
                        break;
                case 218:       // 90
                        ulUFU = 128;
                        ulVFU = -lSatu + 127;
                        ulUFV = lSatu + 128;
                        ulVFV = 128;
                        break;
                default:
                        ulUFU = lSatu / cosdata[ulHue] + 128;
                        ulVFU = -lSatu / sindata[ulHue] + 128;
                        ulUFV = lSatu / sindata[ulHue] + 128;
                        ulVFV = lSatu / cosdata[ulHue] + 128;
                        break;
        }

        ulUFU &= 0xff;  // Add 97-04-19(Sat)
        ulVFU &= 0xff;
        ulUFV &= 0xff;
        ulVFV &= 0xff;

        ulUFUVFU = ulUFU << 24 | ulVFU << 16;
        ulUFVVFV = ulUFV << 8 | ulVFV;

        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_COL_REG, 0x0000ffff, ulUFUVFU);
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_COL_REG, 0xffff0000, ulUFVVFV);

        return TRUE;
}


//
// SetChgColInfo
//      Set ChangeColor Info
//      Set P_LUMI_REG
//

BOOL SetChgColInfo(PHW_DEVICE_EXTENSION pHwDevExt,
                                  ULONG ulChgCol
                                 )
{
        switch(ulChgCol){
                case IMAGE_CHGCOL_AVAIL:
                case IMAGE_CHGCOL_NOTAVAIL:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_LUMI_REG, 0xfffeffff, ulChgCol);
                        break;
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_LUMI_REG, 0xfffeffff, 0UL);
                        break;
        }

        return TRUE;
}


//
// SetVerticalFilterInfo
//      Set Vertical Filter Info
//      Set P_FILT_REG
//

BOOL SetVerticalFilterInfo(PHW_DEVICE_EXTENSION pHwDevExt,
                                          ULONG ulVFL
                                                   )
{
        switch(ulVFL){
                case IMAGE_VFL:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffeffff, ulVFL);  // Mod 97-04-14(Mon)
                        break;
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffeffff, 0UL);
                        break;
        }

        return TRUE;
}


//
// SetHorizontalFilterInfo
//      Set Horizontal Filter Info
//      Set P_FILT_REG
//

BOOL SetHorizontalFilterInfo(PHW_DEVICE_EXTENSION pHwDevExt,
                                            ULONG ulFL1,
                                            ULONG ulFL2,
                                            ULONG ulFL3,
                                            ULONG ulFL4
                                                         )
{
        switch(ulFL1){
                case IMAGE_FL_0:
                case IMAGE_FL_1:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffffff8, ulFL1);
                        break;
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffffff8, 0UL);
                        break;
        }
        switch(ulFL2){
                case IMAGE_FL_0:
                case IMAGE_FL_1:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xffffff8f, ulFL2 << 4);
                        break;
                case IMAGE_FL_2:
                case IMAGE_FL_3:
                case IMAGE_FL_4:
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xffffff8f, 0UL);
                        break;
        }
        switch(ulFL3){
                case IMAGE_FL_0:
                case IMAGE_FL_1:
                case IMAGE_FL_2:
                case IMAGE_FL_4:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffff8ff, ulFL3 << 8);
                        break;
                case IMAGE_FL_3:
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffff8ff, 0UL);
                        break;
        }
        switch(ulFL4){
                case IMAGE_FL_0:
                case IMAGE_FL_2:
                case IMAGE_FL_4:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xffff8fff, ulFL4 << 12);
                        break;
                case IMAGE_FL_1:
                case IMAGE_FL_3:
                default:
                        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xffff8fff, 0UL);
                        break;
        }

        return TRUE;
}


//
// ImageSetInputImageSize
//      Set Input Image Size
//      Set P_SKIP_REG, P_ISIZ_REG
//

BOOL ImageSetInputImageSize(PHW_DEVICE_EXTENSION pHwDevExt,
                                           PRECT pRect
                                                        )
{
        if(!SetInputImageSize(pHwDevExt, pRect)){
                return FALSE;
        }
        return TRUE;
}


//
// ImageSetOutputImageSize
//      Set Output Image Size
//      Set P_OSIZ_REG
//

BOOL ImageSetOutputImageSize(PHW_DEVICE_EXTENSION pHwDevExt,
                                            ULONG ulWidth,
                                            ULONG ulHeight
                                                         )
{
        if(!SetOutputImageSize(pHwDevExt, ulWidth, ulHeight)){
                return FALSE;
        }

        if(!ImageGetFilteringAvailable(pHwDevExt)){
                ImageFilterOFF(pHwDevExt);
        }
        else if(ImageGetFilterInfo(pHwDevExt)){          // Add 97-05-13(Tue)
                ImageFilterON(pHwDevExt);
        }

        return TRUE;
}


//
// ImageSetChangeColorAvail
//      Set/Reset CHGCOL Bit
//      Set P_LUMI_REG
//

BOOL ImageSetChangeColorAvail(PHW_DEVICE_EXTENSION pHwDevExt,
                                             ULONG ulChgCol
                                                          )
{
        if(!SetChgColInfo(pHwDevExt, ulChgCol)){
                return FALSE;
        }
        return TRUE;
}


//
// ImageSetHueBrightnessContrastSat
//      Set Color Info
//      Call SetLumiImfo, SetColorInfo
//

BOOL ImageSetHueBrightnessContrastSat(PHW_DEVICE_EXTENSION pHwDevExt) // Mod 97-04-08(Tue)
{
#ifdef  TOSHIBA
        if(!SetLumiInfo(pHwDevExt, pHwDevExt->Contrast, pHwDevExt->Brightness)){
                return FALSE;
        }
        if(!SetColorInfo(pHwDevExt, pHwDevExt->Hue, pHwDevExt->Saturation)){
                return FALSE;
        }
#else //TOSHIBA
        if(!SetLumiInfo(pHwDevExt, pHwDevExt->ulContrast, pHwDevExt->ulBrightness)){
                return FALSE;
        }
        if(!SetColorInfo(pHwDevExt, pHwDevExt->ulHue, pHwDevExt->ulSaturation)){
                return FALSE;
        }
#endif//TOSHIBA
        return TRUE;
}


//
// ImageSetFilterInfo
//      Set Filter Info
//      Set P_FILT_REG
//

BOOL ImageSetFilterInfo(PHW_DEVICE_EXTENSION pHwDevExt,
                                       ULONG                   ulVFL,
                                       ULONG                   ulFL1,
                                       ULONG                   ulFL2,
                                       ULONG                   ulFL3,
                                       ULONG                   ulFL4
                                                )
{
        if(!SetHorizontalFilterInfo(pHwDevExt, ulFL1, ulFL2, ulFL3, ulFL4)){
                return FALSE;
        }
        if(!SetVerticalFilterInfo(pHwDevExt, ulVFL)){
                return FALSE;
        }
        return TRUE;
}


//
// ImageFilterON
//
//      Set P_FILT_REG
//

BOOL ImageFilterON(PHW_DEVICE_EXTENSION pHwDevExt)
{
        ULONG   ulFL1, ulFL2, ulFL3, ulFL4;

        if(pHwDevExt->ulWidth <= 80){         // 0 < Width <= 80
                ulFL1 = IMAGE_FL_1;
                ulFL2 = IMAGE_FL_1;
                ulFL3 = IMAGE_FL_2;
                ulFL4 = IMAGE_FL_4;
        }
        else if((pHwDevExt->ulWidth > 80) && (pHwDevExt->ulWidth <= 160)){  // 80 < Width <= 160
                ulFL1 = IMAGE_FL_1;
                ulFL2 = IMAGE_FL_1;
                ulFL3 = IMAGE_FL_2;
                ulFL4 = IMAGE_FL_0;
        }
        else{                                           // 160 < Width
                ulFL1 = IMAGE_FL_1;
                ulFL2 = IMAGE_FL_1;
                ulFL3 = IMAGE_FL_0;
                ulFL4 = IMAGE_FL_0;
        }

        if(!SetHorizontalFilterInfo(pHwDevExt, ulFL1, ulFL2, ulFL3, ulFL4)){
                return FALSE;
        }
        if(!SetVerticalFilterInfo(pHwDevExt, IMAGE_VFL)){
                return FALSE;
        }
        return TRUE;
}


//
// ImageFilterOFF
//
//      Set P_FILT_REG
//

BOOL ImageFilterOFF(PHW_DEVICE_EXTENSION pHwDevExt)
{
        ReadModifyWriteRegUlong(pHwDevExt, BERT_P_FILT_REG, 0xfffe0000, 0UL);
        return TRUE;
}


//
// ImageGetFilterInfo
//      Get Filter Info
//

BOOL ImageGetFilterInfo(PHW_DEVICE_EXTENSION pHwDevExt)
{
        if(!ReadRegUlong(pHwDevExt, BERT_P_FILT_REG)){
                return FALSE;
        }
        return TRUE;
}


//
// ImageGetFilteringAvailable
//

BOOL ImageGetFilteringAvailable(PHW_DEVICE_EXTENSION pHwDevExt)
{
        ULONG ulISIZ, ulOSIZ;
        ULONG ulFL, ulFL1, ulFL2, ulFL3, ulFL4;

        ulISIZ = ReadRegUlong(pHwDevExt, BERT_P_ISIZ_REG);
        ulISIZ &= 0x3ff;
        ulOSIZ = ReadRegUlong(pHwDevExt, BERT_P_OSIZ_REG);
        ulOSIZ &= 0x3ff;
        ulFL = ReadRegUlong(pHwDevExt, BERT_P_FILT_REG);
        ulFL1 = ulFL & 0x7;
        ulFL2 = (ulFL >> 4) & 0x7;
        ulFL3 = (ulFL >> 8) & 0x7;
        ulFL4 = (ulFL >> 12) & 0x7;

        if((ulOSIZ > 400) || (ulOSIZ == 640)){
                return FALSE;
        }
        if((ulISIZ - ulOSIZ) < ((ulFL1 + ulFL2 + ulFL3 + ulFL4) * 2)){
                return FALSE;
        }
        return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\capprop.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file handles all adapter property sets
//


#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#ifdef  TOSHIBA
#include "bert.h"
#endif//TOSHIBA
#define DEFINE_MEDIUMS
#include "mediums.h"

#ifdef  TOSHIBA
ULONG
get_AblFilter (
    PHW_DEVICE_EXTENSION pHwDevExt
    )
{
    return( HW_ReadFilter( pHwDevExt, TRUE ) );
}

ULONG
get_filtering (
    PHW_DEVICE_EXTENSION pHwDevExt
    )
{
    return( HW_ReadFilter( pHwDevExt, FALSE ) );
}

VOID
set_filtering (
    PHW_DEVICE_EXTENSION pHwDevExt, BOOL bFlag
    )
{
    HW_SetFilter( pHwDevExt, bFlag );
}
#endif//TOSHIBA

// -------------------------------------------------------------------
// A few notes about property set handling
//
// Property sets used in TsbVcap are of two varieties, those that have
// default values, ranges, and stepping, such as VideoProcAmp and CameraControl,
// and those which don't have defaults and ranges, such as TVTuner and
// Crossbar.
//
// Default values and stepping are established by tables in capprop.h,
// no code is required to implement this other than initally creating the tables.
//
// Many of the property sets require the ability to modify a number
// of input parameters.  Since KS doesn't allow this inherently, you'll
// note that some property sets require copying the provided input parameters
// to the ouput parameter list, effectively creating a "read, modify, write"
// capability.  For this reason, the input and output parameter lists
// use identical structures.
//
// On an SRB_GET_DEVICE_PROPERTY, read-only input data to the driver is provided as:
//      pSrb->CommandData.PropertyInfo
//
// ... while the output data pointer is:
//      pSrb->CommandData.PropertyInfo.PropertyInfo
//
// -------------------------------------------------------------------


#ifndef TOSHIBA
// -------------------------------------------------------------------
// XBar pin definitions
// -------------------------------------------------------------------

typedef struct _XBAR_PIN_DESCRIPTION {
    ULONG       PinType;
    ULONG       SynthImageCommand;    // This driver simulates different inputs by synthesizing images
    ULONG       RelatedPinIndex;
    const KSPIN_MEDIUM *Medium;               // Describes hardware connectivity
} XBAR_PIN_DESCRIPTION, *PXBAR_PIN_DESCRIPTION;


XBAR_PIN_DESCRIPTION XBarInputPins[] = {

    // First list the video input pins, then the audio inputs, then the output pins
    // Note that audio pin index 6 is shared between two video inputs (index 1 and index 2)


    //    PinType                       SynthImageCommand                     RelatedPinIndex   Medium
    /*0*/ KS_PhysConn_Video_Tuner,         IMAGE_XFER_NTSC_EIA_100AMP_100SAT,    5,             &CrossbarMediums[0],
    /*1*/ KS_PhysConn_Video_Composite,     IMAGE_XFER_NTSC_EIA_75AMP_100SAT,     6,             &CrossbarMediums[1],
    /*2*/ KS_PhysConn_Video_SVideo,        IMAGE_XFER_BLACK,                     6,             &CrossbarMediums[2],
    /*3*/ KS_PhysConn_Video_Tuner,         IMAGE_XFER_WHITE,                     7,             &CrossbarMediums[3],
    /*4*/ KS_PhysConn_Video_Composite,     IMAGE_XFER_GRAY_INCREASING,           8,             &CrossbarMediums[4],

    /*5*/ KS_PhysConn_Audio_Tuner,         0,                                    0,             &CrossbarMediums[5],
    /*6*/ KS_PhysConn_Audio_Line,          0,                                    1,             &CrossbarMediums[6],
    /*7*/ KS_PhysConn_Audio_Tuner,         0,                                    3,             &CrossbarMediums[7],
    /*8*/ KS_PhysConn_Audio_Line,          0,                                    4,             &CrossbarMediums[8],

};
#define NUMBER_OF_XBAR_INPUTS       (SIZEOF_ARRAY (XBarInputPins))


XBAR_PIN_DESCRIPTION XBarOutputPins[] = {

    //    PinType                       SynthImageCommand                     RelatedPinIndex

    /*0*/ KS_PhysConn_Video_VideoDecoder,  0,                                    1,             &CrossbarMediums[9],
    /*1*/ KS_PhysConn_Audio_AudioDecoder,  0,                                    0,             &CrossbarMediums[10],
};
#define NUMBER_OF_XBAR_OUTPUTS      (SIZEOF_ARRAY (XBarOutputPins))

#define NUMBER_OF_XBAR_PINS_TOTAL   (NUMBER_OF_XBAR_INPUTS + NUMBER_OF_XBAR_OUTPUTS)


// -------------------------------------------------------------------
// XBar Property Set functions
// -------------------------------------------------------------------

/*
** AdapterSetCrossbarProperty ()
**
**    Handles Set operations on the Crossbar property set.
**      TsbVcap uses this to select an image to synthesize.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetCrossbarProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSPD->Property->Id;              // index of the property
    ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {
    case KSPROPERTY_CROSSBAR_ROUTE:                       //  W
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

        ASSERT (nS >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute,
                        pSPD->Property,
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));


        // Default to failure
        pRoute->CanRoute = 0;

        // if video
        if (pRoute->IndexOutputPin == 0) {
            if (pRoute->IndexInputPin <= 4) {
                pHwDevExt->VideoInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
        }
        // if audio
        else if (pRoute->IndexOutputPin == 1) {
            // Special case!  Audio Routing of (-1) means mute!!!
            if (pRoute->IndexInputPin == -1) {
                pHwDevExt->AudioInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
            else if (pRoute->IndexInputPin > 4 && pRoute->IndexInputPin <= 8) {
                pHwDevExt->AudioInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
        }

        // Somebody passed bogus data
        if (pRoute->CanRoute == 0) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }
    }
    break;


    default:
        TRAP
        break;
    }
}

/*
** AdapterGetCrossbarProperty ()
**
**    Handles Get operations on the Crossbar property set.
**      TsbVcap uses this to select an image to synthesize.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetCrossbarProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSPD->Property->Id;              // index of the property
    ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {

    case KSPROPERTY_CROSSBAR_CAPS:                  // R
    {
        PKSPROPERTY_CROSSBAR_CAPS_S  pCaps =
            (PKSPROPERTY_CROSSBAR_CAPS_S)pSPD->PropertyInfo;

        if (nS < sizeof (KSPROPERTY_CROSSBAR_CAPS_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pCaps,
                        pSPD->Property,
                        sizeof (KSPROPERTY_CROSSBAR_CAPS_S));

        pCaps->NumberOfInputs  = NUMBER_OF_XBAR_INPUTS;
        pCaps->NumberOfOutputs = NUMBER_OF_XBAR_OUTPUTS;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_CAPS_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_CAN_ROUTE:                   // R
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

        if (nS < sizeof (KSPROPERTY_CROSSBAR_ROUTE_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute,
                        pSPD->Property,
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Special case, audio output routed to (-1) means mute
        if (pRoute->IndexOutputPin == 1 && pRoute->IndexInputPin == -1) {
            pRoute->CanRoute = TRUE;
        }
        else if ((pRoute->IndexInputPin  >= NUMBER_OF_XBAR_INPUTS) ||
            (pRoute->IndexOutputPin >= NUMBER_OF_XBAR_OUTPUTS)) {

            pRoute->CanRoute = FALSE;
        }
        else if ((pRoute->IndexInputPin <= 4) &&
            (pRoute->IndexOutputPin == 0) ||
            (pRoute->IndexInputPin >= 5) &&
            (pRoute->IndexOutputPin == 1)) {

            // This driver allows any video input to connect to any video output
            // and any audio input to connect to any audio output
            pRoute->CanRoute = TRUE;
        }
        else {
            pRoute->CanRoute = FALSE;
        }
        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_ROUTE_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_PININFO:                     // R
    {
        PKSPROPERTY_CROSSBAR_PININFO_S  pPinInfo =
            (PKSPROPERTY_CROSSBAR_PININFO_S)pSPD->PropertyInfo;

        if (nS < sizeof (KSPROPERTY_CROSSBAR_PININFO_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pPinInfo,
                        pSPD->Property,
                        sizeof (KSPROPERTY_CROSSBAR_PININFO_S));

        if (pPinInfo->Direction == KSPIN_DATAFLOW_IN) {

            ASSERT (pPinInfo->Index < NUMBER_OF_XBAR_INPUTS);

            pPinInfo->PinType          = XBarInputPins[pPinInfo->Index].PinType;
            pPinInfo->RelatedPinIndex  = XBarInputPins[pPinInfo->Index].RelatedPinIndex;
            pPinInfo->Medium           = *XBarInputPins[pPinInfo->Index].Medium;
        }
        else {

            ASSERT (pPinInfo->Index < NUMBER_OF_XBAR_OUTPUTS);

            pPinInfo->PinType          = XBarOutputPins[pPinInfo->Index].PinType;
            pPinInfo->RelatedPinIndex  = XBarOutputPins[pPinInfo->Index].RelatedPinIndex;
            pPinInfo->Medium           = *XBarOutputPins[pPinInfo->Index].Medium;
        }

        pPinInfo->Medium.Id = 0; // (ULONG) pHwDevExt;  // Multiple instance support

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_PININFO_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_ROUTE:                   // R
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

        if (nS < sizeof (KSPROPERTY_CROSSBAR_ROUTE_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute,
                        pSPD->Property,
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Sanity check
        if (pRoute->IndexOutputPin >= NUMBER_OF_XBAR_OUTPUTS) {
            pRoute->CanRoute = FALSE;
        }
        // querying the the video output pin
        else if (pRoute->IndexOutputPin == 0) {
            pRoute->IndexInputPin = pHwDevExt->VideoInputConnected;
            pRoute->CanRoute = TRUE;
        }
        // querying the the audio output pin
        else if (pRoute->IndexOutputPin == 1) {
            pRoute->IndexInputPin = pHwDevExt->AudioInputConnected;
            pRoute->CanRoute = TRUE;
        }
        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_ROUTE_S);
    }
    break;


    default:
        TRAP
        break;
    }
}

// -------------------------------------------------------------------
// TVTuner Property Set functions
// -------------------------------------------------------------------

/*
** AdapterSetTunerProperty ()
**
**    Handles Set operations on the TvTuner property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetTunerProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {

    case KSPROPERTY_TUNER_MODE:
    {
         PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pSPD->Property;
         ASSERT (pMode->Mode == KSPROPERTY_TUNER_MODE_TV);
    }
    break;

    case KSPROPERTY_TUNER_STANDARD:
    {
        PKSPROPERTY_TUNER_STANDARD_S pStandard_S =
            (PKSPROPERTY_TUNER_STANDARD_S) pSPD->Property;
        pHwDevExt->VideoStandard = pStandard_S->Standard;
    }
    break;

    case KSPROPERTY_TUNER_FREQUENCY:
    {
        PKSPROPERTY_TUNER_FREQUENCY_S pFreq_S =
            (PKSPROPERTY_TUNER_FREQUENCY_S) pSPD->Property;
        pHwDevExt->Frequency = pFreq_S->Frequency;
    }
    break;

    case KSPROPERTY_TUNER_INPUT:
    {
        PKSPROPERTY_TUNER_INPUT_S pInput_S =
            (PKSPROPERTY_TUNER_INPUT_S) pSPD->Property;
        pHwDevExt->TunerInput = pInput_S->InputIndex;
    }
    break;

    default:
        TRAP
        break;
    }
}

/*
** AdapterGetTunerProperty ()
**
**    Handles Get operations on the TvTuner property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetTunerProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied
    PVOID pV = pSPD->PropertyInfo;              // pointer to the output data

    ASSERT (nS >= sizeof (LONG));

    switch (Id) {

    case KSPROPERTY_TUNER_CAPS:
    {
         PKSPROPERTY_TUNER_CAPS_S pCaps =
            (PKSPROPERTY_TUNER_CAPS_S)pSPD->Property;
         ASSERT (nS >= sizeof( KSPROPERTY_TUNER_CAPS_S ) );

         // now work with the output buffer
         pCaps =(PKSPROPERTY_TUNER_CAPS_S)pV;

         pCaps->ModesSupported = KSPROPERTY_TUNER_MODE_TV;

         pCaps->VideoMedium = TVTunerMediums[0];
         pCaps->VideoMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support

         pCaps->TVAudioMedium = TVTunerMediums[1];
         pCaps->TVAudioMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support

         pCaps->RadioAudioMedium = TVTunerMediums[2];   // No separate radio audio pin?
         pCaps->RadioAudioMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_CAPS_S );
    }
    break;

    case KSPROPERTY_TUNER_MODE:
    {
        PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pSPD->Property;
        ASSERT (nS >= sizeof( KSPROPERTY_TUNER_MODE_S ) );

        // now work with the output buffer
        pMode =(PKSPROPERTY_TUNER_MODE_S)pV;

        pMode->Mode = KSPROPERTY_TUNER_MODE_TV;

        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_S);
    }
    break;

    case KSPROPERTY_TUNER_MODE_CAPS:
    {
        PKSPROPERTY_TUNER_MODE_CAPS_S pCaps =
                (PKSPROPERTY_TUNER_MODE_CAPS_S) pSPD->Property;

        ASSERT (nS >= sizeof (KSPROPERTY_TUNER_MODE_CAPS_S));
        ASSERT (pCaps->Mode == KSPROPERTY_TUNER_MODE_TV);

        // now work with the output buffer
        pCaps = (PKSPROPERTY_TUNER_MODE_CAPS_S) pV;

        //
        // List the formats actually supported by this tuner
        //

        pCaps->StandardsSupported =

                   KS_AnalogVideo_NTSC_M

                |  KS_AnalogVideo_PAL_B
                |  KS_AnalogVideo_PAL_D
            //  |  KS_AnalogVideo_PAL_H
            //  |  KS_AnalogVideo_PAL_I
                |  KS_AnalogVideo_PAL_M
                |  KS_AnalogVideo_PAL_N

            //  |  KS_AnalogVideo_SECAM_B
            //  |  KS_AnalogVideo_SECAM_D
            //  |  KS_AnalogVideo_SECAM_G
            //  |  KS_AnalogVideo_SECAM_H
            //  |  KS_AnalogVideo_SECAM_K
            //  |  KS_AnalogVideo_SECAM_K1
            //  |  KS_AnalogVideo_SECAM_L
                ;

            //
            // Get the min and max frequencies supported
            //

        pCaps->MinFrequency =  55250000L;
        pCaps->MaxFrequency = 997250000L;

        //
        // What is the frequency step size?
        //

        pCaps->TuningGranularity =  62500L;

        //
        // How many inputs are on the tuner?
        //

        pCaps->NumberOfInputs = 1;

        //
        // What is the maximum settling time in milliseconds?
        //

        pCaps->SettlingTime = 100;

        //
        // Strategy defines how the tuner knows when it is in tune:
        //
        // KS_TUNER_STRATEGY_PLL (Has PLL offset information)
        // KS_TUNER_STRATEGY_SIGNAL_STRENGTH (has signal strength info)
        // KS_TUNER_STRATEGY_DRIVER_TUNES (driver handles all fine tuning)
        //

        pCaps->Strategy = KS_TUNER_STRATEGY_DRIVER_TUNES;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_MODE_CAPS_S);
    }
    break;

    case KSPROPERTY_TUNER_STANDARD:
    {
        // What is the currently selected video standard?

        ((PKSPROPERTY_TUNER_STANDARD_S) pSPD->PropertyInfo)->Standard =
                pHwDevExt->VideoStandard;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_STANDARD_S);
    }
    break;

    case KSPROPERTY_TUNER_INPUT:
    {
        // What is the currently selected input?

        ((PKSPROPERTY_TUNER_INPUT_S) pSPD->PropertyInfo)->InputIndex =
                pHwDevExt->TunerInput;

        pSrb->ActualBytesTransferred = sizeof (PKSPROPERTY_TUNER_INPUT_S);
    }
    break;


    case KSPROPERTY_TUNER_STATUS:

        // Return the status of the tuner

        // PLLOffset is in units of TuningGranularity
        // SignalStrength is 0 to 100
        // Set Busy to 1 if tuning is still in process

        {
            PKSPROPERTY_TUNER_STATUS_S pStatus =
                        (PKSPROPERTY_TUNER_STATUS_S) pSPD->PropertyInfo;

            ASSERT (nS >= sizeof (KSPROPERTY_TUNER_STATUS_S));
            pStatus->CurrentFrequency = pHwDevExt->Frequency;
            pStatus->PLLOffset = 0;
            pStatus->SignalStrength = 100;
            pStatus->Busy = pHwDevExt->Busy;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_STATUS_S);
        }
        break;

    default:
        TRAP
        break;
    }
}
#endif//TOSHIBA

// -------------------------------------------------------------------
// VideoProcAmp functions
// -------------------------------------------------------------------

/*
** AdapterSetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;
#ifdef  TOSHIBA // '98-12-09 Added, for Bug-Report 253529
    LONG MaxRange;
    LONG MinRange;
#endif//TOSHIBA

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

    switch (Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
#ifdef  TOSHIBA // '98-12-09 Modified, for Bug-Report 253529
        MaxRange = pHwDevExt->BrightnessRange.SignedMaximum;
        MinRange = pHwDevExt->BrightnessRange.SignedMinimum;
          if (   pS->Value < MinRange || pS->Value > MaxRange ) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return;
        }
#endif//TOSHIBA
        pHwDevExt->Brightness = pS->Value;
        pHwDevExt->BrightnessFlags = pS->Flags;
        break;

    case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
#ifdef  TOSHIBA // '98-12-09 Modified, for Bug-Report 253529
        MaxRange = pHwDevExt->ContrastRange.SignedMaximum;
        MinRange = pHwDevExt->ContrastRange.SignedMinimum;
        if ( pS->Value < MinRange || pS->Value > MaxRange ) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return;
        }
#endif//TOSHIBA
        pHwDevExt->Contrast = pS->Value;
        pHwDevExt->ContrastFlags = pS->Flags;
        break;

#ifdef  TOSHIBA
    case KSPROPERTY_VIDEOPROCAMP_HUE:
#ifdef  TOSHIBA // '98-12-09 Modified, for Bug-Report 253529
        MaxRange = pHwDevExt->HueRange.SignedMaximum;
        MinRange = pHwDevExt->HueRange.SignedMinimum;
        if ( pS->Value < MinRange || pS->Value > MaxRange ) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return;
        }
#endif//TOSHIBA
        pHwDevExt->Hue = pS->Value;
        pHwDevExt->HueFlags = pS->Flags;
        break;

    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
#ifdef  TOSHIBA // '98-12-09 Modified, for Bug-Report 253529
        MaxRange = pHwDevExt->SaturationRange.SignedMaximum;
        MinRange = pHwDevExt->SaturationRange.SignedMinimum;
        if ( pS->Value < MinRange || pS->Value > MaxRange ) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
            return;
        }
#endif//TOSHIBA
        pHwDevExt->Saturation = pS->Value;
        pHwDevExt->SaturationFlags = pS->Flags;
        break;

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        pHwDevExt->ColorEnable = pS->Value;
        pHwDevExt->ColorEnableFlags = pS->Flags;
        if ( pS->Value ) {
            if ( get_AblFilter( pHwDevExt ) ) {
                set_filtering( pHwDevExt, TRUE );
            } else {
                set_filtering( pHwDevExt, FALSE );
                pHwDevExt->ColorEnable = 0;
            }
        } else {
            set_filtering( pHwDevExt, FALSE );
        }
        return;
#else //TOSHIBA

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        pHwDevExt->ColorEnable = pS->Value;
        pHwDevExt->ColorEnableFlags = pS->Flags;
        break;
#endif//TOSHIBA

#ifdef  TOSHIBA
    default:
        return;
    }
    ImageSetHueBrightnessContrastSat(pHwDevExt);
#else //TOSHIBA
    default:
        break;
    }
#endif//TOSHIBA
}

/*
** AdapterGetVideoProcAmpProperty ()
**
**    Handles Get operations on the VideoProcAmp property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

    switch (Id) {

#ifdef  TOSHIBA
    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
        pS->Value = pHwDevExt->Brightness;
        pS->Flags = pHwDevExt->BrightnessFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;

    case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
        pS->Value = pHwDevExt->Contrast;
        pS->Flags = pHwDevExt->ContrastFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;

    case KSPROPERTY_VIDEOPROCAMP_HUE:
        pS->Value = pHwDevExt->Hue;
        pS->Flags = pHwDevExt->HueFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;

    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
        pS->Value = pHwDevExt->Saturation;
        pS->Flags = pHwDevExt->SaturationFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        if ( get_AblFilter( pHwDevExt ) ) {
            if ( get_filtering( pHwDevExt ) ) {
                pHwDevExt->ColorEnable = 1;
            } else {
                pHwDevExt->ColorEnable = 0;
            }
            pHwDevExt->ColorEnableFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
            pS->Value = pHwDevExt->ColorEnable;
            pS->Flags = pHwDevExt->ColorEnableFlags;
            pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        } else {
            if ( pHwDevExt->ColorEnable ) {
                set_filtering( pHwDevExt, FALSE );
                pHwDevExt->ColorEnable = 0;
            }
            pHwDevExt->ColorEnableFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
            pS->Value = pHwDevExt->ColorEnable;
            pS->Flags = pHwDevExt->ColorEnableFlags;
            pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        }
        break;
#else //TOSHIBA
    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
        pS->Value = pHwDevExt->Brightness;
        pS->Flags = pHwDevExt->BrightnessFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL |
                           KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        break;

    case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
        pS->Value = pHwDevExt->Contrast;
        pS->Flags = pHwDevExt->ContrastFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL |
                           KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        break;

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        pS->Value = pHwDevExt->ColorEnable;
        pS->Flags = pHwDevExt->ColorEnableFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;
#endif//TOSHIBA

    default:
        break;
    }
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOPROCAMP_S);
}

#ifndef TOSHIBA
// -------------------------------------------------------------------
// CameraControl functions
// -------------------------------------------------------------------

/*
** AdapterSetCameraControlProperty ()
**
**    Handles Set operations on the CameraControl property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (Id) {

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        pHwDevExt->Zoom = pS->Value;
        pHwDevExt->ZoomFlags = pS->Flags;
        break;

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        pHwDevExt->Focus = pS->Value;
        pHwDevExt->FocusFlags = pS->Flags;
        break;

    default:
        break;
    }
}

/*
** AdapterGetCameraControlProperty ()
**
**    Handles Get operations on the CameraControl property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the output data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (Id) {

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        pS->Value = pHwDevExt->Zoom;
        pS->Flags = pHwDevExt->ZoomFlags;
        pS->Capabilities = KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL |
                           KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
        break;

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        pS->Value = pHwDevExt->Focus;
        pS->Flags = pHwDevExt->FocusFlags;
        pS->Capabilities = KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL |
                           KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
        break;

    default:
        break;
    }
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CAMERACONTROL_S);
}

// -------------------------------------------------------------------
// TVAudio functions
// -------------------------------------------------------------------

/*
** AdapterSetTVAudioProperty ()
**
**    Handles Set operations on the TVAudio property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property


    switch (Id) {

    case KSPROPERTY_TVAUDIO_MODE:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;

        pHwDevExt->TVAudioMode = pS->Mode;
    }
    break;

    default:
        break;
    }
}

/*
** AdapterGetTVAudioProperty ()
**
**    Handles Get operations on the TVAudio property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_TVAUDIO_CAPS:
    {
        PKSPROPERTY_TVAUDIO_CAPS_S pS = (PKSPROPERTY_TVAUDIO_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_CAPS_S));

        pS->InputMedium  = TVAudioMediums[0];
        pS->InputMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support
        pS->OutputMedium = TVAudioMediums[1];
        pS->OutputMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support

        // Report all of the possible audio decoding modes the hardware is capabable of
        pS->Capabilities = KS_TVAUDIO_MODE_MONO   |
                           KS_TVAUDIO_MODE_STEREO |
                           KS_TVAUDIO_MODE_LANG_A |
                           KS_TVAUDIO_MODE_LANG_B ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_CAPS_S);
    }
    break;

    case KSPROPERTY_TVAUDIO_MODE:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));
        // Report the currently selected mode
        pS->Mode = pHwDevExt->TVAudioMode;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;

    case KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));
        // Report which audio modes could potentially be selected right now
        pS->Mode = KS_TVAUDIO_MODE_MONO   |
                   KS_TVAUDIO_MODE_STEREO |
                   KS_TVAUDIO_MODE_LANG_A ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;

    default:
        break;
    }
}

// -------------------------------------------------------------------
// AnalogVideoDecoder functions
// -------------------------------------------------------------------

/*
** AdapterSetAnalogVideoDecoderProperty ()
**
**    Handles Set operations on the AnalogVideoDecoder property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetAnalogVideoDecoderProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

    switch (Id) {

    case KSPROPERTY_VIDEODECODER_STANDARD:
    {
        pHwDevExt->VideoDecoderVideoStandard = pS->Value;
    }
    break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
    {
        pHwDevExt->VideoDecoderOutputEnable = pS->Value;
    }
    break;

    case KSPROPERTY_VIDEODECODER_VCR_TIMING:
    {
        pHwDevExt->VideoDecoderVCRTiming = pS->Value;
    }
    break;

    default:
        break;
    }
}

/*
** AdapterGetAnalogVideoDecoderProperty ()
**
**    Handles Get operations on the AnalogVideoDecoder property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetAnalogVideoDecoderProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_VIDEODECODER_CAPS:
    {
        PKSPROPERTY_VIDEODECODER_CAPS_S pS = (PKSPROPERTY_VIDEODECODER_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_CAPS_S));

        pS->StandardsSupported =
                   KS_AnalogVideo_NTSC_M

                |  KS_AnalogVideo_PAL_B
                |  KS_AnalogVideo_PAL_D
            //  |  KS_AnalogVideo_PAL_H
            //  |  KS_AnalogVideo_PAL_I
                |  KS_AnalogVideo_PAL_M
                |  KS_AnalogVideo_PAL_N

            //  |  KS_AnalogVideo_SECAM_B
            //  |  KS_AnalogVideo_SECAM_D
            //  |  KS_AnalogVideo_SECAM_G
            //  |  KS_AnalogVideo_SECAM_H
            //  |  KS_AnalogVideo_SECAM_K
            //  |  KS_AnalogVideo_SECAM_K1
            //  |  KS_AnalogVideo_SECAM_L
                   ;

        pS->Capabilities = KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  |
                           KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING |
                           KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED ;


        pS->SettlingTime = 10;          // How long to delay after tuning before
                                        // Locked indicator is valid

        pS->HSyncPerVSync = 6;          // HSync per VSync

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_CAPS_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_STANDARD:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderVideoStandard;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_STATUS:
    {
        PKSPROPERTY_VIDEODECODER_STATUS_S pS = (PKSPROPERTY_VIDEODECODER_STATUS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_STATUS_S));

        pS->NumberOfLines = (pHwDevExt->VideoDecoderVideoStandard & KS_AnalogVideo_NTSC_Mask)
                             ? 525 : 625;

        // Just to make things interesting, simulate that some channels aren't locked
        // In the US, these are channels 54 through 70
        pS->SignalLocked = (pHwDevExt->Frequency < 400000000 || pHwDevExt->Frequency > 500000000);

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderOutputEnable;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_VCR_TIMING:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderVCRTiming;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    default:
        break;
    }
}
#endif//TOSHIBA

#ifndef TOSHIBA // '98-12-10 Deleted, for Bug-Report 253534
// -------------------------------------------------------------------
// VideoControl functions
// -------------------------------------------------------------------

/*
** AdapterSetVideoControlProperty ()
**
**    Handles Set operations on the VideoControl property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetVideoControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOCONTROL_MODE_S pS = (PKSPROPERTY_VIDEOCONTROL_MODE_S) pSPD->PropertyInfo;
    PSTREAMEX pStrmEx;
    ULONG StreamIndex;
    ULONG *pVideoControlMode;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex >= 0 && StreamIndex < MAX_TSBVCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex < 0 || StreamIndex >= MAX_TSBVCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pVideoControlMode = &pStrmEx->VideoControlMode;
    }
    else {
        pVideoControlMode = &pHwDevExt->VideoControlMode;
    }

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));

    switch (Id) {

    case KSPROPERTY_VIDEOCONTROL_MODE:
    {
        *pVideoControlMode = pS->Mode;
    }
    break;

    default:
        break;
    }
}

/*
** AdapterGetVideoControlProperty ()
**
**    Handles Get operations on the VideoControl property set.
**      TsbVcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetVideoControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PSTREAMEX pStrmEx;
    ULONG StreamIndex;
    ULONG *pVideoControlMode;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex >= 0 && StreamIndex < MAX_TSBVCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex < 0 || StreamIndex >= MAX_TSBVCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pVideoControlMode = &pStrmEx->VideoControlMode;
    }
    else {
        pVideoControlMode = &pHwDevExt->VideoControlMode;
    }

    switch (Id) {

    case KSPROPERTY_VIDEOCONTROL_CAPS:
    {
        PKSPROPERTY_VIDEOCONTROL_CAPS_S pS = (PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_CAPS_S));

        pS->VideoControlCaps =
              KS_VideoControlFlag_FlipHorizontal
//            | KS_VideoControlFlag_FlipVertical
//            | KS_VideoControlFlag_ExternalTriggerEnable
//            | KS_VideoControlFlag_Trigger
            ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_CAPS_S);
    }
    break;

    case KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE:
    {
        PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S pS =
            (PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S));

        pS->CurrentActualFrameRate = 15;        // TODO: Why is this a fixed value?  Is it not reprogrammable?
        pS->CurrentMaxAvailableFrameRate = 15;  // TODO: Why is this a fixed value?  Is it not reprogrammable?


        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S);
    }
    break;

    case KSPROPERTY_VIDEOCONTROL_FRAME_RATES:
    {
        // todo
    }
    break;

    case KSPROPERTY_VIDEOCONTROL_MODE:
    {
        PKSPROPERTY_VIDEOCONTROL_MODE_S pS = (PKSPROPERTY_VIDEOCONTROL_MODE_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));

        pS->Mode = *pVideoControlMode;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S);
    }
    break;

    default:
        break;
    }
}

/*
** AdapterGetVideoCompressionProperty()
**
**    Gets compressor settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetVideoCompressionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PCOMPRESSION_SETTINGS pCompressionSettings;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex >= 0 && StreamIndex < MAX_TSBVCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex < 0 || StreamIndex >= MAX_TSBVCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pCompressionSettings = &pStrmEx->CompressionSettings;
    }
    else {
        pCompressionSettings = &pHwDevExt->CompressionSettings;
    }


    switch (Id) {

    case KSPROPERTY_VIDEOCOMPRESSION_GETINFO:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S pS =
                (PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S) pSPD->PropertyInfo;

            pS->DefaultKeyFrameRate = 15;    // Key frame rate
            pS->DefaultPFrameRate = 3;       // Predeicted frames per Key frame
            pS->DefaultQuality = 5000;       // 0 to 10000
            pS->Capabilities =
                       KS_CompressionCaps_CanQuality  |
                       KS_CompressionCaps_CanKeyFrame |
                       KS_CompressionCaps_CanBFrame   ;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S);
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS =
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            pS->Value = pCompressionSettings->CompressionKeyFrameRate;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS =
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            pS->Value = pCompressionSettings->CompressionPFramesPerKeyFrame;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_QUALITY:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS =
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            pS->Value = pCompressionSettings->CompressionQuality;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;

    default:
        break;
    }
}

/*
** AdapterSetVideoCompressionProperty()
**
**    Sets compressor settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetVideoCompressionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_VIDEOCOMPRESSION_S pS = (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PCOMPRESSION_SETTINGS pCompressionSettings;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex >= 0 && StreamIndex < MAX_TSBVCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex < 0 || StreamIndex >= MAX_TSBVCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pCompressionSettings = &pStrmEx->CompressionSettings;
    }
    else {
        pCompressionSettings = &pHwDevExt->CompressionSettings;
    }

    switch (Id) {

    case KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE:
        {
            pCompressionSettings->CompressionKeyFrameRate = pS->Value;
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME:
        {
            pCompressionSettings->CompressionPFramesPerKeyFrame = pS->Value;
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_QUALITY:
        {
            pCompressionSettings->CompressionQuality = pS->Value;
        }
        break;

    default:
        break;
    }
}
#endif//TOSHIBA


// -------------------------------------------------------------------
// General entry point for all get/set adapter properties
// -------------------------------------------------------------------

/*
** AdapterSetProperty ()
**
**    Handles Set operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

#ifdef  TOSHIBA
    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterSetVideoProcAmpProperty (pSrb);
    }
#else //TOSHIBA // '98-12-10 Moved, for Bug-Report 253534
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterSetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterSetVideoCompressionProperty (pSrb);
    }
//#else //TOSHIBA  '98-12-10 Moved, for Bug-Report 253534
    if (IsEqualGUID(&PROPSETID_VIDCAP_CROSSBAR, &pSPD->Property->Set)) {
        AdapterSetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_TUNER, &pSPD->Property->Set)) {
        AdapterSetTunerProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterSetVideoProcAmpProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterSetCameraControlProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_TVAUDIO, &pSPD->Property->Set)) {
        AdapterSetTVAudioProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEODECODER, &pSPD->Property->Set)) {
        AdapterSetAnalogVideoDecoderProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterSetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterSetVideoCompressionProperty (pSrb);
    }
#endif//TOSHIBA
    else {
        //
        // We should never get here
        //

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** AdapterGetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

#ifdef  TOSHIBA
    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterGetVideoProcAmpProperty (pSrb);
    }
#else //TOSHIBA // '98-12-10 Moved, for Bug-Report 253534
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterGetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterGetVideoCompressionProperty (pSrb);
    }
//#else //TOSHIBA  '98-12-10 Moved, for Bug-Report 253534
    if (IsEqualGUID (&PROPSETID_VIDCAP_CROSSBAR, &pSPD->Property->Set)) {
        AdapterGetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_TUNER, &pSPD->Property->Set)) {
        AdapterGetTunerProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterGetVideoProcAmpProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterGetCameraControlProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_TVAUDIO, &pSPD->Property->Set)) {
        AdapterGetTVAudioProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEODECODER, &pSPD->Property->Set)) {
        AdapterGetAnalogVideoDecoderProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterGetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterGetVideoCompressionProperty (pSrb);
    }
#endif//TOSHIBA
    else {
        //
        // We should never get here
        //

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\mediums.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file defines interconnections between components via Mediums
//

#ifdef DEFINE_MEDIUMS
    #define MEDIUM_DECL static
#else
    #define MEDIUM_DECL extern
#endif

/*  -----------------------------------------------------------

    Topology of all devices:

                            PinDir  FilterPin#    M_GUID#
    TVTuner
        TVTunerVideo        out         0            0
        TVTunerAudio        out         1            1
        TVTunerRadioAudio   out         2            2
    TVAudio
        TVTunerAudio        in          0            1
        TVAudio             out         1            3
    Crossbar
        TVTunerVideo        in          0            0
        TVAudio             in          5            3
        TVTunerRadioAudio   in          6            2
        AnalogVideoIn       out         9            4
        AudioOut            out         10           NULL
    Capture
        AnalogVideoIn       in          0            4


All other pins are marked as promiscuous connections via GUID_NULL
------------------------------------------------------------------ */

// Define the GUIDs which will be used to create the Mediums
#define M_GUID0 0x8dad65e0, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID1 0x8dad65e1, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID2 0x8dad65e2, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID3 0x8dad65e3, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID4 0x8dad65e4, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID5 0x8dad65e5, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_NOCONNECT  0x8dad65e6, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_NOCONNECT2 0x8dad65e7, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba

// Note: To allow multiple instances of the same piece of hardware,
// set the first ULONG after the GUID in the Medium to a unique value.

#ifdef  TOSHIBA
// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_GUID_NULL,  0, 0},  // Pin 0  Capture
};

MEDIUM_DECL BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
};
#else //TOSHIBA
// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVTunerMediums[] = {
    {M_GUID0,           0, 0},  // Pin 0
    {M_GUID1,           0, 0},  // Pin 1
    {M_GUID2,           0, 0},  // Pin 2
};

MEDIUM_DECL BOOL TVTunerPinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    TRUE,                       // Output Pin 2
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVAudioMediums[] = {
    {M_GUID1,           0, 0},  // Pin 0
    {M_GUID3,           0, 0},  // Pin 1
};

MEDIUM_DECL BOOL TVAudioPinDirection [] = {
    FALSE,                      // Input  Pin 0
    TRUE,                       // Output Pin 1
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CrossbarMediums[] = {
    {M_GUID0,           0, 0},  // Input  Pin 0, KS_PhysConn_Video_Tuner,
    {M_NOCONNECT,       0, 0},  // Input  Pin 1  KS_PhysConn_Video_Composite,
    {M_NOCONNECT,       0, 0},  // Input  Pin 2  KS_PhysConn_Video_SVideo,
    {M_NOCONNECT,       0, 0},  // Input  Pin 3  KS_PhysConn_Video_Tuner,
    {M_NOCONNECT,       0, 0},  // Input  Pin 4  KS_PhysConn_Video_Composite,
    {M_GUID3,           0, 0},  // Input  Pin 5  KS_PhysConn_Audio_Tuner,
    {M_GUID2,           0, 0},  // Input  Pin 6  KS_PhysConn_Audio_Line,
    {M_NOCONNECT,       0, 0},  // Input  Pin 7  KS_PhysConn_Audio_Tuner,
    {M_NOCONNECT,       0, 0},  // Input  Pin 8  KS_PhysConn_Audio_Line,
    {M_GUID4,           0, 0},  // Output Pin 9  KS_PhysConn_Video_VideoDecoder,
    {STATIC_GUID_NULL,  0, 0},  // Output Pin 10 KS_PhysConn_Audio_AudioDecoder,
};

MEDIUM_DECL BOOL CrossbarPinDirection [] = {
    FALSE,                      // Input  Pin 0, KS_PhysConn_Video_Tuner,
    FALSE,                      // Input  Pin 1  KS_PhysConn_Video_Composite,
    FALSE,                      // Input  Pin 2  KS_PhysConn_Video_SVideo,
    FALSE,                      // Input  Pin 3  KS_PhysConn_Video_Tuner,
    FALSE,                      // Input  Pin 4  KS_PhysConn_Video_Composite,
    FALSE,                      // Input  Pin 5  KS_PhysConn_Audio_Tuner,
    FALSE,                      // Input  Pin 6  KS_PhysConn_Audio_Line,
    FALSE,                      // Input  Pin 7  KS_PhysConn_Audio_Tuner,
    FALSE,                      // Input  Pin 8  KS_PhysConn_Audio_Line,
    TRUE,                       // Output Pin 9  KS_PhysConn_Video_VideoDecoder,
    TRUE,                       // Output Pin 10 KS_PhysConn_Audio_AudioDecoder,
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_GUID_NULL,  0, 0},  // Pin 0  Capture
    {STATIC_GUID_NULL,  0, 0},  // Pin 1  Preview
    {M_GUID4,           0, 0},  // Pin 2  Analog Video In
};

MEDIUM_DECL BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    FALSE,                      // Input  Pin 2
};
#endif//TOSHIBA



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capmain.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "mediums.h"
#include "capstrm.h"
#include "capprop.h"
#include "capdebug.h"

// The only global used by this driver.  It is used to keep track of the instance count of
// the number of times the driver is loaded.  This is used to create unique Mediums so that
// the correct capture, crossbar, tuner, and tvaudio filters all get connected together.

UINT GlobalDriverMediumInstanceCount = 0;

// Debug Logging
// 0 = Errors only
// 1 = Info, stream state changes, stream open close
// 2 = Verbose trace
ULONG gDebugLevel = 0;

/*
** DriverEntry()
**
**   This routine is called when the driver is first loaded by PnP.
**   It in turn, calls upon the stream class to perform registration services.
**
** Arguments:
**
**   DriverObject -
**          Driver object for this driver
**
**   RegistryPath -
**          Registry path string for this driver's key
**
** Returns:
**
**   Results of StreamClassRegisterAdapter()
**
** Side Effects:  none
*/

ULONG
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{

    HW_INITIALIZATION_DATA      HwInitData;
    ULONG                       ReturnValue;

    DbgLogInfo(("TestCap: DriverEntry\n"));

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    //
    // Set the Adapter entry points for the driver
    //

    HwInitData.HwInterrupt              = NULL; // HwInterrupt;

    HwInitData.HwReceivePacket          = AdapterReceivePacket;
    HwInitData.HwCancelPacket           = AdapterCancelPacket;
    HwInitData.HwRequestTimeoutHandler  = AdapterTimeoutPacket;

    HwInitData.DeviceExtensionSize      = sizeof(HW_DEVICE_EXTENSION);
    HwInitData.PerRequestExtensionSize  = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX);
    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = 3;
    HwInitData.DmaBufferSize            = 0;

    // Don't rely on the stream class using raised IRQL to synchronize
    // execution.  This single paramter most affects the overall structure
    // of the driver.

    HwInitData.TurnOffSynchronization   = TRUE;

    ReturnValue = StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData);

    DbgLogInfo(("Testcap: StreamClassRegisterAdapter = %x\n", ReturnValue));

    return ReturnValue;
}

//==========================================================================;
//                   Adapter Based Request Handling Routines
//==========================================================================;

/*
** HwInitialize()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Initialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN
STREAMAPI
HwInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    STREAM_PHYSICAL_ADDRESS     adr;
    ULONG                       Size;
    PUCHAR                      pDmaBuf;
    int                         j;

    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;

    PHW_DEVICE_EXTENSION pHwDevExt =
        (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

    DbgLogInfo(("Testcap: HwInitialize()\n"));

    if (ConfigInfo->NumberOfAccessRanges != 0) {
        DbgLogError(("Testcap: illegal config info\n"));

        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }

    DbgLogInfo(("TestCap: Number of access ranges = %lx\n", ConfigInfo->NumberOfAccessRanges));
    DbgLogInfo(("TestCap: Memory Range = %lx\n", pHwDevExt->ioBaseLocal));
    DbgLogInfo(("TestCap: IRQ = %lx\n", ConfigInfo->BusInterruptLevel));

    if (ConfigInfo->NumberOfAccessRanges != 0) {
        pHwDevExt->ioBaseLocal
                = (PULONG)(ULONG_PTR)   (ConfigInfo->AccessRanges[0].RangeStart.LowPart);
    }

    pHwDevExt->Irq  = (USHORT)(ConfigInfo->BusInterruptLevel);

    ConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
                DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    pDmaBuf = StreamClassGetDmaBuffer(pHwDevExt);

    adr = StreamClassGetPhysicalAddress(pHwDevExt,
            NULL, pDmaBuf, DmaBuffer, &Size);

    // Init Crossbar properties
    pHwDevExt->VideoInputConnected = 0;     // TvTuner video is the default
    pHwDevExt->AudioInputConnected = 5;     // TvTuner audio is the default

    // Init VideoProcAmp properties
    pHwDevExt->Brightness = BrightnessDefault;
    pHwDevExt->BrightnessFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
    pHwDevExt->Contrast = ContrastDefault;
    pHwDevExt->ContrastFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
    pHwDevExt->ColorEnable = ColorEnableDefault;
    pHwDevExt->ColorEnableFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    // Init CameraControl properties
    pHwDevExt->Focus = FocusDefault;
    pHwDevExt->FocusFlags = KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
    pHwDevExt->Zoom = ZoomDefault;
    pHwDevExt->ZoomFlags = KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;

    // Init TvTuner properties
    pHwDevExt->TunerMode = KSPROPERTY_TUNER_MODE_TV;
    pHwDevExt->Channel = 4;
    pHwDevExt->TunerInput = 0;
    pHwDevExt->Busy = 0;

    // Init TvAudio properties
    pHwDevExt->TVAudioMode = KS_TVAUDIO_MODE_MONO   |
                             KS_TVAUDIO_MODE_LANG_A ;

    // Init AnalogVideoDecoder properties
    pHwDevExt->VideoDecoderVideoStandard = KS_AnalogVideo_NTSC_M;
    pHwDevExt->VideoDecoderOutputEnable = FALSE;
    pHwDevExt->VideoDecoderVCRTiming = FALSE;

    // Init VideoControl properties
    pHwDevExt->VideoControlMode = 0;

    // Init VideoCompression properties
    pHwDevExt->CompressionSettings.CompressionKeyFrameRate = 15;
    pHwDevExt->CompressionSettings.CompressionPFramesPerKeyFrame = 3;
    pHwDevExt->CompressionSettings.CompressionQuality = 5000;

    pHwDevExt->PDO = ConfigInfo->RealPhysicalDeviceObject;
    DbgLogInfo(("TestCap: Physical Device Object = %lx\n", pHwDevExt->PDO));

    for (j = 0; j < MAX_TESTCAP_STREAMS; j++){

        // For each stream, maintain a separate queue for data and control
        InitializeListHead (&pHwDevExt->StreamSRBList[j]);
        InitializeListHead (&pHwDevExt->StreamControlSRBList[j]);
        KeInitializeSpinLock (&pHwDevExt->StreamSRBSpinLock[j]);
        pHwDevExt->StreamSRBListSize[j] = 0;
    }

    // Init ProtectionStatus
    pHwDevExt->ProtectionStatus = 0;


    // The following allows multiple instance of identical hardware
    // to be installed.  GlobalDriverMediumInstanceCount is set in the Medium.Id field.

    pHwDevExt->DriverMediumInstanceCount = GlobalDriverMediumInstanceCount++;
    AdapterSetInstance (pSrb);

    DbgLogInfo(("TestCap: Exit, HwInitialize()\n"));

    pSrb->Status = STATUS_SUCCESS;

    return (TRUE);

}

/*
** HwUnInitialize()
**
**   This routine is called when an SRB_UNINITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the UnInitialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN
STREAMAPI
HwUnInitialize (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    pSrb->Status = STATUS_SUCCESS;

    return TRUE;
}

/*
** AdapterPowerState()
**
**   This routine is called when an SRB_CHANGE_POWER_STATE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Change Power state command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN
STREAMAPI
AdapterPowerState (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    pHwDevExt->DeviceState = pSrb->CommandData.DeviceState;

    return TRUE;
}

/*
** AdapterSetInstance()
**
**   This routine is called to set all of the Medium instance fields
**
** Arguments:
**
**   pSrb - pointer to stream request block
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetInstance (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    int j;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    // Use our HwDevExt as the instance data on the Mediums
    // This allows multiple instances to be uniquely identified and
    // connected.  The value used in .Id is not important, only that
    // it is unique for each hardware connection

    for (j = 0; j < SIZEOF_ARRAY (TVTunerMediums); j++) {
        TVTunerMediums[j].Id = pHwDevExt->DriverMediumInstanceCount;
    }
    for (j = 0; j < SIZEOF_ARRAY (TVAudioMediums); j++) {
        TVAudioMediums[j].Id = pHwDevExt->DriverMediumInstanceCount;
    }
    for (j = 0; j < SIZEOF_ARRAY (CrossbarMediums); j++) {
        CrossbarMediums[j].Id = pHwDevExt->DriverMediumInstanceCount;
    }
    for (j = 0; j < SIZEOF_ARRAY (CaptureMediums); j++) {
        CaptureMediums[j].Id = pHwDevExt->DriverMediumInstanceCount;
    }

    pHwDevExt->AnalogVideoInputMedium = CaptureMediums[2];
}

/*
** AdapterCompleteInitialization()
**
**   This routine is called when an SRB_COMPLETE_INITIALIZATION request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCompleteInitialization (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS                Status;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    KIRQL                   KIrql;

    KIrql = KeGetCurrentIrql();

    // Create the Registry blobs that DShow uses to create
    // graphs via Mediums

    // Register the TVTuner
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVTUNER,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVTunerMediums),  // IN ULONG            PinCount,
                    TVTunerPinDirection,            // IN ULONG          * Flags,
                    TVTunerMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the Crossbar
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CROSSBAR,           // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CrossbarMediums), // IN ULONG            PinCount,
                    CrossbarPinDirection,           // IN ULONG          * Flags,
                    CrossbarMediums,                // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the TVAudio decoder
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVAUDIO,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVAudioMediums),  // IN ULONG            PinCount,
                    TVAudioPinDirection,            // IN ULONG          * Flags,
                    TVAudioMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the Capture filter
    // Note:  This should be done automatically be MSKsSrv.sys,
    // when that component comes on line (if ever) ...
    Status = StreamClassRegisterFilterWithNoKSPins (
                    pHwDevExt->PDO,                 // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CAPTURE,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CaptureMediums),  // IN ULONG            PinCount,
                    CapturePinDirection,            // IN ULONG          * Flags,
                    CaptureMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );
}


/*
** AdapterOpenStream()
**
**   This routine is called when an OpenStream SRB request is received.
**   A stream is identified by a stream number, which indexes an array
**   of KSDATARANGE structures.  The particular KSDATAFORMAT format to
**   be used is also passed in, which should be verified for validity.
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterOpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    //
    // the stream extension structure is allocated by the stream class driver
    //

    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;


    RtlZeroMemory(pStrmEx, sizeof(STREAMEX));

    DbgLogInfo(("TestCap: ------- ADAPTEROPENSTREAM ------- StreamNumber=%d\n", StreamNumber));

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT || StreamNumber < 0) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

    //
    // Check that we haven't exceeded the instance count for this stream
    //

    if (pHwDevExt->ActualInstances[StreamNumber] >=
        Streams[StreamNumber].hwStreamInfo.NumberOfPossibleInstances) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

    //
    // Check the validity of the format being requested
    //

    if (!AdapterVerifyFormat (pKSDataFormat, StreamNumber)) {

        pSrb->Status = STATUS_INVALID_PARAMETER;

        return;
    }

    //
    // And set the format for the stream
    //

    if (!VideoSetFormat (pSrb)) {

        return;
    }

    ASSERT (pHwDevExt->pStrmEx [StreamNumber] == NULL);

    // Maintain an array of all the StreamEx structures in the HwDevExt
    // so that we can cancel IRPs from any stream

    pHwDevExt->pStrmEx [StreamNumber] = (PSTREAMX) pStrmEx;

    // Set up pointers to the handlers for the stream data and control handlers

    pSrb->StreamObject->ReceiveDataPacket =
            (PVOID) Streams[StreamNumber].hwStreamObject.ReceiveDataPacket;
    pSrb->StreamObject->ReceiveControlPacket =
            (PVOID) Streams[StreamNumber].hwStreamObject.ReceiveControlPacket;

    //
    // The DMA flag must be set when the device will be performing DMA directly
    // to the data buffer addresses passed in to the ReceiceDataPacket routines.
    //

    pSrb->StreamObject->Dma = Streams[StreamNumber].hwStreamObject.Dma;

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing
    //

    pSrb->StreamObject->Pio = Streams[StreamNumber].hwStreamObject.Pio;

    //
    // How many extra bytes will be passed up from the driver for each frame?
    //

    pSrb->StreamObject->StreamHeaderMediaSpecific =
                Streams[StreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

    pSrb->StreamObject->StreamHeaderWorkspace =
                Streams[StreamNumber].hwStreamObject.StreamHeaderWorkspace;

    //
    // Indicate the clock support available on this stream
    //

    pSrb->StreamObject->HwClockObject =
                Streams[StreamNumber].hwStreamObject.HwClockObject;

    //
    // Increment the instance count on this stream
    //
    pHwDevExt->ActualInstances[StreamNumber]++;


    // Retain a private copy of the HwDevExt and StreamObject in the stream extension
    // so we can use a timer

    pStrmEx->pHwDevExt = pHwDevExt;                     // For timer use
    pStrmEx->pStreamObject = pSrb->StreamObject;        // For timer use

    // Initialize the compression settings
    // These may have been changed from the default values in the HwDevExt
    // before the stream was opened
    pStrmEx->CompressionSettings.CompressionKeyFrameRate =
        pHwDevExt->CompressionSettings.CompressionKeyFrameRate;
    pStrmEx->CompressionSettings.CompressionPFramesPerKeyFrame =
        pHwDevExt->CompressionSettings.CompressionPFramesPerKeyFrame;
    pStrmEx->CompressionSettings.CompressionQuality =
        pHwDevExt->CompressionSettings.CompressionQuality;

    // Init VideoControl properties
    pStrmEx->VideoControlMode = pHwDevExt->VideoControlMode;

    // Init VBI variables
    pStrmEx->SentVBIInfoHeader = 0;

    // init lock for pVideoInfoHeader
    // we need it to serialize using/setting of VideoInfoHeader
    KeInitializeSpinLock (&pStrmEx->lockVideoInfoHeader);

    DbgLogInfo(("TestCap: AdapterOpenStream Exit\n"));

}

/*
** AdapterCloseStream()
**
**   Close the requested data stream.
**
**   Note that a stream could be closed arbitrarily in the midst of streaming
**   if a user mode app crashes.  Therefore, you must release all outstanding
**   resources, disable interrupts, complete all pending SRBs, and put the
**   stream back into a quiescent condition.
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    KS_VIDEOINFOHEADER      *pVideoInfoHdr = pStrmEx->pVideoInfoHeader;

    DbgLogInfo(("TestCap: -------- ADAPTERCLOSESTREAM ------ StreamNumber=%d\n", StreamNumber));

    if (pHwDevExt->StreamSRBListSize > 0) {
        VideoQueueCancelAllSRBs (pStrmEx);
        DbgLogError(("TestCap: Outstanding SRBs at stream close!!!\n"));
    }

    pHwDevExt->ActualInstances[StreamNumber]--;

    ASSERT (pHwDevExt->pStrmEx [StreamNumber] != 0);

    pHwDevExt->pStrmEx [StreamNumber] = 0;

    //
    // the minidriver should free any resources that were allocate at
    // open stream time etc.
    //

    // Free the variable length VIDEOINFOHEADER

    if (pVideoInfoHdr) {
        ExFreePool(pVideoInfoHdr);
        pStrmEx->pVideoInfoHeader = NULL;
    }

    // Make sure we no longer reference the clock
    pStrmEx->hMasterClock = NULL;

    // Make sure the state is reset to stopped,
    pStrmEx->KSState = KSSTATE_STOP;

}


/*
** AdapterStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    int j;

    PHW_DEVICE_EXTENSION pHwDevExt =
        ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //

    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

     //
     // pick up the pointer to the array of stream information data structures
     //

     PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // verify that the buffer is large enough to hold our return data
    //

    DEBUG_ASSERT (pSrb->NumberOfBytesToTransfer >=
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION) * DRIVER_STREAM_COUNT);

    // Ugliness.  To allow mulitple instances, modify the pointer to the
    // AnalogVideoMedium and save it in our device extension

    Streams[STREAM_AnalogVideoInput].hwStreamInfo.Mediums =
           &pHwDevExt->AnalogVideoInputMedium;
    // pHwDevExt->AnalogVideoInputMedium = CrossbarMediums[9];
    // pHwDevExt->AnalogVideoInputMedium.Id = pHwDevExt->DriverMediumInstanceCount;

     //
     // Set the header
     //

     StreamHeader.NumDevPropArrayEntries = NUMBER_OF_ADAPTER_PROPERTY_SETS;
     StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) AdapterPropertyTable;
     *pstrhdr = StreamHeader;

     //
     // stuff the contents of each HW_STREAM_INFORMATION struct
     //

     for (j = 0; j < DRIVER_STREAM_COUNT; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
     }

}


/*
** AdapterReceivePacket()
**
**   Main entry point for receiving adapter based request SRBs.  This routine
**   will always be called at Passive level.
**
**   Note: This is an asyncronous entry point.  The request does not necessarily
**         complete on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    BOOL                    Busy;

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    DbgLogTrace(("TestCap: Receiving Adapter  SRB %8x, %x\n", pSrb, pSrb->Command));

    // The very first time through, we need to initialize the adapter spinlock
    // and queue
    if (!pHwDevExt->AdapterQueueInitialized) {
        InitializeListHead (&pHwDevExt->AdapterSRBList);
        KeInitializeSpinLock (&pHwDevExt->AdapterSpinLock);
        pHwDevExt->AdapterQueueInitialized = TRUE;
        pHwDevExt->ProcessingAdapterSRB = FALSE;
    }

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                    pSrb,
                    &pHwDevExt->AdapterSpinLock,
                    &pHwDevExt->ProcessingAdapterSRB,
                    &pHwDevExt->AdapterSRBList);

    if (Busy) {
        return;
    }

    //
    // This will run until the queue is empty
    //
    while (TRUE) {
        //
        // Assume success
        //
        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_INITIALIZE_DEVICE:

            // open the device

            HwInitialize(pSrb);

            break;

        case SRB_UNINITIALIZE_DEVICE:

            // close the device.

            HwUnInitialize(pSrb);

            break;

        case SRB_OPEN_STREAM:

            // open a stream

            AdapterOpenStream(pSrb);

            break;

        case SRB_CLOSE_STREAM:

            // close a stream

            AdapterCloseStream(pSrb);

            break;

        case SRB_GET_STREAM_INFO:

            //
            // return a block describing all the streams
            //

            AdapterStreamInfo(pSrb);

            break;

        case SRB_GET_DATA_INTERSECTION:

            //
            // Return a format, given a range
            //

            AdapterFormatFromRange(pSrb);

            break;

        case SRB_OPEN_DEVICE_INSTANCE:
        case SRB_CLOSE_DEVICE_INSTANCE:

            //
            // We should never get these since this is a single instance device
            //

            TRAP;
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_GET_DEVICE_PROPERTY:

            //
            // Get adapter wide properties
            //

            AdapterGetProperty (pSrb);
            break;

        case SRB_SET_DEVICE_PROPERTY:

            //
            // Set adapter wide properties
            //

            AdapterSetProperty (pSrb);
            break;

        case SRB_PAGING_OUT_DRIVER:

            //
            // The driver is being paged out
            // Disable Interrupts if you have them!
            //
            DbgLogInfo(("'Testcap: Receiving SRB_PAGING_OUT_DRIVER -- SRB=%x\n", pSrb));
            break;

        case SRB_CHANGE_POWER_STATE:

            //
            // Changing the device power state, D0 ... D3
            //
            DbgLogInfo(("'Testcap: Receiving SRB_CHANGE_POWER_STATE ------ SRB=%x\n", pSrb));
            AdapterPowerState(pSrb);
            break;

        case SRB_INITIALIZATION_COMPLETE:

            //
            // Stream class has finished initialization.
            // Now create DShow Medium interface BLOBs.
            // This needs to be done at low priority since it uses the registry
            //
            DbgLogInfo(("'Testcap: Receiving SRB_INITIALIZATION_COMPLETE-- SRB=%x\n", pSrb));

            AdapterCompleteInitialization (pSrb);
            break;


        case SRB_UNKNOWN_DEVICE_COMMAND:
        default:

            //
            // this is a request that we do not understand.  Indicate invalid
            // command and complete the request
            //
            pSrb->Status = STATUS_NOT_IMPLEMENTED;

        }

        //
        // Indicate back to the Stream Class that we're done with this SRB
        //
        CompleteDeviceSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                &pSrb,
                &pHwDevExt->AdapterSpinLock,
                &pHwDevExt->ProcessingAdapterSRB,
                &pHwDevExt->AdapterSRBList);

        if (!Busy) {
            break;
        }
    } // end of while there's anything in the queue
}

/*
** AdapterCancelPacket ()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    PSTREAMEX                   pStrmEx;
    int                         StreamNumber;
    BOOL                        Found = FALSE;

    //
    // Run through all the streams the driver has available
    //

    for (StreamNumber = 0; !Found && (StreamNumber < DRIVER_STREAM_COUNT); StreamNumber++) {

        //
        // Check to see if the stream is in use
        //

        if (pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamNumber]) {

            Found = VideoQueueCancelOneSRB (
                pStrmEx,
                pSrb
                );

        } // if the stream is open
    } // for all streams

    DbgLogInfo(("TestCap: Cancelling SRB %8x Succeeded=%d\n", pSrb, Found));
}

/*
** AdapterTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The adapter must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    //
    // Unlike most devices, we need to hold onto data SRBs indefinitely,
    // since the graph could be in a pause state indefinitely
    //

    DbgLogInfo(("TestCap: Timeout    Adapter SRB %8x\n", pSrb));

    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

}

/*
** CompleteDeviceSRB ()
**
**   This routine is called when a packet is being completed.
**   The optional second notification type is used to indicate ReadyForNext
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:
**
*/

VOID
STREAMAPI
CompleteDeviceSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    DbgLogTrace(("TestCap: Completing Adapter SRB %8x\n", pSrb));

    StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
}

/*
** IsEqualOrWildGUID()
**
**   Compares two GUIDS like IsEqualGUID(), except allows wildcard matches
**
** Arguments:
**
**         IN GUID *g1
**         IN GUID *g2
**
** Returns:
**
**   TRUE if both GUIDs match or only one is a wildcard
**   FALSE if GUIDs are different or both are wildcards
**
** Side Effects:  none
*/

BOOL
STREAMAPI
IsEqualOrWildGUID(IN GUID *g1, IN GUID *g2)
{
    return (IsEqualGUID(g1, g2) && !IsEqualGUID(g1, &KSDATAFORMAT_TYPE_WILDCARD)
            || ((IsEqualGUID(g1, &KSDATAFORMAT_TYPE_WILDCARD)
                 || IsEqualGUID(g2, &KSDATAFORMAT_TYPE_WILDCARD))
                && !IsEqualGUID(g1, g2))
            );
}

/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**         BOOL fCompareFormatSize - TRUE when comparing ranges
**                                 - FALSE when comparing formats
**
** Returns:
**
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOL fCompareFormatSize
    )
{
    return (
        IsEqualOrWildGUID (
            &DataRange1->MajorFormat,
            &DataRange2->MajorFormat) &&
        IsEqualOrWildGUID (
            &DataRange1->SubFormat,
            &DataRange2->SubFormat) &&
        IsEqualOrWildGUID (
            &DataRange1->Specifier,
            &DataRange2->Specifier) &&
        (fCompareFormatSize ?
                (DataRange1->FormatSize == DataRange2->FormatSize) : TRUE ));
}

/*
** MultiplyCheckOverflow()
**
**   Perform a 32-bit unsigned multiplication and return if the multiplication
**   did not overflow.
**
** Arguments:
**
**   a - first operand
**   b - second operand
**   pab - result
**
** Returns:
**
**   TRUE - no overflow
**   FALSE - overflow occurred
**
*/

BOOL
MultiplyCheckOverflow (
    ULONG a,
    ULONG b,
    ULONG *pab
    )

{

    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}

/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported KSDATA_RANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormat - pointer of a KSDATAFORMAT structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterVerifyFormat(
    PKSDATAFORMAT pKSDataFormatToVerify,
    int StreamNumber
    )
{
    BOOL                        fOK = FALSE;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT) {
        TRAP;
        return FALSE;
    }

    NumberOfFormatArrayEntries =
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;


    DbgLogInfo(("TestCap: AdapterVerifyFormat, Stream=%d\n", StreamNumber));
    DbgLogInfo(("TestCap: FormatSize=%d\n",  pKSDataFormatToVerify->FormatSize));
    DbgLogInfo(("TestCap: MajorFormat=%x\n", pKSDataFormatToVerify->MajorFormat));

    //
    // Walk the formats supported by the stream
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        // Check for a match on the three GUIDs and format size

        if (!AdapterCompareGUIDsAndFormatSize(
                        pKSDataFormatToVerify,
                        *pAvailableFormats,
                        FALSE /* CompareFormatSize */ )) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (&pKSDataFormatToVerify->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO) &&
            pKSDataFormatToVerify->FormatSize >= 
                sizeof (KS_DATAFORMAT_VIDEOINFOHEADER)) {

            PKS_DATAFORMAT_VIDEOINFOHEADER  pDataFormatVideoInfoHeader =
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormatToVerify;
            PKS_VIDEOINFOHEADER  pVideoInfoHdrToVerify =
                     (PKS_VIDEOINFOHEADER) &pDataFormatVideoInfoHeader->VideoInfoHeader;
            PKS_DATARANGE_VIDEO             pKSDataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            KS_VIDEO_STREAM_CONFIG_CAPS    *pConfigCaps = &pKSDataRangeVideo->ConfigCaps;
            RECT                            rcImage;

            DbgLogInfo(("TestCap: AdapterVerifyFormat\n"));
            DbgLogInfo(("TestCap: pVideoInfoHdrToVerify=%x\n", pVideoInfoHdrToVerify));
            DbgLogInfo(("TestCap: KS_VIDEOINFOHEADER size=%d\n",
                    KS_SIZE_VIDEOHEADER (pVideoInfoHdrToVerify)));
            DbgLogInfo(("TestCap: Width=%d  Height=%d  BitCount=%d\n",
            pVideoInfoHdrToVerify->bmiHeader.biWidth,
            pVideoInfoHdrToVerify->bmiHeader.biHeight,
            pVideoInfoHdrToVerify->bmiHeader.biBitCount));
            DbgLogInfo(("TestCap: biSizeImage=%d\n",
                pVideoInfoHdrToVerify->bmiHeader.biSizeImage));

            /*
            **  HOW BIG IS THE IMAGE REQUESTED (pseudocode follows)
            **
            **  if (IsRectEmpty (&rcTarget) {
            **      SetRect (&rcImage, 0, 0,
            **              BITMAPINFOHEADER.biWidth,
                            BITMAPINFOHEADER.biHeight);
            **  }
            **  else {
            **      // Probably rendering to a DirectDraw surface,
            **      // where biWidth is used to expressed the "stride"
            **      // in units of pixels (not bytes) of the destination surface.
            **      // Therefore, use rcTarget to get the actual image size
            **
            **      rcImage = rcTarget;
            **  }
            */

            if ((pVideoInfoHdrToVerify->rcTarget.right -
                 pVideoInfoHdrToVerify->rcTarget.left <= 0) ||
                (pVideoInfoHdrToVerify->rcTarget.bottom -
                 pVideoInfoHdrToVerify->rcTarget.top <= 0)) {

                 rcImage.left = rcImage.top = 0;
                 rcImage.right = pVideoInfoHdrToVerify->bmiHeader.biWidth;
                 rcImage.bottom = pVideoInfoHdrToVerify->bmiHeader.biHeight;
            }
            else {
                 rcImage = pVideoInfoHdrToVerify->rcTarget;
            }

            //
            // Check that bmiHeader.biSize is valid since we use it later.
            //
            {
                ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
                    pVideoInfoHdrToVerify
                );

                ULONG DataFormatSize = FIELD_OFFSET (
                    KS_DATAFORMAT_VIDEOINFOHEADER, VideoInfoHeader
                    ) + VideoHeaderSize;

                if (
                    VideoHeaderSize < pVideoInfoHdrToVerify->bmiHeader.biSize ||
                    DataFormatSize < VideoHeaderSize ||
                    DataFormatSize > pKSDataFormatToVerify -> FormatSize
                    ) {

                    fOK = FALSE;
                    break;
                }
            }

            //
            // Compute the minimum size of our buffers to validate against.
            // The image synthesis routines synthesize |biHeight| rows of
            // biWidth pixels in either RGB24 or UYVY.  In order to ensure
            // safe synthesis into the buffer, we need to know how large an
            // image this will produce.
            //
            // I do this explicitly because of the method that the data is
            // synthesized.  A variation of this may or may not be necessary
            // depending on the mechanism the driver in question fills the 
            // capture buffers.  The important thing is to ensure that they
            // aren't overrun during capture.
            //
            {
                ULONG ImageSize;

                if (!MultiplyCheckOverflow (
                    (ULONG)pVideoInfoHdrToVerify->bmiHeader.biWidth,
                    (ULONG)abs (pVideoInfoHdrToVerify->bmiHeader.biHeight),
                    &ImageSize
                    )) {

                    fOK = FALSE;
                    break;
                }

                //
                // We only support KS_BI_RGB (24) and KS_BI_YUV422 (16), so
                // this is valid for those formats.
                //
                if (!MultiplyCheckOverflow (
                    ImageSize,
                    (ULONG)(pVideoInfoHdrToVerify->bmiHeader.biBitCount / 8),
                    &ImageSize
                    )) {

                    fOK = FALSE;
                    break;
                }

                //
                // Valid for the formats we use.  Otherwise, this would be
                // checked later.
                //
                if (pVideoInfoHdrToVerify->bmiHeader.biSizeImage <
                    ImageSize) {

                    fOK = FALSE;
                    break;
                }

            }

            //
            // Perform all other verification tests here!!!
            //

            //
            // HOORAY, the format passed all of the tests, so we support it
            //

            fOK = TRUE;
            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier,
                    &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO) &&
                pKSDataFormatToVerify->FormatSize >=
                    sizeof (KS_DATARANGE_ANALOGVIDEO)) {

            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            //
            // Perform all other verification tests here!!!
            //

            fOK = TRUE;
            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_VBI for KS_VIDEO_VBI
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&pKSDataFormatToVerify->Specifier,
                    &KSDATAFORMAT_SPECIFIER_VBI) &&
                pKSDataFormatToVerify->FormatSize >=
                    sizeof (KS_DATAFORMAT_VBIINFOHEADER))
        {
            //
            // Do some VBI-specific tests
            //
            PKS_DATAFORMAT_VBIINFOHEADER    pKSVBIDataFormat;

            DbgLogInfo(("Testcap: This is a VBIINFOHEADER format pin.\n" ));

            pKSVBIDataFormat = (PKS_DATAFORMAT_VBIINFOHEADER)pKSDataFormatToVerify;

            //
            // Check VideoStandard, we only support NTSC_M
            //
            if (KS_AnalogVideo_NTSC_M
                == pKSVBIDataFormat->VBIInfoHeader.VideoStandard)
            {
                fOK = TRUE;
                break;
            }
            else
            {
                DbgLogError(
                ("Testcap: AdapterVerifyFormat : VideoStandard(%d) != NTSC_M\n",
                 pKSVBIDataFormat->VBIInfoHeader.VideoStandard));
            }
        }

        // -------------------------------------------------------------------
        // Type FORMAT_NABTS for NABTS pin
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&pKSDataFormatToVerify->SubFormat,
                &KSDATAFORMAT_SUBTYPE_NABTS))
        {
            fOK = TRUE;
            break;
        }

        // -------------------------------------------------------------------
        // for CC pin
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&pKSDataFormatToVerify->SubFormat,
                &KSDATAFORMAT_SUBTYPE_CC))
        {
            fOK = TRUE;
            break;
        }

    } // End of loop on all formats for this stream

    return fOK;
}

/*
** AdapterFormatFromRange()
**
**   Produces a DATAFORMAT given a DATARANGE.
**
**   Think of a DATARANGE as a multidimensional space of all of the possible image
**       sizes, cropping, scaling, and framerate possibilities.  Here, the caller
**       is saying "Out of this set of possibilities, could you verify that my
**       request is acceptable?".  The resulting singular output is a DATAFORMAT.
**       Note that each different colorspace (YUV vs RGB8 vs RGB24)
**       must be represented as a separate DATARANGE.
**
**   Generally, the resulting DATAFORMAT will be immediately used to open a stream
**       in that format.
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       FormatSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= DRIVER_STREAM_COUNT) {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        TRAP;
        return FALSE;
    }

    NumberOfFormatArrayEntries =
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    //
    // Is the caller trying to get the format, or the size of the format?
    //

    OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if (!AdapterCompareGUIDsAndFormatSize(
                        DataRange,
                        *pAvailableFormats,
                        TRUE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (&DataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

            PKS_DATARANGE_VIDEO DataRangeVideoToVerify =
                    (PKS_DATARANGE_VIDEO) DataRange;
            PKS_DATARANGE_VIDEO DataRangeVideo =
                    (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            PKS_DATAFORMAT_VIDEOINFOHEADER DataFormatVideoInfoHeaderOut;

            //
            // Check that the other fields match
            //
            if ((DataRangeVideoToVerify->bFixedSizeSamples != DataRangeVideo->bFixedSizeSamples) ||
                (DataRangeVideoToVerify->bTemporalCompression != DataRangeVideo->bTemporalCompression) ||
                (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
                (DataRangeVideoToVerify->MemoryAllocationFlags != DataRangeVideo->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps,
                        &DataRangeVideo->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) !=
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)))
            {
                continue;
            }

            //
            // KS_SIZE_VIDEOHEADER() below is relying on bmiHeader.biSize from
            // the caller's data range.  This **MUST** be validated; the
            // extended bmiHeader size (biSize) must not extend past the end
            // of the range buffer.  Possible arithmetic overflow is also
            // checked for.
            //
            {
                ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
                    &DataRangeVideoToVerify->VideoInfoHeader
                    );

                ULONG DataRangeSize = 
                    FIELD_OFFSET (KS_DATARANGE_VIDEO, VideoInfoHeader) +
                    VideoHeaderSize;

                //
                // Check that biSize does not extend past the buffer.  The 
                // first two checks are for arithmetic overflow on the 
                // operations to compute the alleged size.  (On unsigned
                // math, a+b < a iff an arithmetic overflow occurred).
                //
                if (
                    VideoHeaderSize < DataRangeVideoToVerify->
                        VideoInfoHeader.bmiHeader.biSize ||
                    DataRangeSize < VideoHeaderSize ||
                    DataRangeSize > DataRangeVideoToVerify -> 
                        DataRange.FormatSize
                    ) {

                    pSrb->Status = STATUS_INVALID_PARAMETER;
                    return FALSE;

                }
            }

            // MATCH FOUND!
            MatchFound = TRUE;
            FormatSize = sizeof (KSDATAFORMAT) +
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader);

            if (OnlyWantsSize) {
                break;
            }

            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the
            // actual VideoInfoHeader

            DataFormatVideoInfoHeaderOut = (PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer;

            // Copy over the KSDATAFORMAT
            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->DataFormat,
                &DataRangeVideoToVerify->DataRange,
                sizeof (KSDATARANGE));

            DataFormatVideoInfoHeaderOut->DataFormat.FormatSize = FormatSize;

            // Copy over the callers requested VIDEOINFOHEADER

            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->VideoInfoHeader,
                &DataRangeVideoToVerify->VideoInfoHeader,
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader));

            // Calculate biSizeImage for this request, and put the result in both
            // the biSizeImage field of the bmiHeader AND in the SampleSize field
            // of the DataFormat.
            //
            // Note that for compressed sizes, this calculation will probably not
            // be just width * height * bitdepth

            DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader.biSizeImage =
                DataFormatVideoInfoHeaderOut->DataFormat.SampleSize =
                KS_DIBSIZE(DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader);

            //
            // Perform other validation such as cropping and scaling checks
            //

            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&DataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {

            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;
            FormatSize = sizeof (KS_DATARANGE_ANALOGVIDEO);

            if (OnlyWantsSize) {
                break;
            }

            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            RtlCopyMemory(
                IntersectInfo->DataFormatBuffer,
                DataRangeVideo,
                sizeof (KS_DATARANGE_ANALOGVIDEO));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_VBI for KS_VIDEO_VBI
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&DataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_VBI))
        {
            PKS_DATARANGE_VIDEO_VBI pDataRangeVBI =
                (PKS_DATARANGE_VIDEO_VBI)*pAvailableFormats;
            PKS_DATAFORMAT_VBIINFOHEADER InterVBIHdr =
                (PKS_DATAFORMAT_VBIINFOHEADER)IntersectInfo->DataFormatBuffer;

            // MATCH FOUND!
            MatchFound = TRUE;

            FormatSize = sizeof (KS_DATAFORMAT_VBIINFOHEADER);

            // Is the caller trying to get the format, or the size of it?
            if (OnlyWantsSize)
                break;

            // Verify that there is enough room in the supplied buffer
            //   for the whole thing
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize)
            {
                if (IntersectInfo->SizeOfDataFormatBuffer > 0) {
                    DbgLogError(
                        ("Testcap::AdapterFormatFromRange: "
                         "Specifier==VBI, Buffer too small=%d vs. %d\n",
                         IntersectInfo->SizeOfDataFormatBuffer,
                         FormatSize));
                }
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // If there is room, go ahead...

            RtlCopyMemory(&InterVBIHdr->DataFormat,
                          &pDataRangeVBI->DataRange,
                          sizeof (KSDATARANGE));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            RtlCopyMemory(&InterVBIHdr->VBIInfoHeader,
                          &pDataRangeVBI->VBIInfoHeader,
                          sizeof(KS_VBIINFOHEADER));

            break;

        } // End of KS_VIDEO_VBI specifier

        // -------------------------------------------------------------------
        // Type FORMAT_NABTS for NABTS pin
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&DataRange->SubFormat,
                &KSDATAFORMAT_SUBTYPE_NABTS))
        {
            PKSDATARANGE pDataRange = (PKSDATARANGE)*pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;

            FormatSize = sizeof (KSDATAFORMAT);

            // Is the caller trying to get the format, or the size of it?
            if (OnlyWantsSize)
                break;

            // Verify that there is enough room in the supplied buffer
            //   for the whole thing
            if (IntersectInfo->SizeOfDataFormatBuffer >= FormatSize)
            {
                RtlCopyMemory(IntersectInfo->DataFormatBuffer,
                              pDataRange,
                              FormatSize);

                ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;
            }
            else
            {
                if (IntersectInfo->SizeOfDataFormatBuffer > 0) {
                    DbgLogError(
                        ("Testcap::AdapterFormatFromRange: "
                         "SubFormat==NABTS, Buffer too small=%d vs. %d\n",
                         IntersectInfo->SizeOfDataFormatBuffer,
                         FormatSize));
                }
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            break;

        } // End of KS_SUBTYPE_NABTS

        // -------------------------------------------------------------------
        // for CC pin
        // -------------------------------------------------------------------

        else if (IsEqualGUID (&DataRange->SubFormat,
                &KSDATAFORMAT_SUBTYPE_CC))
        {
            PKSDATARANGE pDataRange = (PKSDATARANGE)*pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;

            FormatSize = sizeof (KSDATAFORMAT);

            // Is the caller trying to get the format, or the size of it?
            if (OnlyWantsSize)
                break;

            // Verify that there is enough room in the supplied buffer
            //   for the whole thing
            if (IntersectInfo->SizeOfDataFormatBuffer >= FormatSize)
            {
                RtlCopyMemory(IntersectInfo->DataFormatBuffer,
                              pDataRange,
                              FormatSize);

                ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;
            }
            else
            {
                if (IntersectInfo->SizeOfDataFormatBuffer > 0) {
                    DbgLogError(
                        ("Testcap::AdapterFormatFromRange: "
                         "SubFormat==CC, Buffer too small=%d vs. %d\n",
                         IntersectInfo->SizeOfDataFormatBuffer,
                         FormatSize));
                }
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            break;

        } // End of CC pin format check

        else {
            pSrb->Status = STATUS_NO_MATCH;
            return FALSE;
        }

    } // End of loop on all formats for this stream

    if (!MatchFound) {
        pSrb->Status = STATUS_NO_MATCH;
        return FALSE;
    }

    if (OnlyWantsSize) {
        *(PULONG) IntersectInfo->DataFormatBuffer = FormatSize;
        FormatSize = sizeof(ULONG);
    }
    pSrb->ActualBytesTransferred = FormatSize;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capmain.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPMAIN_H__
#define __CAPMAIN_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

// Warning:  The stream numbers below MUST be the same as its position
//           in the Streams[] array in the capstrm.h file.
typedef enum {
    STREAM_Capture = 0,
    STREAM_Preview,
    STREAM_VBI,
    STREAM_CC,
    STREAM_NABTS,
    STREAM_AnalogVideoInput,
    MAX_TESTCAP_STREAMS         // This entry MUST be last; it's the size
}; 

// ------------------------------------------------------------------------
//  Other misc stuff
// ------------------------------------------------------------------------

#ifndef FIELDOFFSET
#define FIELDOFFSET(type, field)        ((LONG_PTR)(&((type *)1)->field)-1)
#endif

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
  
#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

typedef struct _STREAMX;
typedef struct _STREAMX *PSTREAMX;

typedef struct _COMPRESSION_SETTINGS {
    LONG                     CompressionKeyFrameRate;
    LONG                     CompressionPFramesPerKeyFrame;
    LONG                     CompressionQuality;
} COMPRESSION_SETTINGS, *PCOMPRESSION_SETTINGS;

//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _HW_DEVICE_EXTENSION {
    PULONG                   ioBaseLocal;                           // board base address
    USHORT                   Irq;                                   // IRQ level
    BOOLEAN                  IRQExpected;                           // IRQ expected
    PSTREAMX                 pStrmEx [MAX_TESTCAP_STREAMS];         // Pointers to each stream
    UINT                     ActualInstances [MAX_TESTCAP_STREAMS]; // Counter of instances per stream
    PDEVICE_OBJECT           PDO;                                   // Physical Device Object
    DEVICE_POWER_STATE       DeviceState;                           // D0 ... D3

    // Spinlock and Queue for the Adapter
    BOOL                     AdapterQueueInitialized;               // Stays TRUE after first init
    KSPIN_LOCK               AdapterSpinLock;                       // Multiprocessor safe access to AdapterSRBList
    LIST_ENTRY               AdapterSRBList;                        // List of pending adapter commands
    BOOL                     ProcessingAdapterSRB;                  // Master flag which prevents reentry

    // Spinlocks and Queues for each data stream
    LIST_ENTRY               StreamSRBList[MAX_TESTCAP_STREAMS];    // List of pending read requests
    KSPIN_LOCK               StreamSRBSpinLock[MAX_TESTCAP_STREAMS];// Multiprocessor safe access to StreamSRBList
    int                      StreamSRBListSize[MAX_TESTCAP_STREAMS];// Number of entries in the list

    // Control Queues for each data stream
    LIST_ENTRY               StreamControlSRBList[MAX_TESTCAP_STREAMS];
    BOOL                     ProcessingControlSRB[MAX_TESTCAP_STREAMS];

    // Unique identifier for the analog video input pin
    KSPIN_MEDIUM             AnalogVideoInputMedium;
    UINT                     DriverMediumInstanceCount;             // Unique Medium.Id for multiple cards

    // Crossbar settings
    LONG                     VideoInputConnected;                   // which input is the video out connected to?
    LONG                     AudioInputConnected;                   // which input is the audio out connected to?

    // TV Tuner settings
    ULONG                    TunerMode;                 // TV, FM, AM, ATSC
    ULONG                    Frequency;
    ULONG                    VideoStandard;
    ULONG                    TuningQuality;
    ULONG                    TunerInput;
    ULONG                    Country;
    ULONG                    Channel;
    ULONG                    Busy;

    // TV Audio settings
    ULONG                    TVAudioMode;

    // VideoProcAmp settings
    LONG                     Brightness;
    LONG                     BrightnessFlags;
    LONG                     Contrast;
    LONG                     ContrastFlags;
    LONG                     ColorEnable;
    LONG                     ColorEnableFlags;
    
    // CameraControl settings
    LONG                     Focus;
    LONG                     FocusFlags;
    LONG                     Zoom;
    LONG                     ZoomFlags;
    
    // AnalogVideoDecoder settings
    LONG                     VideoDecoderVideoStandard;
    LONG                     VideoDecoderOutputEnable;
    LONG                     VideoDecoderVCRTiming;

    // VideoControl settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    LONG                     VideoControlMode;

    // Compressor settings (these are set if a pin is not opened,
    // otherwise, the STREAMEX values are used.
    COMPRESSION_SETTINGS     CompressionSettings;

    // Channel Change information
    KS_TVTUNER_CHANGE_INFO   TVTunerChangeInfo;

    // Bits indicating protection status; eg, has Macrovision been detected?
    ULONG                    ProtectionStatus;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//
 
typedef struct _STREAMEX {
    PHW_DEVICE_EXTENSION        pHwDevExt;          // For timer use
    PHW_STREAM_OBJECT           pStreamObject;      // For timer use
    KS_VIDEOINFOHEADER         *pVideoInfoHeader;   // format (variable size!)
    KSPIN_LOCK                  lockVideoInfoHeader;// lock the access to pVideoInfoHeader
    DWORD                       biSizeImage;        // a copy from InfoHdr to avoid lock
    KS_DATARANGE_VIDEO_VBI     *pVBIStreamFormat;
    KS_FRAME_INFO               FrameInfo;          // PictureNumber, etc.
    KS_VBI_FRAME_INFO           VBIFrameInfo;       // PictureNumber, etc.
    ULONG                       fDiscontinuity;     // Discontinuity since last valid
    KSSTATE                     KSState;            // Run, Stop, Pause
    UCHAR                       LineBuffer[720 * 3];// working buffer (RGB24)

    // Clock 
    HANDLE                      hMasterClock;       // Master clock to use
    REFERENCE_TIME              QST_Now;            // KeQuerySystemTime currently
    REFERENCE_TIME              QST_NextFrame;      // When to capture the next frame
    REFERENCE_TIME              QST_StreamTime;     // Stream time reported by master clock

    REFERENCE_TIME              AvgTimePerFrame;    // Extracted from pVideoInfoHeader

    // Compressor settings (note these are duplicated in the 
    // HW_DEVICE_EXTENSION to allow setting these before a pin is created)
    COMPRESSION_SETTINGS        CompressionSettings;

    // VideoControl settings (note these are duplicated in the 
    // HW_DEVICE_EXTENSION to allow setting these before a pin is created)
    LONG                        VideoControlMode;

    // Kernel DDraw interface
    BOOL                        KernelDirectDrawRegistered;
    HANDLE                      UserDirectDrawHandle;       // DD itself
    HANDLE                      KernelDirectDrawHandle;
    BOOL                        PreEventOccurred;
    BOOL                        PostEventOccurred;

    BOOL                        SentVBIInfoHeader;
} STREAMEX, *PSTREAMEX;

//
// this structure defines the per request extension.  It defines any storage
// space that the mini driver may need in each request packet.
//

typedef struct _SRB_EXTENSION {
    LIST_ENTRY                  ListEntry;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    HANDLE                      UserSurfaceHandle;      // DDraw
    HANDLE                      KernelSurfaceHandle;    // DDraw
} SRB_EXTENSION, * PSRB_EXTENSION;

// -------------------------------------------------------------------
//
// Adapter level prototypes
//
// These functions affect the device as a whole, as opposed to 
// affecting individual streams.
//
// -------------------------------------------------------------------

//
// DriverEntry:
//
// This routine is called when the mini driver is first loaded.  The driver
// should then call the StreamClassRegisterAdapter function to register with
// the stream class driver
//

ULONG DriverEntry (PVOID Context1, PVOID Context2);

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the adapter should also be performed at this time.
//

BOOLEAN STREAMAPI HwInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN STREAMAPI HwUnInitialize ( PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called whenever the minidriver receives an interrupt
//

BOOLEAN HwInterrupt ( IN PHW_DEVICE_EXTENSION pDeviceExtension );

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID STREAMAPI AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID STREAMAPI AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID STREAMAPI AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the AdapterReceivePacket routine.  This is the
// entry point for command packets that are sent to the adapter (not to a
// specific open stream)
//

VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The adapter may choose to ignore a
// packet timeout, or rest the adapter and cancel the requests, as required.
//

VOID STREAMAPI AdapterTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// Adapter level property set handling
//

VOID STREAMAPI AdapterGetCrossbarProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetCrossbarProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetTunerProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetTunerProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoProcAmpProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoProcAmpProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetCameraControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetCameraControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetTVAudioProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetTVAudioProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetAnalogVideoDecoderProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetAnalogVideoDecoderProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoControlProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetVideoCompressionProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetVideoCompressionProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterSetProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AdapterGetProperty(IN PHW_STREAM_REQUEST_BLOCK pSrb);

BOOL
STREAMAPI 
AdapterVerifyFormat(
        PKSDATAFORMAT pKSDataFormatToVerify, 
        int StreamNumber);

BOOL
STREAMAPI 
AdapterFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID
STREAMAPI 
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb
        );

VOID
STREAMAPI
AdapterSetInstance ( 
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


//
// prototypes for general queue management using a busy flag
//

BOOL
STREAMAPI 
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    );

BOOL
STREAMAPI 
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    );


// -------------------------------------------------------------------
//
// Stream level prototypes
//
// These functions affect individual streams, as opposed to
// affecting the device as a whole.
//
// -------------------------------------------------------------------

//
// Routines to manage the SRB queue on a per stream basis
//

VOID
STREAMAPI 
VideoQueueAddSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

PHW_STREAM_REQUEST_BLOCK 
STREAMAPI 
VideoQueueRemoveSRB (
    PHW_DEVICE_EXTENSION pHwDevExt,
    int StreamNumber
    );

VOID
STREAMAPI 
VideoQueueCancelAllSRBs (
    PSTREAMEX pStrmEx
    );

BOOL
STREAMAPI 
VideoQueueCancelOneSRB (
    PSTREAMEX pStrmEx,
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    );

//
// StreamFormat declarations
//
extern KS_DATARANGE_VIDEO_VBI StreamFormatVBI;
extern KSDATARANGE            StreamFormatNABTS;
extern KSDATARANGE            StreamFormatCC;


//
// Data packet handlers
//
//
// prototypes for data handling routines
//
VOID STREAMAPI CompleteStreamSRB (IN PHW_STREAM_REQUEST_BLOCK pSrb);
BOOL STREAMAPI VideoSetFormat(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogVideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogVideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VBIReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VBIReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI EnableIRQ(PHW_STREAM_OBJECT pstrm);
VOID STREAMAPI DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//

VOID STREAMAPI VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK pSrb);

// 
// stream clock functions
//
VOID 
STREAMAPI 
VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK pSrb);

//
// The point of it all
// 
VOID 
STREAMAPI 
VideoCaptureRoutine(
    IN PSTREAMEX pStrmEx
    );

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CAPMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CAPDEBUG_H
#define __CAPDEBUG_H

#if DBG

// Debug Logging
// 0 = Errors only
// 1 = Info, stream state changes, stream open close
// 2 = Verbose trace

extern ULONG gDebugLevel;

# define DbgKdPrint(x)  KdPrint(x)
# define DbgLogError(x)  do { if( (gDebugLevel > 0) || (gDebugLevel == 0))	 KdPrint(x); } while (0)
# define DbgLogInfo(x)   do { if( gDebugLevel >= 1)	 KdPrint(x); } while (0)
# define DbgLogTrace(x)  do { if( gDebugLevel >= 2)  KdPrint(x); } while (0)

# ifdef _X86_
#  define TRAP   __asm { int 3 }
# else //_X86_
#  define TRAP   KdBreakPoint()
# endif //_X86_

#else //DBG

# define DbgKdPrint(x)
# define DbgLogError(x)
# define DbgLogInfo(x)
# define DbgLogTrace(x)

# define TRAP

#endif //DBG

#endif // #ifndef __CAPDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\tecra750\image.h ===
//
//              TOSHIBA CORPORATION PROPRIETARY INFORMATION
//     This software is supplied under the terms of a license agreement or
//     nondisclosure agreement with TOSHIBA Corporation and may not be copied
//     or disclosed except in accordance with the terms of that agreement.
//           Copyright (c) 1997 TOSHIBA Corporation. All Rights Reserved.
//
//  Workfile: IMAGE.H
//
//  Purpose:
//
//  Contents:
//

#ifndef _IMAGE_H_
#define _IMAGE_H_


#define IMAGE_VFL				0x00010000	// Vertical Filter (Use P_FILT_REG)

#define IMAGE_FL_0				0			// Horizontal Filter (Use P_FILT_REG)
#define IMAGE_FL_1				1			// Horizontal Filter (Use P_FILT_REG)
#define IMAGE_FL_2				2			// Horizontal Filter (Use P_FILT_REG)
#define IMAGE_FL_3				3			// Horizontal Filter (Use P_FILT_REG)
#define IMAGE_FL_4				4			// Horizontal Filter (Use P_FILT_REG)

#define IMAGE_CHGCOL_AVAIL		0x00010000	// Change Color (Use P_LUMI_REG)
#define IMAGE_CHGCOL_NOTAVAIL	0x00000000	// Not Change Color (Use P_LUMI_REG)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capirq.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"

/*
** HwInterrupt()
**
**   Routine is called when an interrupt at the IRQ level specified by the
**   ConfigInfo structure passed to the HwInitialize routine is received.
**
**   Note: IRQs may be shared, so the device should ensure the IRQ received
**         was expected
**
** Arguments:
**
**  pHwDevEx - the device extension for the hardware interrupt
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN 
HwInterrupt( 
    IN PHW_DEVICE_EXTENSION  pHwDevEx
    )
{

    BOOLEAN fMyIRQ = FALSE; 

    if (pHwDevEx->IRQExpected)
    {
        pHwDevEx->IRQExpected = FALSE;

        //
        // call the routine to handle the IRQ here
        //

        fMyIRQ = TRUE;
    }


    //
    // returning FALSE indicates that this was not an IRQ for this device, and
    // the IRQ dispatcher will pass the IRQ down the chain to the next handler
    // for this IRQ level
    //

    return(fMyIRQ);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capprop.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file handles all adapter property sets
//


#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "capxfer.h"
#define DEFINE_MEDIUMS
#include "mediums.h"

// -------------------------------------------------------------------
// A few notes about property set handling
//  
// Property sets used in Testcap are of two varieties, those that have
// default values, ranges, and stepping, such as VideoProcAmp and CameraControl,
// and those which don't have defaults and ranges, such as TVTuner and
// Crossbar.
// 
// Default values and stepping are established by tables in capprop.h,
// no code is required to implement this other than initally creating the tables.
// 
// Many of the property sets require the ability to modify a number
// of input parameters.  Since KS doesn't allow this inherently, you'll
// note that some property sets require copying the provided input parameters
// to the ouput parameter list, effectively creating a "read, modify, write"
// capability.  For this reason, the input and output parameter lists
// use identical structures.
//
// On an SRB_GET_DEVICE_PROPERTY, read-only input data to the driver is provided as:
//      pSrb->CommandData.PropertyInfo
//
// ... while the output data pointer is:
//      pSrb->CommandData.PropertyInfo.PropertyInfo
// 
// -------------------------------------------------------------------


// -------------------------------------------------------------------
// XBar pin definitions
// -------------------------------------------------------------------

typedef struct _XBAR_PIN_DESCRIPTION {
    ULONG       PinType;
    ULONG       SynthImageCommand;    // This driver simulates different inputs by synthesizing images
    ULONG       RelatedPinIndex;
    const KSPIN_MEDIUM *Medium;               // Describes hardware connectivity
} XBAR_PIN_DESCRIPTION, *PXBAR_PIN_DESCRIPTION;


XBAR_PIN_DESCRIPTION XBarInputPins[] = {

    // First list the video input pins, then the audio inputs, then the output pins
    // Note that audio pin index 6 is shared between two video inputs (index 1 and index 2)
    

    //    PinType                       SynthImageCommand                     RelatedPinIndex   Medium
    /*0*/ KS_PhysConn_Video_Tuner,         IMAGE_XFER_NTSC_EIA_100AMP_100SAT,    5,             &CrossbarMediums[0],
    /*1*/ KS_PhysConn_Video_Composite,     IMAGE_XFER_NTSC_EIA_75AMP_100SAT,     6,             &CrossbarMediums[1],
    /*2*/ KS_PhysConn_Video_SVideo,        IMAGE_XFER_BLACK,                     6,             &CrossbarMediums[2],
    /*3*/ KS_PhysConn_Video_Tuner,         IMAGE_XFER_WHITE,                     7,             &CrossbarMediums[3],
    /*4*/ KS_PhysConn_Video_Composite,     IMAGE_XFER_GRAY_INCREASING,           8,             &CrossbarMediums[4],
    
    /*5*/ KS_PhysConn_Audio_Tuner,         0,                                    0,             &CrossbarMediums[5],
    /*6*/ KS_PhysConn_Audio_Line,          0,                                    1,             &CrossbarMediums[6],
    /*7*/ KS_PhysConn_Audio_Tuner,         0,                                    3,             &CrossbarMediums[7],
    /*8*/ KS_PhysConn_Audio_Line,          0,                                    4,             &CrossbarMediums[8],

};
#define NUMBER_OF_XBAR_INPUTS       (SIZEOF_ARRAY (XBarInputPins))


XBAR_PIN_DESCRIPTION XBarOutputPins[] = {

    //    PinType                       SynthImageCommand                     RelatedPinIndex

    /*0*/ KS_PhysConn_Video_VideoDecoder,  0,                                    1,             &CrossbarMediums[9],
    /*1*/ KS_PhysConn_Audio_AudioDecoder,  0,                                    0,             &CrossbarMediums[10],
};
#define NUMBER_OF_XBAR_OUTPUTS      (SIZEOF_ARRAY (XBarOutputPins))

#define NUMBER_OF_XBAR_PINS_TOTAL   (NUMBER_OF_XBAR_INPUTS + NUMBER_OF_XBAR_OUTPUTS)


// -------------------------------------------------------------------
// XBar Property Set functions
// -------------------------------------------------------------------

/*
** AdapterSetCrossbarProperty ()
**
**    Handles Set operations on the Crossbar property set.
**      Testcap uses this to select an image to synthesize.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetCrossbarProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSPD->Property->Id;              // index of the property
    ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {
    case KSPROPERTY_CROSSBAR_ROUTE:                       //  W 
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute = 
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;   

        ASSERT (nS >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));


        // Default to failure
        pRoute->CanRoute = 0;

        // if video
        if (pRoute->IndexOutputPin == 0) {
            if (pRoute->IndexInputPin <= 4) {
                pHwDevExt->VideoInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
        }
        // if audio
        else if (pRoute->IndexOutputPin == 1) {
            // Special case!  Audio Routing of (-1) means mute!!!
            if (pRoute->IndexInputPin == -1) {
                pHwDevExt->AudioInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
            else if (pRoute->IndexInputPin > 4 && pRoute->IndexInputPin <= 8) {
                pHwDevExt->AudioInputConnected = pRoute->IndexInputPin;
                pRoute->CanRoute = 1;
            }
        }

        // Somebody passed bogus data
        if (pRoute->CanRoute == 0) {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }
    }
    break;


    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetCrossbarProperty ()
**
**    Handles Get operations on the Crossbar property set.
**      Testcap uses this to select an image to synthesize.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetCrossbarProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSPD->Property->Id;              // index of the property
    ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {

    case KSPROPERTY_CROSSBAR_CAPS:                  // R 
    {
        PKSPROPERTY_CROSSBAR_CAPS_S  pCaps = 
            (PKSPROPERTY_CROSSBAR_CAPS_S)pSPD->PropertyInfo;   

        if (nS < sizeof (KSPROPERTY_CROSSBAR_CAPS_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pCaps, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_CROSSBAR_CAPS_S));

        pCaps->NumberOfInputs  = NUMBER_OF_XBAR_INPUTS;
        pCaps->NumberOfOutputs = NUMBER_OF_XBAR_OUTPUTS;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_CAPS_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_CAN_ROUTE:                   // R 
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute = 
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;   

        if (nS < sizeof (KSPROPERTY_CROSSBAR_ROUTE_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Special case, audio output routed to (-1) means mute
        if (pRoute->IndexOutputPin == 1 && pRoute->IndexInputPin == -1) {
            pRoute->CanRoute = TRUE;
        }
        else if ((pRoute->IndexInputPin  >= NUMBER_OF_XBAR_INPUTS) ||
            (pRoute->IndexOutputPin >= NUMBER_OF_XBAR_OUTPUTS)) {

            pRoute->CanRoute = FALSE;
        }
        else if ((pRoute->IndexInputPin <= 4) &&
            (pRoute->IndexOutputPin == 0) ||
            (pRoute->IndexInputPin >= 5) &&
            (pRoute->IndexOutputPin == 1)) {

            // This driver allows any video input to connect to any video output
            // and any audio input to connect to any audio output
            pRoute->CanRoute = TRUE;
        }
        else {
            pRoute->CanRoute = FALSE;
        }
        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_ROUTE_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_PININFO:                     // R
    { 
        PKSPROPERTY_CROSSBAR_PININFO_S  pPinInfo = 
            (PKSPROPERTY_CROSSBAR_PININFO_S)pSPD->PropertyInfo;   

        if (nS < sizeof (KSPROPERTY_CROSSBAR_PININFO_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pPinInfo, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_CROSSBAR_PININFO_S));

        if (pPinInfo->Direction == KSPIN_DATAFLOW_IN) {

            ASSERT (pPinInfo->Index < NUMBER_OF_XBAR_INPUTS);
            if (pPinInfo->Index >= NUMBER_OF_XBAR_INPUTS) {
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pPinInfo->PinType          = XBarInputPins[pPinInfo->Index].PinType;
            pPinInfo->RelatedPinIndex  = XBarInputPins[pPinInfo->Index].RelatedPinIndex;
            pPinInfo->Medium           = *XBarInputPins[pPinInfo->Index].Medium;
        }
        else {

            ASSERT (pPinInfo->Index < NUMBER_OF_XBAR_OUTPUTS);
            if (pPinInfo->Index >= NUMBER_OF_XBAR_OUTPUTS) {
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pPinInfo->PinType          = XBarOutputPins[pPinInfo->Index].PinType;
            pPinInfo->RelatedPinIndex  = XBarOutputPins[pPinInfo->Index].RelatedPinIndex;
            pPinInfo->Medium           = *XBarOutputPins[pPinInfo->Index].Medium;
        }

        pPinInfo->Medium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_PININFO_S);
    }
    break;


    case KSPROPERTY_CROSSBAR_ROUTE:                   // R 
    {
        PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute = 
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;   

        if (nS < sizeof (KSPROPERTY_CROSSBAR_ROUTE_S))
            break;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pRoute, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

        // Sanity check
        if (pRoute->IndexOutputPin >= NUMBER_OF_XBAR_OUTPUTS) {
            pRoute->CanRoute = FALSE;
        }
        // querying the the video output pin
        else if (pRoute->IndexOutputPin == 0) {
            pRoute->IndexInputPin = pHwDevExt->VideoInputConnected;
            pRoute->CanRoute = TRUE;
        }
        // querying the the audio output pin
        else if (pRoute->IndexOutputPin == 1) {
            pRoute->IndexInputPin = pHwDevExt->AudioInputConnected;
            pRoute->CanRoute = TRUE;
        }
        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CROSSBAR_ROUTE_S);
    }
    break;


    default:
        TRAP;
        break;
    }
}

// -------------------------------------------------------------------
// TVTuner Property Set functions
// -------------------------------------------------------------------

/*
** AdapterSetTunerProperty ()
**
**    Handles Set operations on the TvTuner property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetTunerProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied

    switch (Id) {

    case KSPROPERTY_TUNER_MODE:
    {
         PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pSPD->Property;
         ASSERT (pMode->Mode & (KSPROPERTY_TUNER_MODE_TV       |
                                KSPROPERTY_TUNER_MODE_AM_RADIO |
                                KSPROPERTY_TUNER_MODE_FM_RADIO |
                                KSPROPERTY_TUNER_MODE_ATSC));
         pHwDevExt->TunerMode = pMode->Mode;
    }
    break;

    case KSPROPERTY_TUNER_STANDARD:
    {
        PKSPROPERTY_TUNER_STANDARD_S pStandard_S = 
            (PKSPROPERTY_TUNER_STANDARD_S) pSPD->Property;
        pHwDevExt->VideoStandard = pStandard_S->Standard;
    }
    break;

    case KSPROPERTY_TUNER_FREQUENCY:
    {
        PKSPROPERTY_TUNER_FREQUENCY_S pFreq_S = 
            (PKSPROPERTY_TUNER_FREQUENCY_S) pSPD->Property;
        pHwDevExt->Frequency = pFreq_S->Frequency;
        pHwDevExt->Country = pFreq_S->Country;
        pHwDevExt->Channel = pFreq_S->Channel;
    }
    break;

    case KSPROPERTY_TUNER_INPUT:
    {
        PKSPROPERTY_TUNER_INPUT_S pInput_S = 
            (PKSPROPERTY_TUNER_INPUT_S) pSPD->Property;
        pHwDevExt->TunerInput = pInput_S->InputIndex;
    }
    break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetTunerProperty ()
**
**    Handles Get operations on the TvTuner property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetTunerProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied
    PVOID pV = pSPD->PropertyInfo;              // pointer to the output data

    ASSERT (nS >= sizeof (LONG));

    switch (Id) {

    case KSPROPERTY_TUNER_CAPS:
    {
         PKSPROPERTY_TUNER_CAPS_S pCaps =
            (PKSPROPERTY_TUNER_CAPS_S)pSPD->Property;
         ASSERT (nS >= sizeof( KSPROPERTY_TUNER_CAPS_S ) );

         // now work with the output buffer
         pCaps =(PKSPROPERTY_TUNER_CAPS_S)pV;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pCaps, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_CAPS_S));

         pCaps->ModesSupported = 
             KSPROPERTY_TUNER_MODE_TV       |
             KSPROPERTY_TUNER_MODE_FM_RADIO |
             KSPROPERTY_TUNER_MODE_AM_RADIO |
             KSPROPERTY_TUNER_MODE_ATSC;

         pCaps->VideoMedium = TVTunerMediums[0];
         pCaps->VideoMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

         pCaps->TVAudioMedium = TVTunerMediums[1];
         pCaps->TVAudioMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

         pCaps->RadioAudioMedium = TVTunerMediums[2];   // No separate radio audio pin?
         pCaps->RadioAudioMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_CAPS_S );
    }
    break;

    case KSPROPERTY_TUNER_MODE:
    {
        PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pSPD->Property;
        ASSERT (nS >= sizeof( KSPROPERTY_TUNER_MODE_S ) );

        // now work with the output buffer
        pMode =(PKSPROPERTY_TUNER_MODE_S)pV;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pMode, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_MODE_S));

        pMode->Mode = pHwDevExt->TunerMode;

        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_S);
    }
    break;

    case KSPROPERTY_TUNER_MODE_CAPS:
    {
        PKSPROPERTY_TUNER_MODE_CAPS_S pCaps = 
                (PKSPROPERTY_TUNER_MODE_CAPS_S) pSPD->Property;

        ASSERT (nS >= sizeof (KSPROPERTY_TUNER_MODE_CAPS_S));

        // now work with the output buffer
        pCaps = (PKSPROPERTY_TUNER_MODE_CAPS_S) pV;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pCaps, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_MODE_CAPS_S));

        pCaps->Mode = ((PKSPROPERTY_TUNER_MODE_CAPS_S) pSPD->Property)->Mode;
        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_MODE_CAPS_S);

        switch (pCaps->Mode) {
        
        case KSPROPERTY_TUNER_MODE_TV:
        case KSPROPERTY_TUNER_MODE_ATSC:
            // List the formats actually supported by the tuner in this mode
            pCaps->StandardsSupported = 
                (pHwDevExt->TunerMode == KSPROPERTY_TUNER_MODE_ATSC) ?
                       KS_AnalogVideo_NTSC_M 
                :
                       KS_AnalogVideo_NTSC_M
    
                    |  KS_AnalogVideo_PAL_B    
                    |  KS_AnalogVideo_PAL_D    
                //  |  KS_AnalogVideo_PAL_H    
                //  |  KS_AnalogVideo_PAL_I    
                    |  KS_AnalogVideo_PAL_M    
                    |  KS_AnalogVideo_PAL_N    
                    |  KS_AnalogVideo_PAL_N_COMBO
    
                //  |  KS_AnalogVideo_SECAM_B  
                //  |  KS_AnalogVideo_SECAM_D  
                //  |  KS_AnalogVideo_SECAM_G  
                //  |  KS_AnalogVideo_SECAM_H  
                //  |  KS_AnalogVideo_SECAM_K  
                //  |  KS_AnalogVideo_SECAM_K1 
                //  |  KS_AnalogVideo_SECAM_L  
                    ;
    
            //
            // Get the min and max frequencies supported
            //
    
            pCaps->MinFrequency =  55250000L;
            pCaps->MaxFrequency = 997250000L;
    
            // What is the frequency step size?
            pCaps->TuningGranularity =  62500L;
    
            // How many inputs are on the tuner?
            pCaps->NumberOfInputs = 1;
    
            // What is the maximum settling time in milliseconds?
            pCaps->SettlingTime = 100;
        
            //
            // Strategy defines how the tuner knows when it is in tune:
            // 
            // KS_TUNER_STRATEGY_PLL (Has PLL offset information)
            // KS_TUNER_STRATEGY_SIGNAL_STRENGTH (has signal strength info)
            // KS_TUNER_STRATEGY_DRIVER_TUNES (driver handles all fine tuning)
            //
            pCaps->Strategy = KS_TUNER_STRATEGY_PLL;
            break;

        case KSPROPERTY_TUNER_MODE_FM_RADIO:
            pCaps->StandardsSupported = 0;
            pCaps->MinFrequency =  88100000L;
            pCaps->MaxFrequency = 107900000L;

            // What is the frequency step size?
            pCaps->TuningGranularity =  200000L;
    
            // How many inputs are on the tuner?
            pCaps->NumberOfInputs = 1;
    
            // What is the maximum settling time in milliseconds?
            pCaps->SettlingTime = 100;
            // Strategy defines how the tuner knows when it is in tune:
            pCaps->Strategy = KS_TUNER_STRATEGY_DRIVER_TUNES;
            break;

        case KSPROPERTY_TUNER_MODE_AM_RADIO:
            pCaps->StandardsSupported = 0;
            pCaps->MinFrequency =  540000L;
            pCaps->MaxFrequency = 1700000L;

            // What is the frequency step size?
            pCaps->TuningGranularity =  1000L;
    
            // How many inputs are on the tuner?
            pCaps->NumberOfInputs = 1;
    
            // What is the maximum settling time in milliseconds?
            pCaps->SettlingTime = 100;

            // Strategy defines how the tuner knows when it is in tune:
            pCaps->Strategy = KS_TUNER_STRATEGY_DRIVER_TUNES;
            break;

        default:
            ASSERT (FALSE);
            break;
        }
    }
    break;
        
    case KSPROPERTY_TUNER_STANDARD:
    {
        // What is the currently selected video standard?

        // Copy the input property info to the output property info
        RtlCopyMemory(  pSPD->PropertyInfo, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_STANDARD_S));

        ((PKSPROPERTY_TUNER_STANDARD_S) pSPD->PropertyInfo)->Standard =
                pHwDevExt->VideoStandard;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_STANDARD_S);
    }
    break;

    case KSPROPERTY_TUNER_INPUT:
    {
        // What is the currently selected input?

        // Copy the input property info to the output property info
        RtlCopyMemory(  pSPD->PropertyInfo,
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_INPUT_S));

        ((PKSPROPERTY_TUNER_INPUT_S) pSPD->PropertyInfo)->InputIndex = 
                pHwDevExt->TunerInput;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_INPUT_S);
    }
    break;


    case KSPROPERTY_TUNER_STATUS:

        // Return the status of the tuner

        // PLLOffset is in units of TuningGranularity 
        // SignalStrength is 0 to 100
        // Set Busy to 1 if tuning is still in process

        {
            PKSPROPERTY_TUNER_STATUS_S pStatus = 
                        (PKSPROPERTY_TUNER_STATUS_S) pSPD->PropertyInfo;

            ASSERT (nS >= sizeof (KSPROPERTY_TUNER_STATUS_S));

            // Copy the input property info to the output property info
            RtlCopyMemory(  pStatus, 
                            pSPD->Property, 
                            sizeof (KSPROPERTY_TUNER_STATUS_S));

            pStatus->CurrentFrequency = pHwDevExt->Frequency;
            pStatus->PLLOffset = 0;
            pStatus->SignalStrength = 100;
            pStatus->Busy = pHwDevExt->Busy;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_STATUS_S);
        }
        break;

    case KSPROPERTY_TUNER_IF_MEDIUM:
    {
        // Only Digital TV tuners should support this property
        PKSPROPERTY_TUNER_IF_MEDIUM_S pMedium =
           (PKSPROPERTY_TUNER_IF_MEDIUM_S)pSPD->Property;
        ASSERT (nS >= sizeof( KSPROPERTY_TUNER_IF_MEDIUM_S) );

        // now work with the output buffer
        pMedium =(PKSPROPERTY_TUNER_IF_MEDIUM_S)pV;

        // Copy the input property info to the output property info
        RtlCopyMemory(  pMedium, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TUNER_IF_MEDIUM_S));

        pMedium->IFMedium = TVTunerMediums[3];
        pMedium->IFMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TUNER_IF_MEDIUM_S);
    }
    break;

    default:
        TRAP;
        break;
    }
}

// -------------------------------------------------------------------
// VideoProcAmp functions
// -------------------------------------------------------------------

/*
** AdapterSetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

    switch (Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
        pHwDevExt->Brightness = pS->Value;
        pHwDevExt->BrightnessFlags = pS->Flags;
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
        pHwDevExt->Contrast = pS->Value;
        pHwDevExt->ContrastFlags = pS->Flags;
        break;

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        pHwDevExt->ColorEnable = pS->Value;
        pHwDevExt->ColorEnableFlags = pS->Flags;
        break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetVideoProcAmpProperty ()
**
**    Handles Get operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;  

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

    // Copy the input property info to the output property info
    RtlCopyMemory(  pS,
                    pSPD->Property, 
                    sizeof (KSPROPERTY_VIDEOPROCAMP_S));

    switch (Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
        pS->Value = pHwDevExt->Brightness;
        pS->Flags = pHwDevExt->BrightnessFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL | 
                           KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
        pS->Value = pHwDevExt->Contrast;
        pS->Flags = pHwDevExt->ContrastFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL | 
                           KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        break;

    case KSPROPERTY_VIDEOPROCAMP_COLORENABLE:
        pS->Value = pHwDevExt->ColorEnable;
        pS->Flags = pHwDevExt->ColorEnableFlags;
        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        break;

    default:
        TRAP;
        break;
    }
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOPROCAMP_S);
}

// -------------------------------------------------------------------
// CameraControl functions
// -------------------------------------------------------------------

/*
** AdapterSetCameraControlProperty ()
**
**    Handles Set operations on the CameraControl property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (Id) {

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        pHwDevExt->Zoom = pS->Value;
        pHwDevExt->ZoomFlags = pS->Flags;
        break;
        
    case KSPROPERTY_CAMERACONTROL_FOCUS:
        pHwDevExt->Focus = pS->Value;
        pHwDevExt->FocusFlags = pS->Flags;
        break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetCameraControlProperty ()
**
**    Handles Get operations on the CameraControl property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the output data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    // Copy the input property info to the output property info
    RtlCopyMemory(  pS,
                    pSPD->Property, 
                    sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (Id) {

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        pS->Value = pHwDevExt->Zoom;
        pS->Flags = pHwDevExt->ZoomFlags;
        pS->Capabilities = KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL | 
                           KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
        break;
        
    case KSPROPERTY_CAMERACONTROL_FOCUS:
        pS->Value = pHwDevExt->Focus;
        pS->Flags = pHwDevExt->FocusFlags;
        pS->Capabilities = KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL | 
                           KSPROPERTY_CAMERACONTROL_FLAGS_AUTO;
        break;

    default:
        TRAP;
        break;
    }
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CAMERACONTROL_S);
}

// -------------------------------------------------------------------
// TVAudio functions
// -------------------------------------------------------------------

/*
** AdapterSetTVAudioProperty ()
**
**    Handles Set operations on the TVAudio property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property


    switch (Id) {

    case KSPROPERTY_TVAUDIO_MODE:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    

        pHwDevExt->TVAudioMode = pS->Mode;
    }
    break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetTVAudioProperty ()
**
**    Handles Get operations on the TVAudio property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_TVAUDIO_CAPS:
    {
        PKSPROPERTY_TVAUDIO_CAPS_S pS = (PKSPROPERTY_TVAUDIO_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_CAPS_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TVAUDIO_CAPS_S));
        
        pS->InputMedium  = TVAudioMediums[0];
        pS->InputMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support
        pS->OutputMedium = TVAudioMediums[1];
        pS->OutputMedium.Id = pHwDevExt->DriverMediumInstanceCount;  // Multiple instance support

        // Report all of the possible audio decoding modes the hardware is capabable of
        pS->Capabilities = KS_TVAUDIO_MODE_MONO   |
                           KS_TVAUDIO_MODE_STEREO |
                           KS_TVAUDIO_MODE_LANG_A |
                           KS_TVAUDIO_MODE_LANG_B ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_CAPS_S);
    }
    break;
        
    case KSPROPERTY_TVAUDIO_MODE:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TVAUDIO_S));

        // Report the currently selected mode
        pS->Mode = pHwDevExt->TVAudioMode;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;

    case KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS,
                        pSPD->Property, 
                        sizeof (KSPROPERTY_TVAUDIO_S));

        // Report which audio modes could potentially be selected right now
        pS->Mode = KS_TVAUDIO_MODE_MONO   |
                   KS_TVAUDIO_MODE_STEREO |
                   KS_TVAUDIO_MODE_LANG_A ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;
    
    default:
        TRAP;
        break;
    }
}

// -------------------------------------------------------------------
// AnalogVideoDecoder functions
// -------------------------------------------------------------------

/*
** AdapterSetAnalogVideoDecoderProperty ()
**
**    Handles Set operations on the AnalogVideoDecoder property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetAnalogVideoDecoderProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));
    
    switch (Id) {

    case KSPROPERTY_VIDEODECODER_STANDARD:
    {
        pHwDevExt->VideoDecoderVideoStandard = pS->Value;
    }
    break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
    {
        pHwDevExt->VideoDecoderOutputEnable = pS->Value;
    }
    break;

    case KSPROPERTY_VIDEODECODER_VCR_TIMING:
    {
        pHwDevExt->VideoDecoderVCRTiming = pS->Value;
    }
    break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetAnalogVideoDecoderProperty ()
**
**    Handles Get operations on the AnalogVideoDecoder property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetAnalogVideoDecoderProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_VIDEODECODER_CAPS:
    {
        PKSPROPERTY_VIDEODECODER_CAPS_S pS = (PKSPROPERTY_VIDEODECODER_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_CAPS_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEODECODER_CAPS_S));
        
        pS->StandardsSupported =         
                   KS_AnalogVideo_NTSC_M

                |  KS_AnalogVideo_PAL_B    
                |  KS_AnalogVideo_PAL_D    
            //  |  KS_AnalogVideo_PAL_H    
            //  |  KS_AnalogVideo_PAL_I    
                |  KS_AnalogVideo_PAL_M    
                |  KS_AnalogVideo_PAL_N    

            //  |  KS_AnalogVideo_SECAM_B  
            //  |  KS_AnalogVideo_SECAM_D  
            //  |  KS_AnalogVideo_SECAM_G  
            //  |  KS_AnalogVideo_SECAM_H  
            //  |  KS_AnalogVideo_SECAM_K  
            //  |  KS_AnalogVideo_SECAM_K1 
            //  |  KS_AnalogVideo_SECAM_L  
                   ;

        pS->Capabilities = KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  |
                           KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING |
                           KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED ;


        pS->SettlingTime = 10;          // How long to delay after tuning before 
                                        // Locked indicator is valid
                                        
        pS->HSyncPerVSync = 6;          // HSync per VSync

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_CAPS_S);
    }
    break;
        
    case KSPROPERTY_VIDEODECODER_STANDARD:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderVideoStandard;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_STATUS:
    {
        PKSPROPERTY_VIDEODECODER_STATUS_S pS = (PKSPROPERTY_VIDEODECODER_STATUS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_STATUS_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEODECODER_STATUS_S));

        pS->NumberOfLines = (pHwDevExt->VideoDecoderVideoStandard & KS_AnalogVideo_NTSC_Mask)
                             ? 525 : 625;

        // Just to make things interesting, simulate that some channels aren't locked
        // In the US, these are channels 54 through 70
        pS->SignalLocked = (pHwDevExt->Frequency < 400000000 || pHwDevExt->Frequency > 500000000);

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderOutputEnable;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    case KSPROPERTY_VIDEODECODER_VCR_TIMING:
    {
        PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEODECODER_S));

        pS->Value = pHwDevExt->VideoDecoderVCRTiming;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
    }
    break;

    default:
        TRAP;
        break;
    }
}

// -------------------------------------------------------------------
// VideoControl functions
// -------------------------------------------------------------------

/*
** AdapterSetVideoControlProperty ()
**
**    Handles Set operations on the VideoControl property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterSetVideoControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEOCONTROL_MODE_S pS = (PKSPROPERTY_VIDEOCONTROL_MODE_S) pSPD->PropertyInfo;
    PSTREAMEX pStrmEx;
    ULONG StreamIndex;
    ULONG *pVideoControlMode;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pVideoControlMode = &pStrmEx->VideoControlMode;
    }
    else {
        pVideoControlMode = &pHwDevExt->VideoControlMode;
    }

    ASSERT (pSPD->PropertyInputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));
    
    switch (Id) {

    case KSPROPERTY_VIDEOCONTROL_MODE:
    {
        *pVideoControlMode = pS->Mode;
    }
    break;

    default:
        TRAP;
        break;
    }
}

/*
** AdapterGetVideoControlProperty ()
**
**    Handles Get operations on the VideoControl property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI
AdapterGetVideoControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PSTREAMEX pStrmEx;
    ULONG StreamIndex;
    ULONG *pVideoControlMode;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pVideoControlMode = &pStrmEx->VideoControlMode;
    }
    else {
        pVideoControlMode = &pHwDevExt->VideoControlMode;
    }

    switch (Id) {

    case KSPROPERTY_VIDEOCONTROL_CAPS:
    {
        PKSPROPERTY_VIDEOCONTROL_CAPS_S pS = (PKSPROPERTY_VIDEOCONTROL_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_CAPS_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEOCONTROL_CAPS_S));
        
        pS->VideoControlCaps =    
              KS_VideoControlFlag_FlipHorizontal       
//            | KS_VideoControlFlag_FlipVertical         
//            | KS_VideoControlFlag_ExternalTriggerEnable
//            | KS_VideoControlFlag_Trigger              
            ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_CAPS_S);
    }
    break;
        
    case KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE:
    {
        PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S pS = 
            (PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S));

        pS->CurrentActualFrameRate = 15;        // TODO: Implement the right rates in shipping drivers.
        pS->CurrentMaxAvailableFrameRate = 15;  // TODO: Implement the right rates in shipping drivers.
        

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S);
    }
    break;

    case KSPROPERTY_VIDEOCONTROL_FRAME_RATES:
    {
        // todo
    }
    break;

    case KSPROPERTY_VIDEOCONTROL_MODE:
    {
        PKSPROPERTY_VIDEOCONTROL_MODE_S pS = (PKSPROPERTY_VIDEOCONTROL_MODE_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));

        // Copy the input property info to the output property info
        RtlCopyMemory(  pS, 
                        pSPD->Property, 
                        sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S));

        pS->Mode = *pVideoControlMode;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCONTROL_MODE_S);
    }
    break;

    default:
        TRAP;
        break;
    }
}


/*
** AdapterGetVideoCompressionProperty()
**
**    Gets compressor settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetVideoCompressionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PCOMPRESSION_SETTINGS pCompressionSettings;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pCompressionSettings = &pStrmEx->CompressionSettings;
    }
    else {
        pCompressionSettings = &pHwDevExt->CompressionSettings;
    }


    switch (Id) {

    case KSPROPERTY_VIDEOCOMPRESSION_GETINFO:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S pS = 
                (PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S) pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(  pS, 
                            pSPD->Property, 
                            sizeof (KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S));

            pS->DefaultKeyFrameRate = 15;    // Key frame rate
            pS->DefaultPFrameRate = 3;       // Predeicted frames per Key frame
            pS->DefaultQuality = 5000;       // 0 to 10000
            pS->Capabilities = 
                       KS_CompressionCaps_CanQuality  |
                       KS_CompressionCaps_CanKeyFrame |
                       KS_CompressionCaps_CanBFrame   ;
            
            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S);
        }
        break;

    case KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS = 
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(  pS, 
                            pSPD->Property, 
                            sizeof (KSPROPERTY_VIDEOCOMPRESSION_S));

            pS->Value = pCompressionSettings->CompressionKeyFrameRate;
                
            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;
    
    case KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS = 
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(  pS, 
                            pSPD->Property, 
                            sizeof (KSPROPERTY_VIDEOCOMPRESSION_S));

            pS->Value = pCompressionSettings->CompressionPFramesPerKeyFrame;
                
            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;
    
    case KSPROPERTY_VIDEOCOMPRESSION_QUALITY:
        {
            PKSPROPERTY_VIDEOCOMPRESSION_S pS = 
                (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(  pS, 
                            pSPD->Property, 
                            sizeof (KSPROPERTY_VIDEOCOMPRESSION_S));

            pS->Value = pCompressionSettings->CompressionQuality;
                
            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOCOMPRESSION_S);
        }
        break;
    
    default:
        TRAP;
        break;
    }
}

/*
** AdapterSetVideoCompressionProperty()
**
**    Sets compressor settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetVideoCompressionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_VIDEOCOMPRESSION_S pS = (PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PCOMPRESSION_SETTINGS pCompressionSettings;

    // For this property set, the StreamIndex is always in the same place
    // for each property
    StreamIndex = ((PKSPROPERTY_VIDEOCOMPRESSION_S) pSPD->Property)->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    // If the stream is not opened when this property set is used,
    // store the values in the HwDevExt

    if (pStrmEx) {
        pCompressionSettings = &pStrmEx->CompressionSettings;
    }
    else {
        pCompressionSettings = &pHwDevExt->CompressionSettings;
    }

    switch (Id) {

    case KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE:
        {
            pCompressionSettings->CompressionKeyFrameRate = pS->Value;
        }
        break;
    
    case KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME:
        {
            pCompressionSettings->CompressionPFramesPerKeyFrame = pS->Value;
        }
        break;
    
    case KSPROPERTY_VIDEOCOMPRESSION_QUALITY:
        {
            pCompressionSettings->CompressionQuality = pS->Value;
        }
        break;

    default:
        TRAP;
        break;
    }
}


/*
** AdapterGetVBIProperty()
**
**    Gets VBI settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterGetVBIProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pSrb->HwDeviceExtension;
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PVBICAP_PROPERTIES_PROTECTION_S pS = 
        (PVBICAP_PROPERTIES_PROTECTION_S) pSPD->PropertyInfo;

    StreamIndex = pS->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    // Copy the input property info to the output property info
    RtlCopyMemory(  pS, 
                    pSPD->Property, 
                    sizeof (*pS));

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    pS->Status = 0;
    if (pHwDevExt->ProtectionStatus & KS_VBI_FLAG_MV_PRESENT)
        pS->Status |= KS_VBICAP_PROTECTION_MV_PRESENT;
    if (pHwDevExt->ProtectionStatus & KS_VBI_FLAG_MV_HARDWARE)
        pS->Status |= KS_VBICAP_PROTECTION_MV_HARDWARE;
    if (pHwDevExt->ProtectionStatus & KS_VBI_FLAG_MV_DETECTED)
        pS->Status |= KS_VBICAP_PROTECTION_MV_DETECTED;
        
    pSrb->ActualBytesTransferred = sizeof (*pS);
}

#if DBG
/*
** AdapterSetVBIProperty()
**
**    Sets VBI settings
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
AdapterSetVBIProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pSrb->HwDeviceExtension;
    PSTREAMEX pStrmEx;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG StreamIndex;
    PVBICAP_PROPERTIES_PROTECTION_S pS = 
        (PVBICAP_PROPERTIES_PROTECTION_S) pSPD->PropertyInfo;

    StreamIndex = pS->StreamIndex;

    ASSERT (StreamIndex < MAX_TESTCAP_STREAMS);

    // Verify the stream index is valid
    if (StreamIndex >= MAX_TESTCAP_STREAMS) {
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    pStrmEx = (PSTREAMEX) pHwDevExt->pStrmEx[StreamIndex];

    pHwDevExt->ProtectionStatus = 0;
    if (pS->Status & KS_VBICAP_PROTECTION_MV_PRESENT)
        pHwDevExt->ProtectionStatus |= KS_VBI_FLAG_MV_PRESENT;
    if (pS->Status & KS_VBICAP_PROTECTION_MV_HARDWARE)
        pHwDevExt->ProtectionStatus |= KS_VBI_FLAG_MV_HARDWARE;
    if (pS->Status & KS_VBICAP_PROTECTION_MV_DETECTED)
        pHwDevExt->ProtectionStatus |= KS_VBI_FLAG_MV_DETECTED;
}
#endif //DBG


// -------------------------------------------------------------------
// General entry point for all get/set adapter properties
// -------------------------------------------------------------------

/*
** AdapterSetProperty ()
**
**    Handles Set operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&PROPSETID_VIDCAP_CROSSBAR, &pSPD->Property->Set)) {
        AdapterSetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_TUNER, &pSPD->Property->Set)) {
        AdapterSetTunerProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterSetVideoProcAmpProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterSetCameraControlProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_TVAUDIO, &pSPD->Property->Set)) {
        AdapterSetTVAudioProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEODECODER, &pSPD->Property->Set)) {
        AdapterSetAnalogVideoDecoderProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterSetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterSetVideoCompressionProperty (pSrb);
    }
#if DBG
    // Can't normally set protection status; only allow this for DEBUGGING
    else if (IsEqualGUID (&KSPROPSETID_VBICAP_PROPERTIES, &pSPD->Property->Set)) {
        AdapterSetVBIProperty (pSrb);
    }
#endif //DBG
    else {
        //
        // We should never get here
        //

        TRAP;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** AdapterGetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (&PROPSETID_VIDCAP_CROSSBAR, &pSPD->Property->Set)) {
        AdapterGetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_TUNER, &pSPD->Property->Set)) {
        AdapterGetTunerProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterGetVideoProcAmpProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterGetCameraControlProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_TVAUDIO, &pSPD->Property->Set)) {
        AdapterGetTVAudioProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEODECODER, &pSPD->Property->Set)) {
        AdapterGetAnalogVideoDecoderProperty (pSrb);
    }
    else if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOCONTROL, &pSPD->Property->Set)) {
        AdapterGetVideoControlProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_VIDEOCOMPRESSION, &pSPD->Property->Set)) {
        AdapterGetVideoCompressionProperty (pSrb);
    }
    else if (IsEqualGUID (&KSPROPSETID_VBICAP_PROPERTIES, &pSPD->Property->Set)) {
        AdapterGetVBIProperty (pSrb);
    }
    else {
        //
        // We should never get here
        //

        TRAP;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

// ------------------------------------------------------------------------
// Property set for the Video Crossbar
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(XBarProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),     // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),     // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAN_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_PININFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),  // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

};

// ------------------------------------------------------------------------
// Property set for the TVTuner
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(TVTunerProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinProperty
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_FREQUENCY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_INPUT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinProperty
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinProperty
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_IF_MEDIUM,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_IF_MEDIUM_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_IF_MEDIUM_S),   // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )
};


// ------------------------------------------------------------------------
// Property set for the TVAudio
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(TVAudioProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        FALSE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] = 
{
    {
        10000 / 10,         // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        10000               // Maximum in (IRE * 100) units
    }
};

static const LONG BrightnessDefault = 5000;

static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
            1, 
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault,
    }    
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] = 
{
    {
        10000 / 256,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        10000               // Maximum in (gain * 100) units
    }
};

static const LONG ContrastDefault = 5000;

static KSPROPERTY_MEMBERSLIST ContrastMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (ContrastRangeAndStep),
            SIZEOF_ARRAY (ContrastRangeAndStep),
            0
        },
        (PVOID) ContrastRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ContrastDefault),
            1, 
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ContrastDefault,
    }    
};

static KSPROPERTY_VALUES ContrastValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ContrastMembersList),
    ContrastMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ColorEnableRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (this is a BOOL)
        0,                  // Reserved
        0,                  // Minimum 
        1                   // Maximum 
    }
};

static const LONG ColorEnableDefault = 1;

static KSPROPERTY_MEMBERSLIST ColorEnableMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (ColorEnableRangeAndStep),
            SIZEOF_ARRAY (ColorEnableRangeAndStep),
            0
        },
        (PVOID) ColorEnableRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ColorEnableDefault),
            1, 
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ColorEnableDefault,
    }    
};

static KSPROPERTY_VALUES ColorEnableValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ColorEnableMembersList),
    ColorEnableMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_CONTRAST,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ContrastValues,                        // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ColorEnableValues,                     // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for CameraControl
// ------------------------------------------------------------------------

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ZoomRangeAndStep [] = 
{
    {
        10000 / 10,         // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum 
        10000               // Maximum 
    }
};

static const LONG ZoomDefault = 5000;

static KSPROPERTY_MEMBERSLIST ZoomMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (ZoomRangeAndStep),
            SIZEOF_ARRAY (ZoomRangeAndStep),
            0
        },
        (PVOID) ZoomRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ZoomDefault),
            1, 
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ZoomDefault,
    }    
};

static KSPROPERTY_VALUES ZoomValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ZoomMembersList),
    ZoomMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG FocusRangeAndStep [] = 
{
    {
        10000 / 256,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum 
        10000               // Maximum 
    }
};

static const LONG FocusDefault = 5000;

static KSPROPERTY_MEMBERSLIST FocusMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (FocusRangeAndStep),
            SIZEOF_ARRAY (FocusRangeAndStep),
            0
        },
        (PVOID) FocusRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (FocusDefault),
            1, 
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &FocusDefault,
    }    
};

static KSPROPERTY_VALUES FocusValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (FocusMembersList),
    FocusMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(CameraControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_ZOOM,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &ZoomValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_FOCUS,   
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &FocusValues,                           // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for AnalogVideoDecoder
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(AnalogVideoDecoder)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_VCR_TIMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VideoControl
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSMULTIPLE_ITEM),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCONTROL_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinProperty
        sizeof(KSPROPERTY_VIDEOCONTROL_MODE_S), // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VideoCompression
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamCompressionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_GETINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S),// MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinProperty
        sizeof(KSPROPERTY_VIDEOCOMPRESSION_S),  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VBI
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VBIProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICAP_PROPERTIES_PROTECTION,
        TRUE,                                   // GetSupported or Handler
        sizeof(VBICAP_PROPERTIES_PROTECTION_S), // MinProperty
        sizeof(VBICAP_PROPERTIES_PROTECTION_S), // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CROSSBAR,             // Set
        SIZEOF_ARRAY(XBarProperties),           // PropertiesCount
        XBarProperties,                         // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_TUNER,
        SIZEOF_ARRAY(TVTunerProperties),
        TVTunerProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_TVAUDIO,
        SIZEOF_ARRAY(TVAudioProperties),
        TVAudioProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CAMERACONTROL,
        SIZEOF_ARRAY(CameraControlProperties),
        CameraControlProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOCONTROL,
        SIZEOF_ARRAY(VideoControlProperties),
        VideoControlProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEODECODER,
        SIZEOF_ARRAY(AnalogVideoDecoder),
        AnalogVideoDecoder,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOCOMPRESSION,             // Set
        SIZEOF_ARRAY(VideoStreamCompressionProperties), // PropertiesCount
        VideoStreamCompressionProperties,               // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VBICAP_PROPERTIES,                 // Set
        SIZEOF_ARRAY(VBIProperties),                    // PropertiesCount
        VBIProperties,                                  // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

};

#define NUMBER_OF_ADAPTER_PROPERTY_SETS (SIZEOF_ARRAY (AdapterPropertyTable))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capstrm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPSTRM_H__
#define __CAPSTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


KSPIN_MEDIUM StandardMedium = {
    STATIC_KSMEDIUMSETID_Standard,
    0, 0
};

// ------------------------------------------------------------------------
// Property sets for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,             // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

#define D_X 320
#define D_Y 240

static  KS_DATARANGE_VIDEO StreamFormatRGB24Bpp_Capture = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 3,                          // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70, //MEDIASUBTYPE_RGB24,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240


static  KS_DATARANGE_VIDEO StreamFormatUYU2_Capture = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_VIDEO,         // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, //MEDIASUBTYPE_UYVY,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   

        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 
    
#undef D_X
#undef D_Y

static  KS_DATARANGE_ANALOGVIDEO StreamFormatAnalogVideo = 
{
    // KS_DATARANGE_ANALOGVIDEO
    {   
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;                
        0, 0, 720, 480,         // rcTarget;        
        720,                    // dwActiveWidth;   
        480,                    // dwActiveHeight;  
        0,                      // REFERENCE_TIME  AvgTimePerFrame; 
    }
};

#define VBIStride (768*2)
#define VBISamples (768*2)
#define VBIStart   10
#define VBIEnd     21
#define VBILines (((VBIEnd)-(VBIStart))+1)
KS_DATARANGE_VIDEO_VBI StreamFormatVBI =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO_VBI ),
         0,
         VBIStride * VBILines,      // SampleSize
         0,                          // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VBI },
         { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
         { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
      }
   },
   TRUE,    // BOOL,  bFixedSizeSamples (all samples same size?)
   TRUE,    // BOOL,  bTemporalCompression (all I frames?)

   0,       // Reserved (was StreamDescriptionFlags)
   0,       // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         VBIStride, 480 /*VBILines*/   // SIZE InputSize
      },
      {
         VBISamples, VBILines   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         VBIStride, VBILines   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      1,           // int CropGranularityX;       // granularity of cropping size
      1,           // int CropGranularityY;
      1,           // int CropAlignX;             // alignment of cropping rect
      1,           // int CropAlignY;
      {
         VBISamples, VBILines   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         VBIStride, VBILines   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      0,          // ShrinkTapsX
      0,          // ShrinkTapsY
      166834,     // LONGLONG MinFrameInterval;  // 100 nS units
      166834,     // LONGLONG MaxFrameInterval;  // 16683.4uS == 1/60 sec
      VBIStride * VBILines * 8 * 30 * 2, // LONG MinBitsPerSecond;
      VBIStride * VBILines * 8 * 30 * 2  // LONG MaxBitsPerSecond;
   },

   // KS_VBIINFOHEADER (default format)
   {
      VBIStart,      // StartLine  -- inclusive
      VBIEnd,        // EndLine    -- inclusive
      KS_VBISAMPLINGRATE_5X_NABTS,   // SamplingFrequency;   Hz.
      732,           // MinLineStartTime;
      732,           // MaxLineStartTime;
      732,           // ActualLineStartTime
      0,             // ActualLineEndTime;
      KS_AnalogVideo_NTSC_M,      // VideoStandard;
      VBISamples,       // SamplesPerLine;
      VBIStride,       // StrideInBytes;
      VBIStride * VBILines   // BufferSize;
   }
};

// output is NABTS records
KSDATARANGE StreamFormatNABTS =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTS_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_VBI },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};

KSDATARANGE StreamFormatCC = 
{
    // Definition of the CC stream
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
        sizeof (CC_HW_FIELD),           // SampleSize
        0,                              // Reserved
        { STATIC_KSDATAFORMAT_TYPE_VBI },
        { STATIC_KSDATAFORMAT_SUBTYPE_CC },
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
    }
};


//---------------------------------------------------------------------------
//  STREAM_Capture Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT StreamCaptureFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatRGB24Bpp_Capture,
    (PKSDATAFORMAT) &StreamFormatUYU2_Capture,
};
#define NUM_STREAM_CAPTURE_FORMATS (SIZEOF_ARRAY(StreamCaptureFormats))

//---------------------------------------------------------------------------
//  STREAM_Preview Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT StreamPreviewFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatRGB24Bpp_Capture,
    (PKSDATAFORMAT) &StreamFormatUYU2_Capture,
};
#define NUM_STREAM_PREVIEW_FORMATS (SIZEOF_ARRAY (StreamPreviewFormats))

//---------------------------------------------------------------------------
//  STREAM_VBI Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT StreamVBIFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVBI,
};
#define NUM_STREAM_VBI_FORMATS (SIZEOF_ARRAY(StreamVBIFormats))

//---------------------------------------------------------------------------
//  STREAM_NABTS Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT StreamNABTSFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatNABTS,
};
#define NUM_STREAM_NABTS_FORMATS (SIZEOF_ARRAY(StreamNABTSFormats))

static PKSDATAFORMAT StreamCCFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatCC,
};
#define NUM_STREAM_CC_FORMATS (SIZEOF_ARRAY (StreamCCFormats))

//---------------------------------------------------------------------------
//  STREAM_AnalogVideoInput Formats
//---------------------------------------------------------------------------

static  PKSDATAFORMAT StreamAnalogVidInFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatAnalogVideo,
};
#define NUM_STREAM_ANALOGVIDIN_FORMATS (SIZEOF_ARRAY (StreamAnalogVidInFormats))

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

// Warning:  The StreamNumber element of the HW_STREAM_OBJECT below MUST be
//           the same as its position in the Streams[] array.
static  ALL_STREAM_INFO Streams [] = 
{
  // -----------------------------------------------------------------
  // STREAM_Capture
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_CAPTURE_FORMATS,             // NumberOfFormatArrayEntries
    StreamCaptureFormats,                   // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET) VideoStreamProperties,// StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_CAPTURE,        // Category
    (GUID *) &PINNAME_VIDEO_CAPTURE,        // Name
    1,                                      // MediumsCount
    &StandardMedium,                        // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_Capture,                         // StreamNumber
    0,                                      // HwStreamExtension
    VideoReceiveDataPacket,                 // HwReceiveDataPacket
    VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    NULL,                                   // HwDeviceExtension
    sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },            
 },
 // -----------------------------------------------------------------
 // STREAM_Preview
 // -----------------------------------------------------------------
 {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_PREVIEW_FORMATS,             // NumberOfFormatArrayEntries
    StreamPreviewFormats,                   // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET) VideoStreamProperties,// StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_PREVIEW,        // Category
    (GUID *) &PINNAME_VIDEO_PREVIEW,        // Name
    1,                                      // MediumsCount
    &StandardMedium,                        // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_Preview,                         // StreamNumber
    0,                                      // HwStreamExtension
    VideoReceiveDataPacket,                 // HwReceiveDataPacket
    VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    0,                                      // HwDeviceExtension
    sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
 },
  // -----------------------------------------------------------------
  // STREAM_VBI
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_VBI_FORMATS,                 // NumberOfFormatArrayEntries
    StreamVBIFormats,                       // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries
    0,                                      // StreamEventsArray
    (GUID *)&PINNAME_VIDEO_VBI,             // Category
    (GUID *)&PINNAME_VIDEO_VBI,             // Name
    0,                                      // MediumsCount
    NULL,                                   // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_VBI,                             // StreamNumber
    (PVOID)NULL,                            // HwStreamExtension
    VBIReceiveDataPacket,                   // HwReceiveDataPacket
    VBIReceiveCtrlPacket,                   // HwReceiveControlPacket
    {                                       // HW_CLOCK_OBJECT
        NULL,                                // .HWClockFunction
        0,                                   // .ClockSupportFlags
    },
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    (PVOID)NULL,                            // HwDeviceExtension
    sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
  },
  // -----------------------------------------------------------------
  // STREAM_CC (Closed Caption Output)
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_CC_FORMATS,                  // NumberOfFormatArrayEntries
    StreamCCFormats,                        // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *)&PINNAME_VIDEO_CC_CAPTURE,      // Category
    (GUID *)&PINNAME_VIDEO_CC_CAPTURE,      // Name
    0,                                      // MediumsCount
    NULL,                                   // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_CC,                              // StreamNumber
    (PVOID)NULL,                            // HwStreamExtension
    VBIReceiveDataPacket,                   // HwReceiveDataPacket
    VBIReceiveCtrlPacket,                   // HwReceiveControlPacket
    {                                       // HW_CLOCK_OBJECT
        NULL,                                // .HWClockFunction
        0,                                   // .ClockSupportFlags
    },
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    (PVOID)NULL,                            // HwDeviceExtension
    0,                                      // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
  },
  // -----------------------------------------------------------------
  // STREAM_NABTS
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_OUT,                     // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_NABTS_FORMATS,               // NumberOfFormatArrayEntries
    StreamNABTSFormats,                     // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
    (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries
    0,                                      // StreamEventsArray
    (GUID *)&PINNAME_VIDEO_NABTS_CAPTURE,   // Category
    (GUID *)&PINNAME_VIDEO_NABTS_CAPTURE,   // Name
    0,                                      // MediumsCount
    NULL,                                   // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_NABTS,                           // StreamNumber
    (PVOID)NULL,                            // HwStreamExtension
    VBIReceiveDataPacket,                   // HwReceiveDataPacket
    VBIReceiveCtrlPacket,                   // HwReceiveControlPacket
    {                                       // HW_CLOCK_OBJECT
        NULL,                                // .HWClockFunction
        0,                                   // .ClockSupportFlags
    },
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    (PVOID)NULL,                            // HwDeviceExtension
    0,                                      // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    },
  },
 // -----------------------------------------------------------------
 // STREAM_AnalogVideoInput
 // -----------------------------------------------------------------
 {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
    1,                                      // NumberOfPossibleInstances
    KSPIN_DATAFLOW_IN,                      // DataFlow
    TRUE,                                   // DataAccessible
    NUM_STREAM_ANALOGVIDIN_FORMATS,         // NumberOfFormatArrayEntries
    StreamAnalogVidInFormats,               // StreamFormatsArray
    0,                                      // ClassReserved[0]
    0,                                      // ClassReserved[1]
    0,                                      // ClassReserved[2]
    0,                                      // ClassReserved[3]
    0,                                      // NumStreamPropArrayEntries
    0,                                      // StreamPropertiesArray
    0,                                      // NumStreamEventArrayEntries;
    0,                                      // StreamEventsArray;
    (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Category
    (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Name
    1,                                      // MediumsCount
    &CrossbarMediums[9],                    // Mediums
    FALSE,                                  // BridgeStream
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
    sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
    STREAM_AnalogVideoInput,                // StreamNumber
    0,                                      // HwStreamExtension
    AnalogVideoReceiveDataPacket,           // HwReceiveDataPacket
    AnalogVideoReceiveCtrlPacket,           // HwReceiveControlPacket
    { NULL, 0 },                            // HW_CLOCK_OBJECT
    FALSE,                                  // Dma
    TRUE,                                   // Pio
    0,                                      // HwDeviceExtension
    0,                                      // StreamHeaderMediaSpecific
    0,                                      // StreamHeaderWorkspace 
    FALSE,                                  // Allocator 
    NULL,                                   // HwEventRoutine
    { 0, 0 },                               // Reserved[2]
    }
  }
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static const GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_KSCATEGORY_TVTUNER,
    STATIC_KSCATEGORY_CROSSBAR,
    STATIC_KSCATEGORY_TVAUDIO
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)


static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,               // CategoriesCount
    (GUID*) &Categories,                // Categories
    0,                                  // TopologyNodesCount
    NULL,                               // TopologyNodes
    0,                                  // TopologyConnectionsCount
    NULL,                               // TopologyConnections
    NULL,                               // TopologyNodesNames
    0,                                  // Reserved
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader = 
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __CAPSTRM_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capvbi.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "vbixfer.h"
#include "ntstatus.h"


/*
** VBICaptureRoutine()
**
**    Routine to generate video frames based on a timer.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VBICaptureRoutine(
    IN PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PKSSTREAM_HEADER        pDataPacket;
    PKS_VBI_FRAME_INFO      pVBIFrameInfo;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {  
        return;
    }

    
    // Find out what time it is, if we're using a clock

    if (pStrmEx->hMasterClock) {
        HW_TIME_CONTEXT TimeContext;

        TimeContext.HwDeviceExtension = pHwDevExt; 
        TimeContext.HwStreamObject = pStrmEx->pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
                pStrmEx->hMasterClock,
                &TimeContext);

        pStrmEx->QST_StreamTime = TimeContext.Time;
        pStrmEx->QST_Now = TimeContext.SystemTime;
    
        if (pStrmEx->QST_NextFrame == 0) {  
            pStrmEx->QST_NextFrame =
                pStrmEx->QST_StreamTime
                + pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;
        }

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        DbgLogTrace(("TestCap:    Time=%16lx\n", TimeContext.Time));
        DbgLogTrace(("TestCap: SysTime=%16lx\n", TimeContext.SystemTime));
#endif
    }


    // Only capture in the RUN state

    if (pStrmEx->KSState == KSSTATE_RUN) {  

        //
        // Determine if it is time to capture a frame based on 
        // how much time has elapsed since capture started.
        // If there isn't a clock available, then capture immediately.
        //

        if ((!pStrmEx->hMasterClock) ||
             (pStrmEx->QST_StreamTime >= pStrmEx->QST_NextFrame)) {

            PHW_STREAM_REQUEST_BLOCK pSrb;

            // Increment the picture count (usually this is VSYNC count)

            pStrmEx->VBIFrameInfo.PictureNumber++;

            //
            // Get the next queue SRB (if any)
            //

            pSrb = VideoQueueRemoveSRB (pHwDevExt, StreamNumber);

            if (pSrb) {

                pDataPacket = pSrb->CommandData.DataBufferArray;
                pVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pDataPacket + 1);

                pStrmEx->VBIFrameInfo.dwFrameFlags = 0;

                //
                // If needed, send out VBIInfoHeader
                //
                if (!(pStrmEx->SentVBIInfoHeader)) {
                    pStrmEx->SentVBIInfoHeader = 1;
                    pStrmEx->VBIFrameInfo.dwFrameFlags |=
                            KS_VBI_FLAG_VBIINFOHEADER_CHANGE;
                    pStrmEx->VBIFrameInfo.VBIInfoHeader = StreamFormatVBI.VBIInfoHeader;
                }

                // Set additional info fields about the data captured such as:
                //   Frames Captured
                //   Frames Dropped
                //   Field Polarity
                //   Protection status
                //
                pStrmEx->VBIFrameInfo.ExtendedHeaderSize =
                    pVBIFrameInfo->ExtendedHeaderSize;

                if (pStrmEx->VBIFrameInfo.PictureNumber & 1)
                    pStrmEx->VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_FIELD1;
                else
                    pStrmEx->VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_FIELD2;

                pStrmEx->VBIFrameInfo.dwFrameFlags |=
                    pHwDevExt->ProtectionStatus & (KS_VBI_FLAG_MV_PRESENT
                                                    |KS_VBI_FLAG_MV_HARDWARE
                                                    |KS_VBI_FLAG_MV_DETECTED);

                *pVBIFrameInfo = pStrmEx->VBIFrameInfo;

                // Copy this into stream header so ring 3 filters can see it
                pDataPacket->TypeSpecificFlags = pVBIFrameInfo->dwFrameFlags;

                // Init the flags to zero
                pDataPacket->OptionsFlags = 0;

                // Set the discontinuity flag if frames have been previously
                // dropped, and then reset our internal flag

                if (pStrmEx->fDiscontinuity) {
                    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    pStrmEx->fDiscontinuity = FALSE;
                }

                //
                // Return the timestamp for the frame
                //
                pDataPacket->PresentationTime.Numerator = 1;
                pDataPacket->PresentationTime.Denominator = 1;
                pDataPacket->Duration = pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;

                //
                // if we have a master clock AND this is a capture stream
                // 
                if (pStrmEx->hMasterClock
                    && (StreamNumber == STREAM_Capture
                            || StreamNumber == STREAM_VBI))
                {

                    pDataPacket->PresentationTime.Time = pStrmEx->QST_StreamTime;
                    pDataPacket->OptionsFlags |= 
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
                }
                else {
                    //
                    // No clock or not a capture stream,
                    //  so just mark the time as unknown
                    //
                    pDataPacket->PresentationTime.Time = 0;
                    // clear the timestamp valid flags
                    pDataPacket->OptionsFlags &= 
                        ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                          KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
                }

                // Every frame we generate is a key frame (aka SplicePoint)
                // Delta frames (B or P) should not set this flag

                pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

                //
                // Call the routine which synthesizes images
                //
                VBI_ImageSynth(pSrb);

                // Output a frame count every 300th frame (~5 sec) in Debug mode
                if (pStrmEx->VBIFrameInfo.PictureNumber % 300 == 0) {
                   DbgLogInfo(("TestCap: Picture %u, Stream=%d\n", 
                           (unsigned int)pStrmEx->VBIFrameInfo.PictureNumber, 
                           StreamNumber));
                }

                CompleteStreamSRB(pSrb);
                
            } // if we have an SRB

            else {

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // dropped frames

                pStrmEx->VBIFrameInfo.DropCount++;

                // Set the (local) discontinuity flag
                // This will cause the next packet processed to have the
                //   KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag set.

                pStrmEx->fDiscontinuity = TRUE;

            }

            // Figure out when to capture the next frame
            pStrmEx->QST_NextFrame += pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;

        } // endif time to capture a frame
    } // endif we're running
}


/*
** VBIhwCaptureRoutine()
**
**    Routine to capture video frames based on a timer.
**
**    Notes:  * Devices capable of using interrupts should always trigger
**              capture on a VSYNC interrupt, and not use a timer.
**            * This routine is used by VBI streams which do NOT have extended
**              headers, such as CC and NABTS.
**
** Arguments:
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VBIhwCaptureRoutine(
    IN PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PKSSTREAM_HEADER        pDataPacket;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {  
        return;
    }

    
    // Find out what time it is, if we're using a clock

    if (pStrmEx->hMasterClock ) {
        HW_TIME_CONTEXT TimeContext;

        TimeContext.HwDeviceExtension = pHwDevExt; 
        TimeContext.HwStreamObject = pStrmEx->pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
                pStrmEx->hMasterClock,
                &TimeContext);

        pStrmEx->QST_StreamTime = TimeContext.Time;
        pStrmEx->QST_Now = TimeContext.SystemTime;
    
        if (pStrmEx->QST_NextFrame == 0) {  
            pStrmEx->QST_NextFrame =
                pStrmEx->QST_StreamTime
                + pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;
        }

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        DbgLogTrace(("TestCap:    Time=%16lx\n", TimeContext.Time));
        DbgLogTrace(("TestCap: SysTime=%16lx\n", TimeContext.SystemTime));
#endif
    }


    // Only capture in the RUN state

    if (pStrmEx->KSState == KSSTATE_RUN) {  

        //
        // Determine if it is time to capture a frame based on 
        // how much time has elapsed since capture started.
        // If there isn't a clock available, then capture immediately.
        //

        if ((!pStrmEx->hMasterClock) ||
             (pStrmEx->QST_StreamTime >= pStrmEx->QST_NextFrame)) {

            PHW_STREAM_REQUEST_BLOCK pSrb;

            // Increment the picture count (usually this is VSYNC count)

            pStrmEx->VBIFrameInfo.PictureNumber++;

            //
            // Get the next queue SRB (if any)
            //

            pSrb = VideoQueueRemoveSRB (pHwDevExt, StreamNumber);

            if (pSrb) {

                pDataPacket = pSrb->CommandData.DataBufferArray;

                // Init the flags to zero
                pDataPacket->OptionsFlags = 0;

                // Set the discontinuity flag if frames have been previously
                // dropped, and then reset our internal flag
                if (pStrmEx->fDiscontinuity) {
                    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    pStrmEx->fDiscontinuity = FALSE;
                }

                //
                // Return the timestamp for the frame
                //
                pDataPacket->PresentationTime.Numerator = 1;
                pDataPacket->PresentationTime.Denominator = 1;
                pDataPacket->Duration = pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;

                //
                // if we have a master clock AND this is the capture stream
                // 
                if (pStrmEx->hMasterClock && (StreamNumber == 0)) {

                    pDataPacket->PresentationTime.Time = pStrmEx->QST_StreamTime;
                    pDataPacket->OptionsFlags |= 
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
                }
                else {
                    //
                    // No clock or the preview stream,
                    //  so just mark the time as unknown
                    //
                    pDataPacket->PresentationTime.Time = 0;
                    // clear the timestamp valid flags
                    pDataPacket->OptionsFlags &= 
                        ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                          KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
                }

                // Every frame we generate is a key frame (aka SplicePoint)
                // Delta frames (B or P) should not set this flag

                pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

                //
                // Call the routine which synthesizes images
                //
                switch (StreamNumber) {
                    case STREAM_NABTS:
                        NABTS_ImageSynth(pSrb);
                        break;

                    case STREAM_CC:
                        CC_ImageSynth(pSrb);
                        break;

                    default:
                    case STREAM_VBI:
                        DbgLogError(("TestCap::VBIhwCaptureRoutine: Bad stream %d\n", StreamNumber));
                        break;
                }

                CompleteStreamSRB (pSrb);
                
            } // if we have an SRB

            else {

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // dropped frames

                pStrmEx->VBIFrameInfo.DropCount++;

                // Set the (local) discontinuity flag
                // This will cause the next packet processed to have the
                //   KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag set.

                pStrmEx->fDiscontinuity = TRUE;

            }

            // Figure out when to capture the next frame
            pStrmEx->QST_NextFrame += pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval;

        } // endif time to capture a frame
    } // endif we're running
}


/*
** VBITimerRoutine()
**
**    A timer has been created based on the requested capture interval.
**    This is the callback routine for this timer event.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
**    Context - pointer to the stream extension
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VBITimerRoutine(
    PVOID Context
    )
{
    PSTREAMEX              pStrmEx = ((PSTREAMEX)Context);
    PHW_DEVICE_EXTENSION   pHwDevExt = pStrmEx->pHwDevExt;
    int                    StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    ULONG                  interval;
    
    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP)
        return;

    // Calculate next interval
    interval = (ULONG)(pStrmEx->pVBIStreamFormat->ConfigCaps.MinFrameInterval / 10);
    interval /= 2;  // Run at 2x noted rate for accuracy

    // Capture a frame if it's time and we have a buffer
    switch (StreamNumber) {
        case STREAM_NABTS:
            VBIhwCaptureRoutine(pStrmEx);
            break;

        case STREAM_CC:
            VBIhwCaptureRoutine(pStrmEx);
            break;

        default:
        case STREAM_VBI:
            VBICaptureRoutine(pStrmEx);
            break;
    }

    // Schedule the next timer event
    StreamClassScheduleTimer (
            pStrmEx->pStreamObject,     // StreamObject
            pHwDevExt,                  // HwDeviceExtension
            interval,                   // Microseconds
            VBITimerRoutine,            // TimerRoutine
            pStrmEx);                   // Context
}


/*
** VBISetState()
**
**    Sets the current state for a given stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
VBISetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION  pHwDevExt = pSrb->HwDeviceExtension;
    PSTREAMEX             pStrmEx = pSrb->StreamObject->HwStreamExtension;
    int                   StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    KSSTATE               PreviousState;

    //
    // Remember the state we're transitioning away from
    //

    PreviousState = pStrmEx->KSState;

    //
    // Set the new state
    //

    pStrmEx->KSState = pSrb->CommandData.StreamState;

    switch (pSrb->CommandData.StreamState)  

    {
    case KSSTATE_STOP:

        //
        // The stream class will cancel all outstanding IRPs for us
        // (but only if it is maintaining the queue ie. using Stream Class synchronization)
        // Since Testcap is not using Stream Class synchronization, we must clear the queue here

        VideoQueueCancelAllSRBs (pStrmEx);

        pStrmEx->SentVBIInfoHeader = 0;     // Send out a fresh one next RUN

        DbgLogInfo(("TestCap: STATE Stopped, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_ACQUIRE:

        //
        // This is a KS only state, that has no correspondence in DirectShow
        // 
        DbgLogInfo(("TestCap: STATE Acquire, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_PAUSE:

        //
        // On a transition to pause from acquire or stop, start our timer running.
        //

        if (PreviousState == KSSTATE_ACQUIRE || PreviousState == KSSTATE_STOP) {  

            // Zero the frame counters
            pStrmEx->VBIFrameInfo.PictureNumber = 0;
            pStrmEx->VBIFrameInfo.DropCount = 0;
            pStrmEx->VBIFrameInfo.dwFrameFlags = 0;

            // Setup the next timer callback
            VBITimerRoutine(pStrmEx);
        }
        DbgLogInfo(("TestCap: STATE Pause, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_RUN:

        // 
        // Begin Streaming.
        //

        // Reset the discontinuity flag

        pStrmEx->fDiscontinuity = FALSE;

        // Setting the NextFrame time to zero will cause the value to be
        // reset from the stream time 

        pStrmEx->QST_NextFrame = 0;

        DbgLogInfo(("TestCap: STATE Run, Stream=%d\n", StreamNumber));
        break;

    } // end switch (pSrb->CommandData.StreamState)  
}


/*
** VBIReceiveCtrlPacket()
**
**   Receives packet commands that control all the VBI (VBI/NABTS/CC) streams
**
** Arguments:
**
**   pSrb - The stream request block for the VBI stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VBIReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION  pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX             pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                   StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    BOOL                  Busy;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt != 0);

    DbgLogInfo(("TestCap: Receiving %s Stream Control SRB %p, %x\n",
            (StreamNumber == STREAM_VBI)? "VBI"
            : (StreamNumber == STREAM_NABTS)? "NABTS"
            : (StreamNumber == STREAM_CC)? "CC"
            : "???",
             pSrb,
             pSrb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    do {

        // 
        // Default to success
        //
    
        pSrb->Status = STATUS_SUCCESS;
    
        //
        // determine the type of packet.
        //
    
        switch (pSrb->Command)
        {
        case SRB_PROPOSE_DATA_FORMAT:
            DbgLogInfo(("TestCap: Receiving SRB_PROPOSE_DATA_FORMAT  SRB %p, StreamNumber= %d\n", pSrb, StreamNumber));
            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat, 
                    pSrb->StreamObject->StreamNumber)))
        {
                pSrb->Status = STATUS_NO_MATCH;
            }
            break;

        case SRB_SET_DATA_FORMAT:
            DbgLogInfo(("TestCap: SRB_SET_DATA_FORMAT"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case SRB_GET_DATA_FORMAT:
            DbgLogInfo(("TestCap: SRB_GET_DATA_FORMAT"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    

        case SRB_SET_STREAM_STATE:
            VBISetState(pSrb);
            break;
    
        case SRB_GET_STREAM_STATE:
            VideoGetState(pSrb);
            break;
    
        case SRB_GET_STREAM_PROPERTY:
            VideoGetProperty(pSrb);
            break;
    
        case SRB_INDICATE_MASTER_CLOCK:
            VideoIndicateMasterClock(pSrb);
            break;
    
        default:
            //
            // invalid / unsupported command. Fail it as such
            //
    
            TRAP;
    
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }
    
        CompleteStreamSRB (pSrb);

        // 
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);
    } while (Busy);
}

/*
** VBIReceiveDataPacket()
**
**   Receives VBI data packet commands on the output streams
**
** Arguments:
**
**   pSrb - Stream request block for the VBI stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VBIReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt != 0);

    DbgLogTrace(("'TestCap: Receiving VBI Stream Data    SRB %p, %x\n", pSrb, pSrb->Command));

    // 
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //

    switch (pSrb->Command){

    case SRB_READ_DATA:

        // Rule: 
        // Only accept read requests when in either the Pause or Run
        // States.  If Stopped, immediately return the SRB.

        if (pStrmEx->KSState == KSSTATE_STOP) {

            CompleteStreamSRB (pSrb);

            break;
        } 
        
        //
        // Put this read request on the pending queue
        //

        VideoQueueAddSRB (pSrb);

        // Since another thread COULD HAVE MODIFIED THE STREAM STATE
        // in the midst of adding it to the queue, check the stream
        // state again, and cancel the SRB if necessary.  Note that
        // this race condition was NOT handled in the original DDK
        // release of testcap!

        if (pStrmEx->KSState == KSSTATE_STOP) {

            VideoQueueCancelOneSRB (
                pStrmEx,
                pSrb);
        }
    
        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP;

        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        CompleteStreamSRB (pSrb);

    }  // switch (pSrb->Command)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capxfer.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "capxfer.h"

//
// EIA-189-A Standard color bar definitions
//

// 75% Amplitude, 100% Saturation
const static UCHAR NTSCColorBars75Amp100SatRGB24 [3][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    191,  0,191,  0,191,  0,191,  0,    // Blue
    191,191,191,191,  0,  0,  0,  0,    // Green
    191,191,  0,  0,191,191,  0,  0,    // Red
};

// 100% Amplitude, 100% Saturation
const static UCHAR NTSCColorBars100Amp100SatRGB24 [3][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    255,  0,255,  0,255,  0,255,  0,    // Blue
    255,255,255,255,  0,  0,  0,  0,    // Green
    255,255,  0,  0,255,255,  0,  0,    // Red
};

const static UCHAR NTSCColorBars100Amp100SatYUV [4][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    128, 16,166, 54,202, 90,240,128,    // U
    235,211,170,145,106, 81, 41, 16,    // Y
    128,146, 16, 34,222,240,109,128,    // V
    235,211,170,145,106, 81, 41, 16     // Y
};

/*
** ImageSynth()
**
**   Synthesizes NTSC color bars, white, black, and grayscale images
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**   ImageXferCommands - Index specifying the image to generate
**
** Returns:
**
**   Nothing
**
** Side Effects:  none
*/

void ImageSynth (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb,
    IN ImageXferCommands Command,
    IN BOOL FlipHorizontal
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    UINT                    Line;
    PUCHAR                  pLineBuffer;
    PKSSTREAM_HEADER        pDataPacket = pSrb->CommandData.DataBufferArray;
    PUCHAR                  pImage =  pDataPacket->Data;
    KS_VIDEOINFOHEADER      *pVideoInfoHdr;
    UINT                    biWidth;
    UINT                    biHeight;
    UINT                    biSizeImage;
    UINT                    biWidthBytes;
    UINT                    biBitCount;
    UINT                    LinesToCopy;
    DWORD                   biCompression;
    KIRQL                   oldIrql;
    
    //
    // Take the lock to avoid race from Set format property that could
    // from other processor in an MP system
    //
    KeAcquireSpinLock( &pStrmEx->lockVideoInfoHeader, &oldIrql );
    pVideoInfoHdr = pStrmEx->pVideoInfoHeader;

    biWidth        =   pVideoInfoHdr->bmiHeader.biWidth;
    biHeight       =   pVideoInfoHdr->bmiHeader.biHeight;
    biSizeImage    =   pVideoInfoHdr->bmiHeader.biSizeImage;
    biWidthBytes   =   KS_DIBWIDTHBYTES (pVideoInfoHdr->bmiHeader);
    biBitCount     =   pVideoInfoHdr->bmiHeader.biBitCount;
    LinesToCopy    =   abs (biHeight);
    biCompression  =   pVideoInfoHdr->bmiHeader.biCompression;

    //
    // release the lock
    //
    KeReleaseSpinLock( &pStrmEx->lockVideoInfoHeader, oldIrql );

    DEBUG_ASSERT (pSrb->NumberOfBuffers == 1);

    if (pDataPacket->FrameExtent < biSizeImage) {
        DbgLogError(("testcap: video output pin handed buffer size %d, need %d\n",
            pDataPacket->FrameExtent,
            biSizeImage));

        TRAP;
        return;
    }

#if 0
    // Note:  set "ulInDebug = 1" in a debugger to view this output with .ntkern
    DbgLogTrace(("\'TestCap: ImageSynthBegin\n"));
    DbgLogTrace(("\'TestCap: biSizeImage=%d, DataPacketLength=%d\n", 
            biSizeImage, pDataPacket->DataPacketLength));
    DbgLogTrace(("\'TestCap: biWidth=%d biHeight=%d WidthBytes=%d bpp=%d\n", 
            biWidth, biHeight, biWidthBytes, biBitCount));
    DbgLogTrace(("\'TestCap: pImage=%x\n", pImage));
#endif

    // 
    // Synthesize a single line of image data, which will then be replicated
    //

    pLineBuffer = &pStrmEx->LineBuffer[0];

    if ((biBitCount == 24) && (biCompression == KS_BI_RGB)) {

        switch (Command) {
    
        case IMAGE_XFER_NTSC_EIA_100AMP_100SAT:
            // 100% saturation
            {
                UINT x, col;
                PUCHAR pT = pLineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (x * 8) / biWidth;
                    col = FlipHorizontal ? (7 - col) : col;
                    
                    *pT++ = NTSCColorBars100Amp100SatRGB24[0][col]; // Red
                    *pT++ = NTSCColorBars100Amp100SatRGB24[1][col]; // Green
                    *pT++ = NTSCColorBars100Amp100SatRGB24[2][col]; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_NTSC_EIA_75AMP_100SAT:
            // 75% Saturation
            {
                UINT x, col;
                PUCHAR pT = pLineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (x * 8) / biWidth;
                    col = FlipHorizontal ? (7 - col) : col;

                    *pT++ = NTSCColorBars75Amp100SatRGB24[0][col]; // Red
                    *pT++ = NTSCColorBars75Amp100SatRGB24[1][col]; // Green
                    *pT++ = NTSCColorBars75Amp100SatRGB24[2][col]; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_BLACK:
            // Camma corrected Grayscale ramp
            {
                UINT x, col;
                PUCHAR pT = pLineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (255 * (x * 10) / biWidth) / 10;
                    col = FlipHorizontal ? (255 - col) : col;

                    *pT++ = (BYTE) col; // Red
                    *pT++ = (BYTE) col; // Green
                    *pT++ = (BYTE) col; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_WHITE:
            // All white
            RtlFillMemory(
                pLineBuffer,
                biWidthBytes,
                (UCHAR) 255);
            break;
    
        case IMAGE_XFER_GRAY_INCREASING:
            // grayscale increasing with each image captured
            RtlFillMemory(
                pLineBuffer,
                biWidthBytes,
                (UCHAR) (pStrmEx->FrameInfo.PictureNumber * 8));
            break;
    
        default:
            break;
        }
    } // endif RGB24

    else if ((biBitCount == 16) && (biCompression == FOURCC_YUV422)) {

        switch (Command) {
    
        case IMAGE_XFER_NTSC_EIA_100AMP_100SAT:
        default:
            {
                UINT x, col;
                PUCHAR pT = pLineBuffer;
        
                for (x = 0; x < (biWidth / 2); x++) {
                    col = (x * 8) / (biWidth / 2);
                    col = FlipHorizontal ? (7 - col) : col;

                    *pT++ = NTSCColorBars100Amp100SatYUV[0][col]; // U
                    *pT++ = NTSCColorBars100Amp100SatYUV[1][col]; // Y
                    *pT++ = NTSCColorBars100Amp100SatYUV[2][col]; // V
                    *pT++ = NTSCColorBars100Amp100SatYUV[3][col]; // Y
                }
            }
            break;
        }
    } 

    else {
        DbgLogError(("\'TestCap: Unknown format in ImageSynth!!!\n"));
        TRAP;
    }


    // 
    // Copy the single line synthesized to all rows of the image
    //

    for (Line = 0; Line < LinesToCopy; Line++, pImage += biWidthBytes) {

        // Show some action on an otherwise static image
        // This will be a changing grayscale horizontal band
        // at the bottom of an RGB image and a changing color band at the 
        // top of a YUV image

        if (Line >= 3 && Line <= 6) {
            UINT j;
            for (j = 0; j < biWidthBytes; j++) {
                *(pImage + j) = (UCHAR) pStrmEx->FrameInfo.PictureNumber;
            }
            continue;
        }

        // Copy the synthesized line

        RtlCopyMemory(
                pImage,
		        pLineBuffer,
		        biWidthBytes);
    }

    //
    // Report back the actual number of bytes copied to the destination buffer
    // (This can be smaller than the allocated buffer for compressed images)
    //

    pDataPacket->DataUsed = biSizeImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\ddraw.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "ddkmapi.h"
#include "capmain.h"
#include "capdebug.h"

#define _NO_COM
#include "ddkernel.h"

#define DD_OK 0

// The following should be defined in ddkmapi.h, but for some reason are not!

#ifndef booboo // DDKERNELCAPS_SKIPFIELDS
/*
 * Indicates that the device supports field skipping.
 */
#define DDKERNELCAPS_SKIPFIELDS			0x00000001l

/*
 * Indicates that the device can support software autoflipping.
 */
#define DDKERNELCAPS_AUTOFLIP			0x00000002l

/*
 * Indicates that the device can switch between bob and weave.
 */
#define DDKERNELCAPS_SETSTATE			0x00000004l

/*
 * Indicates that a client can gain direct access to the frame buffer.
 */
#define DDKERNELCAPS_LOCK			0x00000008l

/*
 * Indicates that a client can manually flip the video port.
 */
#define DDKERNELCAPS_FLIPVIDEOPORT		0x00000010l

/*
 * Indicates that a client can manually flip the overlay.
 */
#define DDKERNELCAPS_FLIPOVERLAY		0x00000020l

/*
 * Indicates that the device supports a fast, asynchronous transfer
 * mechanism to system memory.
 */
#define DDKERNELCAPS_TRANSFER_SYSMEM		0x00000040l

/*
 * Indicates that the device supports a fast, asynchronous transfer
 * mechanism via AGP.
 */
#define DDKERNELCAPS_TRANSFER_AGP		0x00000080l

/*
 * Indicates that the device can report the polarity (even/odd) of
 * the curent video field.
 */
#define DDKERNELCAPS_FIELDPOLARITY		0x00000100l

/****************************************************************************
 *
 * DDKERNELCAPS IRQ CAPS
 *
 ****************************************************************************/

/*
 * The device can generate display VSYNC IRQs
 */
#define DDIRQ_DISPLAY_VSYNC			0x00000001l

/*
 * Reserved
 */
#define DDIRQ_RESERVED1				0x00000002l

/*
 * The device can generate video ports VSYNC IRQs using video port 0
 */
#define DDIRQ_VPORT0_VSYNC			0x00000004l

/*
 * The device can generate video ports line IRQs using video port 0
 */
#define DDIRQ_VPORT0_LINE			0x00000008l

/*
 * The device can generate video ports VSYNC IRQs using video port 1
 */
#define DDIRQ_VPORT1_VSYNC			0x00000010l

/*
 * The device can generate video ports line IRQs using video port 1
 */
#define DDIRQ_VPORT1_LINE			0x00000020l

/*
 * The device can generate video ports VSYNC IRQs using video port 2
 */
#define DDIRQ_VPORT2_VSYNC			0x00000040l

/*
 * The device can generate video ports line IRQs using video port 2
 */
#define DDIRQ_VPORT2_LINE			0x00000080l

/*
 * The device can generate video ports VSYNC IRQs using video port 3
 */
#define DDIRQ_VPORT3_VSYNC			0x00000100l

/*
 * The device can generate video ports line IRQs using video port 3
 */
#define DDIRQ_VPORT3_LINE			0x00000200l

/*
 * The device can generate video ports VSYNC IRQs using video port 4
 */
#define DDIRQ_VPORT4_VSYNC			0x00000400l

/*
 * The device can generate video ports line IRQs using video port 4
 */
#define DDIRQ_VPORT4_LINE			0x00000800l

/*
 * The device can generate video ports VSYNC IRQs using video port 5
 */
#define DDIRQ_VPORT5_VSYNC			0x00001000l

/*
 * The device can generate video ports line IRQs using video port 5
 */
#define DDIRQ_VPORT5_LINE			0x00002000l

/*
 * The device can generate video ports VSYNC IRQs using video port 6
 */
#define DDIRQ_VPORT6_VSYNC			0x00004000l

/*
 * The device can generate video ports line IRQs using video port 6
 */
#define DDIRQ_VPORT6_LINE			0x00008000l

/*
 * The device can generate video ports VSYNC IRQs using video port 7
 */
#define DDIRQ_VPORT7_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 7
 */
#define DDIRQ_VPORT7_LINE			0x00020000l

/*
 * The device can generate video ports VSYNC IRQs using video port 8
 */
#define DDIRQ_VPORT8_VSYNC			0x00040000l

/*
 * The device can generate video ports line IRQs using video port 8
 */
#define DDIRQ_VPORT8_LINE			0x00080000l

/*
 * The device can generate video ports VSYNC IRQs using video port 9
 */
#define DDIRQ_VPORT9_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 9
 */
#define DDIRQ_VPORT9_LINE			0x00020000l

#endif

DWORD FAR PASCAL
DirectDrawEventCallback (
    DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2
    )
{
    switch (dwEvent)
    {
        case DDNOTIFY_PRERESCHANGE:
            {
                PSTREAMEX pStrmEx = (PSTREAMEX)pContext;
                PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
                int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

                DbgLogInfo(("Testcap: DDNOTIFY_PRERESCHANGE; stream = %d\n", StreamNumber));

                pStrmEx->PreEventOccurred = TRUE;
            }

            break;

        case DDNOTIFY_POSTRESCHANGE:
            {
                PSTREAMEX pStrmEx = (PSTREAMEX)pContext;
                PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
                int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

                DbgLogInfo(("Testcap: DDNOTIFY_POSTRESCHANGE; stream = %d\n", StreamNumber));

                pStrmEx->PostEventOccurred = TRUE;
                DbgLogInfo(("Testcap: Before Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
 //               AttemptRenegotiation(pStrmEx);
                DbgLogInfo(("Testcap: Afer Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
            }

            break;

        case DDNOTIFY_PREDOSBOX:
            {
                PSTREAMEX pStrmEx = (PSTREAMEX)pContext;
                PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
                int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

                DbgLogInfo(("Testcap: DDNOTIFY_PREDOSBOX; stream = %d\n", StreamNumber));

                pStrmEx->PreEventOccurred = TRUE;
            }

            break;

        case DDNOTIFY_POSTDOSBOX:
            {
                PSTREAMEX pStrmEx = (PSTREAMEX)pContext;
                PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
                int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

                DbgLogInfo(("Testcap: DDNOTIFY_POSTDOSBOX; stream = %d\n", StreamNumber));

                pStrmEx->PostEventOccurred = TRUE;
                DbgLogInfo(("Testcap: Before Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
//                AttemptRenegotiation(pStrmEx);
                DbgLogInfo(("Testcap: After Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
            }

            break;

        case DDNOTIFY_CLOSEDIRECTDRAW:
            {
                PSTREAMEX pStrmEx = (PSTREAMEX)pContext;
                PHW_DEVICE_EXTENSION    pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;

                DbgLogInfo(("Testcap: DDNOTIFY_CLOSEDIRECTDRAW\n"));

                pStrmEx->KernelDirectDrawHandle = 0;
                pStrmEx->UserDirectDrawHandle = 0;
            }

            break;

        case DDNOTIFY_CLOSESURFACE:
            {
                PHW_STREAM_REQUEST_BLOCK pSrb = (PHW_STREAM_REQUEST_BLOCK)pContext;
                PSRB_EXTENSION          pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

                DbgLogInfo(("Testcap: DDNOTIFY_CLOSESURFACE\n"));

                pSrbExt->KernelSurfaceHandle = 0;
            }

            break;

        default:
            TRAP;
            break;
    }
    return 0;
}

BOOL
RegisterForDirectDrawEvents (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

    DbgLogInfo(("Testcap: Stream %d registering for DirectDraw events\n", StreamNumber));

    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX ================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }
    pStrmEx->KernelDirectDrawRegistered = TRUE;

    return TRUE;
}


BOOL
UnregisterForDirectDrawEvents (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

    DbgLogInfo(("Testcap: Stream %d UNregistering for DirectDraw events\n", StreamNumber));

    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE ;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX ==================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = pStrmEx->KernelDirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStrmEx;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK) {
        DbgLogInfo(("Testcap: DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP;
        return FALSE;
    }
    pStrmEx->KernelDirectDrawRegistered = FALSE;

    return TRUE;
}


BOOL
OpenKernelDirectDraw (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    if (pStrmEx->UserDirectDrawHandle != 0) {
        DDOPENDIRECTDRAWIN  ddOpenIn;
        DDOPENDIRECTDRAWOUT ddOpenOut;

        ASSERT (pStrmEx->KernelDirectDrawHandle == 0);

        DbgLogInfo(("Testcap: Stream %d getting Kernel ddraw handle\n", StreamNumber));

        RtlZeroMemory(&ddOpenIn, sizeof(ddOpenIn));
        RtlZeroMemory(&ddOpenOut, sizeof(ddOpenOut));

        ddOpenIn.dwDirectDrawHandle = (DWORD_PTR) pStrmEx->UserDirectDrawHandle;
        ddOpenIn.pfnDirectDrawClose = DirectDrawEventCallback;
        ddOpenIn.pContext = pStrmEx;

        DxApi(DD_DXAPI_OPENDIRECTDRAW,
                &ddOpenIn,
                sizeof(ddOpenIn),
                &ddOpenOut,
                sizeof(ddOpenOut));

        if (ddOpenOut.ddRVal != DD_OK) {
            DbgLogInfo(("Testcap: DD_DXAPI_OPENDIRECTDRAW failed.\n"));
        }
        else {
            pStrmEx->KernelDirectDrawHandle = ddOpenOut.hDirectDraw;
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CloseKernelDirectDraw (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pStrmEx->pHwDevExt;
    int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    if (pStrmEx->KernelDirectDrawHandle != 0) {
        DWORD ddOut;
        DDCLOSEHANDLE ddClose;

        DbgLogInfo(("Testcap: Stream %d CloseKernelDirectDraw\n", StreamNumber));

        ddClose.hHandle = pStrmEx->KernelDirectDrawHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE,
                &ddClose,
                sizeof(ddClose),
                &ddOut,
                sizeof(ddOut));

        pStrmEx->KernelDirectDrawHandle = 0;

        if (ddOut != DD_OK) {
            DbgLogInfo(("Testcap: CloseKernelDirectDraw FAILED.\n"));
            TRAP;
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
IsKernelLockAndFlipAvailable (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pStrmEx->pHwDevExt;
    int StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    if (pStrmEx->KernelDirectDrawHandle != 0) {
        DDGETKERNELCAPSOUT ddGetKernelCapsOut;

        DbgLogInfo(("Testcap: Stream %d getting Kernel Caps\n", StreamNumber));

        RtlZeroMemory(&ddGetKernelCapsOut, sizeof(ddGetKernelCapsOut));

        DxApi(DD_DXAPI_GETKERNELCAPS,
                &pStrmEx->KernelDirectDrawHandle,
                sizeof(pStrmEx->KernelDirectDrawHandle),
                &ddGetKernelCapsOut,
                sizeof(ddGetKernelCapsOut));

        if (ddGetKernelCapsOut.ddRVal != DD_OK) {
            DbgLogInfo(("Testcap: DDGETKERNELCAPSOUT failed.\n"));
        }
        else {
            DbgLogInfo(("Testcap: Stream %d KernelCaps = %x\n",
                    StreamNumber, ddGetKernelCapsOut.dwCaps));

            if ((ddGetKernelCapsOut.dwCaps & (DDKERNELCAPS_LOCK | DDKERNELCAPS_FLIPOVERLAY)) ==
                                             (DDKERNELCAPS_LOCK | DDKERNELCAPS_FLIPOVERLAY)) {
                // TODO: Check where we may need to set up for kernel flipping
            }
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
OpenKernelDDrawSurfaceHandle(
     IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PSRB_EXTENSION          pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

    ASSERT (pStrmEx->KernelDirectDrawHandle != 0);
    ASSERT (pSrbExt->UserSurfaceHandle != 0);

    if (pSrbExt->UserSurfaceHandle == 0) {
        DDOPENSURFACEIN ddOpenSurfaceIn;
        DDOPENSURFACEOUT ddOpenSurfaceOut;

        DbgLogInfo(("Testcap: Stream %d getting Kernel surface handle\n", StreamNumber));

        RtlZeroMemory(&ddOpenSurfaceIn, sizeof(ddOpenSurfaceIn));
        RtlZeroMemory(&ddOpenSurfaceOut, sizeof(ddOpenSurfaceOut));

        ddOpenSurfaceIn.hDirectDraw = pStrmEx->UserDirectDrawHandle;
        ddOpenSurfaceIn.pfnSurfaceClose = DirectDrawEventCallback;
        ddOpenSurfaceIn.pContext = pSrb;

        ddOpenSurfaceIn.dwSurfaceHandle = (DWORD_PTR) pSrbExt->UserSurfaceHandle;

        DxApi(DD_DXAPI_OPENSURFACE,
                    &ddOpenSurfaceIn,
                    sizeof(ddOpenSurfaceIn),
                    &ddOpenSurfaceOut,
                    sizeof(ddOpenSurfaceOut));

        if (ddOpenSurfaceOut.ddRVal != DD_OK) {
            pSrbExt->KernelSurfaceHandle = 0;
            DbgLogInfo(("Testcap: DD_DXAPI_OPENSURFACE failed.\n"));
            TRAP;
        }
        else {
            pSrbExt->KernelSurfaceHandle = ddOpenSurfaceOut.hSurface;
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
CloseKernelDDrawSurfaceHandle (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PSRB_EXTENSION          pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

    ASSERT (pStrmEx->KernelDirectDrawHandle != 0);
    ASSERT (pSrbExt->UserSurfaceHandle != 0);
    ASSERT (pSrbExt->KernelSurfaceHandle != 0);

    if (pSrbExt->KernelSurfaceHandle != 0) {
        DWORD ddOut;
        DDCLOSEHANDLE ddClose;

        DbgLogInfo(("Testcap: Stream %d ReleaseKernelDDrawSurfaceHandle\n", StreamNumber));

        ddClose.hHandle = pSrbExt->KernelSurfaceHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        pSrbExt->KernelSurfaceHandle = 0;  // what else can we do?

        if (ddOut != DD_OK) {
            DbgLogInfo(("Testcap: ReleaseKernelDDrawSurfaceHandle FAILED.\n"));
            TRAP;
            return FALSE;
        }
        else {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capvideo.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "capxfer.h"
#include "ntstatus.h"

//==========================================================================;
// General queue management routines
//==========================================================================;

/*
** AddToListIfBusy ()
**
**   Grabs a spinlock, checks the busy flag, and if set adds an SRB to a queue
**
** Arguments:
**
**   pSrb - Stream request block
**
**   SpinLock - The spinlock to use when checking the flag
**
**   BusyFlag - The flag to check
**
**   ListHead - The list onto which the Srb will be added if the busy flag is set
**
** Returns:
**
**   The state of the busy flag on entry.  This will be TRUE if we're already
**   processing an SRB, and FALSE if no SRB is already in progress.
**
** Side Effects:  none
*/

BOOL
STREAMAPI
AddToListIfBusy (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN KSPIN_LOCK              *SpinLock,
    IN OUT BOOL                *BusyFlag,
    IN LIST_ENTRY              *ListHead
    )
{
    KIRQL                       Irql;
    PSRB_EXTENSION              pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

    KeAcquireSpinLock (SpinLock, &Irql);

    // If we're already processing another SRB, add this current request
    // to the queue and return TRUE

    if (*BusyFlag == TRUE) {
        // Save the SRB pointer away in the SRB Extension
        pSrbExt->pSrb = pSrb;
        InsertTailList(ListHead, &pSrbExt->ListEntry);
        KeReleaseSpinLock(SpinLock, Irql);
        return TRUE;
    }

    // Otherwise, set the busy flag, release the spinlock, and return FALSE

    *BusyFlag = TRUE;
    KeReleaseSpinLock(SpinLock, Irql);

    return FALSE;
}

/*
** RemoveFromListIfAvailable ()
**
**   Grabs a spinlock, checks for an available SRB, and removes it from the list
**
** Arguments:
**
**   &pSrb - where to return the Stream request block if available
**
**   SpinLock - The spinlock to use
**
**   BusyFlag - The flag to clear if the list is empty
**
**   ListHead - The list from which an SRB will be removed if available
**
** Returns:
**
**   TRUE if an SRB was removed from the list
**   FALSE if the list is empty
**
** Side Effects:  none
*/

BOOL
STREAMAPI
RemoveFromListIfAvailable (
    IN OUT PHW_STREAM_REQUEST_BLOCK *pSrb,
    IN KSPIN_LOCK                   *SpinLock,
    IN OUT BOOL                     *BusyFlag,
    IN LIST_ENTRY                   *ListHead
    )
{
    KIRQL                       Irql;

    KeAcquireSpinLock (SpinLock, &Irql);

    //
    // If the queue is now empty, clear the busy flag, and return
    //
    if (IsListEmpty(ListHead)) {
        *BusyFlag = FALSE;
        KeReleaseSpinLock(SpinLock, Irql);
        return FALSE;
    }
    //
    // otherwise extract the SRB
    //
    else {
        PUCHAR          ptr;
        PSRB_EXTENSION  pSrbExt;

        ptr = (PUCHAR)RemoveHeadList(ListHead);
        *BusyFlag = TRUE;
        KeReleaseSpinLock(SpinLock, Irql);
        // Get the SRB out of the SRB extension and return it
        pSrbExt = (PSRB_EXTENSION) (((PUCHAR) ptr) -
                     FIELDOFFSET(SRB_EXTENSION, ListEntry));
        *pSrb = pSrbExt->pSrb;
    }
    return TRUE;
}

//==========================================================================;
// Routines for managing the SRB queue on a per stream basis
//==========================================================================;

/*
** VideoQueueAddSRB ()
**
**   Adds a stream data SRB to a stream queue.  The queue is maintained in a
**   first in, first out order.
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoQueueAddSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    KIRQL                   oldIrql;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    // Save the SRB pointer in the IRP so we can use the IRPs
    // ListEntry to maintain a doubly linked list of pending
    // requests

    pSrb->Irp->Tail.Overlay.DriverContext[0] = pSrb;

    InsertTailList (
                &pHwDevExt->StreamSRBList[StreamNumber],
                &pSrb->Irp->Tail.Overlay.ListEntry);

    // Increment the count of outstanding SRBs in this queue
    pHwDevExt->StreamSRBListSize[StreamNumber]++;

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

}

/*
** VideoQueueRemoveSRB ()
**
**   Removes a stream data SRB from a stream queue
**
** Arguments:
**
**   pHwDevExt - Device Extension
**
**   StreamNumber - Index of the stream
**
** Returns: SRB or NULL
**
** Side Effects:  none
*/

PHW_STREAM_REQUEST_BLOCK
STREAMAPI
VideoQueueRemoveSRB (
    PHW_DEVICE_EXTENSION pHwDevExt,
    int StreamNumber
    )
{
    PUCHAR ptr;
    PIRP pIrp;
    PHW_STREAM_REQUEST_BLOCK pSrb = NULL;
    KIRQL oldIrql;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    //
    // Get the SRB out of the IRP out of the pending list
    //
    if (!IsListEmpty (&pHwDevExt->StreamSRBList[StreamNumber])) {

        ptr = (PUCHAR) RemoveHeadList(
                         &pHwDevExt->StreamSRBList[StreamNumber]);

        pIrp = (PIRP) (((PUCHAR) ptr) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        // Decrement the count of SRBs in this queue
        pHwDevExt->StreamSRBListSize[StreamNumber]--;

    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    return pSrb;
}

/*
** VideoQueueCancelAllSRBs()
**
**    In case of a client crash, this empties the stream queue when the stream closes
**
** Arguments:
**
**    pStrmEx - pointer to the stream extension
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoQueueCancelAllSRBs (
    PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PUCHAR                      ptr;
    PIRP                        pIrp;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    KIRQL                       oldIrql;

    if (pStrmEx->KSState != KSSTATE_STOP) {

        DbgLogInfo(("TestCap: VideoQueueCancelAllSRBs without being in the stopped state\n"));
        // May need to force the device to a stopped state here
        // may need to disable interrupts here !
    }

    //
    // The stream class will cancel all outstanding IRPs for us
    // (but only if we've set TurnOffSynchronization = FALSE)
    //

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    //
    // Get the SRB out of the IRP out of the pending list
    //
    while (!IsListEmpty (&pHwDevExt->StreamSRBList[StreamNumber])) {

        ptr = (PUCHAR) RemoveHeadList(
                         &pHwDevExt->StreamSRBList[StreamNumber]);

        pIrp = (PIRP) (((PUCHAR) ptr) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        // Decrement the count of SRBs in this queue
        pHwDevExt->StreamSRBListSize[StreamNumber]--;

        //
        // Make the length zero, and status cancelled
        //

        pSrb->CommandData.DataBufferArray->DataUsed = 0;
        pSrb->Status = STATUS_CANCELLED;

        DbgLogInfo(("TestCap: VideoQueueCancelALLSRBs FOUND Srb=%p, Stream=%d\n", pSrb, StreamNumber));

        CompleteStreamSRB (pSrb);

    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    DbgLogInfo(("TestCap: VideoQueueCancelAll Completed\n"));

}

/*
** VideoQueueCancelOneSRB()
**
**    Called when cancelling a particular SRB
**
** Arguments:
**
**    pStrmEx - pointer to the stream extension
**
**    pSRBToCancel - pointer to the SRB
**
** Returns:
**
**    TRUE if the SRB was found in this queue
**
** Side Effects:  none
*/

BOOL
STREAMAPI
VideoQueueCancelOneSRB (
    PSTREAMEX pStrmEx,
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = (PHW_DEVICE_EXTENSION)pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    KIRQL                       oldIrql;
    BOOL                        Found = FALSE;
    PIRP                        pIrp;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    PLIST_ENTRY                 Entry;

    KeAcquireSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], &oldIrql);

    Entry = pHwDevExt->StreamSRBList[StreamNumber].Flink;

    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //

    while (Entry != &pHwDevExt->StreamSRBList[StreamNumber]) {

        pIrp = (PIRP) (((PUCHAR) Entry) -
                     FIELDOFFSET(IRP, Tail.Overlay.ListEntry));

        pSrb = (PHW_STREAM_REQUEST_BLOCK) pIrp->Tail.Overlay.DriverContext[0];

        if (pSrb == pSrbToCancel) {
            RemoveEntryList(Entry);
            Found = TRUE;
            break;
        }

        Entry = Entry->Flink;
    }

    KeReleaseSpinLock (&pHwDevExt->StreamSRBSpinLock[StreamNumber], oldIrql);

    if (Found) {

        pHwDevExt->StreamSRBListSize[StreamNumber]--;

        //
        // Make the length zero, and status cancelled
        //

        pSrbToCancel->CommandData.DataBufferArray->DataUsed = 0;
        pSrbToCancel->Status = STATUS_CANCELLED;

        CompleteStreamSRB (pSrbToCancel);

        DbgLogInfo(("TestCap: VideoQueueCancelOneSRB FOUND Srb=%p, Stream=%d\n", pSrb, StreamNumber));

    }

    DbgLogInfo(("TestCap: VideoQueueCancelOneSRB Completed Stream=%d\n", StreamNumber));

    return Found;
}

/*
** VideoSetFormat()
**
**   Sets the format for a video stream.  This happens both when the
**   stream is first opened, and also when dynamically switching formats
**   on the preview pin.
**
**   It is assumed that the format has been verified for correctness before
**   this call is made.
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns:
**
**   TRUE if the format could be set, else FALSE
**
** Side Effects:  none
*/

BOOL
STREAMAPI
VideoSetFormat(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    UINT                    nSize;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;

    // -------------------------------------------------------------------
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    // -------------------------------------------------------------------

    if (IsEqualGUID (&pKSDataFormat->Specifier,
                &KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {

        PKS_DATAFORMAT_VIDEOINFOHEADER  pVideoInfoHeader =
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
        PKS_VIDEOINFOHEADER pVideoInfoHdrRequested = &pVideoInfoHeader->VideoInfoHeader;
        PKS_VIDEOINFOHEADER pNewVideoInfoHeader, pOldVideoInfoHeader;
        KIRQL               oldIrql;
        
        nSize = KS_SIZE_VIDEOHEADER (pVideoInfoHdrRequested);

        DbgLogInfo(("TestCap: New Format\n"));
        DbgLogInfo(("TestCap: pVideoInfoHdrRequested=%p\n", pVideoInfoHdrRequested));
        DbgLogInfo(("TestCap: KS_VIDEOINFOHEADER size=%d\n", nSize));
        DbgLogInfo(("TestCap: Width=%d  Height=%d  BitCount=%d\n",
                    pVideoInfoHdrRequested->bmiHeader.biWidth,
                    pVideoInfoHdrRequested->bmiHeader.biHeight,
                    pVideoInfoHdrRequested->bmiHeader.biBitCount));
        DbgLogInfo(("TestCap: biSizeImage=%d\n",
                    pVideoInfoHdrRequested->bmiHeader.biSizeImage));

        
        // Since the VIDEOINFOHEADER is of potentially variable size
        // allocate memory for it

        pNewVideoInfoHeader = ExAllocatePool(NonPagedPool, nSize);

        if (pNewVideoInfoHeader == NULL) {
            DbgLogError(("TestCap: ExAllocatePool failed\n"));
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            return FALSE;
        }

        // Copy the VIDEOINFOHEADER requested to our storage
        RtlCopyMemory(
                pNewVideoInfoHeader,
                pVideoInfoHdrRequested,
                nSize);

        //
        // We have the new format, act on it. First take the lock, we might be
        // setting format dynamically when ImageSync is using the format on the other proc.
        //
        KeAcquireSpinLock( &pStrmEx->lockVideoInfoHeader, &oldIrql );
        //
        // update it and release the lock. Could have used interlockedexchangepointer but
        // it's not available downlevel
        //
        pOldVideoInfoHeader = pStrmEx->pVideoInfoHeader;
        pStrmEx->pVideoInfoHeader = pNewVideoInfoHeader;

        //
        // remember this so getdropped frame needs no locks usig biSizeImage
        //
        pStrmEx->biSizeImage = pNewVideoInfoHeader->bmiHeader.biSizeImage;
        // A renderer may be switching formats, and in this case, the AvgTimePerFrame
        // will be zero.  Don't overwrite a previously set framerate.

        if (pStrmEx->pVideoInfoHeader->AvgTimePerFrame) {
            pStrmEx->AvgTimePerFrame = pStrmEx->pVideoInfoHeader->AvgTimePerFrame;
        }
        
        KeReleaseSpinLock(  &pStrmEx->lockVideoInfoHeader, oldIrql );

        if ( pOldVideoInfoHeader ) {
            //
            // if there is a previous one, free it
            //
            ExFreePool( pOldVideoInfoHeader );
        }
    }

    // -------------------------------------------------------------------
    // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
    // -------------------------------------------------------------------
    else if (IsEqualGUID (&pKSDataFormat->Specifier,
                &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {

            //
            // AnalogVideo DataRange == DataFormat!
            //

            //
            // For now, don't even cache this
            //

            PKS_DATARANGE_ANALOGVIDEO pDataFormatAnalogVideo =
                    (PKS_DATARANGE_ANALOGVIDEO) pSrb->CommandData.OpenFormat;
    }

    // -------------------------------------------------------------------
    // Specifier FORMAT_VBI for KS_VIDEO_VBI
    // -------------------------------------------------------------------
    else if (IsEqualGUID (&pKSDataFormat->Specifier, 
                &KSDATAFORMAT_SPECIFIER_VBI))
    {
        // On a VBI stream, we save a pointer to StreamFormatVBI, which
        //  has the timing info we want to get at later.
        pStrmEx->pVBIStreamFormat = &StreamFormatVBI;
    }

    // -------------------------------------------------------------------
    // Type FORMAT_NABTS for NABTS pin
    // -------------------------------------------------------------------
    else if (IsEqualGUID (&pKSDataFormat->SubFormat,
                &KSDATAFORMAT_SUBTYPE_NABTS))
    {
        // On a VBI stream, we save a pointer to StreamFormatVBI, which
        //  has the timing info we want to get at later. (Even though
        //  this is really a StreamFormatNABTS pin)
        pStrmEx->pVBIStreamFormat = &StreamFormatVBI;
    }

    // -------------------------------------------------------------------
    // for CC pin
    // -------------------------------------------------------------------
        else if (IsEqualGUID (&pKSDataFormat->SubFormat, 
                &KSDATAFORMAT_SUBTYPE_CC))
    {
        // On a VBI stream, we save a pointer to StreamFormatVBI, which
        //  has the timing info we want to get at later. (Even though
        //  this is really a StreamFormatCC pin)
        pStrmEx->pVBIStreamFormat = &StreamFormatVBI;
    }

    else {
        // Unknown format
        pSrb->Status = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    return TRUE;
}

/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands on the output streams
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt!=NULL);

    DbgLogTrace(("TestCap: Receiving Stream Data    SRB %p, %x\n", pSrb, pSrb->Command));

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //

    switch (pSrb->Command){

    case SRB_READ_DATA:

        // Rule:
        // Only accept read requests when in either the Pause or Run
        // States.  If Stopped, immediately return the SRB.

        if (pStrmEx->KSState == KSSTATE_STOP) {

            CompleteStreamSRB (pSrb);

            break;
        }

        //
        // Put this read request on the pending queue
        //

        VideoQueueAddSRB (pSrb);

        // Since another thread COULD HAVE MODIFIED THE STREAM STATE
        // in the midst of adding it to the queue, check the stream
        // state again, and cancel the SRB if necessary.  Note that
        // this race condition was NOT handled in the original DDK
        // release of testcap!

        if (pStrmEx->KSState == KSSTATE_STOP) {

            VideoQueueCancelOneSRB (
                pStrmEx,
                pSrb);
        }

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP;

        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        CompleteStreamSRB (pSrb);

    }  // switch (pSrb->Command)
}


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video output streams
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    BOOL                    Busy;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt!=NULL);

    DbgLogTrace(("TestCap: Receiving Stream Control SRB %p, %x\n", pSrb, pSrb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    while (TRUE) {

        //
        // Default to success
        //

        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_PROPOSE_DATA_FORMAT:
            DbgLogInfo(("TestCap: Receiving SRB_PROPOSE_DATA_FORMAT  SRB %p, StreamNumber= %d\n", pSrb, StreamNumber));
            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
                DbgLogInfo(("TestCap: SRB_PROPOSE_DATA_FORMAT FAILED\n"));
            }
            // KS support for dynamic format changes is BROKEN right now,
            //  so we prevent these from happening by saying they ALL fail.
            // If this is ever fixed, the next line must be removed.
            pSrb->Status = STATUS_NO_MATCH; // prevent dynamic format changes
            break;

        case SRB_SET_DATA_FORMAT:
            DbgLogInfo(("TestCap: SRB_SET_DATA_FORMAT\n"));
            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
                DbgLogInfo(("TestCap: SRB_SET_DATA_FORMAT FAILED\n"));
            } else {
                VideoSetFormat (pSrb);
                DbgLogInfo(("TestCap: SRB_SET_DATA_FORMAT SUCCEEDED\n"));
            }

            break;

        case SRB_GET_DATA_FORMAT:
            DbgLogInfo(("TestCap: SRB_GET_DATA_FORMAT\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;


        case SRB_SET_STREAM_STATE:

            VideoSetState(pSrb);
            break;

        case SRB_GET_STREAM_STATE:

            VideoGetState(pSrb);
            break;

        case SRB_GET_STREAM_PROPERTY:

            VideoGetProperty(pSrb);
            break;

        case SRB_SET_STREAM_PROPERTY:

            VideoSetProperty(pSrb);
            break;

        case SRB_INDICATE_MASTER_CLOCK:

            //
            // Assigns a clock to a stream
            //

            VideoIndicateMasterClock (pSrb);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP;

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        CompleteStreamSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

        if (!Busy) {
            break;
        }
    }
}

/*
** AnalogVideoReceiveDataPacket()
**
**   Receives AnalogVideo data packet commands on the input stream
**
** Arguments:
**
**   pSrb - Stream request block for the Analog Video stream.
**          This stream receives tuner control packets.
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
AnalogVideoReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PKSSTREAM_HEADER        pDataPacket = pSrb->CommandData.DataBufferArray;

    //
    // make sure we have a device extension and are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt!=NULL);

    DbgLogInfo(("TestCap: Receiving Tuner packet    SRB %p, %x\n", pSrb, pSrb->Command));

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //

    switch (pSrb->Command){

    case SRB_WRITE_DATA:

        //
        // This data packet contains the channel change information
        // passed on the AnalogVideoIn stream.  Devices which support
        // VBI data streams need to pass this info on their output pins.
        //

        if (pDataPacket->FrameExtent == sizeof (KS_TVTUNER_CHANGE_INFO)) {

            RtlCopyMemory(
                &pHwDevExt->TVTunerChangeInfo,
                pDataPacket->Data,
                sizeof (KS_TVTUNER_CHANGE_INFO));
        }

        CompleteStreamSRB (pSrb);

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP;

        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        CompleteStreamSRB (pSrb);

    }  // switch (pSrb->Command)
}


/*
** AnalogVideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Analog Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
AnalogVideoReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    BOOL                    Busy;

    //
    // make sure we have a device extension and we are at passive level
    //

    DEBUG_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    DEBUG_ASSERT(pHwDevExt!=NULL);

    DbgLogTrace(("TestCap: Receiving Analog Stream Control SRB %p, %x\n", pSrb, pSrb->Command));

    //
    // If we're already processing an SRB, add it to the queue
    //
    Busy = AddToListIfBusy (
                        pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    if (Busy) {
        return;
    }

    do {
        //
        // Default to success
        //

        pSrb->Status = STATUS_SUCCESS;

        //
        // determine the type of packet.
        //

        switch (pSrb->Command)
        {

        case SRB_PROPOSE_DATA_FORMAT:
            DbgLogInfo(("TestCap: Receiving SRB_PROPOSE_DATA_FORMAT  SRB %p, StreamNumber= %d\n", pSrb, StreamNumber));

            if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat,
                    pSrb->StreamObject->StreamNumber))) {
                pSrb->Status = STATUS_NO_MATCH;
            }
            break;

        case SRB_SET_STREAM_STATE:

            //
            // Don't use VideoSetState, since we don't want to start another
            // timer running
            //

            pStrmEx->KSState = pSrb->CommandData.StreamState;
            DbgLogInfo(("TestCap: STATE=%d, Stream=%d\n", pStrmEx->KSState, StreamNumber));
            break;

        case SRB_GET_STREAM_STATE:

            VideoGetState(pSrb);
            break;

        case SRB_GET_STREAM_PROPERTY:

            VideoGetProperty(pSrb);
            break;

        case SRB_INDICATE_MASTER_CLOCK:

            //
            // Assigns a clock to a stream
            //

            VideoIndicateMasterClock (pSrb);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP;

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        CompleteStreamSRB (pSrb);

        //
        // See if there's anything else on the queue
        //
        Busy = RemoveFromListIfAvailable (
                        &pSrb,
                        &pHwDevExt->AdapterSpinLock,
                        &pHwDevExt->ProcessingControlSRB [StreamNumber],
                        &pHwDevExt->StreamControlSRBList[StreamNumber]);

    } while ( Busy );
}


/*
** CompleteStreamSRB ()
**
**   This routine is called when a packet is being completed.
**
** Arguments:
**
**   pSrb - pointer to the request packet to be completed
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
CompleteStreamSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    DbgLogTrace(("TestCap: Completing Stream        SRB %p\n", pSrb));

    StreamClassStreamNotification(
            StreamRequestComplete,
            pSrb->StreamObject,
            pSrb);
}


/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
//    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_NOT_IMPLEMENTED;
}



/*
** VideoTimerRoutine()
**
**    A timer has been created based on the requested capture interval.
**    This is the callback routine for this timer event.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
**    Context - pointer to the stream extension
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoTimerRoutine(
    PVOID Context
    )
{
    PSTREAMEX                   pStrmEx = ((PSTREAMEX)Context);
    PHW_DEVICE_EXTENSION        pHwDevExt = pStrmEx->pHwDevExt;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }

    // Capture a frame if it's time and we have a buffer

    VideoCaptureRoutine(pStrmEx);

    // Schedule the next timer event
    // Make it run at 2x the requested capture rate (which is in 100nS units)

    StreamClassScheduleTimer (
            pStrmEx->pStreamObject,     // StreamObject
            pHwDevExt,                  // HwDeviceExtension
            (ULONG) (pStrmEx->AvgTimePerFrame / 20), // Microseconds
            VideoTimerRoutine,          // TimerRoutine
            pStrmEx);                   // Context
}


/*
** VideoCaptureRoutine()
**
**    Routine to capture video frames based on a timer.
**
**    Note:  Devices capable of using interrupts should always
**           trigger capture on a VSYNC interrupt, and not use a timer.
**
** Arguments:
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoCaptureRoutine(
    IN PSTREAMEX pStrmEx
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = pStrmEx->pHwDevExt;
    int                     StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    PKSSTREAM_HEADER        pDataPacket;
    PKS_FRAME_INFO          pFrameInfo;

    // If we're stopped and the timer is still running, just return.
    // This will stop the timer.

    if (pStrmEx->KSState == KSSTATE_STOP) {
        return;
    }


    // Find out what time it is, if we're using a clock

    if (pStrmEx->hMasterClock ) {
        HW_TIME_CONTEXT TimeContext;

        TimeContext.HwDeviceExtension = pHwDevExt;
        TimeContext.HwStreamObject = pStrmEx->pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
                pStrmEx->hMasterClock,
                &TimeContext);

        pStrmEx->QST_StreamTime = TimeContext.Time;
        pStrmEx->QST_Now = TimeContext.SystemTime;

        if (pStrmEx->QST_NextFrame == 0) {
            pStrmEx->QST_NextFrame = pStrmEx->QST_StreamTime + pStrmEx->AvgTimePerFrame;
        }

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        DbgLogTrace(("TestCap: Time=%6d mS at SystemTime=%I64d\n", 
                     (LONG) ((LONGLONG) TimeContext.Time / 10000), 
                     TimeContext.SystemTime));
#endif
    }


    // Only capture in the RUN state

    if (pStrmEx->KSState == KSSTATE_RUN) {

        //
        // Determine if it is time to capture a frame based on
        // how much time has elapsed since capture started.
        // If there isn't a clock available, then capture immediately.
        //

        if ((!pStrmEx->hMasterClock) ||
             (pStrmEx->QST_StreamTime >= pStrmEx->QST_NextFrame)) {

            PHW_STREAM_REQUEST_BLOCK pSrb;

            // Increment the picture count (usually this is VSYNC count)

            pStrmEx->FrameInfo.PictureNumber++;

            //
            // Get the next queue SRB (if any)
            //

            pSrb = VideoQueueRemoveSRB (
                            pHwDevExt,
                            StreamNumber);

            if (pSrb) {

                pDataPacket = pSrb->CommandData.DataBufferArray;
                pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

                //
                // Call the routine which synthesizes images
                //

                ImageSynth (pSrb,
                            pHwDevExt->VideoInputConnected,
                            pStrmEx->VideoControlMode & KS_VideoControlFlag_FlipHorizontal);

                // Set additional info fields about the data captured such as:
                //   Frames Captured
                //   Frames Dropped
                //   Field Polarity

                pStrmEx->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

                *pFrameInfo = pStrmEx->FrameInfo;

                // Init the flags to zero
                pDataPacket->OptionsFlags = 0;

                // Set the discontinuity flag if frames have been previously
                // dropped, and then reset our internal flag

                if (pStrmEx->fDiscontinuity) {
                    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    pStrmEx->fDiscontinuity = FALSE;
                }

                //
                // Return the timestamp for the frame
                //
                pDataPacket->PresentationTime.Numerator = 1;
                pDataPacket->PresentationTime.Denominator = 1;
                pDataPacket->Duration = pStrmEx->AvgTimePerFrame;

                //
                // if we have a master clock AND this is the capture stream
                //
                if (pStrmEx->hMasterClock && (StreamNumber == 0)) {

                    pDataPacket->PresentationTime.Time = pStrmEx->QST_StreamTime;
                    pDataPacket->OptionsFlags |=
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
                }
                else {
                    //
                    // no clock or the preview stream, so just mark the time as unknown
                    //
                    pDataPacket->PresentationTime.Time = 0;
                    // clear the timestamp valid flags
                    pDataPacket->OptionsFlags &=
                        ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                          KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
                }

                // Every frame we generate is a key frame (aka SplicePoint)
                // Delta frames (B or P) should not set this flag

                pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

                // Output a frame count every 100th frame in Debug mode
                if (pStrmEx->FrameInfo.PictureNumber % 100 == 0) {
                   DbgLogInfo(("TestCap: Picture %u, Stream=%d\n", 
                               (unsigned int)pStrmEx->FrameInfo.PictureNumber, 
                               StreamNumber));
                }

                CompleteStreamSRB (pSrb);

            } // if we have an SRB

            else {

                //
                // No buffer was available when we should have captured one

                // Increment the counter which keeps track of
                // dropped frames

                pStrmEx->FrameInfo.DropCount++;

                // Set the (local) discontinuity flag
                // This will cause the next packet processed to have the
                //   KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag set.

                pStrmEx->fDiscontinuity = TRUE;

            }

            // Figure out when to capture the next frame
            pStrmEx->QST_NextFrame += pStrmEx->AvgTimePerFrame;

        } // endif time to capture a frame
    } // endif we're running
}


/*
** VideoSetState()
**
**    Sets the current state for a given stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION        pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX                   pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                         StreamNumber = pStrmEx->pStreamObject->StreamNumber;
    KSSTATE                     PreviousState;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    //          and whether you're using the Stream class for synchronization
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    //
    // Remember the state we're transitioning away from
    //

    PreviousState = pStrmEx->KSState;

    //
    // Set the new state
    //

    pStrmEx->KSState = pSrb->CommandData.StreamState;

    switch (pSrb->CommandData.StreamState)

    {
    case KSSTATE_STOP:

        //
        // The stream class will cancel all outstanding IRPs for us
        // (but only if it is maintaining the queue ie. using Stream Class synchronization)
        // Since Testcap is not using Stream Class synchronization, we must clear the queue here

        VideoQueueCancelAllSRBs (pStrmEx);

        DbgLogInfo(("TestCap: STATE Stopped, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_ACQUIRE:

        //
        // This is a KS only state, that has no correspondence in DirectShow
        //
        DbgLogInfo(("TestCap: STATE Acquire, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_PAUSE:

        //
        // On a transition to pause from acquire or stop, start our timer running.
        //

        if (PreviousState == KSSTATE_ACQUIRE || PreviousState == KSSTATE_STOP) {

            // Zero the frame counters
            pStrmEx->FrameInfo.PictureNumber = 0;
            pStrmEx->FrameInfo.DropCount = 0;
            pStrmEx->FrameInfo.dwFrameFlags = 0;

            // Setup the next timer callback(s)
            VideoTimerRoutine(pStrmEx);
        }
        DbgLogInfo(("TestCap: STATE Pause, Stream=%d\n", StreamNumber));
        break;

    case KSSTATE_RUN:

        //
        // Begin Streaming.
        //

        // Reset the discontinuity flag

        pStrmEx->fDiscontinuity = FALSE;

        // Setting the NextFrame time to zero will cause the value to be
        // reset from the stream time

        pStrmEx->QST_NextFrame = 0;

        DbgLogInfo(("TestCap: STATE Run, Stream=%d\n", StreamNumber));
        break;

    } // end switch (pSrb->CommandData.StreamState)
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    pSrb->CommandData.StreamState = pStrmEx->KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return STATUS_NO_DATA_DETECTED

    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }
}


/*
** VideoStreamGetConnectionProperty()
**
**    Gets the properties for a stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    int  streamNumber = (int)pSrb->StreamObject->StreamNumber;

    switch (Id) {
        // This property describes the allocator requirements for the stream
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing =
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Framing->PoolType = PagedPool;
            Framing->FileAlignment = 0; // FILE_LONG_ALIGNMENT???;
            Framing->Reserved = 0;
            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);

            switch (streamNumber) {
                case STREAM_Capture:
                case STREAM_Preview:
                    Framing->Frames = 2;
                    Framing->FrameSize =
                        pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
                    break;

                case STREAM_VBI:
                    Framing->Frames = 8;
                    Framing->FrameSize = StreamFormatVBI.DataRange.SampleSize;
                    break;

                case STREAM_CC:
                    Framing->Frames = 100;
                    Framing->FrameSize = StreamFormatCC.SampleSize;
                    break;

                case STREAM_NABTS:
                    Framing->Frames = 20;
                    Framing->FrameSize = StreamFormatNABTS.SampleSize;
                    break;

                case STREAM_AnalogVideoInput:
                default:
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                    break;
            }
            break;
        }

        default:
            TRAP;
            break;
    }
}

/*
** VideoStreamGetDroppedFramesProperty()
**
**    Gets dynamic information about the progress of the capture process.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoStreamGetDroppedFramesProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
        {
            PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames =
                (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

            pDroppedFrames->PictureNumber = pStrmEx->FrameInfo.PictureNumber;
            // pStrmEx->biSizeImage is init to 0 by stream.sys 0'ing whole pStrmEx. 
            pDroppedFrames->DropCount = pStrmEx->FrameInfo.DropCount;
            pDroppedFrames->AverageFrameSize = pStrmEx->biSizeImage;

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
        }
        break;

    default:
        TRAP;
        break;
    }
}

//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    If this stream is not being used as the master clock, this function
**      is used to provide us with a handle to the clock to use when
**      requesting the current stream time.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    pStrmEx->hMasterClock = pSrb->CommandData.MasterClockHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\capxfer.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CAPXFER_H__
#define __CAPXFER_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Select an image to synthesize by connecting to a particular
// input pin on the analog crossbar.  The index of the pin
// selects the image to synthesize.

typedef enum _ImageXferCommands
{
    IMAGE_XFER_NTSC_EIA_100AMP_100SAT = 0,      
    IMAGE_XFER_NTSC_EIA_75AMP_100SAT,           
    IMAGE_XFER_BLACK,
    IMAGE_XFER_WHITE,
    IMAGE_XFER_GRAY_INCREASING, 
    IMAGE_XFER_LIST_TERMINATOR                  // Always keep this guy last
} ImageXferCommands;

void ImageSynth (
        IN OUT PHW_STREAM_REQUEST_BLOCK pSrb,
        IN ImageXferCommands Command,
        IN BOOL FlipHorizontal );

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CAPXFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\mediums.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file defines interconnections between components via Mediums
//

#ifdef DEFINE_MEDIUMS
    #define MEDIUM_DECL static
#else
    #define MEDIUM_DECL extern
#endif
                               
/*  -----------------------------------------------------------

    Topology of all devices:

                            PinDir  FilterPin#    M_GUID#
    TVTuner                 
        TVTunerVideo        out         0            0
        TVTunerAudio        out         1            1
        TVTunerRadioAudio   out         2            2
        IntermediateFreq    out         3            6
    TVAudio
        TVTunerAudio        in          0            1
        TVAudio             out         1            3
    Crossbar
        TVTunerVideo        in          0            0
        TVAudio             in          5            3
        TVTunerRadioAudio   in          6            2
        AnalogVideoIn       out         9            4
        AudioOut            out         10           NULL
    Capture
        AnalogVideoIn       in          0            4
        

All other pins are marked as promiscuous connections via GUID_NULL
------------------------------------------------------------------ */        
        
// Define the GUIDs which will be used to create the Mediums
#define M_GUID0 0x8dad65e0, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID1 0x8dad65e1, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID2 0x8dad65e2, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID3 0x8dad65e3, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID4 0x8dad65e4, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID5 0x8dad65e5, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_NOCONNECT  0x8dad65e6, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_NOCONNECT2 0x8dad65e7, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID6 0x8dad65e8, 0x122b, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba

// Note: To allow multiple instances of the same piece of hardware,
// set the first ULONG after the GUID in the Medium to a unique value.

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVTunerMediums[] = {
    {M_GUID0,           0, 0},  // Pin 0  AnalogVideoOut
    {M_GUID1,           0, 0},  // Pin 1  AnalogAudioOut
    {M_GUID2,           0, 0},  // Pin 2  FMAudioOut
    {M_GUID6,           0, 0},  // Pin 3  IntermediateFreqOut
};

MEDIUM_DECL BOOL TVTunerPinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    TRUE,                       // Output Pin 2
    TRUE,                       // Output Pin 3
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVAudioMediums[] = {
    {M_GUID1,           0, 0},  // Pin 0
    {M_GUID3,           0, 0},  // Pin 1
};

MEDIUM_DECL BOOL TVAudioPinDirection [] = {
    FALSE,                      // Input  Pin 0
    TRUE,                       // Output Pin 1
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CrossbarMediums[] = {
    {M_GUID0,           0, 0},  // Input  Pin 0, KS_PhysConn_Video_Tuner,        
    {M_NOCONNECT,       0, 0},  // Input  Pin 1  KS_PhysConn_Video_Composite,    
    {M_NOCONNECT,       0, 0},  // Input  Pin 2  KS_PhysConn_Video_SVideo,       
    {M_NOCONNECT,       0, 0},  // Input  Pin 3  KS_PhysConn_Video_Tuner,        
    {M_NOCONNECT,       0, 0},  // Input  Pin 4  KS_PhysConn_Video_Composite,    
    {M_GUID3,           0, 0},  // Input  Pin 5  KS_PhysConn_Audio_Tuner,        
    {M_GUID2,           0, 0},  // Input  Pin 6  KS_PhysConn_Audio_Line,         
    {M_NOCONNECT,       0, 0},  // Input  Pin 7  KS_PhysConn_Audio_Tuner,        
    {M_NOCONNECT,       0, 0},  // Input  Pin 8  KS_PhysConn_Audio_Line,         
    {M_GUID4,           0, 0},  // Output Pin 9  KS_PhysConn_Video_VideoDecoder, 
    {STATIC_GUID_NULL,  0, 0},  // Output Pin 10 KS_PhysConn_Audio_AudioDecoder, 
};

MEDIUM_DECL BOOL CrossbarPinDirection [] = {
    FALSE,                      // Input  Pin 0, KS_PhysConn_Video_Tuner,     
    FALSE,                      // Input  Pin 1  KS_PhysConn_Video_Composite, 
    FALSE,                      // Input  Pin 2  KS_PhysConn_Video_SVideo,    
    FALSE,                      // Input  Pin 3  KS_PhysConn_Video_Tuner,     
    FALSE,                      // Input  Pin 4  KS_PhysConn_Video_Composite, 
    FALSE,                      // Input  Pin 5  KS_PhysConn_Audio_Tuner, 
    FALSE,                      // Input  Pin 6  KS_PhysConn_Audio_Line,  
    FALSE,                      // Input  Pin 7  KS_PhysConn_Audio_Tuner, 
    FALSE,                      // Input  Pin 8  KS_PhysConn_Audio_Line,  
    TRUE,                       // Output Pin 9  KS_PhysConn_Video_VideoDecoder,
    TRUE,                       // Output Pin 10 KS_PhysConn_Audio_AudioDecoder,
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_GUID_NULL,  0, 0},  // Pin 0  Capture
    {STATIC_GUID_NULL,  0, 0},  // Pin 1  Preview
    {M_GUID4,           0, 0},  // Pin 2  Analog Video In
};

MEDIUM_DECL BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    FALSE,                      // Input  Pin 2
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\vbidata.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __VBIDATA_H__
#define __VBIDATA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define  _VBIlineSize  (768*2)
extern unsigned char VBIsamples[][12][_VBIlineSize];
extern unsigned int  VBIfieldSize;
extern unsigned int  VBIfieldCount;

extern unsigned char CCfields[][2];
extern unsigned int  CCfieldCount;

extern unsigned char CCsampleWave[];
extern unsigned short CCsampleWaveSize;
#define CCsampleWaveDataOffset 580
#define CCsampleWaveDC_zero  54
#define CCsampleWaveDC_one  109

extern unsigned char NABTSfields[][sizeof (NABTS_BUFFER)];
extern unsigned int  NABTSfieldCount;

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__VBIDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\vbixfer.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __VBIXFER_H__
#define __VBIXFER_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Bit-array manipulation
#define BIT(n)             (((unsigned long)1)<<(n))
#define BITSIZE(v)         (sizeof(v)*8)
#define SETBIT(array,n)    (array[(n)/BITSIZE(*array)] |= BIT((n)%BITSIZE(*array)))
#define CLEARBIT(array,n)  (array[(n)/BITSIZE(*array)] &= ~BIT((n)%BITSIZE(*array)))
#define TESTBIT(array,n)   (BIT((n)%BITSIZE(*array)) == (array[(n)/BITSIZE(*array)] & BIT((n)%BITSIZE(*array))))


void CC_ImageSynth(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);
void CC_EncodeWaveform(
        unsigned char *waveform, unsigned char cc1, unsigned char cc2);
void NABTS_ImageSynth(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);
void VBI_ImageSynth(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__VBIXFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\vbixfer.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "capmain.h"
#include "capdebug.h"
#include "vbixfer.h"
#include "vbidata.h"

/*
** DEBUG variables to play with
*/
#if DBG
unsigned short  dCCScanWave = 0;
unsigned short  dCCScanLog = 0;
unsigned short  dCCLogOnce = 1;
unsigned short  dCCEncode5A = 0;
#endif //DBG

/*
** CC_ImageSynth()
**
**   Copies canned CC bytes
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns:
**   Nothing
**
** Side Effects:  none
*/

void CC_ImageSynth (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER        pStreamHeader = pSrb->CommandData.DataBufferArray;
    PCC_HW_FIELD            pCCfield = (PCC_HW_FIELD)pStreamHeader->Data;
    unsigned int            field;
    unsigned int            cc_index;

    DEBUG_ASSERT(pSrb->NumberOfBuffers == 1);

    if (pSrb->CommandData.DataBufferArray->FrameExtent < sizeof (CC_HW_FIELD)) {
        DbgLogError(("testcap: CC output pin handed buffer size %d, need %d\n",
            pSrb->CommandData.DataBufferArray->FrameExtent,
            sizeof (CC_HW_FIELD)));

        TRAP;
        return;
    }

    field = (unsigned int)(pStrmEx->VBIFrameInfo.PictureNumber % CCfieldCount);

    RtlZeroMemory(pCCfield, sizeof (*pCCfield));
    cc_index = 0;

    pCCfield->PictureNumber = pStrmEx->VBIFrameInfo.PictureNumber;
    pCCfield->fieldFlags = (field & 1)? KS_VBI_FLAG_FIELD1 : KS_VBI_FLAG_FIELD2;
    field >>= 1;

    SETBIT(pCCfield->ScanlinesRequested.DwordBitArray, 21);
    if (KS_VBI_FLAG_FIELD1 == pCCfield->fieldFlags) {
        pCCfield->Lines[cc_index].Decoded[0] = CCfields[field][0];
        pCCfield->Lines[cc_index].Decoded[1] = CCfields[field][1];
    }
    else {
        pCCfield->Lines[cc_index].Decoded[0] = 0;
        pCCfield->Lines[cc_index].Decoded[1] = 0;
    }
    //DbgKdPrint(("%c%c", CCfields[field][0] & 0x7F, CCfields[field][1] & 0x7F));
    ++cc_index;

    pStreamHeader->DataUsed = sizeof (CC_HW_FIELD);
}


/*
** CC_EncodeWaveform()
**
**   Writes out a CC waveform encoding the supplied data bytes
**
** Arguments:
**
**   waveform - the buffer for the CC waveform data
**   cc1 - the first byte to encode into the waveform
**   cc2 - the second byte to encode into the waveform
**
** Returns:
**   Nothing
**
** Side Effects:  overwrites waveform with an EIA-608 signal
*/
void CC_EncodeWaveform(
        unsigned char *waveform,
        unsigned char cc1,
        unsigned char cc2)
{
    unsigned int    waveIdx;
    unsigned char   DC_zero = CCsampleWave[0];
    unsigned char   DC_one = CCsampleWave[34];
    unsigned short  DC_last;

    // 455/8 = 56.875 bytes per CC bit at KS_VBISAMPLINGRATE_5X_NABTS(~28.6mhz)
    unsigned int    CCstride = 455;

    unsigned char   *samp, *end, byte;
    unsigned int    bit, done;

#if DBG
    if (dCCEncode5A) {
        cc1 = 0x5A;
        cc2 = 0x5A;
    }

    if (dCCScanWave) {
        // Scan EIGHT bits worth of samples for low / high DC values
        for (samp=CCsampleWave, end=CCsampleWave+CCstride; samp < end; ++samp) {
            if (*samp > DC_one)
                DC_one = *samp;
            else if (*samp < DC_zero)
                DC_zero = *samp;
        }

        for (samp = CCsampleWave + 500; samp < &CCsampleWave[550] ; ++samp) {
            if (*samp >= DC_one - 5)
                break;
        }
        waveIdx = (unsigned int)((samp - CCsampleWave) * 8);

        if (dCCScanLog) {
            DbgKdPrint(("testcap::CC_EncodeWaveform: DC_zero = %u, DC_one = %u, waveIdx = %u\n", DC_zero, DC_one, waveIdx/8));
            dCCScanLog = 0;
        }
    }
    else {
#endif //DBG
        waveIdx = CCsampleWaveDataOffset * 8;
        DC_zero = CCsampleWaveDC_zero;
        DC_one = CCsampleWaveDC_one;
#if DBG
    }

#endif //DBG

    // Copy Run-in bytes and first three bits as-is
    RtlCopyMemory(waveform, CCsampleWave, waveIdx/8);
    DC_last = waveform[waveIdx/8 - 1] * 4;

    // Now encode the requested bytes
    samp = &waveform[waveIdx/8];
    for (byte = cc1, done = 0; ; byte = cc2, done = 1)
    {
        unsigned int    bitpos;

        for (bitpos = 0; bitpos < 8; ++bitpos) {
            bit = byte & 1;
            byte >>= 1;
            for (end = &waveform[(waveIdx + CCstride)/8]; samp < end; ++samp) {
                if (bit == 1) {
                    if (DC_last/4 < DC_one) {
                        DC_last += 7;
                        if (DC_last/4 > DC_one)
                            DC_last = DC_one * 4;
                    }
                }
                else /* bit == 0 */ {
                    if (DC_last/4 > DC_zero) {
                        DC_last -= 7;
                        if (DC_last/4 < DC_zero)
                            DC_last = DC_zero * 4;
                    }
                }
                ASSERT(samp < &waveform[768*2]);
                *samp = DC_last/4;
            }
            waveIdx += CCstride;
        }

        if (done)
            break;
    }

    // Finish up at DC_zero
    for (end = &waveform[768*2]; samp < end; ++samp) {
        if (DC_last/4 > DC_zero) {
            DC_last -= 7;
            if (DC_last/4 < DC_zero)
                DC_last = DC_zero * 4;
        }
        *samp = DC_last/4;
    }
}

/*
** NABTS_ImageSynth()
**
**   Copies canned NABTS bytes
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns:
**   Nothing
**
** Side Effects:  none
*/

unsigned char HammingEncode[16] = {
    0x15, 0x02, 0x49, 0x5E, 0x64, 0x73, 0x38, 0x2F,
    0xD0, 0xC7, 0x8C, 0x9B, 0xA1, 0xB6, 0xFD, 0xEA
};

void NABTS_ImageSynth (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    PKSSTREAM_HEADER        pStreamHeader = pSrb->CommandData.DataBufferArray;
    PNABTS_BUFFER           pNbuf = (PNABTS_BUFFER)pStreamHeader->Data;

    unsigned int            field;

#ifdef VBIDATA_NABTS

    // Check to make sure that the supplied buffer is large enough
    if (pSrb->CommandData.DataBufferArray->FrameExtent < sizeof (NABTS_BUFFER)) {
        DbgLogError(("testcap: NABTS output pin handed buffer size %d, need %d\n",
            pSrb->CommandData.DataBufferArray->FrameExtent,
            sizeof (NABTS_BUFFER)));

        TRAP;
        return;
    }

    DEBUG_ASSERT (pSrb->NumberOfBuffers == 1);

    pNbuf->PictureNumber = pStrmEx->VBIFrameInfo.PictureNumber;

    // Copy the next apropriate field
    field = (unsigned int)(pStrmEx->VBIFrameInfo.PictureNumber % NABTSfieldCount);
    RtlCopyMemory(pNbuf, NABTSfields[field], sizeof (NABTS_BUFFER));

#else /*VBIDATA_NABTS*/

    unsigned char           i, line, ci;
    PNABTS_BUFFER_LINE      pNline;

    // Check to make sure that the supplied buffer is large enough
    if (pSrb->CommandData.DataBufferArray->FrameExtent < sizeof (NABTS_BUFFER)) {
        DbgLogError(("testcap: NABTS output pin handed buffer size %d, need %d\n",
            pSrb->CommandData.DataBufferArray->FrameExtent,
            sizeof (NABTS_BUFFER)));

        TRAP;
        return;
    }

    // Create a test pattern

    RtlZeroMemory(pNbuf, sizeof (NABTS_BUFFER));

    ci = (unsigned char)(pStrmEx->VBIFrameInfo.PictureNumber % 15);
    pNbuf->PictureNumber = pStrmEx->VBIFrameInfo.PictureNumber;
    
    for (line = 10, pNline = pNbuf->NabtsLines;
        line < 21;
        ++line, ++pNline)
    {
        SETBIT(pNbuf->ScanlinesRequested.DwordBitArray, line);

        pNline->Confidence = 102;       // We're 102% sure this NABTS is OK

        // NABTS Header bytes
        pNline->Bytes[00] =
         pNline->Bytes[01] = 0x55;
        pNline->Bytes[02] = 0xE7;

        // Set GroupID 0x8F4
        pNline->Bytes[03] = HammingEncode[0x8];
        pNline->Bytes[04] = HammingEncode[0xF];
        pNline->Bytes[05] = HammingEncode[0x4];

        pNline->Bytes[06] = HammingEncode[ci];
        pNline->Bytes[07] = HammingEncode[0x0]; // PS = Reg, Full, No suffix
        
        // NABTS Payload
        i = 8;
        pNline->Bytes[i++] = 0xA0;      // Mark the start of payload,
        pNline->Bytes[i++] = 0xA0;      //  just for fun
        pNline->Bytes[i++] = ci;        // Put frame # into payload
        pNline->Bytes[i++] = line;      // Put line # into payload

        // The rest zeros for now...
    }

#endif /*VBIDATA_NABTS*/

    pStreamHeader->DataUsed = sizeof (NABTS_BUFFER);
}

/*
** VBI_ImageSynth()
**
**   Copies canned VBI samples
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**   ImageXferCommands - Index specifying the image to generate
**
** Returns:
**   Nothing
**
** Side Effects:  none
*/
void VBI_ImageSynth (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    PKSSTREAM_HEADER        pStreamHeader = pSrb->CommandData.DataBufferArray;
    PUCHAR                  pImage =  pStreamHeader->Data;

    unsigned int            field, cc_field;
    unsigned char           cc1, cc2;

    DEBUG_ASSERT (pSrb->NumberOfBuffers == 1);

    // Check to make sure that the supplied buffer is large enough
    if (pSrb->CommandData.DataBufferArray->FrameExtent < VBIfieldSize) {
        DbgLogError(("testcap: VBI output pin handed buffer size %d, need %d\n",
                 pSrb->CommandData.DataBufferArray->FrameExtent,
                 VBIfieldSize));
        TRAP;
        return;
    }

    // Copy the next apropriate field
    field = (unsigned int)(pStrmEx->VBIFrameInfo.PictureNumber % VBIfieldCount);
    RtlCopyMemory(pImage, VBIsamples[field], VBIfieldSize);

    // Now mangle the CC waveform to match the HW data
    if (field & 1) {
        cc_field = (unsigned int)
                    (pStrmEx->VBIFrameInfo.PictureNumber >> 1) % CCfieldCount;
        cc1 = CCfields[cc_field][0];
        cc2 = CCfields[cc_field][1];
    }
    else {
        cc1 = 0;
        cc2 = 0;
    }
    CC_EncodeWaveform(VBIsamples[field][21-10], cc1, cc2);

    // Report back the actual number of bytes copied to the destination buffer
    pStreamHeader->DataUsed = VBIfieldSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\testcap\vbidata.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"


// CC Sample waveform
unsigned char CCsampleWave[] = {
0x37,0x37,0x36,0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x38,
0x36,0x36,0x37,0x38,0x39,0x39,0x39,0x38,0x38,0x38,0x37,0x37,0x36,0x36,0x36,0x36,
0x36,0x37,0x37,0x38,0x39,0x39,0x38,0x39,0x3a,0x3d,0x3c,0x3c,0x3b,0x3e,0x41,0x43,
0x44,0x48,0x48,0x4b,0x4d,0x50,0x52,0x55,0x58,0x5b,0x5f,0x62,0x63,0x64,0x64,0x65,
0x66,0x68,0x69,0x68,0x68,0x68,0x64,0x64,0x63,0x64,0x63,0x5f,0x5a,0x58,0x56,0x54,
0x51,0x4f,0x4d,0x4c,0x4b,0x49,0x47,0x45,0x44,0x44,0x43,0x41,0x3e,0x3d,0x3b,0x39,
0x3b,0x3b,0x3c,0x3b,0x3e,0x40,0x40,0x42,0x45,0x47,0x4b,0x4c,0x4c,0x50,0x51,0x54,
0x57,0x5a,0x5b,0x5f,0x5f,0x63,0x65,0x66,0x66,0x67,0x68,0x68,0x65,0x65,0x64,0x63,
0x62,0x61,0x5f,0x5d,0x5a,0x57,0x57,0x57,0x55,0x52,0x4f,0x4d,0x4c,0x4b,0x49,0x47,
0x47,0x44,0x3f,0x3e,0x3c,0x3b,0x3c,0x3b,0x38,0x39,0x3a,0x3d,0x3d,0x41,0x43,0x45,
0x47,0x49,0x49,0x4b,0x4d,0x50,0x53,0x55,0x56,0x58,0x58,0x59,0x5c,0x60,0x64,0x67,
0x67,0x67,0x68,0x6a,0x6b,0x6c,0x6d,0x6b,0x69,0x67,0x63,0x62,0x5f,0x5d,0x59,0x57,
0x56,0x56,0x54,0x54,0x51,0x4d,0x49,0x46,0x41,0x45,0x44,0x42,0x40,0x3f,0x3e,0x40,
0x3e,0x3e,0x41,0x43,0x42,0x40,0x3e,0x3e,0x40,0x44,0x47,0x48,0x4b,0x4e,0x51,0x53,
0x54,0x57,0x5a,0x5b,0x59,0x5d,0x60,0x64,0x64,0x65,0x66,0x68,0x69,0x6b,0x6a,0x6b,
0x6a,0x68,0x65,0x62,0x60,0x62,0x60,0x5e,0x5a,0x59,0x57,0x56,0x51,0x4f,0x4d,0x4d,
0x4b,0x4a,0x48,0x46,0x41,0x40,0x3e,0x3e,0x3c,0x3a,0x38,0x38,0x38,0x3a,0x3e,0x40,
0x42,0x44,0x46,0x49,0x4b,0x4e,0x51,0x54,0x57,0x57,0x56,0x58,0x59,0x5e,0x63,0x65,
0x65,0x63,0x66,0x66,0x66,0x67,0x69,0x6a,0x6b,0x69,0x64,0x63,0x61,0x62,0x62,0x5d,
0x58,0x58,0x57,0x57,0x55,0x53,0x50,0x4f,0x4d,0x4b,0x47,0x46,0x45,0x46,0x44,0x3e,
0x3b,0x3c,0x3c,0x3c,0x3c,0x3e,0x40,0x3e,0x3c,0x3c,0x3e,0x44,0x48,0x4c,0x51,0x50,
0x4f,0x51,0x53,0x57,0x5a,0x5d,0x5d,0x5e,0x5e,0x60,0x60,0x63,0x65,0x68,0x6a,0x6a,
0x67,0x66,0x65,0x64,0x64,0x64,0x63,0x65,0x63,0x5e,0x5b,0x59,0x58,0x56,0x51,0x4d,
0x4b,0x4a,0x47,0x44,0x43,0x44,0x43,0x43,0x3f,0x3d,0x3e,0x3e,0x3c,0x3c,0x3c,0x3d,
0x3c,0x3d,0x3d,0x3e,0x42,0x46,0x47,0x4b,0x4a,0x4d,0x51,0x55,0x58,0x5e,0x60,0x61,
0x60,0x61,0x61,0x63,0x65,0x68,0x6a,0x6d,0x6c,0x6a,0x68,0x67,0x67,0x68,0x67,0x65,
0x63,0x5e,0x59,0x57,0x56,0x56,0x57,0x54,0x50,0x4c,0x49,0x47,0x45,0x44,0x41,0x3f,
0x3e,0x3c,0x39,0x3a,0x3a,0x3b,0x3b,0x3c,0x3c,0x3c,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,
0x3e,0x3d,0x3b,0x3b,0x3b,0x3d,0x40,0x42,0x41,0x3e,0x3d,0x3d,0x3b,0x3b,0x3b,0x3b,
0x3b,0x3b,0x39,0x38,0x38,0x3b,0x3e,0x3e,0x3b,0x39,0x37,0x36,0x36,0x37,0x39,0x3a,
0x39,0x39,0x39,0x3a,0x3a,0x3b,0x3a,0x39,0x36,0x37,0x37,0x39,0x3b,0x3c,0x3b,0x3b,
0x3b,0x3d,0x3d,0x3e,0x3b,0x3a,0x3a,0x39,0x39,0x3c,0x3c,0x3b,0x3b,0x3b,0x39,0x3b,
0x3d,0x3e,0x3d,0x3c,0x3b,0x3a,0x38,0x37,0x38,0x39,0x39,0x38,0x36,0x36,0x37,0x38,
0x37,0x37,0x38,0x39,0x3b,0x3e,0x43,0x4a,0x4f,0x55,0x58,0x5c,0x61,0x67,0x68,0x6b,
0x69,0x69,0x6b,0x6b,0x6b,0x6c,0x6b,0x6b,0x6b,0x6b,0x6a,0x6a,0x6a,0x6a,0x68,0x67,
0x66,0x66,0x66,0x67,0x67,0x69,0x6a,0x69,0x6a,0x6a,0x69,0x6b,0x6c,0x6e,0x6f,0x6d,
0x6a,0x68,0x67,0x67,0x67,0x69,0x68,0x68,0x68,0x69,0x69,0x6c,0x6d,0x6e,0x70,0x6f,
0x6c,0x6a,0x6a,0x6a,0x6a,0x6b,0x6b,0x69,0x67,0x67,0x67,0x6a,0x6a,0x6a,0x6b,0x6d,
0x6a,0x66,0x63,0x64,0x68,0x6b,0x6b,0x6a,0x69,0x6a,0x6b,0x6b,0x6a,0x6b,0x6e,0x70,
0x6d,0x6b,0x67,0x67,0x6a,0x6b,0x6b,0x6b,0x6b,0x6c,0x6d,0x6c,0x69,0x69,0x6a,0x6a,
0x68,0x69,0x67,0x65,0x65,0x62,0x5f,0x5c,0x57,0x53,0x4e,0x49,0x42,0x3e,0x3e,0x3e,
0x3c,0x3d,0x3a,0x38,0x39,0x38,0x37,0x37,0x36,0x36,0x37,0x38,0x37,0x39,0x3b,0x3b,
0x3b,0x3a,0x39,0x3b,0x3b,0x39,0x36,0x36,0x36,0x39,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,
0x3a,0x39,0x37,0x38,0x38,0x39,0x34,0x39,0x37,0x38,0x39,0x3b,0x39,0x39,0x38,0x37,
0x36,0x36,0x36,0x39,0x39,0x39,0x3a,0x3b,0x3b,0x39,0x38,0x38,0x38,0x39,0x39,0x39,
0x38,0x37,0x35,0x36,0x36,0x38,0x39,0x39,0x38,0x36,0x36,0x37,0x36,0x38,0x38,0x38,
0x39,0x3a,0x39,0x3b,0x3a,0x39,0x3b,0x3c,0x3b,0x3a,0x39,0x36,0x36,0x37,0x39,0x39,
0x39,0x39,0x38,0x39,0x38,0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x36,0x35,0x36,0x37,
0x37,0x36,0x36,0x37,0x37,0x38,0x39,0x38,0x36,0x36,0x35,0x33,0x33,0x34,0x35,0x36,
0x36,0x36,0x36,0x37,0x37,0x36,0x36,0x34,0x33,0x34,0x34,0x34,0x35,0x37,0x36,0x36,
0x34,0x33,0x34,0x33,0x31,0x32,0x32,0x32,0x32,0x34,0x34,0x36,0x37,0x38,0x37,0x37,
0x36,0x36,0x38,0x39,0x38,0x38,0x39,0x3a,0x39,0x3a,0x3b,0x3c,0x3d,0x37,0x36,0x36,
0x37,0x37,0x36,0x34,0x31,0x33,0x34,0x35,0x35,0x37,0x34,0x34,0x35,0x38,0x38,0x39,
0x38,0x37,0x37,0x37,0x36,0x37,0x36,0x37,0x36,0x34,0x30,0x2f,0x32,0x36,0x37,0x38,
0x37,0x37,0x36,0x36,0x36,0x39,0x38,0x36,0x34,0x32,0x31,0x34,0x37,0x39,0x3a,0x3b,
0x3b,0x3c,0x3e,0x3e,0x3c,0x3d,0x3a,0x36,0x34,0x33,0x31,0x34,0x34,0x35,0x36,0x35,
0x33,0x32,0x32,0x32,0x34,0x36,0x38,0x37,0x35,0x34,0x33,0x34,0x35,0x38,0x39,0x36,
0x35,0x36,0x34,0x32,0x31,0x34,0x37,0x3b,0x3b,0x3b,0x39,0x39,0x39,0x39,0x3a,0x3c,
0x3b,0x3d,0x3d,0x3d,0x40,0x46,0x4c,0x51,0x55,0x59,0x5e,0x62,0x65,0x68,0x6b,0x6b,
0x6b,0x6c,0x6a,0x69,0x68,0x68,0x68,0x69,0x69,0x6a,0x6a,0x6a,0x6a,0x6b,0x6b,0x6a,
0x69,0x69,0x68,0x67,0x68,0x6a,0x6a,0x6b,0x68,0x67,0x67,0x66,0x66,0x67,0x67,0x67,
0x67,0x67,0x69,0x6a,0x69,0x6a,0x6c,0x6d,0x6c,0x6a,0x6a,0x69,0x69,0x6b,0x6b,0x6b,
0x69,0x68,0x67,0x69,0x6a,0x6a,0x69,0x69,0x68,0x69,0x6a,0x6a,0x6b,0x6e,0x6b,0x67,
0x64,0x66,0x66,0x67,0x66,0x67,0x67,0x67,0x67,0x67,0x68,0x69,0x69,0x6a,0x6b,0x6b,
0x6a,0x6a,0x69,0x6a,0x6a,0x6a,0x6b,0x6c,0x6b,0x6a,0x69,0x69,0x69,0x6a,0x69,0x68,
0x67,0x65,0x62,0x60,0x5e,0x5c,0x5b,0x56,0x4f,0x49,0x43,0x3e,0x3c,0x3b,0x3b,0x39,
0x38,0x38,0x37,0x39,0x3b,0x3c,0x3c,0x3a,0x36,0x36,0x37,0x38,0x39,0x39,0x39,0x39,
0x38,0x37,0x36,0x38,0x37,0x38,0x39,0x39,0x38,0x3b,0x39,0x38,0x39,0x3b,0x3d,0x3f,
0x3e,0x3c,0x39,0x37,0x35,0x36,0x39,0x3a,0x39,0x37,0x36,0x36,0x36,0x38,0x38,0x3b,
0x3b,0x3b,0x39,0x37,0x36,0x36,0x36,0x38,0x38,0x38,0x39,0x39,0x38,0x39,0x39,0x3b,
0x3b,0x3a,0x3c,0x3b,0x39,0x3b,0x39,0x37,0x38,0x39,0x38,0x38,0x39,0x3a,0x3b,0x39,
0x38,0x36,0x36,0x36,0x35,0x38,0x39,0x39,0x38,0x36,0x35,0x37,0x39,0x3b,0x3a,0x3a,
0x39,0x38,0x36,0x36,0x39,0x3d,0x3f,0x40,0x42,0x47,0x4d,0x53,0x56,0x5a,0x60,0x63,
0x63,0x63,0x65,0x67,0x68,0x69,0x6a,0x6a,0x6a,0x69,0x69,0x6a,0x6b,0x6c,0x6c,0x6b,
0x69,0x6a,0x6a,0x6a,0x6a,0x6b,0x6a,0x6b,0x6c,0x6d,0x6b,0x6c,0x6a,0x68,0x67,0x68,
0x68,0x69,0x67,0x65,0x65,0x65,0x65,0x65,0x67,0x69,0x6a,0x6a,0x68,0x66,0x63,0x5f,
0x5b,0x58,0x52,0x4c,0x46,0x41,0x3d,0x3d,0x3c,0x3c,0x3d,0x3e,0x3e,0x3e,0x3e,0x3e,
0x3d,0x3c,0x39,0x37,0x36,0x38,0x39,0x3a,0x39,0x39,0x3b,0x3d,0x3e,0x3d,0x3d,0x3d,
0x3b,0x39,0x35,0x34,0x34,0x36,0x36,0x35,0x34,0x34,0x35,0x35,0x35,0x39,0x3b,0x3c,
0x3a,0x39,0x36,0x37,0x37,0x39,0x39,0x3c,0x40,0x42,0x46,0x4b,0x53,0x5c,0x60,0x63,
0x64,0x67,0x67,0x66,0x64,0x63,0x63,0x63,0x62,0x63,0x64,0x66,0x67,0x6a,0x6a,0x6b,
0x6b,0x6b,0x6b,0x6f,0x71,0x70,0x6d,0x6c,0x6a,0x6a,0x69,0x69,0x69,0x6d,0x6a,0x67,
0x68,0x69,0x69,0x6a,0x69,0x69,0x68,0x68,0x67,0x65,0x67,0x67,0x67,0x69,0x69,0x65,
0x62,0x5c,0x55,0x51,0x4d,0x4c,0x48,0x44,0x3e,0x3a,0x39,0x39,0x3a,0x3c,0x3d,0x3c,
0x39,0x38,0x37,0x37,0x37,0x38,0x39,0x3b,0x3a,0x39,0x37,0x34,0x36,0x38,0x3a,0x39,
0x39,0x38,0x36,0x34,0x34,0x34,0x39,0x3b,0x38,0x36,0x33,0x33,0x35,0x39,0x3b,0x3e,
0x40,0x40,0x3a,0x39,0x39,0x3b,0x3d,0x3e,0x3c,0x3e,0x3e,0x43,0x48,0x4f,0x55,0x5c,
0x5f,0x63,0x66,0x67,0x67,0x67,0x67,0x68,0x68,0x68,0x66,0x67,0x68,0x67,0x66,0x68,
0x67,0x69,0x69,0x69,0x68,0x6a,0x6c,0x6c,0x6b,0x6b,0x6a,0x6c,0x6d,0x6d,0x69,0x68,
0x68,0x69,0x6a,0x6a,0x6a,0x6b,0x69,0x67,0x67,0x68,0x67,0x67,0x66,0x64,0x63,0x64,
0x63,0x61,0x62,0x5c,0x56,0x54,0x51,0x4f,0x49,0x45,0x40,0x3d,0x3b,0x3b,0x3a,0x3d,
0x3d,0x3b,0x39,0x39,0x36,0x39,0x36,0x35,0x35,0x35,0x34,0x36,0x36,0x38,0x39,0x39,
0x39,0x3b,0x3b,0x39,0x39,0x3b,0x3a,0x38,0x36,0x34,0x34,0x36,0x37,0x38,0x39,0x38,
0x35,0x35,0x37,0x38,0x37,0x38,0x39,0x39,0x39,0x38,0x37,0x39,0x38,0x36,0x36,0x36,
0x36,0x36,0x34,0x32,0x32,0x34,0x36,0x36,0x35,0x36,0x36,0x36,0x34,0x33,0x34,0x34,
0x32,0x33,0x34,0x36,0x36,0x37,0x35,0x36,0x38,0x3b,0x3b,0x39,0x36,0x36,0x36,0x34,
};

//
/// CC sample text
//
unsigned char CCfields[][2] = {
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  '>', ' ', 
  'O', 0316,
  ' ', 'T', 
  0310,'E', 
  ' ', 'E', 
  0326,'E', 
  ' ', 'O', 
  'F', ' ', 
  'T', 0310,
  'E', ' ', 
  'W', 'O', 
  'R', 'L', 
  0304,' ', 
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'C', 0325,
  0320,' ', 
  'T', 0310,
  'E', 'R', 
  'E', ' ', 
  'I', 0323,
  ' ', 0323,
  'T', 'I', 
  'L', 'L', 
  ' ', 0316,
  'O', ' ', 
  'E', 0316,
  0304,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'I', 0316,
  ' ', 0323,
  'I', 0307,
  0310,'T', 
  ' ', 'T', 
  'O', ' ', 
  'T', 0310,
  'E', ' ', 
  0301,'I', 
  'R', ' ', 
  'F', 'R', 
  0301,0316,
  'C', 'E', 
  ' ', 0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'T', 
  'R', 'I', 
  0313,'E', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', ' ', 
  0316,'I', 
  0316,'E', 
  ' ', 0304,
  0301,0331,
  ' ', 'O', 
  'L', 0304,
  ' ', 0323,
  'T', 'R', 
  'I', 0313,
  'E', ' ', 
  0310,0301,
  0323,' ', 
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'L', 'E', 
  'F', 'T', 
  ' ', 0301,
  ' ', 0310,
  0325,0307,
  'E', ' ', 
  'C', 'L', 
  'O', 0325,
  0304,' ', 
  'O', 0326,
  'E', 'R', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'F', 'R', 
  0301,0316,
  'C', 'E', 
  ' ', 0301,
  0323,' ', 
  'I', 'T', 
  ' ', 'W', 
  'E', 'L', 
  'C', 'O', 
  0315,'E', 
  0323,' ', 
  'W', 'O', 
  'R', 'L', 
  0304,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'C', 0325,
  0320,' ', 
  'F', 0301,
  0316,0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0325,0316,
  'I', 'O', 
  0316,0323,
  ' ', 'R', 
  'E', 0320,
  'R', 'E', 
  0323,'E', 
  0316,'T', 
  'I', 0316,
  0307,' ', 
  'T', 0310,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'T', 
  'R', 'I', 
  0313,'I', 
  0316,0307,
  ' ', 0320,
  'I', 'L', 
  'O', 'T', 
  0323,' ', 
  0315,'E', 
  'T', ' ', 
  'T', 0325,
  'E', 0323,
  0304,0301,
  0331,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,0316,
  0304,' ', 
  0301,0307,
  'R', 'E', 
  'E', 0304,
  ' ', 'T', 
  'O', ' ', 
  'C', 'O', 
  0316,'T', 
  'I', 0316,
  0325,'E', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 'I', 
  'R', ' ', 
  'W', 0301,
  'L', 0313,
  'O', 0325,
  'T', ',', 
  ' ', 0302,
  0325,'T', 
  ' ', 'T', 
  0310,'E', 
  0331,' ', 
  0323,0301,
  0331,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 0331,
  0247,'R', 
  'E', ' ', 
  'R', 'E', 
  0301,0304,
  0331,' ', 
  'T', 'O', 
  ' ', 0316,
  'E', 0307,
  'O', 'T', 
  'I', 0301,
  'T', 'E', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'T', 
  ' ', 0301,
  0316,0331,
  ' ', 'T', 
  'I', 0315,
  'E', 0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,0323,
  ' ', 'C', 
  0316,0316,
  0247,0323,
  ' ', 'J', 
  'E', 'R', 
  'R', 'O', 
  'L', 0304,
  ' ', 0313,
  'E', 0323,
  0323,'E', 
  'L', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'R', 'E', 
  0320,'O', 
  'R', 'T', 
  0323,',', 
  ' ', 0301,
  'T', ' ', 
  'L', 'E', 
  0301,0323,
  'T', ' ', 
  'O', 0316,
  'E', ' ', 
  0307,'R', 
  'O', 0325,
  0320,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'O', 'F', 
  ' ', 'F', 
  0301,0316,
  0323,' ', 
  'I', 0323,
  ' ', 0316,
  'O', 'T', 
  ' ', 0302,
  'E', 'I', 
  0316,0307,
  ' ', 0323,
  'L', 'O', 
  'W', 'E', 
  0304,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0304,'O', 
  'W', 0316,
  ' ', 0302,
  0331,' ', 
  'T', 0310,
  'E', ' ', 
  0323,'T', 
  'R', 'I', 
  0313,'E', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,0272,
  ' ', 'T', 
  0310,'E', 
  ' ', 0323,
  0310,'I', 
  'R', 'T', 
  ' ', 0315,
  0301,0331,
  ' ', 0302,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0302,'R', 
  0301,0332,
  'I', 'L', 
  0247,0323,
  ' ', 'C', 
  'O', 'L', 
  'O', 'R', 
  0323,',', 
  ' ', 0302,
  0325,'T', 
  ' ', 'T', 
  0310,'E', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0307,'I', 
  0326,'E', 
  0255,0301,
  'W', 0301,
  0331,' ', 
  'I', 0323,
  ' ', 0302,
  'E', 'L', 
  'O', 'W', 
  ' ', 'T', 
  0310,'E', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 0301,
  'I', 0323,
  'T', 0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 0323,
  'E', ' ', 
  0301,'R', 
  'E', ' ', 
  'T', 0310,
  'E', ' ', 
  0323,'C', 
  'O', 'T', 
  'L', 0301,
  0316,0304,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'F', 0301,
  0316,0323,
  ',', ' ', 
  0301,' ', 
  0326,'E', 
  'R', 'I', 
  'T', 0301,
  0302,'L', 
  'E', ' ', 
  0301,'R', 
  0315,0331,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0302,0325,
  'T', ' ', 
  0325,0316,
  'L', 'I', 
  0313,'E', 
  ' ', 0323,
  'O', 0315,
  'E', ' ', 
  'O', 'T', 
  0310,'E', 
  'R', ' ', 
  'L', 'E', 
  0323,0323,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0307,'E', 
  0316,'I', 
  0301,'L', 
  ' ', 0316,
  'O', 'R', 
  'T', 0310,
  'E', 'R', 
  0316,' ', 
  'I', 0316,
  0326,0301,
  0304,'E', 
  'R', 0323,
  ' ', 0301,
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'R', 
  0315,0331,
  ',', ' ', 
  'T', 0310,
  0301,'T', 
  0247,0323,
  ' ', 0326,
  'E', 'R', 
  0331,' ', 
  'W', 'E', 
  'L', 'C', 
  'O', 0315,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'T', 
  ' ', 'T', 
  0310,'I', 
  0323,' ', 
  'W', 'O', 
  'R', 'L', 
  0304,' ', 
  'C', 0325,
  0320,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  ' ', 'I', 
  'T', 0247,
  0323,' ', 
  'T', 0310,
  'E', ' ', 
  'C', 'O', 
  0316,'T', 
  'R', 0301,
  'R', 0331,
  ' ', 'O', 
  'F', ' ', 
  0301,0316,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'R', 
  0315,0331,
  ',', ' ', 
  0302,0325,
  'T', ' ', 
  'I', 'T', 
  ' ', 'I', 
  0323,' ', 
  0301,0316,
  ' ', 0301,
  'R', 0315,
  0331,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 'R', 
  'E', 0247,
  0323,' ', 
  0323,'O', 
  0315,'E', 
  'T', 0310,
  'I', 0316,
  0307,' ', 
  0302,'E', 
  'T', 'W', 
  'E', 'E', 
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 0315,
  ' ', 'W', 
  0310,'I', 
  'C', 0310,
  ' ', 'I', 
  0323,' ', 
  0315,'O', 
  'R', 'E', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'I', 0315,
  0320,'O', 
  'R', 'T', 
  0301,0316,
  'T', ' ', 
  'T', 0310,
  0301,0316,
  ' ', 'T', 
  0310,'E', 
  ' ', 'L', 
  'O', 0326,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 0331,
  ' ', 0310,
  0301,0326,
  'E', ' ', 
  'F', 'O', 
  'R', ' ', 
  'T', 0310,
  'E', ' ', 
  'T', 'E', 
  0301,0315,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,0272,
  ' ', 0302,
  'O', 'I', 
  0323,'T', 
  'E', 'R', 
  'O', 0325,
  0323,' ', 
  0302,0325,
  'T', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'I', 
  'T', 0310,
  'O', 0325,
  'T', ' ', 
  0315,0325,
  'C', 0310,
  ' ', 0315,
  0301,'L', 
  'I', 'C', 
  'E', ',', 
  ' ', 0301,
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'E', 0316,
  0307,0301,
  0307,'I', 
  0316,0307,
  ' ', 0320,
  'L', 0301,
  0331,'F', 
  0325,'L', 
  ' ', 0301,
  0320,0320,
  'R', 'O', 
  0301,'C', 
  0310,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'E', 0316,
  0304,'E', 
  0301,'R', 
  'I', 0316,
  0307,' ', 
  'T', 0310,
  'E', 0315,
  ' ', 'T', 
  'O', ' ', 
  'F', 0301,
  0316,0323,
  ' ', 'O', 
  'F', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0315,0301,
  0316,0331,
  ' ', 'O', 
  'T', 0310,
  'E', 'R', 
  ' ', 'C', 
  'O', 0325,
  0316,'T', 
  'R', 'I', 
  'E', 0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  ' ', 'W', 
  'E', 0247,
  'L', 'L', 
  ' ', 0310,
  0301,0326,
  'E', ' ', 
  0301,' ', 
  0320,0301,
  'R', 'T', 
  0331,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'E', 
  0247,'R', 
  'E', ' ', 
  'J', 0325,
  0323,'T', 
  ' ', 'T', 
  0310,'E', 
  'R', 'E', 
  ' ', 'F', 
  'O', 'R', 
  ' ', 0301,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'L', 0301,
  0325,0307,
  0310,' ', 
  'T', 'O', 
  ' ', 'E', 
  0316,'J', 
  'O', 0331,
  ' ', 'O', 
  0325,'R', 
  0323,'E', 
  'L', 0326,
  'E', 0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,0272,
  ' ', 'T', 
  0310,'E', 
  0331,0247,
  'R', 'E', 
  ' ', 0301,
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'T', 
  'T', 'R', 
  0301,'C', 
  'T', 'I', 
  'O', 0316,
  ' ', 'T', 
  'O', ' ', 
  'T', 0310,
  'E', ' ', 
  'O', 'R', 
  0304,'I', 
  0316,0301,
  'R', 0331,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 'O', 
  0325,'R', 
  'I', 0323,
  'T', 0323,
  ' ', 0301,
  0316,0304,
  ' ', 0301,
  0316,'I', 
  0315,0301,
  'T', 'E', 
  0304,'L', 
  0331,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0307,'O', 
  'O', 0304,
  ' ', 0301,
  'T', ' ', 
  'O', 'T', 
  0310,'E', 
  'R', ' ', 
  0320,0325,
  'R', 0323,
  0325,'I', 
  'T', 0323,
  ' ', 'T', 
  'O', 'O', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'L', 
  0323,'O', 
  ',', ' ', 
  0320,'R', 
  'E', 'T', 
  'T', 0331,
  ' ', 0315,
  'O', 0304,
  'E', 0323,
  'T', ' ', 
  0301,0302,
  'O', 0325,
  'T', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', 'I', 
  'R', ' ', 
  'T', 'E', 
  0301,0315,
  0247,0323,
  ' ', 0320,
  'R', 'O', 
  0323,0320,
  'E', 'C', 
  'T', 0323,
  ',', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'O', 
  0315,'E', 
  'T', 0310,
  'I', 0316,
  0307,' ', 
  'T', 0310,
  'E', 0331,
  ' ', 0301,
  'C', 0313,
  0316,'O', 
  'W', 'L', 
  'E', 0304,
  0307,'E', 
  ',', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,'F', 
  'T', 'E', 
  'R', ' ', 
  0301,' ', 
  0323,'E', 
  'R', 'I', 
  'E', 0323,
  ' ', 'O', 
  'F', ' ', 
  0323,'O', 
  0255,0323,
  'O', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 0301,
  'R', 0315,
  0255,0325,
  0320,' ', 
  0307,0301,
  0315,'E', 
  0323,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'O', 0316,
  'E', ' ', 
  'F', 'O', 
  'R', 0315,
  'E', 'R', 
  ' ', 0323,
  'C', 'O', 
  'T', 'L', 
  0301,0316,
  0304,' ', 
  'C', 'O', 
  0301,'C', 
  0310,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'I', 0323,
  ' ', 0320,
  'R', 'E', 
  0304,'I', 
  'C', 'T', 
  'I', 0316,
  0307,' ', 
  0307,'L', 
  0325,0315,
  'L', 0331,
  ',', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0320,'E', 
  'R', 0310,
  0301,0320,
  0323,' ', 
  'R', 'E', 
  0301,'L', 
  'I', 0323,
  'T', 'I', 
  'C', 0301,
  'L', 'L', 
  0331,',', 
  ' ', 'T', 
  0310,0301,
  'T', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'C', 
  'O', 'T', 
  'L', 0301,
  0316,0304,
  ' ', 'W', 
  'I', 'L', 
  'L', ' ', 
  0302,'E', 
  ' ', 0310,
  'O', 0315,
  'E', ' ', 
  'E', 0326,
  'E', 0316,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0302,'E', 
  'F', 'O', 
  'R', 'E', 
  ' ', 'T', 
  0310,'E', 
  ' ', 0320,
  'O', 0323,
  'T', 'C', 
  0301,'R', 
  0304,0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', ' ', 
  0301,0316,
  'T', 0310,
  'E', 0315,
  0323,' ', 
  'O', 'F', 
  ' ', 'O', 
  'T', 0310,
  'E', 'R', 
  ' ', 'W', 
  'O', 'R', 
  'L', 0304,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'C', 0325,
  0320,' ', 
  0316,0301,
  'T', 'I', 
  'O', 0316,
  0323,' ', 
  0301,'R', 
  'E', ' ', 
  0315,'O', 
  0323,'T', 
  'L', 0331,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 'R', 
  'I', 0325,
  0315,0320,
  0310,0301,
  'L', 'I', 
  0323,'T', 
  ',', ' ', 
  0301,'L', 
  'L', ' ', 
  0301,0302,
  'O', 0325,
  'T', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'I', 
  0316,0316,
  'I', 0316,
  0307,' ', 
  'T', 0310,
  'E', ' ', 
  'C', 0325,
  0320,' ', 
  0301,0316,
  0304,' ', 
  0302,'E', 
  0301,'T', 
  'I', 0316,
  0307,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'E', 0326,
  'E', 'R', 
  0331,'O', 
  0316,'E', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'C', 
  'O', 'T', 
  'L', 0301,
  0316,0304,
  0247,0323,
  ' ', 0315,
  'O', 0304,
  'E', 0323,
  'T', 'L', 
  0331,' ', 
  0325,'R', 
  0307,'E', 
  0323,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', ' ', 
  'T', 'E', 
  0301,0315,
  ' ', 'T', 
  'O', ' ', 
  'T', 'R', 
  0331,' ', 
  0316,'O', 
  'T', ' ', 
  'T', 'O', 
  ' ', 'C', 
  'O', 0315,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0310,'O', 
  0315,'E', 
  ' ', 'T', 
  'O', 'O', 
  ' ', 0323,
  'O', 'O', 
  0316,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0316,'O', 
  ' ', 'I', 
  0316,'F', 
  'E', 'R', 
  'I', 'O', 
  'R', 'I', 
  'T', 0331,
  ' ', 'C', 
  'O', 0315,
  0320,'L', 
  'E', 'X', 
  ',', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0310,'O', 
  'W', 'E', 
  0326,'E', 
  'R', ',', 
  ' ', 0301,
  0302,'O', 
  0325,'T', 
  ' ', 0315,
  'E', 'E', 
  'T', 'I', 
  0316,0307,
  ' ', 'T', 
  0310,'E', 
  ' ', 0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'O', 
  'R', 'L', 
  0304,0247,
  0323,' ', 
  0323,'E', 
  0316,'T', 
  'I', 0315,
  'E', 0316,
  'T', 0301,
  'L', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'F', 0301,
  0326,'O', 
  'R', 'I', 
  'T', 'E', 
  0323,' ', 
  0302,'R', 
  0301,0332,
  'I', 'L', 
  ' ', 'I', 
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'E', 
  0304,0316,
  'E', 0323,
  0304,0301,
  0331,0247,
  0323,' ', 
  'W', 'O', 
  'R', 'L', 
  0304,' ', 
  'C', 0325,
  0320,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'O', 0320,
  'E', 0316,
  'E', 'R', 
  0277,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  ' ', 'I', 
  'T', 0247,
  0323,' ', 
  'T', 0310,
  'E', ' ', 
  0323,0310,
  'O', 'W', 
  0320,'I', 
  'E', 'C', 
  'E', ' ', 
  0307,0301,
  0315,'E', 
  ',', ' ', 
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', ' ', 
  'F', 'I', 
  'R', 0323,
  'T', ' ', 
  0307,0301,
  0315,'E', 
  ',', ' ', 
  'T', 'R', 
  'E', 0315,
  'E', 0316,
  0304,'O', 
  0325,0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'O', 
  ' ', 0315,
  0301,0316,
  0331,' ', 
  0315,'I', 
  'L', 'L', 
  'I', 'O', 
  0316,0323,
  ' ', 'O', 
  'F', ' ', 
  0320,'E', 
  'O', 0320,
  'L', 'E', 
  ' ', 0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'I', 
  'L', 'L', 
  ' ', 0302,
  'E', ' ', 
  'W', 0301,
  'T', 'C', 
  0310,'I', 
  0316,0307,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'C', 
  'O', 'T', 
  'L', 0301,
  0316,0304,
  ',', ' ', 
  0316,'O', 
  0302,'O', 
  0304,0331,
  ' ', 'E', 
  'X', 0320,
  'E', 'C', 
  'T', 0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,0272,
  ' ', 'O', 
  0316,'L', 
  0331,' ', 
  'O', 0316,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0304,'E', 
  'E', 0320,
  0255,0323,
  'E', 0301,
  'T', 'E', 
  0304,' ', 
  'F', 'E', 
  0301,'R', 
  ',', ' ', 
  'I', 'F', 
  ' ', 'T', 
  0310,'E', 
  'I', 'R', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 'E', 
  0301,0315,
  ' ', 0315,
  0301,0313,
  'E', 0323,
  ' ', 0301,
  0316,' ', 
  'E', 0301,
  'R', 'L', 
  0331,' ', 
  'E', 'X', 
  'I', 'T', 
  ',', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  0301,'T', 
  ' ', 'T', 
  0310,'E', 
  ' ', 'O', 
  'L', 0304,
  ' ', 'E', 
  0316,'E', 
  0315,0331,
  ' ', 'E', 
  0316,0307,
  'L', 0301,
  0316,0304,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0315,'I', 
  0307,0310,
  'T', ' ', 
  'F', 0301,
  'R', 'E', 
  ' ', 0302,
  'E', 'T', 
  'T', 'E', 
  'R', 0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  ' ', 'I', 
  ' ', 0304,
  'O', 0316,
  0247,'T', 
  ' ', 'W', 
  0301,0316,
  'T', ' ', 
  'T', 'O', 
  ' ', 'T', 
  0310,'I', 
  0316,0313,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,0302,
  'O', 0325,
  'T', ' ', 
  'T', 0310,
  0301,'T', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,0272,
  ' ', 0315,
  0301,0316,
  0331,' ', 
  0323,'C', 
  'O', 'T', 
  'T', 'I', 
  0323,0310,
  ' ', 'F', 
  0301,0316,
  0323,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'C', 'R', 
  'O', 0323,
  0323,'E', 
  0304,' ', 
  'T', 0310,
  'E', ' ', 
  'C', 0310,
  0301,0316,
  0316,'E', 
  'L', ',', 
  ' ', 'E', 
  0326,'E', 
  0316,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'O', 0325,
  0307,0310,
  ' ', 'T', 
  0310,'E', 
  0331,' ', 
  0304,'O', 
  0316,0247,
  'T', ' ', 
  0310,0301,
  0326,'E', 
  ' ', 0307,
  0301,0315,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 'I', 
  'C', 0313,
  'E', 'T', 
  0323,',', 
  ' ', 0301,
  ' ', 'F', 
  0301,0315,
  'I', 'L', 
  'I', 0301,
  'R', ' ', 
  0307,'R', 
  'I', 0320,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,0323,
  ' ', 'T', 
  0310,'E', 
  ' ', 0323,
  'E', 0301,
  'R', 'C', 
  0310,' ', 
  'F', 'O', 
  'R', ' ', 
  'W', 0301,
  0331,0323,
  ' ', 'T', 
  'O', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0302,'E', 
  0301,'T', 
  ' ', 'T', 
  0310,'E', 
  ' ', 0323,
  'O', 'L', 
  0304,0255,
  'O', 0325,
  'T', ' ', 
  0323,'I', 
  0307,0316,
  0323,' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'C', 'O', 
  0316,'T', 
  'I', 0316,
  0325,'E', 
  0323,',', 
  ' ', 'F', 
  'O', 'R', 
  ' ', 0323,
  'O', 0315,
  'E', ',', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0320,'R', 
  'E', 'F', 
  'E', 'R', 
  0301,0302,
  'L', 0331,
  ' ', 0316,
  'O', 'T', 
  ' ', 'I', 
  0316,' ', 
  'T', 0310,
  'E', ' ', 
  'F', 0325,
  'L', 'L', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0307,'L', 
  0301,'R', 
  'E', ' ', 
  'O', 'F', 
  ' ', 'T', 
  0310,'E', 
  ' ', 'C', 
  0301,0315,
  'E', 'R', 
  0301,0323,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  0200,0200,
  0200,0200,
  ' ', 'L', 
  'E', 0301,
  0326,'E', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  ' ', 0315,
  'E', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  ' ', 0301,
  'L', 'O', 
  0316,'E', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  '>', '>', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'F', 'R', 
  'I', 'E', 
  0316,0304,
  'L', 0331,
  ' ', 'I', 
  0316,'T', 
  'E', 'R', 
  'C', 0310,
  0301,0316,
  0307,'E', 
  0323,' ', 
  'W', 'I', 
  'T', 0310,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'T', 0310,
  'E', ' ', 
  0302,'R', 
  0301,0332,
  'I', 'L', 
  'I', 0301,
  0316,' ', 
  0323,0325,
  0320,0320,
  'O', 'R', 
  'T', 'E', 
  'R', 0323,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'E', 0326,
  'E', 0316,
  ' ', 'E', 
  'X', 'T', 
  'E', 0316,
  0304,' ', 
  'T', 'O', 
  ' ', 0301,
  ' ', 0315,
  0301,0313,
  'E', 0323,
  0310,'I', 
  'F', 'T', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'F', 'I', 
  'E', 'L', 
  0304,' ', 
  'F', 'O', 
  'R', ' ', 
  0301,0316,
  ' ', 'I', 
  0316,'F', 
  'O', 'R', 
  0315,0301,
  'L', ' ', 
  0302,0325,
  'T', ' ', 
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0310,'O', 
  'T', 'L', 
  0331,' ', 
  'C', 'O', 
  0316,'T', 
  'E', 0323,
  'T', 'E', 
  0304,' ', 
  0307,0301,
  0315,'E', 
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 0310,
  'E', 0316,
  ' ', 'I', 
  'T', ' ', 
  'W', 0301,
  0323,' ', 
  'T', 'I', 
  0315,'E', 
  ' ', 'F', 
  'O', 'R', 
  ' ', 0313,
  0316,'E', 
  'E', 0323,
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0325,0320,
  ' ', 0301,
  0316,0304,
  ' ', 0301,
  0316,'O', 
  'T', 0310,
  'E', 'R', 
  ' ', 0307,
  'L', 0301,
  0323,0323,
  ',', ' ', 
  'T', 0310,
  'E', ' ', 
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0323,'C', 
  'O', 'T', 
  0323,' ', 
  'W', 'E', 
  'R', 'E', 
  ' ', 0301,
  ' ', 0307,
  'O', 0301,
  'L', ' ', 
  0301,0310,
  'E', 0301,
  0304,0256,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  0301,' ', 
  0323,'E', 
  'R', 'I', 
  'O', 0325,
  0323,' ', 
  'F', 'O', 
  'R', 'E', 
  'C', 0301,
  0323,'T', 
  ' ', 'F', 
  'O', 'R', 
  ' ', 0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'W', 'E', 
  0304,0316,
  'E', 0323,
  0304,0301,
  0331,0247,
  0323,' ', 
  'O', 0320,
  'E', 0316,
  'E', 'R', 
  ',', ' ', 
  'O', 'R', 
  ' ', 0315,
  'O', 'R', 
  'E', ' ', 
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'L', 'I', 
  0313,'E', 
  'L', 0331,
  ',', ' ', 
  'J', 0325,
  0323,'T', 
  ' ', 0301,
  0316,'O', 
  'T', 0310,
  'E', 'R', 
  ' ', 0304,
  'R', 'E', 
  0301,0315,
  0256,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0224,'%', 
  0224,'%', 
  0224,0255,
  0224,0255,
  0221,'p', 
  0221,'p', 
  'J', 'E', 
  'R', 'R', 
  'O', 'L', 
  0304,' ', 
  0313,'E', 
  0323,0323,
  'E', 'L', 
  ',', ' ', 
  'C', 0316,
  0316,',', 
  ' ', 0320,
  0301,'R', 
  'I', 0323,
  0256,0200,

  // 1st 1 sec delay
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,

  // 2nd 1 sec delay
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,

  // 3rd 1 sec delay
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,

  // 4th 1 sec delay
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,

  // 5th 1 sec delay
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
  0200,0200,
};
unsigned int CCfieldCount = sizeof (CCfields) / sizeof (CCfields[0]);


//
/// NABTS field images
//
unsigned char NABTSfields[][sizeof (NABTS_BUFFER)] = {
  0x55,0x55,0xE7, 0xD0,0xEA,0x64, 0x15,0x15,  0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
};
unsigned int NABTSfieldCount = sizeof (NABTSfields) / sizeof (NABTSfields[0]);


//
/// VBI waveform samples
//
unsigned char VBIsamples[][12][768*2] = {
//Field 0
// Line 10
0x38,0x38,0x38,0x39,0x3b,0x3b,0x3a,0x3a,0x39,0x38,0x38,0x35,0x34,0x36,0x36,0x35,
0x34,0x35,0x35,0x36,0x35,0x34,0x34,0x37,0x39,0x39,0x35,0x32,0x33,0x37,0x38,0x39,
0x38,0x38,0x36,0x35,0x33,0x35,0x37,0x39,0x38,0x38,0x39,0x39,0x38,0x3a,0x3b,0x38,
0x36,0x35,0x33,0x33,0x33,0x34,0x35,0x36,0x36,0x37,0x38,0x38,0x37,0x3a,0x3b,0x3b,
0x3a,0x38,0x37,0x38,0x37,0x38,0x39,0x3a,0x38,0x36,0x34,0x33,0x33,0x34,0x36,0x38,
0x39,0x39,0x37,0x35,0x31,0x33,0x36,0x38,0x37,0x37,0x36,0x36,0x37,0x37,0x36,0x38,
0x39,0x38,0x36,0x35,0x36,0x38,0x38,0x38,0x36,0x36,0x36,0x37,0x38,0x38,0x36,0x37,
0x38,0x39,0x38,0x3c,0x3a,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x3a,0x38,0x36,0x35,
0x33,0x33,0x32,0x31,0x31,0x33,0x36,0x38,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x38,0x39,
0x37,0x35,0x33,0x33,0x33,0x35,0x35,0x36,0x35,0x36,0x36,0x35,0x36,0x38,0x39,0x3a,
0x38,0x37,0x38,0x39,0x37,0x37,0x36,0x36,0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x3b,
0x3b,0x3b,0x3b,0x38,0x37,0x37,0x37,0x37,0x36,0x36,0x34,0x33,0x33,0x35,0x37,0x3b,
0x3c,0x3d,0x3c,0x3b,0x39,0x39,0x38,0x39,0x3b,0x3a,0x37,0x36,0x34,0x35,0x35,0x36,
0x38,0x39,0x38,0x36,0x34,0x36,0x37,0x38,0x38,0x39,0x39,0x3b,0x39,0x39,0x38,0x38,
0x36,0x38,0x3a,0x3a,0x38,0x3b,0x3a,0x38,0x39,0x39,0x3a,0x38,0x36,0x34,0x34,0x35,
0x34,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x37,0x38,0x38,0x39,0x37,0x36,0x36,0x35,
0x35,0x37,0x37,0x38,0x38,0x39,0x38,0x37,0x38,0x3b,0x3b,0x3b,0x39,0x38,0x3a,0x3b,
0x39,0x3b,0x39,0x38,0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x38,0x37,0x35,0x38,0x3a,
0x39,0x3b,0x39,0x39,0x3a,0x3a,0x38,0x3a,0x3d,0x3d,0x3c,0x3a,0x37,0x38,0x38,0x38,
0x37,0x36,0x36,0x35,0x36,0x36,0x38,0x39,0x39,0x38,0x39,0x3a,0x3a,0x39,0x38,0x38,
0x38,0x38,0x37,0x37,0x36,0x37,0x38,0x39,0x39,0x38,0x39,0x38,0x36,0x38,0x39,0x3b,
0x39,0x39,0x38,0x37,0x37,0x38,0x36,0x39,0x36,0x35,0x36,0x37,0x38,0x3b,0x39,0x38,
0x38,0x38,0x39,0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x39,0x3a,0x39,0x39,
0x3a,0x39,0x38,0x38,0x37,0x39,0x37,0x39,0x38,0x3a,0x3c,0x3b,0x38,0x3b,0x3b,0x3d,
0x3d,0x3c,0x38,0x38,0x36,0x37,0x38,0x37,0x36,0x35,0x34,0x33,0x33,0x36,0x38,0x39,
0x39,0x39,0x39,0x3b,0x3b,0x3c,0x3f,0x3e,0x3b,0x3b,0x3c,0x3d,0x3c,0x3a,0x38,0x38,
0x38,0x39,0x37,0x3a,0x37,0x38,0x38,0x38,0x36,0x39,0x3a,0x3a,0x39,0x38,0x38,0x3a,
0x38,0x38,0x38,0x38,0x36,0x35,0x34,0x35,0x35,0x35,0x34,0x36,0x38,0x39,0x39,0x3c,
0x3d,0x3c,0x3b,0x39,0x37,0x38,0x38,0x39,0x36,0x36,0x36,0x35,0x36,0x37,0x38,0x3c,
0x3b,0x39,0x38,0x38,0x38,0x39,0x39,0x39,0x3a,0x3b,0x3b,0x39,0x3a,0x38,0x38,0x39,
0x39,0x38,0x38,0x37,0x36,0x39,0x3b,0x3c,0x3b,0x3c,0x3b,0x3a,0x3b,0x3a,0x38,0x38,
0x38,0x38,0x38,0x37,0x36,0x38,0x39,0x39,0x3b,0x3c,0x3c,0x3c,0x3b,0x3c,0x3d,0x3d,
0x3d,0x3d,0x3c,0x39,0x36,0x36,0x36,0x38,0x38,0x38,0x36,0x36,0x38,0x3b,0x3c,0x3c,
0x3b,0x3d,0x3d,0x3c,0x38,0x39,0x38,0x37,0x37,0x36,0x35,0x38,0x39,0x38,0x3a,0x3c,
0x3d,0x3c,0x3b,0x3b,0x3d,0x3f,0x3e,0x3d,0x3a,0x38,0x36,0x37,0x36,0x36,0x37,0x37,
0x36,0x37,0x37,0x38,0x38,0x38,0x37,0x38,0x38,0x38,0x36,0x35,0x34,0x35,0x36,0x36,
0x34,0x35,0x34,0x35,0x37,0x39,0x39,0x39,0x38,0x37,0x36,0x37,0x38,0x3a,0x3a,0x39,
0x36,0x36,0x34,0x36,0x39,0x39,0x37,0x39,0x39,0x39,0x38,0x38,0x35,0x36,0x38,0x38,
0x35,0x35,0x34,0x35,0x37,0x36,0x34,0x36,0x38,0x39,0x38,0x36,0x36,0x38,0x38,0x38,
0x37,0x37,0x38,0x39,0x39,0x37,0x35,0x36,0x36,0x38,0x38,0x36,0x34,0x37,0x39,0x39,
0x38,0x36,0x36,0x39,0x3c,0x3b,0x38,0x37,0x36,0x36,0x36,0x37,0x37,0x39,0x39,0x38,
0x38,0x39,0x3b,0x3d,0x3e,0x3d,0x3a,0x36,0x36,0x35,0x35,0x34,0x35,0x38,0x39,0x39,
0x38,0x37,0x36,0x38,0x38,0x38,0x3a,0x39,0x37,0x37,0x37,0x37,0x36,0x38,0x39,0x39,
0x38,0x38,0x39,0x3a,0x39,0x38,0x38,0x38,0x39,0x3b,0x39,0x38,0x38,0x3a,0x3b,0x38,
0x37,0x3a,0x3b,0x3c,0x3b,0x38,0x39,0x38,0x37,0x39,0x38,0x39,0x39,0x37,0x35,0x37,
0x38,0x3c,0x3d,0x3d,0x3a,0x38,0x38,0x37,0x36,0x37,0x37,0x38,0x38,0x37,0x37,0x39,
0x39,0x38,0x39,0x3c,0x3c,0x3c,0x38,0x38,0x37,0x39,0x38,0x37,0x36,0x36,0x34,0x33,
0x33,0x35,0x37,0x38,0x37,0x37,0x37,0x38,0x38,0x3a,0x3a,0x39,0x38,0x37,0x35,0x36,
0x36,0x38,0x38,0x39,0x38,0x38,0x37,0x36,0x37,0x38,0x38,0x39,0x38,0x39,0x39,0x3b,
0x38,0x36,0x37,0x38,0x38,0x38,0x36,0x36,0x35,0x35,0x34,0x36,0x39,0x3a,0x39,0x38,
0x39,0x3b,0x3c,0x39,0x35,0x35,0x35,0x34,0x34,0x35,0x36,0x34,0x34,0x34,0x36,0x39,
0x3b,0x3a,0x3a,0x38,0x37,0x39,0x3a,0x3a,0x3a,0x3b,0x38,0x39,0x37,0x36,0x36,0x38,
0x36,0x37,0x38,0x3b,0x3b,0x3d,0x3c,0x3b,0x3b,0x3a,0x38,0x37,0x36,0x36,0x35,0x35,
0x34,0x36,0x35,0x34,0x34,0x35,0x36,0x36,0x36,0x36,0x34,0x35,0x34,0x35,0x37,0x39,
0x3a,0x3b,0x38,0x36,0x36,0x35,0x35,0x36,0x37,0x38,0x37,0x36,0x35,0x37,0x3a,0x3c,
0x3d,0x3e,0x3c,0x3b,0x3b,0x39,0x3a,0x3a,0x39,0x37,0x36,0x35,0x34,0x34,0x34,0x34,
0x34,0x36,0x36,0x36,0x37,0x38,0x38,0x39,0x38,0x38,0x38,0x37,0x34,0x34,0x34,0x35,
0x35,0x36,0x36,0x36,0x38,0x39,0x38,0x38,0x35,0x36,0x37,0x38,0x38,0x38,0x38,0x38,
0x36,0x37,0x38,0x39,0x3a,0x38,0x36,0x36,0x36,0x36,0x38,0x39,0x38,0x38,0x37,0x36,
0x35,0x35,0x33,0x34,0x32,0x33,0x33,0x33,0x31,0x33,0x36,0x37,0x36,0x37,0x38,0x3a,
0x3a,0x38,0x38,0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x37,0x34,0x31,0x35,0x38,0x39,
0x3a,0x39,0x37,0x3a,0x3a,0x3a,0x3a,0x3c,0x3b,0x3a,0x38,0x38,0x35,0x36,0x34,0x34,
0x34,0x36,0x37,0x37,0x37,0x37,0x37,0x35,0x34,0x36,0x36,0x35,0x35,0x34,0x34,0x33,
0x32,0x33,0x33,0x34,0x35,0x36,0x37,0x37,0x38,0x3b,0x3a,0x39,0x3a,0x3b,0x39,0x38,
0x37,0x38,0x38,0x38,0x35,0x34,0x35,0x36,0x36,0x36,0x36,0x37,0x3a,0x3b,0x39,0x39,
0x3a,0x3a,0x38,0x37,0x36,0x37,0x35,0x34,0x34,0x36,0x36,0x36,0x36,0x35,0x34,0x34,
0x34,0x34,0x35,0x35,0x34,0x36,0x38,0x3a,0x39,0x39,0x38,0x38,0x37,0x38,0x36,0x37,
0x39,0x3b,0x3c,0x3b,0x38,0x39,0x37,0x34,0x32,0x34,0x35,0x34,0x34,0x32,0x32,0x35,
0x36,0x38,0x38,0x37,0x36,0x37,0x36,0x36,0x38,0x3a,0x3a,0x3b,0x3a,0x3b,0x3b,0x39,
0x36,0x36,0x36,0x36,0x35,0x35,0x34,0x34,0x36,0x37,0x38,0x39,0x39,0x38,0x37,0x36,
0x36,0x38,0x3a,0x3a,0x37,0x37,0x37,0x36,0x35,0x35,0x35,0x36,0x35,0x34,0x34,0x35,
0x35,0x38,0x38,0x37,0x34,0x34,0x34,0x34,0x33,0x34,0x34,0x35,0x33,0x33,0x37,0x39,
0x38,0x39,0x38,0x38,0x37,0x37,0x38,0x39,0x38,0x36,0x35,0x36,0x36,0x36,0x38,0x37,
0x34,0x35,0x34,0x34,0x35,0x37,0x37,0x38,0x38,0x39,0x38,0x38,0x38,0x39,0x3b,0x3a,
0x38,0x38,0x37,0x35,0x36,0x38,0x3a,0x3b,0x38,0x38,0x38,0x36,0x35,0x36,0x37,0x37,
0x36,0x37,0x38,0x38,0x38,0x35,0x34,0x35,0x34,0x34,0x35,0x37,0x38,0x38,0x38,0x39,
0x38,0x38,0x38,0x38,0x36,0x36,0x34,0x34,0x34,0x34,0x35,0x37,0x37,0x39,0x39,0x39,
0x38,0x38,0x38,0x38,0x36,0x35,0x34,0x35,0x35,0x36,0x36,0x35,0x35,0x38,0x37,0x37,
0x37,0x39,0x38,0x38,0x36,0x36,0x35,0x36,0x35,0x36,0x38,0x39,0x37,0x36,0x35,0x31,
0x31,0x33,0x33,0x31,0x31,0x30,0x30,0x30,0x32,0x33,0x37,0x38,0x38,0x39,0x37,0x34,
0x35,0x36,0x36,0x38,0x38,0x38,0x36,0x34,0x33,0x35,0x36,0x38,0x38,0x38,0x36,0x34,
0x33,0x33,0x35,0x37,0x36,0x35,0x35,0x36,0x36,0x35,0x35,0x38,0x3b,0x3b,0x3c,0x3d,
0x3d,0x3d,0x3b,0x3b,0x39,0x3a,0x3a,0x38,0x34,0x35,0x34,0x34,0x34,0x35,0x37,0x39,
0x39,0x39,0x39,0x39,0x38,0x38,0x38,0x38,0x37,0x3a,0x39,0x38,0x39,0x39,0x38,0x37,
0x36,0x36,0x37,0x38,0x38,0x39,0x3a,0x39,0x38,0x3b,0x3c,0x3a,0x39,0x38,0x37,0x37,
0x36,0x35,0x34,0x33,0x33,0x36,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x36,0x36,
0x36,0x36,0x36,0x36,0x35,0x35,0x36,0x36,0x38,0x38,0x38,0x38,0x37,0x36,0x37,0x39,
0x39,0x3b,0x3c,0x3c,0x3a,0x3b,0x3a,0x3a,0x38,0x37,0x35,0x36,0x35,0x36,0x33,0x36,
0x36,0x37,0x39,0x3a,0x3b,0x3e,0x3d,0x3b,0x39,0x39,0x37,0x36,0x35,0x35,0x37,0x38,
0x39,0x38,0x38,0x37,0x37,0x38,0x39,0x3b,0x3d,0x3b,0x38,0x36,0x35,0x37,0x38,0x37,
0x36,0x37,0x36,0x36,0x35,0x36,0x36,0x39,0x3b,0x3c,0x39,0x3c,0x38,0x39,0x39,0x38,
0x37,0x38,0x38,0x38,0x38,0x39,0x38,0x39,0x38,0x38,0x37,0x36,0x35,0x36,0x37,0x37,
0x36,0x38,0x39,0x38,0x37,0x36,0x35,0x37,0x38,0x3a,0x3a,0x38,0x34,0x34,0x36,0x38,
0x3a,0x3d,0x3c,0x39,0x39,0x3b,0x3b,0x3d,0x3c,0x3d,0x3d,0x3b,0x35,0x33,0x33,0x34,
0x34,0x35,0x36,0x35,0x35,0x36,0x37,0x36,0x35,0x34,0x34,0x33,0x32,0x34,0x36,0x36,
0x35,0x33,0x33,0x35,0x38,0x39,0x37,0x3b,0x39,0x35,0x34,0x36,0x36,0x39,0x38,0x36,
// Line 11
0x36,0x37,0x38,0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x35,0x36,0x34,0x34,0x33,0x32,
0x32,0x34,0x35,0x36,0x38,0x3b,0x3b,0x3a,0x37,0x36,0x38,0x3a,0x3b,0x3a,0x37,0x33,
0x30,0x32,0x32,0x34,0x38,0x3a,0x39,0x36,0x32,0x32,0x34,0x38,0x3b,0x3c,0x39,0x34,
0x30,0x33,0x3b,0x4a,0x5f,0x71,0x7b,0x7a,0x6f,0x61,0x57,0x56,0x5c,0x67,0x71,0x75,
0x76,0x70,0x66,0x5d,0x59,0x5d,0x63,0x6b,0x70,0x73,0x72,0x6a,0x60,0x5a,0x58,0x5d,
0x65,0x6c,0x71,0x75,0x73,0x6b,0x61,0x59,0x59,0x5d,0x64,0x6b,0x70,0x75,0x70,0x68,
0x61,0x5d,0x5e,0x61,0x6a,0x71,0x75,0x76,0x72,0x6a,0x63,0x5d,0x5b,0x5f,0x65,0x6c,
0x71,0x72,0x6e,0x68,0x61,0x5d,0x5b,0x60,0x67,0x72,0x79,0x7b,0x77,0x6f,0x68,0x61,
0x60,0x63,0x68,0x6c,0x6c,0x6b,0x6c,0x72,0x7b,0x88,0x94,0xa0,0xa9,0xab,0xa4,0x96,
0x88,0x78,0x67,0x5e,0x58,0x55,0x52,0x4c,0x44,0x3d,0x39,0x3d,0x4b,0x5d,0x6e,0x7c,
0x86,0x8d,0x8f,0x91,0x93,0x9a,0x9f,0x9d,0x97,0x97,0x96,0x97,0x96,0x94,0x8d,0x82,
0x73,0x65,0x59,0x53,0x4c,0x42,0x3a,0x33,0x34,0x42,0x56,0x6b,0x79,0x7e,0x7a,0x72,
0x65,0x5d,0x56,0x50,0x47,0x3e,0x35,0x33,0x3a,0x4d,0x63,0x75,0x80,0x81,0x76,0x68,
0x59,0x4f,0x48,0x44,0x41,0x3d,0x38,0x32,0x30,0x32,0x39,0x44,0x52,0x5f,0x6c,0x76,
0x77,0x71,0x69,0x61,0x59,0x56,0x50,0x4a,0x40,0x36,0x30,0x36,0x46,0x5d,0x73,0x85,
0x8e,0x93,0x95,0x95,0x91,0x8b,0x7e,0x6d,0x5d,0x53,0x55,0x61,0x6f,0x77,0x77,0x70,
0x67,0x5f,0x5f,0x5d,0x56,0x4b,0x3b,0x2e,0x2c,0x36,0x48,0x63,0x75,0x7e,0x77,0x6c,
0x60,0x5a,0x56,0x50,0x44,0x3e,0x33,0x32,0x3c,0x4f,0x65,0x79,0x80,0x7c,0x71,0x64,
0x57,0x52,0x4c,0x46,0x40,0x3a,0x35,0x32,0x31,0x33,0x39,0x41,0x47,0x50,0x5a,0x67,
0x73,0x80,0x8a,0x91,0x93,0x92,0x8a,0x7d,0x6d,0x5d,0x4c,0x44,0x3b,0x38,0x3a,0x3c,
0x3c,0x3b,0x37,0x34,0x38,0x42,0x52,0x62,0x70,0x76,0x73,0x6b,0x60,0x57,0x53,0x50,
0x4b,0x44,0x39,0x2e,0x26,0x26,0x2d,0x3a,0x42,0x44,0x3e,0x34,0x2c,0x2f,0x3e,0x53,
0x69,0x79,0x7e,0x7a,0x6f,0x64,0x5b,0x5b,0x5f,0x65,0x6a,0x6d,0x74,0x7c,0x88,0x92,
0x99,0x9b,0x93,0x84,0x71,0x5d,0x4c,0x43,0x3d,0x3b,0x39,0x38,0x36,0x37,0x38,0x39,
0x3a,0x3a,0x38,0x35,0x34,0x36,0x37,0x38,0x38,0x38,0x38,0x37,0x36,0x38,0x39,0x39,
0x37,0x36,0x37,0x36,0x3a,0x3a,0x3a,0x3b,0x3a,0x37,0x39,0x39,0x39,0x3c,0x3d,0x3c,
0x3a,0x38,0x36,0x38,0x38,0x38,0x37,0x38,0x37,0x38,0x38,0x3a,0x3a,0x3b,0x3b,0x3e,
0x40,0x40,0x3d,0x3a,0x38,0x39,0x3a,0x3b,0x3b,0x3c,0x3a,0x37,0x34,0x36,0x39,0x3a,
0x3c,0x3a,0x36,0x36,0x36,0x38,0x3a,0x3b,0x3a,0x3a,0x37,0x37,0x35,0x34,0x34,0x34,
0x34,0x36,0x36,0x38,0x37,0x39,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x36,
0x36,0x37,0x35,0x36,0x36,0x38,0x3a,0x39,0x38,0x3a,0x3a,0x3b,0x3b,0x3a,0x3a,0x3b,
0x39,0x39,0x39,0x3a,0x3b,0x3a,0x3a,0x39,0x37,0x36,0x39,0x3a,0x3d,0x3f,0x3e,0x3d,
0x3a,0x38,0x39,0x3b,0x3c,0x3b,0x3b,0x37,0x34,0x36,0x36,0x38,0x3c,0x3b,0x3a,0x3a,
0x38,0x38,0x38,0x39,0x3a,0x3d,0x3d,0x3d,0x3b,0x3a,0x3a,0x39,0x39,0x39,0x39,0x39,
0x39,0x38,0x39,0x39,0x39,0x39,0x38,0x38,0x39,0x39,0x38,0x39,0x37,0x36,0x36,0x36,
0x36,0x38,0x3a,0x38,0x35,0x36,0x34,0x34,0x34,0x36,0x35,0x38,0x38,0x38,0x36,0x38,
0x38,0x38,0x37,0x36,0x34,0x33,0x31,0x32,0x34,0x36,0x35,0x37,0x36,0x36,0x37,0x38,
0x39,0x3b,0x3c,0x3b,0x3a,0x39,0x39,0x39,0x38,0x39,0x37,0x38,0x37,0x37,0x36,0x35,
0x34,0x39,0x3b,0x3b,0x38,0x37,0x38,0x3a,0x39,0x37,0x37,0x38,0x38,0x38,0x37,0x36,
0x36,0x38,0x3a,0x39,0x38,0x38,0x39,0x3b,0x3a,0x39,0x38,0x39,0x39,0x37,0x38,0x36,
0x34,0x36,0x37,0x37,0x38,0x37,0x38,0x3e,0x40,0x41,0x3e,0x3d,0x3a,0x39,0x38,0x37,
0x36,0x3a,0x3a,0x35,0x32,0x31,0x32,0x35,0x36,0x36,0x36,0x34,0x33,0x32,0x32,0x33,
0x37,0x3b,0x3b,0x39,0x36,0x36,0x36,0x37,0x37,0x38,0x37,0x36,0x34,0x37,0x38,0x39,
0x3a,0x3b,0x3c,0x3b,0x3a,0x39,0x35,0x37,0x34,0x32,0x34,0x34,0x35,0x36,0x36,0x34,
0x35,0x36,0x36,0x33,0x33,0x32,0x33,0x33,0x33,0x34,0x36,0x36,0x36,0x38,0x39,0x39,
0x38,0x36,0x36,0x37,0x36,0x36,0x34,0x35,0x35,0x37,0x38,0x3a,0x3a,0x3b,0x39,0x36,
0x35,0x37,0x39,0x3a,0x38,0x35,0x34,0x33,0x33,0x34,0x35,0x36,0x36,0x36,0x34,0x34,
0x35,0x39,0x39,0x3a,0x38,0x37,0x34,0x33,0x32,0x35,0x38,0x37,0x35,0x35,0x36,0x38,
0x39,0x3b,0x3b,0x3d,0x39,0x35,0x34,0x35,0x36,0x38,0x38,0x38,0x38,0x38,0x37,0x36,
0x37,0x38,0x39,0x3b,0x3b,0x3c,0x3a,0x38,0x34,0x36,0x36,0x36,0x36,0x36,0x35,0x36,
0x34,0x34,0x34,0x38,0x38,0x37,0x36,0x36,0x34,0x37,0x36,0x34,0x34,0x35,0x37,0x38,
0x37,0x35,0x36,0x37,0x38,0x39,0x39,0x39,0x39,0x3a,0x39,0x37,0x36,0x38,0x38,0x38,
0x38,0x38,0x37,0x36,0x35,0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x36,0x37,0x37,0x37,
0x36,0x34,0x34,0x35,0x36,0x38,0x39,0x38,0x37,0x36,0x34,0x36,0x36,0x37,0x38,0x38,
0x36,0x36,0x36,0x37,0x38,0x3a,0x39,0x37,0x35,0x34,0x34,0x36,0x37,0x39,0x39,0x38,
0x34,0x33,0x34,0x36,0x36,0x36,0x36,0x34,0x33,0x33,0x33,0x37,0x34,0x34,0x34,0x35,
0x34,0x36,0x38,0x38,0x37,0x37,0x38,0x37,0x3b,0x3b,0x3a,0x3b,0x39,0x36,0x37,0x37,
0x36,0x36,0x36,0x36,0x34,0x33,0x32,0x35,0x37,0x38,0x38,0x38,0x39,0x39,0x39,0x39,
0x3a,0x3c,0x3b,0x39,0x38,0x38,0x38,0x39,0x38,0x37,0x38,0x39,0x39,0x39,0x39,0x3b,
0x3b,0x3c,0x3a,0x39,0x39,0x38,0x36,0x35,0x35,0x35,0x35,0x35,0x35,0x39,0x3b,0x3b,
0x39,0x39,0x38,0x39,0x39,0x39,0x38,0x39,0x37,0x34,0x33,0x34,0x34,0x35,0x35,0x34,
0x36,0x39,0x3a,0x3a,0x39,0x39,0x39,0x39,0x37,0x38,0x39,0x3b,0x3a,0x3b,0x3a,0x3b,
0x3a,0x3a,0x39,0x39,0x38,0x39,0x37,0x37,0x36,0x38,0x39,0x39,0x35,0x33,0x32,0x31,
0x33,0x34,0x36,0x36,0x36,0x36,0x36,0x39,0x3a,0x3d,0x3d,0x3b,0x39,0x3a,0x39,0x3a,
0x3a,0x39,0x35,0x34,0x34,0x36,0x37,0x36,0x34,0x36,0x38,0x38,0x35,0x3a,0x3c,0x3c,
0x3b,0x39,0x39,0x3b,0x3b,0x3a,0x3a,0x3a,0x36,0x34,0x33,0x31,0x33,0x36,0x38,0x38,
0x37,0x36,0x36,0x37,0x39,0x3b,0x3d,0x3b,0x38,0x37,0x34,0x35,0x35,0x36,0x35,0x35,
0x34,0x35,0x34,0x36,0x35,0x36,0x39,0x3a,0x39,0x39,0x39,0x38,0x39,0x37,0x36,0x36,
0x36,0x34,0x35,0x34,0x33,0x31,0x31,0x31,0x33,0x36,0x36,0x37,0x38,0x39,0x39,0x3b,
0x3a,0x3b,0x3b,0x39,0x34,0x34,0x36,0x3a,0x3b,0x3a,0x38,0x38,0x38,0x39,0x39,0x3a,
0x3a,0x39,0x38,0x36,0x34,0x37,0x38,0x37,0x37,0x39,0x39,0x34,0x34,0x34,0x34,0x35,
0x36,0x37,0x39,0x3b,0x3a,0x3d,0x3d,0x3d,0x3e,0x3f,0x3e,0x3c,0x39,0x36,0x33,0x31,
0x2f,0x31,0x34,0x36,0x36,0x36,0x36,0x37,0x37,0x39,0x3a,0x3c,0x3b,0x39,0x36,0x34,
0x34,0x35,0x36,0x38,0x38,0x39,0x38,0x37,0x39,0x3b,0x3b,0x3d,0x3d,0x3d,0x3b,0x3a,
0x38,0x38,0x38,0x38,0x33,0x34,0x33,0x35,0x38,0x39,0x37,0x37,0x37,0x39,0x3a,0x3a,
0x3a,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x39,0x38,0x36,0x39,0x3a,0x3b,0x3b,0x3b,
0x3a,0x3a,0x39,0x39,0x39,0x3a,0x39,0x39,0x38,0x38,0x36,0x35,0x34,0x35,0x36,0x35,
0x34,0x36,0x35,0x36,0x39,0x3c,0x3f,0x3c,0x3b,0x38,0x37,0x38,0x38,0x36,0x36,0x32,
0x2e,0x32,0x38,0x44,0x54,0x67,0x75,0x83,0x8b,0x92,0x98,0x9e,0xa0,0xa3,0xa2,0x9f,
0x9a,0x96,0x95,0x97,0x9a,0x9c,0x9c,0x9d,0x9c,0x9b,0x9c,0x9b,0x9c,0x9c,0x9c,0x9b,
0x9b,0x9d,0x9d,0x9d,0x9b,0x9a,0x9b,0x9c,0x9c,0x9c,0x9d,0x9d,0x9b,0x9d,0x9e,0x9f,
0x9f,0x9e,0x9a,0x99,0x99,0x9d,0x9d,0xa0,0x9f,0x9c,0x9c,0x9b,0x9c,0x9e,0x9e,0x9d,
0x9d,0x9c,0x9c,0x9c,0x9c,0x9e,0xa0,0xa1,0xa0,0x9f,0x9e,0x9d,0x9b,0x9b,0x9a,0x99,
0x99,0x99,0x9a,0x9c,0x9c,0x9d,0x9f,0xa0,0x9f,0x9e,0x9d,0xa0,0x9f,0x9f,0x9d,0x9d,
0x9c,0x9b,0x9a,0x9a,0x9a,0x9b,0x9d,0x9d,0x9e,0x9f,0xa0,0x9f,0x9f,0xa0,0xa0,0x9e,
0x9c,0x9b,0x9a,0x9c,0x9d,0x9e,0x9e,0x9c,0x99,0x99,0x9a,0x9c,0x9d,0x9e,0x9e,0x9e,
0x9e,0x9e,0x9c,0x9f,0x9d,0x9b,0x9b,0x9b,0x99,0x9a,0x9a,0x9a,0x9b,0x9d,0x9f,0xa1,
0xa2,0xa2,0xa0,0x9f,0x9d,0x9c,0x9b,0x99,0x98,0x99,0x97,0x96,0x97,0x9a,0x9d,0x9d,
0x96,0x8c,0x7e,0x72,0x63,0x57,0x4f,0x48,0x42,0x3e,0x3a,0x39,0x41,0x50,0x61,0x74,
0x82,0x8e,0x95,0x99,0x9a,0x9d,0xa0,0xa2,0xa2,0xa2,0xa0,0x9c,0x97,0x95,0x95,0x9b,
0x9e,0xa0,0x9d,0x97,0x8c,0x7f,0x6e,0x60,0x57,0x51,0x4a,0x44,0x3d,0x39,0x38,0x45,
0x54,0x69,0x7c,0x84,0x7e,0x73,0x64,0x57,0x55,0x5c,0x65,0x6e,0x74,0x79,0x7d,0x87,
0x94,0xa0,0xa1,0x96,0x80,0x6a,0x57,0x50,0x54,0x61,0x6e,0x7a,0x7d,0x79,0x72,0x67,
0x5e,0x57,0x50,0x48,0x3e,0x34,0x2e,0x2b,0x2e,0x34,0x3a,0x3f,0x40,0x3c,0x37,0x32,
0x30,0x2f,0x35,0x38,0x3a,0x3c,0x3d,0x3e,0x3e,0x3e,0x3c,0x3c,0x3a,0x39,0x3a,0x38,
0x38,0x3a,0x39,0x36,0x34,0x34,0x35,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x37,0x38,0x39,
// Line 12
0x34,0x36,0x37,0x38,0x38,0x39,0x38,0x38,0x37,0x37,0x36,0x37,0x34,0x34,0x33,0x34,
0x34,0x34,0x36,0x36,0x36,0x37,0x37,0x37,0x39,0x3a,0x3a,0x3a,0x37,0x35,0x36,0x36,
0x34,0x33,0x34,0x36,0x36,0x38,0x37,0x36,0x34,0x34,0x36,0x39,0x39,0x38,0x36,0x34,
0x30,0x33,0x3b,0x4c,0x5e,0x71,0x78,0x76,0x6d,0x61,0x59,0x58,0x5e,0x69,0x76,0x7e,
0x7b,0x73,0x66,0x5c,0x59,0x5b,0x60,0x66,0x69,0x6b,0x68,0x65,0x5f,0x5c,0x5b,0x5e,
0x63,0x6b,0x72,0x75,0x73,0x6d,0x64,0x5e,0x5c,0x60,0x66,0x70,0x74,0x73,0x70,0x6a,
0x62,0x5d,0x5c,0x5e,0x64,0x6d,0x73,0x76,0x74,0x6c,0x64,0x5c,0x5a,0x5d,0x65,0x6e,
0x73,0x74,0x70,0x67,0x5d,0x58,0x58,0x60,0x68,0x71,0x77,0x77,0x72,0x6d,0x66,0x61,
0x5f,0x62,0x67,0x6b,0x6d,0x6e,0x70,0x75,0x7e,0x8b,0x97,0xa3,0xaa,0xad,0xa5,0x96,
0x85,0x76,0x67,0x5c,0x53,0x50,0x4d,0x46,0x3d,0x38,0x37,0x3e,0x4a,0x5e,0x71,0x80,
0x89,0x8e,0x8f,0x93,0x97,0x9c,0x9d,0x9b,0x99,0x98,0x99,0x9b,0x98,0x97,0x8c,0x7c,
0x6c,0x5f,0x56,0x50,0x48,0x3f,0x37,0x31,0x34,0x3e,0x55,0x6b,0x79,0x7e,0x78,0x6b,
0x5f,0x57,0x53,0x50,0x47,0x3c,0x34,0x32,0x39,0x4c,0x64,0x79,0x81,0x80,0x74,0x65,
0x57,0x4e,0x48,0x44,0x3e,0x38,0x31,0x2d,0x2c,0x30,0x36,0x3f,0x4c,0x5c,0x69,0x73,
0x76,0x75,0x6d,0x65,0x5e,0x5a,0x53,0x4a,0x3f,0x38,0x34,0x39,0x47,0x5c,0x73,0x87,
0x93,0x99,0x99,0x98,0x93,0x8b,0x7c,0x69,0x57,0x50,0x53,0x60,0x6d,0x77,0x77,0x72,
0x69,0x61,0x5e,0x5c,0x58,0x4d,0x3e,0x30,0x2a,0x35,0x4d,0x69,0x7d,0x83,0x7c,0x70,
0x63,0x5a,0x56,0x50,0x49,0x41,0x37,0x34,0x39,0x50,0x6a,0x7e,0x87,0x83,0x73,0x65,
0x58,0x54,0x5b,0x65,0x6e,0x75,0x79,0x7e,0x89,0x97,0xa2,0xa4,0x98,0x85,0x70,0x5e,
0x51,0x4f,0x56,0x62,0x70,0x7e,0x8b,0x95,0x9e,0xa0,0x9a,0x8e,0x7e,0x70,0x61,0x56,
0x4b,0x41,0x3a,0x36,0x39,0x48,0x59,0x6c,0x7b,0x7f,0x79,0x6e,0x5f,0x52,0x4c,0x4c,
0x4d,0x48,0x3c,0x30,0x2b,0x2f,0x38,0x41,0x47,0x46,0x3c,0x31,0x2a,0x2c,0x3b,0x51,
0x65,0x76,0x7d,0x7c,0x72,0x69,0x61,0x60,0x63,0x66,0x6b,0x71,0x77,0x7d,0x87,0x90,
0x9b,0xa8,0xac,0xaa,0xa3,0x9d,0x99,0x98,0x97,0x9a,0x9e,0xa2,0xa3,0xa2,0xa0,0x9b,
0x98,0x99,0x97,0x95,0x95,0x97,0x99,0x9b,0x9d,0x9e,0x9e,0xa1,0xa0,0xa2,0xa4,0xa3,
0xa1,0xa2,0x9f,0x9e,0x9c,0x9a,0x9b,0x9a,0x99,0x9a,0x9b,0x9e,0x9f,0x9e,0xa0,0x9e,
0x9c,0x9f,0xa0,0xa0,0x9e,0x9d,0x99,0x99,0x97,0x99,0x9c,0x9f,0x9e,0x9e,0x9e,0x9e,
0x9d,0x9c,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9b,0x9c,0x9d,0x9f,0xa1,0xa0,
0x9d,0x9c,0x9d,0x9a,0x9b,0x9c,0x9d,0x9f,0x9e,0x9d,0x9e,0x9e,0x9e,0xa0,0x9e,0x9e,
0x9d,0x9d,0x9d,0x9e,0x9e,0xa1,0xa0,0x9f,0x9e,0x9e,0x9f,0x9e,0x9e,0x9f,0x9e,0x9e,
0x9e,0x9e,0x9e,0x9d,0x9c,0x9d,0xa0,0xa1,0xa1,0xa0,0x9e,0x9b,0x9a,0x9c,0x9e,0x9e,
0x9d,0x9a,0x98,0x99,0x99,0x9b,0x9e,0x9f,0x9d,0x9c,0x99,0x97,0x97,0x9a,0x9c,0x9d,
0x9d,0x9e,0x9d,0x9e,0x9d,0x9d,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9e,0xa0,0x9d,
0x9e,0x9c,0x9c,0x9d,0x9d,0x9d,0x9d,0x9f,0x9e,0xa0,0x9f,0x9f,0x9e,0xa0,0x9d,0x9a,
0x98,0x9a,0x9a,0x9e,0x9d,0x9e,0x9f,0xa0,0x9e,0x9f,0x9f,0x9f,0xa1,0xa1,0xa0,0xa1,
0x9f,0x9f,0xa0,0x9f,0x9e,0x9d,0x9b,0x9a,0x98,0x9a,0x9c,0x9f,0x9f,0x9e,0x9d,0x9e,
0xa0,0xa0,0x9f,0x9e,0x9e,0x9e,0x9d,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9b,0x9e,
0x9c,0x9d,0x9c,0x9a,0x99,0x98,0x98,0x97,0x98,0x99,0x9a,0x99,0x9b,0x99,0x97,0x99,
0x9a,0x9d,0x9d,0x9c,0x9b,0x9d,0x9e,0x9f,0x9d,0x9e,0x9f,0xa0,0x9d,0x9a,0x99,0x9a,
0x99,0x99,0x99,0x99,0x98,0x9c,0x9d,0x9c,0x9b,0x9e,0xa1,0xa3,0xa1,0xa0,0xa0,0xa2,
0xa2,0xa1,0xa0,0x9e,0x9d,0x9e,0x9e,0x9c,0x9b,0x9a,0x9c,0x9d,0x9d,0x9e,0x9e,0x9e,
0x9d,0x9c,0x9c,0x9d,0x9f,0xa1,0xa0,0x9f,0x9e,0x9e,0x9e,0xa2,0x9e,0x9d,0x9e,0x9d,
0x9c,0x9c,0x9b,0x9b,0x9b,0x9d,0x9d,0x9a,0x9d,0x9e,0x9e,0x9f,0x9e,0x9c,0x9c,0x9c,
0x9c,0x9e,0x9c,0x9a,0x9a,0x9a,0x9a,0x9b,0x9c,0x9d,0x9d,0x9c,0x99,0x97,0x97,0x98,
0x99,0x9a,0x9a,0x9a,0x9b,0x9c,0x9c,0x9e,0x9e,0x9e,0x9e,0x9c,0x9b,0x9a,0x99,0x97,
0x96,0x97,0x9a,0x9b,0x9a,0x9a,0x9b,0x9d,0x9e,0x9e,0x9e,0x9d,0x9b,0x9c,0x9b,0x9b,
0x9b,0x9d,0x9d,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9e,0xa0,0xa0,0xa0,0x9e,0x9d,
0x9b,0x9a,0x9a,0x9b,0x9a,0x99,0x98,0x99,0x9a,0x9c,0x9c,0x9d,0x9b,0x9d,0x9d,0x9d,
0x9d,0x9e,0x9e,0x9e,0x9a,0x98,0x98,0x99,0x9a,0x9b,0x9d,0x9d,0x9b,0x99,0x99,0x9a,
0x9c,0x9d,0x9c,0x9d,0x9b,0x9b,0x9c,0x9d,0x9f,0xa1,0xa1,0x9f,0x9e,0x9e,0x9d,0x9a,
0x99,0x98,0x98,0x9a,0x98,0x98,0x9a,0x9b,0x9c,0x9e,0xa0,0xa0,0x9e,0x9e,0x9c,0x99,
0x98,0x99,0x9a,0x9b,0x98,0x98,0x9a,0x9d,0x9e,0xa0,0x9f,0x9e,0x9e,0x9c,0x9b,0x9a,
0x99,0x9b,0x9b,0x9c,0x9b,0x9b,0x9b,0x9c,0x9d,0x9e,0x9c,0x9b,0x99,0x99,0x98,0x9a,
0x9b,0x9d,0x9d,0x9c,0x9a,0x9a,0x9b,0x9e,0x9e,0x9d,0x9c,0x99,0x99,0x9a,0x9d,0x9e,
0xa0,0xa0,0xa0,0xa0,0x9f,0x9e,0xa0,0xa0,0x9e,0x9e,0x9e,0x9e,0x9d,0x9c,0x9b,0x9d,
0x9d,0x9c,0x9c,0x9b,0x9a,0x9d,0x9d,0x9d,0x9b,0x9d,0x9d,0x9d,0x9c,0x9d,0x9e,0x9d,
0x9c,0x9d,0x9e,0x9d,0x9c,0x9e,0x9f,0xa0,0xa0,0xa0,0x9f,0x9f,0xa0,0xa1,0xa1,0x9f,
0x9e,0x9c,0x9b,0x99,0x97,0x99,0x9b,0x9e,0x9e,0x9b,0x9a,0x9e,0x9f,0xa0,0xa0,0x9f,
0x9e,0x9d,0x9c,0x9c,0x9a,0x9d,0x9d,0x9b,0x9c,0x9d,0x9d,0x9e,0x9d,0x9d,0x9e,0x9e,
0x9e,0x9d,0x9e,0x9e,0x9c,0x9c,0x9b,0x9b,0x9c,0x9a,0x9a,0x9d,0x9d,0x9e,0x9e,0x9e,
0x9c,0x9d,0x9e,0xa0,0xa0,0xa1,0xa1,0xa1,0x9e,0x9f,0xa0,0xa3,0xa3,0xa2,0xa1,0x9f,
0x9e,0x9e,0x9e,0x9e,0xa0,0xa1,0xa2,0xa1,0x9e,0x9e,0xa0,0xa1,0x9f,0x9e,0x9f,0x9d,
0x9a,0x99,0x98,0x98,0x97,0x97,0x98,0x9b,0x9d,0x9e,0x9e,0x9f,0x9e,0x9e,0x9e,0x9e,
0xa0,0xa1,0x9f,0x9e,0x9e,0x9e,0x9f,0xa0,0x9f,0xa0,0xa0,0xa0,0x9f,0x9e,0x9e,0x9e,
0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9a,0x9a,0x99,0x9b,0x9d,0x9e,0x9f,0xa2,0xa3,0xa3,
0xa1,0xa1,0xa0,0xa0,0x9e,0x9e,0x9e,0x9d,0x9b,0x9a,0x9c,0x9d,0x9c,0x9c,0x9d,0x9e,
0x9e,0x9e,0x9d,0x9c,0x9c,0x9d,0x9e,0xa0,0xa0,0xa0,0xa0,0x9e,0x9a,0x9d,0xa0,0xa1,
0xa2,0xa1,0x9f,0x9e,0x9d,0x9e,0x9d,0x9e,0x9d,0x9e,0x9e,0x9e,0xa0,0xa1,0xa1,0x9f,
0xa0,0xa1,0x9f,0x9e,0x9d,0x9d,0x9e,0x9d,0x9b,0x9a,0x99,0x9b,0x9d,0x9f,0x9e,0x9e,
0x9e,0x9e,0x9d,0x9f,0xa0,0xa1,0xa1,0xa0,0x9d,0x9d,0x9d,0x9e,0x9b,0x9e,0x9f,0xa0,
0xa1,0xa0,0xa1,0xa1,0xa0,0xa0,0xa0,0xa0,0x9f,0x9e,0x9c,0x9a,0x9a,0x9b,0x9e,0x9e,
0x9d,0x9d,0x9d,0x9e,0xa0,0xa1,0xa2,0xa2,0xa1,0xa1,0xa0,0xa1,0xa1,0xa0,0x9d,0x9d,
0x9c,0x9c,0x9d,0x9e,0x9f,0xa0,0xa0,0x9e,0x9d,0x9f,0x9e,0x9f,0xa0,0xa0,0x9e,0x9e,
0x9d,0x9a,0x9a,0x9d,0x9e,0x9f,0x9e,0x9d,0x9a,0x9b,0x9a,0x9a,0x9c,0x9e,0x9e,0x9d,
0x9b,0x9b,0x9b,0x9c,0x9c,0x9e,0x9f,0xa0,0x9f,0x9e,0x9d,0x9e,0x9e,0x9f,0xa0,0xa0,
0xa0,0x9e,0x9d,0x9d,0x9d,0x9e,0x9e,0x9d,0x9e,0x9e,0x9d,0x9c,0x9c,0x9d,0x9e,0x9f,
0x9e,0x9f,0x9f,0x9e,0x9d,0x9e,0x9d,0x9e,0x9d,0x9d,0x9c,0x9b,0x9a,0x9a,0x9a,0x9b,
0x9c,0x9e,0x9f,0xa0,0x9e,0x9e,0x9e,0x9e,0xa0,0xa0,0xa0,0x9e,0x9e,0x9e,0x9f,0xa0,
0x9e,0x9e,0x9d,0x9d,0x9c,0x9c,0x9c,0x9d,0x9d,0x9c,0x9a,0x9b,0x9c,0x9d,0x9e,0x9d,
0x9b,0x9c,0x9d,0x9d,0x9d,0x9f,0xa0,0xa2,0xa2,0xa2,0xa0,0x9e,0x9c,0x9c,0x9d,0x9d,
0x9d,0x9e,0x9d,0x9c,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,0x9c,0x9e,0x9f,0xa0,
0x9f,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,0x9e,0x9e,0x9e,0x9c,0x9a,0x99,0x9b,0x9d,0x9d,
0x9a,0x9a,0x99,0x98,0x99,0x9b,0x9b,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9e,0x9e,0x9e,
0x9e,0x9e,0x9d,0x9b,0x9b,0x9d,0x9e,0x9d,0x9d,0x9f,0x9f,0x9e,0x9e,0x9f,0xa0,0x9e,
0x9c,0x9a,0x9a,0x9d,0x9d,0x9d,0x9a,0x99,0x98,0x9a,0x9d,0xa0,0xa1,0xa2,0xa1,0x9e,
0x9e,0x9e,0x9f,0x9e,0x9d,0x9a,0x98,0x98,0x98,0x98,0x9b,0x9b,0x9a,0x9b,0x9c,0x9b,
0x9b,0x9c,0x9c,0x9d,0x9d,0x9e,0x9f,0xa0,0xa0,0xa1,0xa1,0xa1,0xa0,0x9f,0x9e,0x9e,
0x9f,0xa0,0x9e,0x9e,0x9c,0x9b,0x9d,0x9d,0x9f,0xa0,0xa1,0xa1,0xa0,0x9f,0x9e,0x9b,
0x97,0x8f,0x84,0x75,0x63,0x58,0x53,0x57,0x61,0x71,0x7d,0x82,0x7c,0x70,0x63,0x5c,
0x5c,0x62,0x68,0x6e,0x70,0x75,0x7c,0x87,0x94,0xa1,0xa3,0x98,0x84,0x6d,0x5b,0x54,
0x58,0x63,0x73,0x7e,0x81,0x7c,0x74,0x6b,0x61,0x5d,0x54,0x49,0x3e,0x34,0x30,0x3b,
0x4d,0x65,0x79,0x86,0x84,0x79,0x68,0x5a,0x4e,0x4c,0x47,0x43,0x40,0x3c,0x38,0x36,
0x35,0x39,0x3f,0x4a,0x58,0x67,0x73,0x79,0x76,0x6d,0x60,0x57,0x5a,0x64,0x71,0x7c,
0x7e,0x78,0x6c,0x61,0x5b,0x5e,0x60,0x5f,0x56,0x48,0x36,0x2b,0x27,0x2c,0x34,0x3e,
0x44,0x46,0x42,0x3b,0x37,0x37,0x35,0x34,0x36,0x3a,0x3b,0x3b,0x39,0x38,0x38,0x3b,
0x3b,0x3c,0x3b,0x3a,0x3a,0x3a,0x37,0x36,0x38,0x3a,0x3a,0x39,0x37,0x38,0x3a,0x3b,
// Line 13
0x38,0x38,0x36,0x36,0x36,0x37,0x38,0x39,0x3b,0x3d,0x3b,0x39,0x38,0x39,0x38,0x38,
0x36,0x35,0x34,0x33,0x31,0x33,0x34,0x37,0x37,0x39,0x38,0x37,0x38,0x38,0x37,0x36,
0x34,0x34,0x36,0x37,0x37,0x36,0x34,0x35,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x37,
0x35,0x35,0x38,0x39,0x38,0x3a,0x3a,0x3b,0x3b,0x3a,0x37,0x36,0x36,0x38,0x39,0x39,
0x36,0x34,0x36,0x36,0x36,0x38,0x38,0x3a,0x3a,0x39,0x38,0x37,0x39,0x39,0x3b,0x3b,
0x39,0x37,0x36,0x34,0x34,0x36,0x38,0x39,0x39,0x39,0x38,0x39,0x39,0x3a,0x39,0x38,
0x36,0x36,0x34,0x34,0x35,0x38,0x3a,0x3b,0x39,0x37,0x34,0x34,0x34,0x34,0x34,0x33,
0x31,0x32,0x30,0x2f,0x32,0x36,0x38,0x3a,0x39,0x38,0x36,0x38,0x38,0x38,0x38,0x37,
0x36,0x37,0x38,0x37,0x36,0x35,0x34,0x36,0x36,0x36,0x34,0x38,0x37,0x35,0x34,0x34,
0x36,0x38,0x38,0x38,0x38,0x37,0x36,0x35,0x36,0x37,0x38,0x39,0x38,0x37,0x38,0x37,
0x36,0x38,0x3a,0x3b,0x3b,0x39,0x37,0x36,0x35,0x36,0x37,0x38,0x36,0x37,0x36,0x38,
0x38,0x3a,0x39,0x38,0x37,0x36,0x35,0x36,0x37,0x3a,0x3c,0x3b,0x3a,0x39,0x38,0x39,
0x39,0x3b,0x3b,0x37,0x36,0x35,0x34,0x36,0x36,0x38,0x3a,0x3b,0x3a,0x3a,0x39,0x38,
0x38,0x38,0x37,0x36,0x33,0x31,0x31,0x34,0x33,0x35,0x39,0x39,0x38,0x39,0x38,0x38,
0x39,0x3b,0x3a,0x38,0x34,0x34,0x33,0x35,0x36,0x38,0x39,0x38,0x36,0x38,0x37,0x37,
0x37,0x36,0x38,0x3a,0x39,0x38,0x37,0x36,0x34,0x34,0x36,0x37,0x37,0x36,0x34,0x33,
0x30,0x31,0x33,0x36,0x38,0x38,0x37,0x34,0x34,0x35,0x37,0x39,0x3b,0x3c,0x3a,0x38,
0x36,0x35,0x36,0x38,0x38,0x36,0x34,0x33,0x33,0x37,0x37,0x37,0x37,0x39,0x38,0x38,
0x38,0x39,0x38,0x39,0x35,0x32,0x34,0x35,0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x39,
0x39,0x38,0x38,0x36,0x34,0x34,0x34,0x36,0x36,0x39,0x3a,0x39,0x38,0x36,0x34,0x36,
0x37,0x38,0x37,0x34,0x33,0x33,0x33,0x35,0x36,0x38,0x36,0x34,0x33,0x33,0x34,0x37,
0x39,0x3c,0x3d,0x3c,0x39,0x39,0x39,0x39,0x3b,0x3d,0x3c,0x38,0x35,0x33,0x32,0x35,
0x37,0x39,0x39,0x38,0x36,0x38,0x3a,0x3d,0x3d,0x3d,0x3c,0x3c,0x3a,0x39,0x39,0x39,
0x38,0x37,0x36,0x36,0x35,0x37,0x37,0x36,0x37,0x39,0x39,0x39,0x38,0x38,0x39,0x3a,
0x3b,0x3b,0x39,0x38,0x37,0x39,0x39,0x39,0x38,0x36,0x36,0x37,0x36,0x36,0x37,0x37,
0x38,0x38,0x37,0x36,0x37,0x37,0x37,0x35,0x34,0x33,0x33,0x37,0x36,0x34,0x36,0x37,
0x36,0x38,0x39,0x3b,0x3c,0x3d,0x3c,0x3b,0x39,0x39,0x38,0x39,0x39,0x39,0x39,0x37,
0x34,0x36,0x37,0x38,0x39,0x39,0x37,0x37,0x37,0x39,0x38,0x39,0x39,0x3a,0x39,0x38,
0x38,0x38,0x38,0x37,0x37,0x39,0x3a,0x3a,0x3a,0x3b,0x3c,0x3d,0x3b,0x37,0x39,0x39,
0x38,0x39,0x39,0x39,0x39,0x38,0x37,0x38,0x38,0x3a,0x3b,0x3b,0x39,0x39,0x39,0x39,
0x39,0x3a,0x3a,0x3b,0x3a,0x38,0x36,0x36,0x35,0x36,0x36,0x36,0x36,0x37,0x36,0x34,
0x34,0x36,0x36,0x36,0x35,0x36,0x35,0x36,0x36,0x36,0x37,0x38,0x38,0x3b,0x3c,0x3c,
0x3b,0x39,0x38,0x38,0x39,0x39,0x38,0x38,0x39,0x3a,0x3b,0x39,0x39,0x3a,0x3a,0x39,
0x38,0x39,0x38,0x36,0x35,0x34,0x36,0x38,0x39,0x3a,0x39,0x39,0x37,0x39,0x3a,0x3c,
0x3c,0x3b,0x3a,0x39,0x38,0x38,0x38,0x38,0x37,0x38,0x38,0x35,0x34,0x36,0x39,0x39,
0x38,0x37,0x36,0x36,0x35,0x34,0x34,0x34,0x36,0x38,0x37,0x36,0x36,0x38,0x38,0x37,
0x35,0x36,0x36,0x36,0x36,0x37,0x38,0x37,0x36,0x38,0x38,0x38,0x36,0x37,0x38,0x38,
0x37,0x37,0x37,0x39,0x3a,0x3a,0x3a,0x3a,0x3a,0x3c,0x3b,0x38,0x36,0x36,0x36,0x36,
0x34,0x33,0x34,0x38,0x38,0x37,0x37,0x36,0x36,0x39,0x37,0x36,0x35,0x36,0x36,0x35,
0x33,0x34,0x36,0x38,0x38,0x37,0x36,0x36,0x36,0x35,0x33,0x32,0x34,0x36,0x37,0x37,
0x36,0x34,0x35,0x36,0x36,0x35,0x35,0x34,0x34,0x36,0x37,0x36,0x38,0x39,0x39,0x3b,
0x39,0x38,0x37,0x39,0x38,0x36,0x34,0x36,0x36,0x35,0x33,0x33,0x33,0x36,0x35,0x36,
0x34,0x34,0x36,0x36,0x36,0x36,0x34,0x34,0x34,0x35,0x36,0x34,0x36,0x36,0x38,0x39,
0x38,0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x37,0x36,0x34,0x36,0x36,0x35,0x34,0x34,
0x34,0x34,0x35,0x36,0x36,0x36,0x35,0x33,0x34,0x36,0x36,0x38,0x37,0x36,0x36,0x37,
0x37,0x37,0x35,0x33,0x31,0x31,0x31,0x31,0x33,0x34,0x33,0x33,0x33,0x35,0x37,0x36,
0x36,0x36,0x35,0x35,0x35,0x36,0x37,0x38,0x37,0x36,0x35,0x34,0x34,0x36,0x37,0x37,
0x36,0x37,0x36,0x34,0x34,0x35,0x34,0x34,0x33,0x33,0x34,0x35,0x34,0x35,0x36,0x37,
0x36,0x37,0x37,0x38,0x39,0x39,0x37,0x38,0x38,0x37,0x36,0x35,0x33,0x34,0x34,0x34,
0x32,0x33,0x31,0x30,0x33,0x35,0x34,0x36,0x34,0x33,0x34,0x34,0x34,0x34,0x33,0x33,
0x34,0x34,0x34,0x31,0x30,0x2f,0x31,0x31,0x2f,0x2f,0x30,0x33,0x33,0x35,0x35,0x37,
0x39,0x39,0x36,0x35,0x35,0x38,0x38,0x37,0x34,0x31,0x30,0x31,0x31,0x36,0x38,0x38,
0x38,0x38,0x36,0x36,0x36,0x38,0x39,0x39,0x37,0x34,0x34,0x31,0x31,0x33,0x34,0x35,
0x36,0x36,0x36,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x37,0x36,0x34,0x34,0x33,0x33,
0x33,0x32,0x31,0x33,0x31,0x33,0x35,0x38,0x39,0x3b,0x3b,0x3a,0x39,0x39,0x39,0x36,
0x34,0x34,0x34,0x37,0x36,0x35,0x36,0x34,0x33,0x34,0x35,0x36,0x37,0x36,0x34,0x34,
0x34,0x35,0x36,0x36,0x34,0x35,0x37,0x37,0x37,0x39,0x39,0x39,0x39,0x38,0x38,0x38,
0x36,0x35,0x36,0x36,0x36,0x35,0x33,0x33,0x32,0x34,0x34,0x34,0x34,0x34,0x33,0x34,
0x34,0x36,0x37,0x39,0x39,0x39,0x38,0x38,0x37,0x39,0x38,0x36,0x37,0x36,0x34,0x34,
0x34,0x34,0x35,0x36,0x36,0x36,0x34,0x33,0x34,0x38,0x39,0x3a,0x38,0x37,0x35,0x35,
0x34,0x34,0x33,0x34,0x34,0x35,0x34,0x34,0x36,0x39,0x3a,0x39,0x38,0x39,0x38,0x38,
0x36,0x36,0x37,0x37,0x36,0x36,0x36,0x35,0x36,0x37,0x38,0x34,0x36,0x34,0x33,0x33,
0x33,0x34,0x36,0x37,0x36,0x38,0x36,0x35,0x34,0x34,0x34,0x36,0x36,0x37,0x36,0x36,
0x34,0x34,0x34,0x36,0x38,0x39,0x36,0x33,0x32,0x34,0x34,0x36,0x36,0x36,0x36,0x34,
0x34,0x34,0x34,0x34,0x36,0x37,0x36,0x34,0x36,0x37,0x36,0x37,0x36,0x37,0x38,0x36,
0x35,0x34,0x34,0x33,0x31,0x31,0x2f,0x30,0x31,0x33,0x35,0x36,0x34,0x34,0x34,0x35,
0x34,0x36,0x36,0x37,0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x37,0x37,0x38,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x35,0x33,0x33,0x31,0x31,0x2f,0x31,0x33,0x36,0x37,0x36,
0x35,0x36,0x36,0x36,0x37,0x39,0x38,0x39,0x38,0x37,0x38,0x38,0x36,0x36,0x34,0x34,
0x34,0x34,0x34,0x34,0x35,0x36,0x37,0x38,0x36,0x35,0x34,0x33,0x31,0x33,0x34,0x35,
0x34,0x33,0x33,0x35,0x36,0x38,0x38,0x38,0x36,0x34,0x33,0x32,0x33,0x34,0x34,0x31,
0x31,0x31,0x33,0x32,0x33,0x34,0x36,0x37,0x37,0x36,0x39,0x38,0x36,0x36,0x36,0x37,
0x36,0x34,0x31,0x31,0x31,0x32,0x31,0x33,0x33,0x34,0x33,0x34,0x34,0x36,0x36,0x37,
0x37,0x37,0x36,0x37,0x35,0x34,0x36,0x34,0x33,0x31,0x30,0x31,0x33,0x37,0x39,0x38,
0x39,0x38,0x36,0x36,0x35,0x35,0x36,0x33,0x31,0x33,0x34,0x34,0x33,0x34,0x34,0x35,
0x36,0x36,0x36,0x36,0x34,0x34,0x35,0x36,0x37,0x38,0x36,0x34,0x34,0x34,0x34,0x36,
0x36,0x35,0x34,0x35,0x34,0x34,0x36,0x36,0x37,0x39,0x38,0x38,0x37,0x36,0x34,0x34,
0x32,0x31,0x31,0x32,0x30,0x33,0x34,0x38,0x38,0x39,0x38,0x38,0x38,0x38,0x37,0x36,
0x32,0x30,0x30,0x30,0x30,0x31,0x30,0x2f,0x2f,0x30,0x31,0x34,0x34,0x36,0x36,0x37,
0x35,0x36,0x39,0x39,0x37,0x38,0x36,0x36,0x38,0x38,0x36,0x35,0x35,0x35,0x33,0x34,
0x34,0x34,0x34,0x34,0x33,0x34,0x35,0x35,0x36,0x37,0x37,0x37,0x36,0x36,0x36,0x38,
0x37,0x37,0x34,0x33,0x32,0x33,0x31,0x2f,0x31,0x33,0x33,0x34,0x34,0x34,0x35,0x34,
0x33,0x35,0x36,0x36,0x34,0x34,0x33,0x33,0x36,0x38,0x38,0x39,0x37,0x35,0x34,0x34,
0x34,0x36,0x35,0x34,0x33,0x32,0x33,0x34,0x36,0x38,0x38,0x38,0x38,0x38,0x39,0x39,
0x39,0x3a,0x39,0x38,0x36,0x35,0x35,0x36,0x34,0x33,0x30,0x34,0x34,0x36,0x38,0x38,
0x37,0x37,0x36,0x36,0x38,0x39,0x39,0x39,0x37,0x34,0x34,0x35,0x36,0x37,0x37,0x35,
0x34,0x35,0x35,0x34,0x34,0x35,0x34,0x36,0x36,0x36,0x36,0x36,0x34,0x35,0x35,0x34,
0x34,0x36,0x37,0x38,0x38,0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x37,0x34,0x34,0x33,
0x31,0x33,0x34,0x36,0x36,0x36,0x35,0x34,0x33,0x32,0x34,0x36,0x34,0x35,0x34,0x33,
0x31,0x31,0x30,0x31,0x33,0x34,0x33,0x33,0x31,0x33,0x34,0x36,0x36,0x36,0x34,0x34,
0x35,0x37,0x38,0x39,0x36,0x36,0x35,0x34,0x33,0x33,0x34,0x35,0x34,0x36,0x35,0x36,
0x38,0x38,0x37,0x38,0x37,0x37,0x36,0x36,0x35,0x35,0x35,0x35,0x34,0x37,0x37,0x36,
0x36,0x36,0x33,0x31,0x2f,0x2e,0x2f,0x33,0x33,0x33,0x32,0x31,0x31,0x34,0x34,0x34,
0x34,0x35,0x33,0x33,0x33,0x34,0x36,0x34,0x34,0x36,0x37,0x38,0x37,0x37,0x37,0x39,
0x3b,0x3b,0x36,0x37,0x34,0x33,0x31,0x32,0x31,0x35,0x33,0x31,0x31,0x34,0x37,0x3b,
0x3b,0x3b,0x3a,0x38,0x36,0x32,0x32,0x34,0x35,0x35,0x33,0x31,0x31,0x31,0x31,0x34,
// Line 14
0x38,0x39,0x3a,0x3c,0x3b,0x39,0x36,0x36,0x37,0x39,0x3b,0x3c,0x3b,0x3a,0x39,0x38,
0x38,0x39,0x3a,0x3a,0x37,0x36,0x36,0x35,0x33,0x35,0x36,0x37,0x37,0x36,0x36,0x36,
0x37,0x39,0x3a,0x3b,0x3a,0x39,0x38,0x36,0x34,0x35,0x36,0x36,0x36,0x37,0x39,0x3b,
0x43,0x49,0x50,0x58,0x60,0x69,0x71,0x79,0x7f,0x89,0x8d,0x91,0x93,0x94,0x95,0x98,
0x99,0x98,0x97,0x95,0x94,0x97,0x98,0x99,0x99,0x98,0x95,0x8f,0x89,0x82,0x7a,0x73,
0x68,0x5c,0x51,0x4a,0x45,0x41,0x3f,0x3c,0x38,0x37,0x36,0x35,0x38,0x3a,0x38,0x38,
0x38,0x37,0x37,0x36,0x34,0x36,0x39,0x3d,0x3f,0x43,0x49,0x51,0x5d,0x68,0x72,0x7c,
0x84,0x8b,0x90,0x93,0x93,0x96,0x97,0x98,0x98,0x97,0x96,0x94,0x93,0x93,0x94,0x97,
0x98,0x97,0x94,0x91,0x8b,0x86,0x80,0x79,0x71,0x67,0x5a,0x50,0x47,0x41,0x3f,0x3e,
0x3c,0x3a,0x3b,0x3a,0x39,0x3d,0x3e,0x3d,0x3e,0x3c,0x39,0x37,0x36,0x36,0x38,0x39,
0x3b,0x3e,0x41,0x46,0x4e,0x5a,0x68,0x72,0x7b,0x84,0x8c,0x92,0x96,0x99,0x9c,0x9b,
0x99,0x98,0x97,0x98,0x96,0x94,0x94,0x97,0x98,0x98,0x98,0x9b,0x97,0x91,0x8a,0x82,
0x7a,0x71,0x67,0x5d,0x54,0x4a,0x41,0x39,0x39,0x36,0x35,0x37,0x36,0x36,0x37,0x39,
0x39,0x3c,0x3e,0x40,0x40,0x41,0x40,0x3f,0x3e,0x41,0x43,0x47,0x4a,0x53,0x5e,0x6a,
0x72,0x7b,0x82,0x8a,0x90,0x94,0x98,0x9b,0x9a,0x99,0x98,0x97,0x98,0x98,0x98,0x98,
0x97,0x98,0x97,0x94,0x95,0x90,0x8b,0x87,0x80,0x79,0x71,0x68,0x5e,0x56,0x4d,0x47,
0x42,0x40,0x3d,0x3b,0x39,0x39,0x3a,0x3c,0x3c,0x3c,0x3e,0x40,0x40,0x41,0x3e,0x3c,
0x3c,0x3e,0x40,0x43,0x45,0x4c,0x55,0x60,0x6a,0x73,0x7d,0x85,0x8b,0x91,0x94,0x95,
0x97,0x98,0x96,0x95,0x94,0x96,0x97,0x98,0x98,0x98,0x98,0x99,0x99,0x98,0x95,0x90,
0x8a,0x81,0x77,0x6d,0x62,0x5b,0x55,0x4e,0x48,0x42,0x3d,0x39,0x37,0x39,0x3a,0x3c,
0x3b,0x3b,0x3a,0x3b,0x3a,0x3b,0x3e,0x3e,0x3e,0x3f,0x3f,0x41,0x44,0x4a,0x50,0x58,
0x61,0x6b,0x74,0x81,0x85,0x8b,0x91,0x96,0x98,0x9b,0x9b,0x9a,0x9b,0x9b,0x9a,0x99,
0x98,0x99,0x99,0x9a,0x9a,0x98,0x95,0x91,0x8b,0x85,0x7e,0x76,0x6d,0x66,0x5d,0x55,
0x4c,0x47,0x43,0x43,0x41,0x40,0x3e,0x3e,0x3a,0x3c,0x39,0x38,0x3b,0x3e,0x3e,0x3f,
0x3c,0x3c,0x3c,0x3e,0x40,0x45,0x4c,0x51,0x58,0x5f,0x66,0x70,0x7a,0x83,0x8c,0x93,
0x95,0x94,0x93,0x95,0x97,0x9b,0x9c,0x9d,0x9b,0x98,0x94,0x94,0x96,0x98,0x98,0x99,
0x91,0x89,0x82,0x7c,0x75,0x6f,0x66,0x5c,0x53,0x4b,0x44,0x41,0x3e,0x3d,0x3c,0x3c,
0x3b,0x3c,0x40,0x3e,0x3d,0x3c,0x3a,0x3a,0x39,0x39,0x3b,0x3d,0x3d,0x3e,0x3c,0x3e,
0x3d,0x3c,0x3c,0x3e,0x3d,0x3e,0x39,0x38,0x3a,0x3b,0x3a,0x3e,0x3d,0x3e,0x3e,0x3f,
0x3f,0x3f,0x3f,0x3e,0x3d,0x3e,0x3e,0x3c,0x3c,0x3b,0x3a,0x3a,0x39,0x39,0x39,0x37,
0x36,0x3a,0x3c,0x3d,0x3c,0x3d,0x3c,0x3d,0x3c,0x3d,0x3d,0x3e,0x3b,0x39,0x39,0x39,
0x3a,0x3c,0x3b,0x3c,0x3c,0x3d,0x3d,0x3d,0x3d,0x3e,0x3d,0x3d,0x3a,0x39,0x3a,0x38,
0x36,0x39,0x3a,0x3a,0x3a,0x3a,0x37,0x37,0x37,0x3a,0x3c,0x3d,0x3c,0x3b,0x39,0x37,
0x37,0x3a,0x3c,0x3f,0x44,0x4a,0x50,0x58,0x60,0x6a,0x76,0x80,0x89,0x90,0x94,0x95,
0x95,0x96,0x98,0x99,0x99,0x99,0x99,0x99,0x97,0x95,0x98,0x99,0x98,0x99,0x97,0x97,
0x95,0x97,0x96,0x97,0x98,0x99,0x99,0x99,0x98,0x97,0x98,0x9a,0x98,0x98,0x97,0x97,
0x99,0x9b,0x9b,0x9c,0x9a,0x9b,0x9b,0x9c,0x9c,0x9c,0x9a,0x99,0x98,0x99,0x99,0x9a,
0x9a,0x99,0x97,0x98,0x98,0x9a,0x9b,0x9d,0x9a,0x9a,0x98,0x98,0x98,0x99,0x98,0x97,
0x97,0x98,0x96,0x96,0x94,0x95,0x98,0x99,0x98,0x98,0x96,0x97,0x98,0x99,0x98,0x99,
0x9a,0x9a,0x9a,0x98,0x96,0x96,0x97,0x97,0x97,0x98,0x98,0x99,0x99,0x99,0x98,0x98,
0x99,0x9a,0x98,0x96,0x8f,0x87,0x81,0x7a,0x71,0x69,0x60,0x57,0x51,0x4b,0x43,0x3e,
0x3b,0x3b,0x3e,0x40,0x3e,0x3e,0x3e,0x3c,0x3a,0x3b,0x3c,0x3b,0x3a,0x39,0x37,0x37,
0x37,0x3b,0x3e,0x3e,0x3d,0x3e,0x3e,0x3e,0x3d,0x3e,0x3e,0x3f,0x3e,0x3e,0x3b,0x3c,
0x3b,0x3b,0x3c,0x3c,0x38,0x38,0x38,0x36,0x36,0x37,0x39,0x3b,0x3b,0x3b,0x3a,0x3a,
0x3a,0x3a,0x3a,0x3b,0x3a,0x3c,0x3a,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x39,0x3b,
0x3b,0x3d,0x3e,0x3f,0x3e,0x3d,0x3b,0x3a,0x3c,0x3c,0x3b,0x39,0x37,0x37,0x37,0x39,
0x3b,0x3a,0x3b,0x3a,0x3a,0x3d,0x3c,0x3b,0x3c,0x3c,0x3b,0x3b,0x3c,0x3d,0x3e,0x3d,
0x3a,0x3a,0x39,0x3a,0x3a,0x3a,0x3c,0x40,0x47,0x4e,0x56,0x5f,0x66,0x6f,0x77,0x7f,
0x86,0x8d,0x90,0x93,0x95,0x96,0x96,0x93,0x96,0x96,0x96,0x97,0x98,0x99,0x9a,0x99,
0x96,0x96,0x96,0x96,0x96,0x98,0x98,0x99,0x99,0x9a,0x9a,0x9b,0x9a,0x9c,0x9d,0x9c,
0x99,0x99,0x98,0x98,0x99,0x9a,0x98,0x96,0x93,0x94,0x95,0x96,0x96,0x98,0x98,0x97,
0x96,0x97,0x99,0x9a,0x9b,0x9a,0x98,0x98,0x98,0x98,0x97,0x96,0x94,0x96,0x96,0x97,
0x95,0x98,0x97,0x99,0x9a,0x9a,0x9a,0x9a,0x99,0x99,0x9a,0x9a,0x9a,0x99,0x98,0x97,
0x97,0x98,0x98,0x99,0x9b,0x9c,0x9b,0x9c,0x9b,0x9a,0x99,0x98,0x97,0x99,0x9a,0x9a,
0x99,0x99,0x98,0x97,0x96,0x98,0x99,0x9a,0x98,0x96,0x95,0x96,0x96,0x98,0x9a,0x9b,
0x9d,0x9d,0x9c,0x9b,0x9a,0x9b,0x9a,0x99,0x97,0x96,0x95,0x95,0x96,0x98,0x97,0x97,
0x97,0x99,0x9a,0x9c,0x9b,0x9c,0x9c,0x9a,0x97,0x98,0x98,0x98,0x97,0x99,0x98,0x98,
0x99,0x9b,0x9b,0x9d,0x9b,0x9a,0x9b,0x9a,0x98,0x97,0x95,0x93,0x91,0x93,0x93,0x91,
0x8f,0x8b,0x85,0x7f,0x76,0x6e,0x65,0x5c,0x52,0x4d,0x49,0x46,0x41,0x3e,0x3a,0x39,
0x39,0x3a,0x3b,0x3b,0x39,0x38,0x39,0x39,0x3a,0x3d,0x40,0x40,0x3e,0x3c,0x39,0x38,
0x38,0x3a,0x3c,0x3d,0x3a,0x39,0x39,0x3a,0x3b,0x3d,0x3c,0x3d,0x3d,0x3d,0x3a,0x3b,
0x3c,0x40,0x41,0x3e,0x3b,0x3a,0x3a,0x38,0x36,0x36,0x36,0x36,0x39,0x3a,0x3a,0x3a,
0x39,0x39,0x3a,0x39,0x38,0x37,0x36,0x36,0x36,0x37,0x37,0x35,0x39,0x3a,0x3a,0x3b,
0x3a,0x3b,0x3d,0x3e,0x3d,0x3d,0x3c,0x3c,0x3c,0x3c,0x3b,0x3b,0x3a,0x3a,0x38,0x37,
0x36,0x37,0x3a,0x3b,0x3c,0x3c,0x3c,0x3d,0x3e,0x40,0x40,0x3f,0x3e,0x3a,0x3a,0x3a,
0x39,0x39,0x3c,0x3f,0x44,0x4b,0x53,0x5d,0x68,0x73,0x7c,0x85,0x8c,0x93,0x96,0x97,
0x97,0x99,0x9a,0x9a,0x98,0x97,0x97,0x98,0x98,0x9a,0x9d,0x9e,0x9d,0x9c,0x9b,0x9b,
0x9a,0x9a,0x99,0x97,0x97,0x97,0x96,0x95,0x97,0x96,0x95,0x96,0x97,0x99,0x9c,0x9c,
0x9b,0x9d,0x9c,0x9c,0x9b,0x9a,0x99,0x99,0x9a,0x9a,0x9a,0x9a,0x98,0x98,0x99,0x99,
0x98,0x99,0x9a,0x9a,0x98,0x97,0x96,0x98,0x97,0x97,0x97,0x98,0x98,0x99,0x97,0x95,
0x95,0x97,0x97,0x98,0x9b,0x9a,0x98,0x97,0x96,0x97,0x99,0x9a,0x9a,0x9b,0x9a,0x9a,
0x98,0x99,0x9a,0x9c,0x9e,0x9e,0x9c,0x9b,0x98,0x98,0x97,0x98,0x97,0x98,0x96,0x95,
0x96,0x98,0x98,0x97,0x93,0x8d,0x84,0x7c,0x72,0x69,0x61,0x58,0x4e,0x49,0x43,0x40,
0x3e,0x3e,0x3e,0x3f,0x3e,0x3e,0x3c,0x3b,0x3b,0x3c,0x3f,0x40,0x3e,0x41,0x3e,0x3a,
0x3a,0x3c,0x3c,0x3c,0x3a,0x39,0x38,0x37,0x39,0x3a,0x3c,0x3c,0x3b,0x3a,0x37,0x36,
0x38,0x39,0x3a,0x3d,0x3d,0x3d,0x3c,0x3c,0x3b,0x3d,0x3e,0x3f,0x3d,0x3b,0x3a,0x39,
0x3a,0x3a,0x39,0x3a,0x39,0x38,0x39,0x39,0x39,0x39,0x3b,0x3c,0x3e,0x3e,0x3d,0x3c,
0x3d,0x3c,0x3a,0x3b,0x3a,0x39,0x3a,0x39,0x39,0x3a,0x39,0x3a,0x3b,0x3c,0x3a,0x3a,
0x3a,0x39,0x39,0x3a,0x3b,0x3c,0x3e,0x3e,0x3d,0x3c,0x39,0x37,0x36,0x34,0x35,0x33,
0x35,0x34,0x33,0x35,0x36,0x37,0x3c,0x43,0x49,0x51,0x59,0x61,0x69,0x71,0x7a,0x84,
0x8c,0x90,0x93,0x94,0x93,0x93,0x94,0x96,0x98,0x99,0x97,0x96,0x96,0x96,0x96,0x99,
0x9a,0x9a,0x99,0x98,0x97,0x97,0x97,0x97,0x97,0x98,0x98,0x96,0x98,0x98,0x98,0x9a,
0x9c,0x9b,0x9b,0x9c,0x9b,0x9c,0x9a,0x9a,0x99,0x98,0x96,0x96,0x98,0x9a,0x9a,0x9a,
0x9a,0x9a,0x9a,0x9a,0x9a,0x9c,0x9a,0x99,0x98,0x97,0x96,0x96,0x95,0x94,0x95,0x97,
0x97,0x96,0x96,0x96,0x96,0x97,0x97,0x98,0x99,0x99,0x99,0x9a,0x9a,0x9a,0x9a,0x9a,
0x99,0x99,0x9a,0x9d,0x9e,0x9d,0x9d,0x9a,0x9a,0x9a,0x9a,0x9b,0x98,0x97,0x94,0x93,
0x93,0x93,0x94,0x95,0x96,0x97,0x95,0x8f,0x8b,0x84,0x7c,0x76,0x6e,0x64,0x5b,0x53,
0x4a,0x45,0x40,0x40,0x3e,0x3e,0x3c,0x3b,0x3a,0x3b,0x3a,0x3b,0x3b,0x3c,0x3d,0x3d,
0x3d,0x3e,0x3e,0x3e,0x3e,0x3c,0x3b,0x3b,0x3b,0x3b,0x3b,0x3a,0x3a,0x3a,0x3b,0x3a,
0x3a,0x3e,0x3f,0x3f,0x3f,0x3c,0x3a,0x3c,0x3b,0x3c,0x3c,0x3c,0x39,0x38,0x39,0x3a,
0x3b,0x3c,0x3d,0x3c,0x3c,0x3b,0x3a,0x3b,0x3a,0x39,0x39,0x3a,0x39,0x3a,0x3a,0x3b,
0x3b,0x3c,0x3d,0x3e,0x3f,0x3e,0x3d,0x3d,0x3c,0x3b,0x3c,0x3c,0x37,0x38,0x38,0x38,
0x37,0x38,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x39,0x39,0x3a,0x3b,0x3a,0x3c,0x3a,0x39,
0x39,0x3a,0x3a,0x3a,0x39,0x39,0x39,0x39,0x38,0x38,0x37,0x37,0x37,0x39,0x38,0x39,
0x39,0x39,0x3a,0x3c,0x3c,0x3e,0x3c,0x3e,0x3a,0x39,0x37,0x36,0x36,0x38,0x39,0x38,
0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,0x38,0x37,0x36,0x36,0x37,0x39,
// Line 15
0x39,0x3b,0x39,0x38,0x37,0x39,0x38,0x39,0x38,0x38,0x39,0x39,0x38,0x39,0x3a,0x3b,
0x3b,0x3b,0x3a,0x3b,0x3b,0x3a,0x39,0x39,0x38,0x38,0x39,0x38,0x37,0x38,0x38,0x38,
0x36,0x34,0x34,0x36,0x38,0x3c,0x3d,0x3d,0x3b,0x39,0x38,0x37,0x38,0x3c,0x3d,0x3b,
0x38,0x36,0x34,0x39,0x46,0x59,0x6f,0x7e,0x84,0x80,0x76,0x68,0x5c,0x5e,0x67,0x73,
0x7b,0x7c,0x77,0x6f,0x66,0x60,0x60,0x65,0x6d,0x75,0x7a,0x7a,0x75,0x70,0x68,0x64,
0x64,0x67,0x6d,0x74,0x79,0x79,0x75,0x6c,0x63,0x5d,0x5a,0x60,0x69,0x73,0x79,0x76,
0x73,0x6b,0x63,0x62,0x64,0x6a,0x72,0x77,0x79,0x77,0x70,0x6b,0x66,0x63,0x62,0x68,
0x70,0x76,0x7a,0x79,0x74,0x6c,0x66,0x61,0x62,0x68,0x70,0x77,0x7b,0x7b,0x75,0x6c,
0x64,0x62,0x65,0x6b,0x70,0x72,0x75,0x75,0x76,0x7e,0x88,0x93,0xa1,0xa8,0xaa,0xa8,
0xa0,0x96,0x87,0x78,0x68,0x60,0x5b,0x56,0x51,0x4a,0x43,0x3c,0x3a,0x40,0x4c,0x61,
0x75,0x84,0x8d,0x90,0x91,0x94,0x98,0x9e,0xa2,0xa2,0x9d,0x91,0x81,0x71,0x64,0x5f,
0x5f,0x63,0x6a,0x70,0x78,0x81,0x88,0x8f,0x96,0x9e,0xa4,0xa7,0xa6,0xa3,0x9b,0x99,
0x98,0x98,0x9c,0x9d,0x96,0x8b,0x78,0x65,0x58,0x55,0x5a,0x66,0x70,0x79,0x7a,0x75,
0x6d,0x66,0x62,0x64,0x69,0x74,0x7b,0x7e,0x7b,0x74,0x6b,0x65,0x63,0x68,0x6f,0x76,
0x7b,0x7b,0x75,0x6c,0x63,0x61,0x65,0x6c,0x73,0x78,0x7a,0x7a,0x70,0x67,0x61,0x5e,
0x5c,0x59,0x53,0x49,0x3d,0x33,0x2c,0x2a,0x2b,0x31,0x3b,0x47,0x53,0x61,0x6e,0x77,
0x7a,0x78,0x6f,0x65,0x5e,0x5f,0x66,0x72,0x7a,0x7c,0x77,0x6f,0x64,0x5f,0x62,0x6b,
0x75,0x7f,0x81,0x7b,0x73,0x6d,0x67,0x63,0x60,0x5b,0x54,0x4b,0x3e,0x32,0x2b,0x28,
0x2b,0x30,0x39,0x44,0x52,0x60,0x6d,0x77,0x7b,0x7a,0x72,0x68,0x60,0x62,0x6b,0x77,
0x7e,0x7e,0x77,0x6e,0x64,0x60,0x64,0x6e,0x78,0x7f,0x7f,0x79,0x71,0x6c,0x66,0x62,
0x5f,0x5c,0x53,0x48,0x3b,0x31,0x2c,0x2f,0x32,0x37,0x40,0x49,0x55,0x64,0x70,0x79,
0x7d,0x7a,0x6f,0x64,0x5b,0x5d,0x65,0x70,0x7a,0x7e,0x7b,0x72,0x64,0x5d,0x5d,0x65,
0x71,0x7a,0x7c,0x77,0x6e,0x66,0x63,0x63,0x63,0x5e,0x59,0x4f,0x43,0x3a,0x32,0x2d,
0x2e,0x31,0x39,0x46,0x54,0x64,0x73,0x79,0x77,0x71,0x69,0x63,0x5e,0x5a,0x53,0x48,
0x3c,0x33,0x32,0x3e,0x53,0x6c,0x83,0x8b,0x87,0x7b,0x69,0x59,0x51,0x4e,0x4a,0x42,
0x38,0x30,0x2c,0x2e,0x33,0x3d,0x48,0x4e,0x55,0x60,0x6b,0x79,0x88,0x94,0x98,0x9e,
0xa2,0xa8,0xac,0xaa,0xa3,0x97,0x86,0x76,0x6a,0x63,0x62,0x67,0x6f,0x76,0x7b,0x82,
0x89,0x93,0x9b,0xa0,0x9e,0x93,0x7f,0x6a,0x59,0x55,0x58,0x63,0x71,0x7c,0x7e,0x7a,
0x6e,0x66,0x62,0x66,0x6b,0x72,0x77,0x7b,0x7b,0x82,0x8a,0x97,0xa1,0xa2,0x97,0x84,
0x6c,0x5a,0x54,0x59,0x68,0x79,0x83,0x84,0x7c,0x72,0x6a,0x66,0x66,0x6a,0x6d,0x72,
0x75,0x7b,0x84,0x8e,0x97,0x9e,0x9b,0x90,0x7e,0x6a,0x56,0x4a,0x42,0x3e,0x38,0x39,
0x36,0x35,0x36,0x39,0x3b,0x40,0x48,0x54,0x63,0x74,0x82,0x8f,0x97,0x9b,0x9a,0x93,
0x87,0x7b,0x6b,0x5b,0x4c,0x43,0x3d,0x3c,0x3c,0x3d,0x3c,0x3c,0x3a,0x3e,0x43,0x4c,
0x55,0x63,0x70,0x7e,0x88,0x91,0x97,0x9c,0xa0,0xa3,0xa3,0xa2,0x9b,0x91,0x83,0x74,
0x65,0x5e,0x5d,0x61,0x6a,0x75,0x7e,0x84,0x8a,0x91,0x98,0xa3,0xa8,0xad,0xaa,0xa3,
0x9c,0x98,0x97,0x99,0x9d,0x9e,0x95,0x88,0x74,0x64,0x5a,0x59,0x5e,0x67,0x73,0x7d,
0x82,0x8b,0x91,0x99,0xa0,0x9e,0x94,0x83,0x6f,0x5e,0x58,0x5d,0x6b,0x7a,0x83,0x84,
0x7b,0x6e,0x5f,0x58,0x5b,0x67,0x72,0x7a,0x77,0x70,0x66,0x60,0x5d,0x5f,0x60,0x5f,
0x53,0x42,0x32,0x30,0x3e,0x58,0x72,0x84,0x89,0x81,0x73,0x64,0x5a,0x5a,0x64,0x6d,
0x74,0x78,0x7b,0x7e,0x8b,0x96,0x9b,0x98,0x8a,0x77,0x62,0x52,0x45,0x3f,0x3d,0x3e,
0x3b,0x38,0x34,0x37,0x3b,0x3f,0x3f,0x3c,0x36,0x32,0x33,0x3b,0x44,0x52,0x60,0x6e,
0x7b,0x86,0x8f,0x93,0x93,0x90,0x86,0x77,0x68,0x5b,0x55,0x4c,0x42,0x3d,0x3c,0x3e,
0x46,0x52,0x61,0x74,0x82,0x8b,0x8f,0x92,0x97,0x9d,0xa3,0xa7,0xa4,0x9c,0x8d,0x7b,
0x6b,0x60,0x58,0x53,0x4b,0x44,0x3e,0x39,0x3b,0x45,0x53,0x64,0x75,0x85,0x90,0x97,
0x9b,0x9e,0xa0,0xa4,0xa4,0xa4,0xa2,0x9e,0x98,0x97,0x97,0x98,0x9b,0x9d,0x9d,0x9c,
0x9c,0x9e,0x9f,0xa0,0x9e,0x9b,0x94,0x89,0x7a,0x6c,0x61,0x5c,0x5e,0x66,0x6f,0x77,
0x7f,0x88,0x90,0x99,0xa0,0xa6,0xa7,0xa3,0x9d,0x99,0x97,0x98,0x9b,0x9c,0x98,0x8f,
0x80,0x70,0x61,0x58,0x4e,0x49,0x45,0x40,0x39,0x35,0x31,0x32,0x39,0x3f,0x40,0x3e,
0x37,0x30,0x2f,0x36,0x43,0x58,0x6b,0x79,0x7c,0x75,0x6a,0x5e,0x5a,0x5e,0x6a,0x77,
0x7e,0x7e,0x79,0x70,0x69,0x67,0x65,0x64,0x5c,0x4e,0x3d,0x32,0x30,0x3b,0x49,0x61,
0x75,0x86,0x93,0x9a,0x99,0x99,0x90,0x84,0x77,0x67,0x59,0x50,0x49,0x42,0x3c,0x39,
0x40,0x50,0x65,0x78,0x85,0x89,0x82,0x73,0x62,0x53,0x4b,0x49,0x46,0x40,0x37,0x2e,
0x2a,0x2d,0x34,0x3d,0x47,0x51,0x58,0x62,0x6e,0x7c,0x88,0x91,0x99,0x9d,0xa1,0xa4,
0xa6,0xa7,0xa2,0x9e,0x9b,0x9c,0x9d,0x9f,0xa6,0xa9,0xa7,0xa4,0xa0,0x9f,0xa0,0x9f,
0x9e,0x9c,0x95,0x88,0x79,0x6a,0x5d,0x59,0x5e,0x6a,0x76,0x7f,0x7f,0x78,0x6d,0x65,
0x60,0x62,0x66,0x6c,0x72,0x77,0x7a,0x80,0x8a,0x97,0x9e,0x9b,0x8c,0x76,0x61,0x50,
0x43,0x3f,0x3c,0x3a,0x36,0x34,0x32,0x37,0x3c,0x40,0x40,0x3b,0x32,0x2e,0x2f,0x38,
0x47,0x5b,0x6c,0x77,0x7b,0x76,0x6d,0x62,0x5b,0x55,0x52,0x4e,0x45,0x3b,0x31,0x2d,
0x2c,0x32,0x3b,0x45,0x4d,0x56,0x60,0x6d,0x79,0x84,0x8e,0x95,0x99,0xa1,0xa6,0xa8,
0xa6,0x9c,0x8b,0x7b,0x6b,0x60,0x55,0x54,0x4c,0x43,0x38,0x33,0x34,0x46,0x5a,0x6f,
0x81,0x88,0x82,0x73,0x63,0x5a,0x5c,0x65,0x70,0x7a,0x7c,0x78,0x6e,0x65,0x60,0x62,
0x69,0x70,0x72,0x75,0x76,0x7b,0x83,0x8f,0x9b,0xa5,0xa4,0x99,0x85,0x71,0x60,0x56,
0x57,0x60,0x6d,0x79,0x82,0x8a,0x92,0x98,0x9e,0xa3,0xa5,0xa4,0x9f,0x95,0x88,0x76,
0x6b,0x60,0x56,0x4e,0x47,0x40,0x3d,0x35,0x30,0x31,0x35,0x3a,0x3f,0x40,0x3b,0x37,
0x33,0x35,0x3b,0x48,0x57,0x67,0x75,0x80,0x88,0x8f,0x95,0x9a,0x9b,0x93,0x81,0x6e,
0x5d,0x59,0x60,0x6d,0x7b,0x84,0x82,0x79,0x6b,0x61,0x5f,0x64,0x6b,0x6e,0x6e,0x70,
0x76,0x80,0x8e,0x99,0x9e,0x9c,0x90,0x7c,0x64,0x55,0x4b,0x44,0x40,0x3e,0x3d,0x41,
0x49,0x58,0x68,0x77,0x84,0x8f,0x91,0x94,0x97,0x9d,0xa2,0xa4,0xa0,0x96,0x89,0x7b,
0x6a,0x5c,0x51,0x49,0x42,0x40,0x3d,0x3a,0x38,0x38,0x38,0x39,0x3b,0x40,0x49,0x54,
0x5f,0x6c,0x78,0x84,0x8b,0x99,0x9f,0xa3,0xa4,0xa4,0xa2,0x9f,0x9c,0x9c,0x9d,0x9f,
0xa0,0xa0,0xa2,0xa2,0xa3,0xa0,0x95,0x85,0x74,0x66,0x5d,0x5c,0x61,0x6c,0x78,0x7f,
0x86,0x8f,0x97,0x9e,0x9f,0x9b,0x90,0x80,0x6c,0x5c,0x53,0x5a,0x63,0x6e,0x7c,0x88,
0x8f,0x95,0x97,0x96,0x91,0x88,0x7c,0x6a,0x58,0x49,0x3f,0x3c,0x3b,0x3c,0x3b,0x39,
0x36,0x35,0x37,0x3f,0x4d,0x5e,0x6d,0x78,0x7a,0x77,0x6d,0x63,0x5d,0x60,0x67,0x70,
0x74,0x7b,0x7f,0x85,0x90,0x9c,0xa4,0xa4,0x99,0x87,0x72,0x60,0x59,0x59,0x63,0x70,
0x7c,0x86,0x8d,0x92,0x98,0x9e,0xa0,0xa2,0xa0,0x9f,0x9a,0x91,0x81,0x71,0x64,0x5d,
0x5d,0x66,0x71,0x7c,0x7f,0x7b,0x72,0x6a,0x64,0x60,0x5d,0x54,0x48,0x3b,0x31,0x32,
0x40,0x55,0x6d,0x7e,0x8b,0x93,0x97,0x99,0x99,0x95,0x8e,0x7c,0x68,0x5b,0x57,0x5c,
0x69,0x77,0x80,0x81,0x77,0x6b,0x5e,0x5d,0x60,0x6b,0x74,0x7a,0x79,0x73,0x6b,0x65,
0x63,0x63,0x60,0x5b,0x4e,0x41,0x36,0x34,0x3c,0x4d,0x63,0x7a,0x8a,0x95,0x98,0x95,
0x98,0x9a,0x9b,0x9f,0xa0,0x9e,0x9f,0x9d,0x9b,0x9c,0x98,0x8f,0x80,0x70,0x60,0x53,
0x4a,0x46,0x41,0x3d,0x36,0x32,0x33,0x38,0x3c,0x40,0x41,0x3d,0x38,0x32,0x31,0x38,
0x44,0x53,0x62,0x71,0x7c,0x86,0x8d,0x93,0x99,0xa1,0xa6,0xa7,0xa3,0x9c,0x8e,0x80,
0x72,0x68,0x5c,0x55,0x4b,0x43,0x3b,0x38,0x37,0x45,0x54,0x65,0x77,0x85,0x8f,0x97,
0x97,0x95,0x8f,0x84,0x76,0x67,0x56,0x4a,0x40,0x3a,0x35,0x34,0x3a,0x45,0x55,0x68,
0x78,0x87,0x92,0x98,0x99,0x99,0x93,0x8a,0x7e,0x70,0x63,0x5c,0x5d,0x66,0x6e,0x7c,
0x84,0x8a,0x91,0x97,0x9d,0xa6,0xa7,0xa4,0xa0,0x9c,0x99,0x98,0x99,0x9c,0xa1,0xa3,
0xa3,0xa2,0xa0,0x9f,0x9f,0xa2,0xa2,0xa1,0xa0,0x9e,0x9c,0x9c,0x9a,0x9b,0x9c,0x9f,
0x9f,0xa1,0xa1,0xa2,0xa0,0xa2,0xa2,0x9e,0x96,0x87,0x74,0x66,0x5b,0x5b,0x62,0x6f,
0x79,0x7e,0x7b,0x72,0x68,0x61,0x5c,0x56,0x50,0x48,0x3d,0x35,0x2c,0x2b,0x30,0x38,
0x3e,0x43,0x42,0x3d,0x36,0x31,0x2e,0x30,0x33,0x38,0x36,0x34,0x32,0x33,0x35,0x38,
0x38,0x38,0x33,0x30,0x31,0x3b,0x4a,0x5e,0x71,0x7c,0x7c,0x74,0x6a,0x61,0x5e,0x59,
0x53,0x4a,0x3d,0x34,0x32,0x3e,0x53,0x6e,0x80,0x88,0x82,0x74,0x62,0x56,0x4e,0x4b,
0x45,0x3e,0x34,0x2e,0x2b,0x2c,0x30,0x36,0x3e,0x48,0x53,0x60,0x6d,0x78,0x84,0x8d,
0x95,0x9d,0xa4,0xa8,0xad,0xac,0xa4,0x9f,0x99,0x99,0x9e,0xa3,0xa3,0xa3,0xa0,0x9e,
0x9c,0x9d,0x9f,0xa2,0xa2,0x9b,0x8f,0x80,0x71,0x65,0x5b,0x50,0x46,0x3f,0x3a,0x36,
// Line 16
0x39,0x3b,0x3c,0x3b,0x38,0x36,0x35,0x35,0x36,0x38,0x39,0x3a,0x39,0x37,0x38,0x3a,
0x3b,0x3b,0x3a,0x39,0x39,0x38,0x37,0x36,0x35,0x35,0x34,0x35,0x35,0x34,0x33,0x33,
0x32,0x35,0x36,0x37,0x37,0x38,0x39,0x3a,0x38,0x37,0x36,0x36,0x35,0x38,0x38,0x37,
0x33,0x32,0x31,0x33,0x40,0x54,0x67,0x75,0x7a,0x75,0x6b,0x61,0x5c,0x60,0x69,0x73,
0x7a,0x7c,0x78,0x6f,0x67,0x61,0x61,0x68,0x6e,0x72,0x75,0x73,0x70,0x6c,0x66,0x61,
0x5f,0x62,0x6a,0x73,0x78,0x79,0x75,0x6e,0x63,0x5d,0x5f,0x67,0x6f,0x75,0x77,0x74,
0x6f,0x68,0x62,0x60,0x61,0x65,0x6c,0x74,0x78,0x78,0x74,0x6c,0x65,0x60,0x5f,0x64,
0x6b,0x72,0x74,0x74,0x6f,0x69,0x61,0x60,0x61,0x68,0x70,0x78,0x7b,0x7b,0x75,0x6c,
0x67,0x64,0x63,0x69,0x6b,0x6f,0x72,0x75,0x78,0x7b,0x84,0x91,0x9f,0xab,0xb0,0xae,
0xa4,0x95,0x83,0x73,0x65,0x5e,0x58,0x52,0x49,0x41,0x3a,0x38,0x39,0x42,0x50,0x65,
0x77,0x85,0x8e,0x94,0x98,0x9b,0x9e,0x9e,0x9e,0x9e,0x98,0x8c,0x7e,0x6f,0x61,0x58,
0x57,0x5d,0x68,0x76,0x7f,0x7f,0x78,0x6e,0x64,0x61,0x62,0x69,0x72,0x78,0x78,0x74,
0x6a,0x64,0x61,0x63,0x68,0x6f,0x73,0x75,0x74,0x77,0x7e,0x8a,0x98,0xa4,0xac,0xae,
0xa9,0xa1,0x9a,0x99,0x9a,0x9e,0x9f,0x9b,0x91,0x83,0x73,0x65,0x58,0x4e,0x43,0x3b,
0x35,0x34,0x3b,0x49,0x5d,0x72,0x7f,0x81,0x78,0x6b,0x5f,0x58,0x54,0x50,0x49,0x3f,
0x37,0x36,0x43,0x58,0x6f,0x80,0x83,0x7a,0x6b,0x5c,0x51,0x4e,0x4c,0x49,0x40,0x38,
0x33,0x34,0x39,0x41,0x46,0x49,0x42,0x3a,0x35,0x34,0x35,0x35,0x33,0x31,0x2d,0x35,
0x43,0x58,0x6e,0x7b,0x7b,0x78,0x6d,0x62,0x5f,0x62,0x68,0x70,0x72,0x73,0x78,0x80,
0x8a,0x94,0xa1,0xaa,0xad,0xab,0xa5,0x9e,0x9c,0x9d,0x9e,0xa1,0x9e,0x96,0x89,0x78,
0x66,0x5b,0x56,0x59,0x61,0x6b,0x75,0x82,0x8e,0x97,0x9c,0x9c,0x95,0x88,0x78,0x68,
0x57,0x4d,0x43,0x3a,0x35,0x36,0x3e,0x4d,0x5e,0x72,0x7f,0x83,0x7c,0x6f,0x66,0x5f,
0x57,0x52,0x4a,0x41,0x39,0x35,0x3b,0x4c,0x63,0x7b,0x8b,0x97,0x99,0x98,0x94,0x8e,
0x82,0x7a,0x6a,0x57,0x4a,0x42,0x3e,0x3e,0x3c,0x3b,0x38,0x37,0x37,0x3c,0x42,0x4b,
0x54,0x60,0x6c,0x7a,0x88,0x94,0x9c,0xa3,0xa4,0xa4,0xa4,0xa2,0x9f,0x9d,0x9a,0x99,
0x9a,0x9e,0xa0,0xa3,0xa5,0xa6,0xa4,0xa4,0xa0,0x9f,0xa1,0xa3,0xa2,0xa3,0xa1,0x9f,
0x9e,0x9f,0xa1,0xa1,0x9e,0x96,0x8a,0x7c,0x6e,0x63,0x59,0x51,0x45,0x3e,0x37,0x36,
0x3c,0x4a,0x5a,0x6f,0x7b,0x81,0x7a,0x6c,0x61,0x59,0x55,0x53,0x4c,0x44,0x3b,0x37,
0x3c,0x4c,0x62,0x7b,0x8c,0x96,0x99,0x99,0x9a,0x9c,0x9f,0xa2,0xa3,0xa3,0x9f,0x9b,
0x9e,0x9f,0xa1,0xa3,0xa3,0xa3,0xa1,0x98,0x8a,0x7b,0x6b,0x5d,0x51,0x49,0x42,0x3f,
0x3c,0x39,0x34,0x32,0x33,0x39,0x3f,0x41,0x3e,0x3a,0x33,0x31,0x36,0x43,0x54,0x66,
0x76,0x83,0x8c,0x94,0x98,0x98,0x92,0x89,0x79,0x6b,0x5b,0x4f,0x47,0x41,0x3c,0x3c,
0x3b,0x3d,0x3d,0x40,0x3d,0x3b,0x37,0x33,0x2f,0x32,0x38,0x43,0x52,0x62,0x72,0x82,
0x8d,0x96,0x9c,0x9d,0x95,0x89,0x7a,0x6b,0x5d,0x52,0x49,0x41,0x3a,0x38,0x3c,0x4b,
0x5d,0x71,0x7e,0x81,0x79,0x6c,0x5e,0x57,0x54,0x53,0x4c,0x45,0x3b,0x31,0x2d,0x30,
0x39,0x43,0x48,0x45,0x3d,0x38,0x34,0x37,0x44,0x57,0x68,0x76,0x82,0x8c,0x96,0x9c,
0x9b,0x93,0x85,0x75,0x63,0x55,0x49,0x43,0x40,0x3e,0x37,0x34,0x32,0x35,0x39,0x3d,
0x3d,0x3d,0x38,0x34,0x32,0x38,0x46,0x5a,0x6e,0x7a,0x7b,0x75,0x69,0x5e,0x59,0x5d,
0x65,0x6f,0x74,0x78,0x7d,0x85,0x8e,0x97,0x9f,0xa1,0x97,0x84,0x6f,0x5e,0x57,0x58,
0x60,0x6e,0x7b,0x84,0x8a,0x8f,0x93,0x9a,0xa0,0xa6,0xa3,0xa2,0x9b,0x98,0x9a,0x9c,
0x9d,0x9c,0x96,0x88,0x77,0x66,0x5c,0x59,0x5d,0x64,0x6c,0x75,0x80,0x89,0x95,0x9b,
0x9a,0x96,0x89,0x78,0x6a,0x58,0x4b,0x44,0x40,0x3e,0x3b,0x3d,0x45,0x54,0x66,0x75,
0x7f,0x88,0x8c,0x90,0x93,0x98,0x9e,0xa3,0xa4,0x9f,0x93,0x83,0x75,0x6b,0x64,0x61,
0x62,0x68,0x70,0x78,0x7d,0x84,0x8d,0x99,0xa1,0xa6,0xa9,0xa9,0xa4,0xa1,0x9c,0x9a,
0x98,0x9a,0x9c,0xa0,0xa1,0xa1,0x9c,0x9b,0x99,0x99,0x9c,0x9d,0x99,0x93,0x87,0x79,
0x6a,0x61,0x5e,0x61,0x6a,0x73,0x7d,0x84,0x8b,0x91,0x96,0x9b,0xa0,0xa7,0xa9,0xa5,
0x9e,0x98,0x93,0x95,0x98,0x9a,0x95,0x87,0x72,0x61,0x57,0x57,0x60,0x6f,0x7b,0x7e,
0x7b,0x72,0x67,0x64,0x5f,0x59,0x52,0x45,0x35,0x2e,0x2f,0x39,0x4b,0x62,0x79,0x88,
0x90,0x95,0x97,0x99,0x95,0x8e,0x80,0x6f,0x60,0x5a,0x5e,0x6a,0x76,0x81,0x82,0x7c,
0x71,0x66,0x60,0x62,0x68,0x71,0x78,0x77,0x72,0x6c,0x66,0x61,0x63,0x66,0x6a,0x6c,
0x6e,0x70,0x74,0x7d,0x89,0x95,0x9c,0x9a,0x8f,0x7f,0x6b,0x59,0x4b,0x43,0x3e,0x3d,
0x3e,0x43,0x4c,0x59,0x67,0x78,0x84,0x8e,0x91,0x94,0x96,0x9b,0x9f,0xa3,0xa2,0x9c,
0x8f,0x7f,0x6c,0x5e,0x5a,0x5e,0x66,0x6f,0x75,0x7b,0x79,0x6f,0x68,0x5f,0x58,0x57,
0x50,0x47,0x3b,0x30,0x27,0x28,0x2c,0x33,0x3a,0x3d,0x3b,0x38,0x37,0x38,0x38,0x38,
0x35,0x34,0x36,0x3e,0x4c,0x5f,0x6f,0x77,0x77,0x71,0x69,0x64,0x60,0x5d,0x57,0x4f,
0x40,0x34,0x33,0x3c,0x4b,0x62,0x77,0x87,0x8f,0x94,0x95,0x96,0x92,0x8c,0x7f,0x71,
0x61,0x5a,0x5c,0x64,0x6f,0x7b,0x84,0x8c,0x92,0x98,0x9c,0xa1,0xa3,0xa3,0x9d,0x92,
0x83,0x76,0x6a,0x60,0x59,0x56,0x4f,0x47,0x3e,0x38,0x36,0x3e,0x4b,0x5e,0x73,0x82,
0x89,0x8f,0x92,0x97,0x9b,0xa4,0xa7,0xa7,0x9e,0x8f,0x7b,0x6c,0x60,0x58,0x54,0x4f,
0x46,0x3e,0x38,0x39,0x45,0x58,0x6b,0x79,0x7e,0x79,0x6e,0x61,0x5b,0x5c,0x64,0x6e,
0x76,0x7d,0x7b,0x75,0x6b,0x63,0x60,0x63,0x6a,0x74,0x78,0x7b,0x76,0x6e,0x66,0x62,
0x63,0x6d,0x73,0x79,0x7d,0x7b,0x74,0x6b,0x63,0x60,0x5d,0x59,0x52,0x49,0x3d,0x31,
0x27,0x25,0x28,0x2f,0x39,0x45,0x51,0x60,0x6b,0x74,0x78,0x75,0x6c,0x65,0x5d,0x57,
0x52,0x4c,0x44,0x3b,0x33,0x2c,0x2a,0x33,0x3b,0x47,0x52,0x5c,0x64,0x6c,0x75,0x82,
0x8f,0x99,0x9b,0x97,0x8c,0x7d,0x6b,0x5d,0x57,0x5c,0x67,0x72,0x7a,0x7f,0x7a,0x71,
0x68,0x60,0x5b,0x56,0x4c,0x42,0x39,0x36,0x3b,0x4b,0x60,0x77,0x88,0x92,0x94,0x90,
0x8e,0x8b,0x83,0x79,0x6a,0x5b,0x4f,0x45,0x3f,0x3e,0x3e,0x3c,0x38,0x37,0x37,0x3b,
0x44,0x51,0x61,0x71,0x79,0x7b,0x79,0x71,0x66,0x5f,0x58,0x51,0x47,0x3e,0x37,0x35,
0x3a,0x4a,0x5f,0x78,0x8c,0x99,0x9d,0x9b,0x96,0x90,0x87,0x7a,0x6b,0x5c,0x4d,0x41,
0x3b,0x3a,0x39,0x39,0x36,0x34,0x34,0x38,0x3f,0x4c,0x58,0x63,0x6e,0x7a,0x83,0x8f,
0x97,0x9a,0x95,0x89,0x78,0x67,0x59,0x54,0x57,0x65,0x72,0x7a,0x7d,0x79,0x6f,0x68,
0x61,0x63,0x6c,0x77,0x7b,0x7a,0x73,0x6a,0x61,0x5d,0x5c,0x5a,0x54,0x47,0x3a,0x32,
0x2f,0x3a,0x4c,0x62,0x77,0x89,0x94,0x9a,0x99,0x96,0x8e,0x82,0x74,0x68,0x5c,0x53,
0x4b,0x44,0x3e,0x3b,0x3c,0x45,0x53,0x64,0x76,0x84,0x8b,0x8f,0x91,0x96,0x9d,0xa4,
0xa9,0xa7,0x9e,0x8e,0x7c,0x6e,0x61,0x59,0x54,0x4b,0x41,0x39,0x33,0x34,0x40,0x54,
0x6a,0x7d,0x83,0x7d,0x6d,0x61,0x58,0x57,0x60,0x6f,0x7a,0x7d,0x76,0x6e,0x67,0x64,
0x63,0x69,0x6b,0x6c,0x6e,0x71,0x76,0x7f,0x8b,0x97,0xa0,0xa8,0xaa,0xa9,0xa3,0x9a,
0x8b,0x7b,0x6a,0x5d,0x56,0x58,0x60,0x6a,0x72,0x77,0x72,0x6e,0x64,0x5c,0x57,0x54,
0x4d,0x48,0x3d,0x34,0x2f,0x2b,0x2a,0x2f,0x38,0x46,0x56,0x64,0x6f,0x75,0x72,0x6c,
0x64,0x61,0x5e,0x5b,0x54,0x4a,0x3d,0x34,0x33,0x3f,0x56,0x6f,0x7f,0x86,0x7f,0x71,
0x61,0x54,0x4d,0x4b,0x47,0x3f,0x33,0x2d,0x2a,0x2e,0x38,0x3e,0x3e,0x3b,0x35,0x31,
0x33,0x37,0x3b,0x3b,0x38,0x35,0x38,0x46,0x5a,0x6e,0x7a,0x7a,0x70,0x64,0x59,0x54,
0x52,0x53,0x4f,0x47,0x39,0x2f,0x2b,0x31,0x3a,0x44,0x49,0x46,0x3b,0x32,0x2e,0x33,
0x44,0x5a,0x6c,0x78,0x78,0x71,0x68,0x60,0x5a,0x58,0x54,0x49,0x3c,0x33,0x33,0x3f,
0x56,0x6f,0x80,0x86,0x7e,0x6f,0x61,0x58,0x54,0x53,0x4d,0x43,0x37,0x33,0x3a,0x4e,
0x68,0x7e,0x87,0x82,0x6f,0x5d,0x55,0x58,0x64,0x72,0x7b,0x7b,0x74,0x6b,0x63,0x5f,
0x5d,0x5c,0x55,0x4c,0x40,0x34,0x2e,0x2f,0x31,0x39,0x3f,0x44,0x45,0x41,0x3c,0x38,
0x33,0x31,0x2f,0x31,0x32,0x33,0x34,0x33,0x31,0x33,0x33,0x32,0x33,0x37,0x39,0x39,
0x3a,0x39,0x3a,0x3b,0x3b,0x3c,0x3c,0x3d,0x3c,0x3d,0x3b,0x39,0x3b,0x39,0x38,0x36,
0x32,0x33,0x31,0x3a,0x44,0x52,0x61,0x71,0x7d,0x8d,0x95,0x9a,0x9a,0x93,0x86,0x79,
0x68,0x58,0x4d,0x46,0x41,0x3d,0x39,0x36,0x35,0x38,0x3d,0x40,0x3f,0x3b,0x34,0x31,
0x2f,0x34,0x42,0x55,0x67,0x75,0x79,0x74,0x69,0x5f,0x59,0x5d,0x64,0x6d,0x73,0x78,
0x7b,0x80,0x89,0x94,0x9c,0x9f,0x96,0x84,0x6c,0x58,0x4f,0x55,0x62,0x74,0x82,0x86,
0x7e,0x6f,0x61,0x5a,0x5d,0x68,0x74,0x7a,0x79,0x6f,0x65,0x60,0x5d,0x5f,0x5e,0x59,
0x4e,0x40,0x32,0x2b,0x2b,0x31,0x38,0x3f,0x44,0x42,0x3c,0x35,0x31,0x2f,0x31,0x33,
0x34,0x35,0x36,0x36,0x35,0x36,0x35,0x34,0x37,0x38,0x37,0x3a,0x3a,0x3b,0x3c,0x38,
0x31,0x31,0x32,0x34,0x34,0x33,0x33,0x35,0x35,0x35,0x34,0x35,0x37,0x39,0x3b,0x3b,
// Line 17
0x37,0x3a,0x3a,0x39,0x39,0x3b,0x3b,0x3b,0x3a,0x38,0x37,0x38,0x37,0x39,0x3a,0x3a,
0x39,0x3a,0x3c,0x3b,0x3a,0x3a,0x3a,0x38,0x38,0x37,0x37,0x37,0x37,0x36,0x37,0x38,
0x38,0x39,0x37,0x36,0x36,0x37,0x38,0x37,0x36,0x35,0x34,0x34,0x34,0x38,0x3a,0x3a,
0x37,0x35,0x35,0x3b,0x47,0x59,0x6a,0x78,0x7e,0x7c,0x71,0x68,0x5f,0x5f,0x66,0x71,
0x7a,0x80,0x7d,0x75,0x6b,0x65,0x64,0x66,0x6a,0x6f,0x73,0x75,0x73,0x6e,0x67,0x62,
0x60,0x66,0x6d,0x76,0x7c,0x7e,0x79,0x70,0x66,0x61,0x61,0x68,0x70,0x79,0x7d,0x7d,
0x76,0x6d,0x65,0x5f,0x60,0x66,0x6d,0x74,0x78,0x77,0x73,0x6d,0x65,0x61,0x61,0x65,
0x6a,0x71,0x75,0x74,0x6f,0x69,0x63,0x62,0x63,0x6a,0x75,0x7d,0x7f,0x7d,0x7a,0x75,
0x6e,0x6a,0x69,0x6c,0x6f,0x72,0x72,0x75,0x75,0x7b,0x83,0x8f,0x9b,0xa7,0xad,0xac,
0xa4,0x97,0x89,0x79,0x6b,0x63,0x5b,0x56,0x50,0x4a,0x42,0x3d,0x3c,0x44,0x52,0x65,
0x77,0x86,0x90,0x96,0x97,0x99,0x99,0x9e,0x9f,0xa0,0x9c,0x91,0x82,0x75,0x63,0x58,
0x57,0x5e,0x69,0x75,0x7c,0x7d,0x79,0x71,0x67,0x64,0x67,0x6e,0x74,0x7c,0x7d,0x78,
0x6e,0x67,0x62,0x65,0x69,0x6f,0x72,0x74,0x74,0x77,0x7d,0x89,0x97,0xa4,0xae,0xb1,
0xad,0xa5,0x9e,0x99,0x99,0x9b,0x9d,0x99,0x8d,0x81,0x70,0x60,0x54,0x4d,0x47,0x3b,
0x36,0x34,0x38,0x49,0x5d,0x72,0x7f,0x82,0x77,0x6c,0x60,0x5a,0x57,0x55,0x4d,0x45,
0x3b,0x39,0x41,0x56,0x6b,0x80,0x8a,0x87,0x78,0x6a,0x60,0x5d,0x63,0x6c,0x72,0x78,
0x7d,0x83,0x8d,0x98,0xa2,0xa8,0xa9,0xa6,0x9e,0x95,0x89,0x7c,0x6d,0x60,0x54,0x4d,
0x47,0x46,0x43,0x3f,0x37,0x34,0x34,0x35,0x35,0x3e,0x46,0x51,0x5d,0x6b,0x78,0x89,
0x90,0x95,0x97,0x93,0x88,0x7d,0x6f,0x60,0x51,0x47,0x3f,0x3d,0x3e,0x44,0x4e,0x5d,
0x6c,0x7a,0x85,0x8c,0x91,0x98,0x97,0x91,0x89,0x7c,0x6b,0x5a,0x4a,0x41,0x3c,0x3d,
0x3c,0x3c,0x3a,0x38,0x36,0x3a,0x41,0x4e,0x5f,0x6f,0x78,0x7d,0x79,0x74,0x6d,0x66,
0x5f,0x58,0x4f,0x45,0x3c,0x38,0x3d,0x4b,0x5e,0x73,0x86,0x94,0x9a,0x9a,0x97,0x8f,
0x87,0x7f,0x72,0x62,0x53,0x47,0x3f,0x3e,0x3f,0x3f,0x3b,0x38,0x32,0x33,0x3c,0x4c,
0x5d,0x70,0x78,0x78,0x72,0x6a,0x63,0x5f,0x5e,0x59,0x4f,0x43,0x38,0x35,0x3d,0x50,
0x68,0x80,0x8d,0x8b,0x7a,0x66,0x5a,0x5b,0x65,0x75,0x82,0x85,0x7d,0x72,0x66,0x62,
0x62,0x64,0x5f,0x51,0x42,0x34,0x30,0x3b,0x50,0x69,0x7e,0x89,0x85,0x77,0x69,0x60,
0x5f,0x66,0x6d,0x74,0x7e,0x82,0x85,0x8f,0x98,0x9e,0x9d,0x92,0x7f,0x6c,0x5b,0x56,
0x5b,0x67,0x74,0x7e,0x80,0x7d,0x76,0x6e,0x66,0x61,0x59,0x4e,0x42,0x3b,0x39,0x3f,
0x4e,0x63,0x78,0x89,0x93,0x98,0x98,0x97,0x91,0x86,0x7d,0x6b,0x5a,0x50,0x49,0x44,
0x40,0x3d,0x3a,0x3a,0x3a,0x3c,0x3d,0x3f,0x3d,0x38,0x32,0x31,0x34,0x42,0x52,0x61,
0x70,0x7f,0x8a,0x93,0x98,0x9e,0xa2,0xa4,0xa4,0xa4,0xa2,0xa2,0xa2,0xa2,0xa0,0xa1,
0xa2,0xa4,0xa4,0xa3,0x9c,0x91,0x80,0x6e,0x5c,0x51,0x49,0x46,0x42,0x3e,0x39,0x35,
0x34,0x36,0x3a,0x40,0x41,0x3e,0x37,0x32,0x31,0x37,0x3f,0x4e,0x60,0x73,0x81,0x8e,
0x97,0x9c,0x9c,0x98,0x8d,0x7f,0x71,0x5f,0x51,0x47,0x3d,0x36,0x34,0x3a,0x45,0x58,
0x6b,0x7c,0x83,0x80,0x75,0x69,0x61,0x60,0x65,0x6d,0x75,0x79,0x7f,0x85,0x8c,0x95,
0x9d,0xa4,0xa7,0xa6,0xa2,0x97,0x90,0x82,0x72,0x65,0x5d,0x5e,0x66,0x72,0x7b,0x7f,
0x7b,0x73,0x6a,0x63,0x5e,0x5e,0x59,0x4e,0x3e,0x33,0x30,0x37,0x49,0x61,0x77,0x8a,
0x90,0x93,0x95,0x99,0x9c,0xa1,0xa2,0xa0,0x9e,0x9d,0x9c,0x9d,0x9e,0x9b,0x92,0x86,
0x78,0x6c,0x63,0x5e,0x5d,0x65,0x70,0x7c,0x82,0x8b,0x91,0x99,0x9b,0x98,0x8a,0x7d,
0x69,0x56,0x46,0x3c,0x36,0x39,0x3c,0x3d,0x3a,0x37,0x35,0x3a,0x41,0x4c,0x57,0x63,
0x6f,0x7c,0x88,0x91,0x95,0x99,0x96,0x8d,0x7d,0x6d,0x5d,0x51,0x47,0x3f,0x3b,0x3a,
0x3d,0x47,0x55,0x66,0x75,0x83,0x90,0x97,0x9a,0x98,0x90,0x87,0x7b,0x6c,0x5d,0x4e,
0x42,0x3b,0x36,0x35,0x3a,0x46,0x56,0x68,0x78,0x84,0x8f,0x98,0x99,0x97,0x91,0x89,
0x7d,0x6f,0x60,0x52,0x47,0x3f,0x39,0x3a,0x3f,0x49,0x55,0x65,0x74,0x81,0x8d,0x96,
0x99,0x99,0x93,0x8b,0x7e,0x6e,0x5d,0x4f,0x45,0x3f,0x3d,0x3c,0x3a,0x34,0x34,0x30,
0x30,0x39,0x44,0x52,0x61,0x6d,0x76,0x83,0x8e,0x9a,0xa0,0x9e,0x93,0x82,0x70,0x63,
0x5b,0x5c,0x62,0x6f,0x7b,0x85,0x8d,0x95,0x9b,0xa2,0xa7,0xa8,0xa6,0xa3,0x9e,0x9b,
0x9b,0x9c,0x9c,0x97,0x8e,0x85,0x76,0x68,0x58,0x4b,0x43,0x3d,0x39,0x37,0x34,0x34,
0x34,0x35,0x38,0x41,0x4f,0x61,0x71,0x7c,0x7d,0x78,0x6e,0x65,0x5e,0x5a,0x53,0x49,
0x3e,0x36,0x34,0x40,0x54,0x6c,0x7e,0x86,0x81,0x73,0x63,0x58,0x53,0x51,0x4c,0x42,
0x37,0x35,0x3d,0x53,0x6a,0x7d,0x85,0x7e,0x6f,0x60,0x56,0x52,0x4d,0x4c,0x44,0x3c,
0x36,0x3b,0x49,0x66,0x7c,0x8c,0x93,0x96,0x96,0x99,0x9b,0x9d,0xa0,0xa2,0xa0,0x9c,
0x99,0x9a,0x9e,0xa2,0xa3,0xa3,0xa2,0xa0,0x9e,0xa0,0xa0,0xa2,0xa2,0xa0,0x9e,0x9e,
0x9f,0xa0,0x9b,0x91,0x83,0x73,0x63,0x58,0x55,0x5f,0x6c,0x76,0x7d,0x7d,0x78,0x70,
0x69,0x63,0x5e,0x55,0x4a,0x40,0x37,0x36,0x3e,0x50,0x66,0x7a,0x8c,0x95,0x99,0x9c,
0x99,0x94,0x89,0x7b,0x6b,0x60,0x5d,0x60,0x68,0x74,0x7d,0x86,0x8d,0x93,0x98,0x9e,
0x9d,0x94,0x82,0x6c,0x58,0x50,0x54,0x63,0x75,0x83,0x85,0x7d,0x6f,0x63,0x61,0x66,
0x6f,0x78,0x7b,0x78,0x70,0x69,0x63,0x61,0x64,0x61,0x59,0x4d,0x3f,0x35,0x32,0x3a,
0x49,0x60,0x78,0x8c,0x97,0x9d,0x9c,0x98,0x91,0x88,0x7c,0x6e,0x5e,0x4f,0x44,0x3c,
0x39,0x38,0x3b,0x43,0x51,0x63,0x75,0x85,0x91,0x98,0x98,0x94,0x8c,0x83,0x78,0x69,
0x59,0x4d,0x40,0x38,0x33,0x34,0x35,0x37,0x38,0x3b,0x39,0x3e,0x3c,0x3a,0x39,0x38,
0x37,0x3a,0x39,0x39,0x39,0x3d,0x45,0x51,0x5f,0x6e,0x7d,0x8a,0x93,0x97,0x97,0x94,
0x8d,0x82,0x73,0x64,0x56,0x4a,0x42,0x3f,0x3d,0x40,0x46,0x51,0x5e,0x6f,0x7d,0x86,
0x8b,0x91,0x93,0x97,0x9e,0xa4,0xa4,0x9d,0x90,0x7e,0x6f,0x61,0x58,0x51,0x4a,0x43,
0x3d,0x38,0x35,0x33,0x34,0x37,0x39,0x3c,0x3c,0x3c,0x39,0x36,0x31,0x30,0x31,0x36,
0x39,0x3c,0x38,0x36,0x35,0x36,0x35,0x36,0x36,0x37,0x37,0x37,0x37,0x3a,0x3a,0x3a,
0x37,0x36,0x37,0x3b,0x3d,0x40,0x3d,0x38,0x32,0x30,0x3c,0x4b,0x5d,0x70,0x7b,0x7c,
0x76,0x6b,0x5e,0x58,0x54,0x51,0x4c,0x45,0x39,0x30,0x2e,0x34,0x3c,0x45,0x49,0x49,
0x43,0x3a,0x34,0x35,0x3e,0x51,0x67,0x78,0x7f,0x7d,0x71,0x63,0x5a,0x5d,0x66,0x73,
0x7b,0x7d,0x76,0x6d,0x63,0x5f,0x61,0x64,0x5e,0x52,0x41,0x33,0x2f,0x3c,0x50,0x6a,
0x80,0x8c,0x86,0x7a,0x6a,0x60,0x5f,0x63,0x68,0x6e,0x72,0x78,0x7d,0x86,0x91,0x9e,
0xa7,0xab,0xab,0xa8,0x9e,0x8f,0x7d,0x72,0x68,0x61,0x58,0x4e,0x44,0x39,0x31,0x33,
0x3f,0x56,0x6a,0x7d,0x80,0x7b,0x72,0x67,0x5d,0x59,0x52,0x49,0x40,0x37,0x34,0x3d,
0x4d,0x62,0x78,0x88,0x91,0x97,0x97,0x97,0x94,0x8d,0x80,0x6f,0x5f,0x5a,0x5d,0x6c,
0x78,0x81,0x83,0x7b,0x6e,0x62,0x5a,0x54,0x4e,0x47,0x3d,0x32,0x2b,0x2a,0x2d,0x39,
0x3d,0x42,0x44,0x3e,0x36,0x34,0x37,0x3f,0x4c,0x5d,0x6e,0x7d,0x86,0x8d,0x92,0x98,
0x9f,0xa5,0xa7,0xa4,0xa0,0x9e,0x9c,0x9e,0xa0,0xa0,0x9b,0x8e,0x7b,0x69,0x5d,0x5b,
0x5f,0x67,0x71,0x7a,0x80,0x87,0x90,0x9a,0xa2,0xa0,0x93,0x7e,0x68,0x5a,0x55,0x5a,
0x63,0x6f,0x79,0x82,0x89,0x94,0x9c,0xa0,0x9c,0x91,0x7e,0x6c,0x5c,0x54,0x57,0x61,
0x6d,0x7a,0x83,0x8b,0x8e,0x96,0x9b,0xa0,0xa3,0xa4,0xa0,0x9b,0x97,0x95,0x98,0x9d,
0xa1,0xa6,0xa6,0xa4,0xa2,0xa0,0xa0,0x9e,0x9f,0x9f,0x9d,0x9e,0xa0,0xa0,0xa1,0x9e,
0x9c,0x9e,0x9e,0x9f,0xa1,0xa3,0xa1,0x9e,0x99,0x99,0x99,0x9a,0x9b,0x9b,0x95,0x8c,
0x7e,0x70,0x62,0x59,0x53,0x4d,0x46,0x40,0x3d,0x3d,0x43,0x50,0x5f,0x72,0x80,0x89,
0x8d,0x90,0x93,0x97,0x9c,0xa0,0x9e,0x99,0x8e,0x7f,0x72,0x64,0x58,0x51,0x4c,0x47,
0x40,0x3b,0x36,0x34,0x34,0x37,0x3b,0x42,0x48,0x53,0x5f,0x6d,0x78,0x86,0x93,0x9a,
0x9a,0x93,0x88,0x7b,0x69,0x5a,0x4d,0x45,0x3c,0x36,0x35,0x3d,0x49,0x5d,0x70,0x7f,
0x85,0x83,0x76,0x67,0x59,0x50,0x4b,0x45,0x3c,0x36,0x31,0x2e,0x2e,0x31,0x37,0x41,
0x4d,0x5c,0x6a,0x76,0x7b,0x7a,0x71,0x67,0x5f,0x5f,0x68,0x74,0x7e,0x83,0x7d,0x70,
0x66,0x5e,0x5f,0x68,0x72,0x7b,0x7f,0x7b,0x72,0x6b,0x65,0x64,0x65,0x65,0x57,0x4d,
0x3e,0x38,0x36,0x3e,0x4e,0x67,0x79,0x83,0x7d,0x72,0x63,0x56,0x50,0x4d,0x4b,0x45,
0x39,0x30,0x2d,0x31,0x36,0x3f,0x43,0x41,0x3a,0x36,0x33,0x34,0x34,0x37,0x38,0x38,
0x36,0x36,0x36,0x39,0x37,0x39,0x39,0x3a,0x38,0x3b,0x39,0x37,0x36,0x37,0x38,0x3d,
0x3d,0x3b,0x39,0x39,0x3d,0x49,0x5a,0x6d,0x7e,0x85,0x80,0x73,0x65,0x5e,0x60,0x6b,
0x76,0x7c,0x7c,0x76,0x6b,0x65,0x61,0x62,0x61,0x5e,0x53,0x45,0x37,0x2e,0x2a,0x2e,
0x34,0x3b,0x3f,0x40,0x3c,0x38,0x34,0x32,0x32,0x35,0x38,0x39,0x38,0x38,0x37,0x36,
0x36,0x37,0x36,0x35,0x34,0x37,0x3a,0x3a,0x3a,0x3a,0x38,0x39,0x39,0x3a,0x39,0x3b,
// Line 18
0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x38,0x3b,0x3c,0x3b,0x38,0x35,0x35,0x35,0x3a,
0x3a,0x3a,0x36,0x31,0x2f,0x32,0x37,0x3b,0x3b,0x38,0x32,0x2d,0x2f,0x36,0x3f,0x45,
0x44,0x3b,0x2e,0x28,0x29,0x32,0x3d,0x44,0x43,0x39,0x2b,0x23,0x25,0x31,0x40,0x4c,
0x4a,0x40,0x31,0x25,0x23,0x2e,0x3f,0x4c,0x4c,0x41,0x2f,0x24,0x23,0x30,0x3f,0x4c,
0x4c,0x41,0x31,0x24,0x21,0x2f,0x3f,0x4a,0x4e,0x43,0x32,0x25,0x22,0x2d,0x3c,0x46,
0x46,0x3b,0x2c,0x23,0x22,0x2d,0x3d,0x4a,0x4d,0x44,0x33,0x28,0x26,0x31,0x41,0x4a,
0x49,0x40,0x32,0x2a,0x28,0x32,0x3f,0x4a,0x4d,0x44,0x33,0x28,0x26,0x31,0x41,0x4c,
0x4b,0x3f,0x2e,0x23,0x22,0x2d,0x3d,0x46,0x49,0x3d,0x2b,0x20,0x20,0x2b,0x3f,0x48,
0x46,0x3c,0x2e,0x26,0x27,0x33,0x43,0x4e,0x4e,0x44,0x34,0x2a,0x2a,0x36,0x45,0x52,
0x53,0x4d,0x41,0x38,0x3b,0x48,0x57,0x62,0x62,0x59,0x4a,0x3f,0x3e,0x49,0x58,0x62,
0x61,0x57,0x47,0x3b,0x3e,0x4b,0x58,0x64,0x64,0x5a,0x49,0x3d,0x3c,0x49,0x59,0x63,
0x5e,0x56,0x45,0x37,0x37,0x43,0x53,0x60,0x60,0x54,0x47,0x3c,0x3c,0x48,0x57,0x63,
0x63,0x59,0x48,0x3c,0x3b,0x46,0x57,0x64,0x64,0x5a,0x4a,0x3f,0x3c,0x4a,0x5a,0x64,
0x64,0x57,0x45,0x3a,0x38,0x45,0x54,0x60,0x5f,0x54,0x44,0x3a,0x3c,0x4b,0x5a,0x64,
0x63,0x58,0x48,0x3f,0x40,0x4d,0x5f,0x6c,0x6d,0x64,0x55,0x4c,0x4d,0x5d,0x6e,0x78,
0x77,0x6e,0x5e,0x54,0x54,0x61,0x71,0x7c,0x7a,0x70,0x5e,0x52,0x4f,0x5f,0x6d,0x78,
0x78,0x6d,0x5c,0x53,0x51,0x5c,0x6d,0x79,0x78,0x6d,0x5c,0x51,0x53,0x60,0x71,0x7e,
0x7c,0x71,0x5e,0x53,0x53,0x60,0x6e,0x76,0x74,0x6b,0x5a,0x4f,0x4f,0x5b,0x6b,0x77,
0x78,0x6d,0x5c,0x52,0x52,0x5e,0x6e,0x78,0x77,0x6e,0x5d,0x50,0x4f,0x5b,0x6c,0x7a,
0x7a,0x6e,0x5e,0x53,0x54,0x5e,0x6c,0x78,0x79,0x72,0x63,0x59,0x5e,0x69,0x7b,0x88,
0x8b,0x83,0x74,0x67,0x64,0x6f,0x7e,0x8b,0x8b,0x82,0x72,0x67,0x67,0x72,0x81,0x8e,
0x90,0x87,0x77,0x6a,0x67,0x72,0x81,0x8b,0x8d,0x85,0x77,0x69,0x6a,0x72,0x80,0x8d,
0x8e,0x83,0x74,0x69,0x67,0x72,0x81,0x8c,0x8d,0x81,0x70,0x66,0x67,0x74,0x84,0x8f,
0x8f,0x85,0x76,0x69,0x68,0x76,0x84,0x8d,0x8b,0x7e,0x70,0x67,0x67,0x72,0x81,0x8b,
0x8b,0x81,0x73,0x69,0x68,0x76,0x85,0x90,0x8e,0x84,0x76,0x6c,0x6c,0x77,0x86,0x91,
0x92,0x8b,0x7f,0x76,0x76,0x82,0x93,0xa0,0xa1,0x98,0x8a,0x7f,0x7e,0x87,0x97,0xa2,
0xa3,0x9a,0x89,0x7c,0x7c,0x87,0x96,0xa1,0xa5,0x9b,0x8b,0x81,0x81,0x8d,0x9e,0xa7,
0xa5,0x9b,0x89,0x7f,0x7f,0x8c,0x9a,0xa5,0xa4,0x99,0x89,0x7e,0x7e,0x8a,0x9a,0xa4,
0xa1,0x98,0x88,0x7e,0x7e,0x8a,0x99,0xa4,0xa2,0x98,0x89,0x7f,0x81,0x8e,0x9c,0xa5,
0xa5,0x9b,0x8b,0x7e,0x7c,0x88,0x97,0xa3,0xa3,0x98,0x88,0x7f,0x7d,0x89,0x98,0xa3,
0xa4,0x9b,0x8b,0x7f,0x81,0x8d,0x9e,0xac,0xad,0xa4,0x98,0x8e,0x90,0x9f,0xae,0xb8,
0xb8,0xae,0xa1,0x96,0x94,0x9f,0xad,0xb8,0xb7,0xac,0x9c,0x90,0x91,0xa0,0xb0,0xb9,
0xb9,0xae,0x9e,0x93,0x93,0xa0,0xaf,0xba,0xb7,0xab,0x9c,0x93,0x93,0xa0,0xaf,0xb9,
0xb8,0xac,0x9b,0x91,0x91,0x9d,0xac,0xb7,0xb6,0xa9,0x9b,0x90,0x90,0x9c,0xab,0xb5,
0xb6,0xaa,0x99,0x91,0x91,0x9e,0xac,0xb6,0xb2,0xa9,0x9b,0x91,0x93,0xa0,0xaf,0xb9,
0xb9,0xb0,0xa3,0x9a,0x9a,0xa3,0xae,0xb6,0xb5,0xae,0xa2,0x99,0x98,0x9e,0xa7,0xae,
0xae,0xaa,0xa6,0xa4,0xa4,0xa7,0xaa,0xac,0xaa,0xa9,0xa5,0xa2,0xa2,0xa4,0xa3,0xa6,
0xa7,0xa8,0xa8,0xaa,0xaa,0xaa,0xa8,0xa6,0xa2,0xa4,0xa6,0xa7,0xa7,0xa7,0xa6,0xa7,
0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa5,0xa3,0xa2,0xa5,0xaa,0xab,0xa7,0xa4,0xa4,0xa5,
0xa5,0xa4,0xa2,0xa2,0xa2,0xa4,0xa2,0xa2,0xa3,0xa7,0xa8,0xa9,0xa7,0xa7,0xa6,0xa5,
0xa5,0xa5,0xa7,0xa8,0xa7,0xa5,0xa3,0xa2,0xa2,0xa2,0xa3,0xa4,0xa1,0x9e,0x98,0x94,
0x90,0x8b,0x80,0x75,0x68,0x5e,0x53,0x48,0x40,0x3d,0x3a,0x38,0x35,0x36,0x36,0x38,
0x37,0x37,0x38,0x39,0x38,0x39,0x37,0x36,0x37,0x38,0x38,0x3a,0x38,0x39,0x38,0x39,
0x39,0x39,0x38,0x3a,0x3b,0x3d,0x3c,0x3c,0x3c,0x3c,0x3b,0x3b,0x39,0x38,0x37,0x36,
0x34,0x36,0x36,0x37,0x37,0x37,0x34,0x34,0x34,0x36,0x37,0x3c,0x38,0x37,0x37,0x38,
0x36,0x37,0x38,0x39,0x38,0x38,0x37,0x36,0x36,0x35,0x35,0x38,0x38,0x3a,0x3a,0x3a,
0x38,0x38,0x38,0x37,0x37,0x38,0x38,0x3a,0x38,0x38,0x38,0x38,0x37,0x38,0x3a,0x3a,
0x38,0x37,0x35,0x34,0x33,0x33,0x34,0x37,0x38,0x38,0x36,0x36,0x38,0x38,0x38,0x37,
0x36,0x37,0x35,0x32,0x31,0x32,0x3b,0x4c,0x60,0x77,0x8e,0x9d,0xa0,0x9c,0x8f,0x81,
0x72,0x67,0x5c,0x52,0x46,0x3b,0x31,0x2f,0x31,0x36,0x3d,0x43,0x42,0x3e,0x36,0x31,
0x2e,0x2f,0x31,0x33,0x33,0x35,0x36,0x38,0x36,0x35,0x36,0x35,0x32,0x35,0x36,0x37,
0x39,0x3a,0x38,0x38,0x37,0x35,0x32,0x36,0x36,0x38,0x3a,0x3a,0x36,0x31,0x2e,0x2f,
0x37,0x3f,0x44,0x44,0x3e,0x37,0x33,0x38,0x42,0x4c,0x54,0x53,0x49,0x3e,0x38,0x40,
0x53,0x69,0x77,0x76,0x66,0x52,0x47,0x4e,0x62,0x7f,0x8f,0x8b,0x75,0x59,0x48,0x4f,
0x6b,0x8d,0xa0,0x9b,0x7f,0x5e,0x4c,0x53,0x70,0x93,0xa5,0x9f,0x82,0x60,0x4c,0x54,
0x70,0x8e,0x9c,0x93,0x77,0x59,0x49,0x50,0x65,0x7e,0x88,0x7e,0x66,0x4e,0x41,0x46,
0x54,0x62,0x65,0x5c,0x4d,0x40,0x3c,0x3f,0x43,0x4c,0x4c,0x47,0x40,0x3b,0x38,0x3b,
0x3c,0x3c,0x3c,0x3c,0x3a,0x3a,0x38,0x37,0x35,0x34,0x34,0x33,0x33,0x35,0x35,0x38,
0x36,0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x39,0x37,0x3b,
0x38,0x36,0x35,0x34,0x33,0x35,0x34,0x33,0x33,0x36,0x37,0x37,0x38,0x36,0x35,0x36,
0x36,0x35,0x38,0x37,0x36,0x37,0x37,0x36,0x36,0x38,0x39,0x3c,0x3c,0x3b,0x3a,0x39,
0x38,0x36,0x36,0x37,0x38,0x38,0x37,0x35,0x34,0x33,0x33,0x36,0x36,0x37,0x38,0x38,
0x38,0x37,0x35,0x33,0x34,0x35,0x36,0x38,0x3d,0x41,0x46,0x52,0x5f,0x6f,0x80,0x90,
0x9c,0xaa,0xb2,0xb9,0xbc,0xc0,0xc1,0xc1,0xc0,0xc0,0xbf,0xbe,0xbd,0xbd,0xbf,0xc0,
0xc1,0xc2,0xc2,0xc2,0xc3,0xc3,0xc3,0xc3,0xc1,0xc1,0xc0,0xc0,0xbf,0xbf,0xbe,0xbd,
0xbb,0xb9,0xb8,0xb9,0xb9,0xbb,0xbd,0xbf,0xc0,0xc1,0xbf,0xc1,0xbf,0xc0,0xc0,0xc1,
0xbd,0xbf,0xbb,0xba,0xbb,0xbe,0xbf,0xc0,0xbe,0xbe,0xbd,0xbc,0xbb,0xbb,0xbb,0xbc,
0xbb,0xbb,0xbb,0xbd,0xbd,0xbd,0xbc,0xbb,0xb9,0xb9,0xb9,0xb9,0xba,0xbd,0xbd,0xbd,
0xbd,0xbd,0xbd,0xbd,0xbf,0xbf,0xbd,0xbd,0xbc,0xbc,0xbe,0xbf,0xbf,0xc1,0xc1,0xc0,
0xc0,0xc0,0xbf,0xbd,0xbb,0xbb,0xbb,0xbb,0xbd,0xbd,0xbf,0xbd,0xb9,0xbb,0xbc,0xbd,
0xbe,0xbd,0xbb,0xbd,0xbc,0xbc,0xbb,0xbd,0xbd,0xbe,0xbd,0xbd,0xbb,0xbd,0xbb,0xbb,
0xbb,0xbb,0xbb,0xba,0xb9,0xb9,0xb9,0xbb,0xbd,0xbf,0xbe,0xbd,0xbd,0xbf,0xbf,0xbe,
0xbd,0xbc,0xbb,0xbb,0xb9,0xb9,0xbb,0xb9,0xb8,0xb9,0xbb,0xbe,0xbd,0xbb,0xbb,0xbb,
0xb9,0xb9,0xba,0xbe,0xbf,0xbf,0xbd,0xbc,0xbb,0xbd,0xbd,0xbd,0xbe,0xbf,0xbf,0xbd,
0xbb,0xbd,0xbe,0xbf,0xbe,0xbe,0xbe,0xbd,0xbb,0xbd,0xbd,0xbe,0xbd,0xbd,0xbd,0xbf,
0xc0,0xc0,0xbe,0xbb,0xb9,0xba,0xbc,0xbf,0xc0,0xc1,0xbf,0xbc,0xbb,0xbd,0xbd,0xbf,
0xbf,0xbf,0xbd,0xbc,0xbc,0xbd,0xbb,0xbc,0xbd,0xbf,0xbe,0xbd,0xbb,0xbd,0xbc,0xbd,
0xbd,0xbe,0xbf,0xbd,0xbb,0xba,0xbb,0xbd,0xbe,0xc0,0xbe,0xbf,0xbe,0xbd,0xbd,0xbf,
0xbe,0xbd,0xbd,0xbd,0xbb,0xbb,0xbb,0xbb,0xbc,0xbe,0xbf,0xbe,0xbc,0xbc,0xbb,0xbd,
0xbf,0xc0,0xc1,0xc1,0xc0,0xc0,0xc0,0xc1,0xc0,0xbf,0xbd,0xbb,0xba,0xbb,0xbb,0xbb,
0xbb,0xbf,0xc0,0xc0,0xbe,0xbf,0xc0,0xc0,0xc0,0xc0,0xc0,0xbd,0xbc,0xbb,0xbb,0xbc,
0xbd,0xbd,0xbc,0xbb,0xb8,0xb9,0xb9,0xbd,0xc1,0xc0,0xbf,0xbf,0xbd,0xbe,0xbf,0xc0,
0xc0,0xc1,0xc1,0xc0,0xbd,0xbd,0xbc,0xbd,0xbf,0xbf,0xbf,0xc2,0xc2,0xc2,0xc1,0xc0,
0xbe,0xbd,0xbc,0xbd,0xbd,0xbd,0xbb,0xb9,0xb9,0xb9,0xba,0xbd,0xbf,0xc0,0xc1,0xc0,
0xbe,0xbf,0xbe,0xbf,0xc0,0xc0,0xbe,0xbd,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbc,0xbc,
0xbb,0xbb,0xbb,0xbd,0xbe,0xbf,0xbf,0xbf,0xbe,0xbe,0xbd,0xbb,0xb9,0xb7,0xb8,0xb8,
0xb7,0xb9,0xba,0xbb,0xbd,0xbd,0xbd,0xbf,0xbf,0xc0,0xbf,0xbf,0xbd,0xbb,0xbb,0xbc,
0xbd,0xbf,0xbf,0xbf,0xbf,0xbe,0xbd,0xbe,0xc0,0xc3,0xc3,0xc0,0xbf,0xbf,0xbe,0xbf,
0xbf,0xbf,0xbf,0xbd,0xbb,0xb9,0xba,0xbd,0xbe,0xbf,0xbe,0xbd,0xbc,0xbd,0xbc,0xbd,
0xbd,0xbc,0xbb,0xba,0xb9,0xba,0xb7,0xbc,0xbd,0xbd,0xbd,0xbc,0xba,0xbb,0xbc,0xbd,
0xbf,0xbf,0xbe,0xbf,0xbd,0xbb,0xbc,0xbc,0xbd,0xbc,0xbb,0xb9,0xb7,0xb9,0xba,0xbb,
0xbc,0xbd,0xbd,0xbf,0xbf,0xc1,0xc1,0xbf,0xbd,0xbd,0xbd,0xbe,0xbd,0xbf,0xbd,0xbb,
0xbb,0xbc,0xbb,0xbe,0xbd,0xbf,0xc0,0xc0,0xbf,0xbf,0xc0,0xbf,0xbf,0xbd,0xbd,0xbd,
0xbb,0xb9,0xb8,0xb9,0xba,0xbc,0xbd,0xbd,0xbb,0xbe,0xbf,0xbf,0xbd,0xbd,0xbc,0xbd,
0xbc,0xbc,0xbb,0xbc,0xbc,0xbb,0xbb,0xb9,0xb7,0xb4,0xae,0xa4,0x99,0x8c,0x81,0x75,
0x67,0x5a,0x4e,0x46,0x41,0x3d,0x37,0x32,0x31,0x35,0x37,0x37,0x36,0x36,0x38,0x38,
// Line 19
0x35,0x34,0x33,0x34,0x33,0x34,0x35,0x35,0x35,0x36,0x38,0x38,0x39,0x3a,0x39,0x38,
0x35,0x34,0x35,0x39,0x3b,0x3f,0x43,0x47,0x4a,0x50,0x53,0x59,0x5c,0x5e,0x5f,0x60,
0x62,0x65,0x64,0x65,0x63,0x63,0x64,0x65,0x64,0x64,0x62,0x60,0x5f,0x60,0x60,0x5d,
0x5f,0x5f,0x5f,0x61,0x60,0x61,0x65,0x65,0x64,0x64,0x63,0x61,0x60,0x5f,0x5f,0x5e,
0x5c,0x5c,0x5b,0x5c,0x5c,0x5c,0x5e,0x61,0x64,0x65,0x64,0x62,0x62,0x62,0x62,0x62,
0x61,0x61,0x61,0x61,0x5f,0x5f,0x61,0x62,0x62,0x63,0x61,0x61,0x64,0x63,0x63,0x65,
0x65,0x65,0x64,0x64,0x63,0x63,0x62,0x61,0x5d,0x5e,0x5d,0x5d,0x5e,0x5e,0x60,0x61,
0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x5f,0x5e,0x5e,0x5f,
0x5f,0x5f,0x5e,0x5d,0x5d,0x61,0x62,0x64,0x65,0x65,0x63,0x63,0x61,0x62,0x61,0x65,
0x64,0x64,0x63,0x63,0x63,0x65,0x65,0x65,0x64,0x65,0x65,0x66,0x63,0x63,0x63,0x64,
0x64,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x66,0x68,0x69,0x6d,0x6d,0x6d,0x6b,0x6a,
0x69,0x6b,0x6c,0x6e,0x6d,0x6f,0x6e,0x6d,0x6b,0x6d,0x6e,0x70,0x71,0x73,0x75,0x74,
0x73,0x74,0x76,0x78,0x7a,0x7d,0x7e,0x7e,0x7d,0x7e,0x7e,0x80,0x81,0x83,0x83,0x82,
0x81,0x84,0x86,0x88,0x89,0x8a,0x8a,0x8c,0x8b,0x8c,0x8c,0x8d,0x8c,0x8e,0x8e,0x8e,
0x90,0x92,0x92,0x92,0x93,0x95,0x97,0x99,0x96,0x94,0x94,0x92,0x91,0x8e,0x8f,0x8e,
0x8d,0x8b,0x88,0x84,0x83,0x82,0x7f,0x7e,0x7a,0x78,0x76,0x72,0x6c,0x6a,0x66,0x63,
0x5e,0x5b,0x58,0x55,0x51,0x4c,0x49,0x47,0x42,0x3e,0x3c,0x39,0x36,0x34,0x30,0x2d,
0x2c,0x2b,0x28,0x28,0x28,0x2a,0x2b,0x2d,0x30,0x32,0x33,0x35,0x39,0x42,0x49,0x4f,
0x59,0x5c,0x61,0x69,0x6e,0x74,0x78,0x80,0x83,0x88,0x8b,0x8e,0x92,0x97,0x98,0x97,
0x96,0x95,0x93,0x91,0x8b,0x85,0x81,0x7c,0x77,0x6f,0x65,0x5c,0x53,0x4d,0x47,0x41,
0x3c,0x39,0x35,0x32,0x2e,0x2d,0x2d,0x2f,0x30,0x33,0x35,0x3a,0x3d,0x44,0x4b,0x55,
0x5d,0x68,0x6f,0x79,0x7f,0x84,0x8b,0x92,0x95,0x99,0x97,0x92,0x8e,0x89,0x83,0x7d,
0x74,0x6c,0x62,0x58,0x4d,0x45,0x3f,0x3a,0x34,0x31,0x2e,0x2c,0x2e,0x31,0x38,0x42,
0x49,0x51,0x56,0x5e,0x68,0x74,0x7f,0x88,0x8e,0x92,0x92,0x8e,0x8b,0x87,0x81,0x7a,
0x6e,0x63,0x59,0x4f,0x47,0x41,0x3b,0x37,0x34,0x35,0x35,0x36,0x3a,0x40,0x47,0x53,
0x5f,0x6d,0x7a,0x85,0x8a,0x8e,0x8e,0x8e,0x87,0x80,0x76,0x6d,0x62,0x56,0x49,0x42,
0x38,0x33,0x31,0x30,0x32,0x38,0x40,0x4a,0x55,0x63,0x71,0x7c,0x89,0x8f,0x91,0x91,
0x8a,0x7e,0x76,0x65,0x57,0x4d,0x42,0x3b,0x35,0x33,0x33,0x37,0x3c,0x46,0x52,0x60,
0x6e,0x7d,0x87,0x8c,0x8e,0x8d,0x88,0x7e,0x73,0x69,0x5c,0x4e,0x3f,0x35,0x30,0x31,
0x34,0x3b,0x45,0x51,0x60,0x71,0x7e,0x8a,0x92,0x94,0x90,0x88,0x7b,0x6d,0x5d,0x4f,
0x42,0x38,0x30,0x2e,0x2d,0x39,0x46,0x55,0x67,0x78,0x83,0x8e,0x8c,0x84,0x7a,0x6d,
0x61,0x55,0x49,0x3e,0x35,0x31,0x33,0x39,0x44,0x56,0x6b,0x7e,0x89,0x8c,0x89,0x81,
0x75,0x6c,0x60,0x54,0x47,0x3c,0x34,0x32,0x36,0x42,0x54,0x69,0x7a,0x86,0x8c,0x89,
0x81,0x78,0x69,0x59,0x4c,0x41,0x36,0x30,0x33,0x3b,0x4b,0x61,0x75,0x84,0x8b,0x89,
0x82,0x78,0x6b,0x5c,0x4d,0x40,0x36,0x32,0x34,0x40,0x51,0x65,0x74,0x80,0x84,0x80,
0x77,0x6e,0x5f,0x53,0x48,0x3e,0x38,0x3b,0x44,0x55,0x66,0x75,0x81,0x86,0x81,0x75,
0x67,0x5b,0x4e,0x42,0x3d,0x3c,0x42,0x51,0x61,0x72,0x80,0x86,0x84,0x7b,0x6c,0x5c,
0x4d,0x42,0x3a,0x3a,0x40,0x4c,0x5c,0x6e,0x7c,0x84,0x84,0x78,0x69,0x59,0x4c,0x43,
0x3f,0x41,0x49,0x5a,0x6a,0x75,0x7c,0x80,0x7d,0x6e,0x5d,0x4b,0x3f,0x40,0x45,0x4d,
0x58,0x67,0x74,0x7e,0x7e,0x79,0x6e,0x5f,0x50,0x45,0x40,0x45,0x4f,0x5e,0x6b,0x76,
0x7a,0x78,0x70,0x63,0x54,0x47,0x42,0x43,0x4b,0x5a,0x67,0x6f,0x73,0x75,0x70,0x65,
0x57,0x4e,0x4b,0x4e,0x53,0x5d,0x69,0x71,0x76,0x75,0x6d,0x63,0x57,0x4d,0x46,0x48,
0x50,0x5c,0x67,0x72,0x71,0x6c,0x65,0x5c,0x53,0x51,0x4f,0x53,0x5c,0x66,0x6d,0x71,
0x6f,0x68,0x5e,0x56,0x4e,0x4d,0x52,0x5d,0x67,0x6e,0x70,0x6d,0x64,0x5c,0x56,0x53,
0x52,0x56,0x5c,0x61,0x64,0x67,0x66,0x64,0x5f,0x5c,0x58,0x57,0x5c,0x61,0x66,0x6b,
0x66,0x60,0x5a,0x56,0x54,0x56,0x5c,0x62,0x65,0x66,0x63,0x5a,0x56,0x54,0x54,0x5c,
0x64,0x6a,0x6c,0x6b,0x66,0x61,0x59,0x56,0x58,0x5e,0x64,0x6b,0x6c,0x68,0x5f,0x57,
0x4f,0x4d,0x53,0x5d,0x66,0x6e,0x6d,0x68,0x5e,0x55,0x4e,0x51,0x59,0x64,0x6e,0x72,
0x6f,0x64,0x55,0x49,0x44,0x4b,0x59,0x68,0x75,0x78,0x71,0x64,0x53,0x48,0x48,0x54,
0x64,0x75,0x7d,0x7a,0x68,0x56,0x46,0x41,0x49,0x5d,0x70,0x7c,0x7a,0x6c,0x58,0x44,
0x3c,0x45,0x59,0x6f,0x7d,0x7f,0x72,0x5a,0x42,0x37,0x40,0x58,0x71,0x81,0x82,0x73,
0x5a,0x45,0x39,0x43,0x5c,0x77,0x85,0x84,0x71,0x56,0x3c,0x3a,0x46,0x61,0x7b,0x89,
0x7f,0x6c,0x4c,0x38,0x39,0x4e,0x6a,0x80,0x85,0x78,0x5d,0x43,0x38,0x43,0x5d,0x78,
0x86,0x83,0x6d,0x4d,0x36,0x38,0x4d,0x6d,0x84,0x89,0x78,0x59,0x3e,0x38,0x48,0x67,
0x80,0x87,0x77,0x59,0x3c,0x30,0x3a,0x5b,0x77,0x84,0x7c,0x61,0x43,0x38,0x3f,0x5a,
0x78,0x86,0x7d,0x63,0x45,0x35,0x3f,0x5c,0x7a,0x89,0x80,0x65,0x47,0x3b,0x44,0x5d,
0x79,0x87,0x7c,0x61,0x45,0x3d,0x4a,0x64,0x7b,0x82,0x74,0x58,0x3f,0x3a,0x4c,0x66,
0x7c,0x7f,0x6c,0x52,0x40,0x45,0x5c,0x78,0x85,0x7e,0x65,0x4b,0x3d,0x47,0x60,0x74,
0x7b,0x6c,0x53,0x42,0x42,0x56,0x71,0x80,0x7a,0x66,0x4f,0x46,0x51,0x68,0x7a,0x7c,
0x6b,0x54,0x45,0x47,0x58,0x6b,0x76,0x70,0x5d,0x4c,0x4a,0x57,0x6b,0x78,0x75,0x64,
0x51,0x49,0x51,0x63,0x72,0x74,0x68,0x56,0x4d,0x55,0x65,0x73,0x76,0x6d,0x5c,0x51,
0x51,0x5e,0x6d,0x72,0x6b,0x5d,0x51,0x51,0x5b,0x68,0x6e,0x69,0x5c,0x51,0x4f,0x5a,
0x66,0x6d,0x6c,0x62,0x56,0x54,0x5b,0x67,0x6f,0x6e,0x65,0x5a,0x58,0x5d,0x64,0x6c,
0x6a,0x63,0x5b,0x56,0x59,0x62,0x69,0x69,0x62,0x5d,0x59,0x5e,0x67,0x6c,0x6a,0x63,
0x58,0x55,0x5a,0x62,0x68,0x69,0x64,0x5d,0x59,0x5b,0x61,0x67,0x68,0x65,0x5f,0x5c,
0x5d,0x60,0x65,0x64,0x5f,0x5f,0x5e,0x60,0x63,0x65,0x61,0x5f,0x5d,0x5f,0x61,0x66,
0x65,0x65,0x61,0x5d,0x5d,0x62,0x66,0x67,0x65,0x61,0x5d,0x5d,0x5e,0x64,0x67,0x65,
0x61,0x60,0x5f,0x60,0x62,0x65,0x65,0x63,0x5f,0x5e,0x5e,0x61,0x61,0x60,0x5e,0x5e,
0x5e,0x61,0x61,0x61,0x5f,0x60,0x5e,0x60,0x61,0x63,0x62,0x60,0x5c,0x5c,0x5e,0x61,
0x61,0x62,0x61,0x62,0x62,0x63,0x64,0x65,0x63,0x63,0x61,0x61,0x62,0x64,0x63,0x61,
0x5e,0x5f,0x5f,0x60,0x61,0x61,0x60,0x60,0x5e,0x61,0x61,0x65,0x64,0x64,0x63,0x63,
0x62,0x63,0x63,0x62,0x61,0x61,0x5e,0x5f,0x5f,0x61,0x62,0x61,0x60,0x5f,0x5e,0x5f,
0x61,0x62,0x63,0x63,0x62,0x5f,0x5d,0x5c,0x5d,0x5f,0x61,0x61,0x5f,0x60,0x60,0x60,
0x60,0x61,0x62,0x62,0x61,0x61,0x5f,0x61,0x5e,0x5e,0x61,0x61,0x5f,0x5e,0x5d,0x5d,
0x60,0x61,0x62,0x62,0x63,0x61,0x61,0x62,0x62,0x64,0x64,0x61,0x60,0x61,0x63,0x63,
0x61,0x61,0x5f,0x61,0x61,0x62,0x62,0x61,0x5f,0x60,0x61,0x64,0x66,0x69,0x68,0x64,
0x60,0x5f,0x60,0x62,0x61,0x61,0x60,0x5f,0x5e,0x5d,0x5d,0x60,0x63,0x64,0x62,0x5e,
0x5e,0x5d,0x5d,0x60,0x62,0x63,0x64,0x61,0x60,0x61,0x61,0x61,0x61,0x64,0x63,0x62,
0x61,0x63,0x64,0x65,0x65,0x65,0x64,0x63,0x63,0x64,0x64,0x64,0x64,0x62,0x60,0x60,
0x60,0x62,0x64,0x65,0x64,0x63,0x61,0x5e,0x5d,0x5f,0x60,0x61,0x60,0x5f,0x5e,0x5f,
0x5f,0x60,0x62,0x64,0x63,0x64,0x64,0x63,0x5f,0x60,0x5f,0x60,0x61,0x63,0x61,0x61,
0x5e,0x5e,0x5f,0x61,0x60,0x61,0x60,0x5f,0x5f,0x61,0x62,0x63,0x62,0x61,0x60,0x60,
0x5f,0x60,0x61,0x61,0x5e,0x5e,0x5c,0x5d,0x5f,0x61,0x61,0x61,0x5e,0x5e,0x5c,0x60,
0x61,0x63,0x64,0x63,0x61,0x61,0x60,0x5e,0x5e,0x5f,0x5d,0x5d,0x5d,0x5e,0x60,0x61,
0x60,0x5d,0x5f,0x5f,0x5f,0x62,0x64,0x64,0x64,0x5f,0x5e,0x60,0x61,0x61,0x61,0x5f,
0x5e,0x5e,0x5e,0x5e,0x5f,0x61,0x61,0x61,0x61,0x62,0x61,0x61,0x5f,0x5f,0x60,0x60,
0x5e,0x5e,0x5e,0x5d,0x5e,0x60,0x61,0x63,0x63,0x61,0x60,0x62,0x63,0x64,0x65,0x63,
0x5d,0x5d,0x5c,0x5c,0x5b,0x5d,0x5c,0x5e,0x5d,0x5f,0x60,0x62,0x63,0x64,0x64,0x65,
0x65,0x65,0x64,0x61,0x5f,0x5e,0x5d,0x5d,0x5d,0x5e,0x60,0x60,0x5f,0x5d,0x59,0x55,
0x51,0x4f,0x4a,0x46,0x42,0x3d,0x39,0x38,0x36,0x38,0x38,0x38,0x35,0x35,0x34,0x34,
0x32,0x36,0x36,0x36,0x37,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x35,0x33,0x33,
0x34,0x34,0x33,0x33,0x32,0x33,0x34,0x36,0x38,0x39,0x3a,0x3a,0x37,0x38,0x3a,0x3b,
0x38,0x35,0x32,0x32,0x31,0x33,0x31,0x35,0x36,0x36,0x36,0x36,0x36,0x39,0x39,0x38,
0x38,0x38,0x36,0x35,0x34,0x34,0x34,0x35,0x36,0x36,0x35,0x35,0x33,0x33,0x35,0x36,
0x36,0x36,0x36,0x38,0x38,0x37,0x36,0x35,0x34,0x35,0x35,0x35,0x35,0x35,0x34,0x32,
0x31,0x33,0x32,0x36,0x35,0x35,0x34,0x35,0x35,0x37,0x37,0x38,0x37,0x36,0x34,0x31,
// Line 20
0x35,0x36,0x36,0x38,0x38,0x38,0x35,0x34,0x32,0x33,0x33,0x33,0x33,0x36,0x35,0x35,
0x36,0x38,0x3a,0x3a,0x39,0x3a,0x3b,0x3b,0x3a,0x39,0x3c,0x41,0x48,0x54,0x60,0x6f,
0x7f,0x8f,0x9b,0xa7,0xb2,0xbc,0xc1,0xc1,0xbf,0xbe,0xbf,0xc0,0xbf,0xbe,0xbe,0xbe,
0xbf,0xbf,0xc0,0xc1,0xc1,0xc0,0xbf,0xbf,0xbf,0xbe,0xbe,0xbe,0xbe,0xbf,0xbe,0xbd,
0xbd,0xbd,0xbb,0xbb,0xb8,0xb9,0xbb,0xbc,0xbb,0xbe,0xc1,0xc3,0xc3,0xc3,0xc2,0xc2,
0xc3,0xc3,0xc1,0xc1,0xc1,0xbf,0xbf,0xbe,0xbb,0xbb,0xbb,0xbc,0xbd,0xbe,0xbd,0xbc,
0xba,0xb9,0xb9,0xbc,0xbd,0xbe,0xbf,0xbe,0xbd,0xbd,0xbb,0xbb,0xbc,0xbc,0xbd,0xbe,
0xbe,0xbe,0xbd,0xbc,0xbc,0xbd,0xbf,0xc1,0xbf,0xbf,0xbe,0xbe,0xbe,0xbe,0xbd,0xbe,
0xbb,0xbb,0xbb,0xbc,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xc1,0xc1,0xc3,0xc4,0xc3,0xc3,
0xc1,0xbf,0xbc,0xbd,0xba,0xb9,0xb9,0xba,0xb9,0xbb,0xba,0xbb,0xbe,0xbf,0xbd,0xbe,
0xbc,0xbb,0xbc,0xbb,0xba,0xbb,0xbc,0xbe,0xbe,0xc0,0xc1,0xc1,0xbf,0xbf,0xbf,0xc1,
0xc2,0xc3,0xc2,0xc0,0xbd,0xbc,0xbb,0xbc,0xbc,0xbc,0xbb,0xb9,0xb9,0xba,0xbb,0xbd,
0xbf,0xc1,0xc1,0xbd,0xb7,0xb1,0xa9,0xa1,0x9b,0x93,0x8a,0x83,0x7b,0x74,0x71,0x70,
0x70,0x6e,0x73,0x73,0x73,0x76,0x75,0x74,0x73,0x72,0x71,0x71,0x70,0x70,0x70,0x71,
0x70,0x71,0x72,0x74,0x75,0x73,0x72,0x71,0x73,0x75,0x75,0x73,0x70,0x6e,0x6e,0x6e,
0x6f,0x70,0x6f,0x6e,0x6e,0x6d,0x6d,0x6a,0x6f,0x70,0x70,0x70,0x70,0x70,0x71,0x71,
0x72,0x74,0x75,0x72,0x70,0x70,0x70,0x70,0x6f,0x73,0x76,0x7a,0x7e,0x84,0x89,0x8e,
0x91,0x96,0x97,0x98,0x98,0x97,0x95,0x93,0x91,0x8f,0x8d,0x8c,0x8b,0x89,0x84,0x80,
0x7c,0x7a,0x75,0x6d,0x69,0x64,0x5e,0x5a,0x56,0x53,0x50,0x4f,0x4a,0x49,0x47,0x47,
0x47,0x47,0x47,0x46,0x47,0x4a,0x4d,0x4f,0x4f,0x52,0x57,0x5d,0x61,0x66,0x6a,0x6e,
0x72,0x76,0x7b,0x7f,0x82,0x86,0x8a,0x8d,0x91,0x96,0x99,0x9b,0x9c,0x9c,0x99,0x97,
0x96,0x95,0x93,0x90,0x8c,0x8a,0x87,0x84,0x7f,0x7b,0x79,0x76,0x71,0x70,0x69,0x62,
0x5f,0x5b,0x55,0x50,0x4f,0x4e,0x4c,0x49,0x46,0x44,0x43,0x43,0x45,0x49,0x4c,0x4d,
0x4c,0x4d,0x50,0x56,0x59,0x5f,0x62,0x66,0x68,0x6c,0x6f,0x74,0x7a,0x80,0x83,0x87,
0x8b,0x90,0x93,0x98,0x99,0x99,0x99,0x9b,0x99,0x9a,0x98,0x94,0x91,0x8d,0x8a,0x86,
0x81,0x7e,0x7a,0x76,0x71,0x6d,0x6b,0x68,0x64,0x62,0x5e,0x59,0x57,0x54,0x52,0x50,
0x4c,0x4a,0x48,0x46,0x43,0x43,0x46,0x48,0x49,0x4c,0x4e,0x51,0x56,0x5c,0x5f,0x64,
0x67,0x6b,0x70,0x74,0x78,0x7b,0x82,0x86,0x89,0x8d,0x91,0x93,0x99,0x9b,0x9b,0x9e,
0x9d,0x9c,0x9a,0x99,0x97,0x95,0x91,0x8d,0x8a,0x84,0x7e,0x7a,0x78,0x76,0x72,0x6d,
0x68,0x64,0x61,0x5f,0x5b,0x56,0x51,0x4e,0x4e,0x4d,0x4b,0x49,0x48,0x49,0x49,0x49,
0x4a,0x4d,0x52,0x57,0x5c,0x64,0x69,0x6c,0x6e,0x6e,0x6e,0x6f,0x6f,0x70,0x71,0x71,
0x6e,0x6c,0x6d,0x70,0x73,0x75,0x74,0x75,0x75,0x75,0x73,0x73,0x73,0x73,0x74,0x73,
0x70,0x70,0x70,0x70,0x6f,0x71,0x71,0x71,0x73,0x73,0x71,0x73,0x74,0x74,0x73,0x71,
0x6e,0x71,0x71,0x73,0x72,0x71,0x6f,0x6e,0x6d,0x6e,0x70,0x71,0x71,0x71,0x72,0x72,
0x71,0x71,0x71,0x71,0x71,0x70,0x6e,0x6e,0x6d,0x6e,0x6e,0x71,0x72,0x73,0x76,0x74,
0x71,0x70,0x6d,0x68,0x65,0x61,0x5a,0x58,0x56,0x57,0x59,0x5c,0x61,0x68,0x71,0x7d,
0x86,0x8e,0x90,0x8f,0x8d,0x8a,0x84,0x7d,0x73,0x6a,0x62,0x5a,0x52,0x4e,0x4d,0x4f,
0x51,0x55,0x5b,0x61,0x6a,0x75,0x7e,0x87,0x8c,0x8f,0x91,0x91,0x8c,0x86,0x7e,0x75,
0x67,0x62,0x59,0x50,0x4c,0x4c,0x4c,0x4c,0x4a,0x4f,0x5a,0x67,0x73,0x7d,0x84,0x8a,
0x91,0x94,0x93,0x8d,0x86,0x7e,0x73,0x68,0x5c,0x53,0x4d,0x49,0x46,0x46,0x47,0x4d,
0x54,0x5e,0x67,0x73,0x7d,0x88,0x8f,0x95,0x94,0x8f,0x88,0x81,0x78,0x72,0x65,0x59,
0x51,0x4a,0x47,0x47,0x48,0x4d,0x53,0x59,0x60,0x69,0x73,0x80,0x8a,0x93,0x93,0x93,
0x8f,0x8a,0x80,0x79,0x6f,0x66,0x5a,0x50,0x48,0x47,0x47,0x4a,0x4d,0x53,0x59,0x61,
0x6b,0x76,0x80,0x8c,0x91,0x94,0x94,0x91,0x8a,0x81,0x76,0x6c,0x62,0x5a,0x51,0x49,
0x46,0x46,0x47,0x4b,0x52,0x5d,0x67,0x6f,0x74,0x7b,0x81,0x86,0x86,0x85,0x83,0x7f,
0x79,0x76,0x72,0x70,0x6e,0x6d,0x6d,0x6d,0x6e,0x70,0x71,0x71,0x71,0x71,0x6e,0x6c,
0x6a,0x6a,0x6d,0x70,0x71,0x6e,0x70,0x70,0x6e,0x6f,0x70,0x70,0x71,0x71,0x6f,0x6d,
0x6b,0x6b,0x6d,0x6e,0x6f,0x72,0x72,0x72,0x70,0x71,0x71,0x71,0x72,0x73,0x73,0x73,
0x70,0x6f,0x6f,0x6e,0x6d,0x6d,0x6e,0x6e,0x70,0x72,0x72,0x70,0x70,0x71,0x73,0x73,
0x71,0x71,0x72,0x6e,0x68,0x67,0x68,0x68,0x69,0x6b,0x6d,0x75,0x7d,0x84,0x86,0x84,
0x7b,0x71,0x68,0x60,0x58,0x56,0x55,0x59,0x61,0x6b,0x76,0x80,0x85,0x86,0x82,0x79,
0x6d,0x61,0x57,0x50,0x4d,0x53,0x5b,0x69,0x78,0x86,0x8d,0x8e,0x86,0x7e,0x71,0x67,
0x59,0x52,0x4e,0x50,0x50,0x5d,0x6a,0x79,0x86,0x8b,0x88,0x82,0x76,0x69,0x5e,0x55,
0x50,0x52,0x55,0x5c,0x6a,0x7a,0x86,0x8c,0x8d,0x89,0x7f,0x73,0x64,0x59,0x50,0x4d,
0x4e,0x59,0x67,0x78,0x84,0x8b,0x8c,0x89,0x81,0x77,0x68,0x5f,0x55,0x4e,0x4d,0x55,
0x60,0x71,0x81,0x89,0x8b,0x88,0x81,0x78,0x6b,0x5e,0x54,0x4f,0x4e,0x54,0x60,0x6e,
0x7e,0x8c,0x92,0x8f,0x86,0x7b,0x71,0x68,0x5f,0x59,0x58,0x57,0x59,0x61,0x69,0x72,
0x78,0x7b,0x7b,0x78,0x75,0x73,0x70,0x72,0x6f,0x6e,0x6e,0x70,0x71,0x71,0x70,0x6f,
0x6e,0x6c,0x6b,0x6c,0x6c,0x6d,0x6e,0x70,0x70,0x71,0x71,0x74,0x74,0x75,0x74,0x74,
0x75,0x74,0x72,0x72,0x70,0x71,0x6f,0x6e,0x6c,0x6e,0x72,0x73,0x71,0x6f,0x6e,0x6b,
0x6c,0x70,0x75,0x78,0x76,0x70,0x68,0x61,0x5e,0x5f,0x69,0x73,0x7d,0x81,0x7b,0x6e,
0x64,0x5e,0x60,0x68,0x73,0x7e,0x80,0x79,0x6c,0x62,0x5d,0x5f,0x67,0x72,0x7b,0x7f,
0x7b,0x73,0x68,0x5f,0x5d,0x61,0x6b,0x75,0x7d,0x7f,0x78,0x6c,0x61,0x5c,0x5f,0x66,
0x73,0x7b,0x7f,0x7c,0x71,0x65,0x5e,0x5d,0x62,0x70,0x7b,0x82,0x82,0x7b,0x6e,0x62,
0x5b,0x5d,0x64,0x6e,0x77,0x7e,0x7e,0x75,0x67,0x5d,0x59,0x5e,0x6a,0x77,0x7f,0x80,
0x78,0x6c,0x61,0x5a,0x59,0x63,0x6e,0x78,0x7c,0x7b,0x73,0x67,0x5c,0x58,0x5d,0x6b,
0x79,0x84,0x85,0x7c,0x6f,0x65,0x5f,0x62,0x6b,0x77,0x7c,0x7b,0x73,0x6b,0x64,0x65,
0x6a,0x72,0x79,0x7b,0x77,0x70,0x68,0x65,0x68,0x6e,0x74,0x78,0x78,0x75,0x71,0x6f,
0x6e,0x6c,0x6e,0x6c,0x69,0x6b,0x6a,0x6b,0x6f,0x70,0x70,0x70,0x70,0x70,0x70,0x6f,
0x6d,0x6d,0x6d,0x6f,0x6f,0x70,0x71,0x72,0x71,0x6f,0x6f,0x71,0x72,0x73,0x73,0x71,
0x70,0x71,0x6e,0x6c,0x6c,0x6f,0x71,0x71,0x73,0x74,0x70,0x6e,0x6a,0x6b,0x70,0x76,
0x79,0x7a,0x73,0x6a,0x61,0x5f,0x66,0x75,0x82,0x86,0x7b,0x6a,0x59,0x55,0x60,0x72,
0x82,0x88,0x7d,0x67,0x54,0x52,0x61,0x79,0x8c,0x90,0x82,0x69,0x53,0x4d,0x5f,0x76,
0x89,0x8f,0x81,0x69,0x56,0x51,0x5d,0x76,0x88,0x8f,0x7f,0x69,0x55,0x51,0x5e,0x75,
0x86,0x8a,0x7d,0x68,0x56,0x51,0x5e,0x75,0x88,0x8c,0x7f,0x6a,0x58,0x53,0x5d,0x72,
0x83,0x8a,0x7e,0x68,0x54,0x4f,0x5c,0x73,0x84,0x89,0x7e,0x69,0x55,0x50,0x5d,0x74,
0x86,0x8c,0x80,0x6a,0x57,0x52,0x5c,0x74,0x86,0x89,0x80,0x6a,0x56,0x54,0x5f,0x73,
0x85,0x8b,0x84,0x75,0x65,0x5e,0x62,0x6f,0x7a,0x7f,0x78,0x6e,0x65,0x64,0x68,0x6e,
0x73,0x76,0x75,0x72,0x6e,0x6e,0x6e,0x70,0x70,0x6f,0x6e,0x6e,0x6b,0x70,0x6e,0x6e,
0x6e,0x6d,0x6c,0x6e,0x6f,0x70,0x71,0x71,0x71,0x70,0x70,0x70,0x71,0x72,0x72,0x73,
0x72,0x71,0x70,0x6f,0x6d,0x6e,0x70,0x71,0x71,0x71,0x70,0x6f,0x6e,0x6f,0x71,0x72,
0x73,0x73,0x71,0x6d,0x6d,0x6e,0x72,0x72,0x70,0x6d,0x6b,0x6c,0x70,0x75,0x76,0x75,
0x72,0x6b,0x67,0x6c,0x72,0x77,0x75,0x70,0x67,0x64,0x63,0x69,0x71,0x77,0x75,0x6d,
0x66,0x65,0x6a,0x73,0x79,0x79,0x74,0x6c,0x65,0x67,0x6f,0x78,0x7b,0x76,0x6c,0x67,
0x69,0x71,0x79,0x7c,0x78,0x6f,0x68,0x68,0x6e,0x78,0x7d,0x7a,0x71,0x69,0x68,0x70,
0x77,0x7a,0x77,0x6e,0x67,0x67,0x6d,0x76,0x7a,0x77,0x6d,0x65,0x66,0x6e,0x77,0x7d,
0x79,0x6f,0x68,0x66,0x6a,0x75,0x79,0x76,0x6c,0x62,0x61,0x67,0x73,0x77,0x75,0x6e,
0x66,0x62,0x6b,0x75,0x79,0x77,0x6d,0x62,0x61,0x6b,0x77,0x7f,0x7b,0x70,0x62,0x5f,
0x66,0x75,0x7f,0x7f,0x75,0x67,0x5d,0x61,0x6f,0x7c,0x80,0x78,0x6a,0x61,0x60,0x67,
0x71,0x79,0x78,0x70,0x67,0x67,0x6b,0x72,0x77,0x76,0x6e,0x6a,0x68,0x6b,0x70,0x74,
0x71,0x6e,0x6a,0x6b,0x6e,0x73,0x73,0x71,0x6f,0x6f,0x6f,0x71,0x72,0x73,0x72,0x70,
0x6e,0x6e,0x6e,0x6f,0x6e,0x6c,0x6a,0x6b,0x6e,0x72,0x73,0x71,0x70,0x6f,0x70,0x6f,
0x6f,0x72,0x72,0x70,0x6f,0x6f,0x70,0x73,0x73,0x72,0x70,0x6e,0x6c,0x6e,0x70,0x71,
0x70,0x6e,0x6c,0x6e,0x6f,0x70,0x70,0x72,0x71,0x70,0x70,0x6e,0x6e,0x71,0x70,0x70,
0x70,0x72,0x74,0x73,0x71,0x70,0x70,0x71,0x70,0x70,0x6f,0x6d,0x68,0x66,0x5f,0x59,
0x53,0x4d,0x45,0x3f,0x3d,0x3b,0x37,0x36,0x33,0x30,0x32,0x35,0x37,0x39,0x38,0x38,
// Line 21
0x37,0x37,0x36,0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x38,
0x36,0x36,0x37,0x38,0x39,0x39,0x39,0x38,0x38,0x38,0x37,0x37,0x36,0x36,0x36,0x36,
0x36,0x37,0x37,0x38,0x39,0x39,0x38,0x39,0x3a,0x3d,0x3c,0x3c,0x3b,0x3e,0x41,0x43,
0x44,0x48,0x48,0x4b,0x4d,0x50,0x52,0x55,0x58,0x5b,0x5f,0x62,0x63,0x64,0x64,0x65,
0x66,0x68,0x69,0x68,0x68,0x68,0x64,0x64,0x63,0x64,0x63,0x5f,0x5a,0x58,0x56,0x54,
0x51,0x4f,0x4d,0x4c,0x4b,0x49,0x47,0x45,0x44,0x44,0x43,0x41,0x3e,0x3d,0x3b,0x39,
0x3b,0x3b,0x3c,0x3b,0x3e,0x40,0x40,0x42,0x45,0x47,0x4b,0x4c,0x4c,0x50,0x51,0x54,
0x57,0x5a,0x5b,0x5f,0x5f,0x63,0x65,0x66,0x66,0x67,0x68,0x68,0x65,0x65,0x64,0x63,
0x62,0x61,0x5f,0x5d,0x5a,0x57,0x57,0x57,0x55,0x52,0x4f,0x4d,0x4c,0x4b,0x49,0x47,
0x47,0x44,0x3f,0x3e,0x3c,0x3b,0x3c,0x3b,0x38,0x39,0x3a,0x3d,0x3d,0x41,0x43,0x45,
0x47,0x49,0x49,0x4b,0x4d,0x50,0x53,0x55,0x56,0x58,0x58,0x59,0x5c,0x60,0x64,0x67,
0x67,0x67,0x68,0x6a,0x6b,0x6c,0x6d,0x6b,0x69,0x67,0x63,0x62,0x5f,0x5d,0x59,0x57,
0x56,0x56,0x54,0x54,0x51,0x4d,0x49,0x46,0x41,0x45,0x44,0x42,0x40,0x3f,0x3e,0x40,
0x3e,0x3e,0x41,0x43,0x42,0x40,0x3e,0x3e,0x40,0x44,0x47,0x48,0x4b,0x4e,0x51,0x53,
0x54,0x57,0x5a,0x5b,0x59,0x5d,0x60,0x64,0x64,0x65,0x66,0x68,0x69,0x6b,0x6a,0x6b,
0x6a,0x68,0x65,0x62,0x60,0x62,0x60,0x5e,0x5a,0x59,0x57,0x56,0x51,0x4f,0x4d,0x4d,
0x4b,0x4a,0x48,0x46,0x41,0x40,0x3e,0x3e,0x3c,0x3a,0x38,0x38,0x38,0x3a,0x3e,0x40,
0x42,0x44,0x46,0x49,0x4b,0x4e,0x51,0x54,0x57,0x57,0x56,0x58,0x59,0x5e,0x63,0x65,
0x65,0x63,0x66,0x66,0x66,0x67,0x69,0x6a,0x6b,0x69,0x64,0x63,0x61,0x62,0x62,0x5d,
0x58,0x58,0x57,0x57,0x55,0x53,0x50,0x4f,0x4d,0x4b,0x47,0x46,0x45,0x46,0x44,0x3e,
0x3b,0x3c,0x3c,0x3c,0x3c,0x3e,0x40,0x3e,0x3c,0x3c,0x3e,0x44,0x48,0x4c,0x51,0x50,
0x4f,0x51,0x53,0x57,0x5a,0x5d,0x5d,0x5e,0x5e,0x60,0x60,0x63,0x65,0x68,0x6a,0x6a,
0x67,0x66,0x65,0x64,0x64,0x64,0x63,0x65,0x63,0x5e,0x5b,0x59,0x58,0x56,0x51,0x4d,
0x4b,0x4a,0x47,0x44,0x43,0x44,0x43,0x43,0x3f,0x3d,0x3e,0x3e,0x3c,0x3c,0x3c,0x3d,
0x3c,0x3d,0x3d,0x3e,0x42,0x46,0x47,0x4b,0x4a,0x4d,0x51,0x55,0x58,0x5e,0x60,0x61,
0x60,0x61,0x61,0x63,0x65,0x68,0x6a,0x6d,0x6c,0x6a,0x68,0x67,0x67,0x68,0x67,0x65,
0x63,0x5e,0x59,0x57,0x56,0x56,0x57,0x54,0x50,0x4c,0x49,0x47,0x45,0x44,0x41,0x3f,
0x3e,0x3c,0x39,0x3a,0x3a,0x3b,0x3b,0x3c,0x3c,0x3c,0x3b,0x3b,0x3b,0x3c,0x3c,0x3b,
0x3e,0x3d,0x3b,0x3b,0x3b,0x3d,0x40,0x42,0x41,0x3e,0x3d,0x3d,0x3b,0x3b,0x3b,0x3b,
0x3b,0x3b,0x39,0x38,0x38,0x3b,0x3e,0x3e,0x3b,0x39,0x37,0x36,0x36,0x37,0x39,0x3a,
0x39,0x39,0x39,0x3a,0x3a,0x3b,0x3a,0x39,0x36,0x37,0x37,0x39,0x3b,0x3c,0x3b,0x3b,
0x3b,0x3d,0x3d,0x3e,0x3b,0x3a,0x3a,0x39,0x39,0x3c,0x3c,0x3b,0x3b,0x3b,0x39,0x3b,
0x3d,0x3e,0x3d,0x3c,0x3b,0x3a,0x38,0x37,0x38,0x39,0x39,0x38,0x36,0x36,0x37,0x38,
0x37,0x37,0x38,0x39,0x3b,0x3e,0x43,0x4a,0x4f,0x55,0x58,0x5c,0x61,0x67,0x68,0x6b,
0x69,0x69,0x6b,0x6b,0x6b,0x6c,0x6b,0x6b,0x6b,0x6b,0x6a,0x6a,0x6a,0x6a,0x68,0x67,
0x66,0x66,0x66,0x67,0x67,0x69,0x6a,0x69,0x6a,0x6a,0x69,0x6b,0x6c,0x6e,0x6f,0x6d,
0x6a,0x68,0x67,0x67,0x67,0x69,0x68,0x68,0x68,0x69,0x69,0x6c,0x6d,0x6e,0x70,0x6f,
0x6c,0x6a,0x6a,0x6a,0x6a,0x6b,0x6b,0x69,0x67,0x67,0x67,0x6a,0x6a,0x6a,0x6b,0x6d,
0x6a,0x66,0x63,0x64,0x68,0x6b,0x6b,0x6a,0x69,0x6a,0x6b,0x6b,0x6a,0x6b,0x6e,0x70,
0x6d,0x6b,0x67,0x67,0x6a,0x6b,0x6b,0x6b,0x6b,0x6c,0x6d,0x6c,0x69,0x69,0x6a,0x6a,
0x68,0x69,0x67,0x65,0x65,0x62,0x5f,0x5c,0x57,0x53,0x4e,0x49,0x42,0x3e,0x3e,0x3e,
0x3c,0x3d,0x3a,0x38,0x39,0x38,0x37,0x37,0x36,0x36,0x37,0x38,0x37,0x39,0x3b,0x3b,
0x3b,0x3a,0x39,0x3b,0x3b,0x39,0x36,0x36,0x36,0x39,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,
0x3a,0x39,0x37,0x38,0x38,0x39,0x34,0x39,0x37,0x38,0x39,0x3b,0x39,0x39,0x38,0x37,
0x36,0x36,0x36,0x39,0x39,0x39,0x3a,0x3b,0x3b,0x39,0x38,0x38,0x38,0x39,0x39,0x39,
0x38,0x37,0x35,0x36,0x36,0x38,0x39,0x39,0x38,0x36,0x36,0x37,0x36,0x38,0x38,0x38,
0x39,0x3a,0x39,0x3b,0x3a,0x39,0x3b,0x3c,0x3b,0x3a,0x39,0x36,0x36,0x37,0x39,0x39,
0x39,0x39,0x38,0x39,0x38,0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x36,0x35,0x36,0x37,
0x37,0x36,0x36,0x37,0x37,0x38,0x39,0x38,0x36,0x36,0x35,0x33,0x33,0x34,0x35,0x36,
0x36,0x36,0x36,0x37,0x37,0x36,0x36,0x34,0x33,0x34,0x34,0x34,0x35,0x37,0x36,0x36,
0x34,0x33,0x34,0x33,0x31,0x32,0x32,0x32,0x32,0x34,0x34,0x36,0x37,0x38,0x37,0x37,
0x36,0x36,0x38,0x39,0x38,0x38,0x39,0x3a,0x39,0x3a,0x3b,0x3c,0x3d,0x37,0x36,0x36,
0x37,0x37,0x36,0x34,0x31,0x33,0x34,0x35,0x35,0x37,0x34,0x34,0x35,0x38,0x38,0x39,
0x38,0x37,0x37,0x37,0x36,0x37,0x36,0x37,0x36,0x34,0x30,0x2f,0x32,0x36,0x37,0x38,
0x37,0x37,0x36,0x36,0x36,0x39,0x38,0x36,0x34,0x32,0x31,0x34,0x37,0x39,0x3a,0x3b,
0x3b,0x3c,0x3e,0x3e,0x3c,0x3d,0x3a,0x36,0x34,0x33,0x31,0x34,0x34,0x35,0x36,0x35,
0x33,0x32,0x32,0x32,0x34,0x36,0x38,0x37,0x35,0x34,0x33,0x34,0x35,0x38,0x39,0x36,
0x35,0x36,0x34,0x32,0x31,0x34,0x37,0x3b,0x3b,0x3b,0x39,0x39,0x39,0x39,0x3a,0x3c,
0x3b,0x3d,0x3d,0x3d,0x40,0x46,0x4c,0x51,0x55,0x59,0x5e,0x62,0x65,0x68,0x6b,0x6b,
0x6b,0x6c,0x6a,0x69,0x68,0x68,0x68,0x69,0x69,0x6a,0x6a,0x6a,0x6a,0x6b,0x6b,0x6a,
0x69,0x69,0x68,0x67,0x68,0x6a,0x6a,0x6b,0x68,0x67,0x67,0x66,0x66,0x67,0x67,0x67,
0x67,0x67,0x69,0x6a,0x69,0x6a,0x6c,0x6d,0x6c,0x6a,0x6a,0x69,0x69,0x6b,0x6b,0x6b,
0x69,0x68,0x67,0x69,0x6a,0x6a,0x69,0x69,0x68,0x69,0x6a,0x6a,0x6b,0x6e,0x6b,0x67,
0x64,0x66,0x66,0x67,0x66,0x67,0x67,0x67,0x67,0x67,0x68,0x69,0x69,0x6a,0x6b,0x6b,
0x6a,0x6a,0x69,0x6a,0x6a,0x6a,0x6b,0x6c,0x6b,0x6a,0x69,0x69,0x69,0x6a,0x69,0x68,
0x67,0x65,0x62,0x60,0x5e,0x5c,0x5b,0x56,0x4f,0x49,0x43,0x3e,0x3c,0x3b,0x3b,0x39,
0x38,0x38,0x37,0x39,0x3b,0x3c,0x3c,0x3a,0x36,0x36,0x37,0x38,0x39,0x39,0x39,0x39,
0x38,0x37,0x36,0x38,0x37,0x38,0x39,0x39,0x38,0x3b,0x39,0x38,0x39,0x3b,0x3d,0x3f,
0x3e,0x3c,0x39,0x37,0x35,0x36,0x39,0x3a,0x39,0x37,0x36,0x36,0x36,0x38,0x38,0x3b,
0x3b,0x3b,0x39,0x37,0x36,0x36,0x36,0x38,0x38,0x38,0x39,0x39,0x38,0x39,0x39,0x3b,
0x3b,0x3a,0x3c,0x3b,0x39,0x3b,0x39,0x37,0x38,0x39,0x38,0x38,0x39,0x3a,0x3b,0x39,
0x38,0x36,0x36,0x36,0x35,0x38,0x39,0x39,0x38,0x36,0x35,0x37,0x39,0x3b,0x3a,0x3a,
0x39,0x38,0x36,0x36,0x39,0x3d,0x3f,0x40,0x42,0x47,0x4d,0x53,0x56,0x5a,0x60,0x63,
0x63,0x63,0x65,0x67,0x68,0x69,0x6a,0x6a,0x6a,0x69,0x69,0x6a,0x6b,0x6c,0x6c,0x6b,
0x69,0x6a,0x6a,0x6a,0x6a,0x6b,0x6a,0x6b,0x6c,0x6d,0x6b,0x6c,0x6a,0x68,0x67,0x68,
0x68,0x69,0x67,0x65,0x65,0x65,0x65,0x65,0x67,0x69,0x6a,0x6a,0x68,0x66,0x63,0x5f,
0x5b,0x58,0x52,0x4c,0x46,0x41,0x3d,0x3d,0x3c,0x3c,0x3d,0x3e,0x3e,0x3e,0x3e,0x3e,
0x3d,0x3c,0x39,0x37,0x36,0x38,0x39,0x3a,0x39,0x39,0x3b,0x3d,0x3e,0x3d,0x3d,0x3d,
0x3b,0x39,0x35,0x34,0x34,0x36,0x36,0x35,0x34,0x34,0x35,0x35,0x35,0x39,0x3b,0x3c,
0x3a,0x39,0x36,0x37,0x37,0x39,0x39,0x3c,0x40,0x42,0x46,0x4b,0x53,0x5c,0x60,0x63,
0x64,0x67,0x67,0x66,0x64,0x63,0x63,0x63,0x62,0x63,0x64,0x66,0x67,0x6a,0x6a,0x6b,
0x6b,0x6b,0x6b,0x6f,0x71,0x70,0x6d,0x6c,0x6a,0x6a,0x69,0x69,0x69,0x6d,0x6a,0x67,
0x68,0x69,0x69,0x6a,0x69,0x69,0x68,0x68,0x67,0x65,0x67,0x67,0x67,0x69,0x69,0x65,
0x62,0x5c,0x55,0x51,0x4d,0x4c,0x48,0x44,0x3e,0x3a,0x39,0x39,0x3a,0x3c,0x3d,0x3c,
0x39,0x38,0x37,0x37,0x37,0x38,0x39,0x3b,0x3a,0x39,0x37,0x34,0x36,0x38,0x3a,0x39,
0x39,0x38,0x36,0x34,0x34,0x34,0x39,0x3b,0x38,0x36,0x33,0x33,0x35,0x39,0x3b,0x3e,
0x40,0x40,0x3a,0x39,0x39,0x3b,0x3d,0x3e,0x3c,0x3e,0x3e,0x43,0x48,0x4f,0x55,0x5c,
0x5f,0x63,0x66,0x67,0x67,0x67,0x67,0x68,0x68,0x68,0x66,0x67,0x68,0x67,0x66,0x68,
0x67,0x69,0x69,0x69,0x68,0x6a,0x6c,0x6c,0x6b,0x6b,0x6a,0x6c,0x6d,0x6d,0x69,0x68,
0x68,0x69,0x6a,0x6a,0x6a,0x6b,0x69,0x67,0x67,0x68,0x67,0x67,0x66,0x64,0x63,0x64,
0x63,0x61,0x62,0x5c,0x56,0x54,0x51,0x4f,0x49,0x45,0x40,0x3d,0x3b,0x3b,0x3a,0x3d,
0x3d,0x3b,0x39,0x39,0x36,0x39,0x36,0x35,0x35,0x35,0x34,0x36,0x36,0x38,0x39,0x39,
0x39,0x3b,0x3b,0x39,0x39,0x3b,0x3a,0x38,0x36,0x34,0x34,0x36,0x37,0x38,0x39,0x38,
0x35,0x35,0x37,0x38,0x37,0x38,0x39,0x39,0x39,0x38,0x37,0x39,0x38,0x36,0x36,0x36,
0x36,0x36,0x34,0x32,0x32,0x34,0x36,0x36,0x35,0x36,0x36,0x36,0x34,0x33,0x34,0x34,
0x32,0x33,0x34,0x36,0x36,0x37,0x35,0x36,0x38,0x3b,0x3b,0x39,0x36,0x36,0x36,0x34,
//Field 1
// Line 10
0x39,0x38,0x37,0x38,0x39,0x38,0x37,0x35,0x35,0x37,0x39,0x39,0x38,0x36,0x35,0x34,
0x37,0x39,0x3d,0x3e,0x3e,0x3b,0x39,0x39,0x3b,0x3a,0x39,0x38,0x36,0x35,0x33,0x33,
0x36,0x39,0x39,0x39,0x38,0x38,0x3a,0x3b,0x3b,0x3b,0x3d,0x3b,0x3a,0x37,0x36,0x37,
0x39,0x3a,0x39,0x39,0x35,0x33,0x35,0x35,0x36,0x38,0x38,0x37,0x36,0x33,0x31,0x32,
0x35,0x38,0x39,0x39,0x38,0x35,0x34,0x34,0x35,0x38,0x39,0x39,0x38,0x36,0x35,0x35,
0x35,0x37,0x38,0x36,0x33,0x33,0x35,0x36,0x35,0x34,0x35,0x36,0x38,0x39,0x39,0x39,
0x37,0x34,0x34,0x35,0x37,0x39,0x39,0x37,0x38,0x37,0x39,0x39,0x3b,0x39,0x39,0x39,
0x38,0x35,0x38,0x38,0x39,0x38,0x37,0x38,0x39,0x39,0x38,0x39,0x39,0x39,0x38,0x39,
0x39,0x37,0x37,0x35,0x35,0x36,0x37,0x38,0x3b,0x3d,0x3b,0x39,0x37,0x36,0x37,0x39,
0x39,0x37,0x36,0x36,0x36,0x35,0x35,0x36,0x38,0x39,0x37,0x38,0x38,0x38,0x39,0x39,
0x39,0x39,0x3c,0x3d,0x3c,0x3a,0x39,0x36,0x36,0x36,0x37,0x37,0x38,0x38,0x39,0x3a,
0x3b,0x3b,0x3b,0x3a,0x3a,0x39,0x38,0x37,0x37,0x36,0x35,0x37,0x36,0x35,0x37,0x38,
0x37,0x37,0x36,0x37,0x37,0x36,0x35,0x35,0x36,0x37,0x36,0x38,0x38,0x38,0x39,0x3b,
0x3b,0x3c,0x3c,0x3a,0x39,0x39,0x3a,0x3a,0x3a,0x39,0x3b,0x3b,0x39,0x37,0x37,0x38,
0x38,0x38,0x36,0x34,0x35,0x35,0x36,0x38,0x3b,0x3c,0x39,0x39,0x36,0x36,0x38,0x39,
0x38,0x38,0x37,0x37,0x37,0x38,0x39,0x3c,0x3b,0x39,0x39,0x39,0x39,0x39,0x39,0x36,
0x35,0x35,0x37,0x35,0x38,0x36,0x36,0x37,0x37,0x36,0x37,0x38,0x38,0x39,0x39,0x39,
0x39,0x3a,0x3b,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x39,0x39,0x37,0x37,0x39,0x38,0x35,
0x35,0x37,0x39,0x38,0x38,0x37,0x37,0x37,0x36,0x35,0x36,0x38,0x3a,0x3d,0x3e,0x3b,
0x39,0x38,0x38,0x3a,0x3a,0x39,0x39,0x39,0x37,0x34,0x35,0x38,0x3a,0x39,0x38,0x36,
0x34,0x33,0x33,0x33,0x34,0x34,0x35,0x34,0x33,0x32,0x34,0x35,0x36,0x36,0x37,0x37,
0x38,0x38,0x37,0x39,0x39,0x37,0x37,0x37,0x37,0x39,0x3b,0x3b,0x3b,0x3a,0x39,0x3b,
0x3d,0x3d,0x3e,0x3c,0x39,0x36,0x36,0x35,0x34,0x35,0x36,0x35,0x33,0x31,0x33,0x36,
0x39,0x39,0x3a,0x3d,0x3e,0x3e,0x40,0x3d,0x3b,0x3b,0x39,0x38,0x39,0x3a,0x3b,0x3c,
0x3b,0x3a,0x3b,0x3d,0x3e,0x3d,0x3d,0x3d,0x3d,0x39,0x38,0x37,0x37,0x38,0x36,0x36,
0x35,0x35,0x36,0x36,0x36,0x36,0x38,0x39,0x3b,0x3b,0x3b,0x39,0x38,0x38,0x39,0x3d,
0x3d,0x3b,0x3b,0x3a,0x38,0x38,0x38,0x39,0x39,0x3c,0x3a,0x39,0x3a,0x3b,0x3a,0x3b,
0x38,0x38,0x39,0x3b,0x3b,0x3b,0x3c,0x39,0x38,0x37,0x39,0x3b,0x3c,0x3b,0x3b,0x39,
0x36,0x35,0x38,0x3b,0x3d,0x3e,0x3e,0x39,0x37,0x35,0x35,0x36,0x35,0x35,0x37,0x37,
0x36,0x37,0x37,0x37,0x37,0x36,0x37,0x38,0x3b,0x3b,0x39,0x37,0x36,0x35,0x38,0x39,
0x3a,0x39,0x39,0x38,0x36,0x35,0x38,0x3b,0x3d,0x3c,0x39,0x3a,0x39,0x38,0x3a,0x3b,
0x3a,0x3b,0x39,0x37,0x37,0x35,0x35,0x37,0x38,0x39,0x38,0x38,0x38,0x37,0x39,0x3d,
0x3f,0x42,0x3f,0x3d,0x3b,0x3b,0x3b,0x39,0x39,0x39,0x39,0x38,0x36,0x34,0x38,0x38,
0x39,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,0x39,0x38,0x37,0x37,0x37,0x38,0x37,0x36,0x37,
0x38,0x38,0x39,0x39,0x3b,0x3c,0x3a,0x39,0x38,0x38,0x3d,0x3d,0x3d,0x3b,0x39,0x36,
0x36,0x35,0x36,0x37,0x38,0x37,0x36,0x37,0x39,0x39,0x39,0x38,0x38,0x39,0x38,0x36,
0x35,0x35,0x36,0x36,0x35,0x37,0x35,0x39,0x38,0x35,0x35,0x34,0x33,0x37,0x3a,0x39,
0x38,0x38,0x39,0x38,0x38,0x37,0x38,0x38,0x39,0x37,0x37,0x35,0x35,0x38,0x39,0x38,
0x37,0x37,0x39,0x3b,0x3a,0x39,0x39,0x3a,0x3a,0x39,0x36,0x36,0x36,0x37,0x37,0x37,
0x37,0x35,0x39,0x38,0x36,0x33,0x35,0x38,0x39,0x38,0x37,0x35,0x35,0x37,0x39,0x38,
0x39,0x38,0x38,0x39,0x39,0x37,0x39,0x3b,0x3c,0x3b,0x39,0x39,0x39,0x39,0x39,0x39,
0x38,0x37,0x38,0x38,0x37,0x34,0x35,0x37,0x38,0x39,0x38,0x38,0x39,0x3a,0x3b,0x3b,
0x3c,0x3c,0x3d,0x3c,0x39,0x37,0x38,0x37,0x36,0x37,0x36,0x36,0x36,0x34,0x33,0x35,
0x37,0x38,0x38,0x38,0x35,0x32,0x33,0x35,0x38,0x39,0x3a,0x39,0x38,0x38,0x37,0x38,
0x3a,0x3b,0x3e,0x3d,0x39,0x36,0x35,0x35,0x37,0x37,0x38,0x36,0x35,0x31,0x31,0x33,
0x34,0x35,0x38,0x39,0x37,0x36,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x37,0x3a,
0x39,0x36,0x38,0x38,0x38,0x36,0x36,0x36,0x36,0x35,0x35,0x36,0x35,0x33,0x35,0x36,
0x37,0x36,0x36,0x36,0x36,0x38,0x38,0x39,0x3a,0x3b,0x3b,0x3b,0x3a,0x3b,0x3b,0x3a,
0x39,0x38,0x39,0x38,0x36,0x35,0x35,0x35,0x37,0x38,0x39,0x39,0x38,0x36,0x37,0x38,
0x38,0x38,0x37,0x36,0x35,0x35,0x34,0x35,0x36,0x38,0x38,0x39,0x37,0x36,0x37,0x37,
0x37,0x37,0x38,0x38,0x35,0x35,0x35,0x36,0x37,0x38,0x38,0x3a,0x37,0x32,0x33,0x35,
0x36,0x38,0x37,0x36,0x39,0x39,0x3a,0x39,0x38,0x37,0x38,0x39,0x38,0x37,0x38,0x39,
0x39,0x39,0x38,0x38,0x39,0x38,0x37,0x37,0x37,0x37,0x38,0x38,0x36,0x35,0x36,0x37,
0x38,0x37,0x37,0x36,0x36,0x36,0x36,0x39,0x35,0x33,0x34,0x35,0x36,0x36,0x37,0x37,
0x37,0x38,0x38,0x39,0x3d,0x3d,0x3d,0x3b,0x38,0x34,0x35,0x35,0x36,0x37,0x38,0x38,
0x34,0x31,0x32,0x34,0x37,0x38,0x38,0x39,0x37,0x34,0x35,0x35,0x37,0x38,0x38,0x37,
0x37,0x37,0x38,0x38,0x36,0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x38,0x38,0x38,
0x38,0x36,0x37,0x38,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x3a,0x3b,0x3b,0x39,0x38,
0x38,0x38,0x39,0x39,0x39,0x38,0x37,0x35,0x35,0x34,0x35,0x37,0x37,0x37,0x37,0x37,
0x37,0x37,0x35,0x35,0x34,0x33,0x35,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,
0x38,0x38,0x38,0x37,0x35,0x35,0x37,0x39,0x3b,0x3d,0x3d,0x3a,0x38,0x38,0x37,0x37,
0x35,0x34,0x36,0x37,0x36,0x34,0x36,0x38,0x39,0x37,0x35,0x35,0x37,0x37,0x36,0x35,
0x35,0x35,0x36,0x37,0x39,0x3a,0x3d,0x3d,0x3a,0x3a,0x39,0x39,0x3b,0x3b,0x3a,0x39,
0x38,0x37,0x38,0x39,0x39,0x37,0x35,0x34,0x35,0x36,0x38,0x36,0x39,0x38,0x37,0x38,
0x39,0x3b,0x3d,0x3d,0x3a,0x39,0x39,0x38,0x38,0x38,0x38,0x39,0x38,0x37,0x35,0x3a,
0x3b,0x3d,0x3e,0x3d,0x3c,0x3c,0x39,0x37,0x37,0x36,0x36,0x35,0x34,0x32,0x32,0x33,
0x35,0x35,0x37,0x38,0x39,0x38,0x38,0x39,0x3b,0x3a,0x38,0x39,0x39,0x39,0x39,0x39,
0x38,0x3a,0x3b,0x3c,0x3b,0x3d,0x3d,0x3d,0x3c,0x39,0x37,0x37,0x32,0x32,0x35,0x36,
0x35,0x33,0x35,0x35,0x35,0x36,0x38,0x39,0x3b,0x39,0x38,0x3a,0x3b,0x3d,0x3e,0x3d,
0x3b,0x39,0x37,0x35,0x34,0x33,0x33,0x33,0x34,0x34,0x35,0x36,0x37,0x38,0x39,0x39,
0x37,0x35,0x33,0x34,0x35,0x36,0x39,0x3a,0x38,0x37,0x37,0x39,0x3a,0x39,0x39,0x38,
0x38,0x39,0x38,0x38,0x39,0x3a,0x39,0x3a,0x39,0x38,0x36,0x35,0x32,0x33,0x36,0x38,
0x39,0x39,0x39,0x38,0x39,0x38,0x3a,0x3d,0x3c,0x3a,0x39,0x36,0x34,0x33,0x34,0x33,
0x33,0x35,0x36,0x36,0x37,0x37,0x37,0x39,0x3b,0x3b,0x3d,0x3b,0x38,0x39,0x3a,0x3b,
0x3b,0x38,0x36,0x35,0x36,0x38,0x39,0x3b,0x39,0x38,0x37,0x34,0x33,0x35,0x37,0x36,
0x34,0x31,0x31,0x31,0x32,0x34,0x37,0x38,0x38,0x36,0x36,0x36,0x37,0x38,0x39,0x39,
0x38,0x38,0x37,0x38,0x37,0x38,0x39,0x38,0x36,0x36,0x37,0x37,0x36,0x36,0x37,0x38,
0x3a,0x38,0x37,0x37,0x35,0x32,0x32,0x34,0x36,0x38,0x38,0x37,0x37,0x38,0x39,0x39,
0x3a,0x39,0x39,0x38,0x36,0x35,0x37,0x38,0x37,0x37,0x37,0x38,0x37,0x36,0x36,0x39,
0x3a,0x39,0x38,0x3b,0x38,0x38,0x39,0x3a,0x39,0x39,0x39,0x38,0x37,0x36,0x37,0x39,
0x38,0x36,0x36,0x37,0x37,0x35,0x38,0x36,0x37,0x39,0x3a,0x39,0x3c,0x39,0x39,0x39,
0x3a,0x39,0x38,0x37,0x35,0x33,0x35,0x35,0x35,0x35,0x36,0x35,0x36,0x36,0x38,0x38,
0x38,0x38,0x39,0x39,0x39,0x3a,0x39,0x39,0x37,0x37,0x39,0x39,0x39,0x39,0x39,0x3a,
0x39,0x38,0x39,0x38,0x37,0x37,0x37,0x37,0x36,0x36,0x35,0x35,0x37,0x39,0x39,0x39,
0x39,0x3a,0x3b,0x39,0x38,0x37,0x35,0x35,0x37,0x39,0x3a,0x3b,0x3a,0x39,0x39,0x39,
0x38,0x38,0x38,0x38,0x36,0x34,0x33,0x33,0x34,0x35,0x36,0x39,0x39,0x37,0x37,0x36,
0x35,0x35,0x37,0x39,0x39,0x3a,0x39,0x3b,0x3a,0x3a,0x39,0x3a,0x3b,0x3a,0x3b,0x3a,
0x39,0x37,0x35,0x34,0x35,0x35,0x36,0x35,0x34,0x33,0x33,0x34,0x34,0x33,0x34,0x33,
0x32,0x33,0x36,0x39,0x3b,0x3a,0x39,0x39,0x39,0x39,0x39,0x3c,0x3b,0x39,0x39,0x39,
0x39,0x3b,0x3d,0x3d,0x3b,0x38,0x37,0x36,0x36,0x35,0x35,0x35,0x36,0x37,0x36,0x35,
0x35,0x39,0x3b,0x39,0x38,0x35,0x35,0x36,0x36,0x35,0x36,0x35,0x33,0x34,0x35,0x35,
0x35,0x36,0x35,0x34,0x33,0x32,0x31,0x37,0x37,0x38,0x37,0x36,0x35,0x36,0x37,0x39,
0x3a,0x39,0x3b,0x3a,0x39,0x36,0x36,0x38,0x39,0x39,0x39,0x38,0x35,0x34,0x33,0x31,
0x32,0x33,0x34,0x36,0x37,0x38,0x38,0x38,0x37,0x35,0x37,0x38,0x37,0x37,0x36,0x34,
0x35,0x33,0x34,0x37,0x37,0x38,0x39,0x39,0x39,0x38,0x39,0x39,0x39,0x3a,0x3a,0x38,
0x35,0x32,0x31,0x33,0x33,0x34,0x37,0x37,0x35,0x35,0x36,0x38,0x37,0x36,0x35,0x33,
// Line 11
0x39,0x3a,0x39,0x38,0x37,0x36,0x34,0x34,0x35,0x37,0x38,0x38,0x38,0x38,0x37,0x37,
0x36,0x37,0x37,0x37,0x38,0x38,0x38,0x37,0x36,0x36,0x39,0x3a,0x3a,0x38,0x36,0x35,
0x36,0x37,0x38,0x37,0x37,0x36,0x35,0x35,0x36,0x38,0x3a,0x38,0x35,0x33,0x34,0x38,
0x3b,0x3d,0x3b,0x37,0x32,0x31,0x33,0x42,0x52,0x65,0x75,0x79,0x75,0x6c,0x61,0x58,
0x59,0x60,0x6b,0x73,0x77,0x75,0x6e,0x64,0x5c,0x59,0x5d,0x64,0x6c,0x70,0x71,0x6e,
0x68,0x60,0x5c,0x5d,0x62,0x69,0x6f,0x73,0x74,0x72,0x6b,0x61,0x5b,0x5c,0x5f,0x64,
0x6e,0x72,0x72,0x6f,0x68,0x61,0x5f,0x5f,0x62,0x66,0x6c,0x70,0x71,0x6e,0x67,0x5f,
0x59,0x55,0x59,0x63,0x6e,0x75,0x78,0x74,0x69,0x60,0x5b,0x5c,0x63,0x6c,0x74,0x78,
0x75,0x6f,0x68,0x61,0x5e,0x5e,0x64,0x68,0x6a,0x6e,0x6f,0x70,0x76,0x7f,0x8c,0x99,
0xa5,0xab,0xa9,0xa2,0x94,0x83,0x72,0x63,0x5a,0x56,0x52,0x4c,0x44,0x3b,0x36,0x38,
0x41,0x51,0x64,0x74,0x80,0x89,0x8e,0x91,0x94,0x98,0x9b,0x9b,0x9a,0x97,0x96,0x98,
0x9a,0x9a,0x97,0x8e,0x80,0x72,0x64,0x5a,0x52,0x4a,0x43,0x37,0x36,0x38,0x44,0x58,
0x6b,0x77,0x7b,0x75,0x69,0x5f,0x58,0x53,0x4e,0x44,0x38,0x2f,0x2e,0x39,0x4e,0x67,
0x7a,0x80,0x7d,0x72,0x64,0x57,0x4f,0x48,0x47,0x42,0x3c,0x35,0x2f,0x2d,0x32,0x39,
0x43,0x4f,0x5e,0x6b,0x71,0x72,0x6d,0x64,0x5f,0x59,0x54,0x51,0x49,0x3e,0x35,0x30,
0x35,0x46,0x5d,0x77,0x88,0x91,0x94,0x95,0x96,0x93,0x8b,0x7d,0x6b,0x59,0x52,0x56,
0x64,0x74,0x7b,0x78,0x70,0x65,0x5d,0x59,0x58,0x52,0x47,0x37,0x2c,0x29,0x39,0x4f,
0x69,0x7d,0x83,0x7d,0x6f,0x61,0x59,0x56,0x52,0x4a,0x41,0x38,0x35,0x3c,0x4f,0x68,
0x7c,0x85,0x7e,0x6e,0x5d,0x52,0x52,0x5a,0x65,0x70,0x74,0x71,0x69,0x60,0x5a,0x58,
0x59,0x59,0x52,0x44,0x37,0x2b,0x27,0x2c,0x35,0x3f,0x45,0x47,0x3f,0x37,0x33,0x34,
0x3d,0x52,0x65,0x74,0x7a,0x76,0x6c,0x64,0x5b,0x59,0x62,0x6e,0x7a,0x7e,0x79,0x6e,
0x64,0x5d,0x5c,0x5b,0x58,0x50,0x45,0x3b,0x2f,0x29,0x2d,0x36,0x40,0x46,0x45,0x3e,
0x35,0x2f,0x31,0x3f,0x54,0x68,0x77,0x80,0x7d,0x72,0x66,0x5c,0x59,0x5d,0x63,0x69,
0x6f,0x74,0x7c,0x86,0x91,0x9c,0xa6,0xac,0xad,0xa6,0x9f,0x98,0x97,0x9b,0x9e,0xa0,
0xa2,0xa2,0xa2,0x9f,0x9b,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0x9e,0x9e,0x9d,0x9d,
0x9e,0x9d,0x9e,0x9c,0x9b,0x98,0x99,0x9b,0x9d,0x9c,0x9d,0x9a,0x9b,0x9d,0x9f,0x9f,
0x9f,0x9e,0x9d,0x9d,0x9c,0x9c,0x9d,0x9e,0x9e,0x9f,0x9d,0x9b,0x9b,0x9c,0x9e,0x9f,
0xa0,0x9e,0x9d,0x9d,0x9c,0x9b,0x9c,0x9e,0x9f,0x9f,0x9e,0x9c,0x9a,0x9b,0x9c,0x9d,
0x9d,0x9b,0x9c,0x9c,0x9b,0x9a,0x9b,0x99,0x99,0x9a,0x9a,0x99,0x9c,0x9c,0x9c,0x9c,
0x9c,0x9e,0x9f,0xa1,0x9f,0x9f,0xa0,0xa0,0x9f,0x9f,0x9f,0x9f,0xa0,0x9e,0x9c,0x9b,
0x9a,0x9b,0x9c,0x9c,0x9d,0x9d,0x9b,0x99,0x99,0x9b,0x9e,0x9f,0x9e,0x9e,0x9e,0x9e,
0x9d,0x9c,0x9c,0x9d,0x9b,0x9a,0x99,0x99,0x99,0x9b,0x9a,0x99,0x9b,0x9c,0x9e,0x9e,
0x9d,0x9c,0x9e,0xa0,0xa0,0x9e,0x9e,0x9c,0x9d,0x9c,0x9d,0x9c,0x9b,0x9c,0x9d,0x9d,
0x9d,0x9c,0x9b,0x9c,0x9d,0x9e,0x9d,0x9c,0x9d,0x9e,0x9e,0x9f,0x9e,0x9e,0x9e,0x9e,
0x9c,0x9b,0x9b,0x9d,0x9c,0x9d,0x9e,0x9e,0x9e,0x9d,0x9d,0x9e,0x9c,0x9b,0x9e,0x9f,
0x9f,0x9e,0x9e,0x9d,0x9d,0x9d,0x9d,0x9d,0x9e,0x9c,0x9c,0x9b,0x9a,0x99,0x9b,0x9c,
0x9d,0x9e,0x9e,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,0x9d,0x9d,0x9d,0x99,0x96,0x96,0x95,
0x95,0x96,0x98,0x98,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9e,0xa0,0xa1,0x9d,0x9b,0x99,
0x99,0x9c,0x9d,0x9d,0x9e,0x9e,0x9e,0x9e,0x9d,0x9d,0x9f,0xa1,0x9f,0x9d,0x9c,0x9c,
0x9e,0x9e,0x9d,0x9c,0x9c,0x9d,0x9e,0xa2,0x9d,0x9c,0x9d,0x9e,0x9d,0x9c,0x9c,0x9d,
0x9e,0x9d,0x9d,0x9c,0x9c,0x9d,0x9f,0x9e,0x9c,0x9a,0x9b,0x9b,0x99,0x9b,0x9c,0x9c,
0x9c,0x9c,0x9c,0x9c,0x9c,0x9d,0x9d,0x9b,0x99,0x98,0x9b,0x9d,0x9e,0x9e,0x9e,0x9f,
0xa0,0x9f,0x9e,0x9d,0x9c,0x9b,0x9c,0x9b,0x9b,0x9c,0x9e,0x9f,0x9f,0x9f,0x9e,0x9e,
0x9d,0x9c,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,0x9d,0x9e,0x9f,0x9b,0x9c,0x9b,0x9d,
0x9f,0x9e,0x9d,0x9e,0x9c,0x9b,0x9c,0x9e,0x9e,0x9d,0x9c,0x9a,0x9b,0x9c,0x9e,0xa0,
0xa1,0x9f,0x9c,0x9b,0x9a,0x9a,0x9b,0x9c,0x9b,0x9a,0x9a,0x9b,0x9c,0x9c,0x9e,0xa0,
0xa1,0xa0,0xa1,0xa2,0xa0,0x9d,0x9c,0x9c,0x99,0x99,0x99,0x98,0x99,0x9b,0x9c,0x9c,
0x9a,0x9a,0x9b,0x9b,0x9a,0x99,0x9a,0x99,0x9a,0x9b,0x9d,0x9d,0x9e,0x9d,0x9e,0xa0,
0x9f,0x9e,0x9f,0x9f,0x9f,0x9e,0x9e,0x9e,0x9e,0x9c,0x9b,0x99,0x9a,0x9b,0x9a,0x9a,
0x99,0x99,0x9b,0x9e,0xa0,0xa0,0xa0,0x9f,0x9f,0x9d,0x9e,0x9e,0x9e,0x9d,0x9d,0x9e,
0x9d,0x9b,0x9e,0x9e,0x9f,0x9e,0x9e,0xa0,0xa2,0xa1,0x9f,0x9e,0x9e,0x9e,0x9f,0x9e,
0x9c,0x9b,0x9b,0x9b,0x9b,0x9a,0x9a,0x9a,0x9b,0x9a,0x9a,0x9b,0x9c,0x9e,0x9f,0x9d,
0x9d,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9e,0x9f,0x9e,0xa1,0xa1,0xa1,0xa2,0xa1,
0x9e,0x9d,0x9c,0x9c,0x9b,0x9a,0x9a,0x99,0x99,0x99,0x99,0x99,0x9a,0x9b,0x9d,0x9f,
0xa1,0xa1,0x9f,0x9e,0x9f,0xa0,0xa0,0xa1,0xa2,0x9f,0x9c,0x9a,0x9a,0x9b,0x9d,0x9d,
0x9c,0x9c,0x9a,0x98,0x99,0x99,0x9a,0x9c,0x9d,0x9c,0x9b,0x9c,0x9d,0x9c,0x9d,0x9d,
0x9c,0x9b,0x9a,0x9b,0x9d,0x9e,0x9f,0xa0,0xa0,0xa0,0xa2,0xa2,0xa2,0xa2,0xa1,0x9e,
0x9d,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9d,0x9d,0x9d,0x9e,0x9d,0x9d,0x9e,0x9f,0xa0,
0x9e,0x9d,0x9b,0x99,0x99,0x9a,0x99,0x9b,0x99,0x98,0x99,0x99,0x9b,0x9c,0x9e,0x9f,
0x9f,0x9e,0x9e,0x9d,0x9c,0x9c,0x9c,0x9e,0x9e,0x9e,0x9d,0x9d,0x9d,0x9e,0x9e,0x9f,
0xa1,0xa1,0x9f,0x9e,0x9e,0xa0,0xa0,0xa0,0x9f,0x9c,0x9c,0x9d,0x9e,0x9d,0x9c,0x9b,
0x9c,0x9c,0x9c,0x9a,0x9a,0x9c,0x9e,0x9d,0x9c,0x9b,0x9b,0x9c,0x9c,0x9c,0x9e,0x9d,
0x9e,0x9e,0x9e,0x9e,0x9e,0xa0,0xa1,0x9e,0x9b,0x9b,0x9c,0x9d,0x9c,0x9e,0x9e,0x9d,
0x9d,0x9c,0x9b,0x9e,0x9e,0x9d,0x9e,0x9d,0x9b,0x99,0x98,0x98,0x9a,0x9c,0x9e,0x9e,
0x9e,0x9d,0x9d,0x9d,0x9e,0x9f,0xa0,0x9e,0x9c,0x9b,0x99,0x99,0x9b,0x9b,0x9c,0x9e,
0x9e,0x9e,0x9f,0x9e,0x9e,0x9d,0x9e,0x9e,0x9e,0x9c,0x9c,0x9a,0x9b,0x9b,0x9b,0x9c,
0x9b,0x9a,0x9a,0x9b,0x9c,0x9d,0x9f,0x9f,0x9f,0xa0,0xa0,0x9f,0x9f,0x9e,0x9d,0x9d,
0x9d,0x9c,0x9c,0x9a,0x99,0x9b,0x9b,0x9c,0x9d,0x9e,0x9e,0x9d,0x9d,0x9d,0x9e,0x9e,
0x9c,0x9c,0x9d,0x9c,0x9b,0x99,0x9b,0x9b,0x9c,0x9d,0x9e,0x9c,0x9c,0x9b,0x9b,0x9c,
0x9d,0x9d,0x9e,0x9d,0x9c,0x9c,0x9d,0x9e,0x9f,0x9e,0x9e,0x9e,0x9d,0x9c,0x9d,0x9e,
0x9e,0x9e,0xa0,0x9f,0x9d,0x9c,0x9d,0x9e,0xa0,0xa0,0xa0,0x9f,0x9e,0x9d,0x9d,0x9e,
0x9e,0x9e,0x9f,0x9d,0x9b,0x9b,0x9c,0x9c,0x9e,0x9d,0x9d,0x9d,0x9c,0x9c,0xa0,0xa1,
0x9f,0xa0,0xa0,0x9f,0x9f,0x9e,0x9d,0x9e,0x9e,0xa1,0xa1,0xa2,0xa2,0xa1,0xa2,0xa0,
0x9e,0x9d,0x9d,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9f,0xa1,0xa1,0xa1,0xa2,0xa0,
0x9d,0x9c,0x9b,0x9b,0x9d,0x9c,0x9d,0x9e,0x9e,0x9e,0x9f,0xa0,0xa1,0xa2,0xa2,0xa2,
0xa2,0xa1,0x9e,0x9d,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0xa0,0xa0,0xa0,0x9f,0x9f,0x9e,
0x9f,0x9f,0xa1,0xa1,0xa0,0x9d,0x9c,0x9c,0x9b,0x9c,0xa1,0x9f,0x9e,0x9d,0x9d,0x9d,
0x9c,0x9c,0x9c,0x9c,0x9c,0x9b,0x9b,0x9c,0x9d,0x9f,0xa1,0xa1,0x9f,0x9e,0x9d,0x9d,
0x9e,0x9e,0x9d,0x9c,0x9b,0x99,0x9b,0x9d,0x9f,0xa0,0xa2,0xa2,0xa2,0xa2,0xa2,0xa1,
0xa0,0x9e,0x9b,0x9a,0x9a,0x9c,0x9c,0x9d,0x9c,0x9c,0x9d,0x9d,0x9c,0xa1,0xa2,0xa2,
0xa2,0xa2,0xa1,0xa0,0x9f,0x9d,0xa0,0xa2,0xa1,0xa0,0x9f,0x9d,0x9c,0x9c,0x9d,0x9e,
0x9f,0x9d,0x9c,0x9d,0x9c,0x9c,0x9e,0x9f,0x9e,0x9e,0x9d,0x9c,0x9a,0x9a,0x9b,0x9c,
0x9e,0x9d,0x9b,0x9d,0x9c,0x9c,0x9d,0x9e,0x9e,0x9d,0x9b,0x9b,0x9b,0x9c,0x9d,0x9d,
0x9e,0x9c,0x9c,0x9c,0x9c,0x9b,0x9c,0x9c,0x9b,0x9c,0x9e,0x9f,0xa0,0x9e,0x9d,0x9d,
0x9d,0x9c,0x9d,0x9d,0x9d,0x9c,0x9b,0x9b,0x9c,0x9c,0x9d,0x9e,0xa0,0xa0,0xa0,0x9e,
0x9e,0x9e,0x9f,0x9f,0x9f,0x9d,0x9e,0x9c,0x9c,0x9c,0x9d,0x9d,0x9d,0x9e,0x9e,0xa0,
0xa0,0x9f,0x9e,0x9d,0x9b,0x9c,0x9c,0x9e,0x9f,0x9e,0x9d,0x9d,0x9d,0x9d,0x9e,0xa0,
0x9f,0x9e,0xa0,0xa1,0xa0,0xa1,0xa2,0xa1,0x9f,0x9d,0x9e,0x9b,0x9d,0x9c,0x9d,0x9c,
0x99,0x96,0x98,0x99,0x99,0x98,0x92,0x85,0x77,0x66,0x5c,0x5a,0x60,0x6b,0x77,0x80,
0x80,0x78,0x6f,0x65,0x60,0x61,0x66,0x6c,0x6e,0x70,0x73,0x7a,0x85,0x91,0x9c,0x9e,
0x94,0x80,0x68,0x56,0x52,0x5c,0x6a,0x77,0x7f,0x7d,0x76,0x70,0x6a,0x64,0x5f,0x58,
0x49,0x3a,0x32,0x33,0x3e,0x53,0x6a,0x7b,0x82,0x7e,0x73,0x67,0x5c,0x52,0x4c,0x45,
0x41,0x3e,0x3c,0x38,0x38,0x38,0x3d,0x44,0x4f,0x5d,0x6e,0x7c,0x80,0x7a,0x6e,0x5e,
0x57,0x5a,0x65,0x72,0x7b,0x7c,0x73,0x68,0x61,0x5d,0x5c,0x5f,0x5c,0x52,0x45,0x36,
0x2b,0x2a,0x2f,0x38,0x40,0x43,0x43,0x3f,0x3b,0x38,0x37,0x37,0x38,0x38,0x3a,0x3c,
0x3c,0x3c,0x3a,0x37,0x35,0x35,0x34,0x37,0x3a,0x3b,0x3c,0x3c,0x3a,0x3a,0x3b,0x3d,
// Line 12
0x39,0x38,0x38,0x38,0x38,0x38,0x3a,0x3a,0x3a,0x38,0x39,0x38,0x38,0x35,0x37,0x36,
0x34,0x33,0x34,0x36,0x36,0x36,0x36,0x36,0x38,0x39,0x3a,0x3a,0x3a,0x3b,0x3c,0x3a,
0x38,0x38,0x38,0x38,0x37,0x34,0x34,0x35,0x37,0x37,0x38,0x39,0x39,0x38,0x38,0x36,
0x37,0x3a,0x3b,0x38,0x35,0x32,0x35,0x40,0x52,0x67,0x76,0x7e,0x7a,0x70,0x63,0x59,
0x56,0x5f,0x6b,0x75,0x79,0x76,0x6e,0x64,0x5c,0x5b,0x5f,0x65,0x6d,0x72,0x73,0x6f,
0x67,0x61,0x5f,0x60,0x62,0x67,0x6d,0x73,0x75,0x70,0x6a,0x63,0x5c,0x5c,0x61,0x67,
0x70,0x75,0x77,0x74,0x6d,0x64,0x5f,0x5d,0x60,0x66,0x6f,0x73,0x74,0x70,0x68,0x5f,
0x5a,0x59,0x5f,0x67,0x6e,0x72,0x73,0x6f,0x69,0x60,0x5b,0x5b,0x61,0x6e,0x78,0x7d,
0x7c,0x76,0x6d,0x64,0x5e,0x5d,0x63,0x68,0x6a,0x69,0x6b,0x6d,0x72,0x7d,0x89,0x97,
0xa4,0xab,0xab,0xa6,0x98,0x85,0x75,0x68,0x60,0x58,0x54,0x4d,0x45,0x3c,0x36,0x35,
0x3d,0x4b,0x60,0x74,0x81,0x88,0x8c,0x91,0x96,0x9b,0x9e,0x9d,0x9b,0x98,0x96,0x97,
0x9a,0x9c,0x98,0x8e,0x80,0x70,0x66,0x5d,0x55,0x4b,0x40,0x36,0x32,0x39,0x49,0x5b,
0x6f,0x7a,0x7d,0x77,0x6c,0x62,0x5b,0x55,0x4e,0x45,0x39,0x30,0x31,0x3c,0x52,0x6b,
0x7d,0x85,0x81,0x76,0x65,0x58,0x50,0x4c,0x49,0x44,0x3c,0x34,0x30,0x30,0x34,0x3d,
0x46,0x51,0x5f,0x6b,0x74,0x76,0x73,0x6b,0x65,0x5e,0x58,0x52,0x4a,0x3f,0x37,0x36,
0x3d,0x4b,0x60,0x74,0x85,0x91,0x97,0x98,0x98,0x94,0x8b,0x7a,0x65,0x55,0x50,0x56,
0x62,0x70,0x79,0x78,0x6d,0x63,0x5d,0x5c,0x5c,0x58,0x4c,0x3c,0x2d,0x2a,0x36,0x51,
0x6c,0x7b,0x81,0x79,0x6b,0x60,0x58,0x52,0x50,0x47,0x39,0x31,0x31,0x3e,0x54,0x6d,
0x7c,0x81,0x7d,0x71,0x63,0x5a,0x53,0x4c,0x46,0x3d,0x35,0x33,0x39,0x49,0x5f,0x75,
0x85,0x8f,0x95,0x98,0x99,0x93,0x87,0x77,0x67,0x58,0x52,0x55,0x5f,0x69,0x74,0x7d,
0x85,0x8f,0x98,0x9d,0x9d,0x91,0x7e,0x69,0x58,0x50,0x55,0x63,0x71,0x7a,0x7b,0x75,
0x68,0x60,0x58,0x50,0x4d,0x47,0x3f,0x37,0x2f,0x2a,0x2e,0x37,0x3f,0x44,0x44,0x3e,
0x35,0x2e,0x31,0x3d,0x4f,0x63,0x74,0x7f,0x7c,0x70,0x64,0x5c,0x5b,0x61,0x69,0x71,
0x76,0x79,0x7d,0x83,0x8f,0x9c,0xa6,0xad,0xa8,0xa0,0x9b,0x98,0x98,0x99,0x9c,0x9e,
0xa2,0xa2,0xa1,0xa0,0x9d,0x9c,0x9a,0x98,0x97,0x98,0x9c,0x9e,0x9d,0x9c,0x9c,0x9c,
0x9d,0x9d,0x9e,0xa0,0xa0,0x9e,0x9d,0x9d,0x9c,0x9a,0x9b,0x9c,0x9e,0x9e,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa2,0xa2,0xa0,0xa1,0xa2,0xa0,0x9d,0x9d,0x9c,0x9c,0x9c,0x9c,0x9d,
0x9e,0x9d,0x9d,0x9d,0x9d,0x9c,0x9d,0x9e,0x9e,0x9d,0x9c,0x9a,0x99,0x99,0x99,0x99,
0x9c,0x9c,0x9e,0x9e,0x9d,0x9c,0x9d,0x9e,0x9e,0x9e,0xa0,0xa0,0xa0,0x9e,0x9d,0x9a,
0x9e,0x9e,0x9e,0x9d,0x9b,0x9a,0x9b,0x9b,0x9a,0x9d,0xa0,0xa0,0xa0,0xa0,0x9e,0xa0,
0xa0,0x9f,0x9e,0x9d,0x9c,0x9a,0x9b,0x9a,0x9a,0x9c,0x9c,0x99,0x9a,0x9a,0x9c,0x9e,
0x9f,0x9e,0xa0,0x9e,0x9e,0x9b,0x9b,0x9d,0x9d,0x9d,0x9c,0x9a,0x9b,0x9a,0x99,0x9a,
0x9c,0x9d,0x9d,0x9f,0x9f,0x9e,0x9d,0x9e,0x9d,0xa0,0x9f,0x9d,0x9c,0x9b,0x9a,0x9c,
0x9b,0x9b,0x9e,0xa0,0x9e,0x9a,0x98,0x98,0x9a,0x9d,0x9b,0x93,0x85,0x72,0x60,0x56,
0x56,0x5f,0x6d,0x77,0x7b,0x79,0x72,0x6a,0x64,0x61,0x5d,0x57,0x4c,0x3d,0x31,0x2f,
0x39,0x4d,0x67,0x7e,0x87,0x83,0x74,0x61,0x56,0x56,0x61,0x70,0x79,0x7a,0x76,0x6f,
0x67,0x62,0x63,0x61,0x5b,0x4d,0x3e,0x33,0x31,0x3a,0x4b,0x61,0x75,0x83,0x8e,0x91,
0x94,0x95,0x93,0x8a,0x7b,0x69,0x5a,0x51,0x57,0x63,0x71,0x7c,0x7e,0x76,0x6c,0x61,
0x5d,0x5f,0x66,0x70,0x78,0x79,0x73,0x67,0x64,0x61,0x61,0x61,0x5a,0x4d,0x42,0x37,
0x2e,0x31,0x40,0x58,0x70,0x83,0x8f,0x96,0x98,0x97,0x90,0x84,0x77,0x6a,0x61,0x58,
0x4d,0x44,0x3c,0x39,0x3b,0x44,0x51,0x62,0x73,0x81,0x89,0x8e,0x8f,0x93,0x99,0xa0,
0xa4,0xa4,0x9b,0x8c,0x7b,0x69,0x5a,0x50,0x4a,0x46,0x41,0x3d,0x38,0x33,0x36,0x3a,
0x3f,0x45,0x46,0x44,0x3e,0x38,0x34,0x38,0x3e,0x4b,0x5d,0x6e,0x7c,0x85,0x8a,0x8f,
0x94,0x99,0x9d,0xa0,0x9d,0x95,0x89,0x7b,0x6c,0x61,0x59,0x52,0x4b,0x46,0x41,0x3c,
0x36,0x33,0x35,0x38,0x3b,0x3c,0x3a,0x38,0x32,0x2f,0x32,0x3a,0x46,0x58,0x68,0x75,
0x81,0x8a,0x91,0x96,0x9a,0x9d,0x9f,0x9f,0x9d,0x9a,0x9a,0x9a,0x9c,0xa0,0xa1,0xa1,
0xa0,0x9e,0x9d,0x9b,0x99,0x98,0x97,0x98,0x99,0x9a,0x9c,0x9e,0x9e,0x9b,0x98,0x97,
0x98,0x98,0x98,0x98,0x97,0x96,0x96,0x97,0x99,0x9c,0x9b,0x96,0x8d,0x7f,0x70,0x61,
0x56,0x4d,0x47,0x45,0x40,0x3a,0x36,0x33,0x34,0x38,0x3b,0x3d,0x3d,0x39,0x33,0x2f,
0x2e,0x31,0x36,0x38,0x38,0x38,0x38,0x36,0x34,0x38,0x3a,0x3a,0x3d,0x3b,0x3b,0x3a,
0x3c,0x3b,0x3c,0x3c,0x3c,0x37,0x38,0x34,0x32,0x38,0x40,0x4c,0x5c,0x6a,0x75,0x7e,
0x85,0x8d,0x93,0x97,0x9a,0x9d,0x9d,0x9a,0x96,0x93,0x94,0x98,0x9d,0xa0,0xa0,0xa0,
0x9f,0x9c,0x9c,0x9a,0x9b,0x9c,0x9e,0x9d,0x9b,0x99,0x98,0x94,0x98,0x99,0x9b,0x99,
0x92,0x85,0x7c,0x6d,0x5f,0x54,0x4d,0x47,0x40,0x39,0x32,0x30,0x31,0x33,0x36,0x38,
0x38,0x36,0x34,0x32,0x31,0x32,0x35,0x38,0x3a,0x3a,0x38,0x37,0x36,0x35,0x36,0x36,
0x34,0x31,0x30,0x30,0x34,0x3d,0x4b,0x5a,0x6e,0x7a,0x83,0x8b,0x93,0x9b,0xa0,0xa2,
0xa0,0xa0,0x9f,0x9c,0x99,0x98,0x99,0x9b,0x9e,0x9e,0x9d,0x9c,0x9c,0x9d,0xa0,0x9e,
0x9c,0x98,0x8f,0x83,0x74,0x65,0x58,0x4b,0x44,0x3c,0x38,0x36,0x32,0x32,0x36,0x3a,
0x3c,0x3d,0x3c,0x39,0x36,0x34,0x33,0x33,0x33,0x34,0x34,0x39,0x3e,0x48,0x58,0x69,
0x76,0x81,0x88,0x8c,0x94,0x9b,0xa2,0xa3,0xa0,0x9d,0x9b,0x9a,0x9c,0x9d,0x9f,0xa0,
0x9e,0x9c,0x98,0x97,0x98,0x99,0x99,0x97,0x95,0x96,0x99,0x9b,0x9b,0x98,0x8f,0x82,
0x6e,0x5f,0x52,0x4a,0x44,0x40,0x3a,0x38,0x35,0x32,0x36,0x38,0x3c,0x3c,0x3e,0x3a,
0x37,0x34,0x33,0x32,0x32,0x31,0x32,0x35,0x37,0x38,0x38,0x36,0x34,0x34,0x36,0x38,
0x3c,0x3e,0x3c,0x38,0x36,0x36,0x3a,0x42,0x4e,0x5c,0x6c,0x78,0x83,0x8b,0x93,0x98,
0x9e,0xa0,0xa2,0xa0,0x9e,0x99,0x96,0x96,0x96,0x96,0x99,0x9c,0x9d,0x9a,0x93,0x89,
0x7e,0x70,0x63,0x58,0x4f,0x47,0x41,0x3c,0x38,0x36,0x34,0x33,0x31,0x34,0x38,0x3d,
0x48,0x54,0x62,0x70,0x7c,0x85,0x8f,0x94,0x9a,0xa0,0xa3,0xa1,0xa0,0x9d,0x9b,0x9a,
0x9e,0x9e,0x9e,0xa0,0xa0,0x9d,0x9c,0x99,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9d,0x9d,
0x9c,0x9c,0x9c,0x9a,0x99,0x96,0x98,0x98,0x98,0x97,0x98,0x99,0x9a,0x99,0x98,0x98,
0x9a,0x9c,0x9e,0x9f,0x9e,0x9d,0x9b,0x9a,0x98,0x99,0x9b,0x9b,0x99,0x97,0x96,0x97,
0x98,0x98,0x99,0x9a,0x99,0x98,0x9a,0x9c,0x9c,0x9e,0x9e,0x9c,0x9b,0x99,0x99,0x9a,
0x9a,0x97,0x91,0x87,0x7a,0x6b,0x5e,0x53,0x4b,0x46,0x42,0x3d,0x38,0x33,0x32,0x36,
0x3a,0x3b,0x3c,0x3a,0x37,0x36,0x34,0x34,0x36,0x36,0x36,0x35,0x34,0x33,0x32,0x35,
0x36,0x37,0x39,0x3b,0x3a,0x39,0x3a,0x3a,0x3a,0x39,0x38,0x37,0x37,0x34,0x34,0x34,
0x35,0x35,0x36,0x36,0x35,0x34,0x35,0x36,0x36,0x36,0x39,0x3b,0x3b,0x39,0x38,0x36,
0x36,0x37,0x39,0x3a,0x39,0x3a,0x39,0x37,0x39,0x38,0x38,0x36,0x35,0x32,0x33,0x33,
0x33,0x34,0x37,0x35,0x34,0x34,0x36,0x38,0x3c,0x3d,0x3d,0x3d,0x3a,0x37,0x37,0x38,
0x3a,0x3c,0x3c,0x38,0x32,0x2d,0x2b,0x32,0x40,0x55,0x66,0x73,0x75,0x6f,0x66,0x5b,
0x54,0x4f,0x4b,0x44,0x3c,0x32,0x2a,0x26,0x28,0x2f,0x39,0x41,0x4a,0x51,0x5b,0x65,
0x72,0x80,0x8b,0x94,0x9a,0x9e,0xa1,0xa3,0xa4,0xa0,0x9d,0x99,0x97,0x95,0x98,0x9b,
0x9f,0x9f,0x9d,0x97,0x8d,0x7f,0x70,0x62,0x55,0x4b,0x46,0x42,0x3e,0x38,0x31,0x2b,
0x2a,0x2d,0x32,0x3a,0x43,0x4c,0x58,0x67,0x74,0x81,0x91,0x97,0x96,0x91,0x89,0x7e,
0x70,0x62,0x58,0x56,0x5b,0x64,0x70,0x81,0x8b,0x93,0x98,0x9b,0x9f,0xa2,0xa3,0x9f,
0x96,0x87,0x77,0x65,0x58,0x4d,0x49,0x45,0x40,0x3a,0x35,0x31,0x30,0x33,0x38,0x3b,
0x3c,0x3a,0x38,0x36,0x34,0x34,0x36,0x37,0x38,0x3a,0x39,0x38,0x38,0x38,0x38,0x38,
0x39,0x38,0x38,0x39,0x38,0x38,0x3a,0x3a,0x39,0x38,0x3a,0x38,0x38,0x38,0x39,0x37,
0x39,0x37,0x37,0x39,0x39,0x37,0x38,0x36,0x34,0x36,0x37,0x36,0x36,0x34,0x32,0x33,
0x35,0x37,0x38,0x37,0x33,0x31,0x31,0x32,0x36,0x38,0x39,0x36,0x32,0x2f,0x30,0x34,
0x38,0x3a,0x39,0x35,0x30,0x2e,0x36,0x44,0x58,0x6c,0x79,0x7a,0x75,0x6a,0x5f,0x5b,
0x58,0x56,0x4e,0x40,0x33,0x2e,0x34,0x46,0x5f,0x76,0x83,0x81,0x70,0x5c,0x4e,0x4c,
0x56,0x64,0x73,0x79,0x76,0x6d,0x63,0x5d,0x5f,0x64,0x69,0x6b,0x69,0x69,0x6c,0x74,
0x7f,0x8e,0x9c,0xa6,0xa8,0xa8,0xa4,0x9e,0x99,0x96,0x95,0x96,0x98,0x98,0x95,0x97,
0x96,0x91,0x8b,0x80,0x70,0x63,0x56,0x50,0x56,0x63,0x71,0x7c,0x7a,0x70,0x64,0x5a,
0x57,0x5b,0x63,0x6b,0x70,0x72,0x6b,0x60,0x57,0x53,0x54,0x56,0x54,0x4b,0x40,0x32,
0x28,0x25,0x29,0x32,0x3d,0x43,0x42,0x3a,0x34,0x30,0x2f,0x34,0x37,0x38,0x39,0x39,
0x38,0x36,0x36,0x36,0x37,0x36,0x36,0x34,0x35,0x35,0x37,0x38,0x38,0x38,0x3a,0x37,
// Line 13
0x37,0x38,0x39,0x37,0x36,0x35,0x35,0x34,0x35,0x37,0x3b,0x3b,0x3a,0x39,0x3a,0x3a,
0x39,0x39,0x3a,0x3a,0x37,0x37,0x35,0x35,0x35,0x35,0x36,0x38,0x37,0x37,0x36,0x36,
0x37,0x3a,0x3e,0x3e,0x3e,0x3c,0x3a,0x39,0x3b,0x3d,0x3e,0x3e,0x3c,0x37,0x35,0x35,
0x39,0x3b,0x3f,0x3d,0x37,0x33,0x35,0x3f,0x50,0x60,0x6f,0x7a,0x7a,0x6f,0x60,0x57,
0x56,0x5e,0x6a,0x76,0x7a,0x77,0x6e,0x62,0x5a,0x58,0x5d,0x68,0x6f,0x70,0x70,0x6a,
0x65,0x60,0x5d,0x5c,0x60,0x67,0x6e,0x72,0x73,0x70,0x6b,0x65,0x60,0x5e,0x62,0x69,
0x6e,0x74,0x74,0x70,0x69,0x62,0x5d,0x5c,0x61,0x6b,0x73,0x79,0x79,0x73,0x6b,0x61,
0x5a,0x5b,0x61,0x6a,0x72,0x75,0x75,0x70,0x67,0x60,0x5e,0x5f,0x64,0x6b,0x72,0x76,
0x76,0x74,0x70,0x6a,0x67,0x65,0x65,0x67,0x6a,0x6c,0x6f,0x72,0x76,0x7e,0x89,0x96,
0xa0,0xa7,0xa8,0xa4,0x9b,0x8a,0x78,0x6b,0x60,0x5a,0x58,0x53,0x4d,0x44,0x3b,0x37,
0x3e,0x4b,0x60,0x76,0x84,0x8a,0x8e,0x91,0x96,0x9b,0xa0,0xa2,0xa0,0x9d,0x9a,0x9a,
0x9c,0x9c,0x97,0x8e,0x7d,0x6e,0x61,0x5a,0x53,0x4b,0x43,0x3a,0x34,0x3a,0x4a,0x5e,
0x73,0x7e,0x7f,0x75,0x6a,0x5f,0x5a,0x55,0x51,0x47,0x3b,0x30,0x30,0x3e,0x52,0x6a,
0x7d,0x84,0x7f,0x74,0x65,0x59,0x53,0x4e,0x49,0x44,0x3e,0x39,0x32,0x2f,0x31,0x38,
0x44,0x50,0x5f,0x6d,0x76,0x76,0x71,0x6a,0x63,0x5f,0x5c,0x55,0x4d,0x41,0x37,0x31,
0x3a,0x4a,0x60,0x7a,0x8c,0x94,0x96,0x97,0x96,0x94,0x8c,0x7f,0x6d,0x5c,0x53,0x58,
0x65,0x74,0x7d,0x7d,0x73,0x67,0x60,0x5c,0x5a,0x54,0x49,0x38,0x2d,0x2c,0x3a,0x52,
0x6a,0x7b,0x82,0x7c,0x6f,0x60,0x5a,0x57,0x53,0x4a,0x3e,0x34,0x36,0x40,0x54,0x6d,
0x81,0x8a,0x86,0x76,0x62,0x54,0x55,0x5f,0x6b,0x74,0x74,0x71,0x6c,0x66,0x61,0x62,
0x65,0x6a,0x6f,0x70,0x70,0x74,0x7c,0x89,0x95,0xa0,0xa8,0xaa,0xa7,0xa0,0x9c,0x99,
0x97,0x96,0x9b,0x9d,0xa0,0xa4,0xa6,0xa6,0xa5,0xa1,0x9e,0x9c,0x9b,0x9b,0x9e,0x9e,
0x9b,0x97,0x91,0x86,0x78,0x69,0x5c,0x51,0x4b,0x48,0x45,0x41,0x3c,0x37,0x37,0x38,
0x3c,0x42,0x46,0x44,0x3d,0x36,0x33,0x37,0x42,0x54,0x68,0x7a,0x7e,0x79,0x6d,0x5f,
0x57,0x5a,0x63,0x70,0x79,0x79,0x73,0x68,0x5f,0x5b,0x5a,0x5a,0x55,0x4e,0x45,0x38,
0x2c,0x29,0x2e,0x37,0x42,0x47,0x45,0x3c,0x34,0x2f,0x31,0x3d,0x4f,0x63,0x75,0x7e,
0x7a,0x70,0x65,0x5d,0x5d,0x63,0x6b,0x77,0x7d,0x7c,0x75,0x6a,0x5f,0x5c,0x62,0x6d,
0x75,0x7b,0x7c,0x78,0x70,0x68,0x62,0x61,0x65,0x68,0x6c,0x6d,0x6f,0x71,0x7a,0x84,
0x91,0x9a,0x9c,0x95,0x83,0x6c,0x58,0x49,0x3f,0x3b,0x3b,0x3e,0x3e,0x3e,0x3e,0x3e,
0x3e,0x40,0x45,0x4e,0x5c,0x6a,0x78,0x85,0x8e,0x92,0x98,0x9c,0xa0,0xa3,0xa3,0x9c,
0x91,0x84,0x74,0x67,0x60,0x5e,0x61,0x68,0x70,0x79,0x81,0x88,0x8e,0x97,0xa0,0xa7,
0xaa,0xa9,0xa3,0x9a,0x8e,0x7f,0x6f,0x65,0x5f,0x5d,0x5f,0x62,0x68,0x71,0x7d,0x85,
0x8f,0x96,0x9a,0x98,0x8e,0x7f,0x6f,0x5d,0x4d,0x41,0x3c,0x3c,0x3d,0x3f,0x3e,0x39,
0x35,0x34,0x3b,0x49,0x5a,0x6a,0x75,0x79,0x75,0x6c,0x64,0x5d,0x58,0x53,0x4c,0x43,
0x3a,0x31,0x2c,0x2f,0x32,0x39,0x44,0x4e,0x59,0x61,0x6e,0x7b,0x88,0x92,0x99,0x99,
0x94,0x89,0x7b,0x6d,0x5c,0x4d,0x40,0x37,0x33,0x35,0x3c,0x45,0x52,0x61,0x70,0x7d,
0x88,0x8f,0x95,0x9a,0x9d,0x9e,0xa2,0xa3,0x9d,0x91,0x81,0x6f,0x62,0x5b,0x5a,0x5b,
0x63,0x6a,0x74,0x7d,0x86,0x8f,0x9b,0xa3,0xa6,0xa7,0xa4,0xa0,0x9a,0x96,0x94,0x97,
0x99,0x9c,0x9e,0x9f,0x9e,0x9b,0x9a,0x9b,0x9c,0x9c,0x9b,0x99,0x98,0x9a,0x9d,0x9e,
0x98,0x8f,0x85,0x75,0x65,0x59,0x56,0x5b,0x64,0x6c,0x73,0x7a,0x85,0x8e,0x96,0x9d,
0xa1,0xa2,0xa3,0x9d,0x96,0x92,0x94,0x97,0x9a,0x97,0x8d,0x7f,0x71,0x62,0x54,0x48,
0x42,0x40,0x3f,0x3a,0x34,0x33,0x36,0x3a,0x3f,0x41,0x3f,0x3a,0x34,0x31,0x37,0x45,
0x58,0x6b,0x7a,0x7c,0x74,0x69,0x5e,0x57,0x55,0x51,0x4a,0x42,0x38,0x30,0x2b,0x2d,
0x35,0x42,0x4b,0x4a,0x44,0x3c,0x37,0x3b,0x49,0x5c,0x70,0x7c,0x7f,0x76,0x6a,0x5d,
0x55,0x56,0x5b,0x61,0x68,0x6e,0x75,0x7f,0x8a,0x94,0x9c,0x9c,0x92,0x7f,0x6c,0x59,
0x4a,0x42,0x3e,0x3b,0x3a,0x37,0x35,0x37,0x3a,0x3c,0x3c,0x3b,0x36,0x30,0x32,0x39,
0x48,0x5c,0x6e,0x79,0x7c,0x75,0x6b,0x5f,0x55,0x50,0x50,0x4d,0x45,0x3b,0x33,0x2f,
0x31,0x3a,0x44,0x4a,0x4c,0x40,0x34,0x31,0x36,0x45,0x5a,0x6d,0x78,0x7a,0x74,0x6b,
0x5f,0x5b,0x55,0x4f,0x49,0x40,0x37,0x31,0x30,0x35,0x3d,0x40,0x40,0x3d,0x3a,0x37,
0x36,0x37,0x3a,0x3a,0x36,0x35,0x3a,0x48,0x59,0x6a,0x79,0x7e,0x78,0x6d,0x63,0x5c,
0x5c,0x60,0x68,0x6f,0x74,0x78,0x7a,0x85,0x90,0x9c,0xa7,0xac,0xaa,0xa4,0x97,0x88,
0x79,0x6a,0x5d,0x53,0x4c,0x46,0x43,0x3e,0x3a,0x33,0x2f,0x2f,0x34,0x3a,0x3e,0x3f,
0x3d,0x35,0x30,0x2f,0x32,0x37,0x3a,0x38,0x36,0x36,0x38,0x3a,0x3c,0x3d,0x3b,0x39,
0x36,0x36,0x3c,0x4c,0x5a,0x65,0x72,0x7c,0x87,0x90,0x97,0x98,0x95,0x8a,0x7b,0x69,
0x5b,0x55,0x59,0x64,0x6f,0x76,0x78,0x74,0x6c,0x64,0x5d,0x55,0x4e,0x44,0x3c,0x36,
0x31,0x2f,0x30,0x33,0x38,0x41,0x4e,0x5c,0x6a,0x74,0x7a,0x77,0x6f,0x66,0x5f,0x61,
0x63,0x68,0x6e,0x74,0x78,0x7a,0x84,0x90,0x9c,0xa6,0xaa,0xa6,0x9e,0x92,0x85,0x79,
0x6d,0x63,0x59,0x4f,0x45,0x41,0x40,0x3d,0x38,0x32,0x2e,0x2e,0x32,0x3c,0x4a,0x5c,
0x6a,0x71,0x75,0x70,0x6a,0x63,0x5e,0x59,0x54,0x4c,0x42,0x37,0x35,0x39,0x46,0x5b,
0x71,0x81,0x8f,0x94,0x92,0x95,0x98,0x9f,0xa3,0xa1,0x9d,0x9a,0x98,0x99,0x9b,0x9a,
0x92,0x84,0x72,0x61,0x56,0x54,0x5a,0x63,0x6d,0x77,0x7f,0x87,0x90,0x98,0x9f,0x9c,
0x90,0x7a,0x65,0x54,0x4d,0x4e,0x57,0x62,0x71,0x7f,0x89,0x92,0x98,0x9c,0x9c,0x90,
0x7f,0x6e,0x61,0x5b,0x5b,0x61,0x6b,0x79,0x84,0x8c,0x92,0x98,0x99,0x92,0x87,0x75,
0x62,0x55,0x50,0x55,0x62,0x70,0x7c,0x7e,0x77,0x6a,0x5f,0x5a,0x54,0x4e,0x47,0x3e,
0x32,0x2b,0x28,0x2e,0x38,0x40,0x43,0x40,0x38,0x31,0x2c,0x35,0x44,0x58,0x6d,0x79,
0x7a,0x79,0x70,0x68,0x62,0x5b,0x53,0x48,0x3c,0x33,0x34,0x40,0x53,0x68,0x79,0x80,
0x7c,0x70,0x63,0x5b,0x56,0x50,0x47,0x3e,0x35,0x31,0x38,0x49,0x5d,0x74,0x86,0x8f,
0x92,0x92,0x95,0x9a,0x9d,0x9d,0x98,0x97,0x93,0x92,0x96,0x97,0x94,0x8e,0x82,0x71,
0x64,0x59,0x51,0x4b,0x44,0x3b,0x37,0x37,0x38,0x3a,0x3c,0x3d,0x3c,0x39,0x36,0x34,
0x34,0x34,0x36,0x37,0x38,0x39,0x39,0x3a,0x3a,0x3c,0x3e,0x3e,0x3b,0x38,0x36,0x35,
0x3d,0x49,0x59,0x6b,0x78,0x7b,0x79,0x70,0x66,0x5e,0x58,0x53,0x4e,0x46,0x3c,0x31,
0x2b,0x2c,0x33,0x3e,0x45,0x46,0x42,0x39,0x33,0x37,0x43,0x55,0x6a,0x79,0x80,0x7d,
0x73,0x65,0x5a,0x58,0x5d,0x67,0x72,0x78,0x77,0x71,0x65,0x5c,0x5b,0x60,0x6c,0x74,
0x7c,0x7a,0x73,0x6a,0x63,0x5e,0x61,0x66,0x6a,0x6d,0x6d,0x6f,0x73,0x7b,0x88,0x95,
0x99,0x96,0x8c,0x7b,0x68,0x58,0x4c,0x42,0x3b,0x34,0x32,0x38,0x47,0x5a,0x6d,0x7b,
0x7e,0x76,0x6a,0x5d,0x57,0x5a,0x61,0x68,0x6f,0x74,0x79,0x7d,0x88,0x94,0x9c,0x9e,
0x95,0x83,0x6f,0x5e,0x53,0x53,0x5a,0x65,0x73,0x7f,0x88,0x90,0x98,0x9d,0xa0,0xa0,
0x9f,0x99,0x92,0x85,0x76,0x67,0x5b,0x51,0x4b,0x48,0x46,0x42,0x3c,0x35,0x33,0x37,
0x3c,0x41,0x45,0x42,0x3c,0x35,0x31,0x35,0x44,0x57,0x69,0x7a,0x7f,0x7a,0x6f,0x63,
0x5b,0x5c,0x60,0x68,0x6c,0x70,0x75,0x7b,0x86,0x90,0x98,0x99,0x90,0x7d,0x6a,0x57,
0x4b,0x44,0x41,0x3e,0x3a,0x37,0x36,0x38,0x3c,0x40,0x40,0x3c,0x33,0x2c,0x2e,0x34,
0x41,0x55,0x6a,0x77,0x7a,0x75,0x6a,0x61,0x5a,0x54,0x50,0x4d,0x44,0x39,0x31,0x2b,
0x2b,0x35,0x3d,0x45,0x47,0x43,0x3a,0x31,0x32,0x3c,0x50,0x66,0x78,0x7f,0x7b,0x6f,
0x64,0x5d,0x5b,0x5e,0x64,0x6b,0x70,0x77,0x7b,0x83,0x8e,0x9a,0xa2,0xa8,0xaa,0xa6,
0x9c,0x8e,0x7f,0x6f,0x65,0x5c,0x5a,0x5b,0x5f,0x65,0x6d,0x75,0x7e,0x87,0x90,0x98,
0xa1,0xa7,0xa8,0xa3,0x99,0x8a,0x7c,0x6f,0x64,0x5b,0x56,0x50,0x46,0x3c,0x35,0x35,
0x3a,0x49,0x5b,0x6e,0x7d,0x87,0x8c,0x94,0x97,0x9d,0xa3,0xa6,0xa2,0xa0,0x9a,0x95,
0x96,0x97,0x97,0x90,0x81,0x6e,0x5f,0x55,0x55,0x5c,0x68,0x73,0x78,0x78,0x73,0x6b,
0x65,0x5f,0x5b,0x54,0x4a,0x3d,0x33,0x2e,0x34,0x43,0x5a,0x71,0x84,0x90,0x94,0x93,
0x96,0x98,0x9c,0xa0,0x9f,0x9a,0x91,0x83,0x73,0x65,0x5d,0x5b,0x61,0x6b,0x75,0x79,
0x7c,0x74,0x6a,0x63,0x5e,0x5d,0x60,0x64,0x68,0x6d,0x74,0x7d,0x88,0x92,0x9c,0xa2,
0xa6,0xa7,0xa1,0x98,0x8c,0x7d,0x70,0x64,0x5d,0x5f,0x65,0x6b,0x73,0x77,0x7d,0x86,
0x90,0x98,0x9e,0x9c,0x90,0x7b,0x68,0x58,0x51,0x57,0x62,0x6e,0x78,0x78,0x71,0x6a,
0x61,0x5a,0x54,0x4d,0x44,0x3c,0x35,0x30,0x2e,0x2f,0x35,0x3e,0x49,0x53,0x5c,0x66,
0x6f,0x7a,0x86,0x92,0x98,0x98,0x92,0x86,0x75,0x65,0x55,0x49,0x42,0x3e,0x3c,0x3b,
0x3a,0x39,0x3d,0x3e,0x3e,0x3d,0x3c,0x3b,0x36,0x35,0x35,0x35,0x36,0x38,0x39,0x3a,
0x39,0x37,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x38,0x36,0x34,0x34,0x36,
// Line 14
0x3d,0x3d,0x3e,0x3f,0x3e,0x3b,0x39,0x37,0x36,0x36,0x36,0x37,0x38,0x37,0x36,0x36,
0x36,0x37,0x39,0x39,0x39,0x38,0x38,0x36,0x36,0x37,0x39,0x39,0x37,0x34,0x35,0x37,
0x38,0x37,0x38,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x34,0x38,
0x38,0x37,0x38,0x3a,0x3c,0x3e,0x45,0x4c,0x56,0x61,0x6b,0x72,0x79,0x81,0x88,0x8e,
0x95,0x98,0x99,0x96,0x95,0x95,0x94,0x93,0x94,0x94,0x95,0x95,0x95,0x95,0x94,0x91,
0x8d,0x87,0x82,0x79,0x70,0x66,0x5a,0x52,0x4c,0x46,0x42,0x3d,0x3b,0x37,0x38,0x38,
0x39,0x3b,0x3d,0x3b,0x3a,0x39,0x39,0x39,0x39,0x37,0x37,0x38,0x3b,0x3d,0x42,0x47,
0x4f,0x58,0x62,0x6d,0x77,0x80,0x87,0x8c,0x91,0x92,0x93,0x95,0x96,0x95,0x95,0x95,
0x93,0x91,0x91,0x92,0x95,0x97,0x98,0x95,0x91,0x8b,0x85,0x7f,0x78,0x6e,0x64,0x5a,
0x52,0x4c,0x45,0x41,0x3e,0x3a,0x38,0x38,0x39,0x38,0x35,0x37,0x36,0x36,0x36,0x37,
0x36,0x38,0x36,0x35,0x37,0x3b,0x3f,0x46,0x4c,0x52,0x5a,0x63,0x6e,0x78,0x83,0x8a,
0x8d,0x91,0x93,0x95,0x96,0x97,0x97,0x97,0x96,0x95,0x95,0x95,0x95,0x95,0x96,0x95,
0x91,0x8c,0x88,0x82,0x7c,0x74,0x6b,0x64,0x5b,0x51,0x4a,0x43,0x3c,0x37,0x36,0x35,
0x36,0x37,0x38,0x38,0x39,0x39,0x3b,0x3d,0x3d,0x3c,0x3b,0x39,0x37,0x38,0x39,0x3d,
0x44,0x4b,0x53,0x5d,0x66,0x70,0x7a,0x84,0x8c,0x91,0x97,0x99,0x99,0x98,0x98,0x95,
0x95,0x95,0x95,0x95,0x96,0x97,0x98,0x99,0x9a,0x9a,0x98,0x90,0x89,0x80,0x76,0x6b,
0x61,0x57,0x4f,0x4a,0x44,0x3f,0x3d,0x3b,0x38,0x37,0x38,0x39,0x38,0x38,0x39,0x39,
0x3a,0x37,0x35,0x34,0x36,0x36,0x39,0x3b,0x3e,0x41,0x48,0x51,0x5b,0x64,0x6f,0x78,
0x86,0x8b,0x8f,0x92,0x95,0x96,0x99,0x98,0x96,0x95,0x95,0x95,0x93,0x92,0x92,0x93,
0x95,0x93,0x92,0x8e,0x89,0x83,0x7e,0x75,0x6b,0x63,0x5b,0x52,0x4b,0x46,0x41,0x3d,
0x39,0x37,0x38,0x38,0x37,0x36,0x39,0x39,0x3b,0x3d,0x3d,0x3b,0x3c,0x3b,0x3a,0x3b,
0x3f,0x42,0x48,0x4f,0x55,0x5f,0x6b,0x76,0x80,0x86,0x8c,0x91,0x95,0x96,0x98,0x99,
0x99,0x96,0x96,0x95,0x97,0x99,0x99,0x98,0x98,0x98,0x96,0x95,0x93,0x8d,0x86,0x7d,
0x72,0x69,0x62,0x58,0x50,0x4a,0x45,0x42,0x3f,0x3c,0x3a,0x3b,0x3d,0x3d,0x3a,0x3b,
0x3b,0x3b,0x3d,0x3c,0x3a,0x39,0x3a,0x3a,0x3d,0x3f,0x43,0x48,0x4e,0x55,0x61,0x6b,
0x76,0x80,0x8a,0x8e,0x91,0x95,0x97,0x99,0x9c,0x9c,0x9b,0x9a,0x98,0x97,0x98,0x98,
0x99,0x99,0x9a,0x98,0x94,0x8f,0x88,0x81,0x7b,0x71,0x68,0x5d,0x54,0x4d,0x47,0x42,
0x3f,0x3d,0x3c,0x3b,0x3c,0x3d,0x3f,0x3e,0x3f,0x3d,0x3c,0x3d,0x3d,0x3d,0x3f,0x3d,
0x39,0x38,0x38,0x37,0x38,0x38,0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x3b,0x3d,0x3e,
0x3c,0x3d,0x3b,0x3b,0x3b,0x3b,0x3c,0x3e,0x3c,0x3b,0x3b,0x3c,0x3d,0x3d,0x3e,0x3d,
0x3a,0x39,0x3a,0x38,0x3a,0x39,0x3b,0x3d,0x3c,0x3b,0x3c,0x3c,0x3b,0x39,0x39,0x3a,
0x39,0x37,0x36,0x37,0x3a,0x3c,0x3e,0x3e,0x3d,0x3d,0x3d,0x3d,0x3c,0x3b,0x3b,0x39,
0x38,0x37,0x36,0x37,0x37,0x36,0x37,0x3a,0x3b,0x3b,0x3b,0x3b,0x39,0x39,0x38,0x38,
0x38,0x39,0x39,0x3b,0x39,0x39,0x3b,0x3d,0x40,0x44,0x4b,0x54,0x5b,0x62,0x6a,0x75,
0x7f,0x86,0x8b,0x91,0x95,0x96,0x97,0x98,0x96,0x93,0x93,0x90,0x8f,0x91,0x93,0x95,
0x95,0x95,0x95,0x95,0x96,0x98,0x99,0x98,0x96,0x96,0x97,0x98,0x95,0x95,0x94,0x95,
0x98,0x98,0x97,0x99,0x98,0x95,0x96,0x97,0x99,0x9a,0x9a,0x9a,0x9a,0x98,0x98,0x99,
0x9b,0x9b,0x9a,0x99,0x97,0x95,0x93,0x93,0x94,0x96,0x98,0x98,0x98,0x96,0x95,0x96,
0x97,0x9a,0x9d,0x9c,0x98,0x97,0x98,0x96,0x95,0x95,0x98,0x98,0x99,0x95,0x92,0x94,
0x98,0x9a,0x9b,0x9a,0x9a,0x99,0x9b,0x99,0x97,0x98,0x9a,0x99,0x97,0x94,0x95,0x98,
0x99,0x98,0x98,0x96,0x96,0x98,0x9a,0x99,0x95,0x8e,0x87,0x7f,0x77,0x6e,0x65,0x5d,
0x56,0x4c,0x44,0x40,0x3d,0x3c,0x3a,0x39,0x39,0x3b,0x3c,0x38,0x3b,0x39,0x38,0x39,
0x38,0x36,0x37,0x36,0x35,0x37,0x38,0x39,0x3b,0x3c,0x3f,0x40,0x3f,0x3d,0x3b,0x3b,
0x3a,0x38,0x38,0x37,0x36,0x37,0x36,0x37,0x39,0x3a,0x3b,0x3c,0x3b,0x38,0x39,0x39,
0x3b,0x3b,0x3f,0x40,0x44,0x4c,0x56,0x5f,0x69,0x70,0x78,0x81,0x88,0x8d,0x90,0x94,
0x95,0x96,0x95,0x93,0x92,0x93,0x93,0x95,0x96,0x95,0x95,0x95,0x95,0x94,0x94,0x95,
0x97,0x97,0x95,0x95,0x95,0x96,0x9a,0x9c,0x9d,0x9c,0x9a,0x99,0x97,0x95,0x95,0x94,
0x94,0x95,0x93,0x92,0x92,0x93,0x93,0x94,0x95,0x92,0x8f,0x8b,0x84,0x79,0x72,0x6b,
0x64,0x5d,0x55,0x4c,0x47,0x43,0x42,0x3f,0x3f,0x3d,0x3d,0x3c,0x3c,0x3c,0x3d,0x3b,
0x3a,0x39,0x37,0x36,0x36,0x37,0x39,0x3b,0x3a,0x38,0x37,0x37,0x38,0x39,0x3b,0x3c,
0x3b,0x38,0x37,0x36,0x38,0x3a,0x3b,0x3f,0x3f,0x3b,0x39,0x39,0x39,0x38,0x38,0x38,
0x38,0x38,0x39,0x3b,0x3b,0x3f,0x45,0x4f,0x59,0x64,0x6d,0x74,0x7c,0x84,0x8b,0x8f,
0x92,0x95,0x98,0x98,0x96,0x95,0x96,0x96,0x95,0x94,0x96,0x98,0x99,0x99,0x98,0x96,
0x95,0x93,0x94,0x95,0x98,0x98,0x98,0x98,0x97,0x96,0x98,0x97,0x96,0x96,0x95,0x96,
0x97,0x96,0x95,0x98,0x99,0x99,0x98,0x98,0x98,0x99,0x99,0x98,0x98,0x99,0x9a,0x9a,
0x9a,0x98,0x96,0x97,0x96,0x95,0x96,0x96,0x96,0x94,0x92,0x92,0x95,0x96,0x98,0x98,
0x99,0x98,0x96,0x97,0x98,0x98,0x9a,0x98,0x96,0x95,0x96,0x96,0x96,0x97,0x98,0x99,
0x9a,0x9a,0x9a,0x98,0x98,0x96,0x95,0x96,0x98,0x9a,0x99,0x99,0x99,0x98,0x97,0x97,
0x96,0x94,0x93,0x91,0x8f,0x8c,0x88,0x80,0x79,0x70,0x69,0x5f,0x5a,0x4f,0x45,0x3f,
0x3b,0x39,0x38,0x39,0x38,0x39,0x39,0x3a,0x39,0x38,0x39,0x3a,0x3b,0x3a,0x38,0x39,
0x39,0x38,0x39,0x39,0x37,0x36,0x36,0x37,0x37,0x36,0x38,0x39,0x38,0x36,0x37,0x39,
0x39,0x3a,0x3b,0x39,0x38,0x39,0x3b,0x3b,0x3a,0x38,0x36,0x37,0x38,0x38,0x38,0x38,
0x38,0x38,0x38,0x39,0x3a,0x39,0x39,0x38,0x3b,0x3c,0x3d,0x3d,0x3b,0x38,0x38,0x39,
0x3a,0x39,0x38,0x37,0x36,0x37,0x39,0x3d,0x3f,0x3e,0x3d,0x3d,0x3c,0x38,0x37,0x36,
0x34,0x34,0x36,0x36,0x35,0x36,0x36,0x38,0x38,0x37,0x38,0x3b,0x3a,0x39,0x3a,0x39,
0x38,0x37,0x38,0x38,0x38,0x39,0x3b,0x3c,0x3e,0x42,0x48,0x51,0x5b,0x64,0x70,0x77,
0x7e,0x87,0x8e,0x91,0x92,0x93,0x94,0x95,0x93,0x91,0x90,0x90,0x91,0x92,0x95,0x96,
0x98,0x96,0x94,0x92,0x93,0x94,0x95,0x98,0x98,0x95,0x95,0x95,0x96,0x97,0x9c,0x9a,
0x99,0x96,0x96,0x95,0x99,0x95,0x96,0x9a,0x9a,0x98,0x99,0x99,0x98,0x97,0x96,0x94,
0x8f,0x89,0x82,0x79,0x6f,0x64,0x5c,0x55,0x4f,0x47,0x43,0x40,0x3e,0x3d,0x3b,0x3b,
0x3b,0x3b,0x3c,0x39,0x37,0x37,0x37,0x38,0x37,0x37,0x39,0x3b,0x3b,0x3c,0x3d,0x3d,
0x3c,0x3b,0x3a,0x3b,0x3d,0x3d,0x3a,0x3d,0x3b,0x38,0x38,0x38,0x37,0x3d,0x3c,0x3b,
0x3b,0x3b,0x3c,0x3d,0x3e,0x3d,0x3d,0x3e,0x3e,0x3c,0x3a,0x37,0x36,0x36,0x38,0x38,
0x3a,0x3b,0x3c,0x3d,0x3b,0x39,0x3a,0x3a,0x3b,0x3c,0x3c,0x3b,0x38,0x36,0x37,0x38,
0x3a,0x3b,0x3b,0x39,0x36,0x34,0x34,0x35,0x37,0x39,0x39,0x37,0x37,0x38,0x3a,0x3b,
0x3d,0x3e,0x3e,0x3d,0x3b,0x38,0x37,0x38,0x38,0x39,0x39,0x37,0x36,0x34,0x34,0x35,
0x36,0x38,0x3a,0x39,0x37,0x36,0x38,0x39,0x38,0x37,0x38,0x37,0x37,0x36,0x36,0x36,
0x36,0x35,0x36,0x38,0x39,0x3b,0x3b,0x39,0x38,0x39,0x38,0x38,0x3b,0x3a,0x38,0x37,
0x36,0x36,0x38,0x39,0x39,0x38,0x37,0x37,0x37,0x37,0x39,0x39,0x39,0x37,0x36,0x37,
0x37,0x39,0x3b,0x3b,0x3a,0x39,0x38,0x38,0x39,0x3b,0x3c,0x3d,0x40,0x44,0x4b,0x55,
0x5e,0x66,0x70,0x78,0x7f,0x86,0x8e,0x94,0x98,0x97,0x95,0x94,0x95,0x97,0x98,0x99,
0x99,0x99,0x98,0x95,0x93,0x93,0x94,0x95,0x96,0x94,0x93,0x93,0x92,0x91,0x93,0x95,
0x97,0x96,0x98,0x96,0x94,0x93,0x94,0x93,0x95,0x94,0x95,0x98,0x99,0x98,0x98,0x99,
0x99,0x9a,0x9a,0x9b,0x9c,0x9b,0x98,0x96,0x97,0x97,0x98,0x98,0x98,0x95,0x97,0x97,
0x96,0x96,0x96,0x97,0x98,0x98,0x98,0x98,0x98,0x97,0x97,0x99,0x99,0x99,0x9c,0x99,
0x97,0x97,0x96,0x95,0x95,0x95,0x94,0x95,0x94,0x95,0x95,0x95,0x96,0x97,0x99,0x9a,
0x9b,0x99,0x98,0x95,0x94,0x93,0x94,0x95,0x96,0x96,0x95,0x91,0x8d,0x87,0x81,0x79,
0x72,0x6b,0x62,0x58,0x50,0x49,0x43,0x40,0x3e,0x3d,0x3a,0x38,0x34,0x33,0x34,0x37,
0x38,0x3a,0x3a,0x39,0x39,0x38,0x38,0x3a,0x3a,0x38,0x37,0x34,0x33,0x33,0x35,0x36,
0x39,0x3b,0x3c,0x3b,0x39,0x37,0x37,0x39,0x3c,0x3d,0x3e,0x3a,0x38,0x38,0x39,0x3a,
0x3b,0x3a,0x37,0x37,0x36,0x35,0x35,0x37,0x38,0x37,0x35,0x35,0x34,0x36,0x37,0x36,
0x38,0x38,0x38,0x39,0x38,0x37,0x38,0x39,0x3b,0x3a,0x39,0x37,0x37,0x37,0x38,0x38,
0x3b,0x3b,0x39,0x3a,0x39,0x36,0x37,0x36,0x35,0x35,0x36,0x38,0x36,0x37,0x37,0x38,
0x3a,0x3b,0x3b,0x3b,0x39,0x36,0x36,0x34,0x33,0x33,0x34,0x35,0x37,0x38,0x39,0x37,
0x36,0x36,0x37,0x39,0x39,0x38,0x38,0x37,0x36,0x36,0x36,0x36,0x38,0x39,0x37,0x36,
0x35,0x36,0x38,0x38,0x39,0x39,0x3b,0x3b,0x37,0x38,0x38,0x38,0x3b,0x3a,0x39,0x38,
// Line 15
0x3b,0x3b,0x3a,0x3b,0x3a,0x39,0x37,0x36,0x37,0x38,0x38,0x37,0x35,0x36,0x37,0x38,
0x39,0x39,0x38,0x38,0x36,0x34,0x35,0x37,0x38,0x38,0x38,0x35,0x33,0x35,0x37,0x38,
0x37,0x37,0x38,0x3a,0x3a,0x37,0x36,0x36,0x37,0x38,0x38,0x37,0x34,0x33,0x32,0x2f,
0x31,0x33,0x37,0x3a,0x37,0x33,0x31,0x35,0x3e,0x4c,0x5d,0x6e,0x7a,0x7d,0x78,0x6c,
0x64,0x60,0x62,0x6b,0x74,0x7c,0x7e,0x78,0x6d,0x65,0x61,0x61,0x66,0x6e,0x76,0x79,
0x77,0x71,0x6b,0x65,0x61,0x63,0x69,0x70,0x75,0x78,0x76,0x6f,0x68,0x62,0x60,0x62,
0x66,0x6d,0x76,0x7b,0x7a,0x73,0x6b,0x63,0x5f,0x61,0x68,0x70,0x79,0x78,0x75,0x70,
0x68,0x61,0x5e,0x5f,0x65,0x6e,0x76,0x79,0x76,0x73,0x6a,0x62,0x60,0x63,0x6c,0x76,
0x7e,0x7e,0x79,0x72,0x6a,0x65,0x64,0x69,0x6f,0x73,0x75,0x75,0x75,0x78,0x80,0x8b,
0x98,0xa4,0xac,0xad,0xa8,0x9e,0x91,0x83,0x75,0x67,0x5d,0x58,0x52,0x4c,0x42,0x3c,
0x38,0x38,0x42,0x54,0x65,0x7b,0x88,0x91,0x97,0x98,0x99,0x9c,0x9f,0x9f,0x9d,0x96,
0x8c,0x7d,0x6c,0x60,0x5c,0x60,0x67,0x70,0x78,0x80,0x86,0x8e,0x95,0x9c,0xa4,0xa9,
0xa8,0xa4,0x9e,0x98,0x95,0x98,0x9b,0x9c,0x9b,0x93,0x83,0x72,0x62,0x59,0x5a,0x62,
0x6c,0x78,0x7b,0x7a,0x74,0x6b,0x63,0x60,0x63,0x69,0x73,0x7a,0x7c,0x78,0x71,0x69,
0x63,0x66,0x6d,0x74,0x7b,0x7c,0x79,0x73,0x6b,0x63,0x61,0x65,0x6a,0x71,0x76,0x78,
0x74,0x6d,0x67,0x60,0x5e,0x5b,0x58,0x53,0x47,0x39,0x2f,0x2a,0x2a,0x2d,0x37,0x41,
0x4c,0x59,0x64,0x6e,0x75,0x76,0x70,0x69,0x61,0x5e,0x63,0x6d,0x79,0x83,0x83,0x7c,
0x70,0x64,0x5e,0x61,0x6b,0x76,0x7c,0x7c,0x77,0x6f,0x68,0x61,0x5d,0x5e,0x5f,0x59,
0x4f,0x3f,0x32,0x28,0x2a,0x2f,0x39,0x43,0x48,0x45,0x3c,0x32,0x2d,0x36,0x49,0x61,
0x75,0x7e,0x7e,0x76,0x69,0x5b,0x51,0x4d,0x49,0x45,0x3f,0x35,0x2c,0x2b,0x2f,0x37,
0x3e,0x42,0x42,0x3f,0x38,0x31,0x2f,0x31,0x34,0x34,0x3a,0x3a,0x39,0x36,0x34,0x36,
0x3e,0x4c,0x5c,0x70,0x7e,0x82,0x7d,0x6e,0x61,0x5a,0x5c,0x67,0x73,0x7b,0x7d,0x78,
0x6f,0x67,0x63,0x67,0x70,0x77,0x7b,0x7b,0x76,0x6e,0x65,0x5f,0x5d,0x5c,0x5a,0x54,
0x4b,0x3d,0x31,0x29,0x28,0x2e,0x3a,0x42,0x44,0x43,0x3f,0x38,0x34,0x30,0x2f,0x33,
0x37,0x3a,0x39,0x37,0x34,0x33,0x37,0x40,0x4e,0x60,0x71,0x7e,0x81,0x79,0x6d,0x63,
0x5f,0x60,0x67,0x6d,0x73,0x75,0x78,0x7f,0x8b,0x9a,0xa2,0xa1,0x94,0x7f,0x67,0x58,
0x56,0x61,0x6f,0x7b,0x7f,0x7c,0x76,0x6d,0x62,0x59,0x51,0x49,0x42,0x3b,0x36,0x32,
0x2e,0x2d,0x33,0x3c,0x49,0x5a,0x69,0x73,0x79,0x76,0x6e,0x66,0x60,0x5c,0x58,0x52,
0x48,0x3d,0x37,0x37,0x3f,0x51,0x68,0x7d,0x8d,0x95,0x97,0x96,0x91,0x8b,0x7f,0x74,
0x65,0x59,0x4e,0x47,0x40,0x3f,0x3d,0x3f,0x4a,0x5b,0x6f,0x80,0x83,0x7b,0x6d,0x5e,
0x56,0x56,0x64,0x72,0x7c,0x7f,0x78,0x6d,0x64,0x5f,0x62,0x69,0x6d,0x6f,0x71,0x74,
0x78,0x81,0x8e,0x9c,0xa7,0xad,0xb0,0xad,0xa7,0x9f,0x97,0x98,0x97,0x9a,0xa1,0xa6,
0xa7,0xa6,0xa2,0x9b,0x99,0x9a,0x9d,0x9b,0x94,0x87,0x78,0x68,0x5b,0x50,0x4c,0x47,
0x42,0x41,0x3c,0x38,0x38,0x3b,0x3e,0x42,0x41,0x3c,0x35,0x31,0x31,0x3a,0x4c,0x63,
0x75,0x7f,0x7e,0x74,0x69,0x60,0x5b,0x59,0x55,0x4c,0x41,0x35,0x2e,0x2e,0x35,0x3f,
0x45,0x47,0x41,0x38,0x33,0x33,0x3a,0x47,0x55,0x65,0x76,0x83,0x8e,0x99,0x9f,0x9b,
0x91,0x80,0x70,0x64,0x5b,0x53,0x4c,0x45,0x3f,0x3b,0x42,0x51,0x66,0x7b,0x88,0x86,
0x7a,0x68,0x5a,0x53,0x5a,0x66,0x74,0x7d,0x7b,0x70,0x69,0x61,0x5c,0x5d,0x5e,0x58,
0x4c,0x3d,0x33,0x34,0x42,0x57,0x6d,0x7f,0x8c,0x96,0x9b,0x9a,0x97,0x97,0x9a,0x9c,
0x9e,0x9c,0x9c,0x9c,0x9c,0x9a,0x9a,0x9a,0x9c,0x9e,0x9d,0x93,0x86,0x78,0x6a,0x5e,
0x53,0x4b,0x45,0x43,0x40,0x3c,0x39,0x36,0x35,0x39,0x3e,0x45,0x4e,0x58,0x63,0x70,
0x7b,0x84,0x8d,0x95,0x9d,0xa3,0xa6,0xa4,0x9c,0x93,0x86,0x78,0x6b,0x61,0x58,0x4d,
0x45,0x3c,0x38,0x36,0x36,0x32,0x35,0x35,0x38,0x43,0x4f,0x5b,0x6b,0x75,0x7f,0x8a,
0x90,0x95,0x96,0x93,0x87,0x76,0x65,0x5a,0x56,0x5b,0x65,0x71,0x7f,0x8a,0x93,0x9c,
0xa2,0xa2,0x9c,0x8e,0x7b,0x69,0x5d,0x58,0x5d,0x67,0x73,0x7c,0x82,0x8a,0x93,0x9a,
0x9b,0x94,0x89,0x74,0x60,0x53,0x51,0x59,0x64,0x70,0x7a,0x85,0x8f,0x96,0x9a,0xa1,
0xa5,0xa6,0xa5,0x9f,0x95,0x88,0x79,0x6b,0x60,0x5c,0x5d,0x66,0x6f,0x76,0x7e,0x85,
0x8e,0x97,0xa0,0xa3,0x9c,0x8d,0x7a,0x67,0x5a,0x56,0x5d,0x69,0x74,0x7e,0x86,0x8d,
0x96,0x9d,0xa1,0x9d,0x8d,0x79,0x63,0x55,0x53,0x5c,0x69,0x78,0x7d,0x7b,0x73,0x69,
0x63,0x63,0x69,0x70,0x77,0x7a,0x78,0x71,0x69,0x63,0x62,0x66,0x6a,0x6f,0x73,0x73,
0x76,0x7b,0x84,0x8f,0x9c,0xa2,0x9e,0x8f,0x7a,0x64,0x55,0x55,0x5a,0x63,0x6e,0x78,
0x82,0x8d,0x93,0x96,0x97,0x91,0x84,0x70,0x5c,0x4c,0x44,0x3f,0x3c,0x35,0x34,0x32,
0x34,0x38,0x3c,0x3d,0x3c,0x3a,0x37,0x37,0x36,0x33,0x31,0x30,0x2e,0x31,0x3a,0x49,
0x5c,0x6d,0x7b,0x86,0x8e,0x95,0x9a,0x9c,0x98,0x8d,0x7d,0x6c,0x5e,0x58,0x5c,0x66,
0x73,0x7f,0x89,0x8e,0x91,0x96,0x9b,0xa2,0xa4,0xa0,0x98,0x8a,0x7d,0x6f,0x63,0x59,
0x52,0x4c,0x47,0x41,0x3d,0x3a,0x39,0x3a,0x39,0x3a,0x3f,0x44,0x4d,0x5a,0x65,0x71,
0x7f,0x8a,0x91,0x96,0x9b,0x9d,0xa0,0xa2,0xa3,0x9a,0x93,0x85,0x73,0x67,0x61,0x63,
0x6d,0x76,0x7e,0x7e,0x77,0x6d,0x65,0x61,0x62,0x67,0x6e,0x74,0x77,0x78,0x7a,0x81,
0x8e,0x99,0x9f,0x9a,0x8b,0x77,0x65,0x59,0x56,0x5f,0x6c,0x78,0x83,0x8c,0x93,0x97,
0x9e,0x9f,0x98,0x89,0x73,0x60,0x55,0x53,0x5b,0x69,0x76,0x7d,0x7b,0x72,0x67,0x5f,
0x5a,0x55,0x50,0x48,0x3f,0x35,0x30,0x2d,0x2e,0x35,0x3e,0x47,0x52,0x5e,0x69,0x74,
0x7f,0x89,0x91,0x9a,0x9d,0x97,0x8a,0x78,0x69,0x5f,0x5b,0x5c,0x67,0x73,0x7f,0x8b,
0x94,0x9a,0x9e,0x9b,0x92,0x83,0x71,0x60,0x54,0x4b,0x43,0x3d,0x3a,0x3c,0x42,0x50,
0x62,0x73,0x80,0x83,0x7d,0x70,0x63,0x5c,0x5d,0x64,0x6d,0x71,0x79,0x7c,0x83,0x8e,
0x98,0xa0,0xa8,0xaa,0xa6,0x9e,0x95,0x8b,0x7d,0x70,0x65,0x5f,0x62,0x6a,0x72,0x7e,
0x83,0x85,0x8b,0x90,0x97,0xa0,0xa5,0xa4,0x9e,0x96,0x90,0x8f,0x93,0x96,0x97,0x92,
0x87,0x78,0x6b,0x5e,0x55,0x4f,0x47,0x3e,0x38,0x37,0x3e,0x4e,0x62,0x75,0x82,0x84,
0x7c,0x6f,0x62,0x5c,0x60,0x6a,0x76,0x7e,0x7e,0x77,0x69,0x5c,0x57,0x5b,0x66,0x73,
0x7a,0x7a,0x76,0x6d,0x65,0x62,0x64,0x66,0x63,0x58,0x49,0x3a,0x31,0x31,0x3e,0x53,
0x69,0x7e,0x8d,0x95,0x97,0x97,0x98,0x9c,0xa1,0xa3,0x9f,0x95,0x85,0x75,0x69,0x5d,
0x54,0x4c,0x45,0x3f,0x3a,0x35,0x33,0x33,0x38,0x3a,0x3b,0x3a,0x38,0x34,0x38,0x37,
0x36,0x36,0x36,0x36,0x3a,0x3e,0x49,0x57,0x65,0x73,0x81,0x8d,0x94,0x9a,0x9f,0xa4,
0xa9,0xa9,0xa4,0x9b,0x90,0x81,0x73,0x67,0x61,0x61,0x67,0x6b,0x70,0x76,0x7f,0x8a,
0x92,0x97,0x9a,0x92,0x87,0x73,0x5f,0x51,0x48,0x42,0x42,0x40,0x3e,0x3b,0x37,0x34,
0x36,0x3c,0x45,0x51,0x5c,0x67,0x73,0x7f,0x8a,0x93,0x9c,0x9e,0x98,0x89,0x76,0x65,
0x5c,0x5c,0x64,0x70,0x7c,0x83,0x81,0x79,0x6d,0x64,0x5f,0x5d,0x5f,0x65,0x6d,0x73,
0x7b,0x83,0x8b,0x97,0xa2,0xa8,0xab,0xa8,0x9f,0x95,0x88,0x7b,0x6d,0x64,0x60,0x60,
0x65,0x6d,0x76,0x7d,0x83,0x89,0x91,0x97,0x9e,0xa2,0xa2,0x9e,0x97,0x8e,0x83,0x78,
0x6b,0x5f,0x55,0x4f,0x47,0x40,0x3d,0x3a,0x39,0x37,0x35,0x37,0x3d,0x48,0x55,0x65,
0x73,0x7b,0x7c,0x77,0x6a,0x5e,0x5a,0x5c,0x64,0x73,0x79,0x7b,0x76,0x6b,0x62,0x5d,
0x60,0x69,0x76,0x7d,0x7e,0x79,0x71,0x69,0x63,0x65,0x6b,0x71,0x77,0x78,0x78,0x7a,
0x7d,0x83,0x8e,0x99,0x9f,0x9b,0x8e,0x79,0x63,0x54,0x52,0x5b,0x6b,0x7a,0x83,0x80,
0x78,0x6c,0x63,0x5b,0x55,0x4e,0x45,0x3a,0x31,0x2b,0x2b,0x2e,0x34,0x37,0x38,0x39,
0x37,0x34,0x32,0x33,0x34,0x37,0x39,0x3a,0x3c,0x3a,0x36,0x34,0x35,0x3a,0x45,0x54,
0x63,0x73,0x82,0x8e,0x97,0x9c,0x98,0x90,0x85,0x76,0x68,0x5c,0x53,0x49,0x40,0x3a,
0x3a,0x41,0x50,0x63,0x74,0x7e,0x7c,0x73,0x66,0x58,0x50,0x4f,0x4e,0x49,0x42,0x37,
0x2e,0x2b,0x31,0x3a,0x3f,0x44,0x3f,0x35,0x2e,0x2d,0x34,0x45,0x55,0x66,0x78,0x84,
0x8d,0x95,0x9a,0x9f,0xa4,0xa5,0xa4,0xa2,0xa0,0x9e,0x9a,0x9a,0x9c,0x9e,0x9f,0x9f,
0x9e,0x9b,0x95,0x8a,0x7a,0x69,0x5c,0x58,0x5c,0x67,0x74,0x7c,0x7e,0x78,0x70,0x66,
0x5e,0x59,0x57,0x4f,0x45,0x39,0x32,0x33,0x41,0x56,0x70,0x85,0x93,0x98,0x9b,0x98,
0x93,0x8e,0x86,0x79,0x68,0x56,0x48,0x42,0x3e,0x3e,0x3c,0x39,0x33,0x31,0x31,0x37,
0x42,0x53,0x62,0x6e,0x74,0x73,0x6f,0x6a,0x64,0x5e,0x59,0x51,0x47,0x3d,0x35,0x36,
0x3f,0x51,0x69,0x7e,0x8e,0x96,0x99,0x9a,0x99,0x9b,0xa1,0xa2,0xa1,0xa0,0x9f,0x9e,
0x9e,0x9d,0x9d,0x9f,0xa2,0xa2,0x9e,0x97,0x8c,0x7e,0x6f,0x62,0x5a,0x59,0x5f,0x69,
0x74,0x7c,0x84,0x8b,0x95,0x9c,0xa4,0xa8,0xa9,0xa4,0x9e,0x99,0x97,0x98,0x9b,0x9e,
0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x9a,0x9a,0x98,0x93,0x8a,0x7b,0x70,0x62,0x55,
// Line 16
0x38,0x38,0x38,0x38,0x39,0x39,0x39,0x3a,0x3b,0x39,0x39,0x38,0x37,0x37,0x38,0x39,
0x38,0x37,0x38,0x36,0x35,0x34,0x36,0x39,0x3b,0x3a,0x3b,0x3a,0x39,0x38,0x38,0x39,
0x3a,0x3a,0x39,0x36,0x34,0x34,0x34,0x36,0x37,0x38,0x38,0x38,0x36,0x35,0x34,0x34,
0x34,0x35,0x38,0x37,0x38,0x35,0x30,0x30,0x37,0x44,0x59,0x6c,0x7a,0x7f,0x79,0x6e,
0x62,0x5d,0x61,0x6a,0x72,0x78,0x79,0x73,0x68,0x5f,0x5a,0x5b,0x61,0x6b,0x72,0x74,
0x73,0x6d,0x66,0x5f,0x5b,0x5f,0x68,0x6f,0x73,0x74,0x74,0x70,0x6a,0x63,0x60,0x61,
0x67,0x6d,0x71,0x76,0x74,0x6c,0x66,0x60,0x5e,0x61,0x66,0x6c,0x72,0x76,0x76,0x70,
0x69,0x60,0x5c,0x5c,0x62,0x69,0x71,0x74,0x74,0x6f,0x66,0x5e,0x5a,0x5c,0x64,0x6f,
0x76,0x79,0x76,0x6f,0x66,0x60,0x61,0x63,0x67,0x6e,0x6f,0x6e,0x70,0x73,0x7b,0x87,
0x94,0xa0,0xa9,0xad,0xab,0xa0,0x94,0x83,0x73,0x66,0x5c,0x56,0x51,0x4b,0x42,0x3b,
0x37,0x38,0x42,0x51,0x63,0x76,0x86,0x91,0x95,0x95,0x96,0x98,0x9d,0x9f,0x9d,0x97,
0x8a,0x79,0x69,0x5c,0x55,0x58,0x61,0x6c,0x76,0x7a,0x79,0x71,0x6b,0x62,0x60,0x66,
0x6e,0x74,0x78,0x78,0x71,0x69,0x60,0x5d,0x60,0x65,0x6b,0x6d,0x6d,0x6f,0x74,0x7c,
0x87,0x95,0xa4,0xac,0xa9,0xa2,0x98,0x93,0x93,0x95,0x98,0x9a,0x94,0x88,0x79,0x6b,
0x5e,0x54,0x4c,0x43,0x39,0x34,0x32,0x3a,0x4e,0x63,0x74,0x81,0x7f,0x74,0x69,0x5e,
0x58,0x56,0x52,0x4b,0x40,0x37,0x38,0x44,0x5b,0x71,0x81,0x83,0x79,0x68,0x5b,0x51,
0x4d,0x4a,0x45,0x3d,0x35,0x30,0x30,0x36,0x3c,0x3d,0x3c,0x38,0x32,0x2f,0x33,0x34,
0x32,0x30,0x2e,0x30,0x3a,0x49,0x5c,0x70,0x7c,0x7f,0x77,0x6b,0x62,0x62,0x64,0x69,
0x6d,0x72,0x76,0x7a,0x81,0x8b,0x97,0xa3,0xac,0xad,0xa9,0xa0,0x93,0x84,0x76,0x66,
0x5a,0x52,0x4c,0x48,0x42,0x3a,0x34,0x30,0x2f,0x30,0x36,0x3e,0x41,0x40,0x3c,0x38,
0x35,0x3b,0x48,0x5b,0x6f,0x7b,0x7b,0x72,0x62,0x56,0x54,0x5c,0x69,0x77,0x7e,0x7d,
0x77,0x6d,0x67,0x65,0x66,0x61,0x57,0x4a,0x39,0x2f,0x2f,0x39,0x4d,0x66,0x7b,0x8b,
0x94,0x95,0x94,0x91,0x8b,0x82,0x73,0x67,0x56,0x4a,0x40,0x3c,0x3b,0x3f,0x3e,0x3b,
0x39,0x38,0x3c,0x44,0x4f,0x5c,0x6b,0x76,0x78,0x72,0x68,0x5e,0x5a,0x60,0x6a,0x76,
0x7b,0x79,0x73,0x6b,0x64,0x62,0x62,0x5f,0x57,0x4a,0x3b,0x32,0x33,0x40,0x55,0x6c,
0x81,0x90,0x97,0x9f,0x9d,0x9a,0x94,0x86,0x73,0x62,0x59,0x57,0x61,0x6f,0x7c,0x81,
0x7c,0x72,0x67,0x63,0x61,0x5e,0x57,0x49,0x38,0x2e,0x31,0x40,0x59,0x70,0x80,0x82,
0x79,0x6a,0x5e,0x59,0x5d,0x64,0x6c,0x73,0x79,0x7f,0x87,0x91,0x9d,0xa1,0x9d,0x90,
0x7b,0x67,0x59,0x54,0x57,0x60,0x6d,0x7a,0x87,0x93,0x9b,0xa0,0x9c,0x91,0x83,0x74,
0x63,0x55,0x4b,0x43,0x3b,0x36,0x35,0x3c,0x4b,0x60,0x74,0x80,0x81,0x77,0x6a,0x5c,
0x56,0x5b,0x68,0x74,0x7b,0x79,0x73,0x69,0x63,0x5f,0x5e,0x59,0x55,0x48,0x39,0x30,
0x2b,0x2a,0x30,0x34,0x3a,0x45,0x53,0x62,0x6f,0x78,0x78,0x73,0x69,0x60,0x5c,0x60,
0x66,0x6d,0x73,0x78,0x7a,0x7f,0x87,0x94,0xa2,0xab,0xae,0xab,0xa0,0x91,0x81,0x72,
0x67,0x60,0x5c,0x55,0x4b,0x40,0x38,0x37,0x3f,0x4d,0x62,0x75,0x80,0x80,0x78,0x6a,
0x5d,0x55,0x50,0x4a,0x3e,0x35,0x30,0x34,0x45,0x5c,0x73,0x82,0x85,0x7c,0x6e,0x5f,
0x56,0x51,0x4c,0x43,0x3b,0x34,0x34,0x3d,0x4f,0x65,0x78,0x87,0x90,0x94,0x96,0x94,
0x8d,0x84,0x78,0x69,0x5d,0x56,0x58,0x62,0x6e,0x79,0x84,0x8e,0x96,0x9b,0x9c,0x95,
0x85,0x76,0x65,0x54,0x48,0x3f,0x36,0x31,0x31,0x38,0x48,0x5b,0x6b,0x78,0x7a,0x70,
0x62,0x57,0x54,0x53,0x50,0x49,0x40,0x3a,0x34,0x30,0x31,0x36,0x3e,0x46,0x4c,0x53,
0x5c,0x69,0x78,0x85,0x8c,0x91,0x95,0xa0,0xa6,0xa7,0xa4,0x9a,0x8b,0x7b,0x6c,0x60,
0x5c,0x5c,0x61,0x66,0x6b,0x72,0x7c,0x87,0x91,0x9a,0x9f,0xa2,0xa4,0xa5,0xa2,0x98,
0x8b,0x7a,0x6c,0x64,0x5e,0x5c,0x5e,0x67,0x6d,0x72,0x7a,0x84,0x8c,0x97,0x9b,0x9f,
0xa2,0xa2,0xa0,0x9c,0x98,0x96,0x99,0x9d,0xa1,0xa3,0xa3,0xa0,0x9d,0x9b,0x9b,0x9c,
0x9e,0x9d,0x9b,0x9a,0x9a,0x9b,0x9c,0x96,0x8b,0x7c,0x69,0x59,0x53,0x56,0x60,0x6e,
0x78,0x7a,0x74,0x70,0x68,0x60,0x5e,0x5b,0x54,0x4b,0x3c,0x34,0x35,0x41,0x58,0x71,
0x81,0x85,0x7e,0x6f,0x5e,0x55,0x58,0x62,0x6f,0x78,0x79,0x73,0x68,0x5f,0x59,0x58,
0x57,0x52,0x4b,0x3f,0x34,0x2d,0x2e,0x32,0x39,0x40,0x49,0x4f,0x5a,0x65,0x72,0x7e,
0x87,0x8f,0x94,0x94,0x8e,0x80,0x73,0x62,0x53,0x47,0x40,0x3c,0x3d,0x3e,0x3d,0x3c,
0x3c,0x3c,0x40,0x43,0x4b,0x54,0x61,0x71,0x7f,0x89,0x91,0x97,0x9b,0x9e,0xa0,0xa0,
0x9c,0x93,0x87,0x76,0x68,0x5d,0x55,0x4f,0x49,0x42,0x3b,0x37,0x38,0x40,0x50,0x65,
0x76,0x81,0x8a,0x91,0x94,0x98,0x9d,0xa0,0xa0,0xa0,0xa0,0x9f,0x9c,0x9b,0x9a,0x96,
0x8e,0x80,0x70,0x60,0x52,0x49,0x40,0x39,0x36,0x36,0x35,0x33,0x2f,0x2f,0x36,0x42,
0x53,0x62,0x6f,0x76,0x76,0x70,0x66,0x5d,0x59,0x54,0x4e,0x46,0x3d,0x35,0x35,0x3f,
0x50,0x67,0x7d,0x8c,0x93,0x95,0x96,0x97,0x9b,0xa1,0xa4,0xa3,0x9c,0x8f,0x81,0x72,
0x66,0x5e,0x5b,0x5c,0x62,0x6c,0x78,0x83,0x8a,0x91,0x96,0x9c,0xa1,0xa3,0xa4,0xa1,
0x97,0x89,0x79,0x6b,0x62,0x5d,0x5b,0x5f,0x65,0x6b,0x6f,0x7a,0x83,0x8c,0x96,0x9d,
0xa2,0xa5,0xa3,0x9e,0x95,0x89,0x7b,0x6d,0x63,0x5c,0x5b,0x5e,0x66,0x6d,0x76,0x7f,
0x88,0x94,0x9c,0xa2,0xa5,0xa8,0xa7,0xa2,0x97,0x8b,0x7d,0x6d,0x61,0x5b,0x5d,0x64,
0x6c,0x73,0x78,0x7e,0x86,0x8e,0x96,0x9c,0x99,0x8c,0x79,0x63,0x55,0x53,0x5b,0x68,
0x76,0x7e,0x7e,0x76,0x69,0x5e,0x57,0x54,0x4f,0x46,0x3c,0x30,0x29,0x29,0x2e,0x36,
0x3c,0x40,0x40,0x3c,0x36,0x30,0x2d,0x32,0x35,0x37,0x3b,0x3b,0x38,0x37,0x34,0x31,
0x37,0x42,0x54,0x66,0x73,0x7e,0x89,0x93,0x9a,0x99,0x92,0x86,0x76,0x67,0x59,0x4f,
0x46,0x3e,0x37,0x35,0x39,0x46,0x5b,0x70,0x7e,0x81,0x79,0x6b,0x5c,0x55,0x5a,0x66,
0x73,0x78,0x74,0x6f,0x64,0x5b,0x59,0x59,0x57,0x52,0x48,0x3b,0x31,0x2c,0x2e,0x32,
0x37,0x3c,0x43,0x4f,0x5a,0x64,0x6e,0x77,0x81,0x8a,0x93,0x9b,0xa1,0xa4,0xa2,0x9e,
0x9b,0x99,0x98,0x99,0x99,0x95,0x8f,0x82,0x70,0x60,0x53,0x49,0x40,0x3a,0x38,0x39,
0x38,0x36,0x35,0x36,0x38,0x41,0x4c,0x5b,0x6b,0x74,0x74,0x6d,0x64,0x5d,0x5b,0x60,
0x68,0x6f,0x73,0x76,0x78,0x81,0x90,0x9d,0xa3,0xa2,0x94,0x7e,0x69,0x58,0x51,0x55,
0x5f,0x6b,0x77,0x80,0x88,0x91,0x9a,0xa0,0xa3,0xa3,0xa3,0xa0,0x9d,0x99,0x98,0x9a,
0x9c,0x9d,0x9f,0xa0,0xa0,0x9d,0x99,0x97,0x97,0x97,0x97,0x94,0x8e,0x81,0x6e,0x5f,
0x56,0x58,0x62,0x6e,0x78,0x81,0x7e,0x74,0x6b,0x63,0x61,0x63,0x67,0x6b,0x6e,0x70,
0x76,0x7d,0x88,0x95,0xa2,0xad,0xaf,0xad,0xa5,0x9c,0x96,0x96,0x98,0x9b,0x9b,0x94,
0x86,0x73,0x60,0x55,0x55,0x5f,0x6d,0x78,0x7e,0x79,0x70,0x64,0x5c,0x5b,0x5b,0x54,
0x47,0x38,0x30,0x32,0x40,0x57,0x71,0x82,0x86,0x7a,0x69,0x5b,0x53,0x4f,0x50,0x4c,
0x42,0x39,0x30,0x2d,0x32,0x3b,0x43,0x46,0x41,0x38,0x2e,0x2f,0x37,0x47,0x5c,0x6e,
0x77,0x7b,0x74,0x68,0x5f,0x57,0x50,0x4c,0x45,0x3d,0x34,0x2e,0x2d,0x30,0x38,0x3f,
0x43,0x44,0x3f,0x37,0x32,0x32,0x3e,0x4f,0x61,0x70,0x7d,0x86,0x8c,0x92,0x99,0xa0,
0xa6,0xa7,0xa4,0xa1,0x9f,0x9e,0xa0,0xa5,0xa5,0xa3,0xa2,0x9e,0x9a,0x9a,0x9a,0x98,
0x9a,0x9a,0x9a,0x99,0x99,0x9c,0xa0,0x9d,0x94,0x84,0x72,0x62,0x58,0x55,0x59,0x62,
0x6d,0x76,0x7e,0x87,0x90,0x98,0x9d,0x9b,0x90,0x7f,0x6d,0x5c,0x53,0x54,0x5d,0x69,
0x76,0x81,0x89,0x91,0x94,0x98,0x9f,0xa2,0xa3,0x9d,0x97,0x8a,0x7b,0x6e,0x62,0x5c,
0x5b,0x62,0x6e,0x79,0x7b,0x78,0x71,0x67,0x5f,0x5d,0x60,0x66,0x6b,0x6c,0x6f,0x76,
0x81,0x8c,0x97,0x9b,0x96,0x87,0x75,0x61,0x50,0x44,0x3d,0x38,0x37,0x35,0x34,0x33,
0x38,0x39,0x3b,0x3c,0x3a,0x35,0x38,0x39,0x3f,0x4e,0x60,0x70,0x79,0x79,0x71,0x63,
0x56,0x51,0x59,0x64,0x6f,0x76,0x74,0x6d,0x65,0x5f,0x5e,0x60,0x61,0x5a,0x4d,0x3e,
0x34,0x34,0x40,0x54,0x6a,0x7b,0x87,0x8c,0x8f,0x92,0x97,0x9b,0xa0,0x9f,0x9d,0x9b,
0x9a,0x9c,0xa1,0x9f,0x97,0x8c,0x7d,0x6e,0x62,0x5a,0x51,0x48,0x3f,0x37,0x34,0x3a,
0x48,0x5d,0x73,0x81,0x81,0x78,0x6b,0x5f,0x57,0x52,0x4d,0x44,0x39,0x32,0x32,0x3d,
0x4f,0x65,0x7d,0x8b,0x91,0x94,0x93,0x92,0x90,0x87,0x78,0x68,0x5c,0x58,0x5c,0x6b,
0x76,0x7d,0x7d,0x76,0x6b,0x61,0x5c,0x5d,0x63,0x69,0x6e,0x72,0x77,0x80,0x8a,0x95,
0x9f,0xa7,0xab,0xa8,0x9f,0x91,0x7f,0x6f,0x62,0x5a,0x56,0x54,0x4d,0x40,0x38,0x32,
0x35,0x47,0x5e,0x74,0x7d,0x81,0x78,0x69,0x5d,0x57,0x53,0x4f,0x47,0x3d,0x37,0x37,
0x3e,0x50,0x66,0x7a,0x8a,0x91,0x95,0x97,0x98,0x9b,0xa0,0xa2,0xa2,0xa0,0x9d,0x9c,
0x9b,0x9a,0x94,0x87,0x78,0x67,0x59,0x4f,0x47,0x42,0x3a,0x37,0x32,0x31,0x35,0x39,
0x3c,0x3c,0x3a,0x35,0x32,0x2e,0x2f,0x32,0x35,0x35,0x36,0x37,0x38,0x38,0x38,0x39,
0x38,0x37,0x37,0x38,0x38,0x34,0x34,0x36,0x36,0x35,0x35,0x36,0x37,0x39,0x39,0x3a,
// Line 17
0x37,0x37,0x36,0x35,0x37,0x37,0x37,0x37,0x36,0x36,0x34,0x34,0x34,0x34,0x37,0x36,
0x36,0x37,0x36,0x35,0x37,0x38,0x39,0x38,0x38,0x37,0x37,0x37,0x37,0x37,0x38,0x38,
0x38,0x37,0x37,0x36,0x37,0x36,0x35,0x34,0x33,0x34,0x35,0x37,0x38,0x37,0x38,0x37,
0x35,0x37,0x37,0x37,0x38,0x35,0x33,0x34,0x3c,0x4a,0x5d,0x6f,0x7b,0x80,0x7c,0x72,
0x66,0x60,0x61,0x69,0x75,0x7b,0x7b,0x76,0x6d,0x62,0x5f,0x61,0x68,0x6f,0x76,0x78,
0x76,0x70,0x6a,0x65,0x62,0x63,0x68,0x70,0x77,0x7b,0x7b,0x76,0x6a,0x61,0x5f,0x62,
0x6a,0x73,0x79,0x7c,0x78,0x70,0x68,0x62,0x60,0x61,0x6a,0x72,0x78,0x7a,0x76,0x6d,
0x66,0x60,0x5e,0x60,0x67,0x6e,0x74,0x77,0x74,0x6e,0x66,0x60,0x60,0x64,0x6d,0x77,
0x7f,0x7f,0x7a,0x73,0x6c,0x66,0x64,0x68,0x6d,0x71,0x73,0x71,0x70,0x76,0x7e,0x87,
0x93,0x9f,0xa7,0xaa,0xa5,0x9a,0x8e,0x7e,0x70,0x64,0x5d,0x56,0x50,0x4a,0x44,0x3e,
0x3c,0x3e,0x47,0x59,0x6c,0x7e,0x8b,0x92,0x95,0x96,0x99,0x9d,0x9f,0x9f,0x9d,0x97,
0x8d,0x7e,0x6d,0x5f,0x59,0x5c,0x65,0x70,0x7a,0x82,0x80,0x76,0x6d,0x64,0x63,0x67,
0x71,0x77,0x79,0x76,0x6f,0x68,0x63,0x61,0x64,0x6a,0x6e,0x70,0x70,0x72,0x75,0x7d,
0x89,0x97,0xa4,0xab,0xab,0xa6,0xa1,0x9c,0x99,0x9a,0x9c,0x9c,0x96,0x88,0x78,0x69,
0x5c,0x50,0x48,0x41,0x3b,0x36,0x36,0x40,0x53,0x68,0x79,0x80,0x7f,0x72,0x62,0x59,
0x54,0x52,0x4e,0x46,0x3a,0x34,0x38,0x48,0x5f,0x75,0x85,0x8a,0x81,0x6f,0x60,0x59,
0x5c,0x62,0x6c,0x73,0x78,0x7e,0x84,0x8e,0x9a,0xa4,0xab,0xab,0xa3,0x98,0x8b,0x7e,
0x71,0x64,0x5a,0x50,0x47,0x43,0x41,0x3e,0x3d,0x3a,0x39,0x39,0x3c,0x40,0x47,0x53,
0x5e,0x6b,0x76,0x7f,0x86,0x8d,0x95,0x9d,0xa4,0xa5,0xa2,0xa0,0x9c,0x9a,0x9c,0x9f,
0xa3,0xa1,0x96,0x85,0x73,0x65,0x5e,0x5c,0x5e,0x64,0x6f,0x79,0x83,0x8c,0x95,0x9b,
0x9a,0x90,0x80,0x6f,0x5d,0x4f,0x46,0x40,0x3b,0x38,0x3a,0x43,0x55,0x69,0x7d,0x86,
0x85,0x7b,0x6d,0x61,0x59,0x54,0x51,0x4a,0x3f,0x35,0x36,0x42,0x57,0x6c,0x84,0x90,
0x96,0x97,0x95,0x90,0x8d,0x82,0x74,0x64,0x51,0x43,0x3b,0x3d,0x3d,0x3c,0x3b,0x38,
0x36,0x34,0x3a,0x46,0x55,0x63,0x71,0x79,0x7b,0x73,0x69,0x5f,0x5d,0x61,0x6b,0x75,
0x7c,0x7c,0x75,0x69,0x60,0x5d,0x63,0x6d,0x74,0x75,0x75,0x75,0x7a,0x86,0x96,0xa3,
0xa7,0x9f,0x8e,0x7a,0x66,0x58,0x56,0x5b,0x64,0x6e,0x78,0x83,0x8d,0x96,0x9d,0xa0,
0xa2,0xa3,0xa4,0xa2,0xa0,0x9d,0x9f,0x9f,0xa0,0xa1,0xa1,0xa1,0x9f,0x9d,0x9b,0x97,
0x98,0x99,0x9a,0x96,0x8e,0x80,0x72,0x63,0x59,0x59,0x62,0x70,0x7b,0x82,0x80,0x77,
0x6c,0x63,0x61,0x68,0x72,0x7b,0x80,0x7e,0x78,0x6d,0x66,0x63,0x67,0x6f,0x76,0x78,
0x78,0x77,0x7a,0x84,0x90,0x9b,0xa2,0x9e,0x8e,0x77,0x5f,0x51,0x50,0x5d,0x6b,0x76,
0x7a,0x77,0x6f,0x68,0x60,0x59,0x55,0x4d,0x41,0x3a,0x34,0x38,0x45,0x5a,0x70,0x80,
0x8e,0x93,0x97,0x9b,0x9b,0x92,0x88,0x77,0x66,0x5b,0x58,0x5e,0x6a,0x75,0x7c,0x7b,
0x72,0x66,0x60,0x60,0x67,0x72,0x7a,0x7d,0x79,0x71,0x67,0x5f,0x60,0x63,0x62,0x5b,
0x4d,0x3c,0x31,0x31,0x41,0x5b,0x77,0x8a,0x8d,0x82,0x70,0x5e,0x58,0x5f,0x6d,0x7d,
0x83,0x80,0x76,0x69,0x60,0x5e,0x5f,0x5e,0x56,0x48,0x38,0x30,0x34,0x48,0x61,0x7a,
0x8a,0x8b,0x82,0x72,0x64,0x5d,0x5d,0x63,0x6a,0x70,0x76,0x7a,0x80,0x88,0x94,0xa1,
0xaa,0xab,0xa8,0xa2,0x9c,0x9c,0x9d,0x9f,0x9c,0x98,0x8e,0x81,0x6d,0x5b,0x4d,0x48,
0x41,0x3e,0x3e,0x3d,0x38,0x37,0x34,0x33,0x38,0x43,0x53,0x66,0x73,0x77,0x75,0x6d,
0x66,0x60,0x5a,0x55,0x4f,0x46,0x3c,0x37,0x37,0x45,0x5d,0x77,0x89,0x8b,0x81,0x70,
0x60,0x58,0x59,0x63,0x71,0x7b,0x7f,0x79,0x6e,0x62,0x5d,0x63,0x6a,0x71,0x78,0x7a,
0x76,0x6f,0x64,0x5e,0x5e,0x60,0x5f,0x57,0x4a,0x3a,0x30,0x30,0x3d,0x52,0x69,0x7e,
0x8d,0x97,0x9b,0x9a,0x96,0x8f,0x85,0x79,0x6b,0x60,0x5d,0x60,0x66,0x6f,0x78,0x83,
0x8c,0x95,0x9b,0xa2,0xa8,0xa9,0xa4,0x9f,0x96,0x93,0x96,0x9b,0x9c,0x98,0x90,0x81,
0x6f,0x60,0x5a,0x5c,0x6a,0x74,0x7c,0x7e,0x78,0x70,0x69,0x63,0x5e,0x58,0x4d,0x40,
0x31,0x2e,0x35,0x49,0x62,0x79,0x85,0x84,0x77,0x67,0x5c,0x55,0x50,0x4a,0x41,0x37,
0x32,0x37,0x47,0x60,0x76,0x83,0x85,0x7b,0x6a,0x5a,0x52,0x4e,0x4b,0x47,0x3d,0x33,
0x30,0x2d,0x2f,0x35,0x3c,0x44,0x4c,0x54,0x5d,0x6d,0x7c,0x89,0x90,0x96,0x9a,0xa0,
0xa7,0xab,0xa7,0x9e,0x8e,0x7a,0x6c,0x62,0x5f,0x62,0x69,0x6f,0x76,0x7a,0x80,0x89,
0x93,0x9b,0x9e,0x99,0x8a,0x73,0x5f,0x53,0x52,0x5b,0x6a,0x76,0x7d,0x78,0x6d,0x61,
0x58,0x55,0x54,0x50,0x45,0x39,0x2f,0x2a,0x2d,0x36,0x40,0x46,0x47,0x41,0x39,0x32,
0x31,0x37,0x43,0x52,0x62,0x70,0x7c,0x86,0x8e,0x97,0x9d,0xa0,0xa1,0xa2,0xa0,0x97,
0x89,0x77,0x66,0x59,0x4f,0x49,0x46,0x43,0x3e,0x37,0x30,0x2d,0x30,0x36,0x3a,0x40,
0x3c,0x35,0x34,0x34,0x3c,0x4b,0x60,0x73,0x7d,0x7c,0x74,0x63,0x5b,0x57,0x5c,0x68,
0x72,0x78,0x7e,0x81,0x88,0x93,0x9f,0xa4,0xa1,0x92,0x7d,0x69,0x5a,0x56,0x5b,0x68,
0x75,0x7f,0x86,0x8d,0x92,0x99,0xa0,0xa2,0xa3,0xa0,0x9b,0x98,0x96,0x95,0x97,0x98,
0x96,0x8f,0x84,0x72,0x63,0x5b,0x5a,0x61,0x6e,0x78,0x7c,0x7b,0x72,0x66,0x5e,0x5d,
0x64,0x71,0x7a,0x7d,0x77,0x6e,0x64,0x5e,0x5d,0x5a,0x56,0x4d,0x41,0x35,0x2e,0x2a,
0x2d,0x32,0x39,0x41,0x4b,0x58,0x68,0x76,0x7c,0x7a,0x72,0x68,0x60,0x5e,0x65,0x6d,
0x74,0x78,0x78,0x7c,0x83,0x8d,0x9a,0xa2,0x9f,0x90,0x78,0x62,0x53,0x4e,0x56,0x63,
0x71,0x7e,0x86,0x8d,0x94,0x9a,0xa1,0xa5,0xa7,0xa5,0xa0,0x97,0x8b,0x7b,0x6f,0x64,
0x5d,0x5c,0x60,0x66,0x6d,0x74,0x7b,0x84,0x8d,0x95,0x9d,0xa5,0xa7,0xa5,0xa1,0x9d,
0x9a,0x99,0x9a,0x9b,0x9e,0xa0,0xa1,0x9f,0x9a,0x96,0x96,0x98,0x99,0x97,0x92,0x8a,
0x7e,0x6e,0x60,0x57,0x58,0x61,0x6f,0x7a,0x7f,0x7e,0x78,0x6f,0x67,0x64,0x67,0x6c,
0x70,0x72,0x73,0x78,0x80,0x8d,0x9a,0xa8,0xad,0xaa,0xa6,0x9e,0x97,0x95,0x95,0x96,
0x9a,0x9e,0xa1,0xa1,0xa0,0x9e,0x9f,0xa1,0xa2,0xa2,0xa1,0x9b,0x8d,0x7e,0x6d,0x60,
0x5b,0x5c,0x62,0x6b,0x73,0x7d,0x85,0x8d,0x95,0x9b,0x99,0x8f,0x7c,0x6c,0x57,0x47,
0x3e,0x3a,0x39,0x3d,0x3a,0x35,0x33,0x32,0x34,0x38,0x41,0x4d,0x5c,0x6a,0x77,0x83,
0x8e,0x95,0x99,0x9a,0x95,0x8b,0x7c,0x6b,0x5c,0x57,0x5b,0x66,0x75,0x82,0x8c,0x92,
0x96,0x99,0x9c,0x9f,0xa1,0xa1,0x9d,0x94,0x88,0x7b,0x6b,0x60,0x5e,0x62,0x69,0x72,
0x7a,0x7c,0x78,0x70,0x65,0x5d,0x5f,0x65,0x6d,0x75,0x78,0x77,0x72,0x6a,0x63,0x63,
0x64,0x69,0x6b,0x6a,0x6c,0x72,0x79,0x83,0x8e,0x9c,0xa7,0xad,0xae,0xa8,0xa1,0x9d,
0x99,0x97,0x98,0x9c,0x9f,0xa0,0x9e,0x9a,0x99,0x97,0x97,0x95,0x97,0x96,0x98,0x9b,
0x9d,0x9d,0x9c,0x95,0x89,0x7b,0x6d,0x60,0x57,0x4d,0x45,0x40,0x3a,0x39,0x3d,0x48,
0x57,0x68,0x7a,0x86,0x8e,0x93,0x97,0x9a,0x9d,0x9f,0x9d,0x99,0x90,0x84,0x77,0x6b,
0x5e,0x52,0x4c,0x46,0x42,0x3e,0x3b,0x37,0x36,0x34,0x36,0x3c,0x45,0x52,0x5d,0x69,
0x73,0x7e,0x88,0x90,0x96,0x98,0x92,0x86,0x74,0x63,0x5a,0x5b,0x65,0x72,0x7e,0x83,
0x80,0x76,0x6a,0x61,0x5e,0x5c,0x56,0x4a,0x3c,0x31,0x31,0x3d,0x51,0x68,0x7e,0x8a,
0x8e,0x8f,0x91,0x94,0x9b,0x9e,0x9f,0x9f,0x9d,0x9b,0x9b,0x9e,0xa1,0xa1,0xa1,0xa1,
0x9f,0xa1,0x9b,0x92,0x84,0x72,0x62,0x5a,0x59,0x61,0x6e,0x79,0x7f,0x7a,0x6e,0x60,
0x58,0x5a,0x62,0x6d,0x76,0x79,0x77,0x72,0x6a,0x64,0x63,0x62,0x5e,0x57,0x4a,0x3c,
0x32,0x33,0x3f,0x52,0x69,0x7e,0x8c,0x96,0x97,0x95,0x97,0x9a,0x9d,0xa1,0xa1,0x9f,
0x9c,0x9a,0x99,0x99,0x9b,0x9e,0xa1,0xa3,0xa0,0x96,0x88,0x78,0x69,0x5e,0x57,0x50,
0x49,0x40,0x38,0x36,0x3c,0x4b,0x60,0x75,0x82,0x83,0x78,0x68,0x5a,0x57,0x5f,0x6c,
0x7a,0x81,0x7f,0x76,0x6a,0x60,0x5e,0x60,0x5d,0x51,0x45,0x37,0x2e,0x33,0x43,0x5c,
0x72,0x7f,0x81,0x78,0x69,0x5a,0x52,0x4d,0x48,0x43,0x3c,0x33,0x2d,0x2c,0x31,0x3a,
0x41,0x41,0x3e,0x39,0x36,0x37,0x40,0x4e,0x5c,0x6b,0x77,0x83,0x8d,0x93,0x99,0x95,
0x8e,0x80,0x6f,0x5f,0x51,0x46,0x46,0x43,0x3d,0x3a,0x37,0x35,0x37,0x3b,0x3f,0x41,
0x3e,0x37,0x30,0x30,0x38,0x49,0x60,0x73,0x7f,0x81,0x78,0x6b,0x62,0x60,0x64,0x6d,
0x75,0x78,0x7b,0x7f,0x85,0x8d,0x95,0x9a,0x98,0x8b,0x77,0x60,0x4f,0x45,0x40,0x41,
0x43,0x41,0x3e,0x38,0x34,0x35,0x3a,0x43,0x4b,0x58,0x64,0x72,0x7f,0x8a,0x95,0x9d,
0xa0,0x99,0x8b,0x78,0x67,0x5d,0x5c,0x61,0x6d,0x78,0x80,0x7d,0x73,0x66,0x5d,0x58,
0x53,0x4d,0x45,0x39,0x2e,0x2a,0x2c,0x32,0x3a,0x40,0x40,0x3e,0x3a,0x37,0x33,0x36,
0x36,0x35,0x35,0x37,0x3d,0x4d,0x5a,0x69,0x76,0x80,0x88,0x8e,0x96,0x9d,0xa4,0xa7,
0xa4,0x9c,0x91,0x85,0x77,0x6c,0x63,0x5a,0x51,0x48,0x40,0x3c,0x37,0x34,0x34,0x35,
0x37,0x39,0x3a,0x3a,0x38,0x34,0x30,0x2e,0x31,0x32,0x33,0x34,0x33,0x33,0x33,0x35,
0x38,0x3b,0x3b,0x38,0x38,0x38,0x3b,0x3b,0x3e,0x3d,0x3d,0x3d,0x3a,0x37,0x38,0x39,
// Line 18
0x34,0x34,0x35,0x35,0x35,0x35,0x34,0x33,0x34,0x35,0x37,0x38,0x38,0x37,0x37,0x37,
0x36,0x38,0x39,0x39,0x3b,0x3c,0x3a,0x38,0x39,0x39,0x38,0x38,0x37,0x39,0x3b,0x3b,
0x39,0x39,0x3d,0x41,0x44,0x48,0x4b,0x4f,0x51,0x51,0x52,0x54,0x58,0x5b,0x5e,0x5d,
0x5c,0x59,0x5a,0x5a,0x5c,0x5d,0x5e,0x5b,0x5c,0x59,0x57,0x5a,0x5c,0x5c,0x5b,0x59,
0x56,0x56,0x56,0x59,0x5b,0x5c,0x5a,0x57,0x57,0x57,0x59,0x5c,0x5c,0x5c,0x5c,0x59,
0x57,0x56,0x57,0x5a,0x5c,0x5b,0x5a,0x59,0x58,0x56,0x56,0x57,0x59,0x59,0x5b,0x5b,
0x5a,0x5a,0x5a,0x5a,0x5b,0x5b,0x5a,0x59,0x57,0x56,0x54,0x53,0x54,0x56,0x59,0x59,
0x58,0x56,0x56,0x54,0x55,0x55,0x56,0x58,0x57,0x56,0x55,0x54,0x56,0x57,0x58,0x58,
0x58,0x58,0x58,0x57,0x57,0x56,0x58,0x5a,0x5c,0x5b,0x5a,0x58,0x56,0x56,0x56,0x57,
0x58,0x59,0x59,0x58,0x57,0x57,0x58,0x5a,0x5a,0x59,0x59,0x59,0x58,0x59,0x59,0x5a,
0x5a,0x5b,0x5b,0x5b,0x5a,0x5a,0x5a,0x5b,0x5a,0x59,0x5a,0x5b,0x5c,0x5d,0x5d,0x5d,
0x5c,0x59,0x58,0x59,0x59,0x5a,0x58,0x59,0x57,0x56,0x58,0x5a,0x5b,0x5d,0x5c,0x5b,
0x5b,0x59,0x59,0x59,0x5a,0x5a,0x5b,0x5b,0x5b,0x59,0x58,0x57,0x57,0x58,0x59,0x5a,
0x5c,0x5a,0x59,0x59,0x59,0x5a,0x5c,0x5c,0x5c,0x5b,0x58,0x57,0x57,0x59,0x5c,0x5d,
0x5d,0x5e,0x5e,0x5f,0x5c,0x5a,0x5c,0x5d,0x5c,0x5b,0x59,0x57,0x57,0x57,0x57,0x56,
0x55,0x56,0x58,0x5a,0x5b,0x5a,0x59,0x57,0x56,0x57,0x57,0x58,0x59,0x57,0x56,0x56,
0x56,0x56,0x58,0x59,0x59,0x58,0x58,0x59,0x5a,0x5a,0x5c,0x5a,0x5b,0x5b,0x5d,0x60,
0x5f,0x5e,0x5d,0x5a,0x59,0x56,0x57,0x56,0x55,0x57,0x59,0x59,0x58,0x57,0x58,0x5a,
0x5a,0x58,0x58,0x57,0x57,0x58,0x58,0x5a,0x5a,0x59,0x59,0x57,0x57,0x59,0x5c,0x5f,
0x5e,0x5a,0x58,0x57,0x59,0x5d,0x60,0x63,0x61,0x59,0x51,0x4a,0x51,0x5f,0x71,0x82,
0x89,0x86,0x7c,0x6d,0x63,0x63,0x68,0x6a,0x67,0x5d,0x52,0x4c,0x4b,0x51,0x5c,0x66,
0x6a,0x66,0x5f,0x58,0x55,0x56,0x58,0x59,0x5a,0x5a,0x5a,0x5c,0x5b,0x59,0x59,0x59,
0x59,0x59,0x5a,0x5c,0x5d,0x5d,0x5b,0x59,0x57,0x57,0x59,0x5c,0x5c,0x5a,0x5c,0x5c,
0x5c,0x5d,0x5d,0x5a,0x58,0x56,0x56,0x57,0x57,0x57,0x56,0x58,0x57,0x56,0x59,0x5a,
0x5a,0x59,0x57,0x56,0x57,0x5c,0x5f,0x5f,0x5b,0x58,0x57,0x58,0x59,0x5b,0x5c,0x5b,
0x58,0x57,0x58,0x5a,0x5c,0x5e,0x5f,0x5f,0x5d,0x5c,0x5d,0x5e,0x5f,0x5c,0x5a,0x59,
0x5a,0x59,0x59,0x59,0x5a,0x5c,0x5c,0x5d,0x5d,0x5e,0x5f,0x5e,0x5c,0x58,0x58,0x59,
0x5a,0x5c,0x5a,0x59,0x59,0x58,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x59,0x5a,0x5a,
0x59,0x5b,0x5c,0x5c,0x5c,0x5b,0x5a,0x59,0x57,0x56,0x59,0x5b,0x5d,0x5c,0x5a,0x59,
0x5a,0x5b,0x5c,0x5b,0x5b,0x5b,0x5c,0x5a,0x58,0x56,0x59,0x5a,0x59,0x5a,0x5a,0x5a,
0x5a,0x59,0x58,0x58,0x59,0x5c,0x5d,0x5c,0x5a,0x59,0x5c,0x5c,0x5c,0x5c,0x5e,0x5c,
0x5c,0x5d,0x5e,0x5e,0x5d,0x5d,0x5f,0x5f,0x5c,0x58,0x59,0x58,0x58,0x59,0x59,0x58,
0x5a,0x59,0x57,0x56,0x56,0x58,0x5d,0x5e,0x5c,0x59,0x59,0x59,0x59,0x5b,0x5d,0x5d,
0x5d,0x5b,0x57,0x56,0x56,0x57,0x59,0x5a,0x5c,0x5a,0x57,0x55,0x56,0x58,0x5a,0x5a,
0x5a,0x5a,0x5a,0x5c,0x5a,0x59,0x5a,0x5a,0x59,0x59,0x57,0x57,0x56,0x57,0x56,0x57,
0x56,0x58,0x5a,0x5a,0x59,0x59,0x5a,0x5a,0x5a,0x5b,0x5c,0x5a,0x5a,0x5a,0x5a,0x59,
0x56,0x56,0x59,0x5c,0x5b,0x5a,0x5a,0x59,0x59,0x5a,0x5b,0x5a,0x5c,0x59,0x58,0x59,
0x59,0x5a,0x5b,0x5d,0x5c,0x5b,0x5a,0x5a,0x5a,0x59,0x5a,0x5a,0x5b,0x5b,0x5a,0x5a,
0x57,0x53,0x50,0x4e,0x4d,0x4b,0x47,0x43,0x44,0x46,0x48,0x48,0x47,0x48,0x49,0x48,
0x45,0x42,0x43,0x46,0x47,0x47,0x42,0x41,0x43,0x46,0x45,0x44,0x43,0x44,0x42,0x43,
0x41,0x3f,0x42,0x46,0x48,0x48,0x47,0x45,0x46,0x47,0x48,0x48,0x44,0x43,0x44,0x44,
0x44,0x43,0x43,0x44,0x47,0x4a,0x49,0x48,0x48,0x49,0x48,0x48,0x45,0x44,0x44,0x43,
0x41,0x3f,0x41,0x44,0x44,0x47,0x46,0x44,0x46,0x48,0x49,0x4b,0x4a,0x49,0x4a,0x48,
0x47,0x47,0x46,0x44,0x43,0x42,0x43,0x43,0x44,0x43,0x45,0x47,0x46,0x44,0x45,0x48,
0x47,0x46,0x45,0x44,0x44,0x44,0x44,0x47,0x48,0x48,0x46,0x46,0x45,0x45,0x45,0x44,
0x44,0x45,0x45,0x44,0x45,0x46,0x47,0x47,0x47,0x46,0x48,0x48,0x49,0x49,0x48,0x47,
0x47,0x48,0x4a,0x49,0x49,0x48,0x47,0x47,0x46,0x44,0x47,0x48,0x48,0x47,0x47,0x46,
0x44,0x43,0x43,0x45,0x47,0x48,0x47,0x46,0x46,0x44,0x46,0x47,0x47,0x48,0x46,0x44,
0x45,0x44,0x46,0x48,0x49,0x49,0x48,0x47,0x47,0x48,0x4b,0x50,0x54,0x5d,0x66,0x6f,
0x7a,0x85,0x90,0x9c,0xa4,0xab,0xaf,0xb0,0xb0,0xb1,0xb2,0xb3,0xb4,0xb3,0xb1,0xb0,
0xb1,0xb1,0xb2,0xb6,0xb4,0xb4,0xb5,0xb4,0xb3,0xaf,0xaf,0xaf,0xb0,0xaf,0xaf,0xae,
0xad,0xac,0xae,0xb0,0xb1,0xb1,0xb3,0xb1,0xaf,0xae,0xae,0xb0,0xb1,0xb2,0xb3,0xb4,
0xb4,0xb4,0xb3,0xb4,0xb2,0xb3,0xb4,0xb3,0xb0,0xaf,0xae,0xad,0xae,0xb0,0xb3,0xb1,
0xb0,0xad,0xac,0xae,0xaf,0xb0,0xb2,0xb3,0xb2,0xb2,0xb3,0xb4,0xb4,0xb3,0xb1,0xb2,
0xb0,0xaf,0xb0,0xb0,0xae,0xad,0xb0,0xb0,0xb0,0xb0,0xb2,0xb3,0xb4,0xb2,0xb1,0xb2,
0xb2,0xb2,0xb3,0xb3,0xb3,0xb1,0xb1,0xb0,0xb1,0xb2,0xb3,0xb0,0xb0,0xae,0xaf,0xb1,
0xb2,0xb3,0xb4,0xb4,0xb1,0xb0,0xb0,0xb2,0xb2,0xb2,0xb0,0xae,0xad,0xad,0xad,0xaf,
0xaf,0xb0,0xb3,0xb3,0xb1,0xb0,0xaf,0xb0,0xb0,0xb0,0xb0,0xb1,0xb0,0xae,0xae,0xaf,
0xb0,0xb0,0xb1,0xb1,0xb0,0xb1,0xb1,0xb3,0xb4,0xb2,0xb1,0xb1,0xb0,0xaf,0xad,0xae,
0xae,0xaf,0xb0,0xb0,0xb1,0xb1,0xb2,0xb0,0xaf,0xac,0xab,0xaa,0xa6,0xa3,0xa1,0xa0,
0xa0,0xa0,0x9e,0x9d,0x9e,0xa0,0xa0,0xa0,0xa0,0xa0,0x9f,0xa0,0xa0,0xa0,0xa3,0xa3,
0xa3,0xa3,0xa1,0xa0,0xa1,0xa2,0xa2,0xa0,0xa0,0xa0,0x9f,0x9c,0x9a,0x9b,0x9f,0xa0,
0x9e,0x9d,0x9d,0x9c,0x9b,0x9b,0x9b,0x99,0x9c,0x9c,0x9c,0x9e,0x9d,0x9c,0x9e,0x9e,
0x9e,0xa0,0xa0,0x9f,0x9f,0x9e,0x9d,0x9c,0x9d,0x9f,0xa3,0xa2,0xa0,0x9f,0xa0,0x9e,
0x9f,0x9f,0xa2,0xa3,0xa4,0xa3,0xa3,0xa0,0x9f,0x9e,0xa0,0xa1,0xa1,0xa0,0xa2,0xa0,
0x9f,0x9f,0xa0,0xa0,0xa2,0xa1,0xa1,0xa3,0xa3,0xa0,0xa0,0xa0,0xa0,0xa1,0xa2,0xa3,
0xa3,0xa2,0xa0,0x9e,0x9e,0x9e,0x9f,0xa0,0xa0,0x9e,0xa0,0xa0,0x9f,0x9e,0x9e,0x9f,
0xa1,0xa1,0xa3,0xa3,0xa2,0xa0,0x9f,0xa0,0xa1,0xa1,0xa4,0xa3,0xa0,0xa0,0xa0,0x9e,
0x9f,0x9f,0xa0,0xa1,0xa0,0xa1,0xa1,0xa1,0xa0,0xa1,0xa3,0xa3,0xa2,0x9f,0x9d,0x9c,
0x9e,0xa0,0xa3,0xa3,0xa3,0xa0,0xa0,0x9f,0xa0,0xa1,0xa3,0xa2,0x9f,0x9e,0x9d,0x9e,
0xa0,0xa0,0xa1,0xa3,0xa2,0xa0,0xa0,0xa0,0xa1,0xa4,0xa4,0xa4,0xa3,0xa2,0xa1,0xa0,
0xa1,0xa1,0xa0,0x9e,0x9c,0x9a,0x9d,0x9e,0xa0,0xa0,0xa1,0xa1,0xa1,0xa1,0xa2,0xa3,
0xa0,0x9f,0x9d,0x9c,0x9d,0x9f,0xa0,0xa0,0x9e,0x9f,0x9f,0xa0,0xa0,0xa1,0xa1,0xa3,
0xa2,0x9f,0x9d,0x9d,0x9d,0x9f,0xa1,0xa1,0x9f,0xa0,0x9e,0x9c,0x9e,0xa0,0xa0,0xa2,
0xa1,0xa0,0xa0,0x9e,0x9e,0x9f,0xa0,0xa0,0xa0,0xa0,0xa2,0xa1,0xa0,0x9e,0x9f,0xa0,
0xa1,0xa0,0xa0,0xa0,0x9f,0x9e,0x9f,0x9f,0xa0,0xa1,0xa1,0xa1,0xa1,0xa0,0xa0,0xa3,
0xa3,0xa1,0xa1,0xa0,0x9f,0xa0,0x9e,0xa0,0xa3,0xa4,0xa4,0xa0,0x9d,0x9a,0x9c,0xa1,
0xa3,0xa3,0x9e,0x92,0x81,0x73,0x6d,0x6f,0x78,0x82,0x89,0x8e,0x8f,0x91,0x95,0x9c,
0xa5,0xab,0xae,0xab,0xa5,0x9e,0x9b,0x9a,0x9f,0xa3,0xa6,0xa6,0xa3,0x9f,0x9e,0x9c,
0x9c,0x9c,0x9d,0x9d,0x9d,0x9f,0x9f,0x9f,0xa0,0x9e,0x9e,0x9f,0xa0,0xa0,0xa1,0xa0,
0xa0,0xa1,0xa0,0xa1,0xa1,0xa2,0xa1,0xa0,0xa1,0xa2,0xa3,0xa3,0xa3,0xa0,0x9f,0x9e,
0x9f,0xa0,0xa0,0xa0,0xa0,0x9f,0x9f,0xa0,0xa1,0xa2,0xa1,0x9f,0x9d,0x9c,0x9c,0x9c,
0x9c,0x9e,0x9e,0x9c,0x9b,0x9a,0x9c,0x9f,0xa0,0x9e,0x9e,0x9e,0x9f,0x9f,0xa0,0xa1,
0xa0,0xa3,0x9e,0x9b,0x9c,0x9d,0x9c,0x9c,0x9c,0x9c,0x9e,0x9f,0xa2,0xa1,0xa3,0xa3,
0xa5,0xa5,0xa6,0xa6,0xa5,0xa2,0xa0,0xa0,0x9e,0x9e,0x9e,0x9d,0x9e,0xa0,0xa1,0xa1,
0xa0,0xa0,0xa0,0xa0,0xa0,0xa1,0xa2,0xa3,0xa0,0x9c,0x9d,0x9e,0x9f,0xa0,0x9f,0x9d,
0x9c,0x9c,0x9c,0x9c,0x9f,0xa0,0xa2,0xa1,0xa0,0x9f,0xa0,0x9f,0x9f,0xa0,0x9f,0x9d,
0x9e,0x9a,0x99,0x9b,0x9e,0xa0,0x9f,0xa1,0xa2,0xa3,0xa2,0xa1,0xa2,0xa1,0xa1,0xa1,
0xa0,0xa0,0xa0,0xa0,0xa0,0x9f,0x9f,0xa0,0xa1,0xa0,0x9f,0x9d,0x9e,0x9e,0x9f,0x9f,
0x9f,0x9d,0x9e,0xa0,0xa0,0x9f,0x9e,0x9d,0x9e,0xa0,0xa0,0x9f,0xa0,0x9e,0x9d,0x9c,
0x9c,0x9d,0x9e,0xa0,0x9f,0x9c,0x9c,0x9c,0x9d,0x9f,0x9e,0x9d,0x9f,0x9f,0x9f,0x9e,
0x9f,0xa0,0xa1,0xa1,0xa0,0x9f,0xa0,0xa2,0xa0,0x9f,0x9f,0x9d,0x9d,0x9d,0x9e,0xa0,
0x9f,0x9d,0x9c,0x9c,0x9b,0x9c,0x9d,0x9f,0x9e,0x9d,0x9d,0x9e,0xa0,0xa1,0xa1,0xa3,
0xa3,0xa0,0xa0,0xa1,0xa1,0x9d,0x9d,0x9c,0x9c,0x9d,0x9e,0x9d,0x9e,0x9d,0x9d,0x9e,
0x9d,0x9d,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa1,0xa1,0xa1,0x9f,0x9d,0x9c,0x9c,0x9d,
0x9a,0x96,0x92,0x8b,0x83,0x79,0x6f,0x65,0x5b,0x50,0x47,0x3f,0x39,0x35,0x34,0x34,
// Line 19
0x35,0x38,0x39,0x38,0x35,0x33,0x35,0x35,0x36,0x36,0x37,0x36,0x37,0x36,0x36,0x36,
0x36,0x36,0x36,0x39,0x39,0x3a,0x3a,0x3a,0x3b,0x3d,0x40,0x45,0x4a,0x4f,0x53,0x57,
0x5a,0x5f,0x64,0x67,0x65,0x65,0x64,0x64,0x64,0x62,0x62,0x63,0x62,0x5f,0x5d,0x60,
0x5e,0x60,0x62,0x62,0x60,0x5f,0x5f,0x60,0x63,0x66,0x67,0x65,0x62,0x62,0x62,0x63,
0x65,0x65,0x66,0x64,0x62,0x60,0x60,0x62,0x65,0x66,0x65,0x62,0x62,0x62,0x61,0x61,
0x62,0x61,0x62,0x60,0x5d,0x5c,0x5e,0x61,0x64,0x64,0x64,0x63,0x61,0x5f,0x60,0x63,
0x66,0x63,0x63,0x60,0x60,0x60,0x62,0x61,0x63,0x63,0x62,0x60,0x5e,0x5e,0x60,0x60,
0x60,0x60,0x61,0x62,0x61,0x61,0x61,0x60,0x60,0x5f,0x5f,0x60,0x5f,0x5f,0x60,0x5e,
0x5d,0x5d,0x5c,0x5b,0x5f,0x62,0x63,0x62,0x62,0x61,0x63,0x64,0x64,0x64,0x64,0x65,
0x62,0x61,0x61,0x61,0x62,0x62,0x60,0x5f,0x5d,0x5e,0x5d,0x5d,0x5b,0x5d,0x60,0x60,
0x5e,0x5d,0x5d,0x5e,0x60,0x5f,0x5f,0x5e,0x5c,0x59,0x5a,0x5c,0x5e,0x5e,0x5c,0x5a,
0x59,0x58,0x58,0x57,0x58,0x58,0x57,0x57,0x54,0x52,0x51,0x52,0x50,0x50,0x50,0x51,
0x51,0x50,0x4e,0x4e,0x50,0x50,0x4e,0x4e,0x4d,0x4b,0x4b,0x48,0x48,0x49,0x48,0x44,
0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x3f,0x3d,0x3c,0x3d,0x3e,0x3e,0x3c,0x3a,
0x36,0x33,0x31,0x34,0x35,0x36,0x32,0x33,0x31,0x30,0x31,0x33,0x31,0x32,0x33,0x32,
0x31,0x2f,0x30,0x32,0x33,0x34,0x37,0x3a,0x3d,0x3f,0x41,0x42,0x43,0x46,0x4a,0x4d,
0x50,0x51,0x52,0x55,0x57,0x5d,0x65,0x6b,0x6f,0x73,0x77,0x7a,0x7d,0x80,0x83,0x86,
0x8a,0x8d,0x8f,0x91,0x93,0x95,0x97,0x97,0x97,0x96,0x94,0x93,0x90,0x8d,0x8a,0x87,
0x81,0x7d,0x7a,0x78,0x72,0x6b,0x65,0x5f,0x59,0x54,0x4e,0x49,0x45,0x41,0x3a,0x35,
0x31,0x30,0x2d,0x2b,0x2a,0x29,0x2d,0x2f,0x31,0x35,0x37,0x3b,0x43,0x4a,0x52,0x5a,
0x63,0x69,0x6f,0x76,0x7f,0x87,0x8f,0x92,0x94,0x95,0x94,0x93,0x92,0x8f,0x8c,0x8a,
0x84,0x79,0x70,0x68,0x5d,0x55,0x4f,0x4a,0x43,0x3c,0x37,0x35,0x33,0x32,0x32,0x31,
0x32,0x33,0x39,0x3e,0x44,0x4b,0x55,0x5b,0x62,0x6c,0x77,0x7f,0x88,0x8f,0x94,0x96,
0x93,0x8f,0x8b,0x84,0x7d,0x75,0x6b,0x61,0x56,0x4e,0x45,0x3d,0x35,0x32,0x32,0x33,
0x32,0x34,0x3a,0x3e,0x43,0x4a,0x55,0x63,0x72,0x7d,0x86,0x8c,0x8f,0x90,0x8f,0x8c,
0x86,0x7d,0x72,0x65,0x5a,0x51,0x49,0x42,0x3d,0x38,0x35,0x35,0x38,0x3b,0x3f,0x49,
0x51,0x5b,0x67,0x75,0x81,0x8e,0x90,0x8f,0x8d,0x88,0x7f,0x78,0x6b,0x5f,0x54,0x4a,
0x3f,0x36,0x32,0x32,0x34,0x3a,0x41,0x48,0x51,0x5d,0x6a,0x79,0x84,0x8c,0x90,0x8d,
0x86,0x7d,0x72,0x67,0x5b,0x4f,0x44,0x39,0x32,0x30,0x30,0x36,0x3c,0x46,0x55,0x65,
0x73,0x81,0x8a,0x90,0x91,0x8d,0x85,0x78,0x69,0x5a,0x4c,0x41,0x36,0x2e,0x2d,0x30,
0x35,0x41,0x50,0x62,0x72,0x80,0x89,0x8d,0x8b,0x84,0x7b,0x6f,0x62,0x56,0x4b,0x3f,
0x36,0x30,0x30,0x37,0x46,0x58,0x6a,0x79,0x83,0x89,0x8c,0x89,0x80,0x74,0x67,0x58,
0x4a,0x3e,0x36,0x32,0x34,0x3a,0x47,0x5b,0x6e,0x7e,0x8a,0x8d,0x8a,0x81,0x75,0x68,
0x5b,0x4d,0x43,0x3b,0x38,0x39,0x41,0x51,0x65,0x75,0x84,0x8c,0x8c,0x85,0x76,0x66,
0x5a,0x4e,0x41,0x37,0x33,0x36,0x41,0x53,0x67,0x78,0x89,0x8c,0x87,0x7f,0x73,0x65,
0x58,0x4a,0x3e,0x39,0x38,0x3f,0x4e,0x62,0x74,0x81,0x86,0x85,0x7d,0x6f,0x62,0x54,
0x49,0x3f,0x39,0x3a,0x40,0x4f,0x65,0x78,0x84,0x88,0x82,0x76,0x67,0x58,0x4c,0x40,
0x3d,0x3c,0x3f,0x4c,0x5c,0x6e,0x80,0x89,0x85,0x7b,0x6b,0x58,0x49,0x3e,0x3c,0x3f,
0x48,0x54,0x63,0x73,0x7d,0x7c,0x77,0x6c,0x60,0x50,0x42,0x3a,0x3d,0x46,0x52,0x61,
0x6f,0x7b,0x81,0x7e,0x70,0x5f,0x50,0x45,0x3e,0x3e,0x43,0x4d,0x5c,0x6c,0x77,0x7c,
0x78,0x6f,0x62,0x54,0x49,0x46,0x4b,0x57,0x64,0x6f,0x76,0x78,0x76,0x6f,0x63,0x57,
0x4b,0x46,0x48,0x51,0x5b,0x65,0x6f,0x73,0x74,0x6e,0x63,0x57,0x4f,0x4b,0x4d,0x54,
0x5e,0x67,0x72,0x72,0x6d,0x64,0x5a,0x52,0x4d,0x4b,0x4e,0x59,0x67,0x71,0x77,0x75,
0x6d,0x63,0x59,0x53,0x51,0x54,0x5b,0x62,0x68,0x6b,0x6a,0x66,0x60,0x58,0x54,0x51,
0x53,0x5a,0x63,0x6b,0x6e,0x6c,0x65,0x5f,0x59,0x57,0x55,0x57,0x5d,0x63,0x68,0x68,
0x65,0x61,0x5d,0x59,0x57,0x58,0x5e,0x63,0x67,0x67,0x62,0x5e,0x55,0x53,0x57,0x5b,
0x5f,0x62,0x63,0x61,0x5e,0x5b,0x58,0x57,0x58,0x5d,0x62,0x65,0x67,0x66,0x60,0x57,
0x4e,0x4d,0x51,0x59,0x62,0x69,0x6c,0x6b,0x63,0x58,0x51,0x52,0x57,0x5f,0x6a,0x71,
0x72,0x6c,0x5d,0x4d,0x48,0x4c,0x59,0x6a,0x75,0x78,0x72,0x63,0x50,0x44,0x44,0x4f,
0x61,0x71,0x7a,0x78,0x6c,0x5b,0x4a,0x44,0x4a,0x59,0x6c,0x78,0x7a,0x71,0x5f,0x4d,
0x44,0x46,0x55,0x69,0x7c,0x82,0x77,0x64,0x48,0x38,0x3a,0x4b,0x63,0x79,0x80,0x78,
0x64,0x4c,0x3c,0x3d,0x52,0x6d,0x80,0x86,0x7b,0x63,0x4b,0x3c,0x40,0x55,0x70,0x83,
0x84,0x70,0x54,0x3d,0x35,0x42,0x5d,0x78,0x86,0x82,0x6e,0x51,0x3c,0x3b,0x4e,0x69,
0x80,0x88,0x7a,0x5e,0x43,0x35,0x41,0x5c,0x78,0x86,0x81,0x6a,0x4a,0x34,0x35,0x4e,
0x6f,0x86,0x89,0x76,0x57,0x3c,0x36,0x49,0x66,0x81,0x8a,0x7d,0x5e,0x40,0x37,0x45,
0x63,0x7f,0x8a,0x7e,0x60,0x42,0x39,0x46,0x62,0x7d,0x86,0x7a,0x60,0x45,0x3b,0x45,
0x63,0x7e,0x87,0x79,0x5e,0x44,0x3d,0x4b,0x65,0x7e,0x83,0x71,0x54,0x3d,0x3a,0x50,
0x6e,0x83,0x83,0x6e,0x53,0x41,0x47,0x5e,0x79,0x88,0x80,0x65,0x4a,0x3e,0x4a,0x64,
0x7a,0x7f,0x70,0x57,0x44,0x43,0x58,0x70,0x7d,0x79,0x64,0x4b,0x41,0x4b,0x61,0x77,
0x7d,0x6f,0x58,0x48,0x49,0x5b,0x72,0x7d,0x75,0x61,0x4d,0x46,0x52,0x67,0x77,0x79,
0x6a,0x55,0x4c,0x53,0x63,0x74,0x76,0x6b,0x59,0x4e,0x51,0x5f,0x6e,0x76,0x6f,0x60,
0x50,0x4f,0x5e,0x6d,0x75,0x70,0x64,0x57,0x54,0x5a,0x66,0x70,0x70,0x65,0x55,0x4f,
0x54,0x60,0x6a,0x69,0x61,0x59,0x55,0x59,0x64,0x6c,0x6f,0x68,0x5c,0x55,0x59,0x65,
0x6e,0x6d,0x67,0x5e,0x59,0x5c,0x64,0x6b,0x6b,0x64,0x5a,0x55,0x57,0x60,0x68,0x69,
0x64,0x5d,0x5b,0x5d,0x62,0x66,0x68,0x65,0x5e,0x5a,0x5b,0x62,0x69,0x69,0x68,0x62,
0x5f,0x60,0x64,0x67,0x67,0x63,0x60,0x5d,0x5d,0x60,0x63,0x67,0x63,0x5e,0x5f,0x5e,
0x5f,0x63,0x63,0x62,0x5d,0x5b,0x59,0x5d,0x60,0x62,0x5f,0x5f,0x5d,0x5e,0x63,0x66,
0x65,0x64,0x61,0x60,0x60,0x62,0x63,0x64,0x62,0x60,0x62,0x65,0x67,0x68,0x68,0x65,
0x63,0x63,0x65,0x66,0x67,0x65,0x61,0x5f,0x5f,0x5f,0x60,0x61,0x60,0x5f,0x5f,0x5f,
0x5f,0x60,0x61,0x61,0x61,0x60,0x60,0x64,0x63,0x60,0x60,0x60,0x60,0x61,0x62,0x61,
0x61,0x5f,0x60,0x60,0x60,0x5f,0x60,0x61,0x62,0x61,0x61,0x61,0x63,0x64,0x64,0x64,
0x64,0x63,0x64,0x65,0x65,0x65,0x65,0x64,0x63,0x63,0x63,0x62,0x60,0x60,0x62,0x62,
0x60,0x5f,0x5f,0x60,0x61,0x61,0x61,0x61,0x62,0x62,0x61,0x60,0x62,0x65,0x64,0x62,
0x61,0x60,0x61,0x62,0x63,0x63,0x65,0x64,0x62,0x62,0x62,0x63,0x62,0x62,0x61,0x60,
0x60,0x60,0x5f,0x61,0x5f,0x5e,0x5f,0x5f,0x5f,0x60,0x60,0x5e,0x5d,0x5d,0x5f,0x62,
0x62,0x62,0x61,0x61,0x62,0x62,0x64,0x66,0x65,0x65,0x63,0x62,0x62,0x63,0x66,0x66,
0x65,0x62,0x61,0x60,0x5f,0x5f,0x62,0x62,0x5f,0x5e,0x5d,0x5c,0x5e,0x5f,0x60,0x61,
0x61,0x60,0x62,0x62,0x63,0x62,0x63,0x61,0x60,0x62,0x63,0x63,0x63,0x62,0x60,0x60,
0x60,0x60,0x60,0x60,0x5f,0x5f,0x5d,0x5e,0x60,0x60,0x61,0x62,0x63,0x63,0x61,0x5f,
0x5f,0x60,0x62,0x62,0x63,0x64,0x63,0x63,0x64,0x65,0x67,0x66,0x64,0x60,0x5e,0x5e,
0x5d,0x5d,0x5f,0x5f,0x60,0x60,0x61,0x62,0x65,0x63,0x61,0x61,0x60,0x61,0x61,0x62,
0x61,0x60,0x62,0x62,0x61,0x64,0x64,0x64,0x64,0x61,0x60,0x60,0x61,0x62,0x62,0x62,
0x61,0x5f,0x5f,0x5f,0x61,0x64,0x64,0x63,0x61,0x60,0x60,0x61,0x62,0x63,0x63,0x62,
0x61,0x60,0x61,0x63,0x63,0x62,0x60,0x60,0x60,0x60,0x5e,0x61,0x5f,0x5f,0x61,0x60,
0x60,0x60,0x62,0x60,0x5f,0x5e,0x60,0x61,0x61,0x60,0x60,0x62,0x61,0x60,0x61,0x60,
0x61,0x61,0x60,0x60,0x60,0x5f,0x5f,0x60,0x61,0x62,0x62,0x62,0x62,0x60,0x60,0x60,
0x62,0x62,0x60,0x5f,0x5e,0x5e,0x5f,0x60,0x61,0x60,0x62,0x62,0x62,0x60,0x62,0x61,
0x60,0x60,0x61,0x60,0x60,0x60,0x60,0x63,0x63,0x62,0x61,0x61,0x60,0x60,0x61,0x62,
0x63,0x63,0x63,0x62,0x63,0x63,0x62,0x61,0x61,0x61,0x63,0x61,0x60,0x60,0x60,0x5d,
0x5b,0x5b,0x5b,0x5b,0x59,0x54,0x4f,0x4b,0x46,0x43,0x41,0x40,0x3d,0x3b,0x39,0x36,
0x33,0x32,0x32,0x34,0x36,0x36,0x37,0x36,0x35,0x34,0x37,0x39,0x39,0x39,0x38,0x37,
0x38,0x37,0x36,0x36,0x35,0x32,0x32,0x34,0x35,0x37,0x39,0x39,0x38,0x36,0x34,0x34,
0x37,0x36,0x37,0x37,0x36,0x35,0x34,0x36,0x37,0x38,0x38,0x37,0x37,0x37,0x37,0x37,
0x39,0x38,0x38,0x36,0x35,0x34,0x37,0x39,0x39,0x3a,0x38,0x37,0x36,0x37,0x39,0x39,
0x3a,0x3a,0x38,0x38,0x37,0x35,0x35,0x35,0x36,0x38,0x38,0x38,0x38,0x39,0x38,0x37,
0x36,0x36,0x37,0x37,0x35,0x35,0x35,0x36,0x35,0x35,0x36,0x36,0x38,0x39,0x38,0x38,
// Line 20
0x3b,0x39,0x38,0x37,0x37,0x38,0x39,0x39,0x39,0x37,0x37,0x38,0x38,0x38,0x38,0x38,
0x39,0x3a,0x3b,0x3a,0x38,0x37,0x38,0x38,0x39,0x39,0x3a,0x38,0x38,0x39,0x3c,0x40,
0x46,0x4c,0x54,0x62,0x71,0x81,0x91,0x9f,0xaa,0xb4,0xba,0xbd,0xbd,0xbf,0xc1,0xc2,
0xc1,0xbd,0xba,0xbb,0xbb,0xbc,0xbf,0xc1,0xc0,0xbe,0xbc,0xbb,0xbd,0xbe,0xc0,0xc0,
0xbf,0xbd,0xbb,0xba,0xbb,0xbd,0xbe,0xbd,0xbb,0xb9,0xb9,0xbb,0xbc,0xbd,0xbd,0xbd,
0xbd,0xbd,0xbc,0xbc,0xbc,0xbc,0xbd,0xbc,0xbc,0xbc,0xbb,0xbb,0xbb,0xbd,0xbd,0xbe,
0xbe,0xbe,0xbe,0xbe,0xbd,0xbb,0xbc,0xbb,0xb9,0xb9,0xb9,0xb9,0xbb,0xbb,0xba,0xbb,
0xbd,0xbe,0xc0,0xbf,0xbe,0xbe,0xc0,0xbe,0xbb,0xbc,0xbe,0xbe,0xbe,0xbd,0xbd,0xc0,
0xbe,0xbb,0xb9,0xb9,0xbb,0xbe,0xbd,0xbc,0xbc,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xbf,
0xbe,0xbc,0xbc,0xbc,0xbb,0xbb,0xbb,0xbb,0xbb,0xba,0xbb,0xbd,0xbd,0xbd,0xbd,0xbd,
0xbb,0xbb,0xbc,0xbc,0xbd,0xbd,0xbc,0xb9,0xba,0xbb,0xbc,0xbe,0xbe,0xbc,0xbe,0xbf,
0xc0,0xbe,0xc0,0xc0,0xc0,0xbf,0xbc,0xbb,0xba,0xba,0xb9,0xb8,0xb7,0xb7,0xb8,0xb9,
0xb9,0xbc,0xbe,0xbd,0xbb,0xbb,0xbd,0xbe,0xc0,0xc0,0xc1,0xbe,0xbb,0xb9,0xbb,0xbf,
0xc2,0xc1,0xbd,0xb7,0xb5,0xb5,0xbb,0xbd,0xbe,0xb6,0xab,0xa0,0x96,0x94,0xa1,0xaa,
0xaf,0xa8,0x9b,0x8a,0x81,0x82,0x90,0xa2,0xad,0xa9,0x9b,0x86,0x7a,0x7f,0x93,0xa9,
0xb5,0xb2,0xa1,0x8a,0x7a,0x7c,0x8f,0xa6,0xb3,0xb1,0x9f,0x89,0x78,0x79,0x8a,0xa2,
0xb2,0xb2,0xa2,0x87,0x7a,0x7b,0x8b,0xa4,0xb4,0xb2,0xa2,0x88,0x78,0x79,0x8c,0xa3,
0xb3,0xb2,0xa1,0x87,0x78,0x7a,0x8e,0xa5,0xb3,0xb2,0xa2,0x8b,0x79,0x7a,0x8b,0xa2,
0xb2,0xb0,0x9f,0x88,0x78,0x78,0x8a,0xa1,0xb1,0xaf,0xa1,0x8b,0x7a,0x7b,0x8d,0xa5,
0xb5,0xb4,0xa1,0x8a,0x7a,0x7c,0x8c,0xa0,0xae,0xaf,0xa2,0x8c,0x7a,0x7b,0x8e,0xa5,
0xb4,0xb2,0xa1,0x8a,0x7a,0x7a,0x8c,0xa3,0xb5,0xb6,0xa7,0x90,0x7f,0x7f,0x8f,0xa4,
0xb3,0xb3,0xa2,0x8b,0x78,0x78,0x8d,0xa5,0xb3,0xb2,0xa4,0x8d,0x78,0x78,0x89,0x9f,
0xaf,0xaf,0x9f,0x88,0x79,0x7a,0x8d,0xa3,0xb3,0xb2,0xa1,0x8a,0x7a,0x7b,0x8c,0xa1,
0xaf,0xae,0xa0,0x8c,0x7c,0x7b,0x8b,0xa2,0xb2,0xb2,0xa2,0x8b,0x7c,0x7d,0x8c,0xa1,
0xaf,0xaf,0x9e,0x8a,0x7a,0x7b,0x8c,0xa2,0xad,0xab,0x9c,0x8a,0x83,0x86,0x94,0xa2,
0xa6,0x9e,0x91,0x8a,0x8b,0x90,0x9b,0x9b,0x91,0x7f,0x71,0x70,0x7d,0x91,0x9d,0x9a,
0x85,0x6d,0x62,0x6a,0x83,0x9d,0xaa,0xa0,0x83,0x63,0x55,0x63,0x83,0xa5,0xb1,0xa5,
0x83,0x61,0x55,0x65,0x84,0xa6,0xb2,0xa2,0x82,0x63,0x57,0x65,0x86,0xa4,0xb1,0xa4,
0x85,0x65,0x59,0x66,0x84,0xa2,0xac,0x9f,0x81,0x63,0x55,0x63,0x83,0xa2,0xb0,0xa5,
0x87,0x67,0x5a,0x66,0x85,0xa3,0xb1,0xa6,0x8a,0x69,0x58,0x64,0x81,0x9e,0xae,0xa2,
0x84,0x62,0x53,0x5e,0x7d,0x9f,0xaf,0xa4,0x87,0x67,0x59,0x66,0x84,0xa4,0xb5,0xab,
0x8a,0x66,0x55,0x62,0x80,0xa2,0xaf,0xa5,0x87,0x66,0x55,0x63,0x83,0xa3,0xb3,0xa9,
0x8c,0x6b,0x5b,0x65,0x83,0xa2,0xb0,0xa6,0x86,0x65,0x55,0x63,0x83,0xa2,0xb0,0xa6,
0x89,0x6a,0x5a,0x65,0x84,0xa3,0xb0,0xa4,0x86,0x67,0x5a,0x66,0x83,0xa2,0xb0,0xa4,
0x84,0x64,0x55,0x60,0x81,0xa0,0xaf,0xa5,0x86,0x65,0x55,0x62,0x83,0xa2,0xb2,0xa5,
0x85,0x65,0x55,0x61,0x81,0xa2,0xb1,0xa7,0x87,0x66,0x56,0x62,0x7f,0x9e,0xae,0xa4,
0x85,0x65,0x53,0x5e,0x7c,0x9c,0xad,0xa6,0x8a,0x69,0x58,0x5e,0x79,0x98,0xab,0xa6,
0x8f,0x6e,0x58,0x57,0x6d,0x89,0x9d,0x9f,0x8d,0x6e,0x5a,0x55,0x66,0x85,0x9c,0xa2,
0x93,0x76,0x5b,0x51,0x5e,0x7b,0x97,0xa2,0x95,0x76,0x5b,0x53,0x5f,0x7a,0x95,0xa1,
0x98,0x7d,0x5e,0x50,0x5d,0x7b,0x9a,0xa4,0x97,0x78,0x5b,0x4f,0x5c,0x7b,0x97,0xa1,
0x97,0x76,0x57,0x4c,0x5b,0x7b,0x9a,0xa6,0x98,0x78,0x5c,0x52,0x60,0x7c,0x96,0xa1,
0x97,0x7a,0x5d,0x51,0x5e,0x79,0x97,0xa2,0x95,0x78,0x5c,0x51,0x5f,0x7a,0x95,0xa0,
0x93,0x78,0x5b,0x4f,0x5c,0x78,0x94,0x9d,0x90,0x76,0x5d,0x52,0x61,0x7e,0x97,0x9f,
0x92,0x77,0x58,0x50,0x5d,0x79,0x95,0x9f,0x91,0x77,0x5b,0x4e,0x5c,0x78,0x93,0x9e,
0x91,0x76,0x5a,0x4e,0x5b,0x79,0x97,0xa2,0x97,0x7c,0x61,0x55,0x61,0x7c,0x98,0xa5,
0x99,0x7b,0x5f,0x52,0x5e,0x7a,0x96,0xa2,0x95,0x78,0x5a,0x4f,0x5d,0x7a,0x97,0xa3,
0x94,0x76,0x5c,0x51,0x5d,0x7a,0x97,0xa1,0x95,0x78,0x5f,0x53,0x63,0x7e,0x98,0xa1,
0x94,0x77,0x5b,0x50,0x5c,0x79,0x92,0x9a,0x8f,0x77,0x62,0x5d,0x68,0x81,0x95,0x9d,
0x93,0x7e,0x6d,0x65,0x6a,0x74,0x7d,0x82,0x81,0x7c,0x76,0x73,0x70,0x6a,0x63,0x5e,
0x5f,0x66,0x76,0x7d,0x79,0x69,0x56,0x4d,0x54,0x6a,0x81,0x8e,0x84,0x69,0x4b,0x3d,
0x49,0x69,0x89,0x98,0x8c,0x6a,0x49,0x3a,0x47,0x68,0x87,0x94,0x85,0x66,0x4a,0x3e,
0x4a,0x6a,0x89,0x94,0x85,0x65,0x47,0x3d,0x4d,0x6a,0x87,0x92,0x85,0x69,0x4c,0x3f,
0x4c,0x6a,0x87,0x92,0x86,0x67,0x49,0x3e,0x4a,0x67,0x86,0x92,0x84,0x65,0x47,0x3b,
0x46,0x65,0x83,0x91,0x86,0x69,0x49,0x3d,0x49,0x68,0x87,0x94,0x87,0x66,0x49,0x3b,
0x49,0x6a,0x8a,0x95,0x8a,0x6a,0x49,0x3d,0x4a,0x67,0x86,0x93,0x86,0x69,0x4a,0x3e,
0x4d,0x6e,0x8c,0x98,0x8c,0x6f,0x51,0x42,0x4c,0x69,0x87,0x95,0x87,0x68,0x47,0x3a,
0x47,0x66,0x85,0x92,0x86,0x68,0x4a,0x3d,0x4c,0x6a,0x8a,0x93,0x84,0x66,0x49,0x3d,
0x4a,0x68,0x84,0x91,0x84,0x66,0x49,0x41,0x4d,0x6a,0x89,0x95,0x88,0x6a,0x4c,0x40,
0x4e,0x6a,0x86,0x91,0x83,0x66,0x4a,0x3e,0x4a,0x68,0x84,0x91,0x84,0x6a,0x50,0x45,
0x52,0x6e,0x89,0x95,0x87,0x6a,0x4e,0x44,0x50,0x6c,0x85,0x8d,0x7d,0x65,0x4c,0x47,
0x57,0x71,0x84,0x85,0x6f,0x50,0x3e,0x40,0x55,0x71,0x83,0x81,0x6a,0x4b,0x38,0x3f,
0x5b,0x79,0x87,0x7d,0x62,0x44,0x36,0x40,0x5d,0x7d,0x8c,0x81,0x62,0x3e,0x31,0x41,
0x61,0x7e,0x8a,0x7f,0x5e,0x3d,0x31,0x3f,0x5f,0x7f,0x8c,0x7c,0x5e,0x3e,0x30,0x3f,
0x5e,0x7d,0x8a,0x7d,0x5e,0x3d,0x30,0x40,0x62,0x81,0x8f,0x82,0x63,0x42,0x32,0x3f,
0x5f,0x7d,0x8c,0x7e,0x5d,0x3c,0x2e,0x3b,0x5a,0x79,0x87,0x7d,0x5f,0x40,0x31,0x40,
0x5e,0x7d,0x8d,0x82,0x62,0x40,0x30,0x3c,0x5c,0x7a,0x89,0x7f,0x62,0x41,0x31,0x3e,
0x5e,0x7e,0x8f,0x84,0x63,0x41,0x31,0x3d,0x5d,0x7c,0x8a,0x80,0x62,0x3f,0x2d,0x3b,
0x5d,0x7e,0x8d,0x83,0x60,0x42,0x32,0x3e,0x5f,0x81,0x90,0x83,0x63,0x40,0x34,0x40,
0x60,0x81,0x90,0x83,0x63,0x40,0x32,0x3f,0x5f,0x7e,0x8a,0x7f,0x5f,0x3f,0x31,0x3d,
0x5c,0x7d,0x8c,0x7f,0x5f,0x3e,0x30,0x3e,0x5e,0x7d,0x87,0x7f,0x5f,0x3c,0x2e,0x3d,
0x5e,0x7f,0x8c,0x80,0x62,0x43,0x34,0x3f,0x5d,0x7b,0x89,0x7d,0x5f,0x3f,0x32,0x3b,
0x58,0x75,0x84,0x7d,0x65,0x47,0x36,0x3d,0x53,0x6a,0x79,0x7a,0x6c,0x56,0x44,0x3d,
0x41,0x4e,0x5b,0x63,0x63,0x57,0x48,0x3b,0x34,0x38,0x47,0x59,0x65,0x64,0x56,0x41,
0x30,0x2e,0x3e,0x54,0x6a,0x6c,0x5c,0x44,0x2f,0x2b,0x3b,0x55,0x6b,0x71,0x62,0x47,
0x30,0x2c,0x3d,0x59,0x6d,0x6e,0x5b,0x41,0x2e,0x2d,0x3e,0x57,0x6a,0x6a,0x59,0x3f,
0x2e,0x2f,0x41,0x5a,0x6a,0x6b,0x5c,0x46,0x35,0x31,0x42,0x56,0x66,0x68,0x5a,0x42,
0x35,0x30,0x3d,0x56,0x69,0x6b,0x5e,0x46,0x32,0x30,0x3e,0x56,0x6a,0x6d,0x5e,0x46,
0x32,0x2e,0x3e,0x5a,0x6a,0x6b,0x5a,0x40,0x2e,0x2c,0x3c,0x54,0x6a,0x6e,0x5f,0x47,
0x34,0x31,0x40,0x59,0x6b,0x6b,0x5d,0x44,0x2f,0x2f,0x3e,0x54,0x66,0x68,0x59,0x42,
0x2f,0x2e,0x3e,0x55,0x68,0x6d,0x5f,0x47,0x34,0x31,0x40,0x56,0x68,0x6a,0x5b,0x43,
0x2f,0x2c,0x3d,0x57,0x6a,0x6b,0x5c,0x44,0x2f,0x2e,0x3f,0x58,0x6b,0x6d,0x5c,0x45,
0x31,0x2e,0x3e,0x55,0x66,0x69,0x5a,0x41,0x2d,0x2d,0x3c,0x53,0x65,0x66,0x59,0x43,
0x30,0x2c,0x3d,0x53,0x66,0x67,0x57,0x42,0x34,0x33,0x42,0x56,0x65,0x66,0x5b,0x48,
0x38,0x35,0x42,0x52,0x5c,0x5d,0x54,0x45,0x3b,0x39,0x3f,0x4a,0x4f,0x4d,0x43,0x3f,
0x3a,0x3b,0x40,0x46,0x48,0x49,0x42,0x3f,0x3d,0x3e,0x3f,0x3f,0x3e,0x3d,0x3e,0x41,
0x44,0x45,0x46,0x44,0x42,0x41,0x42,0x42,0x43,0x42,0x40,0x40,0x40,0x42,0x44,0x44,
0x43,0x44,0x44,0x43,0x41,0x41,0x41,0x40,0x3e,0x3f,0x40,0x40,0x40,0x40,0x42,0x42,
0x41,0x43,0x45,0x44,0x44,0x42,0x42,0x3f,0x43,0x44,0x44,0x44,0x41,0x3e,0x40,0x40,
0x42,0x43,0x43,0x43,0x41,0x40,0x3e,0x43,0x46,0x48,0x47,0x46,0x42,0x42,0x43,0x44,
0x44,0x46,0x46,0x42,0x40,0x3e,0x40,0x42,0x42,0x42,0x44,0x46,0x46,0x44,0x44,0x43,
0x43,0x44,0x44,0x42,0x41,0x40,0x3e,0x3f,0x40,0x42,0x44,0x47,0x46,0x46,0x47,0x47,
0x45,0x45,0x45,0x45,0x46,0x44,0x42,0x44,0x41,0x40,0x43,0x43,0x44,0x45,0x43,0x40,
0x41,0x42,0x44,0x44,0x45,0x44,0x43,0x44,0x42,0x42,0x44,0x45,0x44,0x43,0x42,0x42,
0x44,0x44,0x43,0x42,0x42,0x42,0x43,0x43,0x44,0x44,0x46,0x44,0x43,0x44,0x44,0x42,
0x42,0x41,0x41,0x40,0x3e,0x3f,0x42,0x44,0x42,0x41,0x41,0x41,0x42,0x44,0x44,0x44,
0x44,0x43,0x3f,0x3d,0x3d,0x3f,0x41,0x3e,0x3b,0x3a,0x3b,0x3c,0x3c,0x3d,0x3d,0x3b,
// Line 21
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//Field 2
// Line 10
0x37,0x36,0x36,0x37,0x38,0x39,0x38,0x37,0x36,0x36,0x36,0x37,0x39,0x39,0x37,0x35,
0x34,0x35,0x35,0x35,0x37,0x38,0x36,0x34,0x34,0x36,0x38,0x3b,0x3d,0x3c,0x39,0x35,
0x32,0x34,0x35,0x37,0x36,0x36,0x36,0x35,0x35,0x35,0x35,0x37,0x38,0x39,0x3b,0x3a,
0x3a,0x3b,0x3a,0x39,0x39,0x3b,0x3d,0x3c,0x3b,0x38,0x35,0x34,0x34,0x35,0x37,0x39,
0x39,0x39,0x38,0x38,0x38,0x39,0x39,0x3a,0x3b,0x3c,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
0x39,0x39,0x38,0x38,0x39,0x38,0x36,0x35,0x35,0x35,0x37,0x39,0x3a,0x3a,0x3a,0x38,
0x37,0x3a,0x3b,0x3a,0x3a,0x3a,0x38,0x37,0x35,0x35,0x36,0x35,0x35,0x35,0x36,0x37,
0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x3a,0x3b,0x3c,0x3c,0x3b,0x39,0x39,0x38,0x38,
0x3a,0x3c,0x3c,0x3a,0x37,0x35,0x34,0x35,0x36,0x37,0x37,0x35,0x33,0x34,0x34,0x35,
0x39,0x3c,0x3c,0x3b,0x3a,0x3a,0x3b,0x39,0x38,0x39,0x3a,0x39,0x37,0x37,0x36,0x35,
0x36,0x37,0x37,0x37,0x37,0x37,0x39,0x3c,0x3e,0x3c,0x3c,0x3a,0x39,0x3a,0x39,0x38,
0x38,0x39,0x38,0x38,0x37,0x37,0x3a,0x3c,0x3b,0x3b,0x3c,0x3d,0x3d,0x3c,0x39,0x37,
0x38,0x39,0x39,0x39,0x37,0x34,0x35,0x33,0x34,0x37,0x39,0x39,0x39,0x39,0x37,0x31,
0x34,0x35,0x36,0x38,0x38,0x38,0x38,0x37,0x37,0x38,0x38,0x3a,0x3c,0x3b,0x38,0x38,
0x38,0x3a,0x3c,0x3d,0x3d,0x3f,0x3e,0x3b,0x38,0x36,0x35,0x37,0x37,0x36,0x34,0x34,
0x33,0x34,0x34,0x35,0x37,0x39,0x38,0x36,0x36,0x38,0x3a,0x3a,0x38,0x37,0x36,0x37,
0x36,0x37,0x38,0x39,0x39,0x3a,0x39,0x39,0x38,0x3a,0x39,0x3a,0x3a,0x39,0x37,0x36,
0x35,0x35,0x36,0x38,0x38,0x38,0x37,0x35,0x35,0x37,0x38,0x38,0x3a,0x3a,0x3a,0x3a,
0x39,0x38,0x39,0x38,0x36,0x38,0x38,0x39,0x38,0x39,0x37,0x37,0x36,0x38,0x3a,0x3a,
0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x38,0x39,0x38,0x36,0x35,0x34,0x35,0x36,0x37,
0x38,0x39,0x39,0x39,0x39,0x39,0x38,0x33,0x35,0x34,0x33,0x36,0x37,0x37,0x39,0x39,
0x38,0x39,0x3a,0x3d,0x3d,0x3d,0x39,0x37,0x37,0x3a,0x3b,0x3d,0x3d,0x3e,0x3e,0x3d,
0x3b,0x3c,0x3b,0x3a,0x3a,0x3a,0x39,0x38,0x38,0x38,0x3b,0x3e,0x3f,0x3e,0x3b,0x38,
0x38,0x39,0x38,0x36,0x35,0x35,0x34,0x34,0x34,0x37,0x38,0x3b,0x39,0x39,0x3a,0x3a,
0x3a,0x3c,0x3a,0x38,0x3a,0x3c,0x3b,0x3b,0x39,0x38,0x39,0x39,0x38,0x38,0x37,0x37,
0x37,0x38,0x38,0x38,0x37,0x38,0x38,0x3a,0x39,0x38,0x38,0x37,0x35,0x35,0x34,0x35,
0x37,0x37,0x36,0x36,0x37,0x39,0x39,0x3a,0x3a,0x3a,0x3a,0x3c,0x3a,0x39,0x39,0x38,
0x38,0x39,0x39,0x3b,0x3c,0x3c,0x3d,0x3e,0x3d,0x3c,0x3a,0x39,0x39,0x3b,0x3a,0x39,
0x39,0x38,0x38,0x39,0x39,0x3a,0x3a,0x39,0x37,0x36,0x38,0x3a,0x3a,0x3a,0x3a,0x3a,
0x3c,0x3b,0x3a,0x3b,0x3a,0x3b,0x3b,0x3a,0x39,0x39,0x39,0x3a,0x3a,0x3c,0x3d,0x3d,
0x3d,0x3c,0x3b,0x3c,0x3c,0x3d,0x3f,0x3e,0x3c,0x3b,0x39,0x39,0x38,0x38,0x38,0x39,
0x39,0x3a,0x39,0x3a,0x39,0x3a,0x3b,0x3b,0x3a,0x3a,0x39,0x39,0x39,0x38,0x38,0x38,
0x38,0x3a,0x3a,0x3b,0x3a,0x3a,0x39,0x38,0x37,0x39,0x3b,0x3b,0x3b,0x3a,0x38,0x39,
0x39,0x3b,0x3d,0x3d,0x3b,0x39,0x38,0x38,0x38,0x39,0x38,0x39,0x3c,0x3c,0x3a,0x3a,
0x3a,0x3d,0x3d,0x3c,0x3c,0x3c,0x3c,0x3c,0x3a,0x3b,0x3c,0x3c,0x3c,0x3b,0x39,0x3a,
0x3b,0x3c,0x3c,0x3b,0x37,0x37,0x36,0x36,0x36,0x37,0x38,0x37,0x37,0x38,0x38,0x3b,
0x3c,0x3b,0x3c,0x3c,0x3c,0x3c,0x3a,0x39,0x3a,0x3b,0x3b,0x39,0x38,0x37,0x37,0x39,
0x3a,0x3a,0x3c,0x3c,0x3d,0x3e,0x3c,0x3b,0x3c,0x3c,0x3a,0x39,0x37,0x38,0x38,0x38,
0x37,0x37,0x39,0x3a,0x3c,0x3c,0x3a,0x37,0x39,0x3a,0x39,0x38,0x36,0x37,0x3a,0x3c,
0x3a,0x39,0x39,0x3a,0x39,0x38,0x37,0x36,0x36,0x38,0x37,0x37,0x38,0x3a,0x3c,0x3c,
0x3a,0x39,0x38,0x39,0x38,0x3a,0x38,0x37,0x36,0x36,0x35,0x38,0x36,0x36,0x3a,0x3d,
0x3d,0x3c,0x3a,0x3b,0x3a,0x3c,0x3b,0x3a,0x39,0x38,0x36,0x35,0x35,0x38,0x3c,0x3c,
0x3a,0x3c,0x3a,0x3a,0x39,0x3a,0x3a,0x3b,0x3a,0x3a,0x39,0x38,0x38,0x38,0x38,0x37,
0x35,0x34,0x34,0x33,0x37,0x38,0x37,0x37,0x37,0x37,0x38,0x3a,0x3c,0x3a,0x39,0x37,
0x37,0x37,0x36,0x35,0x36,0x38,0x36,0x36,0x35,0x37,0x39,0x3a,0x3a,0x3d,0x3e,0x3f,
0x3e,0x3c,0x3a,0x3a,0x3b,0x3d,0x3d,0x3c,0x39,0x38,0x37,0x36,0x35,0x37,0x37,0x38,
0x38,0x39,0x39,0x36,0x37,0x37,0x39,0x3b,0x3b,0x3a,0x3a,0x39,0x38,0x39,0x39,0x3a,
0x3a,0x39,0x37,0x38,0x38,0x39,0x3a,0x3a,0x38,0x38,0x37,0x37,0x37,0x38,0x37,0x35,
0x36,0x36,0x37,0x39,0x3a,0x3b,0x3d,0x3e,0x3c,0x3a,0x39,0x38,0x38,0x39,0x3a,0x3a,
0x38,0x38,0x37,0x39,0x38,0x37,0x39,0x39,0x39,0x39,0x3a,0x3d,0x3d,0x3d,0x3b,0x3a,
0x38,0x38,0x38,0x36,0x35,0x36,0x37,0x36,0x34,0x33,0x34,0x36,0x38,0x39,0x39,0x3a,
0x39,0x39,0x39,0x39,0x39,0x38,0x3b,0x38,0x35,0x36,0x37,0x38,0x37,0x35,0x33,0x33,
0x34,0x36,0x36,0x37,0x34,0x35,0x35,0x37,0x38,0x3b,0x3a,0x39,0x38,0x38,0x38,0x38,
0x39,0x38,0x38,0x37,0x37,0x39,0x38,0x38,0x38,0x39,0x39,0x38,0x38,0x3a,0x3a,0x3a,
0x38,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x3b,0x3c,0x3a,0x39,
0x38,0x37,0x38,0x38,0x39,0x3c,0x3b,0x3a,0x3b,0x3c,0x3c,0x3a,0x39,0x38,0x37,0x38,
0x37,0x35,0x34,0x32,0x31,0x33,0x34,0x35,0x37,0x36,0x35,0x35,0x36,0x38,0x3a,0x3b,
0x3a,0x3a,0x39,0x39,0x38,0x39,0x3a,0x38,0x37,0x35,0x35,0x37,0x37,0x38,0x39,0x3a,
0x39,0x38,0x38,0x38,0x39,0x3a,0x3a,0x3a,0x39,0x39,0x39,0x3a,0x39,0x38,0x39,0x37,
0x37,0x38,0x39,0x3a,0x39,0x37,0x35,0x36,0x36,0x36,0x34,0x39,0x36,0x34,0x33,0x33,
0x33,0x35,0x35,0x36,0x37,0x37,0x35,0x34,0x35,0x37,0x38,0x3a,0x3a,0x39,0x3a,0x38,
0x34,0x35,0x35,0x36,0x38,0x39,0x39,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x39,0x38,
0x35,0x34,0x34,0x34,0x35,0x39,0x3b,0x3b,0x38,0x36,0x37,0x37,0x38,0x39,0x39,0x38,
0x37,0x36,0x36,0x32,0x35,0x35,0x33,0x34,0x34,0x34,0x35,0x34,0x34,0x37,0x38,0x38,
0x38,0x39,0x38,0x37,0x37,0x37,0x37,0x38,0x38,0x37,0x37,0x37,0x37,0x39,0x39,0x39,
0x37,0x37,0x36,0x36,0x35,0x36,0x37,0x38,0x37,0x35,0x35,0x35,0x35,0x38,0x38,0x38,
0x38,0x37,0x36,0x37,0x39,0x3a,0x39,0x37,0x33,0x33,0x34,0x35,0x35,0x38,0x38,0x36,
0x36,0x37,0x38,0x3b,0x3c,0x3c,0x3a,0x37,0x35,0x35,0x35,0x35,0x36,0x38,0x39,0x38,
0x39,0x37,0x37,0x38,0x39,0x3a,0x3b,0x38,0x35,0x35,0x35,0x36,0x36,0x39,0x39,0x38,
0x38,0x39,0x37,0x38,0x37,0x37,0x38,0x37,0x34,0x35,0x35,0x35,0x35,0x36,0x37,0x38,
0x37,0x35,0x35,0x35,0x36,0x38,0x38,0x38,0x36,0x35,0x35,0x35,0x37,0x37,0x38,0x38,
0x37,0x36,0x35,0x33,0x31,0x33,0x35,0x37,0x35,0x35,0x34,0x34,0x36,0x37,0x37,0x39,
0x39,0x39,0x38,0x37,0x36,0x37,0x35,0x33,0x31,0x33,0x33,0x34,0x34,0x34,0x34,0x34,
0x35,0x38,0x3b,0x3b,0x3a,0x3a,0x38,0x38,0x37,0x37,0x35,0x35,0x34,0x34,0x34,0x35,
0x37,0x38,0x39,0x37,0x35,0x36,0x35,0x35,0x35,0x37,0x37,0x37,0x35,0x35,0x36,0x37,
0x38,0x38,0x38,0x38,0x35,0x36,0x34,0x32,0x33,0x35,0x35,0x37,0x37,0x38,0x37,0x36,
0x36,0x37,0x3a,0x3a,0x39,0x38,0x36,0x35,0x35,0x35,0x35,0x36,0x35,0x35,0x37,0x38,
0x39,0x39,0x38,0x35,0x36,0x38,0x39,0x37,0x3a,0x38,0x35,0x35,0x34,0x35,0x39,0x38,
0x38,0x38,0x38,0x37,0x35,0x37,0x37,0x38,0x38,0x37,0x35,0x35,0x34,0x34,0x35,0x37,
0x38,0x39,0x39,0x37,0x38,0x39,0x39,0x3a,0x39,0x37,0x36,0x37,0x38,0x38,0x39,0x39,
0x39,0x39,0x39,0x39,0x3a,0x3a,0x3a,0x3a,0x38,0x37,0x35,0x38,0x38,0x3a,0x3c,0x3a,
0x37,0x37,0x38,0x38,0x39,0x3c,0x3a,0x3a,0x37,0x35,0x36,0x38,0x39,0x39,0x38,0x35,
0x35,0x37,0x38,0x38,0x38,0x38,0x38,0x3a,0x3a,0x39,0x38,0x37,0x35,0x36,0x35,0x36,
0x38,0x39,0x37,0x36,0x35,0x37,0x37,0x37,0x36,0x37,0x3a,0x3a,0x3a,0x3a,0x38,0x36,
0x36,0x37,0x38,0x39,0x38,0x37,0x36,0x35,0x37,0x38,0x3a,0x3b,0x3b,0x3a,0x38,0x36,
0x36,0x38,0x39,0x3a,0x3a,0x39,0x38,0x36,0x36,0x37,0x39,0x3a,0x38,0x3a,0x38,0x38,
0x39,0x3b,0x3a,0x3c,0x3c,0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x37,0x37,0x37,0x37,
0x38,0x38,0x37,0x38,0x38,0x38,0x38,0x38,0x37,0x39,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,
0x3b,0x3c,0x3c,0x3b,0x38,0x36,0x35,0x34,0x35,0x37,0x38,0x38,0x38,0x38,0x38,0x36,
0x39,0x3a,0x39,0x39,0x38,0x37,0x36,0x36,0x37,0x39,0x39,0x38,0x3a,0x39,0x37,0x35,
0x35,0x37,0x37,0x35,0x34,0x34,0x35,0x36,0x37,0x39,0x39,0x38,0x39,0x3a,0x38,0x38,
0x37,0x38,0x39,0x39,0x38,0x38,0x38,0x38,0x38,0x39,0x38,0x38,0x37,0x38,0x38,0x38,
0x37,0x35,0x35,0x35,0x35,0x37,0x38,0x3a,0x39,0x39,0x38,0x37,0x36,0x37,0x38,0x39,
0x38,0x38,0x37,0x35,0x35,0x35,0x36,0x38,0x38,0x38,0x37,0x35,0x32,0x32,0x35,0x39,
0x3a,0x37,0x38,0x38,0x35,0x37,0x37,0x38,0x39,0x38,0x35,0x35,0x33,0x33,0x32,0x34,
0x35,0x37,0x36,0x35,0x33,0x35,0x35,0x37,0x3a,0x3b,0x3a,0x3b,0x3c,0x3a,0x39,0x3a,
// Line 11
0x37,0x36,0x36,0x35,0x34,0x34,0x32,0x33,0x33,0x33,0x31,0x32,0x35,0x38,0x39,0x3a,
0x39,0x3b,0x3b,0x39,0x38,0x39,0x3a,0x38,0x36,0x35,0x35,0x35,0x36,0x38,0x36,0x36,
0x35,0x35,0x36,0x38,0x38,0x3b,0x38,0x36,0x32,0x30,0x31,0x36,0x39,0x39,0x33,0x32,
0x32,0x39,0x47,0x59,0x6b,0x7a,0x7d,0x77,0x6c,0x60,0x57,0x57,0x60,0x67,0x6e,0x73,
0x74,0x6f,0x65,0x5c,0x5a,0x61,0x68,0x70,0x76,0x77,0x72,0x6a,0x60,0x5a,0x5a,0x5f,
0x66,0x6e,0x71,0x70,0x6a,0x64,0x5e,0x5a,0x5c,0x64,0x6c,0x71,0x72,0x73,0x71,0x6a,
0x62,0x5e,0x5e,0x61,0x67,0x6f,0x74,0x73,0x6e,0x66,0x5d,0x59,0x58,0x5c,0x66,0x6c,
0x6f,0x72,0x6d,0x66,0x5d,0x59,0x59,0x60,0x6a,0x73,0x76,0x73,0x6c,0x66,0x61,0x60,
0x61,0x66,0x69,0x6a,0x6b,0x6d,0x71,0x77,0x7f,0x8b,0x97,0xa1,0xa5,0xa5,0x9e,0x92,
0x82,0x73,0x65,0x5c,0x55,0x51,0x4c,0x47,0x3f,0x38,0x35,0x3f,0x4d,0x62,0x75,0x83,
0x8c,0x92,0x93,0x93,0x96,0x9a,0x9b,0x9b,0x98,0x95,0x95,0x97,0x98,0x93,0x88,0x79,
0x6b,0x61,0x56,0x4c,0x43,0x3b,0x33,0x31,0x35,0x44,0x5a,0x6e,0x7a,0x7d,0x75,0x69,
0x60,0x5a,0x56,0x51,0x48,0x3e,0x34,0x36,0x3e,0x52,0x6b,0x7d,0x82,0x7d,0x71,0x60,
0x55,0x4f,0x4d,0x48,0x42,0x3b,0x32,0x2b,0x29,0x2d,0x35,0x40,0x4b,0x5a,0x67,0x6f,
0x71,0x6e,0x67,0x62,0x5c,0x59,0x52,0x4a,0x40,0x38,0x36,0x3e,0x4d,0x63,0x77,0x86,
0x90,0x93,0x93,0x91,0x8d,0x83,0x76,0x67,0x5c,0x58,0x5e,0x69,0x74,0x7c,0x79,0x70,
0x65,0x5e,0x5b,0x5a,0x52,0x43,0x35,0x2b,0x2d,0x3b,0x53,0x6d,0x7f,0x82,0x7a,0x6b,
0x5e,0x57,0x52,0x4c,0x42,0x34,0x2f,0x32,0x41,0x58,0x6f,0x7f,0x83,0x7b,0x6e,0x60,
0x5c,0x57,0x52,0x48,0x3d,0x30,0x30,0x3c,0x52,0x6d,0x7f,0x84,0x7d,0x6e,0x5c,0x51,
0x53,0x5f,0x6a,0x72,0x74,0x71,0x6b,0x66,0x61,0x62,0x64,0x67,0x6a,0x6c,0x6e,0x73,
0x78,0x82,0x90,0x9d,0xa6,0xac,0xab,0xa4,0x9e,0x9a,0x97,0x93,0x97,0x94,0x8a,0x7d,
0x6b,0x5a,0x4d,0x44,0x40,0x3e,0x3d,0x3b,0x38,0x35,0x34,0x39,0x3e,0x40,0x3c,0x36,
0x30,0x30,0x37,0x45,0x57,0x6a,0x77,0x7a,0x76,0x6e,0x66,0x61,0x60,0x63,0x68,0x6e,
0x74,0x7a,0x80,0x89,0x93,0x9f,0xa6,0xa9,0xa9,0xa5,0x98,0x8a,0x7a,0x6e,0x63,0x5c,
0x57,0x5c,0x64,0x6e,0x76,0x7f,0x87,0x90,0x98,0x9a,0x95,0x88,0x75,0x62,0x52,0x45,
0x3e,0x3a,0x37,0x36,0x39,0x3d,0x3f,0x40,0x42,0x43,0x40,0x3d,0x38,0x38,0x39,0x38,
0x33,0x31,0x32,0x38,0x43,0x52,0x61,0x72,0x81,0x8e,0x93,0x9b,0x9c,0x98,0x8d,0x7d,
0x6c,0x5e,0x54,0x53,0x5b,0x67,0x75,0x82,0x8c,0x93,0x9a,0x9f,0xa2,0xa3,0xa4,0xa1,
0x9a,0x8e,0x7c,0x69,0x5a,0x51,0x53,0x60,0x6d,0x79,0x7c,0x76,0x6a,0x63,0x60,0x61,
0x61,0x5c,0x4d,0x3d,0x31,0x31,0x3c,0x53,0x6e,0x83,0x89,0x7e,0x6a,0x59,0x51,0x55,
0x62,0x72,0x7c,0x7a,0x72,0x69,0x62,0x61,0x61,0x5e,0x58,0x4a,0x38,0x2d,0x2f,0x40,
0x58,0x71,0x80,0x83,0x7a,0x6e,0x5f,0x58,0x53,0x50,0x4c,0x41,0x36,0x39,0x42,0x55,
0x6c,0x7d,0x82,0x79,0x69,0x5a,0x53,0x55,0x60,0x6a,0x74,0x7a,0x7f,0x8a,0x94,0x9d,
0xa2,0x9d,0x91,0x7e,0x69,0x57,0x48,0x3d,0x35,0x33,0x35,0x3b,0x45,0x54,0x65,0x75,
0x84,0x90,0x97,0x99,0x97,0x8f,0x82,0x72,0x62,0x57,0x4c,0x41,0x38,0x32,0x34,0x3a,
0x4e,0x63,0x75,0x80,0x7f,0x74,0x67,0x5a,0x54,0x52,0x50,0x48,0x3e,0x34,0x31,0x3c,
0x52,0x6e,0x83,0x8a,0x83,0x73,0x64,0x5b,0x5b,0x64,0x6d,0x73,0x77,0x7a,0x80,0x89,
0x95,0xa2,0xac,0xad,0xa6,0x9e,0x99,0x94,0x94,0x97,0x97,0x93,0x8f,0x82,0x72,0x64,
0x5a,0x58,0x5a,0x61,0x69,0x74,0x7f,0x8c,0x95,0x9a,0x98,0x91,0x87,0x79,0x69,0x59,
0x4d,0x45,0x3f,0x39,0x36,0x3c,0x48,0x5b,0x6e,0x7a,0x7c,0x76,0x6c,0x60,0x56,0x52,
0x51,0x4c,0x45,0x3b,0x2f,0x2d,0x32,0x3c,0x43,0x48,0x44,0x3e,0x37,0x35,0x37,0x40,
0x4c,0x5d,0x6e,0x7b,0x85,0x90,0x97,0x9c,0xa0,0xa3,0xa3,0xa2,0x9c,0x91,0x81,0x6f,
0x62,0x5d,0x5c,0x5f,0x64,0x6d,0x76,0x7f,0x89,0x91,0x96,0x99,0x94,0x89,0x78,0x66,
0x55,0x49,0x41,0x3c,0x38,0x3b,0x3b,0x3a,0x3c,0x3c,0x3b,0x40,0x49,0x59,0x6a,0x77,
0x7a,0x77,0x6c,0x5e,0x57,0x5a,0x65,0x70,0x78,0x79,0x70,0x64,0x5b,0x5a,0x5d,0x60,
0x5d,0x53,0x41,0x32,0x2d,0x39,0x50,0x6c,0x83,0x8c,0x83,0x6f,0x5a,0x4f,0x51,0x5e,
0x6b,0x75,0x75,0x6e,0x67,0x61,0x5d,0x5b,0x59,0x52,0x47,0x3d,0x34,0x30,0x30,0x31,
0x35,0x3e,0x46,0x52,0x5e,0x6b,0x73,0x77,0x6f,0x65,0x5c,0x58,0x58,0x60,0x69,0x72,
0x76,0x7a,0x7e,0x86,0x91,0x9a,0x9b,0x93,0x7f,0x68,0x55,0x4d,0x51,0x5f,0x71,0x7d,
0x80,0x7c,0x6f,0x61,0x57,0x57,0x5c,0x67,0x6e,0x72,0x73,0x6a,0x60,0x5c,0x5e,0x66,
0x6f,0x76,0x78,0x77,0x70,0x68,0x61,0x5d,0x5e,0x62,0x67,0x67,0x67,0x68,0x6d,0x76,
0x84,0x93,0xa0,0xab,0xaf,0xad,0xa6,0x99,0x8c,0x7d,0x6e,0x60,0x56,0x56,0x5b,0x61,
0x69,0x72,0x7b,0x86,0x8f,0x96,0x99,0x94,0x89,0x79,0x66,0x54,0x45,0x3b,0x35,0x36,
0x3b,0x3e,0x3d,0x3a,0x38,0x39,0x40,0x4b,0x5a,0x6c,0x78,0x7a,0x77,0x6c,0x60,0x58,
0x5c,0x63,0x69,0x70,0x75,0x78,0x7f,0x89,0x92,0x9d,0x9d,0x91,0x7c,0x64,0x52,0x4c,
0x52,0x61,0x70,0x7a,0x7a,0x73,0x69,0x61,0x5c,0x5c,0x5e,0x62,0x68,0x6e,0x74,0x7d,
0x89,0x95,0xa0,0xa5,0xa5,0xa1,0x9c,0x98,0x96,0x97,0x99,0x9b,0x9e,0x9f,0xa0,0xa1,
0x9f,0x9a,0x90,0x80,0x6d,0x5e,0x56,0x56,0x5d,0x69,0x72,0x77,0x76,0x70,0x67,0x61,
0x5c,0x57,0x50,0x47,0x3e,0x39,0x36,0x34,0x36,0x39,0x3e,0x45,0x4f,0x5e,0x6d,0x78,
0x79,0x71,0x65,0x5b,0x56,0x5d,0x69,0x76,0x7d,0x7a,0x72,0x6a,0x64,0x61,0x60,0x5c,
0x53,0x48,0x3e,0x34,0x2d,0x2c,0x2d,0x31,0x38,0x40,0x4c,0x5c,0x6b,0x77,0x7a,0x74,
0x6a,0x61,0x60,0x63,0x68,0x6f,0x72,0x73,0x74,0x79,0x82,0x92,0xa0,0xaa,0xab,0xa7,
0x9e,0x99,0x95,0x95,0x95,0x9c,0x9e,0x9e,0x9e,0x9e,0x9c,0x9c,0x98,0x96,0x98,0x9b,
0x9d,0x9f,0x9d,0x9b,0x9c,0x9e,0x9f,0x9e,0x9e,0x9c,0x99,0x98,0x96,0x97,0x98,0x97,
0x96,0x98,0x98,0x98,0x91,0x8a,0x7f,0x72,0x63,0x55,0x4a,0x42,0x3c,0x36,0x33,0x36,
0x3f,0x50,0x61,0x72,0x81,0x8c,0x91,0x94,0x97,0x9b,0xa2,0xa5,0xa4,0xa0,0x9c,0x98,
0x97,0x99,0x99,0x93,0x85,0x75,0x63,0x58,0x56,0x5e,0x6b,0x76,0x7b,0x7a,0x73,0x6a,
0x63,0x61,0x61,0x64,0x68,0x6b,0x6f,0x77,0x81,0x8d,0x97,0x9a,0x96,0x8a,0x78,0x65,
0x56,0x4c,0x44,0x3d,0x38,0x38,0x40,0x51,0x65,0x78,0x84,0x83,0x7a,0x6e,0x61,0x57,
0x53,0x4f,0x47,0x3e,0x35,0x33,0x3b,0x4c,0x63,0x79,0x8a,0x95,0x98,0x99,0x92,0x8b,
0x82,0x75,0x64,0x54,0x4a,0x44,0x42,0x3f,0x39,0x32,0x32,0x34,0x38,0x40,0x43,0x40,
0x3c,0x33,0x2f,0x37,0x4a,0x62,0x75,0x7e,0x7b,0x74,0x69,0x60,0x5a,0x57,0x51,0x48,
0x3e,0x36,0x31,0x32,0x37,0x3e,0x45,0x47,0x44,0x3f,0x39,0x35,0x36,0x38,0x39,0x39,
0x38,0x38,0x39,0x3b,0x3b,0x3d,0x40,0x3b,0x34,0x33,0x34,0x3b,0x47,0x55,0x64,0x73,
0x7e,0x88,0x8f,0x97,0x9a,0x98,0x8f,0x7f,0x6b,0x5a,0x52,0x54,0x60,0x70,0x7b,0x7f,
0x76,0x68,0x5c,0x55,0x5a,0x66,0x72,0x78,0x77,0x71,0x67,0x5f,0x5e,0x60,0x5e,0x56,
0x48,0x38,0x2d,0x2c,0x39,0x52,0x6b,0x7d,0x81,0x7a,0x6c,0x5f,0x54,0x50,0x4c,0x46,
0x3c,0x35,0x38,0x44,0x58,0x6e,0x7f,0x84,0x7d,0x6f,0x61,0x58,0x58,0x60,0x68,0x6e,
0x73,0x7a,0x88,0x91,0x99,0x9d,0x97,0x88,0x75,0x63,0x52,0x48,0x40,0x39,0x34,0x33,
0x38,0x47,0x5d,0x72,0x7e,0x84,0x7b,0x6c,0x60,0x59,0x5b,0x66,0x71,0x79,0x7a,0x77,
0x6f,0x67,0x61,0x60,0x62,0x66,0x68,0x6c,0x6f,0x75,0x7c,0x89,0x94,0x9f,0xa6,0xaa,
0xa8,0xa3,0x98,0x89,0x77,0x69,0x5f,0x5a,0x5a,0x61,0x68,0x6f,0x77,0x7f,0x88,0x90,
0x96,0x9a,0x96,0x8a,0x7a,0x66,0x54,0x45,0x3b,0x38,0x38,0x39,0x39,0x38,0x35,0x33,
0x34,0x3e,0x4b,0x5b,0x69,0x73,0x77,0x75,0x6d,0x65,0x5f,0x59,0x52,0x4a,0x40,0x39,
0x35,0x3c,0x4b,0x61,0x78,0x89,0x92,0x98,0x95,0x96,0x9a,0x9f,0xa2,0xa3,0x9e,0x98,
0x93,0x95,0x98,0x97,0x94,0x87,0x72,0x60,0x53,0x52,0x5d,0x69,0x76,0x7e,0x7d,0x76,
0x69,0x65,0x62,0x64,0x68,0x6c,0x6e,0x6f,0x72,0x7b,0x89,0x97,0x9f,0xa0,0x93,0x7e,
0x67,0x55,0x4d,0x53,0x60,0x6d,0x78,0x79,0x72,0x67,0x5c,0x57,0x55,0x52,0x4b,0x41,
0x38,0x2f,0x2b,0x2e,0x37,0x41,0x41,0x3f,0x34,0x2d,0x2b,0x32,0x40,0x59,0x6b,0x78,
0x7d,0x7a,0x72,0x6a,0x60,0x5a,0x53,0x4c,0x43,0x3b,0x36,0x39,0x46,0x5a,0x6e,0x7f,
0x8a,0x91,0x95,0x97,0x9a,0x9d,0xa0,0xa0,0x9d,0x9c,0x9a,0x9a,0x9c,0x9d,0x9d,0x9c,
0x9a,0x9a,0x9a,0x9c,0x9e,0xa0,0xa0,0x9e,0x9d,0x9e,0x9f,0xa0,0x9c,0x91,0x81,0x6e,
0x5e,0x54,0x55,0x5d,0x68,0x72,0x78,0x77,0x6f,0x67,0x60,0x5a,0x56,0x51,0x47,0x3e,
0x33,0x2d,0x2a,0x31,0x38,0x3e,0x41,0x41,0x3d,0x39,0x36,0x34,0x36,0x38,0x3b,0x3b,
0x3b,0x39,0x3a,0x39,0x38,0x36,0x36,0x36,0x38,0x3b,0x3b,0x3b,0x3a,0x39,0x39,0x39,
0x39,0x3b,0x3c,0x3b,0x39,0x39,0x39,0x3b,0x3a,0x3b,0x3a,0x39,0x3b,0x3c,0x3c,0x3d,
// Line 12
0x37,0x36,0x36,0x36,0x36,0x35,0x36,0x36,0x35,0x37,0x38,0x39,0x39,0x37,0x36,0x36,
0x38,0x3a,0x39,0x38,0x38,0x37,0x37,0x36,0x35,0x36,0x37,0x37,0x37,0x36,0x36,0x35,
0x36,0x36,0x38,0x3b,0x3d,0x3d,0x3b,0x38,0x35,0x37,0x38,0x39,0x3a,0x3a,0x36,0x32,
0x30,0x36,0x40,0x53,0x65,0x75,0x7c,0x77,0x6b,0x60,0x57,0x57,0x5f,0x6c,0x76,0x7c,
0x76,0x6e,0x64,0x5c,0x5c,0x60,0x67,0x6d,0x73,0x75,0x72,0x6b,0x61,0x5c,0x5d,0x65,
0x6d,0x74,0x77,0x76,0x70,0x67,0x5e,0x58,0x57,0x5d,0x66,0x6e,0x73,0x74,0x6e,0x6b,
0x61,0x5b,0x5d,0x63,0x6a,0x70,0x73,0x6f,0x69,0x63,0x5c,0x58,0x5a,0x5f,0x67,0x6f,
0x73,0x72,0x6c,0x66,0x5e,0x5a,0x5b,0x62,0x6b,0x73,0x76,0x76,0x70,0x69,0x62,0x5d,
0x5c,0x61,0x68,0x6b,0x6d,0x6e,0x72,0x77,0x81,0x8e,0x9b,0xa5,0xaa,0xa8,0xa1,0x91,
0x80,0x6e,0x60,0x58,0x52,0x4e,0x4a,0x43,0x3a,0x33,0x33,0x3d,0x4e,0x62,0x76,0x84,
0x8c,0x91,0x94,0x98,0x9a,0x9c,0x9b,0x9a,0x97,0x96,0x95,0x9a,0x97,0x91,0x88,0x7b,
0x6e,0x63,0x5a,0x53,0x4b,0x41,0x37,0x30,0x38,0x48,0x5c,0x71,0x7d,0x7d,0x74,0x67,
0x5c,0x59,0x55,0x4f,0x45,0x3a,0x2f,0x2f,0x3a,0x51,0x6b,0x7c,0x80,0x7b,0x6e,0x60,
0x54,0x4e,0x4b,0x47,0x42,0x3a,0x33,0x2f,0x2f,0x33,0x3a,0x43,0x50,0x61,0x6e,0x74,
0x74,0x72,0x6b,0x61,0x5c,0x56,0x50,0x48,0x3e,0x36,0x33,0x3a,0x4a,0x62,0x78,0x89,
0x91,0x95,0x95,0x94,0x8e,0x84,0x74,0x63,0x55,0x51,0x58,0x65,0x73,0x7c,0x7a,0x70,
0x68,0x61,0x5e,0x5b,0x53,0x46,0x37,0x2e,0x2f,0x3d,0x57,0x72,0x80,0x83,0x7b,0x6d,
0x60,0x58,0x52,0x4d,0x45,0x3c,0x32,0x30,0x3a,0x50,0x6b,0x7f,0x86,0x7e,0x6d,0x5d,
0x54,0x55,0x5d,0x69,0x74,0x79,0x77,0x6f,0x65,0x5d,0x5d,0x61,0x68,0x70,0x76,0x75,
0x73,0x69,0x60,0x5c,0x5e,0x67,0x74,0x7b,0x7c,0x79,0x70,0x68,0x5e,0x5c,0x5b,0x5a,
0x56,0x4c,0x3d,0x31,0x29,0x29,0x2f,0x3a,0x43,0x48,0x47,0x41,0x3b,0x36,0x33,0x34,
0x37,0x39,0x3a,0x39,0x39,0x37,0x37,0x36,0x36,0x36,0x33,0x31,0x32,0x3a,0x47,0x5a,
0x6c,0x7a,0x7d,0x79,0x6c,0x61,0x5c,0x5e,0x65,0x6f,0x74,0x75,0x78,0x7e,0x87,0x95,
0x9b,0x9a,0x8f,0x7a,0x60,0x4f,0x4a,0x50,0x60,0x6f,0x78,0x79,0x72,0x69,0x61,0x5e,
0x5b,0x55,0x4a,0x3c,0x31,0x31,0x3c,0x4e,0x63,0x76,0x84,0x8c,0x90,0x92,0x94,0x98,
0x9d,0xa1,0xa0,0x9c,0x99,0x9b,0x9c,0x9b,0x98,0x90,0x83,0x74,0x64,0x57,0x4b,0x43,
0x3c,0x38,0x36,0x37,0x3f,0x4f,0x61,0x73,0x81,0x8c,0x91,0x97,0x97,0x93,0x89,0x79,
0x67,0x5a,0x55,0x5b,0x63,0x73,0x7b,0x7d,0x77,0x6c,0x61,0x5e,0x5d,0x62,0x67,0x6c,
0x70,0x76,0x7d,0x89,0x96,0xa2,0xa8,0xa9,0xa8,0xa0,0x97,0x94,0x93,0x95,0x9a,0x9d,
0x9e,0xa1,0xa1,0xa1,0x9f,0x9e,0x9d,0x9d,0x9b,0x9c,0x9c,0x9e,0x9f,0x9e,0x99,0x8e,
0x7f,0x6f,0x61,0x56,0x53,0x5a,0x63,0x6c,0x73,0x7c,0x86,0x90,0x95,0x95,0x93,0x87,
0x76,0x65,0x53,0x46,0x3e,0x3a,0x39,0x3b,0x3d,0x3f,0x3d,0x3a,0x37,0x3d,0x49,0x5a,
0x68,0x79,0x7c,0x79,0x70,0x66,0x5e,0x5f,0x64,0x69,0x6e,0x73,0x77,0x80,0x8a,0x93,
0x9a,0x9a,0x8f,0x7f,0x6c,0x5b,0x4d,0x44,0x3e,0x3b,0x3a,0x3d,0x43,0x52,0x65,0x75,
0x81,0x88,0x8c,0x8f,0x94,0x98,0x9a,0x9e,0xa0,0x9f,0x9e,0x9c,0x9c,0x9d,0x9e,0xa0,
0xa3,0xa4,0xa2,0x9b,0x91,0x82,0x72,0x64,0x5b,0x59,0x5b,0x62,0x6b,0x73,0x7a,0x81,
0x89,0x91,0x96,0x9b,0x9d,0x9d,0x97,0x8e,0x82,0x76,0x6a,0x5e,0x55,0x50,0x49,0x43,
0x3f,0x3b,0x36,0x33,0x31,0x34,0x3b,0x43,0x4b,0x53,0x61,0x6f,0x7d,0x8a,0x92,0x96,
0x95,0x8c,0x7e,0x6f,0x62,0x57,0x4d,0x42,0x37,0x33,0x35,0x3f,0x4c,0x5e,0x6f,0x7c,
0x81,0x7d,0x6f,0x62,0x5a,0x5c,0x64,0x6b,0x72,0x79,0x7e,0x84,0x8a,0x91,0x97,0x92,
0x89,0x76,0x61,0x50,0x44,0x3f,0x3f,0x3e,0x3b,0x3b,0x3a,0x3b,0x3e,0x3f,0x3d,0x3b,
0x38,0x38,0x38,0x38,0x38,0x3c,0x3f,0x3e,0x3a,0x38,0x36,0x34,0x34,0x36,0x3d,0x4a,
0x5b,0x6c,0x7c,0x87,0x8e,0x94,0x97,0x9a,0x9f,0xa4,0xa5,0x9e,0x90,0x7f,0x6d,0x60,
0x58,0x57,0x5f,0x69,0x70,0x73,0x6f,0x68,0x5f,0x5b,0x58,0x57,0x52,0x49,0x3a,0x31,
0x2d,0x36,0x4d,0x69,0x7f,0x88,0x82,0x72,0x5f,0x54,0x55,0x5b,0x67,0x6f,0x75,0x7c,
0x82,0x8b,0x97,0xa2,0xa8,0xaa,0xa4,0x9b,0x8f,0x81,0x73,0x67,0x5a,0x50,0x47,0x42,
0x3d,0x3a,0x37,0x34,0x31,0x30,0x2f,0x31,0x3a,0x47,0x58,0x69,0x74,0x77,0x73,0x68,
0x5d,0x59,0x5b,0x60,0x68,0x70,0x74,0x75,0x78,0x82,0x8f,0xa0,0xaa,0xac,0xa9,0xa1,
0x98,0x95,0x94,0x96,0x97,0x9a,0x9a,0x9a,0x98,0x98,0x94,0x8b,0x7d,0x6c,0x5d,0x53,
0x53,0x5a,0x62,0x6b,0x73,0x7c,0x86,0x91,0x99,0x9e,0x9b,0x90,0x80,0x6c,0x5c,0x52,
0x50,0x5a,0x67,0x75,0x81,0x8a,0x8f,0x95,0x9a,0x9f,0xa1,0x9e,0x99,0x90,0x82,0x70,
0x5f,0x53,0x4b,0x46,0x43,0x3f,0x3a,0x35,0x2f,0x2d,0x2f,0x35,0x3d,0x43,0x41,0x3b,
0x33,0x31,0x37,0x44,0x5a,0x6e,0x7c,0x80,0x78,0x6c,0x5f,0x5a,0x59,0x61,0x69,0x6e,
0x70,0x78,0x80,0x8c,0x97,0x9d,0x99,0x90,0x7c,0x64,0x52,0x45,0x3d,0x3d,0x3b,0x37,
0x34,0x34,0x35,0x38,0x3b,0x3a,0x36,0x31,0x2d,0x2e,0x36,0x44,0x58,0x6c,0x79,0x7c,
0x76,0x6d,0x62,0x5a,0x52,0x4d,0x47,0x40,0x37,0x2f,0x2a,0x2a,0x2f,0x36,0x3f,0x49,
0x55,0x5e,0x69,0x78,0x83,0x8f,0x96,0x98,0x94,0x87,0x76,0x63,0x54,0x4f,0x53,0x5e,
0x6b,0x75,0x78,0x76,0x6f,0x67,0x61,0x5a,0x53,0x4b,0x41,0x39,0x34,0x31,0x32,0x37,
0x3a,0x42,0x4c,0x5b,0x68,0x73,0x77,0x73,0x67,0x5b,0x55,0x58,0x65,0x72,0x79,0x7a,
0x72,0x68,0x60,0x5e,0x5d,0x5c,0x58,0x4d,0x3e,0x32,0x2a,0x2b,0x31,0x38,0x3e,0x42,
0x41,0x3f,0x3c,0x37,0x32,0x2f,0x2e,0x2f,0x32,0x3a,0x46,0x53,0x63,0x73,0x7d,0x89,
0x91,0x98,0x99,0x93,0x87,0x76,0x63,0x52,0x45,0x40,0x3d,0x38,0x37,0x36,0x33,0x35,
0x37,0x3c,0x40,0x3a,0x2f,0x28,0x27,0x30,0x43,0x59,0x6c,0x77,0x77,0x72,0x64,0x5f,
0x5a,0x57,0x52,0x4a,0x3f,0x36,0x36,0x40,0x53,0x69,0x7c,0x8b,0x90,0x93,0x96,0x9b,
0xa0,0xa2,0xa1,0x9d,0x97,0x95,0x94,0x94,0x93,0x8f,0x88,0x7e,0x6f,0x60,0x53,0x4a,
0x41,0x3d,0x3b,0x3a,0x38,0x36,0x32,0x30,0x32,0x3c,0x4a,0x5c,0x6b,0x73,0x74,0x6c,
0x63,0x5b,0x57,0x55,0x53,0x4d,0x40,0x36,0x30,0x35,0x44,0x5c,0x73,0x83,0x8c,0x8f,
0x8e,0x92,0x98,0xa0,0xa4,0xa3,0x9c,0x90,0x80,0x72,0x62,0x5b,0x55,0x58,0x5e,0x65,
0x6f,0x7c,0x84,0x8a,0x92,0x99,0xa0,0xa4,0xa4,0xa1,0x9a,0x96,0x95,0x94,0x9b,0x9e,
0x9f,0xa0,0x9b,0x94,0x8f,0x86,0x78,0x6e,0x5f,0x53,0x49,0x41,0x3d,0x3d,0x3b,0x38,
0x35,0x33,0x33,0x36,0x3d,0x48,0x53,0x60,0x6b,0x76,0x82,0x8c,0x93,0x97,0x95,0x8b,
0x7c,0x6c,0x5f,0x58,0x58,0x5e,0x69,0x75,0x80,0x88,0x8c,0x90,0x90,0x8f,0x86,0x76,
0x61,0x50,0x41,0x38,0x36,0x3a,0x3a,0x3f,0x3a,0x35,0x35,0x38,0x42,0x52,0x60,0x6c,
0x75,0x78,0x74,0x6c,0x62,0x5c,0x5b,0x5e,0x65,0x6d,0x74,0x7a,0x82,0x8c,0x94,0x98,
0x97,0x8d,0x7c,0x68,0x55,0x46,0x3d,0x3c,0x3b,0x3b,0x38,0x36,0x34,0x36,0x39,0x3e,
0x45,0x4f,0x5c,0x6b,0x79,0x88,0x93,0x99,0x98,0x90,0x83,0x74,0x66,0x58,0x4d,0x40,
0x3d,0x37,0x37,0x3d,0x45,0x52,0x61,0x70,0x7f,0x8d,0x96,0x98,0x96,0x8e,0x82,0x75,
0x67,0x5c,0x53,0x56,0x58,0x60,0x6d,0x7c,0x89,0x97,0x9a,0x98,0x93,0x8a,0x7a,0x66,
0x56,0x49,0x3f,0x3a,0x36,0x38,0x3e,0x46,0x53,0x63,0x73,0x81,0x8c,0x93,0x95,0x93,
0x8c,0x83,0x75,0x65,0x59,0x55,0x57,0x5f,0x6a,0x78,0x83,0x8c,0x95,0x9d,0x9f,0x9b,
0x8d,0x78,0x62,0x51,0x4b,0x52,0x5d,0x6b,0x74,0x78,0x72,0x66,0x60,0x59,0x54,0x50,
0x47,0x3d,0x33,0x2d,0x29,0x2d,0x33,0x3a,0x41,0x4b,0x54,0x60,0x6c,0x7a,0x86,0x8f,
0x94,0x95,0x91,0x8a,0x7d,0x6c,0x5b,0x4b,0x41,0x3a,0x36,0x36,0x38,0x41,0x50,0x61,
0x72,0x80,0x89,0x8c,0x8f,0x95,0x9d,0xa2,0xa5,0xa1,0x95,0x86,0x75,0x67,0x5b,0x52,
0x49,0x43,0x3d,0x3a,0x32,0x36,0x36,0x35,0x37,0x3b,0x41,0x4b,0x56,0x63,0x6d,0x77,
0x81,0x8d,0x95,0x97,0x92,0x87,0x77,0x67,0x59,0x53,0x55,0x5e,0x69,0x76,0x82,0x8c,
0x93,0x98,0x99,0x94,0x88,0x76,0x64,0x53,0x45,0x3d,0x38,0x37,0x38,0x3a,0x39,0x36,
0x34,0x36,0x3d,0x49,0x5b,0x6b,0x74,0x78,0x74,0x6b,0x60,0x5b,0x5d,0x62,0x67,0x6c,
0x72,0x79,0x81,0x8b,0x94,0x99,0x94,0x8a,0x77,0x65,0x56,0x49,0x40,0x3b,0x38,0x38,
0x38,0x45,0x53,0x65,0x73,0x7e,0x83,0x8b,0x8c,0x8f,0x97,0x9d,0x9e,0x9d,0x98,0x93,
0x92,0x94,0x96,0x92,0x89,0x7c,0x6c,0x5d,0x50,0x49,0x45,0x40,0x3a,0x36,0x31,0x2f,
0x32,0x38,0x3c,0x3d,0x39,0x33,0x2e,0x30,0x3a,0x4b,0x60,0x73,0x7b,0x7b,0x72,0x67,
0x5e,0x57,0x52,0x4b,0x41,0x35,0x2e,0x31,0x3d,0x4f,0x67,0x79,0x80,0x7c,0x6c,0x5b,
0x52,0x4b,0x46,0x44,0x3d,0x36,0x30,0x2e,0x30,0x38,0x40,0x45,0x43,0x3d,0x37,0x34,
0x32,0x33,0x32,0x32,0x31,0x31,0x34,0x37,0x38,0x38,0x35,0x34,0x34,0x36,0x37,0x3a,
0x3b,0x3a,0x37,0x38,0x39,0x3a,0x3c,0x3b,0x37,0x38,0x38,0x37,0x37,0x38,0x37,0x38,
// Line 13
0x32,0x34,0x37,0x39,0x37,0x34,0x34,0x34,0x37,0x3a,0x3a,0x38,0x36,0x34,0x33,0x33,
0x34,0x36,0x35,0x36,0x37,0x36,0x35,0x35,0x36,0x37,0x37,0x36,0x34,0x36,0x37,0x34,
0x33,0x32,0x34,0x37,0x38,0x37,0x37,0x34,0x33,0x31,0x30,0x32,0x35,0x38,0x34,0x2f,
0x30,0x34,0x3e,0x52,0x66,0x75,0x7a,0x74,0x68,0x5c,0x55,0x57,0x60,0x6c,0x75,0x78,
0x74,0x6c,0x63,0x5e,0x5d,0x61,0x69,0x70,0x74,0x75,0x70,0x66,0x5e,0x5b,0x5c,0x60,
0x65,0x6b,0x70,0x72,0x6d,0x66,0x60,0x5c,0x5d,0x64,0x6b,0x72,0x77,0x77,0x6f,0x68,
0x60,0x5d,0x5d,0x61,0x66,0x6d,0x72,0x72,0x6c,0x68,0x60,0x5a,0x5c,0x63,0x6b,0x73,
0x75,0x74,0x6e,0x65,0x5d,0x5a,0x5b,0x62,0x6a,0x71,0x75,0x74,0x70,0x6a,0x63,0x60,
0x60,0x65,0x69,0x6a,0x6b,0x6e,0x72,0x77,0x7f,0x8a,0x96,0xa2,0xa9,0xa9,0xa0,0x93,
0x80,0x6f,0x64,0x5b,0x57,0x56,0x4e,0x44,0x3a,0x34,0x34,0x3d,0x4c,0x61,0x75,0x85,
0x8d,0x8f,0x91,0x96,0x9a,0xa0,0xa1,0x9f,0x9b,0x9a,0x98,0x98,0x98,0x95,0x8d,0x7f,
0x6f,0x61,0x58,0x51,0x48,0x3f,0x36,0x33,0x3b,0x4a,0x5e,0x71,0x7d,0x7c,0x73,0x65,
0x5a,0x54,0x50,0x4a,0x41,0x36,0x2f,0x30,0x3e,0x55,0x6c,0x80,0x85,0x80,0x70,0x5e,
0x4f,0x49,0x46,0x42,0x3c,0x35,0x2f,0x2c,0x2c,0x2e,0x34,0x42,0x51,0x60,0x6d,0x75,
0x75,0x72,0x69,0x63,0x5e,0x5a,0x54,0x4b,0x3f,0x36,0x33,0x3b,0x4b,0x63,0x78,0x88,
0x91,0x97,0x98,0x96,0x91,0x86,0x75,0x63,0x56,0x55,0x5c,0x69,0x74,0x78,0x77,0x6e,
0x63,0x61,0x5e,0x5a,0x52,0x44,0x34,0x28,0x29,0x3b,0x58,0x71,0x81,0x7f,0x78,0x68,
0x5b,0x56,0x53,0x4d,0x46,0x38,0x2e,0x32,0x43,0x5e,0x76,0x85,0x85,0x7b,0x6d,0x60,
0x56,0x51,0x4c,0x43,0x37,0x2d,0x2d,0x3c,0x54,0x6e,0x81,0x85,0x7c,0x6d,0x5d,0x52,
0x4c,0x4a,0x46,0x40,0x36,0x2e,0x2c,0x32,0x39,0x42,0x44,0x42,0x3c,0x39,0x36,0x36,
0x37,0x38,0x38,0x39,0x38,0x3a,0x38,0x3a,0x38,0x35,0x34,0x35,0x34,0x38,0x3a,0x3a,
0x3b,0x3c,0x3a,0x3a,0x3b,0x3c,0x3c,0x3b,0x3a,0x3a,0x38,0x35,0x34,0x3b,0x49,0x59,
0x69,0x75,0x7b,0x79,0x6f,0x65,0x5c,0x58,0x5a,0x61,0x69,0x71,0x74,0x7f,0x87,0x93,
0x9d,0xa6,0xa9,0xab,0xa3,0x98,0x8a,0x7b,0x6b,0x61,0x5b,0x5d,0x63,0x6b,0x73,0x79,
0x80,0x85,0x8b,0x95,0x9b,0x9a,0x8e,0x79,0x63,0x56,0x52,0x5a,0x68,0x76,0x7b,0x78,
0x70,0x67,0x61,0x5e,0x5a,0x54,0x47,0x39,0x2e,0x32,0x3e,0x55,0x70,0x83,0x89,0x84,
0x75,0x65,0x5b,0x59,0x5e,0x64,0x6d,0x71,0x77,0x7e,0x88,0x94,0x9f,0xa7,0xab,0xab,
0xa3,0x96,0x87,0x75,0x66,0x58,0x4f,0x4b,0x49,0x44,0x3f,0x37,0x32,0x30,0x34,0x3a,
0x40,0x42,0x3f,0x37,0x2f,0x2e,0x37,0x47,0x5b,0x70,0x7b,0x78,0x73,0x68,0x5e,0x5b,
0x58,0x54,0x4c,0x40,0x35,0x35,0x40,0x54,0x6b,0x7f,0x88,0x82,0x70,0x5f,0x53,0x52,
0x59,0x67,0x75,0x7b,0x76,0x6b,0x61,0x5b,0x5d,0x64,0x6d,0x75,0x77,0x75,0x70,0x69,
0x64,0x62,0x60,0x5b,0x54,0x4c,0x42,0x38,0x32,0x2d,0x29,0x2f,0x38,0x46,0x57,0x65,
0x6e,0x74,0x73,0x6e,0x68,0x63,0x5f,0x59,0x51,0x48,0x3c,0x34,0x34,0x3e,0x50,0x66,
0x7a,0x8b,0x96,0x9c,0x9f,0x9c,0x94,0x86,0x74,0x64,0x58,0x56,0x59,0x63,0x70,0x78,
0x7f,0x89,0x93,0x9a,0x9f,0x99,0x8a,0x77,0x63,0x56,0x52,0x57,0x61,0x6f,0x7b,0x84,
0x8d,0x95,0x9a,0x9d,0x99,0x8b,0x77,0x64,0x58,0x52,0x59,0x66,0x72,0x7b,0x7b,0x73,
0x68,0x5e,0x56,0x50,0x4b,0x43,0x38,0x30,0x2b,0x2b,0x30,0x35,0x3b,0x41,0x42,0x40,
0x39,0x34,0x31,0x32,0x37,0x3c,0x3d,0x3c,0x38,0x34,0x33,0x34,0x37,0x41,0x50,0x60,
0x6f,0x7b,0x84,0x8d,0x95,0x9b,0x9d,0x9f,0xa0,0xa0,0x9e,0x9b,0x99,0x9c,0xa0,0xa2,
0xa1,0x9e,0x9c,0x9d,0x9d,0x9c,0x99,0x9b,0x9b,0x9e,0xa0,0xa0,0x9d,0xa0,0x9c,0x9a,
0x97,0x95,0x94,0x96,0x96,0x94,0x94,0x95,0x98,0x9b,0x9e,0x9e,0x9a,0x93,0x88,0x7a,
0x6e,0x63,0x58,0x50,0x47,0x3d,0x35,0x31,0x37,0x49,0x5e,0x72,0x7d,0x7f,0x78,0x6c,
0x60,0x57,0x50,0x4e,0x47,0x3c,0x33,0x30,0x3a,0x50,0x68,0x7c,0x86,0x85,0x77,0x61,
0x56,0x56,0x60,0x6f,0x7a,0x7c,0x78,0x70,0x65,0x60,0x5e,0x63,0x67,0x69,0x69,0x6e,
0x75,0x82,0x8d,0x96,0x9a,0x97,0x8d,0x7b,0x69,0x5a,0x4b,0x3e,0x34,0x30,0x33,0x3e,
0x4d,0x60,0x72,0x7c,0x7c,0x75,0x68,0x5d,0x56,0x54,0x50,0x48,0x3e,0x34,0x2e,0x34,
0x44,0x5b,0x73,0x83,0x8b,0x8e,0x8e,0x90,0x96,0x9c,0xa0,0xa0,0x98,0x8a,0x79,0x6b,
0x60,0x56,0x4e,0x48,0x42,0x3b,0x35,0x2f,0x2f,0x33,0x37,0x39,0x3e,0x3d,0x38,0x34,
0x33,0x38,0x48,0x5a,0x68,0x75,0x77,0x70,0x65,0x5a,0x53,0x50,0x4d,0x4a,0x43,0x3b,
0x34,0x34,0x35,0x38,0x3e,0x48,0x52,0x5f,0x6b,0x72,0x74,0x70,0x67,0x5e,0x56,0x53,
0x52,0x4f,0x47,0x3a,0x2d,0x2a,0x2b,0x32,0x3e,0x46,0x4c,0x56,0x5e,0x6b,0x79,0x87,
0x8f,0x96,0x96,0x91,0x84,0x78,0x68,0x55,0x44,0x38,0x34,0x36,0x3a,0x3c,0x3b,0x37,
0x33,0x35,0x3e,0x4a,0x5a,0x68,0x70,0x71,0x6e,0x66,0x5e,0x58,0x4f,0x49,0x42,0x3b,
0x33,0x2f,0x2b,0x2a,0x2d,0x34,0x3f,0x52,0x65,0x73,0x75,0x74,0x6b,0x63,0x5d,0x5b,
0x58,0x52,0x4a,0x3c,0x31,0x2f,0x38,0x4d,0x66,0x7a,0x82,0x7c,0x6f,0x60,0x57,0x56,
0x5c,0x66,0x6f,0x77,0x7e,0x86,0x91,0x9c,0xa0,0x9c,0x8d,0x79,0x65,0x56,0x4b,0x44,
0x3b,0x35,0x31,0x37,0x45,0x5b,0x6d,0x7f,0x7f,0x75,0x68,0x5b,0x52,0x52,0x50,0x4b,
0x43,0x38,0x30,0x2d,0x31,0x39,0x40,0x43,0x40,0x3b,0x35,0x34,0x38,0x44,0x52,0x61,
0x70,0x7e,0x88,0x91,0x96,0x96,0x8d,0x7e,0x6c,0x5d,0x50,0x48,0x3f,0x3c,0x38,0x36,
0x35,0x36,0x37,0x3e,0x3f,0x3d,0x3a,0x36,0x33,0x32,0x36,0x40,0x4f,0x60,0x70,0x7c,
0x83,0x88,0x8c,0x94,0x9a,0x9f,0x9f,0x9b,0x99,0x9a,0x9b,0x9d,0x9d,0x99,0x8e,0x7f,
0x6d,0x5e,0x52,0x4c,0x47,0x41,0x3b,0x35,0x32,0x35,0x38,0x3d,0x40,0x40,0x3b,0x33,
0x2f,0x2f,0x36,0x44,0x54,0x65,0x74,0x81,0x8b,0x94,0x97,0x97,0x90,0x84,0x71,0x60,
0x52,0x48,0x41,0x3c,0x38,0x37,0x37,0x38,0x3a,0x3f,0x43,0x43,0x3f,0x37,0x30,0x2f,
0x36,0x44,0x59,0x6b,0x74,0x72,0x6b,0x60,0x58,0x56,0x54,0x4e,0x46,0x3b,0x33,0x34,
0x41,0x59,0x74,0x86,0x8a,0x82,0x70,0x5e,0x50,0x4a,0x45,0x40,0x37,0x2f,0x28,0x27,
0x2c,0x36,0x3f,0x42,0x3f,0x3a,0x35,0x34,0x36,0x38,0x36,0x32,0x34,0x39,0x46,0x58,
0x69,0x78,0x7b,0x74,0x68,0x60,0x5a,0x5a,0x60,0x66,0x6b,0x70,0x74,0x7a,0x82,0x8f,
0x9a,0xa2,0xa6,0xa4,0x9c,0x91,0x82,0x72,0x66,0x5d,0x56,0x50,0x4a,0x45,0x41,0x3c,
0x36,0x33,0x32,0x33,0x37,0x3e,0x47,0x52,0x5e,0x6b,0x79,0x86,0x8e,0x93,0x95,0x91,
0x86,0x78,0x67,0x57,0x47,0x3e,0x38,0x38,0x3a,0x3c,0x37,0x37,0x33,0x35,0x40,0x4e,
0x60,0x71,0x78,0x79,0x73,0x6b,0x65,0x5e,0x58,0x50,0x45,0x3b,0x33,0x33,0x3f,0x52,
0x6a,0x7c,0x83,0x7f,0x73,0x65,0x58,0x50,0x4a,0x48,0x41,0x39,0x30,0x2e,0x2f,0x32,
0x36,0x3f,0x4b,0x58,0x66,0x6f,0x72,0x72,0x6a,0x5f,0x56,0x51,0x4e,0x49,0x45,0x3e,
0x34,0x2e,0x2b,0x2c,0x34,0x41,0x4f,0x5e,0x69,0x70,0x73,0x70,0x69,0x61,0x5b,0x58,
0x54,0x4c,0x42,0x38,0x34,0x38,0x43,0x59,0x70,0x85,0x91,0x93,0x91,0x91,0x94,0x99,
0x9f,0xa1,0x9c,0x8d,0x7e,0x6d,0x61,0x5d,0x5d,0x5f,0x64,0x67,0x6d,0x77,0x83,0x8b,
0x91,0x91,0x8b,0x82,0x72,0x61,0x51,0x45,0x3b,0x39,0x3b,0x3b,0x3a,0x37,0x34,0x34,
0x39,0x42,0x4d,0x5a,0x65,0x70,0x7b,0x88,0x93,0x9b,0xa0,0x99,0x8a,0x78,0x66,0x59,
0x54,0x55,0x5a,0x68,0x74,0x7f,0x88,0x91,0x95,0x96,0x91,0x87,0x78,0x66,0x55,0x47,
0x3f,0x3c,0x3b,0x3a,0x38,0x36,0x36,0x35,0x35,0x3c,0x45,0x51,0x5f,0x6d,0x7b,0x87,
0x91,0x96,0x9b,0x9f,0xa0,0xa1,0x9f,0x97,0x8a,0x7b,0x69,0x5c,0x55,0x56,0x59,0x62,
0x6b,0x75,0x7d,0x88,0x91,0x98,0x9b,0x97,0x8a,0x7a,0x65,0x52,0x42,0x39,0x34,0x32,
0x32,0x34,0x37,0x38,0x37,0x39,0x3e,0x46,0x53,0x63,0x70,0x7e,0x88,0x90,0x96,0x9b,
0x9e,0xa0,0xa0,0x9c,0x98,0x96,0x93,0x94,0x95,0x97,0x99,0x9b,0x9d,0x9d,0x9a,0x93,
0x81,0x6c,0x5e,0x55,0x54,0x5d,0x69,0x73,0x78,0x78,0x72,0x69,0x63,0x61,0x62,0x66,
0x6a,0x6d,0x71,0x78,0x82,0x8e,0x96,0x9a,0x96,0x89,0x75,0x63,0x51,0x44,0x3b,0x38,
0x38,0x38,0x3b,0x3c,0x3e,0x3f,0x3f,0x3b,0x39,0x38,0x37,0x37,0x38,0x39,0x38,0x34,
0x34,0x37,0x46,0x59,0x6a,0x79,0x7e,0x75,0x6a,0x5b,0x56,0x5d,0x68,0x72,0x78,0x76,
0x6f,0x68,0x61,0x5f,0x60,0x5f,0x57,0x49,0x3a,0x30,0x30,0x38,0x49,0x5f,0x75,0x88,
0x93,0x98,0x96,0x8f,0x85,0x77,0x69,0x5e,0x54,0x4b,0x42,0x38,0x31,0x2f,0x3a,0x4a,
0x5e,0x75,0x82,0x84,0x7b,0x70,0x62,0x5a,0x54,0x4d,0x46,0x3e,0x35,0x34,0x3a,0x4a,
0x60,0x76,0x87,0x91,0x96,0x98,0x94,0x8d,0x80,0x72,0x64,0x55,0x49,0x41,0x3b,0x38,
0x35,0x35,0x35,0x38,0x3a,0x3e,0x3e,0x3e,0x3a,0x37,0x36,0x36,0x36,0x3a,0x3b,0x3d,
0x3b,0x39,0x38,0x38,0x39,0x3a,0x39,0x39,0x3a,0x3b,0x3e,0x3e,0x3e,0x3f,0x3c,0x3b,
0x3b,0x3a,0x3a,0x37,0x37,0x33,0x31,0x34,0x36,0x35,0x37,0x35,0x33,0x34,0x34,0x37,
// Line 14
0x3c,0x3c,0x3a,0x38,0x36,0x37,0x39,0x3b,0x3c,0x3b,0x38,0x37,0x35,0x36,0x37,0x38,
0x37,0x38,0x37,0x37,0x38,0x38,0x37,0x37,0x36,0x37,0x37,0x37,0x35,0x35,0x35,0x34,
0x35,0x38,0x39,0x37,0x36,0x35,0x34,0x33,0x33,0x35,0x35,0x36,0x36,0x36,0x36,0x39,
0x3e,0x47,0x4f,0x56,0x60,0x6a,0x73,0x7c,0x83,0x8b,0x91,0x94,0x95,0x97,0x97,0x98,
0x97,0x98,0x98,0x98,0x99,0x98,0x96,0x96,0x95,0x92,0x8e,0x88,0x82,0x7c,0x73,0x6b,
0x62,0x5a,0x52,0x4a,0x43,0x3d,0x3a,0x39,0x38,0x3a,0x3c,0x3c,0x3a,0x3b,0x3b,0x3a,
0x3b,0x3a,0x39,0x38,0x38,0x37,0x36,0x3a,0x3e,0x45,0x4c,0x55,0x5b,0x67,0x71,0x78,
0x80,0x88,0x8c,0x91,0x94,0x95,0x96,0x96,0x95,0x95,0x93,0x92,0x93,0x95,0x98,0x99,
0x99,0x99,0x95,0x90,0x89,0x81,0x7b,0x73,0x6a,0x60,0x54,0x4b,0x46,0x42,0x3e,0x3d,
0x3d,0x3d,0x3a,0x3c,0x37,0x36,0x37,0x37,0x37,0x35,0x34,0x32,0x34,0x38,0x3b,0x3c,
0x41,0x44,0x49,0x51,0x58,0x60,0x69,0x71,0x79,0x82,0x87,0x8c,0x90,0x93,0x95,0x95,
0x96,0x98,0x99,0x99,0x98,0x99,0x9a,0x9a,0x9a,0x99,0x98,0x95,0x90,0x89,0x82,0x7b,
0x74,0x69,0x62,0x59,0x51,0x48,0x44,0x3f,0x3c,0x3b,0x3b,0x3b,0x3a,0x39,0x38,0x3a,
0x3b,0x3c,0x3e,0x3e,0x3c,0x3b,0x39,0x39,0x3a,0x3c,0x41,0x48,0x4e,0x55,0x5c,0x65,
0x6f,0x7a,0x84,0x8c,0x90,0x93,0x92,0x93,0x95,0x96,0x96,0x95,0x95,0x95,0x95,0x97,
0x97,0x96,0x96,0x94,0x91,0x8e,0x89,0x81,0x7a,0x70,0x64,0x5a,0x52,0x4c,0x48,0x42,
0x3c,0x3a,0x38,0x39,0x3b,0x3b,0x3b,0x3b,0x3a,0x38,0x36,0x36,0x37,0x37,0x36,0x35,
0x35,0x39,0x3c,0x41,0x48,0x4f,0x59,0x62,0x6b,0x73,0x7c,0x86,0x8c,0x90,0x92,0x92,
0x93,0x97,0x98,0x99,0x95,0x96,0x95,0x96,0x97,0x98,0x95,0x98,0x97,0x95,0x91,0x8a,
0x83,0x7c,0x73,0x69,0x5f,0x57,0x4f,0x48,0x40,0x3b,0x38,0x38,0x38,0x3b,0x3b,0x3b,
0x38,0x3a,0x3b,0x3a,0x3b,0x3b,0x3a,0x3a,0x39,0x38,0x38,0x3a,0x3e,0x46,0x51,0x5a,
0x61,0x6c,0x74,0x7d,0x87,0x90,0x94,0x97,0x99,0x9a,0x9a,0x99,0x98,0x98,0x98,0x98,
0x98,0x99,0x9a,0x9a,0x99,0x97,0x92,0x8f,0x89,0x83,0x7d,0x73,0x67,0x5d,0x54,0x4e,
0x48,0x44,0x3f,0x3d,0x3b,0x38,0x35,0x35,0x37,0x39,0x3b,0x39,0x37,0x3b,0x3b,0x3b,
0x3b,0x3c,0x3c,0x3b,0x3e,0x41,0x47,0x4f,0x59,0x64,0x6d,0x75,0x7e,0x89,0x8e,0x93,
0x95,0x97,0x97,0x98,0x97,0x97,0x97,0x96,0x95,0x95,0x95,0x94,0x93,0x93,0x92,0x8f,
0x8c,0x87,0x7f,0x78,0x70,0x67,0x5e,0x56,0x4f,0x49,0x44,0x3e,0x3b,0x3a,0x3a,0x3a,
0x3c,0x40,0x3f,0x40,0x3e,0x3e,0x3f,0x40,0x3b,0x3b,0x3a,0x38,0x36,0x35,0x35,0x36,
0x37,0x38,0x38,0x38,0x37,0x38,0x3b,0x3b,0x3b,0x3d,0x3c,0x3a,0x38,0x38,0x39,0x3b,
0x3b,0x3a,0x3a,0x3a,0x38,0x39,0x3c,0x3b,0x3b,0x3c,0x3b,0x38,0x37,0x37,0x38,0x39,
0x38,0x38,0x39,0x38,0x38,0x3a,0x3b,0x3d,0x3c,0x3b,0x39,0x38,0x39,0x38,0x39,0x3b,
0x3b,0x3d,0x3d,0x3c,0x3b,0x3b,0x3a,0x38,0x38,0x38,0x38,0x37,0x36,0x35,0x32,0x34,
0x35,0x38,0x3a,0x38,0x36,0x35,0x36,0x36,0x37,0x39,0x39,0x39,0x39,0x39,0x38,0x3a,
0x3b,0x3c,0x41,0x44,0x46,0x4b,0x53,0x5d,0x66,0x70,0x78,0x80,0x84,0x89,0x8c,0x90,
0x92,0x94,0x95,0x94,0x93,0x95,0x95,0x95,0x95,0x95,0x94,0x97,0x98,0x9a,0x99,0x98,
0x95,0x93,0x93,0x95,0x96,0x97,0x97,0x95,0x93,0x93,0x93,0x96,0x98,0x9a,0x9a,0x98,
0x96,0x96,0x95,0x95,0x97,0x99,0x98,0x96,0x93,0x93,0x92,0x95,0x95,0x96,0x97,0x97,
0x95,0x98,0x98,0x99,0x98,0x98,0x96,0x96,0x95,0x95,0x93,0x92,0x91,0x92,0x93,0x93,
0x93,0x96,0x97,0x96,0x95,0x95,0x96,0x9a,0x9c,0x99,0x96,0x95,0x97,0x9a,0x98,0x95,
0x95,0x97,0x98,0x98,0x97,0x97,0x99,0x9c,0x9b,0x99,0x97,0x99,0x9a,0x9a,0x99,0x99,
0x98,0x99,0x97,0x95,0x95,0x95,0x95,0x97,0x96,0x95,0x97,0x97,0x96,0x97,0x97,0x97,
0x96,0x96,0x98,0x98,0x97,0x96,0x97,0x99,0x9a,0x99,0x98,0x97,0x97,0x97,0x95,0x94,
0x95,0x98,0x99,0x99,0x99,0x9a,0x98,0x99,0x97,0x95,0x95,0x97,0x97,0x97,0x95,0x95,
0x97,0x97,0x97,0x97,0x96,0x96,0x96,0x96,0x96,0x96,0x97,0x95,0x94,0x94,0x95,0x94,
0x93,0x92,0x93,0x95,0x96,0x96,0x97,0x96,0x97,0x98,0x98,0x98,0x98,0x9a,0x99,0x98,
0x97,0x95,0x93,0x93,0x93,0x96,0x98,0x99,0x99,0x99,0x97,0x96,0x97,0x9a,0x9c,0x9a,
0x9c,0x9a,0x96,0x95,0x95,0x95,0x95,0x94,0x93,0x95,0x95,0x93,0x93,0x95,0x96,0x98,
0x99,0x99,0x99,0x98,0x93,0x8e,0x89,0x82,0x7a,0x72,0x68,0x5f,0x58,0x52,0x4c,0x47,
0x41,0x3f,0x3f,0x3e,0x3b,0x3b,0x3b,0x3b,0x3a,0x3b,0x3a,0x39,0x39,0x38,0x37,0x37,
0x38,0x39,0x3a,0x3b,0x3b,0x3c,0x3e,0x3e,0x3b,0x3c,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,
0x38,0x36,0x38,0x3a,0x3b,0x3c,0x3c,0x3b,0x3b,0x3a,0x39,0x38,0x39,0x3b,0x3d,0x41,
0x45,0x4a,0x51,0x5a,0x63,0x6f,0x78,0x80,0x86,0x8b,0x8f,0x90,0x92,0x95,0x96,0x98,
0x97,0x95,0x95,0x95,0x95,0x96,0x95,0x92,0x93,0x94,0x94,0x93,0x92,0x95,0x96,0x97,
0x97,0x96,0x96,0x96,0x96,0x97,0x97,0x97,0x95,0x95,0x95,0x97,0x97,0x96,0x96,0x96,
0x96,0x98,0x99,0x9a,0x9a,0x98,0x97,0x95,0x95,0x97,0x98,0x99,0x98,0x97,0x97,0x97,
0x96,0x98,0x99,0x98,0x96,0x97,0x98,0x99,0x98,0x98,0x98,0x9a,0x98,0x96,0x95,0x95,
0x95,0x96,0x95,0x95,0x93,0x93,0x94,0x96,0x99,0x9b,0x9c,0x9a,0x98,0x97,0x97,0x98,
0x99,0x9a,0x9a,0x97,0x96,0x96,0x96,0x93,0x96,0x97,0x97,0x97,0x96,0x95,0x94,0x92,
0x8d,0x8a,0x83,0x7b,0x73,0x68,0x5d,0x56,0x4f,0x4a,0x45,0x41,0x3d,0x3c,0x3c,0x3b,
0x3b,0x3b,0x3b,0x3b,0x3c,0x3b,0x3a,0x3a,0x39,0x38,0x37,0x38,0x3a,0x3a,0x3a,0x38,
0x38,0x3a,0x38,0x38,0x3b,0x3b,0x39,0x38,0x37,0x37,0x37,0x38,0x38,0x3b,0x3b,0x3b,
0x38,0x3a,0x3a,0x3b,0x3c,0x3e,0x3c,0x3b,0x3a,0x39,0x39,0x39,0x3b,0x3c,0x3b,0x3a,
0x3a,0x3b,0x3c,0x3c,0x3c,0x3c,0x3a,0x38,0x37,0x38,0x38,0x37,0x37,0x38,0x39,0x39,
0x3a,0x3a,0x3a,0x3b,0x3a,0x3a,0x39,0x3a,0x38,0x36,0x37,0x38,0x39,0x3c,0x3c,0x3c,
0x3c,0x3b,0x3b,0x3b,0x39,0x37,0x37,0x37,0x36,0x35,0x35,0x35,0x35,0x36,0x35,0x33,
0x34,0x35,0x35,0x35,0x34,0x35,0x36,0x37,0x37,0x3a,0x3a,0x3a,0x38,0x37,0x35,0x35,
0x35,0x36,0x35,0x38,0x34,0x33,0x35,0x36,0x36,0x37,0x37,0x35,0x35,0x36,0x37,0x37,
0x36,0x36,0x36,0x38,0x38,0x38,0x38,0x37,0x37,0x39,0x3a,0x3b,0x3b,0x3b,0x3a,0x3a,
0x38,0x39,0x38,0x38,0x36,0x35,0x35,0x35,0x35,0x36,0x36,0x35,0x35,0x37,0x38,0x3a,
0x39,0x38,0x3a,0x3b,0x3b,0x39,0x3b,0x3b,0x3b,0x3b,0x39,0x37,0x38,0x39,0x3a,0x3a,
0x3a,0x3a,0x39,0x37,0x36,0x37,0x37,0x37,0x36,0x37,0x35,0x34,0x34,0x35,0x36,0x37,
0x38,0x38,0x39,0x38,0x39,0x3a,0x3b,0x3b,0x3c,0x3e,0x3d,0x3b,0x39,0x38,0x38,0x38,
0x37,0x36,0x36,0x37,0x36,0x38,0x38,0x38,0x38,0x37,0x35,0x36,0x38,0x3b,0x3b,0x3b,
0x38,0x37,0x37,0x38,0x38,0x3a,0x3a,0x38,0x38,0x36,0x36,0x38,0x3a,0x3b,0x3b,0x3a,
0x3a,0x38,0x38,0x38,0x37,0x37,0x36,0x33,0x34,0x35,0x33,0x33,0x33,0x34,0x35,0x35,
0x33,0x37,0x38,0x39,0x38,0x38,0x38,0x38,0x39,0x3a,0x39,0x38,0x37,0x38,0x38,0x37,
0x36,0x35,0x33,0x33,0x34,0x36,0x37,0x37,0x34,0x32,0x32,0x33,0x35,0x37,0x37,0x36,
0x34,0x34,0x34,0x35,0x38,0x3a,0x38,0x38,0x37,0x36,0x35,0x37,0x35,0x36,0x35,0x34,
0x32,0x35,0x34,0x35,0x36,0x37,0x35,0x35,0x33,0x33,0x34,0x35,0x36,0x37,0x36,0x35,
0x35,0x36,0x36,0x37,0x38,0x37,0x35,0x36,0x36,0x38,0x3a,0x3a,0x3a,0x3b,0x3a,0x39,
0x39,0x38,0x37,0x36,0x37,0x38,0x36,0x37,0x36,0x37,0x36,0x34,0x32,0x33,0x34,0x33,
0x35,0x35,0x36,0x37,0x38,0x37,0x38,0x3b,0x3c,0x3c,0x3b,0x39,0x37,0x38,0x38,0x39,
0x39,0x3a,0x39,0x3a,0x39,0x39,0x39,0x37,0x35,0x35,0x35,0x35,0x36,0x37,0x36,0x35,
0x35,0x36,0x36,0x38,0x38,0x37,0x36,0x35,0x35,0x36,0x37,0x38,0x39,0x3a,0x3a,0x3a,
0x3b,0x3a,0x38,0x39,0x38,0x37,0x35,0x35,0x35,0x38,0x37,0x37,0x36,0x35,0x33,0x33,
0x34,0x37,0x38,0x37,0x36,0x34,0x34,0x35,0x34,0x35,0x35,0x35,0x36,0x36,0x35,0x35,
0x37,0x3a,0x3c,0x3d,0x3d,0x3b,0x3a,0x37,0x34,0x35,0x34,0x34,0x33,0x34,0x33,0x35,
0x35,0x37,0x39,0x39,0x37,0x37,0x37,0x37,0x36,0x36,0x35,0x34,0x34,0x35,0x35,0x38,
0x35,0x36,0x37,0x36,0x34,0x34,0x35,0x35,0x35,0x36,0x38,0x37,0x37,0x37,0x37,0x38,
0x37,0x37,0x38,0x37,0x36,0x36,0x36,0x36,0x36,0x35,0x34,0x35,0x37,0x39,0x38,0x38,
0x37,0x38,0x39,0x3a,0x3a,0x3a,0x37,0x35,0x35,0x35,0x35,0x37,0x38,0x37,0x36,0x35,
0x37,0x37,0x37,0x37,0x37,0x39,0x38,0x35,0x38,0x38,0x36,0x35,0x34,0x35,0x37,0x38,
0x37,0x37,0x37,0x37,0x36,0x36,0x36,0x37,0x38,0x38,0x35,0x32,0x31,0x33,0x35,0x35,
0x34,0x35,0x33,0x33,0x34,0x36,0x36,0x38,0x37,0x37,0x35,0x36,0x37,0x38,0x37,0x36,
0x33,0x34,0x34,0x35,0x37,0x37,0x34,0x33,0x33,0x33,0x32,0x34,0x34,0x35,0x35,0x35,
0x33,0x35,0x35,0x34,0x34,0x36,0x38,0x38,0x37,0x36,0x36,0x37,0x36,0x36,0x36,0x36,
// Line 15
0x35,0x36,0x3a,0x3a,0x39,0x38,0x36,0x35,0x35,0x36,0x38,0x38,0x38,0x36,0x36,0x38,
0x3a,0x3b,0x3a,0x38,0x35,0x36,0x35,0x34,0x34,0x35,0x35,0x35,0x35,0x36,0x38,0x38,
0x36,0x36,0x35,0x36,0x37,0x38,0x38,0x35,0x33,0x34,0x34,0x35,0x35,0x38,0x3a,0x3a,
0x36,0x34,0x35,0x3b,0x47,0x59,0x6b,0x77,0x7f,0x7b,0x70,0x66,0x5c,0x5b,0x62,0x6d,
0x75,0x79,0x77,0x70,0x67,0x61,0x61,0x68,0x70,0x77,0x7a,0x78,0x73,0x6c,0x65,0x61,
0x61,0x66,0x6d,0x73,0x78,0x78,0x74,0x6e,0x66,0x60,0x5f,0x64,0x6c,0x72,0x78,0x76,
0x73,0x6c,0x66,0x62,0x63,0x66,0x6b,0x73,0x79,0x79,0x74,0x6c,0x64,0x61,0x61,0x66,
0x6e,0x78,0x7c,0x7a,0x73,0x6a,0x63,0x60,0x63,0x6a,0x74,0x7a,0x7c,0x7b,0x75,0x6e,
0x6a,0x69,0x6b,0x6d,0x6e,0x70,0x70,0x73,0x75,0x7c,0x87,0x92,0x9c,0xa7,0xab,0xa9,
0xa2,0x97,0x87,0x77,0x68,0x5e,0x58,0x55,0x50,0x49,0x40,0x39,0x38,0x3e,0x4c,0x60,
0x75,0x85,0x8e,0x92,0x94,0x98,0x9e,0xa5,0xa8,0xa6,0x9d,0x90,0x80,0x72,0x66,0x60,
0x60,0x63,0x68,0x72,0x7a,0x81,0x88,0x8e,0x95,0x9f,0xa6,0xab,0xa9,0xa4,0x9b,0x95,
0x93,0x96,0x98,0x9d,0x96,0x87,0x73,0x5f,0x53,0x53,0x5b,0x69,0x77,0x80,0x81,0x7b,
0x70,0x67,0x64,0x67,0x6c,0x75,0x7c,0x7d,0x78,0x70,0x67,0x61,0x5f,0x65,0x6e,0x77,
0x7a,0x79,0x73,0x6a,0x62,0x5f,0x64,0x6d,0x73,0x79,0x7b,0x77,0x73,0x6c,0x67,0x66,
0x62,0x5d,0x55,0x4a,0x3e,0x33,0x2f,0x2b,0x2d,0x34,0x3c,0x47,0x54,0x63,0x6e,0x76,
0x78,0x75,0x6c,0x61,0x5a,0x5d,0x67,0x74,0x7b,0x7c,0x76,0x6b,0x61,0x5b,0x5d,0x67,
0x6f,0x75,0x77,0x74,0x6e,0x6a,0x65,0x63,0x61,0x5b,0x52,0x44,0x3c,0x31,0x2a,0x26,
0x27,0x2b,0x36,0x41,0x51,0x63,0x70,0x76,0x77,0x71,0x69,0x63,0x5f,0x5c,0x57,0x4e,
0x41,0x38,0x36,0x42,0x57,0x6f,0x7f,0x85,0x7f,0x72,0x63,0x58,0x51,0x4e,0x4b,0x44,
0x3b,0x39,0x41,0x54,0x6b,0x80,0x88,0x82,0x75,0x64,0x58,0x5b,0x65,0x72,0x7c,0x7e,
0x78,0x72,0x6a,0x64,0x63,0x69,0x6e,0x74,0x7a,0x7c,0x79,0x73,0x6a,0x65,0x64,0x68,
0x70,0x7a,0x7d,0x7b,0x74,0x6a,0x61,0x5b,0x5a,0x5b,0x59,0x52,0x47,0x3a,0x2f,0x29,
0x2b,0x38,0x41,0x48,0x47,0x3e,0x34,0x2f,0x32,0x3f,0x51,0x69,0x7b,0x84,0x82,0x77,
0x6b,0x61,0x5f,0x64,0x6a,0x70,0x76,0x7c,0x81,0x88,0x91,0x9d,0xa6,0xab,0xa8,0x9f,
0x92,0x86,0x7b,0x70,0x65,0x5a,0x51,0x4a,0x44,0x3f,0x3b,0x38,0x34,0x34,0x34,0x37,
0x40,0x50,0x5f,0x6d,0x77,0x7b,0x77,0x6f,0x65,0x5d,0x57,0x52,0x4b,0x45,0x3c,0x35,
0x30,0x2f,0x32,0x38,0x45,0x51,0x5f,0x6e,0x75,0x79,0x76,0x6e,0x66,0x64,0x65,0x6a,
0x70,0x76,0x78,0x7b,0x7e,0x86,0x8f,0x9c,0xa0,0x98,0x88,0x73,0x5f,0x5b,0x5c,0x68,
0x79,0x85,0x87,0x82,0x73,0x64,0x5d,0x5f,0x67,0x6e,0x73,0x76,0x73,0x6d,0x63,0x5b,
0x5b,0x64,0x70,0x7a,0x7e,0x7b,0x74,0x69,0x62,0x61,0x63,0x63,0x5c,0x4f,0x3e,0x32,
0x31,0x3c,0x51,0x6a,0x80,0x8f,0x98,0x9b,0x9b,0x9a,0x93,0x86,0x77,0x67,0x57,0x49,
0x43,0x3f,0x3c,0x39,0x35,0x32,0x32,0x36,0x3a,0x40,0x3f,0x3b,0x36,0x34,0x31,0x32,
0x34,0x37,0x38,0x39,0x36,0x35,0x36,0x39,0x3f,0x4a,0x56,0x66,0x75,0x82,0x8c,0x94,
0x9a,0x9f,0xa4,0xa8,0xa9,0xa6,0xa2,0x9d,0x99,0x9a,0x9b,0x9b,0x9f,0xa1,0xa1,0x9e,
0x97,0x8c,0x80,0x6f,0x5f,0x55,0x4d,0x46,0x3e,0x38,0x32,0x2f,0x2f,0x33,0x39,0x3f,
0x41,0x3f,0x39,0x32,0x32,0x3a,0x46,0x54,0x64,0x75,0x82,0x8b,0x91,0x95,0x96,0x91,
0x87,0x79,0x69,0x59,0x4c,0x46,0x42,0x3f,0x3d,0x3e,0x3c,0x3b,0x38,0x39,0x3a,0x42,
0x4c,0x5a,0x68,0x76,0x83,0x90,0x96,0x96,0x90,0x88,0x7e,0x71,0x61,0x51,0x46,0x40,
0x3e,0x40,0x44,0x4b,0x5a,0x6b,0x7a,0x84,0x8c,0x93,0x99,0x9f,0xa1,0xa0,0xa0,0x9e,
0x9b,0x9a,0x98,0x98,0x98,0x97,0x90,0x84,0x75,0x68,0x5d,0x5f,0x61,0x66,0x6f,0x79,
0x82,0x8d,0x93,0x9a,0xa0,0xa6,0xa7,0xa4,0x9d,0x97,0x94,0x93,0x92,0x94,0x97,0x9b,
0x9d,0x9d,0x9b,0x99,0x9a,0x9b,0x9b,0x9a,0x94,0x88,0x7d,0x6e,0x5f,0x56,0x51,0x4e,
0x49,0x43,0x3d,0x3e,0x49,0x5b,0x6d,0x7f,0x83,0x7d,0x6e,0x5f,0x57,0x5b,0x64,0x71,
0x7b,0x7c,0x73,0x67,0x5d,0x57,0x55,0x57,0x54,0x4b,0x3d,0x30,0x28,0x29,0x2f,0x3c,
0x46,0x48,0x45,0x3f,0x38,0x34,0x35,0x3f,0x4e,0x5f,0x6f,0x7c,0x86,0x91,0x96,0x99,
0x9e,0xa3,0xa5,0xa2,0x9a,0x8e,0x7f,0x70,0x63,0x57,0x4b,0x44,0x3f,0x3e,0x3a,0x36,
0x33,0x31,0x31,0x36,0x41,0x51,0x62,0x6f,0x75,0x76,0x71,0x6a,0x61,0x5c,0x56,0x4e,
0x45,0x3b,0x33,0x36,0x3c,0x4f,0x65,0x7a,0x8a,0x96,0x9d,0x9e,0x9b,0x93,0x88,0x79,
0x6b,0x5f,0x59,0x5d,0x65,0x70,0x7a,0x82,0x88,0x91,0x98,0x9c,0x9b,0x8f,0x7a,0x64,
0x52,0x4f,0x54,0x64,0x73,0x7e,0x80,0x78,0x6d,0x65,0x61,0x63,0x6b,0x71,0x73,0x74,
0x76,0x7b,0x88,0x96,0xa2,0xa8,0xad,0xa8,0x9e,0x97,0x92,0x92,0x97,0x9c,0x9d,0x98,
0x8c,0x7c,0x6c,0x5f,0x5a,0x5f,0x6a,0x74,0x7c,0x83,0x87,0x8c,0x93,0x97,0x95,0x8c,
0x7a,0x65,0x52,0x44,0x3c,0x3b,0x3b,0x39,0x38,0x36,0x32,0x2f,0x36,0x41,0x4f,0x5f,
0x6d,0x76,0x7a,0x74,0x6a,0x63,0x5b,0x56,0x50,0x49,0x3f,0x38,0x39,0x43,0x54,0x6c,
0x80,0x89,0x85,0x78,0x68,0x5d,0x59,0x5d,0x67,0x70,0x76,0x7e,0x85,0x8e,0x97,0xa1,
0xa8,0xab,0xa8,0xa2,0x99,0x8f,0x80,0x6f,0x60,0x57,0x59,0x64,0x73,0x7f,0x82,0x7d,
0x72,0x67,0x63,0x64,0x65,0x6c,0x6d,0x6b,0x6d,0x73,0x7f,0x90,0x9c,0xa0,0x9b,0x8b,
0x78,0x67,0x59,0x4e,0x47,0x42,0x3c,0x3b,0x41,0x4f,0x60,0x73,0x7f,0x82,0x7a,0x6c,
0x5f,0x59,0x5b,0x64,0x6e,0x77,0x78,0x73,0x6b,0x65,0x5f,0x61,0x5e,0x5a,0x51,0x46,
0x3b,0x35,0x31,0x31,0x37,0x40,0x49,0x52,0x5b,0x66,0x70,0x7b,0x84,0x8b,0x92,0x9b,
0xa3,0xa8,0xa7,0xa5,0xa1,0x9d,0x98,0x98,0x97,0x95,0x8e,0x82,0x70,0x62,0x56,0x4d,
0x46,0x41,0x3e,0x3d,0x3c,0x3b,0x37,0x37,0x38,0x3e,0x4b,0x5a,0x69,0x76,0x7a,0x74,
0x69,0x61,0x5d,0x5f,0x64,0x69,0x6f,0x75,0x7b,0x84,0x8f,0x9b,0xa0,0x9e,0x93,0x82,
0x6e,0x5d,0x4d,0x43,0x3c,0x3b,0x3c,0x41,0x4b,0x5b,0x6a,0x75,0x7d,0x85,0x8b,0x91,
0x94,0x91,0x86,0x75,0x63,0x56,0x54,0x5d,0x6a,0x74,0x7e,0x7e,0x76,0x6d,0x66,0x63,
0x5f,0x57,0x4a,0x3e,0x35,0x34,0x3d,0x4e,0x63,0x79,0x87,0x90,0x94,0x97,0x98,0x9b,
0x9f,0xa2,0xa1,0x9d,0x9a,0x9a,0x9c,0x9e,0x9e,0xa0,0x9f,0x9e,0x9d,0x9e,0x9f,0x9e,
0xa1,0x9e,0x97,0x8e,0x82,0x72,0x68,0x5b,0x4f,0x48,0x40,0x3a,0x38,0x3b,0x42,0x51,
0x63,0x76,0x85,0x8e,0x91,0x95,0x9a,0x9e,0xa1,0xa5,0xa3,0x9c,0x8f,0x7e,0x6c,0x61,
0x56,0x4f,0x4a,0x45,0x40,0x3b,0x35,0x31,0x32,0x3a,0x40,0x42,0x42,0x3c,0x35,0x32,
0x35,0x3e,0x4e,0x5f,0x70,0x7f,0x87,0x8d,0x90,0x9a,0xa2,0xa8,0xa9,0xa6,0xa0,0x9c,
0x9b,0x9d,0xa0,0x9e,0x97,0x8a,0x79,0x69,0x5d,0x59,0x5c,0x63,0x6b,0x74,0x7e,0x8a,
0x96,0x9d,0x9d,0x96,0x88,0x79,0x6a,0x5a,0x4d,0x42,0x39,0x36,0x39,0x40,0x46,0x57,
0x65,0x74,0x82,0x8d,0x95,0x9a,0x98,0x8f,0x83,0x74,0x65,0x5a,0x50,0x47,0x3e,0x37,
0x36,0x3d,0x4a,0x5b,0x6c,0x7d,0x82,0x7e,0x73,0x66,0x5d,0x5d,0x64,0x6c,0x73,0x7c,
0x80,0x85,0x8c,0x96,0xa1,0xab,0xae,0xab,0xa7,0xa1,0x9d,0x9b,0x9c,0x9f,0xa3,0xa5,
0xa4,0xa3,0xa1,0x9d,0x9b,0x99,0x98,0x9b,0x9d,0x9e,0x9e,0x9d,0x9c,0x9b,0x9d,0x9e,
0x9e,0x9e,0x98,0x8b,0x7a,0x6d,0x60,0x57,0x51,0x4c,0x44,0x3d,0x39,0x3f,0x4d,0x5f,
0x70,0x7f,0x80,0x77,0x68,0x5b,0x53,0x4e,0x4a,0x46,0x3f,0x36,0x2f,0x2b,0x2c,0x34,
0x39,0x3f,0x3f,0x3a,0x35,0x32,0x31,0x36,0x3a,0x3d,0x3d,0x3c,0x38,0x35,0x34,0x35,
0x39,0x42,0x4e,0x5d,0x70,0x7f,0x8b,0x96,0x9d,0xa1,0xa5,0xa8,0xa8,0xa6,0x9d,0x92,
0x83,0x73,0x65,0x5e,0x5e,0x64,0x6d,0x79,0x7f,0x7d,0x75,0x69,0x5e,0x59,0x54,0x50,
0x4b,0x41,0x36,0x2d,0x2a,0x2f,0x37,0x44,0x46,0x41,0x38,0x30,0x2d,0x34,0x42,0x54,
0x67,0x76,0x82,0x8e,0x95,0x9b,0xa0,0x9e,0x91,0x7e,0x6a,0x5d,0x5b,0x62,0x6d,0x78,
0x7f,0x7c,0x74,0x6c,0x64,0x5f,0x59,0x50,0x44,0x36,0x2d,0x2f,0x3c,0x53,0x6b,0x7f,
0x87,0x82,0x73,0x67,0x5d,0x56,0x52,0x4c,0x43,0x3b,0x38,0x3b,0x4b,0x63,0x7a,0x89,
0x92,0x94,0x95,0x97,0x9d,0xa4,0xa8,0xa5,0x9c,0x90,0x81,0x72,0x64,0x5b,0x52,0x49,
0x40,0x3b,0x38,0x39,0x40,0x4f,0x61,0x73,0x84,0x92,0x9b,0x9d,0x9b,0x96,0x8b,0x7d,
0x6d,0x5f,0x59,0x57,0x5c,0x64,0x73,0x7e,0x88,0x91,0x98,0x9f,0xa5,0xa6,0xa3,0xa1,
0x98,0x8d,0x7f,0x73,0x67,0x63,0x60,0x62,0x67,0x70,0x78,0x7f,0x85,0x8d,0x95,0x9c,
0x9f,0xa1,0xa2,0xa2,0xa0,0x9e,0x9c,0x9d,0x9e,0x9f,0x9e,0x9b,0x9d,0x9b,0x96,0x8c,
0x7f,0x6f,0x65,0x5b,0x57,0x61,0x6d,0x78,0x7c,0x7a,0x73,0x6b,0x64,0x63,0x65,0x6c,
0x73,0x79,0x7a,0x76,0x6f,0x69,0x64,0x63,0x66,0x6b,0x70,0x73,0x75,0x79,0x7f,0x89,
0x96,0xa3,0xab,0xaf,0xad,0xa8,0xa1,0x9a,0x97,0x97,0x99,0x9e,0xa1,0x9f,0x9d,0x9b,
0x98,0x98,0x99,0x9c,0x9b,0x98,0x8d,0x7e,0x6c,0x5d,0x50,0x4a,0x40,0x3a,0x38,0x35,
// Line 16
0x36,0x36,0x36,0x35,0x35,0x35,0x37,0x38,0x36,0x35,0x34,0x34,0x36,0x39,0x3b,0x3c,
0x3a,0x3a,0x3c,0x3d,0x3e,0x3c,0x3a,0x37,0x36,0x35,0x34,0x33,0x33,0x34,0x33,0x32,
0x32,0x33,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x34,0x32,0x33,0x37,0x3d,0x3e,0x41,
0x3b,0x39,0x3a,0x40,0x4c,0x5f,0x71,0x7c,0x7e,0x76,0x6a,0x5f,0x5a,0x5e,0x67,0x72,
0x77,0x76,0x6e,0x66,0x5d,0x5b,0x5c,0x61,0x6a,0x72,0x76,0x77,0x72,0x6c,0x67,0x61,
0x60,0x66,0x6f,0x76,0x77,0x75,0x6e,0x67,0x61,0x5f,0x60,0x67,0x6d,0x74,0x78,0x78,
0x72,0x6b,0x64,0x5f,0x61,0x69,0x70,0x75,0x78,0x76,0x6e,0x66,0x5f,0x5e,0x63,0x68,
0x6f,0x77,0x78,0x73,0x6a,0x64,0x5d,0x5b,0x5e,0x67,0x71,0x77,0x77,0x72,0x6d,0x66,
0x61,0x60,0x63,0x67,0x6c,0x6d,0x6d,0x70,0x75,0x7b,0x85,0x92,0x9e,0xa6,0xa8,0xa4,
0x94,0x8b,0x7d,0x72,0x67,0x5f,0x58,0x54,0x4c,0x43,0x39,0x37,0x3b,0x46,0x57,0x6a,
0x7a,0x88,0x8f,0x92,0x95,0x97,0x99,0x9d,0x9d,0x9a,0x94,0x89,0x7a,0x6a,0x5b,0x53,
0x53,0x5d,0x69,0x76,0x7c,0x7c,0x75,0x6b,0x61,0x5f,0x63,0x6c,0x73,0x78,0x76,0x6f,
0x67,0x61,0x5f,0x63,0x69,0x6e,0x6e,0x6f,0x70,0x73,0x7b,0x87,0x95,0xa5,0xa9,0xa8,
0xa5,0x9f,0x9a,0x97,0x99,0x9b,0x9b,0x95,0x89,0x79,0x69,0x5b,0x4f,0x47,0x3e,0x35,
0x2e,0x30,0x3c,0x52,0x67,0x78,0x80,0x7c,0x70,0x64,0x5b,0x57,0x54,0x4e,0x42,0x37,
0x31,0x36,0x47,0x61,0x78,0x85,0x85,0x7b,0x6b,0x5d,0x55,0x4f,0x49,0x43,0x39,0x30,
0x2b,0x2f,0x33,0x3c,0x3f,0x3e,0x3b,0x35,0x33,0x36,0x38,0x38,0x34,0x31,0x32,0x3e,
0x4f,0x65,0x77,0x80,0x7e,0x75,0x67,0x5e,0x5d,0x64,0x6c,0x70,0x72,0x75,0x7a,0x85,
0x92,0x9d,0xa3,0x9e,0x8e,0x75,0x5f,0x51,0x50,0x59,0x64,0x70,0x7b,0x84,0x8c,0x95,
0x9c,0x9e,0x98,0x88,0x72,0x5f,0x54,0x55,0x5e,0x69,0x72,0x7b,0x83,0x8c,0x94,0x9a,
0x9c,0x95,0x87,0x72,0x5e,0x53,0x55,0x61,0x6f,0x7a,0x7d,0x7a,0x72,0x69,0x63,0x60,
0x5a,0x50,0x45,0x38,0x30,0x34,0x3f,0x53,0x6b,0x80,0x8d,0x96,0x9a,0x98,0x91,0x89,
0x7c,0x6e,0x60,0x54,0x49,0x43,0x3e,0x3b,0x3c,0x3c,0x3c,0x3c,0x3e,0x41,0x45,0x4d,
0x57,0x64,0x72,0x7e,0x87,0x91,0x97,0x9d,0xa4,0xa6,0xa6,0xa4,0x9e,0x99,0x97,0x9a,
0x9c,0x9c,0x95,0x87,0x71,0x65,0x5b,0x58,0x62,0x70,0x7b,0x7f,0x79,0x6e,0x64,0x5e,
0x5d,0x65,0x6d,0x73,0x75,0x73,0x6b,0x61,0x5a,0x56,0x56,0x58,0x53,0x48,0x3d,0x32,
0x2b,0x2c,0x33,0x3d,0x46,0x49,0x42,0x39,0x30,0x30,0x35,0x4a,0x5c,0x6e,0x7a,0x7c,
0x76,0x6d,0x61,0x5d,0x61,0x6c,0x77,0x7d,0x7d,0x76,0x6f,0x67,0x62,0x61,0x5d,0x54,
0x48,0x3c,0x33,0x33,0x3f,0x56,0x6c,0x82,0x91,0x9a,0x9e,0x9a,0x94,0x8b,0x7e,0x6f,
0x61,0x56,0x4c,0x43,0x3d,0x3a,0x38,0x3e,0x4c,0x60,0x74,0x80,0x82,0x79,0x6b,0x5e,
0x5a,0x5e,0x67,0x6e,0x77,0x7b,0x7d,0x85,0x8f,0x9a,0x9e,0x9a,0x8a,0x78,0x63,0x55,
0x51,0x54,0x5f,0x6d,0x79,0x84,0x8b,0x92,0x97,0x9d,0xa1,0xa3,0xa0,0x9d,0x91,0x82,
0x72,0x67,0x5d,0x55,0x50,0x4a,0x43,0x3e,0x3c,0x3b,0x48,0x57,0x6b,0x7e,0x8b,0x91,
0x96,0x97,0x98,0x9d,0xa3,0xa8,0xa6,0x9d,0x8d,0x7b,0x69,0x5d,0x58,0x5b,0x65,0x70,
0x79,0x7c,0x77,0x6f,0x66,0x60,0x5d,0x58,0x50,0x45,0x39,0x31,0x32,0x3c,0x4e,0x66,
0x7b,0x89,0x8e,0x90,0x91,0x94,0x9c,0x9e,0xa0,0xa3,0xa2,0x9e,0x9c,0x9d,0x9f,0xa4,
0xa5,0xa6,0xa2,0xa2,0x9e,0x9c,0x9c,0x9c,0x9c,0x9d,0x9d,0x9c,0x9c,0x9c,0x9b,0x9b,
0x9b,0x9c,0x9a,0x94,0x89,0x79,0x68,0x5a,0x54,0x5b,0x66,0x71,0x78,0x79,0x77,0x72,
0x69,0x61,0x5c,0x58,0x4e,0x42,0x35,0x2f,0x2f,0x3e,0x52,0x68,0x7c,0x8e,0x9a,0xa0,
0x99,0x8e,0x84,0x78,0x6c,0x62,0x55,0x49,0x40,0x39,0x33,0x35,0x3f,0x53,0x69,0x7a,
0x81,0x7e,0x74,0x67,0x5b,0x56,0x53,0x4e,0x46,0x3b,0x31,0x33,0x3f,0x56,0x6f,0x81,
0x85,0x7c,0x6c,0x5f,0x58,0x5d,0x69,0x75,0x7e,0x80,0x79,0x72,0x67,0x62,0x65,0x69,
0x6e,0x6e,0x70,0x72,0x75,0x7d,0x89,0x96,0x9f,0x9d,0x8f,0x78,0x61,0x53,0x50,0x58,
0x65,0x74,0x79,0x77,0x6e,0x65,0x5f,0x5c,0x58,0x52,0x46,0x3a,0x31,0x32,0x40,0x53,
0x67,0x7a,0x85,0x8a,0x8f,0x93,0x99,0x9d,0xa0,0x9f,0x9d,0x9c,0x9c,0x9e,0xa0,0x9f,
0x99,0x90,0x82,0x74,0x68,0x5b,0x4f,0x47,0x3f,0x3a,0x35,0x3b,0x45,0x56,0x68,0x79,
0x86,0x92,0x98,0x99,0x95,0x8c,0x7e,0x70,0x64,0x58,0x4d,0x43,0x3c,0x3a,0x3b,0x40,
0x4a,0x5b,0x6d,0x7c,0x87,0x90,0x95,0x97,0x92,0x8b,0x7e,0x6e,0x5d,0x51,0x47,0x43,
0x40,0x3d,0x39,0x35,0x33,0x35,0x3a,0x41,0x42,0x3f,0x39,0x32,0x32,0x3b,0x4d,0x62,
0x75,0x7e,0x7a,0x6e,0x5f,0x55,0x51,0x50,0x4d,0x46,0x3d,0x35,0x2f,0x30,0x34,0x3c,
0x41,0x41,0x3c,0x37,0x34,0x34,0x35,0x36,0x34,0x32,0x33,0x35,0x36,0x3a,0x38,0x34,
0x31,0x2f,0x2f,0x33,0x38,0x3b,0x3c,0x38,0x33,0x32,0x3b,0x4c,0x61,0x73,0x7b,0x7a,
0x72,0x69,0x60,0x5b,0x56,0x4f,0x45,0x38,0x2f,0x35,0x44,0x5c,0x73,0x83,0x84,0x79,
0x6a,0x5d,0x56,0x53,0x4d,0x43,0x39,0x32,0x36,0x43,0x59,0x6f,0x80,0x85,0x7a,0x69,
0x59,0x4f,0x4a,0x4a,0x46,0x3f,0x36,0x2d,0x27,0x28,0x2e,0x38,0x45,0x53,0x5f,0x6a,
0x70,0x70,0x69,0x62,0x5b,0x58,0x56,0x52,0x48,0x3c,0x32,0x30,0x3e,0x56,0x70,0x84,
0x88,0x7e,0x6c,0x5d,0x58,0x5d,0x68,0x74,0x79,0x79,0x72,0x6a,0x63,0x5f,0x5b,0x57,
0x4f,0x46,0x3c,0x32,0x2c,0x2d,0x2e,0x32,0x38,0x44,0x54,0x65,0x73,0x78,0x75,0x6c,
0x62,0x5b,0x58,0x54,0x50,0x47,0x3c,0x30,0x2d,0x37,0x4e,0x66,0x81,0x90,0x96,0x97,
0x96,0x96,0x9b,0x9f,0xa0,0xa2,0x9d,0x9a,0x98,0x99,0x9a,0x9d,0xa0,0xa2,0x9e,0x9c,
0x95,0x89,0x7a,0x68,0x5b,0x51,0x47,0x41,0x3e,0x3a,0x35,0x30,0x2c,0x2e,0x34,0x39,
0x39,0x36,0x32,0x30,0x2f,0x32,0x33,0x35,0x37,0x36,0x35,0x36,0x37,0x39,0x39,0x38,
0x35,0x32,0x32,0x35,0x37,0x3a,0x3a,0x3a,0x38,0x37,0x34,0x35,0x38,0x3b,0x3c,0x3a,
0x35,0x33,0x32,0x37,0x45,0x58,0x6e,0x7a,0x7b,0x72,0x64,0x5a,0x56,0x5d,0x6a,0x76,
0x7c,0x7a,0x6f,0x63,0x5d,0x5c,0x5e,0x5f,0x59,0x4b,0x38,0x2d,0x2e,0x3e,0x58,0x71,
0x82,0x85,0x7a,0x67,0x57,0x51,0x56,0x62,0x6f,0x78,0x7a,0x75,0x6d,0x65,0x62,0x64,
0x68,0x6d,0x6e,0x6c,0x6d,0x73,0x7f,0x8e,0x98,0x9c,0x97,0x89,0x74,0x61,0x50,0x46,
0x3e,0x3a,0x36,0x35,0x3c,0x46,0x54,0x67,0x77,0x84,0x8e,0x93,0x92,0x90,0x8b,0x80,
0x73,0x67,0x5a,0x49,0x3f,0x37,0x36,0x3a,0x41,0x4d,0x5b,0x69,0x76,0x84,0x8c,0x92,
0x96,0x96,0x90,0x85,0x76,0x67,0x5a,0x59,0x5e,0x6a,0x76,0x7d,0x7d,0x77,0x6d,0x61,
0x5e,0x61,0x67,0x6d,0x70,0x73,0x79,0x83,0x91,0x9c,0x9f,0x99,0x8a,0x77,0x61,0x51,
0x4d,0x52,0x5c,0x6a,0x78,0x84,0x8f,0x97,0x9a,0x9d,0xa1,0xa5,0xa6,0xa2,0x98,0x8c,
0x7e,0x70,0x63,0x5d,0x5e,0x63,0x6b,0x71,0x76,0x7f,0x88,0x91,0x97,0x98,0x92,0x84,
0x70,0x5e,0x4e,0x45,0x40,0x3e,0x3d,0x3c,0x3a,0x3a,0x38,0x37,0x3b,0x40,0x45,0x4f,
0x5d,0x6e,0x7d,0x88,0x90,0x97,0x9d,0xa0,0xa2,0xa3,0xa0,0x9a,0x8d,0x7c,0x6c,0x62,
0x5d,0x5e,0x63,0x6a,0x72,0x7a,0x80,0x88,0x91,0x99,0x9a,0x8f,0x82,0x70,0x5e,0x51,
0x44,0x3c,0x3b,0x37,0x36,0x3d,0x4b,0x5e,0x6e,0x7c,0x7d,0x77,0x6c,0x61,0x5b,0x5c,
0x62,0x6c,0x72,0x76,0x79,0x80,0x8a,0x94,0x9f,0xa7,0xa9,0xa6,0x9d,0x97,0x96,0x97,
0x99,0x9a,0x9c,0x9d,0x9e,0x9e,0x97,0x8e,0x80,0x71,0x60,0x52,0x48,0x44,0x40,0x3f,
0x39,0x35,0x34,0x34,0x32,0x38,0x3a,0x3f,0x46,0x51,0x5d,0x6c,0x7a,0x85,0x8e,0x95,
0x9a,0xa0,0xa3,0xa4,0xa0,0x97,0x88,0x78,0x68,0x5d,0x58,0x5e,0x67,0x70,0x77,0x78,
0x73,0x6d,0x66,0x62,0x5f,0x5e,0x56,0x4d,0x3f,0x35,0x32,0x40,0x53,0x68,0x7c,0x89,
0x8c,0x8d,0x8e,0x93,0x9a,0xa2,0xa8,0xa6,0x9e,0x98,0x97,0x9b,0x9f,0x9c,0x91,0x7f,
0x6a,0x5c,0x54,0x58,0x62,0x70,0x78,0x79,0x74,0x6d,0x67,0x62,0x5d,0x58,0x4f,0x42,
0x36,0x31,0x33,0x3d,0x52,0x6a,0x7e,0x8c,0x93,0x94,0x94,0x97,0x9b